<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.5//EN' 'http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd'>
<book>
  
  
  
  
  

<title>Real World OCaml</title>
<xi:include href="bookinfo.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
<xi:include href="ch00.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>

























<preface id="prologue">
  <title>Prologue</title>
  <sect1 id="why-ocaml">
    <title>Why OCaml?</title>
    <para>
      The programming languages that you use affect the software you
      create. They influence your software's reliability, security and
      efficiency, and how easy it is to read, refactor, and extend. The
      languages you know can also deeply affect how you think about
      programming and software design.
    </para>
    <para>
      But not all ideas about how to design a programming language are
      created equal. Over the last 40 years, a few key language features
      have emerged that together form a kind of sweet-spot in language
      design. These features include:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis>Garbage collection</emphasis> for automatic memory
          management, now a feature of almost every modern high-level
          language.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>First-class functions</emphasis> that can be passed
          around like ordinary values, as seen in JavaScript and C#.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Static type-checking</emphasis> to increase
          performance and reduce the number of runtime errors, as found
          in Java and C#.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Parametric polymorphism</emphasis>, which enables
          the construction of abstractions that work across different
          datatypes, similar to generics in Java and C# and templates in
          C++.
        </para>
      </listitem>
      <listitem>
        <para>
          Good support for <emphasis>immutable programming</emphasis>,
          <emphasis>i.e.</emphasis>, programming without making
          destructive updates to data-structures. This is present in
          traditional functional languages like Scheme, and is also
          found in distributed big data frameworks like Hadoop.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Automatic type inference</emphasis> to avoid having
          to laboriously define the type of every single variable in a
          program and instead have them inferred based on how a value is
          used. Available in C# with implicitly typed local variables
          and in a limited form in C++11 with its
          <literal>auto</literal> keyword.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Algebraic datatypes</emphasis> and <emphasis>pattern
          matching</emphasis> to define and manipulate complex data
          structures. Available in Scala and F#.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Some of you will know and love these features, and others will be
      completely new to them. Most of you will have seen
      <emphasis>some</emphasis> of them in other languages that you've
      used. As we'll demonstrate over the course of this book, there is
      something transformative about having them all together and able
      to interact in a single language. Despite their importance, these
      ideas have made only limited inroads into mainstream languages and
      when they do arrive there, like higher-order functions in C# or
      parametric polymorphism in Java, it's typically in a limited and
      awkward form. The only languages that completely embody these
      ideas are <emphasis>statically-typed functional programming
      languages</emphasis> like OCaml, F#, Haskell, Scala and Standard
      ML.
    </para>
    <para>
      Among this worthy set of languages, OCaml stands apart because it
      manages to provide a great deal of power while remaining highly
      pragmatic. The compiler has a straightforward compilation strategy
      that produces performant code without requiring heavy optimization
      and without the complexities of dynamic JIT compilation. This,
      along with OCaml's strict evaluation model, makes runtime behavior
      easy to predict. The garbage collector is
      <emphasis>incremental</emphasis>, letting you avoid large
      GC-related pauses, and <emphasis>precise</emphasis>, meaning it
      will collect all unreferenced data (unlike many reference-counting
      collectors), and the runtime is simple and highly portable.
    </para>
    <para>
      All of this makes OCaml a great choice for programmers who want to
      step up to a better programming language, and at the same time get
      practical work done.
    </para>
    <sect2 id="a-brief-history-from-the-1960s">
      <title>A brief history from the 1960s</title>
      <para>
        OCaml was written in 1996 by Xavier Leroy, Jérôme Vouillon,
        Damien Doligez and Didier Rémy at INRIA in France. It was
        inspired by a long line of research into ML starting in the
        1960s, and continues to have deep links to the academic
        community.
      </para>
      <para>
        ML was originally the <emphasis>meta language</emphasis> of the
        LCF proof assistant released by Robin Milner in 1972 (at
        Stanford, and later at Cambridge). ML was turned into a compiler
        in order to make it easier to use LCF on different machines, and
        gradually turned into a fully fledged system of its own by the
        1980s.
      </para>
      <para>
        The first implementation of Caml appeared in 1987, initially
        created by Ascander Saurez and later continued by Pierre Weis
        and Michel Mauny. In 1990, Xavier Leroy and Damien Doligez built
        a new implementation called Caml Light that was based on a
        bytecode interpreter with a fast sequential garbage collector.
        Over the next few years useful libraries appeared, such as
        Michel Mauny's syntax manipulation tools, and this helped
        promote the use of Caml in education and research teams.
      </para>
      <para>
        Xavier Leroy continued extending Caml Light with new features,
        which resulted in the 1995 release of Caml Special Light. This
        improved the executable efficiency significantly by adding a
        fast native code compiler that made Caml's performance
        competitive with mainstream languages such as C++. A module
        system inspired by Standard ML also provided powerful facilities
        for abstraction and made larger-scale programs easier to
        construct.
      </para>
      <para>
        The modern OCaml emerged in 1996, when a powerful and elegant
        object system was implemented by Didier Rémy and Jérôme
        Vouillon. This object system was notable for supporting many
        common OO idioms in a statically type-safe way, whereas the same
        idioms required runtime checks in languages such as C++ or Java.
        In 2000, Jacques Garrigue extended OCaml with several new
        features such as polymorphic methods and variants and labeled
        and optional arguments.
      </para>
      <para>
        The last decade has seen OCaml attract a significant user base.
        Language improvements have been steadily added to support the
        growing commercial and academic codebases written in OCaml.
        First-class modules, Generalized Algebraic Data Types (GADTs)
        and dynamic linking have improved the flexibility of the
        language and there is fast native code support for x86_64, ARM,
        PowerPC, and Sparc, making OCaml a good choice for systems where
        resource usage, predictability, and performance all matter.
      </para>
    </sect2>
    <sect2 id="the-core-standard-library">
      <title>The Core Standard Library</title>
      <para>
        A language on its own isn't enough. You also need a rich set of
        libraries to base your applications on. A common source of
        frustration for those learning OCaml is that the standard
        library that ships with the compiler is limited, covering only a
        small subset of the functionality you would expect from a
        general-purpose standard library. That's because the standard
        library isn't a general-purpose tool; it was developed for use
        in bootstrapping the compiler, and is purposefully kept small
        and simple.
      </para>
      <para>
        Happily, in the world of open-source software nothing stops
        alternative libraries from being written to supplement the
        compiler-supplied standard library, and this is exactly what the
        Core distribution is.
      </para>
      <para>
        Jane Street, a company that has been using OCaml for more than a
        decade, developed Core for its own internal use, but designed it
        from the start with an eye towards being a general-purpose
        standard library. Like the OCaml language itself, Core is
        engineered with correctness, reliability and performance in
        mind.
      </para>
      <para>
        Core is distributed with syntax extensions which provide useful
        new functionality to OCaml, and there are additional libraries
        such as the Async network communications library that extend the
        reach of Core into building complex distributed systems. All of
        these libraries are distributed under a liberal Apache 2 license
        to permit free use in hobby, academic and commercial settings.
      </para>
    </sect2>
    <sect2 id="the-ocaml-platform">
      <title>The OCaml Platform</title>
      <para>
        Core is a comprehensive and effective standard library, but
        there's much more OCaml software out there. A large community of
        programmers have been using OCaml since its first release in
        1996 and have generated many useful libraries and tools. We'll
        introduce some of these libraries in the course of the examples
        presented in the book.
      </para>
      <para>
        The installation and management of these third-party libraries
        is made much easier via a package management tool known as OPAM.
        We'll explain more about OPAM as the book unfolds, but it forms
        the basis of the Platform, which is a set of tools and libraries
        that, along with the OCaml compiler, let you build real-world
        applications quickly and effectively.
      </para>
      <para>
        We'll also use OPAM for installing the <literal>utop</literal>
        command-line interface. This is a modern interactive tool that
        supports command history, macro expansion, module completion,
        and other niceties that make it much more pleasant to work with
        the language. We'll be using <literal>utop</literal> throughout
        the book instead of the normal OCaml toplevel.
      </para>
    </sect2>
  </sect1>
  <sect1 id="about-this-book">
    <title>About this book</title>
    <para>
      Real World OCaml is aimed at programmers who have some experience
      with conventional programming languages, but not specifically with
      statically-typed functional programming. Depending on your
      background, many of the concepts we cover will be new, including
      traditional functional-programming techniques like higher-order
      functions and immutable data types, as well as aspects of OCaml's
      powerful type and module systems.
    </para>
    <para>
      If you've learned some OCaml before, this book may surprise you
      with some differences from your experience. Core redefines most of
      the standard modules to be much more consistent, so you'll need to
      adapt older code to work with Core. We believe the Core model is
      worth learning; it's been successfully used on large,
      multi-million-line codebases and removes a big barrier to building
      sophisticated applications in OCaml. Code that uses only the
      traditional compiler standard library will always exist, but there
      are other online resources to learn how that works. Real World
      OCaml focuses on the techniques the authors have used in their
      personal experience to construct scalable, robust software
      systems.
    </para>
    <sect2 id="what-to-expect">
      <title>What to expect</title>
      <para>
        Real World OCaml is split into three parts:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Part I covers the language itself, opening with a guided
            tour designed to provide a quick sketch of the language.
            Don't expect to understand everything in the tour; it's
            meant to give you a taste of many different aspects of the
            language, but the ideas covered there will be explained in
            more depth in the chapters that follow.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        After covering the core language, Part I then moves onto more
        advanced features like modules, functors and objects, which may
        take some time to digest. Understanding these concepts is
        important, though. These ideas will put you in good stead even
        beyond OCaml when switching to other modern languages, many of
        which have drawn inspiration from ML.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Part II builds on the basics by working through useful tools
            and techniques for addressing common practical applications,
            from command-line parsing to asynchronous network
            programming. Along the way, you'll see how some of the
            concepts from Part I are glued together into real libraries
            and tools that combine different features of the language to
            good effect.
          </para>
        </listitem>
        <listitem>
          <para>
            Part III discusses OCaml's runtime system and compiler
            toolchain. It is remarkably simple when compared to some
            other language implementations (such as Java's or .NET's
            CLR). Reading this part will enable you to build very high
            performance systems, or to interface with C libraries. This
            is also where we talk about profiling and debugging
            techniques using tools such as GNU <literal>gdb</literal>.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Real World OCaml uses some tools that we've developed while
        writing this book. Some of these resulted in improvements to the
        OCaml compiler, which means that you will need to ensure that
        you have an up-to-date development environment (using the 4.1
        version of the compiler). We've automated everything you need to
        do via the OPAM package manager, so please do follow the
        installation instructions in
        <xref linkend="installation"/> carefully.
      </para>
      <para>
        As of publication, the Windows operating system is unsupported
        by Core, and so only Mac OS X, Linux, FreeBSD and OpenBSD can be
        expected to work reliably. Please check the online installaton
        instructions for updates regarding Windows, or install a Linux
        virtual machine to work through the book as it stands.
      </para>
    </sect2>
  </sect1>
  <sect1 id="about-the-authors">
    <title>About the Authors</title>
    <sect2 id="yaron-minsky">
      <title>Yaron Minsky</title>
      <para>
        Yaron Minsky heads the Technology group at Jane Street, a
        proprietary trading firm that is the largest industrial user of
        OCaml. He was responsible for introducing OCaml to the company
        and for managing the company's transition to using OCaml for all
        of its core infrastructure. Today, billions of dollars worth of
        securities transactions flow each day through those systems.
      </para>
      <para>
        Yaron obtained his PhD in Computer Science from Cornell
        University, where he studied distributed systems. Yaron has
        lectured, blogged and written about OCaml for years, with
        articles published in Communications of the ACM and the Journal
        of Functional Programming. He chairs the steering committee of
        the Commercial Users of Functional Programming, and is a member
        of the steering committee for the International Conference on
        Functional Programming.
      </para>
    </sect2>
    <sect2 id="anil-madhavapeddy">
      <title>Anil Madhavapeddy</title>
      <para>
        Anil Madhavapeddy is a Senior Research Fellow at the University
        of Cambridge, based in the Systems Research Group. He was on the
        original team that developed the Xen hypervisor and helped
        develop an industry-leading cloud management toolstack written
        entirely in OCaml. This XenServer product has been deployed on
        millions of physical hosts, and drives critical infrastructure
        for many Fortune 500 companies.
      </para>
      <para>
        Prior to obtaining his PhD in 2006 from the University of
        Cambridge, Anil had a diverse background in industry at NetApp,
        NASA, and Internet Vision. He is an active member of the
        open-source development community with the OpenBSD operating
        system, is on the steering committee of the ACM Commercial Uses
        of Functional Programming workshop, and serves on the boards of
        startup companies where OCaml is extensively used. He has also
        developed the Mirage unikernel system that is written entirely
        in OCaml from the device drivers up.
      </para>
    </sect2>
    <sect2 id="jason-hickey">
      <title>Jason Hickey</title>
      <para>
        Jason Hickey is a Software Engineer at Google Inc. in Mountain
        View, California. He is part of the team that designs and
        develops the global computing infrastructure used to support
        Google services, including the software systems for managing and
        scheduling massively distributed computing resources.
      </para>
      <para>
        Prior to joining Google, Jason was an Assistant Professor of
        Computer Science at Caltech, where he researched reliable and
        fault-tolerant computing systems, including programming language
        design, formal methods, compilers, and new models of distributed
        computation. He obtained his PhD in Computer Science from
        Cornell University, where he studied programming languages. He
        is the author of the MetaPRL system, a logical framework for
        design and analysis of large software systems; and OMake, an
        advanced build system for large software projects. He is the
        author of the textbook, <emphasis>An Introduction to Objective
        Caml</emphasis> (unpublished).
      </para>
    </sect2>
  </sect1>
</preface><part label="I"><title>Language Concepts</title><partintro><para>Part I covers the basic language concepts you'll need to know when building OCaml programs.
      You won't need to memorise all of this (objects, for example, are used rarely in practice)
      but understanding the concepts and examples is important.</para><para>This part opens up with a guided tour to give you a quick overview of the language using
      an interactive command-line interface. It then moves onto covering language features such 
      as records, algebraic data types and the module system.</para><para>The final portion covers more advanced features such as functors, objects and first-class 
      modules, which may all take some time to digest. Persevere though; even though these concepts 
      may be difficult at first, they will put you in good stead even when switching to other 
      languages, many of which have drawn inspiration from ML.</para></partintro><chapter id="a-guided-tour">
  <title>A Guided Tour</title>
  <para>
    This chapter gives an overview of OCaml by walking through a series
    of small examples that cover most of the major features of the
    language. This should provide a sense of what OCaml can do, without
    getting too deep into any one topic.
  </para>
  <para>
    Throughout the book we're going to use Core, a more full-featured
    and capable replacement for OCaml's standard library. We'll also use
    <literal>utop</literal>, a shell that lets you type in expressions
    and evaluate them interactively. <literal>utop</literal> is an
    easier-to-use version of OCaml's standard toplevel (which you can
    start by typing <literal>ocaml</literal> at the command line). These
    instructions will assume you're using <literal>utop</literal>
    specifically.
  </para>
  <para>
    Before getting started, make sure you have a working OCaml
    installation and toplevel so you can try out the examples as you
    read through the chapter. Look at
    <xref linkend="installation"/> for details.
  </para>
  <sect1 id="ocaml-as-a-calculator">
    <title>OCaml as a calculator</title>
    <para>
      The first thing you need to do when using Core is to open
      <literal>Core.Std</literal>.
    </para>
    <programlisting language="ocaml">
# script guided-tour/main.topscript
$ utop
# open Core.Std;; 
</programlisting>
    <para>
      This makes the definitions in Core available, and is required for
      many of the examples in the tour and in the remainder of the book.
    </para>
    <para>
      Now let's try a few simple numerical calculations.
    </para>
    <programlisting language="ocaml">
<lineannotation>Part 1 of guided-tour/main.topscript</lineannotation>
<prompt># </prompt><userinput>3 + 4;;</userinput>
<computeroutput>- : int = 7</computeroutput>
<prompt># </prompt><userinput>8 / 3;;</userinput>
<computeroutput>- : int = 2</computeroutput>
# 3.5 +. 6.;; 
- : float = 9.5
# 30_000_000 / 300_000;; 
- : int = 100
# sqrt 9.;; 
- : float = 3.
</programlisting>
    <para>
      By and large, this is pretty similar to what you'd find in any
      programming language, but there are a few things that jump right
      out at you.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          We needed to type <literal>;;</literal> in order to tell the
          toplevel that it should evaluate an expression. This is a
          peculiarity of the toplevel that is not required in standalone
          programs (though it is sometimes helpful to include
          <literal>;;</literal> to improve OCaml's error reporting).
        </para>
      </listitem>
      <listitem>
        <para>
          After evaluating an expression, the toplevel prints first the
          result and then the type of the result.
        </para>
      </listitem>
      <listitem>
        <para>
          Function arguments are separated by spaces instead of by
          parentheses and commas, which is more like the UNIX shell than
          it is like traditional programming languages like C or Java.
        </para>
      </listitem>
      <listitem>
        <para>
          OCaml allows you to place underscores in the middle of your
          integer literals, to improve readability. Note that
          underscores can be placed anywhere within a number, not just
          every three digits.
        </para>
      </listitem>
      <listitem>
        <para>
          OCaml carefully distinguishes between
          <literal>float</literal>, the type for floating point numbers
          and <literal>int</literal>, the type for integers. The types
          have different literals (<literal>6.</literal> instead of
          <literal>6</literal>) and different infix operators
          (<literal>+.</literal> instead of <literal>+</literal>), and
          OCaml doesn't automatically cast between these types. This can
          be a bit of a nuisance, but it has its benefits, since it
          prevents some kinds of bugs that arise in other languages due
          to unexpected differences between the behavior of
          <literal>int</literal> and <literal>float</literal>. For
          example, in many languages, <literal>1 / 3</literal> is
          <literal>0</literal>, but <literal>1 / 3.0</literal> is a
          third. OCaml requires you to be explicit about which operation
          you're doing.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We can also create a variable to name the value of a given
      expression, using the <literal>let</literal> keyword. This is
      known as a <emphasis>let binding</emphasis>.
    </para>
    <programlisting language="ocaml">
...part 2 of guided-tour/main.topscript
# let x = 3 + 4;; 
val x : int = 7
# let y = x + x;; 
val y : int = 14
</programlisting>
    <para>
      After a new variable is created, the toplevel tells us the name of
      the variable (<literal>x</literal> or <literal>y</literal>), in
      addition to its type (<literal>int</literal>) and value
      (<literal>7</literal> or <literal>14</literal>).
    </para>
    <para>
      Note that there are some constraints on what identifiers can be
      used for variable names. Punctuation is excluded, except for
      <literal>_</literal> and <literal>'</literal>, and variables must
      start with a lowercase letter or an underscore. Thus, these are
      legal:
    </para>
    <programlisting language="ocaml">
...part 3 of guided-tour/main.topscript
# let x7 = 3 + 4;; 
val x7 : int = 7
# let x_plus_y = x + y;; 
val x_plus_y : int = 21
# let x' = x + 1;; 
val x' : int = 8
# let _x' = x' + x';; 
# _x';; 
- : int = 16
</programlisting>
    <para>
      Note that by default, <literal>utop</literal> doesn't bother to
      print out variables starting with an underscore.
    </para>
    <para>
      The following examples, however, are not legal.
    </para>
    <programlisting language="ocaml">
...part 4 of guided-tour/main.topscript
# let Seven = 3 + 4;; 
Characters 4-9:
Error: Unbound constructor Seven
# let 7x = 7;; 
Characters 5-10:
Error: This expression should not be a function, the expected type is
int
# let x-plus-y = x + y;; 
</programlisting>
    <para>
      The error messages here are a little confusing, but they'll make
      more sense as you learn more about the language.
    </para>
  </sect1>
  <sect1 id="functions-and-type-inference">
    <title>Functions and type inference</title>
    <para>
      The <literal>let</literal> syntax can also be used to define a
      function.
    </para>
    <programlisting language="ocaml">
...part 5 of guided-tour/main.topscript
# let square x = x * x ;; 
val square : int -&gt; int = &lt;fun&gt;
# square 2;; 
- : int = 4
# square (square 2);; 
- : int = 16
</programlisting>
    <para>
      Functions in OCaml are values like any other, which is why we use
      the <literal>let</literal> keyword to bind a function to a
      variable name, just as we use <literal>let</literal> to bind a
      simple value like an integer to a variable name. When using
      <literal>let</literal> to define a function, the first identifier
      after the <literal>let</literal> is the function name, and each
      subsequent identifier is a different argument to the function.
      Thus, <literal>square</literal> is a function with a single
      argument.
    </para>
    <para>
      Now that we're creating more interesting values like functions,
      the types have gotten more interesting too.
      <literal>int -&gt; int</literal> is a function type, in this case
      indicating a function that takes an <literal>int</literal> and
      returns an <literal>int</literal>. We can also write functions
      that take multiple arguments. (Note that the following example
      will not work if you haven't opened <literal>Core.Std</literal> as
      was suggested earlier.)
    </para>
    <programlisting language="ocaml">
...part 6 of guided-tour/main.topscript
# let ratio x y =
     Float.of_int x /. Float.of_int y
  ;; 
val ratio : int -&gt; int -&gt; float = &lt;fun&gt;
# ratio 4 7;; 
- : float = 0.571428571429
</programlisting>
    <para>
      The above also happens to be our first use of modules. Here,
      <literal>Float.of_int</literal> refers to the
      <literal>of_int</literal> function contained in the
      <literal>Float</literal> module. This is different from what you
      might expect from an object-oriented language, where dot-notation
      is typically used for accessing a method of an object. Note that
      module names always start with a capital letter.
    </para>
    <para>
      The notation for the type-signature of a multi-argument function
      may be a little surprising at first, but we'll explain where it
      comes from when we get to function currying in
      <xref linkend="multi-argument-functions"/>. For the
      moment, think of the arrows as separating different arguments of
      the function, with the type after the final arrow being the return
      value. Thus, <literal>int -&gt; int -&gt; float</literal>
      describes a function that takes two <literal>int</literal>
      arguments and returns a <literal>float</literal>.
    </para>
    <para>
      We can also write functions that take other functions as
      arguments. Here's an example of a function that takes three
      arguments: a test function and two integer arguments. The function
      returns the sum of the integers that pass the test.
    </para>
    <programlisting language="ocaml">
...part 7 of guided-tour/main.topscript
# let sum_if_true test first second =
    (if test first then first else 0)
    + (if test second then second else 0)
  ;; 
val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      If we look at the inferred type signature in detail, we see that
      the first argument is a function that takes an integer and returns
      a boolean, and that the remaining two arguments are integers.
      Here's an example of this function in action.
    </para>
    <programlisting language="ocaml">
...part 8 of guided-tour/main.topscript
# let even x =
    x mod 2 = 0 ;; 
val even : int -&gt; bool = &lt;fun&gt;
# sum_if_true even 3 4;; 
- : int = 4
# sum_if_true even 2 4;; 
- : int = 6
</programlisting>
    <para>
      Note that in the definition of <literal>even</literal> we used
      <literal>=</literal> in two different ways: once as the part of
      the let binding that separates the thing being defined from its
      definition; and once as an equality test, when comparing
      <literal>x mod 2</literal> to <literal>0</literal>. These are very
      different operations despite the fact that they share some syntax.
    </para>
    <sect2 id="type-inference">
      <title>Type inference</title>
      <para>
        As the types we encounter get more complicated, you might ask
        yourself how OCaml is able to figure them out, given that we
        didn't write down any explicit type information.
      </para>
      <para>
        OCaml determines the type of an expression using a technique
        called <emphasis>type inference</emphasis>, by which it infers
        the type of a given expression from the information it has about
        the types of variables along with constraints that are implied
        by the structure of the expression.
      </para>
      <para>
        As an example, let's walk through the process of inferring the
        type of <literal>sum_if_true</literal>.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            OCaml requires that both branches of an
            <literal>if</literal> statement have the same type, so the
            expression
            <literal>if test first then first else 0</literal> requires
            that <literal>first</literal> must be the same type as
            <literal>0</literal>, and so <literal>first</literal> must
            be of type <literal>int</literal>. Similarly, from
            <literal>if test second then second else 0</literal> we can
            infer that <literal>second</literal> has type
            <literal>int</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>test</literal> is passed <literal>first</literal>
            as an argument. Since <literal>first</literal> has type
            <literal>int</literal>, the input type of
            <literal>test</literal> must be <literal>int</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>test first</literal> is used as the condition in an
            <literal>if</literal> statement, so the return type of
            <literal>test</literal> must be <literal>bool</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            The fact that <literal>+</literal> returns
            <literal>int</literal> implies that the return value of
            <literal>sum_if_true</literal> must be int.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Together, that nails down the types of all the variables, which
        determines the overall type of <literal>sum_if_true</literal>.
      </para>
      <para>
        Over time, you'll build a rough intuition for how the OCaml
        inference engine works, which makes it easier to reason through
        your programs. You can make it easier to understand the types of
        a given expression by adding explicit type annotations. These
        annotations don't change the behavior of an OCaml program, but
        they can serve as useful documentation, as well as catch
        unintended type changes. They can also be helpful in figuring
        out why a given piece of code fails to compile.
      </para>
      <para>
        Here's an annotated version of <literal>sum_if_true</literal>:
      </para>
      <programlisting language="ocaml">
...part 9 of guided-tour/main.topscript
# let sum_if_true (test : int -&gt; bool) (x : int) (y : int) : int =
     (if test x then x else 0)
     + (if test y then y else 0)
  ;; 
val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        In the above, we've marked every argument to the function with
        its type, with the final annotation indicating the type of the
        return value. Such type annotations can be placed on any
        expression in an OCaml program.
      </para>
    </sect2>
    <sect2 id="inferring-generic-types">
      <title>Inferring generic types</title>
      <para>
        Sometimes, there isn't enough information to fully determine the
        concrete type of a given value. Consider this function:
      </para>
      <programlisting language="ocaml">
...part 10 of guided-tour/main.topscript
# let first_if_true test x y =
    if test x then x else y
  ;; 
val first_if_true : ('a -&gt; bool) -&gt; 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
</programlisting>
      <para>
        <literal>first_if_true</literal> takes as its arguments a
        function <literal>test</literal>, and two values,
        <literal>x</literal> and <literal>y</literal>, where
        <literal>x</literal> is to be returned if
        <literal>test x</literal> evaluates to <literal>true</literal>,
        and <literal>y</literal> otherwise. So what's the type of
        <literal>first_if_true</literal>? There are no obvious clues
        such as arithmetic operators or literals to tell you what the
        type of <literal>x</literal> and <literal>y</literal> are. That
        makes it seem like one could use
        <literal>first_if_true</literal> on values of any type.
      </para>
      <para>
        Indeed, if we look at the type returned by the toplevel, we see
        that rather than choose a single concrete type, OCaml has
        introduced a <emphasis>type variable</emphasis>
        <literal>'a</literal> to express that the type is generic. (You
        can tell it's a type variable by the leading single-quote.) In
        particular, the type of the <literal>test</literal> argument is
        <literal>('a -&gt; bool)</literal>, which means that test is a
        one-argument function whose return value is
        <literal>bool</literal>, and whose argument could be of any type
        <literal>'a</literal>. But, whatever type <literal>'a</literal>
        is, it has to be the same as the type of the other two
        arguments, <literal>x</literal> and <literal>y</literal>, and of
        the return value of <literal>first_if_true</literal>. This kind
        of genericity is called <emphasis>parametric
        polymorphism</emphasis>, and is very similar to generics in C#
        and Java.
      </para>
      <para>
        The generic type of <literal>first_if_true</literal> allows us
        to write this.
      </para>
      <programlisting language="ocaml">
...part 11 of guided-tour/main.topscript
# let long_string s = String.length s &gt; 6;; 
val long_string : string -&gt; bool = &lt;fun&gt;
# first_if_true long_string &quot;short&quot; &quot;loooooong&quot;;; 
- : string = &quot;loooooong&quot;
</programlisting>
      <para>
        As well as this.
      </para>
      <programlisting language="ocaml">
...part 12 of guided-tour/main.topscript
# let big_number x = x &gt; 3;; 
val big_number : int -&gt; bool = &lt;fun&gt;
# first_if_true big_number 4 3;; 
- : int = 4
</programlisting>
      <para>
        Both <literal>long_string</literal> and
        <literal>big_number</literal> are functions, and each is passed
        to <literal>first_if_true</literal> with two other arguments of
        the appropriate type (strings in the first example, and integers
        in the second). But we can't mix and match two different
        concrete types for <literal>'a</literal> in the same use of
        <literal>first_if_true</literal>.
      </para>
      <programlisting language="ocaml">
...part 13 of guided-tour/main.topscript
# first_if_true big_number &quot;short&quot; &quot;loooooong&quot;;; 
Characters 25-32:
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
      <para>
        In this example, <literal>big_number</literal> requires that
        <literal>'a</literal> be instantiated as <literal>int</literal>,
        whereas <literal>&quot;short&quot;</literal> and
        <literal>&quot;loooooong&quot;</literal> require that
        <literal>'a</literal> be instantiated as
        <literal>string</literal>, and they can't both be right at the
        same time.
      </para>
      <note><title>
      Type errors vs exceptions
      </title>
      <para>
        There's a big difference in OCaml (and really in any compiled
        language) between errors that are caught at compile time and
        those that are caught at run time. It's better to catch errors
        as early as possible in the development process, and compilation
        time is best of all.
      </para>
      <para>
        Working in the toplevel somewhat obscures the difference between
        run time and compile time errors, but that difference is still
        there. Generally, type errors, like this one:
      </para>
      <programlisting language="ocaml">
...part 14 of guided-tour/main.topscript
# let add_potato x =
     x + &quot;potato&quot;;; 
Characters 28-36:
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
      <para>
        are compile-time errors (because <literal>+</literal> requires
        that both its arguments be of type <literal>int</literal>),
        whereas errors that can't be caught by the type system, like
        division by zero, lead to runtime exceptions.
      </para>
      <programlisting language="ocaml">
...part 15 of guided-tour/main.topscript
# let is_a_multiple x y =
     x mod y = 0 ;; 
val is_a_multiple : int -&gt; int -&gt; bool = &lt;fun&gt;
# is_a_multiple 8 2;; 
- : bool = true
# is_a_multiple 8 0;; 
Exception: Division_by_zero.
</programlisting>
      <para>
        The distinction here is that type errors will stop you whether
        or not the offending code is ever actually executed. Merely
        defining <literal>add_potato</literal> is an error, whereas
        <literal>is_a_multiple</literal> only fails when it's called,
        and then, only when it's called with an input that triggers the
        exception.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="tuples-lists-options-and-pattern-matching">
    <title>Tuples, lists, options and pattern matching</title>
    <sect2 id="tuples">
      <title>Tuples</title>
      <para>
        So far we've encountered a handful of basic types like
        <literal>int</literal>, <literal>float</literal> and
        <literal>string</literal> as well as function types like
        <literal>string -&gt; int</literal>. But we haven't yet talked
        about any data structures. We'll start by looking at a
        particularly simple data structure, the tuple. A tuple is an
        ordered collection of values that can each be of different type.
        You can create a tuple by joining values together with a comma.
      </para>
      <programlisting language="ocaml">
...part 16 of guided-tour/main.topscript
# let a_tuple = (3,&quot;three&quot;);; 
val a_tuple : int * string = (3, &quot;three&quot;)
# let another_tuple = (3,&quot;four&quot;,5.);; 
val another_tuple : int * string * float = (3, &quot;four&quot;, 5.)
</programlisting>
      <para>
        (For the mathematically inclined, the <literal>*</literal>
        character is used because the set of all pairs of type
        <literal>t * s</literal> corresponds to the Cartesian product of
        the set of elements of type <literal>t</literal> and the set of
        elements of type <literal>s</literal>.)
      </para>
      <para>
        You can extract the components of a tuple using OCaml's pattern
        matching syntax, as shown below.
      </para>
      <programlisting language="ocaml">
...part 17 of guided-tour/main.topscript
# let (x,y) = a_tuple;; 
val x : int = 3
val y : string = &quot;three&quot;
</programlisting>
      <para>
        Here, the <literal>(x,y)</literal> on the left-hand side of the
        <literal>let</literal> binding is the pattern. This pattern lets
        us mint the new variables <literal>x</literal> and
        <literal>y</literal>, each bound to different components of the
        value being matched, which can now be used in subsequent
        expressions.
      </para>
      <programlisting language="ocaml">
...part 18 of guided-tour/main.topscript
# x + String.length y;; 
- : int = 8
</programlisting>
      <para>
        Note that the same syntax is used both for constructing and for
        pattern matching on tuples.
      </para>
      <para>
        Pattern matching can also show up in function arguments. Here's
        a function for computing the distance between two points on the
        plane, where each point is represented as a pair of
        <literal>float</literal>s. The pattern matching syntax lets us
        get at the values we need with a minimum of fuss.
      </para>
      <programlisting language="ocaml">
...part 19 of guided-tour/main.topscript
# let distance (x1,y1) (x2,y2) =
    sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
  ;; 
val distance : float * float -&gt; float * float -&gt; float = &lt;fun&gt;
</programlisting>
      <para>
        The <literal>**</literal> operator used above is for raising a
        floating-point number to a power.
      </para>
      <para>
        This is just a first taste of pattern matching. Pattern matching
        is a pervasive tool in OCaml, and as you'll see, it has
        surprising power.
      </para>
    </sect2>
    <sect2 id="lists">
      <title>Lists</title>
      <para>
        Where tuples let you combine a fixed number of items,
        potentially of different types, lists let you hold any number of
        items of the same type. Consider the following example.
      </para>
      <programlisting language="ocaml">
...part 20 of guided-tour/main.topscript
# let languages = [&quot;OCaml&quot;;&quot;Perl&quot;;&quot;C&quot;];; 
val languages : string list = [&quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
      <para>
        Note that you can't mix elements of different types in the same
        list, unlike tuples.
      </para>
      <programlisting language="ocaml">
...part 21 of guided-tour/main.topscript
# let numbers = [3;&quot;four&quot;;5];; 
Characters 17-23:
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
      <sect3 id="the-list-module">
        <title>The <literal>List</literal> module</title>
        <para>
          Core comes with a <literal>List</literal> module that has a
          rich collection of functions for working with lists. We can
          access values from within a module by using dot-notation. For
          example, this is how we compute the length of a list.
        </para>
        <programlisting language="ocaml">
...part 22 of guided-tour/main.topscript
# List.length languages;; 
- : int = 3
</programlisting>
        <para>
          Here's something a little more complicated. We can compute the
          list of the lengths of each language as follows.
        </para>
        <programlisting language="ocaml">
...part 23 of guided-tour/main.topscript
# List.map languages ~f:String.length;; 
- : int list = [5; 4; 1]
</programlisting>
        <para>
          <literal>List.map</literal> takes two arguments: a list and a
          function for transforming the elements of that list. It
          returns a new list with the transformed elements, and does not
          modify the original list.
        </para>
        <para>
          Notably, the function passed to <literal>List.map</literal> is
          passed under a <emphasis>labeled argument</emphasis>
          <literal>~f</literal>. Labeled arguments are specified by name
          rather than by position, and thus allow you to change the
          order in which arguments are presented to a function without
          changing its behavior, as you can see here.
        </para>
        <programlisting language="ocaml">
...part 24 of guided-tour/main.topscript
# List.map ~f:String.length languages;; 
- : int list = [5; 4; 1]
</programlisting>
        <para>
          We'll learn more about labeled arguments and why they're
          important in
          <xref linkend="variables-and-functions"/>.
        </para>
      </sect3>
      <sect3 id="constructing-lists-with">
        <title>Constructing lists with <literal>::</literal></title>
        <para>
          In addition to constructing lists using brackets, we can use
          the operator <literal>::</literal> for adding elements to the
          front of a list.
        </para>
        <programlisting language="ocaml">
...part 25 of guided-tour/main.topscript
# &quot;French&quot; :: &quot;Spanish&quot; :: languages;; 
- : string list = [&quot;French&quot;; &quot;Spanish&quot;; &quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
        <para>
          Here, we're creating a new and extended list, not changing the
          list we started with, as you can see below.
        </para>
        <programlisting language="ocaml">
...part 26 of guided-tour/main.topscript
# languages;; 
- : string list = [&quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
        <note> <title> 
        Semicolons vs. commas
        </title>
        <para>
          Unlike many other languages, OCaml uses semicolons to separate
          list elements in lists rather than commas. Commas, instead,
          are used for separating elements in a tuple. If you try to use
          commas instead, you'll see that your code compiles, but
          doesn't do quite what you might expect.
        </para>
        <programlisting language="ocaml">
...part 27 of guided-tour/main.topscript
# [&quot;OCaml&quot;, &quot;Perl&quot;, &quot;C&quot;];; 
- : (string * string * string) list = [(&quot;OCaml&quot;, &quot;Perl&quot;, &quot;C&quot;)]
</programlisting>
        <para>
          In particular, rather than a list of three strings, what we
          have is a singleton list containing a three-tuple of strings.
        </para>
        <para>
          This example uncovers the fact that commas create a tuple,
          even if there are no surrounding parens. So, we can write:
        </para>
        <programlisting language="ocaml">
...part 28 of guided-tour/main.topscript
# 1,2,3;; 
- : int * int * int = (1, 2, 3)
</programlisting>
        <para>
          to allocate a tuple of integers. This is generally considered
          poor style and should be avoided.
        </para>
        </note>
        <para>
          The bracket notation for lists is really just syntactic sugar
          for <literal>::</literal>. Thus, the following declarations
          are all equivalent. Note that <literal>[]</literal> is used to
          represent the empty list, and that <literal>::</literal> is
          right-associative.
        </para>
        <programlisting language="ocaml">
...part 29 of guided-tour/main.topscript
# [1; 2; 3];; 
- : int list = [1; 2; 3]
# 1 :: (2 :: (3 :: []));; 
- : int list = [1; 2; 3]
# 1 :: 2 :: 3 :: [];; 
- : int list = [1; 2; 3]
</programlisting>
        <para>
          The <literal>::</literal> operator can only be used for adding
          one element to the front of the list, with the list
          terminating at <literal>[]</literal>, the empty list. There's
          also a list concatenation operator, <literal>@</literal>,
          which can concatenate two lists.
        </para>
        <programlisting language="ocaml">
...part 30 of guided-tour/main.topscript
# [1;2;3] @ [4;5;6];; 
- : int list = [1; 2; 3; 4; 5; 6]
</programlisting>
        <para>
          It's important to remember that, unlike <literal>::</literal>,
          this is not a constant-time operation. Concatenating two lists
          takes time proportional to the length of the first list.
        </para>
      </sect3>
      <sect3 id="list-patterns-using-match">
        <title>List patterns using <literal>match</literal></title>
        <para>
          The elements of a list can be accessed through pattern
          matching. List patterns are based on the two list
          constructors, <literal>[]</literal> and <literal>::</literal>.
          Here's a simple example.
        </para>
        <programlisting language="ocaml">
...part 31 of guided-tour/main.topscript
# let my_favorite_language (my_favorite :: the_rest) =
     my_favorite
  ;; 

Characters 25-69:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val my_favorite_language : 'a list -&gt; 'a = &lt;fun&gt;
</programlisting>
        <para>
          By pattern matching using <literal>::</literal>, we've
          isolated and named the first element of the list
          (<literal>my_favorite</literal>) and the remainder of the list
          (<literal>the_rest</literal>). If you know Lisp or Scheme,
          what we've done is the equivalent of using the functions
          <literal>car</literal> and <literal>cdr</literal> to isolate
          the first element of a list and the remainder of that list.
        </para>
        <para>
          As you can see, however, the toplevel did not like this
          definition, and spit out a warning indicating that the pattern
          is not exhaustive. This means that there are values of the
          type in question that won't be captured by the pattern. The
          warning even gives an example of a value that doesn't match
          the provided pattern, in particular, <literal>[]</literal>,
          the empty list. If we try to run
          <literal>my_favorite_language</literal>, we'll see that it
          works on non-empty list, and fails on empty ones.
        </para>
        <programlisting language="ocaml">
...part 32 of guided-tour/main.topscript
# my_favorite_language [&quot;English&quot;;&quot;Spanish&quot;;&quot;French&quot;];; 
- : string = &quot;English&quot;
# my_favorite_language [];; 
Exception: (Match_failure //toplevel// 0 25).
</programlisting>
        <para>
          You can avoid these warnings, and more importantly make sure
          that your code actually handles all of the possible cases, by
          using a <literal>match</literal> statement instead.
        </para>
        <para>
          A <literal>match</literal> statement is a kind of juiced-up
          version of the switch statement found in <literal>C</literal>
          and <literal>Java</literal>. It essentially lets you list a
          sequence of patterns (separated by <literal>|</literal>'s. The
          one before the first case is optional), and the compiler then
          dispatches to the code following the first matching pattern.
          As we've already seen, the pattern can mint new variables that
          correspond to sub-structures of the value being matched.
        </para>
        <para>
          Here's a new version of
          <literal>my_favorite_language</literal> that uses
          <literal>match</literal> and doesn't trigger a compiler
          warning.
        </para>
        <programlisting language="ocaml">
...part 33 of guided-tour/main.topscript
# let my_favorite_language languages =
    match languages with
    | first :: the_rest -&gt; first
    | [] -&gt; &quot;OCaml&quot; (* A good default! *)
 ;; 
val my_favorite_language : string list -&gt; string = &lt;fun&gt;
# my_favorite_language [&quot;English&quot;;&quot;Spanish&quot;;&quot;French&quot;];; 
- : string = &quot;English&quot;
# my_favorite_language [];; 
- : string = &quot;OCaml&quot;
</programlisting>
        <para>
          The above code also includes our first comment. OCaml comments
          are bounded by <literal>(*</literal> and
          <literal>*)</literal>, and can be nested arbitrarily and cover
          multiple lines. There's no equivalent of C++-style single line
          comments that are prefixed by <literal>//</literal>.
        </para>
        <para>
          The first pattern, <literal>first :: the_rest</literal>,
          covers the case where <literal>languages</literal> has at
          least one element, since every list except for the empty list
          can be written down with one or more <literal>::</literal>'s.
          The second pattern, <literal>[]</literal>, matches only the
          empty list. These cases are exhaustive, since every list is
          either empty, or has at least one element, a fact which is
          verified by the compiler.
        </para>
      </sect3>
      <sect3 id="recursive-list-functions">
        <title>Recursive list functions</title>
        <para>
          Recursive functions, or, functions that call themselves, are
          an important technique in OCaml and in any functional
          language. The typical approach to designing a recursive
          function is to separate the logic into a set of <emphasis>base
          cases</emphasis>, that can be solved directly, and a set of
          <emphasis>inductive cases</emphasis>, where the function
          breaks the problem down into smaller pieces and then calls
          itself to solve those smaller problems.
        </para>
        <para>
          When writing recursive list functions, this separation between
          the base cases and the inductive cases is often done using
          pattern matching. Here's a simple example of a function that
          sums the elements of a list.
        </para>
        <programlisting language="ocaml">
...part 34 of guided-tour/main.topscript
# let rec sum l =
    match l with
    | [] -&gt; 0                   (* base case *)
    | hd :: tl -&gt; hd + sum tl   (* inductive case *)
  ;; 
val sum : int list -&gt; int = &lt;fun&gt;
# sum [1;2;3];; 
- : int = 6
</programlisting>
        <para>
          Following the common OCaml idiom, we use <literal>hd</literal>
          to refer to the head of the list and <literal>tl</literal> to
          refer to the tail. Note that we had to use the
          <literal>rec</literal> keyword to allow <literal>sum</literal>
          to refer to itself. As you might imagine, the base case and
          inductive case are different arms of the match.
        </para>
        <para>
          Logically, you can think of the evaluation of a simple
          recursive function like <literal>sum</literal> almost as if it
          were a mathematical equation whose meaning you were unfolding
          step by step.
        </para>
        <programlisting language="ocaml">
sum [1;2;3]
= 1 + sum [2;3]
= 1 + (2 + sum [3])
= 1 + (2 + (3 + sum []))
= 1 + (2 + (3 + 0))
= 1 + (2 + 3)
= 1 + 5
= 6
</programlisting>
        <para>
          This suggests a reasonable mental model for what OCaml is
          actually doing to evaluate a recursive function.
        </para>
        <para>
          We can introduce more complicated list patterns as well.
          Here's a function for removing sequential duplicates.
        </para>
        <programlisting language="ocaml">
...part 35 of guided-tour/main.topscript
# let rec destutter list =
    match list with
    | [] -&gt; []
    | hd1 :: hd2 :: tl -&gt;
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl)
  ;; 

Characters 29-171:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::[]
val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</programlisting>
        <para>
          Again, the first arm of the match is the base case, and the
          second is the inductive. Unfortunately, this code has a
          problem, as is indicated by the warning message. In particular
          we don't handle one-element lists. We can fix this warning by
          adding another case to the match.
        </para>
        <programlisting language="ocaml">
...part 36 of guided-tour/main.topscript
# let rec destutter list =
    match list with
    | [] -&gt; []
    | [hd] -&gt; [hd]
    | hd1 :: hd2 :: tl -&gt;
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl)
  ;; 
val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
# destutter [&quot;hey&quot;;&quot;hey&quot;;&quot;hey&quot;;&quot;man!&quot;];; 
- : string list = [&quot;hey&quot;; &quot;man!&quot;]
</programlisting>
        <para>
          Note that this code used another variant of the list pattern,
          <literal>[hd]</literal>, to match a list with a single
          element. We can do this to match a list with any fixed number
          of elements, <emphasis>e.g.</emphasis>,
          <literal>[x;y;z]</literal> will match any list with exactly
          three elements, and will bind those elements to the variables
          <literal>x</literal>, <literal>y</literal> and
          <literal>z</literal>.
        </para>
        <para>
          In the last few examples, our list processing code involved a
          lot of recursive functions. In practice, this isn't usually
          necessary. Most of the time, you'll find yourself happy to use
          the iteration functions found in the <literal>List</literal>
          module. But it's good to know how to use recursion when you
          need to do something new.
        </para>
      </sect3>
    </sect2>
    <sect2 id="options">
      <title>Options</title>
      <para>
        Another common data structure in OCaml is the option. An option
        is used to express that a value might or might not be present.
        For example,
      </para>
      <programlisting language="ocaml">
...part 37 of guided-tour/main.topscript
# let divide x y =
    if y = 0 then None else Some (x/y) ;; 
val divide : int -&gt; int -&gt; int option = &lt;fun&gt;
</programlisting>
      <para>
        The function <literal>divide</literal> either returns
        <literal>None</literal>, if the divisor is zero, or
        <literal>Some</literal> of the result of the division,
        otherwise. <literal>Some</literal> and <literal>None</literal>
        are constructors, like <literal>::</literal> and
        <literal>[]</literal> for lists, which let you build optional
        values. You can think of an option as a specialized list that
        can only have zero or one element.
      </para>
      <para>
        To examine the contents of an option, we use pattern matching,
        as we did with tuples and lists. Consider the following function
        for creating a log entry string given an optional time and a
        message. If no time is provided (<emphasis>i.e.</emphasis>, if
        the time is <literal>None</literal>), the current time is
        computed and used in its place.
      </para>
      <programlisting language="ocaml">
...part 38 of guided-tour/main.topscript
# let log_entry maybe_time message =
    let time =
      match maybe_time with
      | Some x -&gt; x
      | None -&gt; Time.now ()
    in
    Time.to_sec_string time ^ &quot; -- &quot; ^ message
  ;; 
val log_entry : Time.t option -&gt; string -&gt; string = &lt;fun&gt;
# log_entry (Some Time.epoch) &quot;A long long time ago&quot;;; 
- : string = &quot;1970-01-01 01:00:00 -- A long long time ago&quot;
# log_entry None &quot;Up to the minute&quot;;; 
- : string = &quot;2013-08-11 22:03:26 -- Up to the minute&quot;
</programlisting>
      <para>
        This example uses Core's <literal>Time</literal> module for
        dealing with time as well as the <literal>^</literal> operator
        for concatenating strings. The concatenation operator is
        provided as part of the <literal>Pervasives</literal> module
        which is automatically opened in every OCaml program.
      </para>
      <note> <title> 
      Nesting <literal>let</literal>s with <literal>let</literal> and
      <literal>in</literal>
      </title>
      <para>
        <literal>log_entry</literal> was our first use of
        <literal>let</literal> to define a new variable within the body
        of a function. A <literal>let</literal> bounded with an
        <literal>in</literal> can be used to introduce a new binding
        within any local scope, including a function body. The
        <literal>in</literal> marks the beginning of the scope within
        which the new variable can be used. Thus, we could write:
      </para>
      <programlisting language="ocaml">
# script guided-tour/local_let.topscript
$ utop
# let x = 7 in
  x + x
  ;; 
- : int = 14
</programlisting>
      <para>
        Note that the scope of the let binding is terminated by the
        double-semicolon, so the value of <literal>x</literal> is no
        longer available.
      </para>
      <programlisting language="ocaml">
...part 1 of guided-tour/local_let.topscript
# x;; 
Characters -1-1:
Error: Unbound value x
</programlisting>
      <para>
        We can also have multiple let statements in a row, each one
        adding a new variable binding to what came before.
      </para>
      <programlisting language="ocaml">
...part 2 of guided-tour/local_let.topscript
# let x = 7 in
  let y = x * x in
  x + y
  ;; 
- : int = 56
</programlisting>
      <para>
        This kind of nested let binding is a common way of building up a
        complex expression, with each <literal>let</literal> naming some
        component, before combining them in one final expression.
      </para>
      </note>
      <para>
        Options are important because they are the standard way in OCaml
        to encode a value that might not be there; there's no such thing
        as a <literal>NullPointerException</literal> in OCaml. This is
        different from most other languages, including Java and C#,
        where most if not all datatypes are
        <emphasis>nullable</emphasis>, meaning that, whatever their type
        is, any given value also contains the possibility of being a
        null value. In such languages, null is lurking everywhere.
      </para>
      <para>
        In OCaml, however, missing values are explicit. A value of type
        <literal>string * string</literal> always actually contains two
        well-defined values of type <literal>string</literal>. If you
        want to allow, say, the first of those to be absent, then you
        need to change the type to
        <literal>string option * string</literal>. As we'll see in
        <xref linkend="error-handling"/>, this explicitness
        allows the compiler to provide a great deal of help in making
        sure you're correctly handing the possibility of missing data.
      </para>
    </sect2>
  </sect1>
  <sect1 id="records-and-variants">
    <title>Records and variants</title>
    <para>
      So far, we've only looked at data structures that were predefined
      in the language, like lists and tuples. But OCaml also allows us
      to define new datatypes. Here's a toy example of a datatype
      representing a point in 2-dimensional space:
    </para>
    <programlisting language="ocaml">
...part 41 of guided-tour/main.topscript
# type point2d = { x : float; y : float };; 
type point2d = { x : float; y : float; }
</programlisting>
    <para>
      <literal>point2d</literal> is a <emphasis>record</emphasis> type,
      which you can think of as a tuple where the individual fields are
      named, rather than being defined positionally. Record types are
      easy enough to construct:
    </para>
    <programlisting language="ocaml">
...part 42 of guided-tour/main.topscript
# let p = { x = 3.; y = -4. };; 
val p : point2d = {x = 3.; y = -4.}
</programlisting>
    <para>
      And we can get access to the contents of these types using pattern
      matching:
    </para>
    <programlisting language="ocaml">
...part 43 of guided-tour/main.topscript
# let magnitude { x = x_pos; y = y_pos } =
    sqrt (x_pos ** 2. +. y_pos ** 2.);; 
val magnitude : point2d -&gt; float = &lt;fun&gt;
</programlisting>
    <para>
      The pattern match here binds the variable <literal>x_pos</literal>
      to the value contained in the <literal>x</literal> field, and the
      variable <literal>y_pos</literal> to the value in the
      <literal>y</literal> field.
    </para>
    <para>
      We can write this more tersely using what's called <emphasis>field
      punning</emphasis>. In particular, when the name of the field and
      the name of the variable it is bound to in the match coincide, we
      don't have to write them both down. Using this, our magnitude
      function can be rewritten as follows.
    </para>
    <programlisting language="ocaml">
...part 44 of guided-tour/main.topscript
# let magnitude { x; y } = sqrt (x ** 2. +. y ** 2.);; 
val magnitude : point2d -&gt; float = &lt;fun&gt;
</programlisting>
    <para>
      We can also use dot-notation for accessing record fields:
    </para>
    <programlisting language="ocaml">
...part 45 of guided-tour/main.topscript
# let distance v1 v2 =
     magnitude { x = v1.x -. v2.x; y = v1.y -. v2.y };; 
val distance : point2d -&gt; point2d -&gt; float = &lt;fun&gt;
</programlisting>
    <para>
      And we can of course include our newly defined types as components
      in larger types. Here, for example, are some types for modeling
      different geometric objects that contain values of type
      <literal>point2d</literal>.
    </para>
    <programlisting language="ocaml">
...part 46 of guided-tour/main.topscript
# type circle_desc  = { center: point2d; radius: float }
  type rect_desc    = { lower_left: point2d; width: float; height: float }
  type segment_desc = { endpoint1: point2d; endpoint2: point2d } ;; 
type circle_desc = { center : point2d; radius : float; }
type rect_desc = { lower_left : point2d; width : float; height : float; }
type segment_desc = { endpoint1 : point2d; endpoint2 : point2d; }
</programlisting>
    <para>
      Now, imagine that you want to combine multiple objects of these
      types together as a description of a multi-object scene. You need
      some unified way of representing these objects together in a
      single type. One way of doing this is using a
      <emphasis>variant</emphasis> type:
    </para>
    <programlisting language="ocaml">
...part 47 of guided-tour/main.topscript
# type scene_element =
    | Circle  of circle_desc
    | Rect    of rect_desc
    | Segment of segment_desc
  ;; 
type scene_element =
    Circle of circle_desc
  | Rect of rect_desc
  | Segment of segment_desc
</programlisting>
    <para>
      The <literal>|</literal> character separates the different cases
      of the variant (the first <literal>|</literal> is optional), and
      each case has a capitalized tag, like <literal>Circle</literal>,
      <literal>Rect</literal> and <literal>Segment</literal>, to
      distinguish that case from the others.
    </para>
    <para>
      Here's how we might write a function for testing whether a point
      is in the interior of some element of a list of
      <literal>scene_element</literal>s.
    </para>
    <programlisting language="ocaml">
...part 48 of guided-tour/main.topscript
# let is_inside_scene_element point scene_element =
     match scene_element with
     | Circle { center; radius } -&gt;
       distance center point &lt; radius
     | Rect { lower_left; width; height } -&gt;
       point.x    &gt; lower_left.x &amp;&amp; point.x &lt; lower_left.x +. width
       &amp;&amp; point.y &gt; lower_left.y &amp;&amp; point.y &lt; lower_left.y +. height
     | Segment { endpoint1; endpoint2 } -&gt; false
  ;; 
val is_inside_scene_element : point2d -&gt; scene_element -&gt; bool = &lt;fun&gt;
# let is_inside_scene point scene =
     List.exists scene
       ~f:(fun el -&gt; is_inside_scene_element point el)
   ;; 
val is_inside_scene : point2d -&gt; scene_element list -&gt; bool = &lt;fun&gt;
# is_inside_scene {x=3.;y=7.}
    [ Circle {center = {x=4.;y= 4.}; radius = 0.5 } ];; 
- : bool = false
# is_inside_scene {x=3.;y=7.}
    [ Circle {center = {x=4.;y= 4.}; radius = 5.0 } ];; 
- : bool = true
</programlisting>
    <para>
      You might at this point notice that the use of
      <literal>match</literal> here is reminiscent of how we used
      <literal>match</literal> with <literal>option</literal> and
      <literal>list</literal>. This is no accident:
      <literal>option</literal> and <literal>list</literal> are really
      just examples of variant types that happen to be important enough
      to be defined in the standard library (and in the case of lists,
      to have some special syntax).
    </para>
    <para>
      We also made our first use of an <emphasis>anonymous
      function</emphasis> in the call to <literal>List.exists</literal>.
      Anonymous functions are declared using the <literal>fun</literal>
      keyword, and don't need to be explicitly named. Such functions are
      common in OCaml, particularly when using iteration functions like
      <literal>List.exists</literal>.
    </para>
    <para>
      The purpose of <literal>List.exists</literal> is to check if there
      are any elements of the list in question on which the provided
      function evaluates to <literal>true</literal>. In this case, we're
      using <literal>List.exists</literal> to check if there is a scene
      element within which our point resides.
    </para>
  </sect1>
  <sect1 id="imperative-programming">
    <title>Imperative programming</title>
    <para>
      The code we've written so far has been almost entirely
      <emphasis>pure</emphasis> or <emphasis>functional</emphasis>,
      which roughly speaking means that the code in question doesn't
      modify variables or values as part of its execution. Indeed,
      almost all of the data structures we've encountered are
      <emphasis>immutable</emphasis>, meaning there's no way in the
      language to modify them at all. This is a quite different style
      from <emphasis>imperative</emphasis> programming, where
      computations are structured as sequences of instructions that
      operate by making modifications to the state of the program.
    </para>
    <para>
      Functional code is the default in OCaml, with variable bindings
      and most data structures being immutable. But OCaml also has
      excellent support for imperative programming, including mutable
      data structures like arrays and hash tables, and control-flow
      constructs like for and while loops.
    </para>
    <sect2 id="arrays">
      <title>Arrays</title>
      <para>
        Perhaps the simplest mutable data structure in OCaml is the
        array. Arrays in OCaml are very similar to arrays in other
        languages like C: indexing starts at 0, and accessing or
        modifying an array element is a constant-time operation. Arrays
        are more compact in terms of memory utilization than most other
        data structures in OCaml, including lists. Here's an example:
      </para>
      <programlisting language="ocaml">
...part 49 of guided-tour/main.topscript
# let numbers = [| 1; 2; 3; 4 |];; 
val numbers : int array = [|1; 2; 3; 4|]
# numbers.(2) &lt;- 4;; 
- : unit = ()
# numbers;; 
- : int array = [|1; 2; 4; 4|]
</programlisting>
      <para>
        the <literal>.(i)</literal> syntax is used to refer to an
        element of an array, and the <literal>&lt;-</literal> syntax is
        for modification. Because the elements of the array are counted
        starting at zero, element <literal>.(2)</literal> is the third
        element.
      </para>
      <para>
        The <literal>unit</literal> type that we see above is
        interesting in that it has only one possible value, written
        <literal>()</literal>. This means that a value of type
        <literal>unit</literal> doesn't convey any information, and thus
        tends to be used as a placeholder. Thus, we use
        <literal>unit</literal> for the return value of an operation
        like setting a mutable field that communicates by side effect
        rather than by returning a value. It's also used as the argument
        to functions that don't require an input value. This is similar
        to the role that <literal>void</literal> plays in languages like
        C and Java.
      </para>
    </sect2>
    <sect2 id="mutable-record-fields">
      <title>Mutable record fields</title>
      <para>
        The array is an important mutable data structure, but it's not
        the only one. Records, which are immutable by default, can have
        some of their fields explicitly declared as mutable. Here's a
        small example of a data structure for storing a running
        statistical summary of a collection of numbers. Here's the basic
        data structure:
      </para>
      <programlisting language="ocaml">
...part 50 of guided-tour/main.topscript
# type running_sum =
   { mutable sum: float;
     mutable sum_sq: float; (* sum of squares *)
     mutable samples: int;
   }
  ;; 
type running_sum = {
  mutable sum : float;
  mutable sum_sq : float;
  mutable samples : int;
}
</programlisting>
      <para>
        The fields in <literal>running_sum</literal> are designed to be
        easy to extend incrementally, and sufficient to compute means
        and standard deviations, as shown below. Note that there are two
        let-bindings in a row without a double semicolon between them.
        That's because the double semicolon is required only to tell
        utop to process the input, not to separate two expressions.
      </para>
      <programlisting language="ocaml">
...part 51 of guided-tour/main.topscript
# let mean rsum = rsum.sum /. float rsum.samples
  let stdev rsum =
     sqrt (rsum.sum_sq /. float rsum.samples
           -. (rsum.sum /. float rsum.samples) ** 2.) ;; 
val mean : running_sum -&gt; float = &lt;fun&gt;
val stdev : running_sum -&gt; float = &lt;fun&gt;
</programlisting>
      <para>
        We use the function <literal>float</literal> above, which is a
        convenient equivalent of <literal>Float.of_int</literal> which
        is provided by the <literal>Pervasives</literal> library.
      </para>
      <para>
        We also need functions to create and update
        <literal>running_sum</literal>s:
      </para>
      <programlisting language="ocaml">
...part 52 of guided-tour/main.topscript
# let create () = { sum = 0.; sum_sq = 0.; samples = 0 }
  let update rsum x =
     rsum.samples &lt;- rsum.samples + 1;
     rsum.sum     &lt;- rsum.sum     +. x;
     rsum.sum_sq  &lt;- rsum.sum_sq  +. x *. x
  ;; 
val create : unit -&gt; running_sum = &lt;fun&gt;
val update : running_sum -&gt; float -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        <literal>create</literal> returns a
        <literal>running_sum</literal> corresponding to the empty set,
        and <literal>update rsum x</literal> changes
        <literal>rsum</literal> to reflect the addition of
        <literal>x</literal> to its set of samples, by updating the
        number of samples, the sum, and the sum of squares.
      </para>
      <para>
        Note the use in the above code of single semi-colons to sequence
        operations. When we were working purely functionally, this
        wasn't necessary, but you start needing it when you're writing
        imperative code.
      </para>
      <para>
        Here's an example of <literal>create</literal> and
        <literal>update</literal> in action. Note that this code uses
        <literal>List.iter</literal>, which calls the function
        <literal>~f</literal> on each element of the provided list.
      </para>
      <programlisting language="ocaml">
...part 53 of guided-tour/main.topscript
# let rsum = create ();; 
val rsum : running_sum = {sum = 0.; sum_sq = 0.; samples = 0}
# List.iter [1.;3.;2.;-7.;4.;5.] ~f:(fun x -&gt; update rsum x);; 
- : unit = ()
# mean rsum;; 
- : float = 1.33333333333
# stdev rsum;; 
- : float = 3.94405318873
</programlisting>
    </sect2>
    <sect2 id="refs">
      <title>Refs</title>
      <para>
        We can create a single mutable value by using a
        <literal>ref</literal>. The <literal>ref</literal> type comes
        pre-defined in the standard library, but there's nothing really
        special about it. It's just a record type with a single mutable
        field called <literal>contents</literal>.
      </para>
      <programlisting language="ocaml">
...part 54 of guided-tour/main.topscript
# let x = { contents = 0 };; 
val x : int ref = {contents = 0}
# x.contents &lt;- x.contents + 1;; 
- : unit = ()
# x;; 
- : int ref = {contents = 1}
</programlisting>
      <para>
        There are a handful of useful functions and operators defined
        for <literal>ref</literal>s to make them more convenient to work
        with.
      </para>
      <programlisting language="ocaml">
...part 55 of guided-tour/main.topscript
# let x = ref 0  (* create a ref, i.e., { contents = 0 } *) ;; 
val x : int ref = {contents = 0}
# !x             (* get the contents of a ref, i.e., x.contents *) ;; 
- : int = 0
# x := !x + 1    (* assignment, i.e., x.contents &lt;- ... *) ;; 
- : unit = ()
# !x ;; 
- : int = 1
</programlisting>
      <para>
        There's nothing magical with these operators either. You can
        completely reimplement the <literal>ref</literal> type and all
        of these operators in just a few lines of code.
      </para>
      <programlisting language="ocaml">
...part 56 of guided-tour/main.topscript
# type 'a ref = { mutable contents : 'a }

  let ref x = { contents = x }
  let (!) r = r.contents
  let (:=) r x = r.contents &lt;- x
  ;; 
type 'a ref = { mutable contents : 'a; }
val ref : 'a -&gt; 'a ref = &lt;fun&gt;
val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;
val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        The <literal>'a</literal> before the ref indicates that the
        <literal>ref</literal> type is polymorphic, in the same way that
        lists are polymorphic, meaning it can contain values of any
        type. The parentheses around <literal>!</literal> and
        <literal>:=</literal> are needed because these are operators,
        rather than ordinary functions.
      </para>
      <para>
        Even though a <literal>ref</literal> is just another record
        type, it's important because it is the standard way of
        simulating the traditional mutable variables you'll find in most
        languages. For example, we can sum over the elements of a list
        imperatively by calling <literal>List.iter</literal> to call a
        simple function on every element of a list, using a ref to
        accumulate the results.
      </para>
      <programlisting language="ocaml">
...part 57 of guided-tour/main.topscript
# let sum list =
    let sum = ref 0 in
    List.iter list ~f:(fun x -&gt; sum := !sum + x);
    !sum
  ;; 
val sum : int list -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This isn't the most idiomatic (or the fastest) way to sum up a
        list, but it shows how you can use a ref in place of a mutable
        variable.
      </para>
    </sect2>
    <sect2 id="for-and-while-loops">
      <title>For and while loops</title>
      <para>
        OCaml also supports traditional imperative control-flow
        constructs like for and while loops. Here, for example, is some
        code for permuting an array that uses a for loop. We use the
        <literal>Random</literal> module as our source of randomness.
        <literal>Random</literal> starts with a default seed, but you
        can call <literal>Random.self_init</literal> to choose a new
        seed at random.
      </para>
      <programlisting language="ocaml">
...part 58 of guided-tour/main.topscript
# let permute array =
    let length = Array.length array in
    for i = 0 to length - 2 do
       (* pick a j that is after i and before the end of the array *)
       let j = i + 1 + Random.int (length - i - 1) in
       (* Swap i and j *)
       let tmp = array.(i) in
       array.(i) &lt;- array.(j);
       array.(j) &lt;- tmp
    done
  ;; 
val permute : 'a array -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        From a syntactic perspective, you should note the keywords that
        distinguish a for loop: <literal>for</literal>,
        <literal>to</literal>, <literal>do</literal> and
        <literal>done</literal>.
      </para>
      <para>
        Here's an example run of this code.
      </para>
      <programlisting language="ocaml">
...part 59 of guided-tour/main.topscript
# let ar = Array.init 20 ~f:(fun i -&gt; i);; 
val ar : int array =
  [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19|]
# permute ar;; 
- : unit = ()
# ar;; 
- : int array =
[|1; 2; 4; 6; 11; 7; 14; 9; 10; 0; 13; 16; 19; 12; 17; 5; 3; 18; 8; 15|]
</programlisting>
      <para>
        OCaml also supports while loops, as shown in the following
        function for finding the position of the first negative entry in
        an array. Note that <literal>while</literal> (like
        <literal>for</literal>) is also a keyword.
      </para>
      <programlisting language="ocaml">
...part 60 of guided-tour/main.topscript
# let find_first_negative_entry array =
     let pos = ref 0 in
     while !pos &lt; Array.length array &amp;&amp; array.(!pos) &gt;= 0 do
       pos := !pos + 1
     done;
     if !pos = Array.length array then None else Some !pos
  ;; 
val find_first_negative_entry : int array -&gt; int option = &lt;fun&gt;
# find_first_negative_entry [|1;2;0;3|];; 
- : int option = None
# find_first_negative_entry [|1;-2;0;3|];; 
- : int option = Some 1
</programlisting>
      <para>
        As a side note, the above code takes advantage of the fact that
        <literal>&amp;&amp;</literal>, OCaml's and operator,
        short-circuits. In particular, in an expression of the form
        <literal>&lt;expr1&gt; &amp;&amp; &lt;expr2&gt;</literal>,
        <literal>&lt;expr2&gt;</literal> will only be evaluated if
        <literal>&lt;expr1&gt;</literal> evaluated to true. Were it not
        for that, then the above function would result in an
        out-of-bounds error. Indeed, we can trigger that out-of-bounds
        error by rewriting the function to avoid the short-circuiting.
      </para>
      <programlisting language="ocaml">
...part 61 of guided-tour/main.topscript
# let find_first_negative_entry array =
     let pos = ref 0 in
     while
       let pos_is_good = !pos &lt; Array.length array in
       let element_is_non_negative = array.(!pos) &gt;= 0 in
       pos_is_good &amp;&amp; element_is_non_negative
     do
       pos := !pos + 1
     done;
     if !pos = Array.length array then None else Some !pos
  ;; 
val find_first_negative_entry : int array -&gt; int option = &lt;fun&gt;
# find_first_negative_entry [|1;2;0;3|];; 
Exception: (Invalid_argument &quot;index out of bounds&quot;).
</programlisting>
      <para>
        The or operator, <literal>||</literal> short-circuits in a
        similar way to <literal>&amp;&amp;</literal>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="a-complete-program">
    <title>A complete program</title>
    <para>
      So far, we've played with the basic features of the language via
      <literal>utop</literal>. Now we'll show how to create a simple
      standalone program. In particular, we'll create a program that
      sums up a list of numbers read in from the standard input.
    </para>
    <para>
      Here's the code, which you can save in a file called
      <literal>sum.ml</literal>. Note that we don't terminate
      expressions with <literal>;;</literal> here, since it's not
      required outside the toplevel.
    </para>
    <programlisting language="ocaml">
(* guided-tour/sum.ml  *)
open Core.Std

let rec read_and_accumulate accum =
  let line = In_channel.input_line In_channel.stdin in
  match line with
  | None -&gt; accum
  | Some x -&gt; read_and_accumulate (accum +. Float.of_string x)

let () =
  printf &quot;Total: %F\n&quot; (read_and_accumulate 0.)
</programlisting>
    <para>
      This is our first use of OCaml's input and output routines. The
      function <literal>read_and_accumulate</literal> is a recursive
      function that uses <literal>In_channel.input_line</literal> to
      read in lines one by one from the standard input, invoking itself
      at each iteration with its updated accumulated sum. Note that
      <literal>input_line</literal> returns an optional value, with
      <literal>None</literal> indicating the end of the input stream.
    </para>
    <para>
      After <literal>read_and_accumulate</literal> returns, the total
      needs to be printed. This is done using the
      <literal>printf</literal> command, which provides support for
      type-safe format strings, similar to what you'll find in a variety
      of languages. The format string is parsed by the compiler and used
      to determine the number and type of the remaining arguments that
      are required. In this case, there is a single formatting
      directive, <literal>%F</literal>, so <literal>printf</literal>
      expects one additional argument of type <literal>float</literal>.
    </para>
    <sect2 id="compiling-and-running">
      <title>Compiling and running</title>
      <para>
        We'll compile our program using <literal>corebuild</literal>, a
        small wrapper on top of <literal>ocamlbuild</literal>, which
        itself is a build-tool that ships with the OCaml compiler. The
        <literal>corebuild</literal> script is installed along with
        Core, and its purpose is to pass in the flags required for
        building a program with Core.
      </para>
      <programlisting>
# running guided-tour/build_sum.out.sh
$ corebuild sum.native
</programlisting>
      <para>
        The <literal>.native</literal> suffix indicates that we're
        building a native-code executable, which we'll discuss more in
        <xref linkend="files-modules-and-programs"/>. Once the
        build completes, we can use the resulting program like any
        command-line utility. We can feed input to
        <literal>build_sum.native</literal> by typing in a sequence of
        numbers, one per line, hitting <literal>control-d</literal> when
        we're done.
      </para>
      <programlisting>
# running guided-tour/sum.out.sh
$ ./sum.native
1
2
3
94.5
Total: 100.5
</programlisting>
      <para>
        More work is needed to make a really usable command-line
        program, including a proper command-line parsing interface and
        better error handling, all of which is covered in
        <xref linkend="command-line-parsing"/>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="where-to-go-from-here">
    <title>Where to go from here</title>
    <para>
      That's it for the guided tour! There are plenty of features left
      and lots of details to explain, but we hope that you now have a
      sense of what to expect from OCaml, and that you'll be more
      comfortable reading the rest of the book as a result.
    </para>
  </sect1>
</chapter><chapter id="variables-and-functions">
  <title>Variables and Functions</title>
  <para>
    Variables and functions are fundamental ideas that show up in
    virtually all programming languages. But OCaml has a different take
    on these basic concepts, so we'll spend some time digging into the
    details so you can understand OCaml's variables and functions and
    see how they differ from what you've encountered elsewhere.
  </para>
  <sect1 id="variables">
    <title>Variables</title>
    <para>
      At its simplest, a variable is an identifier whose meaning is
      bound to a particular value. In OCaml these bindings are often
      introduced using the <literal>let</literal> keyword. We can type a
      so-called <emphasis>top-level</emphasis> <literal>let</literal>
      binding into <literal>utop</literal> with the following syntax to
      bind a new variable. Note that variable names must start with a
      lowercase letter or an underscore.
    </para>
    <programlisting language="html">
let &lt;variable&gt; = &lt;expr&gt;
</programlisting>
    <para>
      As we'll see when we get to the module system in
      <xref linkend="files-modules-and-programs"/>, this same
      syntax is used for let bindings at the top-level of a module.
    </para>
    <para>
      Every variable binding has a <emphasis>scope</emphasis>, which is
      the portion of the code that can refer to that binding. When using
      <literal>utop</literal>, the scope of a top-level let binding is
      everything that follows it in the session. When it shows up in a
      module, the scope is the remainder of that module.
    </para>
    <para>
      Here's a simple example.
    </para>
    <programlisting language="ocaml">
# script variables-and-functions/main.topscript
$ utop
# let x = 3;; 
val x : int = 3
# let y = 4;; 
val y : int = 4
# let z = x + y;; 
val z : int = 7
</programlisting>
    <para>
      <literal>let</literal> can also be used to create a variable
      binding whose scope is limited to a particular expression, using
      the following syntax.
    </para>
    <programlisting language="html">
let &lt;variable&gt; = &lt;expr1&gt; in &lt;expr2&gt;
</programlisting>
    <para>
      This first evaluates
      <emphasis><literal>&lt;expr1&gt;</literal></emphasis> and then
      evaluates <emphasis><literal>&lt;expr2&gt;</literal></emphasis>
      with <emphasis><literal>&lt;variable&gt;</literal></emphasis>
      bound to whatever value was produced by the evaluation of
      <emphasis><literal>&lt;expr1&gt;</literal></emphasis>. Here's how
      it looks in practice.
    </para>
    <programlisting language="ocaml">
...part 1 of variables-and-functions/main.topscript
# let languages = &quot;OCaml,Perl,C++,C&quot;;; 
val languages : string = &quot;OCaml,Perl,C++,C&quot;
# let dashed_languages =
    let language_list = String.split languages ~on:',' in
    String.concat ~sep:&quot;-&quot; language_list
  ;; 
val dashed_languages : string = &quot;OCaml-Perl-C++-C&quot;
</programlisting>
    <para>
      Note that the scope of <literal>language_list</literal> is just
      the expression
      <literal>String.concat ~sep:&quot;-&quot; language_list</literal>,
      and is not available at the top level, as we can see if we try to
      access it now.
    </para>
    <programlisting language="ocaml">
...part 2 of variables-and-functions/main.topscript
# language_list;; 
Characters -1-13:
Error: Unbound value language_list
</programlisting>
    <para>
      A let binding in an inner scope can <emphasis>shadow</emphasis>,
      or hide, the definition from an outer scope. So, for example, we
      could have written the <literal>dashed_languages</literal> example
      as follows:
    </para>
    <programlisting language="ocaml">
...part 3 of variables-and-functions/main.topscript
# let languages = &quot;OCaml,Perl,C++,C&quot;;; 
val languages : string = &quot;OCaml,Perl,C++,C&quot;
# let dashed_languages =
     let languages = String.split languages ~on:',' in
     String.concat ~sep:&quot;-&quot; languages
  ;; 
val dashed_languages : string = &quot;OCaml-Perl-C++-C&quot;
</programlisting>
    <para>
      This time, in the inner scope we called the list of strings
      <literal>languages</literal> instead of
      <literal>language_list</literal>, thus hiding the original
      definition of <literal>languages</literal>. But once the
      definition of <literal>dashed_languages</literal> is complete, the
      inner scope has closed and the original definition of languages
      reappears.
    </para>
    <programlisting language="ocaml">
...part 4 of variables-and-functions/main.topscript
# languages;; 
- : string = &quot;OCaml,Perl,C++,C&quot;
</programlisting>
    <para>
      One common idiom is to use a series of nested
      <literal>let</literal>/<literal>in</literal> expressions to build
      up the components of a larger computation. Thus, we might write:
    </para>
    <programlisting language="ocaml">
...part 5 of variables-and-functions/main.topscript
# let area_of_ring inner_radius outer_radius =
     let pi = acos (-1.) in
     let area_of_circle r = pi *. r *. r in
     area_of_circle outer_radius -. area_of_circle inner_radius
  ;; 
val area_of_ring : float -&gt; float -&gt; float = &lt;fun&gt;
# area_of_ring 1. 3.;; 
- : float = 25.1327412287
</programlisting>
    <para>
      It's important not to confuse a sequence of let bindings with the
      modification of a mutable variable. For example, consider how
      <literal>area_of_ring</literal> would work if we had instead
      written this purposefully confusing bit of code.
    </para>
    <programlisting language="ocaml">
...part 6 of variables-and-functions/main.topscript
# let area_of_ring inner_radius outer_radius =
     let pi = acos (-1.) in
     let area_of_circle r = pi *. r *. r in
     let pi = 0. in
     area_of_circle outer_radius -. area_of_circle inner_radius
  ;; 

Characters 126-128:
Warning 26: unused variable pi.
val area_of_ring : float -&gt; float -&gt; float = &lt;fun&gt;
</programlisting>
    <para>
      Here, we redefined <literal>pi</literal> to be zero after the
      definition of <literal>area_of_circle</literal>. You might think
      that this would mean that the result of the computation would now
      be zero, but in fact, the behavior of the function is unchanged.
      That's because the original definition of <literal>pi</literal>
      wasn't changed, it was just shadowed, which means that any
      subsequent reference to <literal>pi</literal> would see the new
      definition of <literal>pi</literal> as zero, but earlier
      references would be unchanged. But there is no later use of
      <literal>pi</literal>, so the binding of <literal>0.</literal> to
      <literal>pi</literal> made no difference. This explains the
      warning produced by the toplevel telling us that there is an
      unused definition of <literal>pi</literal>.
    </para>
    <para>
      In OCaml, let bindings are immutable. As we'll see in
      <xref linkend="imperative-programming-1"/>, there are
      mutable values in OCaml, but no mutable variables.
    </para>
    <note> <title> 
    Why don't variables vary?
    </title>
    <para>
      One source of confusion for people new to OCaml is the fact that
      variables are immutable. This seems pretty surprising even on
      linguistic terms. Isn't the whole point of a variable that it can
      vary?
    </para>
    <para>
      The answer to this is that variables in OCaml (and generally in
      functional languages) are really more like variables in an
      equation than a variable in an imperative language. If you think
      about the mathematical equation
      <literal>x(y + z) = xy + xz</literal>, there's no notion of
      mutating the variables <literal>x</literal>, <literal>y</literal>
      and <literal>z</literal>. They vary in the sense that you can
      instantiate this equation with different numbers for those
      variables, and it still holds.
    </para>
    <para>
      The same is true in a functional language. A function can be
      applied to different inputs, and thus its variables will take on
      different values, even without mutation.
    </para>
    </note>

    <sect2 id="pattern-matching-and-let">
      <title>Pattern matching and <literal>let</literal></title>
      <para>
        Another useful feature of let bindings is that they support the
        use of <emphasis>patterns</emphasis> on the left-hand side.
        Consider the following code, which uses
        <literal>List.unzip</literal>, a function for converting a list
        of pairs into a pair of lists.
      </para>
      <programlisting language="ocaml">
...part 7 of variables-and-functions/main.topscript
# let (ints,strings) = List.unzip [(1,&quot;one&quot;); (2,&quot;two&quot;); (3,&quot;three&quot;)];; 
val ints : int list = [1; 2; 3]
val strings : string list = [&quot;one&quot;; &quot;two&quot;; &quot;three&quot;]
</programlisting>
      <para>
        Here, <literal>(ints,strings)</literal> is a pattern, and the
        <literal>let</literal> binding assigns values to both of the
        identifiers that show up in that pattern. A pattern is
        essentially a description of the shape of a data-structure,
        where some components are identifiers to be bound. As we saw in
        <xref linkend="tuples-lists-options-and-pattern-matching"/>,
        OCaml has patterns for a variety of different data-types.
      </para>
      <para>
        Using a pattern in a let-binding makes the most sense for a
        pattern that is <emphasis>irrefutable</emphasis>,
        <emphasis>i.e.</emphasis>, where any value of the type in
        question is guaranteed to match the pattern. Tuple and record
        patterns are irrefutable, but list patterns are not. Consider
        the following code that implements a function for up-casing the
        first element of a comma-separated list.
      </para>
      <programlisting language="ocaml">
...part 8 of variables-and-functions/main.topscript
# let upcase_first_entry line =
     let (first :: rest) = String.split ~on:',' line in
     String.concat ~sep:&quot;,&quot; (String.uppercase first :: rest)
  ;; 

Characters 40-53:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val upcase_first_entry : string -&gt; string = &lt;fun&gt;
</programlisting>
      <para>
        This case can't really come up in practice, because
        <literal>String.split</literal> always returns a list with at
        least one element. But the compiler doesn't know this, and so it
        emits the warning. It's generally better to use a match
        statement to handle such cases explicitly:
      </para>
      <programlisting language="ocaml">
...part 9 of variables-and-functions/main.topscript
# let upcase_first_entry line =
     match String.split ~on:',' line with
     | [] -&gt; assert false (* String.split returns at least one element *)
     | first :: rest -&gt; String.concat ~sep:&quot;,&quot; (String.uppercase first :: rest)
  ;; 
val upcase_first_entry : string -&gt; string = &lt;fun&gt;
</programlisting>
      <para>
        Note that this is our first use of <literal>assert</literal>,
        which is useful for marking cases that should be impossible.
        Asserts are discussed in more detail in
        <xref linkend="error-handling"/>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="functions">
    <title>Functions</title>
    <para>
      Given that OCaml is a functional language, it's no surprise that
      functions are important and pervasive. Indeed, functions have come
      up in almost every example we've done so far. This section will go
      into more depth, explaining the details of how OCaml's functions
      work. As you'll see, functions in OCaml differ in a variety of
      ways from what you'll find in most mainstream languages.
    </para>
    <sect2 id="anonymous-functions">
      <title>Anonymous Functions</title>
      <para>
        We'll start by looking at the most basic style of function
        declaration in OCaml: the <emphasis>anonymous
        function</emphasis>. An anonymous function is a function value
        that is declared without being named. They can be declared using
        the <literal>fun</literal> keyword, as shown here.
      </para>
      <programlisting language="ocaml">
...part 10 of variables-and-functions/main.topscript
# (fun x -&gt; x + 1);; 
- : int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        Anonymous functions aren't named, but they can be used for many
        different purposes nonetheless. You can, for example, apply an
        anonymous function to an argument.
      </para>
      <programlisting language="ocaml">
...part 11 of variables-and-functions/main.topscript
# (fun x -&gt; x + 1) 7;; 
- : int = 8
</programlisting>
      <para>
        Or pass it to another function. Passing functions to iteration
        functions like <literal>List.map</literal> is probably the most
        common use-case for anonymous functions.
      </para>
      <programlisting language="ocaml">
...part 12 of variables-and-functions/main.topscript
# List.map ~f:(fun x -&gt; x + 1) [1;2;3];; 
- : int list = [2; 3; 4]
</programlisting>
      <para>
        You can even stuff them into a data structure.
      </para>
      <programlisting language="ocaml">
...part 13 of variables-and-functions/main.topscript
# let increments = [ (fun x -&gt; x + 1); (fun x -&gt; x + 2) ] ;; 
val increments : (int -&gt; int) list = [&lt;fun&gt;; &lt;fun&gt;]
# List.map ~f:(fun g -&gt; g 5) increments;; 
- : int list = [6; 7]
</programlisting>
      <para>
        It's worth stopping for a moment to puzzle this example out,
        since this kind of higher-order use of functions can be a bit
        obscure at first. The first thing to understand is the function
        <literal>(fun g -&gt; g 5)</literal>, which takes a function as
        its argument and applies that function to the number
        <literal>5</literal>. The invocation of
        <literal>List.map</literal> applies
        <literal>(fun g -&gt; g 5)</literal> to the elements of the
        <literal>increments</literal> list (which are themselves
        functions) and returns the list containing the results of these
        function applications.
      </para>
      <para>
        The key thing to understand is that functions are ordinary
        values in OCaml, and you can do everything with them that you'd
        do with an ordinary value, including passing them to and
        returning them from other functions and storing them in data
        structures. We even name functions in the same way that we name
        other values, by using a let binding.
      </para>
      <programlisting language="ocaml">
...part 14 of variables-and-functions/main.topscript
# let plusone = (fun x -&gt; x + 1);; 
val plusone : int -&gt; int = &lt;fun&gt;
# plusone 3;; 
- : int = 4
</programlisting>
      <para>
        Defining named functions is so common that there is some
        syntactic sugar for it. Thus, the following definition of
        <literal>plusone</literal> is equivalent to the definition
        above.
      </para>
      <programlisting language="ocaml">
...part 15 of variables-and-functions/main.topscript
# let plusone x = x + 1;; 
val plusone : int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This is the most common and convenient way to declare a
        function, but syntactic niceties aside, the two styles of
        function definition are entirely equivalent.
      </para>
      <note>
      <title>
      <literal>let</literal> and <literal>fun</literal>
      </title>
      <para>
        Functions and let bindings have a lot to do with each other. In
        some sense, you can think of the parameter of a function as a
        variable being bound to the value passed by the caller. Indeed,
        the following two expressions are nearly equivalent:
      </para>
      <programlisting language="ocaml">
...part 16 of variables-and-functions/main.topscript
# (fun x -&gt; x + 1) 7;; 
- : int = 8
# let x = 7 in x + 1;; 
- : int = 8
</programlisting>
      <para>
        This connection is important, and will come up more when
        programming in a monadic style, as we'll see in
        <xref linkend="concurrent-programming-with-async"/>.
      </para>
      </note>
    </sect2>
    <sect2 id="multi-argument-functions">
      <title>Multi-argument functions</title>
      <para>
        OCaml of course also supports multi-argument functions, for
        example:
      </para>
      <programlisting language="ocaml">
...part 17 of variables-and-functions/main.topscript
# let abs_diff x y = abs (x - y);; 
val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;
# abs_diff 3 4;; 
- : int = 1
</programlisting>
      <para>
        You may find the type signature of <literal>abs_diff</literal>
        with all of its arrows a little hard to parse. To understand
        what's going on, let's rewrite <literal>abs_diff</literal> in an
        equivalent form, using the <literal>fun</literal> keyword:
      </para>
      <programlisting language="ocaml">
...part 18 of variables-and-functions/main.topscript
# let abs_diff =
    (fun x -&gt; (fun y -&gt; abs (x - y)));; 
val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This rewrite makes it explicit that <literal>abs_diff</literal>
        is actually a function of one argument that returns another
        function of one argument, which itself returns the final result.
        Because the functions are nested, the inner expression
        <literal>abs (x - y)</literal> has access to both
        <literal>x</literal>, which was bound by the first function
        application, and <literal>y</literal>, which was bound by the
        second one.
      </para>
      <para>
        This style of function is called a <emphasis>curried</emphasis>
        function. (Currying is named after Haskell Curry, a logician who
        had a significant impact on the design and theory of programming
        languages.) The key to interpreting the type signature of a
        curried function is the observation that
        <literal>-&gt;</literal> is right-associative. The type
        signature of <literal>abs_diff</literal> can therefore be
        parenthesized as follows.
      </para>
      <programlisting language="ocaml">
(* variables-and-functions/abs_diff.mli  *)
val abs_diff : int -&gt; (int -&gt; int)
</programlisting>
      <para>
        The parentheses above don't change the meaning of the signature,
        but it makes it easier to see the currying.
      </para>
      <para>
        Currying is more than just a theoretical curiosity. You can make
        use of currying to specialize a function by feeding in some of
        the arguments. Here's an example where we create a specialized
        version of <literal>abs_diff</literal> that measures the
        distance of a given number from <literal>3</literal>.
      </para>
      <programlisting language="ocaml">
...part 19 of variables-and-functions/main.topscript
# let dist_from_3 = abs_diff 3;; 
val dist_from_3 : int -&gt; int = &lt;fun&gt;
# dist_from_3 8;; 
- : int = 5
# dist_from_3 (-1);; 
- : int = 4
</programlisting>
      <para>
        The practice of applying some of the arguments of a curried
        function to get a new function is called <emphasis>partial
        application</emphasis>.
      </para>
      <para>
        Note that the <literal>fun</literal> keyword supports its own
        syntax for currying, so the following definition of
        <literal>abs_diff</literal> is equivalent to the definition
        above.
      </para>
      <programlisting language="ocaml">
...part 20 of variables-and-functions/main.topscript
# let abs_diff = (fun x y -&gt; abs (x - y));; 
val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        You might worry that curried functions are terribly expensive,
        but this is not the case. In OCaml, there is no penalty for
        calling a curried function with all of its arguments. (Partial
        application, unsurprisingly, does have a small extra cost.)
      </para>
      <para>
        Currying is not the only way of writing a multi-argument
        function in OCaml. It's also possible to use the different parts
        of a tuple as different arguments. So, we could write:
      </para>
      <programlisting language="ocaml">
...part 21 of variables-and-functions/main.topscript
# let abs_diff (x,y) = abs (x - y);; 
val abs_diff : int * int -&gt; int = &lt;fun&gt;
# abs_diff (3,4);; 
- : int = 1
</programlisting>
      <para>
        OCaml handles this calling convention efficiently as well. In
        particular it does not generally have to allocate a tuple just
        for the purpose of sending arguments to a tuple-style function.
        (You can't, however, use partial application for this style of
        function.)
      </para>
      <para>
        There are small tradeoffs between these two approaches, but most
        of the time, one should stick to currying, since it's the
        default style in the OCaml world.
      </para>
    </sect2>
    <sect2 id="recursive-functions">
      <title>Recursive functions</title>
      <para>
        A function is <emphasis>recursive</emphasis> if it refers to
        itself in its definition. Recursion is important in any
        programming language, but is particularly important in
        functional languages, because it is the fundamental building
        block that is used for building looping constructs. (As we'll
        see in <xref linkend="imperative-programming-1"/>,
        OCaml also supports imperative looping constructs like
        <literal>for</literal> and <literal>while</literal>, but these
        are only useful when using OCaml's imperative features.)
      </para>
      <para>
        In order to define a recursive function, you need to mark the
        let binding as recursive with the <literal>rec</literal>
        keyword, as shown in this function for finding the first
        sequentially-repeated element in a list.
      </para>
      <programlisting language="ocaml">
...part 22 of variables-and-functions/main.topscript
# let rec find_first_stutter list =
    match list with
    | [] | [_] -&gt;
      (* only zero or one elements, so no repeats *)
      None
    | x :: y :: tl -&gt;
      if x = y then Some x else find_first_stutter (y::tl)
   ;; 
val find_first_stutter : 'a list -&gt; 'a option = &lt;fun&gt;
</programlisting>
      <para>
        Note that in the above, the pattern
        <literal>| [] | [_]</literal> is what's called on
        <emphasis>or-pattern</emphasis>, which is the combination of two
        patterns. In this case, <literal>[]</literal>, matching the
        empty list, and <literal>[_]</literal>, matching any single
        element list. The <literal>_</literal> is there so we don't have
        to put an explicit name on that single element.
      </para>
      <para>
        We can also define multiple mutually recursive values by using
        <literal>let rec</literal> combined with the
        <literal>and</literal> keyword. Here's a (gratuitously
        inefficient) example.
      </para>
      <programlisting language="ocaml">
...part 23 of variables-and-functions/main.topscript
# let rec is_even x =
    if x = 0 then true else is_odd (x - 1)
  and is_odd x =
    if x = 0 then false else is_even (x - 1)
 ;; 
val is_even : int -&gt; bool = &lt;fun&gt;
val is_odd : int -&gt; bool = &lt;fun&gt;
# List.map ~f:is_even [0;1;2;3;4;5];; 
- : bool list = [true; false; true; false; true; false]
# List.map ~f:is_odd [0;1;2;3;4;5];; 
- : bool list = [false; true; false; true; false; true]
</programlisting>
      <para>
        OCaml distinguishes between non-recursive definitions (using
        <literal>let</literal>) and recursive definitions (using
        <literal>let rec</literal>) largely for technical reasons: the
        type-inference algorithm needs to know when a set of function
        definitions are mutually recursive, and for reasons that don't
        apply to a pure language like Haskell, these have to be marked
        explicitly by the programmer.
      </para>
      <para>
        But this decision has some good effects. For one thing,
        recursive (and especially mutually recursive) definitions are
        harder to reason about than non-recursive definitions that
        proceed in order, each building on top of what has already been
        defined. It's therefore useful that, in the absence of an
        explicit marker, new definitions can only build upon ones that
        were previously defined.
      </para>
      <para>
        In addition, having a non-recursive form makes it easier to
        create a new definition that extends and supersedes an existing
        one by shadowing it.
      </para>
    </sect2>
    <sect2 id="prefix-and-infix-operators">
      <title>Prefix and infix operators</title>
      <para>
        So far, we've seen examples of functions used in both prefix and
        infix style:
      </para>
      <programlisting language="ocaml">
...part 24 of variables-and-functions/main.topscript
# Int.max 3 4  (* prefix *);; 
- : int = 4
# 3 + 4        (* infix  *);; 
- : int = 7
</programlisting>
      <para>
        You might not have thought of the second example as an ordinary
        function, but it very much is. Infix operators like
        <literal>+</literal> really only differ syntactically from other
        functions. In fact, if we put parentheses around an infix
        operator, you can use it as an ordinary prefix function.
      </para>
      <programlisting language="ocaml">
...part 25 of variables-and-functions/main.topscript
# (+) 3 4;; 
- : int = 7
# List.map ~f:((+) 3) [4;5;6];; 
- : int list = [7; 8; 9]
</programlisting>
      <para>
        In the second expression above, we've partially applied
        <literal>(+)</literal> to gain a function that increments its
        single argument by <literal>3</literal>, and then applied that
        to all the elements of a list.
      </para>
      <para>
        A function is treated syntactically as an operator if the name
        of that function is chosen from one of a specialized set of
        identifiers. This set includes identifiers that are sequences of
        characters from the following set:
      </para>
      <programlisting language="html">
! $ % &amp; * + - . / : &lt; = &gt; ? @ ^ | ~
</programlisting>
      <para>
        or is one of a handful of pre-determined strings, including
        <literal>mod</literal>, the modulus operator, and
        <literal>lsl</literal>, for &quot;logical shift left&quot;, a
        bit-shifting operation.
      </para>
      <para>
        We can define (or redefine) the meaning of an operator. Here's
        an example of a simple vector-addition operator on int pairs.
      </para>
      <programlisting language="ocaml">
...part 26 of variables-and-functions/main.topscript
# let (+!) (x1,y1) (x2,y2) = (x1 + x2, y1 + y2);; 
val ( +! ) : int * int -&gt; int * int -&gt; int * int = &lt;fun&gt;
# (3,2) +! (-2,4);; 
- : int * int = (1, 6)
</programlisting>
      <para>
        Note that you have to be careful when dealing with operators
        containing <literal>*</literal>. Consider the following example.
      </para>
      <programlisting language="ocaml">
...part 27 of variables-and-functions/main.topscript
# let (***) x y = (x ** y) ** y;; 
Characters 17-18:
Error: This expression has type int but an expression was expected of type
         float
</programlisting>
      <para>
        What's going on is that <literal>(***)</literal> isn't
        interpreted as an operator at all; it's read as a comment! To
        get this to work properly, we need to put spaces around any
        operator that begins or ends with <literal>*</literal>.
      </para>
      <programlisting language="ocaml">
...part 28 of variables-and-functions/main.topscript
# let ( *** ) x y = (x ** y) ** y;; 
val ( *** ) : float -&gt; float -&gt; float = &lt;fun&gt;
</programlisting>
      <para>
        The syntactic role of an operator is typically determined by its
        first character or two, though there are a few exceptions. This
        table breaks the different operators and other syntactic forms
        into groups from highest to lowest precedence, explaining how
        each behaves syntactically. We write <literal>!</literal>... to
        indicate the class of operators beginning with
        <literal>!</literal>.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec colwidth="37*" align="left"/>
          <colspec colwidth="23*" align="left"/>
          <thead>
            <row>
              <entry>
                Prefix
              </entry>
              <entry>
                Usage
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <literal>!</literal>..., <literal>?</literal>...,
                <literal>~</literal>...
              </entry>
              <entry>
                Prefix
              </entry>
            </row>
            <row>
              <entry>
                <literal>.</literal>, <literal>.(</literal>,
                <literal>.[</literal>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
                function application, constructor,
                <literal>assert</literal>, <literal>lazy</literal>
              </entry>
              <entry>
                Left associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>-</literal>, <literal>-.</literal>
              </entry>
              <entry>
                Prefix
              </entry>
            </row>
            <row>
              <entry>
                <literal>**</literal>..., <literal>lsl</literal>,
                <literal>lsr</literal>, <literal>asr</literal>
              </entry>
              <entry>
                Right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>*</literal>..., <literal>/</literal>...,
                <literal>%</literal>..., <literal>mod</literal>,
                <literal>land</literal>, <literal>lor</literal>,
                <literal>lxor</literal>
              </entry>
              <entry>
                Left associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>+</literal>, <literal>-</literal>
              </entry>
              <entry>
                Left associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>::</literal>
              </entry>
              <entry>
                Right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>@</literal>..., <literal>^</literal>...
              </entry>
              <entry>
                Right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>=</literal>..., <literal>&lt;</literal>...,
                <literal>&gt;</literal>..., <literal>|</literal>...,
                <literal>&amp;</literal>..., <literal>$</literal>...
              </entry>
              <entry>
                Left associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>&amp;</literal>, <literal>&amp;&amp;</literal>
              </entry>
              <entry>
                Right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>or</literal>, <literal>||</literal>
              </entry>
              <entry>
                Right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>,</literal>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
                <literal>&lt;-</literal>, <literal>:=</literal>
              </entry>
              <entry>
                Right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>if</literal>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
                <literal>;</literal>
              </entry>
              <entry>
                Right associative
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        There's one important special case: <literal>-</literal> and
        <literal>-.</literal>, which are the integer and floating-point
        subtraction operators, can act as both prefix operators (for
        negation) and infix operators (for subtraction), So, both
        <literal>-x</literal> and <literal>x - y</literal> are
        meaningful expressions. Another thing to remember about negation
        is that it has lower precedence than function application, which
        means that if you want to pass a negative value, you need to
        wrap it in parentheses, as you can see below.
      </para>
      <programlisting language="ocaml">
...part 29 of variables-and-functions/main.topscript
# Int.max 3 (-4);; 
- : int = 3
# Int.max 3 -4;; 
Characters -1-9:
Error: This expression has type int -&gt; int
       but an expression was expected of type int
</programlisting>
      <para>
        Here, OCaml is interpreting the second expression as equivalent
        to:
      </para>
      <programlisting language="ocaml">
...part 30 of variables-and-functions/main.topscript
# (Int.max 3) - 4;; 
Characters 1-10:
Error: This expression has type int -&gt; int
       but an expression was expected of type int
</programlisting>
      <para>
        which obviously doesn't make sense.
      </para>
      <para>
        Here's an example of a very useful operator from the standard
        library whose behavior depends critically on the precedence
        rules described above. Here's the code.
      </para>
      <programlisting language="ocaml">
...part 31 of variables-and-functions/main.topscript
# let (|&gt;) x f = f x ;; 
val ( |&gt; ) : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &lt;fun&gt;
</programlisting>
      <para>
        It's not quite obvious at first what the purpose of this
        operator is: it just takes a value and a function, and applies
        the function to the value. Despite that bland sounding
        description, it has the useful role of a sequencing operator,
        similar in spirit to using pipe in the UNIX shell. Consider, for
        example, the following code for printing out the unique elements
        of your <literal>PATH</literal>. Note that
        <literal>List.dedup</literal> below removes duplicates from a
        list by sorting the list using the provided comparison function.
      </para>
      <programlisting language="ocaml">
...part 32 of variables-and-functions/main.topscript
# let path = &quot;/usr/bin:/usr/local/bin:/bin:/sbin&quot;;; 
val path : string = &quot;/usr/bin:/usr/local/bin:/bin:/sbin&quot;
#   String.split ~on:':' path
  |&gt; List.dedup ~compare:String.compare
  |&gt; List.iter ~f:print_endline
  ;; 

/bin
/sbin
/usr/bin
/usr/local/bin
- : unit = ()
</programlisting>
      <para>
        Note that we can do this without <literal>|&gt;</literal>, but
        the result is a bit more verbose.
      </para>
      <programlisting language="ocaml">
...part 33 of variables-and-functions/main.topscript
#   let split_path = String.split ~on:':' path in
  let deduped_path = List.dedup ~compare:String.compare split_path in
  List.iter ~f:print_endline deduped_path
  ;; 

/bin
/sbin
/usr/bin
/usr/local/bin
- : unit = ()
</programlisting>
      <para>
        An important part of what's happening here is partial
        application. For example, <literal>List.iter</literal> normally
        takes two arguments: a function to be called on each element of
        the list, and the list to iterate over. We can call
        <literal>List.iter</literal> with all its arguments:
      </para>
      <programlisting language="ocaml">
...part 34 of variables-and-functions/main.topscript
# List.iter ~f:print_endline [&quot;Two&quot;; &quot;lines&quot;];; 

Two
lines
- : unit = ()
</programlisting>
      <para>
        Or, we can pass it just the function argument, leaving us with a
        function for printing out a list of strings.
      </para>
      <programlisting language="ocaml">
...part 35 of variables-and-functions/main.topscript
# List.iter ~f:print_endline;; 
- : string list -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        It is this later form that we're using in the
        <literal>|&gt;</literal> pipeline above.
      </para>
      <para>
        Note that <literal>|&gt;</literal> only works in the intended
        way because it is left-associative. Indeed, let's see what
        happens if we try using a right associative operator, like
        (^&gt;).
      </para>
      <programlisting language="ocaml">
...part 36 of variables-and-functions/main.topscript
# let (^&gt;) x f = f x;; 
val ( ^&gt; ) : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &lt;fun&gt;
# Sys.getenv_exn &quot;PATH&quot;
  ^&gt; String.split ~on:':' path
  ^&gt; List.dedup ~compare:String.compare
  ^&gt; List.iter ~f:print_endline
  ;; 
Characters 98-124:
Error: This expression has type string list -&gt; unit
       but an expression was expected of type
         (string list -&gt; string list) -&gt; 'a
       Type string list is not compatible with type
         string list -&gt; string list 
</programlisting>
      <para>
        The above type error is a little bewildering at first glance.
        What's going on is that, because <literal>^&gt;</literal> is
        right associative, the operator is trying to feed the value
        <literal>List.dedup ~compare:String.compare</literal> to the
        function <literal>List.iter ~f:print_endline</literal>. But
        <literal>List.iter ~f:print_endline</literal> expects a list of
        strings as its input, not a function.
      </para>
      <para>
        The type error aside, this example highlights the importance of
        choosing the operator you use with care, particularly with
        respect to associativity.
      </para>
    </sect2>
    <sect2 id="declaring-functions-with-function">
      <title>Declaring functions with
      <literal>function</literal></title>
      <para>
        Another way to define a function is using the
        <literal>function</literal> keyword. Instead of having syntactic
        support for declaring multi-argument (curried) functions,
        <literal>function</literal> has built-in pattern matching.
        Here's an example:
      </para>
      <programlisting language="ocaml">
...part 37 of variables-and-functions/main.topscript
# let some_or_zero = function
     | Some x -&gt; x
     | None -&gt; 0
  ;; 
val some_or_zero : int option -&gt; int = &lt;fun&gt;
# List.map ~f:some_or_zero [Some 3; None; Some 4];; 
- : int list = [3; 0; 4]
</programlisting>
      <para>
        This is equivalent to combining an ordinary function definition
        with a <literal>match</literal>.
      </para>
      <programlisting language="ocaml">
...part 38 of variables-and-functions/main.topscript
# let some_or_zero num_opt =
    match num_opt with
    | Some x -&gt; x
    | None -&gt; 0
  ;; 
val some_or_zero : int option -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        We can also combine the different styles of function declaration
        together, as in the following example where we declare a two
        argument (curried) function with a pattern match on the second
        argument.
      </para>
      <programlisting language="ocaml">
...part 39 of variables-and-functions/main.topscript
# let some_or_default default = function
     | Some x -&gt; x
     | None -&gt; default
  ;; 
val some_or_default : 'a -&gt; 'a option -&gt; 'a = &lt;fun&gt;
# some_or_default 3 (Some 5);; 
- : int = 5
# List.map ~f:(some_or_default 100) [Some 3; None; Some 4];; 
- : int list = [3; 100; 4]
</programlisting>
      <para>
        Also, note the use of partial application to generate the
        function passed to <literal>List.map</literal>. In other words,
        <literal>some_or_default 100</literal> is a function that was
        created by feeding just the first argument to
        <literal>some_or_default</literal>.
      </para>
    </sect2>
    <sect2 id="labeled-arguments">
      <title>Labeled arguments</title>
      <para>
        Up until now, the functions we've defined have specified their
        arguments positionally, <emphasis>i.e.</emphasis>, by the order
        in which the arguments are passed to the function. OCaml also
        supports labeled arguments, which let you identify a function
        argument by name. Indeed, we've already encountered functions
        from Core like <literal>List.map</literal> that use labeled
        arguments. Labeled arguments are marked by a leading tilde, and
        a label (followed by a colon) are put in front of the variable
        to be labeled. Here's an example.
      </para>
      <programlisting language="ocaml">
...part 40 of variables-and-functions/main.topscript
# let ratio ~num ~denom = float num /. float denom;; 
val ratio : num:int -&gt; denom:int -&gt; float = &lt;fun&gt;
</programlisting>
      <para>
        We can then provide a labeled argument using a similar
        convention. As you can see, the arguments can be provided in any
        order.
      </para>
      <programlisting language="ocaml">
...part 41 of variables-and-functions/main.topscript
# ratio ~num:3 ~denom:10;; 
- : float = 0.3
# ratio ~denom:10 ~num:3;; 
- : float = 0.3
</programlisting>
      <para>
        OCaml also supports <emphasis>label punning</emphasis>, meaning
        that you get to drop the text after the <literal>:</literal> if
        the name of the label and the name of the variable being used
        are the same. We were actually already using label punning when
        defining our labeled function above. The following shows how
        punning can be used when invoking a function.
      </para>
      <programlisting language="ocaml">
...part 42 of variables-and-functions/main.topscript
# let num = 3 in
let denom = 4 in
ratio ~num ~denom;; 
- : float = 0.75
</programlisting>
      <para>
        Labeled arguments are useful in a few different cases:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            When defining a function with lots of arguments. Beyond a
            certain number, arguments are easier to remember by name
            than by position.
          </para>
        </listitem>
        <listitem>
          <para>
            When the meaning of a particular argument is unclear from
            the type alone. Consider a function for creating a hash
            table whose first argument is the initial size of the array
            backing the hashtable, and the second is a Boolean flag
            which indicates whether that array will ever shrink when
            elements are removed.
          </para>
        </listitem>
      </itemizedlist>
      <programlisting language="ocaml">
(* variables-and-functions/htable_sig1.ml  *)
val create_hashtable : int -&gt; bool -&gt; ('a,'b) Hashtable.t
</programlisting>
      <para>
        The above signature makes it hard to divine the meaning of those
        two arguments. but with labeled arguments, we can make the
        intent immediately clear.
      </para>
      <programlisting language="ocaml">
(* variables-and-functions/htable_sig2.ml  *)
val create_hashtable :
  init_size:int -&gt; allow_shrinking:bool -&gt; ('a,'b) Hashtable.t
</programlisting>
      <para>
        Choosing label names well is especially important for Boolean
        values, since it's often easy to get confused about whether a
        value being true is meant ot enable or disable a given feature.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            When defining functions that have multiple arguments that
            might get confused with each other. This is most at issue
            when the arguments are of the same type. For example,
            consider this signature for a function that extracts a
            substring.
          </para>
        </listitem>
      </itemizedlist>
      <programlisting language="ocaml">
(* variables-and-functions/substring_sig1.ml  *)
val substring: string -&gt; int -&gt; int -&gt; string
</programlisting>
      <para>
        Here, the two ints are the starting position and length of the
        substring to extract, respectively. We can can make this fact
        more obvious from the signature by adding labels.
      </para>
      <programlisting language="ocaml">
(* variables-and-functions/substring_sig2.ml  *)
val substring: string -&gt; pos:int -&gt; len:int -&gt; string
</programlisting>
      <para>
        This improves the readability of both the signature and of
        client code that makes use of <literal>substring</literal>, and
        makes it harder to accidentally swap the position and the
        length.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            When you want flexibility on the order in which arguments
            are passed. Consider a function like
            <literal>List.iter</literal>, that takes two arguments: a
            function, and a list of elements to call that function on. A
            common pattern is to partially apply
            <literal>List.iter</literal> by giving it just the function,
            as in the following example from earlier in the chapter.
          </para>
        </listitem>
      </itemizedlist>
      <programlisting language="ocaml">
...part 43 of variables-and-functions/main.topscript
#   String.split ~on:':' path
  |&gt; List.dedup ~compare:String.compare
  |&gt; List.iter ~f:print_endline
  ;; 

/bin
/sbin
/usr/bin
/usr/local/bin
- : unit = ()
</programlisting>
      <para>
        This requires that we put the function argument first. In other
        cases, you want to put the function argument second. One common
        reason is readability. In particular, a multi-line function
        passed as an argument to another function is easiest to read
        when it is the final argument to that function.
      </para>
      <sect3 id="higher-order-functions-and-labels">
        <title>Higher-order functions and labels</title>
        <para>
          One surprising gotcha with labeled arguments is that while
          order doesn't matter when calling a function with labeled
          arguments, it does matter in a higher-order context,
          <emphasis>e.g.</emphasis>, when passing a function with
          labeled arguments to another function. Here's an example.
        </para>
        <programlisting language="ocaml">
...part 44 of variables-and-functions/main.topscript
# let apply_to_tuple f (first,second) = f ~first ~second;; 
val apply_to_tuple : (first:'a -&gt; second:'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c = &lt;fun&gt;
</programlisting>
        <para>
          Here, the definition of <literal>apply_to_tuple</literal> sets
          up the expectation that its first argument is a function with
          two labeled arguments, <literal>first</literal> and
          <literal>second</literal>, listed in that order. We could have
          defined <literal>apply_to_tuple</literal> differently to
          change the order in which the labeled arguments were listed.
        </para>
        <programlisting language="ocaml">
...part 45 of variables-and-functions/main.topscript
# let apply_to_tuple_2 f (first,second) = f ~second ~first;; 
val apply_to_tuple_2 : (second:'a -&gt; first:'b -&gt; 'c) -&gt; 'b * 'a -&gt; 'c = &lt;fun&gt;
</programlisting>
        <para>
          It turns out this order matters. In particular, if we define a
          function that has a different order
        </para>
        <programlisting language="ocaml">
...part 46 of variables-and-functions/main.topscript
# let divide ~first ~second = first / second;; 
val divide : first:int -&gt; second:int -&gt; int = &lt;fun&gt;
</programlisting>
        <para>
          we'll find that it can't be passed in to
          <literal>apply_to_tuple_2</literal>.
        </para>
        <programlisting language="ocaml">
...part 47 of variables-and-functions/main.topscript
# apply_to_tuple_2 divide (3,4);; 
Characters 17-23:
Error: This expression has type first:int -&gt; second:int -&gt; int
       but an expression was expected of type second:'a -&gt; first:'b -&gt; 'c
</programlisting>
        <para>
          But, it works smoothly with the original
          <literal>apply_to_tuple</literal>.
        </para>
        <programlisting language="ocaml">
...part 48 of variables-and-functions/main.topscript
# let apply_to_tuple f (first,second) = f ~first ~second;; 
val apply_to_tuple : (first:'a -&gt; second:'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c = &lt;fun&gt;
# apply_to_tuple divide (3,4);; 
- : int = 0
</programlisting>
        <para>
          As a result, when passing labeled functions as arguments, you
          need to take care to be consistent in your ordering of labeled
          arguments in higher-order contexts.
        </para>
      </sect3>
    </sect2>
    <sect2 id="optional-arguments">
      <title>Optional arguments</title>
      <para>
        An optional argument is like a labeled argument that the caller
        can choose whether or not to provide. Optional arguments are
        passed in using the same syntax as labeled arguments, and, like
        labeled arguments, can be provided in any order.
      </para>
      <para>
        Here's an example of a string concatenation function with an
        optional separator. This function uses the <literal>^</literal>
        operator for simple pairwise string concatenation.
      </para>
      <programlisting language="ocaml">
...part 49 of variables-and-functions/main.topscript
# let concat ?sep x y =
     let sep = match sep with None -&gt; &quot;&quot; | Some x -&gt; x in
     x ^ sep ^ y
  ;; 
val concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
# concat &quot;foo&quot; &quot;bar&quot;             (* without the optional argument *);; 
- : string = &quot;foobar&quot;
# concat ~sep:&quot;:&quot; &quot;foo&quot; &quot;bar&quot;    (* with the optional argument    *);; 
- : string = &quot;foo:bar&quot;
</programlisting>
      <para>
        Here, <literal>?</literal> is used in the definition of the
        function to mark <literal>sep</literal> as optional. And while
        the caller can pass a value of type <literal>string</literal>
        for <literal>sep</literal>, internally to the function,
        <literal>sep</literal> is seen as a
        <literal>string option</literal>, with <literal>None</literal>
        appearing when <literal>sep</literal> is not provided by the
        caller.
      </para>
      <para>
        The above example needed a bit of boilerplate to choose a
        default separator when none was provided. This is a common
        enough pattern that there's an explicit syntax for providing a
        default value, which allows us to write
        <literal>concat</literal> more concisely.
      </para>
      <programlisting language="ocaml">
...part 50 of variables-and-functions/main.topscript
# let concat ?(sep=&quot;&quot;) x y = x ^ sep ^ y ;; 
val concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
</programlisting>
      <para>
        Optional arguments are very useful, but they're also easy to
        abuse. The key advantage of optional arguments is that they let
        you write functions with multiple arguments that users can
        ignore most of the time, only worrying about them when they
        specifically want to invoke those options. They also allow you
        to extend an API with new functionality without changing
        existing code that calls that function.
      </para>
      <para>
        The downside is that the caller may be unaware that there is a
        choice to be made, and so may unknowingly (and wrongly) pick the
        default behavior. Optional arguments really only make sense when
        the extra concision of omitting the argument outweighs the
        corresponding loss of explicitness.
      </para>
      <para>
        This means that rarely used functions should not have optional
        arguments. A good rule of thumb is to avoid optional arguments
        for functions internal to a module, <emphasis>i.e.</emphasis>,
        functions that are not included in the module's interface, or
        <literal>mli</literal> file. We'll learn more about
        <literal>mli</literal>s in
        <xref linkend="files-modules-and-programs"/>.
      </para>
      <sect3 id="explicit-passing-of-an-optional-argument">
        <title>Explicit passing of an optional argument</title>
        <para>
          Under the covers, a function with an optional argument
          receives <literal>None</literal> when the caller doesn't
          provide the argument, and <literal>Some</literal> when it
          does. But the <literal>Some</literal> and
          <literal>None</literal> are normally not explicitly passed in
          by the caller.
        </para>
        <para>
          But sometimes, passing in <literal>Some</literal> or
          <literal>None</literal> explicitly is exactly what you want.
          OCaml lets you do this by using <literal>?</literal> instead
          of <literal>~</literal> to mark the argument. Thus, the
          following two lines are equivalent ways of specifying the
          <literal>sep</literal> argument to concat.
        </para>
        <programlisting language="ocaml">
...part 51 of variables-and-functions/main.topscript
# concat ~sep:&quot;:&quot; &quot;foo&quot; &quot;bar&quot; (* provide the optional argument *);; 
- : string = &quot;foo:bar&quot;
# concat ?sep:(Some &quot;:&quot;) &quot;foo&quot; &quot;bar&quot; (* pass an explicit [Some] *);; 
- : string = &quot;foo:bar&quot;
</programlisting>
        <para>
          And the following two lines are equivalent ways of calling
          <literal>concat</literal> without specifying
          <literal>sep</literal>.
        </para>
        <programlisting language="ocaml">
...part 52 of variables-and-functions/main.topscript
# concat &quot;foo&quot; &quot;bar&quot; (* don't provide the optional argument *);; 
- : string = &quot;foobar&quot;
# concat ?sep:None &quot;foo&quot; &quot;bar&quot; (* explicitly pass `None` *);; 
- : string = &quot;foobar&quot;
</programlisting>
        <para>
          One use-case for this is when you want to define a wrapper
          function that mimics the optional arguments of the function
          it's wrapping. For example, imagine we wanted to create a
          function called <literal>uppercase_concat</literal>, which is
          the same as <literal>concat</literal> except that it converts
          the first string that it's passed to uppercase. We could write
          the function as follows.
        </para>
        <programlisting language="ocaml">
...part 53 of variables-and-functions/main.topscript
# let uppercase_concat ?(sep=&quot;&quot;) a b = concat ~sep (String.uppercase a) b ;; 
val uppercase_concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
# uppercase_concat &quot;foo&quot; &quot;bar&quot;;; 
- : string = &quot;FOObar&quot;
# uppercase_concat &quot;foo&quot; &quot;bar&quot; ~sep:&quot;:&quot;;; 
- : string = &quot;FOO:bar&quot;
</programlisting>
        <para>
          In the way we've written it, we've been forced to separately
          make the decision as to what the default separator is. Thus,
          if we later change <literal>concat</literal>'s default
          behavior, we'll need to remember to change
          <literal>uppercase_concat</literal> to match it.
        </para>
        <para>
          Instead, we can have <literal>uppercase_concat</literal>
          simply pass through the optional argument to
          <literal>concat</literal> using the <literal>?</literal>
          syntax.
        </para>
        <programlisting language="ocaml">
...part 54 of variables-and-functions/main.topscript
# let uppercase_concat ?sep a b = concat ?sep (String.uppercase a) b ;; 
val uppercase_concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
</programlisting>
        <para>
          Now, if someone calls <literal>uppercase_concat</literal>
          without an argument, an explicit <literal>None</literal> will
          be passed to <literal>concat</literal>, leaving
          <literal>concat</literal> to decide what the default behavior
          should be.
        </para>
      </sect3>
      <sect3 id="inference-of-labeled-and-optional-arguments">
        <title>Inference of labeled and optional arguments</title>
        <para>
          One subtle aspect of labeled and optional arguments is how
          they are inferred by the type system. Consider the following
          example for computing numerical derivatives of a function of
          two dimensions. The function takes an argument
          <literal>delta</literal> which determines the scale at which
          to compute the derivative, values <literal>x</literal> and
          <literal>y</literal> which determine which point to compute
          the derivative at, and the function <literal>f</literal> whose
          derivative is being computed. The function
          <literal>f</literal> itself takes two labeled arguments
          <literal>x</literal> and <literal>y</literal>. Note that you
          can use an apostrophe as part of a variable name, so
          <literal>x'</literal> and <literal>y'</literal> are just
          ordinary variables.
        </para>
        <programlisting language="ocaml">
...part 55 of variables-and-functions/main.topscript
# let numeric_deriv ~delta ~x ~y ~f =
    let x' = x +. delta in
    let y' = y +. delta in
    let base = f ~x ~y in
    let dx = (f ~x:x' ~y -. base) /. delta in
    let dy = (f ~x ~y:y' -. base) /. delta in
    (dx,dy)
  ;; 
val numeric_deriv :
  delta:float -&gt;
  x:float -&gt; y:float -&gt; f:(x:float -&gt; y:float -&gt; float) -&gt; float * float =
  &lt;fun&gt;
</programlisting>
        <para>
          In principle, it's not obvious how the order of the arguments
          to <literal>f</literal> should be chosen. Since labeled
          arguments can be passed in arbitrary order, it seems like it
          could as well be
          <literal>y:float -&gt; x:float -&gt; float</literal> as it is
          <literal>x:float -&gt; y:float -&gt; float</literal>.
        </para>
        <para>
          Even worse, it would be perfectly consistent for
          <literal>f</literal> to take an optional argument instead of a
          labeled one, which could lead to this type signature for
          <literal>numeric_deriv</literal>.
        </para>
        <programlisting language="ocaml">
(* variables-and-functions/numerical_deriv_alt_sig.mli  *)
val numeric_deriv :
  delta:float -&gt;
  x:float -&gt; y:float -&gt; f:(?x:float -&gt; y:float -&gt; float) -&gt; float * float
</programlisting>
        <para>
          Since there are multiple plausible types to choose from, OCaml
          needs some heuristic for choosing between them. The heuristic
          the compiler uses is to prefer labels to options, and to
          choose the order of arguments that shows up in the source
          code.
        </para>
        <para>
          Note that these heuristics might at different points in the
          source suggest different types. Here's a version of
          <literal>numeric_deriv</literal> where different invocations
          of <literal>f</literal> list the arguments in different
          orders.
        </para>
        <programlisting language="ocaml">
...part 56 of variables-and-functions/main.topscript
# let numeric_deriv ~delta ~x ~y ~f =
    let x' = x +. delta in
    let y' = y +. delta in
    let base = f ~x ~y in
    let dx = (f ~y ~x:x' -. base) /. delta in
    let dy = (f ~x ~y:y' -. base) /. delta in
    (dx,dy)
  ;; 
Characters 130-131:
Error: This function is applied to arguments
in an order different from other calls.
This is only allowed when the real type is known.
</programlisting>
        <para>
          As suggested by the error message, we can get OCaml to accept
          the fact that <literal>f</literal> is used with different
          argument orders if we provide explicit type information. Thus,
          the following code compiles without error, due to the type
          annotation on <literal>f</literal>.
        </para>
        <programlisting language="ocaml">
...part 57 of variables-and-functions/main.topscript
# let numeric_deriv ~delta ~x ~y ~(f: x:float -&gt; y:float -&gt; float) =
    let x' = x +. delta in
    let y' = y +. delta in
    let base = f ~x ~y in
    let dx = (f ~y ~x:x' -. base) /. delta in
    let dy = (f ~x ~y:y' -. base) /. delta in
    (dx,dy)
  ;; 
val numeric_deriv :
  delta:float -&gt;
  x:float -&gt; y:float -&gt; f:(x:float -&gt; y:float -&gt; float) -&gt; float * float =
  &lt;fun&gt;
</programlisting>
      </sect3>
      <sect3 id="optional-arguments-and-partial-application">
        <title>Optional arguments and partial application</title>
        <para>
          Optional arguments can be tricky to think about in the
          presence of partial application. We can of course partially
          apply the optional argument itself:
        </para>
        <programlisting language="ocaml">
...part 58 of variables-and-functions/main.topscript
# let colon_concat = concat ~sep:&quot;:&quot;;; 
val colon_concat : string -&gt; string -&gt; string = &lt;fun&gt;
# colon_concat &quot;a&quot; &quot;b&quot;;; 
- : string = &quot;a:b&quot;
</programlisting>
        <para>
          But what happens if we partially apply just the first
          argument?
        </para>
        <programlisting language="ocaml">
...part 59 of variables-and-functions/main.topscript
# let prepend_pound = concat &quot;# &quot;;; 
val prepend_pound : string -&gt; string = &lt;fun&gt;
# prepend_pound &quot;a BASH comment&quot;;; 
- : string = &quot;# a BASH comment&quot;
</programlisting>
        <para>
          The optional argument <literal>?sep</literal> has now
          disappeared, or been <emphasis>erased</emphasis>. Indeed, if
          we try to pass in that optional argument now, it will be
          rejected.
        </para>
        <programlisting language="ocaml">
...part 60 of variables-and-functions/main.topscript
# prepend_pound &quot;a BASH comment&quot; ~sep:&quot;:&quot;;; 
Characters -1-13:
Error: This function has type string -&gt; string
       It is applied to too many arguments; maybe you forgot a `;'.
</programlisting>
        <para>
          So when does OCaml decide to erase an optional argument?
        </para>
        <para>
          The rule is: an optional argument is erased as soon as the
          first positional (<emphasis>i.e.</emphasis>, neither labeled
          nor optional) argument defined <emphasis>after</emphasis> the
          optional argument is passed in. That explains the behavior of
          <literal>prepend_pound</literal> above. But if we had instead
          defined <literal>concat</literal> with the optional argument
          in the second position:
        </para>
        <programlisting language="ocaml">
...part 61 of variables-and-functions/main.topscript
# let concat x ?(sep=&quot;&quot;) y = x ^ sep ^ y ;; 
val concat : string -&gt; ?sep:string -&gt; string -&gt; string = &lt;fun&gt;
</programlisting>
        <para>
          then application of the first argument would not cause the
          optional argument to be erased.
        </para>
        <programlisting language="ocaml">
...part 62 of variables-and-functions/main.topscript
# let prepend_pound = concat &quot;# &quot;;; 
val prepend_pound : ?sep:string -&gt; string -&gt; string = &lt;fun&gt;
# prepend_pound &quot;a BASH comment&quot;;; 
- : string = &quot;# a BASH comment&quot;
# prepend_pound &quot;a BASH comment&quot; ~sep:&quot;--- &quot;;; 
- : string = &quot;# --- a BASH comment&quot;
</programlisting>
        <para>
          However, if all arguments to a function are presented at once,
          then erasure of optional arguments isn't applied until all of
          the arguments are passed in. This preserves our ability to
          pass in optional arguments anywhere on the argument list.
          Thus, we can write:
        </para>
        <programlisting language="ocaml">
...part 63 of variables-and-functions/main.topscript
# concat &quot;a&quot; &quot;b&quot; ~sep:&quot;=&quot;;; 
- : string = &quot;a=b&quot;
</programlisting>
        <para>
          An optional argument that doesn't have any following
          positional arguments can't be erased at all, which leads to a
          compiler warning.
        </para>
        <programlisting language="ocaml">
...part 64 of variables-and-functions/main.topscript
# let concat x y ?(sep=&quot;&quot;) = x ^ sep ^ y ;; 

Characters 15-38:
Warning 16: this optional argument cannot be erased.
val concat : string -&gt; string -&gt; ?sep:string -&gt; string = &lt;fun&gt;
</programlisting>
        <para>
          And indeed, when we provide the two positional arguments, the
          <literal>sep</literal> argument is not erased, instead
          returning a function that expects the <literal>sep</literal>
          argument to be provided.
        </para>
        <programlisting language="ocaml">
...part 65 of variables-and-functions/main.topscript
# concat &quot;a&quot; &quot;b&quot;;; 
- : ?sep:string -&gt; string = &lt;fun&gt;
</programlisting>
      </sect3>
    </sect2>
  </sect1>
</chapter><chapter id="lists-and-patterns">
  <title>Lists and Patterns</title>
  <para>
    This chapter will focus on two common elements of programming in
    OCaml: lists and pattern matching. Both of these were discussed in
    <xref linkend="a-guided-tour"/>, but we'll go into more
    depth here, presenting the two topics together and using one to help
    illustrate the other.
  </para>
  <sect1 id="list-basics">
    <title>List basics</title>
    <para>
      An OCaml list is an immutable, finite sequence of elements of the
      same type. As we've seen, OCaml lists can be generated using a
      bracket-and-semicolon notation:
    </para>
    <programlisting language="ocaml">
# script lists-and-patterns/main.topscript
$ utop
# [1;2;3];; 
- : int list = [1; 2; 3]
</programlisting>
    <para>
      And they can also be generated using the equivalent
      <literal>::</literal> notation.
    </para>
    <programlisting language="ocaml">
...part 1 of lists-and-patterns/main.topscript
# 1 :: (2 :: (3 :: [])) ;; 
- : int list = [1; 2; 3]
</programlisting>
    <para>
      As you can see, the <literal>::</literal> operator is
      right-associative, which means that we can build up lists without
      parentheses. The empty list <literal>[]</literal> is used to
      terminate a list. Note that the empty list is polymorphic, meaning
      it can be used with elements of any type.
    </para>
    <programlisting language="ocaml">
...part 2 of lists-and-patterns/main.topscript
# let empty = [];; 
val empty : 'a list = []
# 3 :: empty;; 
- : int list = [3]
# &quot;three&quot; :: empty;; 
- : string list = [&quot;three&quot;]
</programlisting>
    <para>
      The <literal>::</literal> operator conveys something important
      about the nature of lists, which is that they are implemented as
      singly-linked lists. The following is a rough graphical
      representation of how the list
      <literal>1 :: 2 :: 3 :: []</literal> is laid out as a
      data-structure. The final arrow (from the box containing
      <literal>3</literal>) points to the empty list.
    </para>
    <programlisting>
+---+---+   +---+---+   +---+---+
| 1 | *----&gt;| 2 | *----&gt;| 3 | *----&gt;||
+---+---+   +---+---+   +---+---+
</programlisting>
    <para>
      Each <literal>::</literal> essentially adds a new block to the
      picture above. Such a block contains two things: a reference to
      the data in that list element, and a reference to the remainder of
      the list. This is why <literal>::</literal> can extend a list
      without modifying it; extension allocates a new list element but
      doesn't need to change any of the existing ones, as you can see:
    </para>
    <programlisting language="ocaml">
...part 3 of lists-and-patterns/main.topscript
# let l = 1 :: 2 :: 3 :: [];; 
val l : int list = [1; 2; 3]
# let m = 0 :: l;; 
val m : int list = [0; 1; 2; 3]
# l;; 
- : int list = [1; 2; 3]
</programlisting>
  </sect1>
  <sect1 id="using-patterns-to-extract-data-from-a-list">
    <title>Using patterns to extract data from a list</title>
    <para>
      We can read data out of a list using a match statement. Here's a
      simple example of a recursive function that computes the sum of
      all elements of a list.
    </para>
    <programlisting language="ocaml">
...part 4 of lists-and-patterns/main.topscript
# let rec sum l =
    match l with
    | [] -&gt; 0
    | hd :: tl -&gt; hd + sum tl
  ;; 
val sum : int list -&gt; int = &lt;fun&gt;
# sum [1;2;3];;  
sum []
;; 
- : int = 6
</programlisting>
    <para>
      This code follows the convention of using <literal>hd</literal> to
      represent the first element (or head) of the list, and
      <literal>tl</literal> to represent the remainder (or tail).
    </para>
    <para>
      The match statement in <literal>sum</literal> is really doing two
      things: first, it's acting as a case-analysis tool, breaking down
      the possibilities into a pattern-indexed list of cases. Second, it
      lets you name sub-structures within the data-structure being
      matched. In this case, the variables <literal>hd</literal> and
      <literal>tl</literal> are bound by the pattern that defines the
      first case of the match statement. Variables that are bound in
      this way can be used in the expression to the right of the arrow
      for the pattern in question.
    </para>
    <para>
      The fact that match statements can be used to bind new variables
      can be a source of confusion. To see how, imagine we wanted to
      write a function that filtered out from a list all elements equal
      to a particular value. You might be tempted to write that code as
      follows, but when you do, the compiler will immediately warn you
      that something is wrong.
    </para>
    <programlisting language="ocaml">
...part 5 of lists-and-patterns/main.topscript
# let rec drop_value l to_drop =
    match l with
    | [] -&gt; []
    | to_drop :: tl -&gt; drop_value tl to_drop
    | hd :: tl -&gt; hd :: drop_value tl to_drop
  ;; 

Characters 114-122:
Warning 11: this match case is unused.
val drop_value : 'a list -&gt; 'a -&gt; 'a list = &lt;fun&gt;
</programlisting>
    <para>
      Moreover, the function clearly does the wrong thing, filtering out
      all elements of the list rather than just those equal to the
      provided value, as you can see below.
    </para>
    <programlisting language="ocaml">
...part 6 of lists-and-patterns/main.topscript
# drop_value [1;2;3] 2;; 
- : int list = []
</programlisting>
    <para>
      So, what's going on?
    </para>
    <para>
      The key observation is that the appearance of
      <literal>to_drop</literal> in the second case doesn't imply a
      check that the first element is equal to the value
      <literal>to_drop</literal> passed in as an argument to
      <literal>drop_value</literal>. Instead, it just causes a new
      variable <literal>to_drop</literal> to be bound to whatever
      happens to be in the first element of the list, shadowing the
      earlier definition of <literal>to_drop</literal>. The third case
      is unused because it is essentially the same pattern as we had in
      the second case.
    </para>
    <para>
      A better way to write this code is not to use pattern matching for
      determining whether the first element is equal to
      <literal>to_drop</literal>, but to instead use an ordinary
      if-statement.
    </para>
    <programlisting language="ocaml">
...part 7 of lists-and-patterns/main.topscript
# let rec drop_value l to_drop =
    match l with
    | [] -&gt; []
    | hd :: tl -&gt;
      let new_tl = drop_value tl to_drop in
      if hd = to_drop then new_tl else hd :: new_tl
  ;; 
val drop_value : 'a list -&gt; 'a -&gt; 'a list = &lt;fun&gt;
# drop_value [1;2;3] 2;; 
- : int list = [1; 3]
</programlisting>
    <para>
      Note that if we wanted to drop a particular literal value (rather
      than a value that was passed in), we could do this using something
      like our original implementation of <literal>drop_value</literal>.
    </para>
    <programlisting language="ocaml">
...part 8 of lists-and-patterns/main.topscript
# let rec drop_zero l =
    match l with
    | [] -&gt; []
    | 0  :: tl -&gt; drop_zero tl
    | hd :: tl -&gt; hd :: drop_zero tl
  ;; 
val drop_zero : int list -&gt; int list = &lt;fun&gt;
# drop_zero [1;2;0;3];; 
- : int list = [1; 2; 3]
</programlisting>
  </sect1>
  <sect1 id="limitations-and-blessings-of-pattern-matching">
    <title>Limitations (and blessings) of pattern matching</title>
    <para>
      The above example highlights an important fact about patterns,
      which is that they can't be used to express arbitrary conditions.
      Patterns can characterize the layout of a data-structure, and can
      even include literals as in the <literal>drop_zero</literal>
      example, but that's where they stop. A pattern can check if a list
      has two elements, but it can't check if the first two elements are
      equal to each other.
    </para>
    <para>
      You can think of patterns as a specialized sub-language that can
      express a limited (though still quite rich) set of conditions. The
      fact that the pattern language is limited turns out to be a very
      good thing, making it possible to build better support for
      patterns in the compiler. In particular, both the efficiency of
      match statements and the ability of the compiler to detect errors
      in matches depend on the constrained nature of patterns.
    </para>
    <sect2 id="performance">
      <title>Performance</title>
      <para>
        Naively, you might think that it would be necessary to check
        each case in a <literal>match</literal> in sequence to figure
        out which one fires. If the cases of a match were guarded by
        arbitrary code, that would be the case. But OCaml is often able
        to generate machine code that jumps directly to the matched case
        based on an efficiently chosen set of runtime checks.
      </para>
      <para>
        As an example, consider the following rather silly functions for
        incrementing an integer by one. The first is implemented with a
        match statement, and the second with a sequence of if
        statements.
      </para>
      <programlisting language="ocaml">
...part 9 of lists-and-patterns/main.topscript
# let plus_one_match x =
    match x with
    | 0 -&gt; 1
    | 1 -&gt; 2
    | 2 -&gt; 3
    | _ -&gt; x + 1

  let plus_one_if x =
    if      x = 0 then 1
    else if x = 1 then 2
    else if x = 2 then 3
    else x + 1
  ;; 
val plus_one_match : int -&gt; int = &lt;fun&gt;
val plus_one_if : int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        Note the use of <literal>_</literal> in the above match. This is
        a wild-card pattern that matches any value, but without binding
        a variable name to the value in question.
      </para>
      <para>
        If you benchmark these functions, you'll see that
        <literal>plus_one_if</literal> is considerably slower than
        <literal>plus_one_match</literal>, and the advantage gets larger
        as the number of cases increases. Here, we'll benchmark these
        functions using the <literal>core_bench</literal> library, which
        can be installed by running
        <literal>opam install core_bench</literal> from the
        command-line.
      </para>
      <programlisting language="ocaml">
...part 10 of lists-and-patterns/main.topscript
# #require &quot;core_bench&quot;;; 

/home/rwo/.opam/4.01.0dev+trunk/lib/textutils: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/textutils/textutils.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/core_bench: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/core_bench/core_bench.cma: loaded
# open Core_bench.Std;; 
# let run_bench tests =
  Bench.bench
    ~ascii_table:true
    ~display:Textutils.Ascii_table.Display.column_titles 
    tests
;; 
val run_bench : Bench.Test.t list -&gt; unit = &lt;fun&gt;
# [ Bench.Test.create ~name:&quot;plus_one_match&quot; (fun () -&gt;
      ignore (plus_one_match 10))
  ; Bench.Test.create ~name:&quot;plus_one_if&quot; (fun () -&gt;
      ignore (plus_one_if 10)) ]
  |&gt; run_bench
  ;; 

Estimated testing time 20s (change using -quota SECS).
                                         
  Name             Time (ns)   % of max  
 ---------------- ----------- ---------- 
  plus_one_match       46.81      68.21  
  plus_one_if          68.63     100.00  
                                         
- : unit = ()
</programlisting>
      <para>
        Here's another less artificial example. We can rewrite the
        <literal>sum</literal> function we described earlier in the
        chapter using an <literal>if</literal> statement rather than a
        match. We can then use the functions
        <literal>is_empty</literal>, <literal>hd_exn</literal> and
        <literal>tl_exn</literal> from the <literal>List</literal>
        module to deconstruct the list, allowing us to implement the
        entire function without pattern matching.
      </para>
      <programlisting language="ocaml">
...part 11 of lists-and-patterns/main.topscript
# let rec sum_if l =
    if List.is_empty l then 0
    else List.hd_exn l + sum_if (List.tl_exn l)
  ;; 
val sum_if : int list -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        Again, we can benchmark these to see the difference.
      </para>
      <programlisting language="ocaml">
...part 12 of lists-and-patterns/main.topscript
# let numbers = List.range 0 1000 in
  [ Bench.Test.create ~name:&quot;sum_if&quot; (fun () -&gt; ignore (sum_if numbers))
  ; Bench.Test.create ~name:&quot;sum&quot;    (fun () -&gt; ignore (sum numbers)) ]
  |&gt; run_bench
  ;; 

Estimated testing time 20s (change using -quota SECS).
                                 
  Name     Time (ns)   % of max  
 -------- ----------- ---------- 
  sum_if     110_533     100.00  
  sum         22_347      20.22  
                                 
- : unit = ()
</programlisting>
      <para>
        In this case, the <literal>match</literal>-based implementation
        is more than three times faster than the one using
        <literal>if</literal>. The difference comes because we need to
        effectively do the same work multiple times, since each function
        we call has to re-examine the first element of the list to
        determine whether or not it's the empty cell. With a match
        statement, this work happens exactly once per list element.
      </para>
      <para>
        Generally, pattern matching is more efficient than the
        alternatives you might code by hand. One notable exception is
        matches over strings, which are in fact tested sequentially, so
        matches containing a long sequence of strings can be
        outperformed by a hash table. But most of the time, pattern
        matching is a clear performance win.
      </para>
    </sect2>
    <sect2 id="detecting-errors">
      <title>Detecting errors</title>
      <para>
        The error-detecting capabilities of match statements are if
        anything more important than their performance. We've already
        seen one example of OCaml's ability to find problems in a
        pattern match: in our broken implementation of
        <literal>drop_value</literal>, OCaml warned us that the final
        case was redundant. There are no algorithms for determining if a
        predicate written in a general-purpose language is redundant,
        but it can be solved reliably in the context of patterns.
      </para>
      <para>
        OCaml also checks match statements for exhaustiveness. Consider
        what happens if we modify <literal>drop_zero</literal> by
        deleting the handler for one of the cases. As you can see, the
        compiler will produce a warning that we've missed a case, along
        with an example of an unmatched pattern.
      </para>
      <programlisting language="ocaml">
...part 13 of lists-and-patterns/main.topscript
# let rec drop_zero l =
    match l with
    | [] -&gt; []
    | 0  :: tl -&gt; drop_zero tl
  ;; 

Characters 26-84:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
1::_
val drop_zero : int list -&gt; 'a list = &lt;fun&gt;
</programlisting>
      <para>
        For simple examples like this, exhaustiveness checks are useful
        enough. But as we'll see in
        <xref linkend="variants"/>, as you get to more
        complicated examples, especially those involving user-defined
        types, exhaustiveness checks become a lot more valuable. In
        addition to catching outright errors, they act as a sort of
        refactoring tool, guiding you to the locations where you need to
        adapt your code to deal with changing types.
      </para>
    </sect2>
  </sect1>
  <sect1 id="using-the-list-module-effectively">
    <title>Using the <literal>List</literal> module effectively</title>
    <para>
      We've so far written a fair amount of list-munging code using
      pattern matching and recursive functions. But in real life, you're
      usually better off using the <literal>List</literal> module, which
      is full of reusable functions that abstract out common patterns
      for computing with lists.
    </para>
    <para>
      Let's work through a concrete example to see this in action. We'll
      write a function <literal>render_table</literal> that, given a
      list of column headers and a list of rows, prints them out in a
      well formatted text table, as follows.
    </para>
    <programlisting language="ocaml">
...part 69 of lists-and-patterns/main.topscript
# printf &quot;%s\n&quot;
   (render_table
     [&quot;language&quot;;&quot;architect&quot;;&quot;first release&quot;]
     [ [&quot;Lisp&quot; ;&quot;John McCarthy&quot; ;&quot;1958&quot;] ;
       [&quot;C&quot;    ;&quot;Dennis Ritchie&quot;;&quot;1969&quot;] ;
       [&quot;ML&quot;   ;&quot;Robin Milner&quot;  ;&quot;1973&quot;] ;
       [&quot;OCaml&quot;;&quot;Xavier Leroy&quot;  ;&quot;1996&quot;] ;
     ]);; 

| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |
- : unit = ()
</programlisting>
    <para>
      The first step is to write a function to compute the maximum width
      of each column of data. We can do this by converting the header
      and each row into a list of integer lengths, and then taking the
      element-wise max of those lists of lengths. Writing the code for
      all of this directly would be a bit of a chore, but we can do it
      quite concisely by making use of three functions from the
      <literal>List</literal> module: <literal>map</literal>,
      <literal>map2_exn</literal>, and <literal>fold</literal>.
    </para>
    <para>
      <literal>List.map</literal> is the simplest to explain. It takes a
      list and a function for transforming elements of that list, and
      returns a new list with the transformed elements. Thus, we can
      write:
    </para>
    <programlisting language="ocaml">
...part 14 of lists-and-patterns/main.topscript
# List.map ~f:String.length [&quot;Hello&quot;; &quot;World!&quot;];; 
- : int list = [5; 6]
</programlisting>
    <para>
      <literal>List.map2_exn</literal> is similar to
      <literal>List.map</literal>, except that it takes two lists and a
      function for combining them. Thus, we might write:
    </para>
    <programlisting language="ocaml">
...part 15 of lists-and-patterns/main.topscript
# List.map2_exn ~f:Int.max [1;2;3] [3;2;1];; 
- : int list = [3; 2; 3]
</programlisting>
    <para>
      The <literal>_exn</literal> is there because the function throws
      an exception if the lists are of mismatched length.
    </para>
    <programlisting language="ocaml">
...part 16 of lists-and-patterns/main.topscript
# List.map2_exn ~f:Int.max [1;2;3] [3;2;1;0];; 
Exception: (Invalid_argument &quot;length mismatch in rev_map2_exn: 3 &lt;&gt; 4 &quot;).
</programlisting>
    <para>
      <literal>List.fold</literal> is the most complicated of the three,
      taking three arguments: a list to process, an initial accumulator
      value, and a function for updating the accumulator with the
      information from a list element. <literal>List.fold</literal>
      walks over the list from left to right, updating the accumulator
      at each step and returning the final value of the accumulator when
      it's done. You can see some of this by looking at the
      type-signature for <literal>fold</literal>.
    </para>
    <programlisting language="ocaml">
...part 17 of lists-and-patterns/main.topscript
# List.fold;; 
- : 'a list -&gt; init:'accum -&gt; f:('accum -&gt; 'a -&gt; 'accum) -&gt; 'accum = &lt;fun&gt;
</programlisting>
    <para>
      We can use <literal>List.fold</literal> for something as simple as
      summing up a list:
    </para>
    <programlisting language="ocaml">
...part 18 of lists-and-patterns/main.topscript
# List.fold ~init:0 ~f:(+) [1;2;3;4];; 
- : int = 10
</programlisting>
    <para>
      This example is particularly simple because the accumulator and
      the list elements are of the same type. But
      <literal>fold</literal> is not limited to such cases. We can for
      example use <literal>fold</literal> to reverse a list, in which
      case the accumulator is itself a list.
    </para>
    <programlisting language="ocaml">
...part 19 of lists-and-patterns/main.topscript
# List.fold ~init:[] ~f:(fun list x -&gt; x :: list) [1;2;3;4];; 
- : int list = [4; 3; 2; 1]
</programlisting>
    <para>
      Let's bring our three functions together to compute the maximum
      column widths.
    </para>
    <programlisting language="ocaml">
...part 20 of lists-and-patterns/main.topscript
# let max_widths header rows =
    let lengths l = List.map ~f:String.length l in
    List.fold rows
      ~init:(lengths header)
      ~f:(fun acc row -&gt;
        List.map2_exn ~f:Int.max acc (lengths row))
  ;; 
val max_widths : string list -&gt; string list list -&gt; int list = &lt;fun&gt;
</programlisting>
    <para>
      Using <literal>List.map</literal> we define the function
      <literal>lengths</literal> which converts a list of strings to a
      list of integer lengths. <literal>List.fold</literal> is then used
      to iterate over the rows, using <literal>map2_exn</literal> to
      take the max of the accumulator with the lengths of the strings in
      each row of the table, with the accumulator initialized to the
      lengths of the header row.
    </para>
    <para>
      Now that we know how to compute column widths, we can write the
      code to generate the line that separates the header from the rest
      of the text table. We'll do this in part by mapping
      <literal>String.make</literal> over the lengths of the columns to
      generate a string of dashes of the appropriate length. We'll then
      join these sequences of dashes together using
      <literal>String.concat</literal>, which concatenates a list of
      strings with an optional separator string, and
      <literal>^</literal>, which is a pairwise string concatenation
      function, to add the delimiters on the outside.
    </para>
    <programlisting language="ocaml">
...part 21 of lists-and-patterns/main.topscript
# let render_separator widths =
    let pieces = List.map widths
      ~f:(fun w -&gt; String.make (w + 2) '-')
    in
    &quot;|&quot; ^ String.concat ~sep:&quot;+&quot; pieces ^ &quot;|&quot;
  ;; 
val render_separator : int list -&gt; string = &lt;fun&gt;
# render_separator [3;6;2];; 
- : string = &quot;|-----+--------+----|&quot;
</programlisting>
    <para>
      Note that we make the line of dashes two larger than the provided
      width to provide some whitespace around each entry in the table.
    </para>
    <note>
    <title>
    Performance of <literal>String.concat</literal> and
    <literal>^</literal>
    </title>
    <para>
      In the above, we're using two different ways of concatenating
      strings, <literal>String.concat</literal>, which operates on lists
      of strings, and <literal>^</literal>, which is a pairwise
      operator. You should avoid <literal>^</literal> for joining long
      numbers of strings, since, it allocates a new string every time it
      runs. Thus, the following code:
    </para>
    <programlisting language="ocaml">
...part 22 of lists-and-patterns/main.topscript
# let s = &quot;.&quot; ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;;; 
val s : string = &quot;.......&quot;
</programlisting>
    <para>
      will allocate strings of length 2, 3, 4, 5, 6 and 7, whereas this
      code:
    </para>
    <programlisting language="ocaml">
...part 23 of lists-and-patterns/main.topscript
# let s = String.concat [&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;];; 
val s : string = &quot;.......&quot;
</programlisting>
    <para>
      allocates one string of size 7, as well as a list of length 7. At
      these small sizes, the differences don't amount to much, but for
      assembling of large strings, it can be a serious performance
      issue.
    </para>
    </note>
    <para>
      Now we need code for rendering a row with data in it. We'll first
      write a function <literal>pad</literal> for padding out a string
      to a specified length plus one blank space on either side.
    </para>
    <programlisting language="ocaml">
...part 24 of lists-and-patterns/main.topscript
# let pad s length =
    &quot; &quot; ^ s ^ String.make (length - String.length s + 1) ' '
  ;; 
val pad : string -&gt; int -&gt; string = &lt;fun&gt;
# pad &quot;hello&quot; 10;; 
- : string = &quot; hello      &quot;
</programlisting>
    <para>
      We can render a row of data by merging together the padded
      strings. Again, we'll use <literal>List.map2_exn</literal> for
      combining the list of data in the row with the list of widths.
    </para>
    <programlisting language="ocaml">
...part 25 of lists-and-patterns/main.topscript
# let render_row row widths =
    let padded = List.map2_exn row widths ~f:pad in
    &quot;|&quot; ^ String.concat ~sep:&quot;|&quot; padded ^ &quot;|&quot;
  ;; 
val render_row : string list -&gt; int list -&gt; string = &lt;fun&gt;
# render_row [&quot;Hello&quot;;&quot;World&quot;] [10;15];; 
- : string = &quot;| Hello      | World           |&quot;
</programlisting>
    <para>
      Now we can bring this all together in a single function that
      renders the table.
    </para>
    <programlisting language="ocaml">
...part 26 of lists-and-patterns/main.topscript
# let render_table header rows =
    let widths = max_widths header rows in
    String.concat ~sep:&quot;\n&quot;
      (render_row header widths
       :: render_separator widths
       :: List.map rows ~f:(fun row -&gt; render_row row widths)
      )
  ;; 
val render_table : string list -&gt; string list list -&gt; string = &lt;fun&gt;
</programlisting>
    <sect2 id="more-useful-list-functions">
      <title>More useful list functions</title>
      <para>
        The example we worked through above only touched on three of the
        function in <literal>List</literal>. We won't cover the entire
        interface, but there are a few more functions that are useful
        enough to mention here.
      </para>
      <sect3 id="combining-list-elements-with-list.reduce">
        <title>Combining list elements with
        <literal>List.reduce</literal></title>
        <para>
          <literal>List.fold</literal>, which we described earlier, is a
          very general and powerful function. Sometimes, however, you
          want something more that's simpler and thereby easier to use.
          One such function is <literal>List.reduce</literal>, which is
          essentially a specialized version of
          <literal>List.fold</literal> that doesn't require an explicit
          starting value, and whose accumulator has to consume and
          produce values of the same type as the elements of the list it
          applies to.
        </para>
        <para>
          Here's the type signature:
        </para>
        <programlisting language="ocaml">
...part 27 of lists-and-patterns/main.topscript
# List.reduce;; 
- : 'a list -&gt; f:('a -&gt; 'a -&gt; 'a) -&gt; 'a option = &lt;fun&gt;
</programlisting>
        <para>
          <literal>reduce</literal> returns an optional result,
          returning <literal>None</literal> when the input list is
          empty.
        </para>
        <para>
          Now we can see reduce in action.
        </para>
        <programlisting language="ocaml">
...part 28 of lists-and-patterns/main.topscript
# List.reduce ~f:(+) [1;2;3;4;5];; 
- : int option = Some 15
# List.reduce ~f:(+) [];; 
- : int option = None
</programlisting>
      </sect3>
      <sect3 id="filtering-with-list.filter-and-list.filter_map">
        <title>Filtering with <literal>List.filter</literal> and
        <literal>List.filter_map</literal></title>
        <para>
          Very often when processing lists, one wants to restrict
          attention to just a subset of values. The
          <literal>List.filter</literal> function does just that.
        </para>
        <programlisting language="ocaml">
...part 29 of lists-and-patterns/main.topscript
# List.filter ~f:(fun x -&gt; x mod 2 = 0) [1;2;3;4;5];; 
- : int list = [2; 4]
</programlisting>
        <para>
          Note that the <literal>mod</literal> used above is an infix
          operator, as described in
          <xref linkend="variables-and-functions"/>.
        </para>
        <para>
          Sometimes, you want to both transform and filter as part of
          the same computation. <literal>List.filter_map</literal>
          allows you to do just that. The function passed to
          <literal>List.filter_map</literal> returns an optional value,
          and <literal>List.filter_map</literal> drops all elements for
          which <literal>None</literal> is returned.
        </para>
        <para>
          Here's an example. The following expression computes the list
          of file extensions in the current directory, piping the
          results through <literal>List.dedup</literal> to remove
          duplicates. Note that this example also uses some functions
          from other modules, including <literal>Sys.ls_dir</literal> to
          get a directory listing, and <literal>String.rsplit2</literal>
          to split a string on the rightmost appearance of a given
          character.
        </para>
        <programlisting language="ocaml">
...part 30 of lists-and-patterns/main.topscript
# List.filter_map (Sys.ls_dir &quot;.&quot;) ~f:(fun fname -&gt;
    match String.rsplit2 ~on:'.' fname with
    | None  | Some (&quot;&quot;,_) -&gt; None
    | Some (_,ext) -&gt;
      Some ext)
  |&gt; List.dedup
  ;; 
- : string list = [&quot;ascii&quot;; &quot;ml&quot;; &quot;mli&quot;; &quot;topscript&quot;]
</programlisting>
        <para>
          The above is also an example of an or-patterns, which allows
          you to have multiple sub-patterns within a larger pattern. In
          this case, <literal>None | Some (&quot;&quot;,_)</literal> is
          an or-pattern. As we'll see later, or-patterns can be nested
          anywhere within larger patterns.
        </para>
      </sect3>
      <sect3 id="partitioning-with-list.partition_tf">
        <title>Partitioning with
        <literal>List.partition_tf</literal></title>
        <para>
          Another function that is similar to <literal>filter</literal>
          is <literal>partition_tf</literal>, which takes a list and
          partitions it into a pair of lists based on a boolean
          condition. <literal>tf</literal> is a mnemonic to remind the
          reader that <literal>true</literal> elements go to the first
          bucket and <literal>false</literal> ones go to the second.
          Thus, one could write:
        </para>
        <programlisting language="ocaml">
...part 31 of lists-and-patterns/main.topscript
# let is_ocaml_source s =
    match String.rsplit2 s ~on:'.' with
    | Some (_,(&quot;ml&quot;|&quot;mli&quot;)) -&gt; true
    | _ -&gt; false
  ;; 
val is_ocaml_source : string -&gt; bool = &lt;fun&gt;
# let (ml_files,other_files) =
    List.partition_tf (Sys.ls_dir &quot;.&quot;)  ~f:is_ocaml_source;; 
val ml_files : string list = [&quot;example.mli&quot;; &quot;example.ml&quot;]
val other_files : string list = [&quot;main.topscript&quot;; &quot;lists_layout.ascii&quot;]
</programlisting>
        <para>
          Note the use of a nested or-pattern in
          <literal>is_ocaml_source</literal>.
        </para>
      </sect3>
      <sect3 id="combining-lists">
        <title>Combining lists</title>
        <para>
          Another very common operation on lists is concatenation. The
          list module actually comes with a few different ways of doing
          this. First, there's <literal>List.append</literal>, for
          concatenating a pair of lists.
        </para>
        <programlisting language="ocaml">
...part 32 of lists-and-patterns/main.topscript
# List.append [1;2;3] [4;5;6];; 
- : int list = [1; 2; 3; 4; 5; 6]
</programlisting>
        <para>
          There's also <literal>@</literal>, an operator equivalent of
          <literal>List.append</literal>.
        </para>
        <programlisting language="ocaml">
...part 33 of lists-and-patterns/main.topscript
# [1;2;3] @ [4;5;6];; 
- : int list = [1; 2; 3; 4; 5; 6]
</programlisting>
        <para>
          In addition, there is <literal>List.concat</literal>, for
          concatenating a list of lists.
        </para>
        <programlisting language="ocaml">
...part 34 of lists-and-patterns/main.topscript
# List.concat [[1;2];[3;4;5];[6];[]];; 
- : int list = [1; 2; 3; 4; 5; 6]
</programlisting>
        <para>
          Here's an example of using <literal>List.concat</literal>
          along with <literal>List.map</literal> to compute a recursive
          listing of a directory tree.
        </para>
        <programlisting language="ocaml">
...part 35 of lists-and-patterns/main.topscript
# let rec ls_rec s =
    if Sys.is_file_exn ~follow_symlinks:true s
    then [s]
    else
      Sys.ls_dir s
      |&gt; List.map ~f:(fun sub -&gt; ls_rec (s ^ &quot;/&quot; ^ sub))
      |&gt; List.concat
  ;; 
val ls_rec : string -&gt; string list = &lt;fun&gt;
# ls_rec &quot;.&quot;;; 
- : string list =
[&quot;./main.topscript&quot;; &quot;./example.mli&quot;; &quot;./example.ml&quot;; &quot;./lists_layout.ascii&quot;]
</programlisting>
        <para>
          The above combination of <literal>List.map</literal> and
          <literal>List.concat</literal> is common enough that there is
          a function <literal>List.concat_map</literal> that combines
          these into one, more efficient operation.
        </para>
        <programlisting language="ocaml">
...part 36 of lists-and-patterns/main.topscript
# let rec ls_rec s =
    if Sys.is_file_exn ~follow_symlinks:true s
    then [s]
    else
      Sys.ls_dir s
      |&gt; List.concat_map ~f:(fun sub -&gt; ls_rec (s ^/ sub))
  ;; 
val ls_rec : string -&gt; string list = &lt;fun&gt;
</programlisting>
        <para>
          Note that <literal>^/</literal> is an infix operator provided
          by Core for adding a new element to a string representing a
          file path. It is equivalent to Core's
          <literal>Filename.concat</literal>.
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="tail-recursion">
    <title>Tail recursion</title>
    <para>
      The only way to compute the length of an OCaml list is to walk the
      list from beginning to end. As a result, computing the length of a
      list takes time linear in the size of the list. Here's a simple
      function for doing so.
    </para>
    <programlisting language="ocaml">
...part 37 of lists-and-patterns/main.topscript
# let rec length = function
    | [] -&gt; 0
    | _ :: tl -&gt; 1 + length tl
  ;; 
val length : 'a list -&gt; int = &lt;fun&gt;
# length [1;2;3];; 
- : int = 3
</programlisting>
    <para>
      This looks simple enough, but you'll discover that this
      implementation runs into problems on very large lists. Here are
      some examples, using another useful function from the
      <literal>List</literal> module, <literal>List.init</literal>, to
      create the lists. <literal>List.init</literal> takes an integer
      <literal>n</literal> and a function <literal>f</literal> and
      creates a list of length <literal>n</literal> where the data for
      each element is created by calling <literal>f</literal> on the
      index of that element.
    </para>
    <programlisting language="ocaml">
...part 38 of lists-and-patterns/main.topscript
# let make_list n = List.init n ~f:(fun x -&gt; x);; 
val make_list : int -&gt; int list = &lt;fun&gt;
# make_list 10;
length (make_list 10_000_000);; 

Characters -1-12:
Warning 10: this expression should have type unit.
Characters -1-12:
Warning 10: this expression should have type unit.
Stack overflow during evaluation (looping recursion?).
</programlisting>
    <para>
      To understand what went wrong, you need to learn a bit more about
      how function calls work. Typically, a function call needs some
      space to keep track of information associated with the call, such
      as the arguments passed to the function, or the location of the
      code that needs to start executing when the function call is
      complete. To allow for nested function calls, this information is
      typically organized in a stack, where a new <emphasis>stack
      frame</emphasis> is allocated for each nested function call, and
      then deallocated when the function call is complete.
    </para>
    <para>
      And that's the problem with our call to <literal>length</literal>:
      it tried to allocate ten million stack frames, which exhausted the
      available stack space. Happily, there's a way around this problem.
      Consider the following alternative implementation.
    </para>
    <programlisting language="ocaml">
...part 39 of lists-and-patterns/main.topscript
# let rec length_plus_n l n =
    match l with
    | [] -&gt; n
    | _ :: tl -&gt; length_plus_n tl (n + 1)
  ;; 
val length_plus_n : 'a list -&gt; int -&gt; int = &lt;fun&gt;
# let length l = length_plus_n l 0 ;; 
val length : 'a list -&gt; int = &lt;fun&gt;
# length [1;2;3;4];; 
- : int = 4
</programlisting>
    <para>
      This implementation depends on a helper function,
      <literal>length_plus_n</literal>, that computes the length of a
      given list plus a given <literal>n</literal>. In practice,
      <literal>n</literal> acts as an accumulator in which the answer is
      built up, step by step. As a result, we can do the additions along
      the way rather than doing them as we unwind the nested sequence of
      function calls, as we did in our first implementation of
      <literal>length</literal>.
    </para>
    <para>
      The advantage of this approach is that the recursive call in
      <literal>length_plus_n</literal> is a <emphasis>tail
      call</emphasis>. We'll explain more precisely what it means to be
      a tail call shortly, but the reason it's important is that tail
      calls don't require the allocation of a new stack frame, due to
      what is called the <emphasis>tail-call optimization</emphasis>. A
      recursive function is said to be <emphasis>tail
      recursive</emphasis> if all of its recursive calls are tail calls.
      <literal>length_plus_n</literal> is indeed tail recursive, and as
      a result, <literal>length</literal> can take a long list as input
      without blowing the stack.
    </para>
    <programlisting language="ocaml">
...part 40 of lists-and-patterns/main.topscript
# length (make_list 10_000_000);; 
- : int = 10000000
</programlisting>
    <para>
      So when is a call a tail call? Let's think about the situation of
      one function (the <emphasis>caller</emphasis>) invokes another
      (the <emphasis>callee</emphasis>). The invocation is considered a
      tail call when the caller doesn't do anything with the value
      returned by the callee except to return it. The tail-call
      optimization makes sense because, when a caller makes a tail call,
      the caller's stack frame need never be used again, and so you
      don't need to keep it around. Thus, instead of allocating a new
      stack frame for the callee, the compiler is free to reuse the
      caller's stack frame.
    </para>
    <para>
      Tail recursion is important for more than just lists. Ordinary
      (non-tail) recursive calls are reasonable when dealing with
      data-structures like binary trees where the depth of the tree is
      logarithmic in the size of your data. But when dealing with
      situations where the depth of the sequence of nested calls is on
      the order of the size of your data, tail recursion is usually the
      right approach.
    </para>
  </sect1>
  <sect1 id="more-concise-and-faster-patterns">
    <title>More concise and faster patterns</title>
    <para>
      Now that we know more about how lists and patterns work, let's
      consider how we can improve on an example from
      <xref linkend="recursive-list-functions"/>: the function
      <literal>destutter</literal>, which removes sequential duplicates
      from a list. Here's the implementation that was described earlier.
    </para>
    <programlisting language="ocaml">
...part 41 of lists-and-patterns/main.topscript
# let rec destutter list =
    match list with
    | [] -&gt; []
    | [hd] -&gt; [hd]
    | hd :: hd' :: tl -&gt;
      if hd = hd' then destutter (hd' :: tl)
      else hd :: destutter (hd' :: tl)
  ;; 
val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</programlisting>
    <para>
      We'll consider some ways of making this code more concise and more
      efficient.
    </para>
    <para>
      First, let's consider efficiency. One problem with the
      <literal>destutter</literal> code above is that it in some cases
      recreates on the right-hand side of the arrow a value that already
      existed on the left hand side. Thus, the pattern
      <literal>[hd] -&gt; [hd]</literal> actually allocates a new list
      element, which really, it should be able to just return the list
      being matched. We can reduce allocation here by using an
      <literal>as</literal> pattern, which allows us to declare a name
      for the thing matched by a pattern or sub-pattern. While we're at
      it, we'll use the <literal>function</literal> keyword to eliminate
      the need for an explicit match.
    </para>
    <programlisting language="ocaml">
...part 42 of lists-and-patterns/main.topscript
# let rec destutter = function
    | [] as l -&gt; l
    | [_] as l -&gt; l
    | hd :: (hd' :: _ as tl) -&gt;
      if hd = hd' then destutter tl
      else hd :: destutter tl
  ;; 
val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</programlisting>
    <para>
      We can further collapse this by combining the first two cases into
      one, using an or-pattern.
    </para>
    <programlisting language="ocaml">
...part 43 of lists-and-patterns/main.topscript
# let rec destutter = function
    | [] | [_] as l -&gt; l
    | hd :: (hd' :: _ as tl) -&gt;
      if hd = hd' then destutter tl
      else hd :: destutter tl
  ;; 
val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</programlisting>
    <para>
      We can make the code slightly terser now by using a
      <literal>when</literal> clause. A <literal>when</literal> clause
      allows one to add an extra precondition on a pattern in the form
      of an arbitrary OCaml expression. In this case, we can use it to
      include the check on whether the first two elements are equal.
    </para>
    <programlisting language="ocaml">
...part 44 of lists-and-patterns/main.topscript
# let rec destutter = function
    | [] | [_] as l -&gt; l
    | hd :: (hd' :: _ as tl) when hd = hd' -&gt; destutter tl
    | hd :: tl -&gt; hd :: destutter tl
  ;; 
val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</programlisting>
    <note> <title> 
    Polymorphic compare
    </title>
    <para>
      In the <literal>destutter</literal> example above, we made use of
      the fact that OCaml lets us test equality between values of any
      type, using the <literal>=</literal> operator. Thus, we can write:
    </para>
    <programlisting language="ocaml">
...part 45 of lists-and-patterns/main.topscript
# 3 = 4;; 
- : bool = false
# [3;4;5] = [3;4;5];; 
- : bool = true
# [Some 3; None] = [None; Some 3];; 
- : bool = false
</programlisting>
    <para>
      Indeed, if we look at the type of the equality operator, we'll see
      that it is polymorphic:
    </para>
    <programlisting language="ocaml">
...part 46 of lists-and-patterns/main.topscript
# (=);; 
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
</programlisting>
    <para>
      OCaml actually comes with a whole family of polymorphic comparison
      operators, including the standard infix comparators,
      <literal>&lt;</literal>, <literal>&gt;=</literal>,
      <emphasis>etc.</emphasis>, as well as the function
      <literal>compare</literal> that returns <literal>-1</literal>,
      <literal>0</literal> or <literal>1</literal> to flag whether the
      first operand is smaller than, equal to, or greater than the
      second, respectively.
    </para>
    <para>
      You might wonder how you could build functions like these yourself
      if OCaml didn't come with them built-in. It turns out that you
      <emphasis>can't</emphasis> build these functions on your own.
      OCaml's polymorphic comparison functions are actually built-in to
      the runtime to a low level. These comparisons are polymorphic on
      the basis of ignoring almost everything about the types of the
      values that are being compared, paying attention only to the
      structure of the values as they're laid out in memory.
    </para>
    <para>
      Polymorphic compare does have some limitations. For example, it
      will fail at runtime if it encounters a function value.
    </para>
    <programlisting language="ocaml">
...part 47 of lists-and-patterns/main.topscript
# (fun x -&gt; x + 1) = (fun x -&gt; x + 1);; 
Exception: (Invalid_argument &quot;equal: functional value&quot;).
</programlisting>
    <para>
      Similarly, it will fail on values that come from outside the OCaml
      heap, like values from C-bindings. But it will work in a
      reasonable way for other kinds of values.
    </para>
    <para>
      For simple atomic types, polymorphic compare has the semantics you
      would expect: for floating-point numbers and integer, polymorphic
      compare corresponds to the expected numerical comparison
      functions. For strings, it's a lexicographic comparison.
    </para>
    <para>
      Sometimes, however, the type-ignoring nature of polymorphic
      compare is a problem, particularly when you have your own notion
      of equality and ordering that you want to impose. We'll discuss
      this issue more, as well as some of the other downsides of
      polymorphic compare, in
      <xref linkend="maps-and-hash-tables"/>.
    </para>
    </note>

    <para>
      Note that <literal>when</literal> clauses have some downsides. As
      we noted earlier, the static checks associated with pattern
      matches rely on the fact that patterns are restricted in what they
      can express. Once we add the ability to add an arbitrary condition
      to a pattern, something will be lost. In particular, the ability
      for the compiler to determine if a match is exhaustive, or if some
      case is redundant, is compromised.
    </para>
    <para>
      Consider the following function which takes a list of optional
      values, and returns the number of those values that are
      <literal>Some</literal>. Because this implementation uses
      <literal>when</literal> clauses, the compiler can't tell that the
      code is exhaustive.
    </para>
    <programlisting language="ocaml">
...part 48 of lists-and-patterns/main.topscript
# let rec count_some list =
    match list with
    | [] -&gt; 0
    | x :: tl when Option.is_none x -&gt; count_some tl
    | x :: tl when Option.is_some x -&gt; 1 + count_some tl
  ;; 

Characters 30-169:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_
(However, some guarded clause may match this value.)
val count_some : 'a option list -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      Despite the warning, the function does work fine.
    </para>
    <programlisting language="ocaml">
...part 49 of lists-and-patterns/main.topscript
# count_some [Some 3; None; Some 4];; 
- : int = 2
</programlisting>
    <para>
      If we add another redundant case without a <literal>when</literal>
      clause, the compiler will stop complaining about exhaustiveness,
      and won't produce a warning about the redundancy.
    </para>
    <programlisting language="ocaml">
...part 50 of lists-and-patterns/main.topscript
# let rec count_some list =
    match list with
    | [] -&gt; 0
    | x :: tl when Option.is_none x -&gt; count_some tl
    | x :: tl when Option.is_some x -&gt; 1 + count_some tl
    | x :: tl -&gt; -1 (* unreachable *)
  ;; 
val count_some : 'a option list -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      Probably a better approach is to simply drop the second
      <literal>when</literal> clause.
    </para>
    <programlisting language="ocaml">
...part 51 of lists-and-patterns/main.topscript
# let rec count_some list =
    match list with
    | [] -&gt; 0
    | x :: tl when Option.is_none x -&gt; count_some tl
    | _ :: tl -&gt; 1 + count_some tl
  ;; 
val count_some : 'a option list -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      This is a little less clear, however, than the direct pattern
      matching solution, where the meaning of each pattern is clearer on
      its own.
    </para>
    <programlisting language="ocaml">
...part 52 of lists-and-patterns/main.topscript
# let rec count_some list =
    match list with
    | [] -&gt; 0
    | None   :: tl -&gt; count_some tl
    | Some _ :: tl -&gt; 1 + count_some tl
  ;; 
val count_some : 'a option list -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      The takeaway from all of this is that, while
      <literal>when</literal> clauses can be useful, one should prefer
      patterns wherever they are sufficient.
    </para>
    <para>
      As a side note, the above implementation of
      <literal>count_some</literal> is longer than necessary, and even
      worse is not tail recursive. In real life, you would probably just
      use the <literal>List.count</literal> function from
      <literal>Core</literal>:
    </para>
    <programlisting language="ocaml">
...part 53 of lists-and-patterns/main.topscript
# let count_some l = List.count ~f:Option.is_some l;; 
val count_some : 'a option list -&gt; int = &lt;fun&gt;
</programlisting>
  </sect1>
</chapter><chapter id="files-modules-and-programs">
  <title>Files, Modules and Programs</title>
  <para>
    We've so far experienced OCaml largely through the toplevel. As you
    move from exercises to real-world programs, you'll need to leave the
    toplevel behind and start building programs from files. Files are
    more than just a convenient way to store and manage your code; in
    OCaml, they also act as boundaries that divide your program into
    conceptual units.
  </para>
  <para>
    In this chapter, we'll show you how to build an OCaml program from a
    collection of files, as well as the basics of working with modules
    and module signatures.
  </para>
  <sect1 id="single-file-programs">
    <title>Single file programs</title>
    <para>
      We'll start with an example: a utility that reads lines from
      <literal>stdin</literal> and computes a frequency count of the
      lines that have been read in. At the end, the 10 lines with the
      highest frequency counts are written out. We'll start with a
      simple implementation, which we'll save as the file
      <literal>freq.ml</literal>.
    </para>
    <para>
      This implementation will use two functions from the
      <literal>List.Assoc</literal> module, which provides utility
      functions for interacting with association lists,
      <emphasis>i.e.</emphasis>, lists of key/value pairs. In
      particular, we use the function
      <literal>List.Assoc.find</literal>, which looks up a key in an
      association list, and <literal>List.add</literal>, which adds a
      new binding to an association list, as shown below.
    </para>
    <programlisting language="ocaml">
# script files-modules-and-programs/intro.topscript
$ utop
# let assoc = [(&quot;one&quot;, 1); (&quot;two&quot;,2); (&quot;three&quot;,3)] ;; 
val assoc : (string * int) list = [(&quot;one&quot;, 1); (&quot;two&quot;, 2); (&quot;three&quot;, 3)]
# List.Assoc.find assoc &quot;two&quot; ;; 
- : int option = Some 2
# List.Assoc.add assoc &quot;four&quot; 4 (* add a new key *) ;; 
- : (string, int) List.Assoc.t =
[(&quot;four&quot;, 4); (&quot;one&quot;, 1); (&quot;two&quot;, 2); (&quot;three&quot;, 3)]
# List.Assoc.add assoc &quot;two&quot;  4 (* overwrite an existing key *) ;; 
- : (string, int) List.Assoc.t = [(&quot;two&quot;, 4); (&quot;one&quot;, 1); (&quot;three&quot;, 3)]
</programlisting>
    <para>
      Note that <literal>List.Assoc.add</literal> doesn't modify the
      original list, but instead allocates a new list with the requisite
      key/value added.
    </para>
    <para>
      Now we can write down <literal>freq.ml</literal>.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq/freq.ml  *)
open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:[] ~f:(fun counts line -&gt;
    let count =
      match List.Assoc.find counts line with
      | None -&gt; 0
      | Some x -&gt; x
    in
    List.Assoc.add counts line (count + 1)
  )

let () =
  build_counts ()
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun l -&gt; List.take l 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf &quot;%3d: %s\n&quot; count line)
</programlisting>
    <para>
      The function <literal>build_counts</literal> reads in lines from
      <literal>stdin</literal>, constructing from those lines an
      association list with the frequencies of each line. It does this
      by invoking <literal>In_channel.fold_lines</literal> (similar to
      the function <literal>List.fold</literal> described in
      <xref linkend="lists-and-patterns"/>), which reads
      through the lines one by one, calling the provided fold function
      for each line to update the accumulator. That accumulator is
      initialized to the empty list.
    </para>
    <para>
      With <literal>build_counts</literal> defined, we then call the
      function to build the association list, sort that list by
      frequency in descending order, grab the first 10 elements off the
      list, and then iterate over those ten elements and print them to
      the screen. These operations are tied together using the
      <literal>|&gt;</literal> operator, as described in
      <xref linkend="variables-and-functions"/>.
    </para>
    <note><title>
    Where is the main function?
    </title>
    <para>
      Unlike C, programs in OCaml do not have a unique
      <literal>main</literal> function. When an OCaml program is
      evaluated, all the statements in the implementation files are
      evaluated in the order in which they were linked together. These
      implementation files can contain arbitrary expressions, not just
      function definitions. In this example, the declaration starting
      with <literal>let () =</literal> plays the role of the
      <literal>main</literal> declaration, kicking off the processing.
      But really the entire file is evaluated at startup, and so in some
      sense the full codebase is one big <literal>main</literal>
      function.
    </para>
    </note>
    <para>
      If we weren't using Core or any other external libraries, we could
      build the executable like this:
    </para>
    <programlisting>
# running files-modules-and-programs-freq/simple_build_fail.out.sh
$ ocamlc freq.ml -o freq
File &quot;freq.ml&quot;, line 1, characters 0-13:
Error: Unbound module Core
</programlisting>
    <para>
      But as you can see, it fails because it can't find Core. We need a
      somewhat more complex invocation to get Core linked in:
    </para>
    <programlisting>
# running files-modules-and-programs-freq/simple_build.out.sh
$ ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq.byte
</programlisting>
    <para>
      Here we're using <command>ocamlfind</command>, a tool which itself
      invokes other parts of the OCaml toolchain (in this case,
      <command>ocamlc</command>) with the appropriate flags to link in
      particular libraries and packages. Here,
      <literal>-package core</literal> is asking
      <command>ocamlfind</command> to link in the Core library,
      <literal>-linkpkg</literal> asks ocamlfind to link in the packages
      as is necessary for building an executable, while
      <literal>-thread</literal> turns on threading support, which is
      required for Core.
    </para>
    <para>
      While this works well enough for a one-file project, more
      complicated projects require a tool to orchestrate the build. One
      good tool for this task is <literal>ocamlbuild</literal>, which is
      shipped with the OCaml compiler. We'll talk more about
      <literal>ocamlbuild</literal> in
      <xref linkend="the-compiler-frontend-parsing-and-type-checking"/>,
      but for now, we'll just use a simple wrapper around
      <literal>ocamlbuild</literal> called <literal>corebuild</literal>
      that sets build parameters appropriately for building against Core
      and its related libraries.
    </para>
    <programlisting>
# running files-modules-and-programs-freq-obuild/build.out.sh
$ corebuild freq.byte
</programlisting>
    <para>
      If we'd invoked <literal>ocamlbuild</literal> with a target of
      <literal>freq.native</literal> instead of
      <literal>freq.byte</literal>, we would have gotten native-code
      instead.
    </para>
    <para>
      We can run the resulting executable from the command-line. The
      following line extracts strings from the
      <command>ocamlopt</command> binary, reporting the most frequently
      occurring ones. Note that the specific results will vary from
      platform to platform, since the binary itself will differ between
      platforms.
    </para>
    <programlisting>
# running files-modules-and-programs-freq-obuild/test.out.sh
$ strings `which ocamlopt` | ./freq.byte
  6: +pci_expr =
  6: -pci_params =
  6: .pci_virt = %a
  4: #lsr
  4: #lsl
  4: $lxor
  4: #lor
  4: $land
  4: #mod
  3: 6  .section .rdata,&quot;dr&quot;
</programlisting>
    <note><title>
    Bytecode vs native code
    </title>
    <para>
      OCaml ships with two compilers: the <command>ocamlc</command>
      bytecode compiler and the <command>ocamlopt</command> native-code
      compiler. Programs compiled with <command>ocamlc</command> are
      interpreted by a virtual machine, while programs compiled with
      <command>ocamlopt</command> are compiled to native machine code to
      be run on a specific operating system and processor architecture.
    </para>
    <para>
      Aside from performance, executables generated by the two compilers
      have nearly identical behavior. There are a few things to be aware
      of. First, the bytecode compiler can be used on more
      architectures, and has some tools that are not available for
      native code. For example, the OCaml debugger only works with
      bytecode (although <command>gdb</command>, the GNU Debugger, works
      with OCaml native-code applications). The bytecode compiler is
      also quicker than the native-code compiler. In addition, in order
      to run a bytecode executable you typically need to have OCaml
      installed on the system in question. That's not strictly required,
      though, since you can build a bytecode executable with an embedded
      runtime, using the <literal>-custom</literal> compiler flag.
    </para>
    <para>
      As a general matter, production executables should usually be
      built using the native-code compiler, but it sometimes makes sense
      to use bytecode for development builds. And, of course, bytecode
      makes sense when targeting a platform not supported by the
      native-code compiler. We'll cover both compilers in more detail in
      <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.
    </para>
    </note>

  </sect1>
  <sect1 id="multi-file-programs-and-modules">
    <title>Multi-file programs and modules</title>
    <para>
      Source files in OCaml are tied into the module system, with each
      file compiling down into a module whose name is derived from the
      name of the file. We've encountered modules before, for example,
      when we used functions like <literal>find</literal> and
      <literal>add</literal> from the <literal>List.Assoc</literal>
      module. At its simplest, you can think of a module as a collection
      of definitions that are stored within a namespace.
    </para>
    <para>
      Let's consider how we can use modules to refactor the
      implementation of <literal>freq.ml</literal>. Remember that the
      variable <literal>counts</literal> contains an association list
      representing the counts of the lines seen so far. But updating an
      association list takes time linear in the length of the list,
      meaning that the time complexity of processing a file is quadratic
      in the number of distinct lines in the file.
    </para>
    <para>
      We can fix this problem by replacing association lists with a more
      efficient data structure. To do that, we'll first factor out the
      key functionality into a separate module with an explicit
      interface. We can consider alternative (and more efficient)
      implementations once we have a clear interface to program against.
    </para>
    <para>
      We'll start by creating a file, <literal>counter.ml</literal> that
      contains the logic for maintaining the association list used to
      describe the counts. The key function, called
      <literal>touch</literal>, updates the association list with the
      information that a given line should be added to the frequency
      counts.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-counter/counter.ml  *)
open Core.Std

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)
</programlisting>
    <para>
      The file <literal>counter.ml</literal> will be compiled into a
      module named <literal>Counter</literal>. The name of the module is
      derived automatically from the filename. The module name is
      capitalized even if the file is not, and more generally module
      names must be capitalized.
    </para>
    <para>
      We can now rewrite <literal>freq.ml</literal> to use
      <literal>Counter</literal>. Note that the resulting code can still
      be built with <literal>ocamlbuild</literal>, which will discover
      dependencies and realize that <literal>counter.ml</literal> needs
      to be compiled.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-counter/freq.ml  *)
open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:[] ~f:Counter.touch

let () =
  build_counts ()
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun l -&gt; List.take l 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf &quot;%3d: %s\n&quot; count line)
</programlisting>
  </sect1>
  <sect1 id="signatures-and-abstract-types">
    <title>Signatures and abstract types</title>
    <para>
      While we've pushed some of the logic to the
      <literal>Counter</literal> module, the code in
      <literal>freq.ml</literal> can still depend on the details of the
      implementation of <literal>Counter</literal>. Indeed, if you look
      at the definition of <literal>build_counts</literal>, you'll see
      that it depends on the fact that the empty set of frequency counts
      is represented as an empty list. We'd like to prevent this kind of
      dependency so we can change the implementation of
      <literal>Counter</literal> without needing to change client code
      like that in <literal>freq.ml</literal>.
    </para>
    <para>
      The implementation details of a module can be hidden by attaching
      an <emphasis>interface</emphasis>. (Note that the terms
      <emphasis>interface</emphasis>, <emphasis>signature</emphasis> and
      <emphasis>module type</emphasis> are all used interchangeably.) A
      module defined by a file <literal>filename.ml</literal> can be
      constrained by a signature placed in a file called
      <literal>filename.mli</literal>.
    </para>
    <para>
      For <literal>counter.mli</literal>, we'll start by writing down an
      interface that describes what's currently available in
      <literal>counter.ml</literal>, without hiding anything.
      <literal>val</literal> declarations are used to specify values in
      a signature. The syntax of a <literal>val</literal> declaration is
      as follows:
    </para>
    <programlisting language="html">
val &lt;identifier&gt; : &lt;type&gt;
</programlisting>
    <para>
      Using this syntax, we can write the signature of
      <literal>counter.ml</literal> as follows.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-sig/counter.mli  *)
open Core.Std

(** Bump the frequency count for the given string. *)
val touch : (string * int) list -&gt; string -&gt; (string * int) list
</programlisting>
    <para>
      Note that <literal>ocamlbuild</literal> will detect the presence
      of the <literal>mli</literal> file automatically and include it in
      the build.
    </para>
    <note><title>
    Auto-generating <literal>mli</literal> files
    </title>
    <para>
      If you don't want to construct an mli entirely by hand, you can
      ask OCaml to auto-generate one for you from the source, which you
      can then adjust to fit your needs. Here's how you can do that
      using <literal>corebuild</literal>.
    </para>
    <programlisting>
# running files-modules-and-programs-freq-with-counter/infer_mli.out.sh
$ corebuild counter.inferred.mli
$ cat _build/counter.inferred.mli
val touch :
  ('a, int) Core.Std.List.Assoc.t -&gt; 'a -&gt; ('a, int) Core.Std.List.Assoc.t
</programlisting>
    <para>
      The generated code is basically equivalent to the
      <literal>mli</literal> that we wrote by hand, but is a bit uglier
      and more verbose, and, of course, has no comments. In general,
      auto-generated <literal>mli</literal>'s are only useful as a
      starting point. In OCaml, the <literal>mli</literal> is the key
      place where you present and document your interface, and there's
      no replacement for careful human editing and organization.
    </para>
    </note>

    <para>
      To hide the fact that frequency counts are represented as
      association lists, we'll need to make the type of frequency counts
      <emphasis>abstract</emphasis>. A type is abstract if its name is
      exposed in the interface, but its definition is not. Here's an
      abstract interface for <literal>Counter</literal>:
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-sig-abstract/counter.mli  *)
open Core.Std

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(** Converts the set of frequency counts to an association list.  Every string
    in the list will show up at most once, and the integers will be at least
    1. *)
val to_list : t -&gt; (string * int) list
</programlisting>
    <para>
      Note that we needed to add <literal>empty</literal> and
      <literal>to_list</literal> to <literal>Counter</literal>, since
      otherwise, there would be no way to create a
      <literal>Counter.t</literal> or get data out of one.
    </para>
    <para>
      We also used this opportunity to document the module. The
      <literal>mli</literal> file is the place where you specify your
      module's interface, and as such is a natural place to document the
      module as well. We also started our comments with a double
      asterisk to cause them to be picked up by the
      <command>ocamldoc</command> tool when generating API
      documentation. We'll discuss <command>ocamldoc</command> more in
      <xref linkend="the-compiler-frontend-parsing-and-type-checking"/>.
    </para>
    <para>
      Here's a rewrite of <literal>counter.ml</literal> to match the new
      <literal>counter.mli</literal>.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-sig-abstract/counter.ml  *)
open Core.Std

type t = (string * int) list

let empty = []

let to_list x = x

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)
</programlisting>
    <para>
      If we now try to compile <literal>freq.ml</literal>, we'll get the
      following error:
    </para>
    <programlisting>
# running files-modules-and-programs-freq-with-sig-abstract/build.out.sh
$ corebuild freq.byte
File &quot;freq.ml&quot;, line 4, characters 42-55:
Error: This expression has type Counter.t -&gt; string -&gt; Counter.t
       but an expression was expected of type 'a list -&gt; string -&gt; 'a list
       Type Counter.t is not compatible with type 'a list 
Command exited with code 2.
</programlisting>
    <para>
      This is because <literal>freq.ml</literal> depends on the fact
      that frequency counts are represented as association lists, a fact
      that we've just hidden. We just need to fix
      <literal>build_counts</literal> to use
      <literal>Counter.empty</literal> instead of <literal>[]</literal>
      and <literal>Counter.to_list</literal> to get the association list
      out at the end for processing and printing. The resulting
      implementation is shown below.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-sig-abstract-fixed/freq.ml  *)
open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:Counter.empty ~f:Counter.touch

let () =
  build_counts ()
  |&gt; Counter.to_list
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun counts -&gt; List.take counts 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf &quot;%3d: %s\n&quot; count line)
</programlisting>
    <para>
      Now we can turn to optimizing the implementation of
      <literal>Counter</literal>. Here's an alternate and far more
      efficient implementation, based on the <literal>Map</literal>
      datastructure in Core.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-fast/counter.ml  *)
open Core.Std

type t = int String.Map.t

let empty = String.Map.empty

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t ~key:s ~data:(count + 1)
</programlisting>
    <para>
      Note that in the above we use <literal>String.Map</literal> in
      some places and simply <literal>Map</literal> in others. This has
      to do with the fact that for some operations, like creating a
      <literal>Map.t</literal>, you need access to type-specialized
      information, and for others, like looking something up in
      <literal>Map.t</literal>, you don't. This is covered in more
      detail in <xref linkend="maps-and-hash-tables"/>.
    </para>
  </sect1>
  <sect1 id="concrete-types-in-signatures">
    <title>Concrete types in signatures</title>
    <para>
      In our frequency-count example, the module
      <literal>Counter</literal> had an abstract type
      <literal>Counter.t</literal> for representing a collection of
      frequency counts. Sometimes, you'll want to make a type in your
      interface <emphasis>concrete</emphasis>, by including the type
      definition in the interface.
    </para>
    <para>
      For example, imagine we wanted to add a function to
      <literal>Counter</literal> for returning the line with the median
      frequency count. If the number of lines is even, then there is no
      precise median and the function would return the lines before and
      after the median instead. We'll use a custom type to represent the
      fact that there are two possible return values. Here's a possible
      implementation.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-median/counter.ml (starting from part 1) *)
type median = | Median of string
              | Before_and_after of string * string

let median t =
  let sorted_strings = List.sort (Map.to_alist t)
                         ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  in
  let len = List.length sorted_strings in
  if len = 0 then failwith &quot;median: empty frequency count&quot;;
  let nth n = fst (List.nth_exn sorted_strings n) in
  if len mod 2 = 1
  then Median (nth (len/2))
  else Before_and_after (nth (len/2 - 1), nth (len/2));;
</programlisting>
    <para>
      In the above, we use <literal>failwith</literal> to throw an
      exception for the case of the empty list. We'll discuss exceptions
      more in <xref linkend="error-handling"/>. Note also that
      the function <literal>fst</literal> simply returns the first
      element of any 2-tuple.
    </para>
    <para>
      Now, to expose this usefully in the interface, we need to expose
      both the function and the type <literal>median</literal> with its
      definition. Note that values (of which functions are an example)
      and types have distinct namespaces, so there's no name clash here.
      Adding the following two lines added to
      <literal>counter.mli</literal> does the trick.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-median/counter.mli (starting from part 1) *)
(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Median of string
              | Before_and_after of string * string

val median : t -&gt; median
</programlisting>
    <para>
      The decision of whether a given type should be abstract or
      concrete is an important one. Abstract types give you more control
      over how values are created and accessed, and make it easier to
      enforce invariants beyond what is enforced by the type itself;
      concrete types let you expose more detail and structure to client
      code in a lightweight way. The right choice depends very much on
      the context.
    </para>
  </sect1>
  <sect1 id="nested-modules">
    <title>Nested modules</title>
    <para>
      Up until now, we've only considered modules that correspond to
      files, like <literal>counter.ml</literal>. But modules (and module
      signatures) can be nested inside other modules. As a simple
      example, consider a program that needs to deal with multiple
      identifiers like usernames and hostnames. If you just represent
      these as strings, then it becomes easy to confuse one with the
      other.
    </para>
    <para>
      A better approach is to mint new abstract types for each
      identifier, where those types are under the covers just
      implemented as strings. That way, the type system will prevent you
      from confusing a username with a hostname, and if you do need to
      convert, you can do so using explicit conversions to and from the
      string type.
    </para>
    <para>
      Here's how you might create such an abstract type, within a
      sub-module:
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs/abstract_username.ml  *)
open Core.Std

module Username : sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end = struct
  type t = string
  let of_string x = x
  let to_string x = x
end
</programlisting>
    <para>
      Note that the <literal>to_string</literal> and
      <literal>of_string</literal> functions above are implemented
      simply as the identity function, which means they have no runtime
      effect. They are there purely as part of the discipline that they
      enforce on the code through the type system.
    </para>
    <para>
      The basic structure of a module declaration like this is:
    </para>
    <programlisting language="html">
module &lt;name&gt; : &lt;signature&gt; = &lt;implementation&gt;
</programlisting>
    <para>
      We could have written this slightly differently, by giving the
      signature its own toplevel <literal>module type</literal>
      declaration, making it possible to create multiple distinct types
      with the same underlying implementation in a lightweight way.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs/session_info.ml  *)
open Core.Std

module type ID = sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end

module String_id = struct
  type t = string
  let of_string x = x
  let to_string x = x
end

module Username : ID = String_id
module Hostname : ID = String_id

type session_info = { user: Username.t;
                      host: Hostname.t;
                      when_started: Time.t;
                    }

let sessions_have_same_user s1 s2 =
  s1.user = s2.host
</programlisting>
    <para>
      The above code has a bug: it compares the username in one session
      to the host in the other session, when it should be comparing the
      usernames in both cases. Because of how we defined our types,
      however, the compiler will flag this bug for us.
    </para>
    <programlisting>
# running files-modules-and-programs/build_session_info.out.sh
$ corebuild session_info.native
File &quot;session_info.ml&quot;, line 24, characters 12-19:
Error: This expression has type Hostname.t
       but an expression was expected of type Username.t
Command exited with code 2.
</programlisting>
  </sect1>
  <sect1 id="opening-modules">
    <title>Opening modules</title>
    <para>
      Most of the time, you refer to values and types within a module by
      using the module name as an explicit qualifier.
      <emphasis>e.g.</emphasis>, you write <literal>List.map</literal>
      to refer to the <literal>map</literal> function in the
      <literal>List</literal> module. Sometimes, though, you want to be
      able to refer to the contents of a module without this explicit
      qualification. That's what the <literal>open</literal> statement
      is for.
    </para>
    <para>
      We've encountered <literal>open</literal> already, specifically
      where we've written <literal>open Core.Std</literal> to get access
      to the standard definitions in the Core library. In general,
      opening a module adds the contents of that module to the
      environment that the compiler looks at to find the definition of
      various identifiers. Here's an example.
    </para>
    <programlisting language="ocaml">
# script files-modules-and-programs/main.topscript
$ utop
# module M = struct let foo = 3 end;; 
module M : sig val foo : int end
# foo;; 
Characters -1-3:
Error: Unbound value foo
# open M;; 
# foo;; 
- : int = 3
</programlisting>
    <para>
      <literal>open</literal> is essential when you want to modify your
      environment for a standard library like Core, but it's generally
      good style to keep opening of modules to a minimum. Opening a
      module is basically a tradeoff between terseness and
      explicitness—the more modules you open, the fewer module
      qualifications you need, and the harder it is to look at an
      identifier and figure out where it comes from.
    </para>
    <para>
      Here's some general advice on how to deal with opens.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Opening modules at the toplevel of a module should be done
          quite sparingly, and generally only with modules that have
          been specifically designed to be opened, like
          <literal>Core.Std</literal> or
          <literal>Option.Monad_infix</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          If you do need to do an open, it's better to do a
          <emphasis>local open</emphasis>. There are two syntaxes for
          local opens. For example, you can write:
        </para>
      </listitem>
    </itemizedlist>
    <programlisting language="ocaml">
...part 1 of files-modules-and-programs/main.topscript
# let average x y =
    let open Int64 in
    x + y / of_int 2;; 
val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;
</programlisting>
    <para>
      In the above, <literal>of_int</literal> and the infix operators
      are the ones from the <literal>Int64</literal> module.
    </para>
    <para>
      There's another even more lightweight syntax for local opens,
      which is particularly useful for small expressions:
    </para>
    <programlisting language="ocaml">
...part 2 of files-modules-and-programs/main.topscript
# let average x y =
    Int64.(x + y / of_int 2);; 
val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;
</programlisting>
    <itemizedlist>
      <listitem>
        <para>
          An alternative to local opens that makes your code terser
          without giving up on explicitness is to locally rebind the
          name of a module. So, when using the
          <literal>Counter.median</literal> type, instead of writing:
        </para>
      </listitem>
    </itemizedlist>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-median/use_median_1.ml (starting from part 1) *)
let print_median m =
  match m with
  | Counter.Median string -&gt; printf &quot;True median:\n   %s\n&quot; string
  | Counter.Before_and_after (before, after) -&gt;
    printf &quot;Before and after median:\n   %s\n   %s\n&quot; before after
</programlisting>
    <para>
      you could write:
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-median/use_median_2.ml (starting from part 1) *)
let print_median m =
  let module C = Counter in
  match m with
  | C.Median string -&gt; printf &quot;True median:\n   %s\n&quot; string
  | C.Before_and_after (before, after) -&gt;
    printf &quot;Before and after median:\n   %s\n   %s\n&quot; before after
</programlisting>
    <para>
      Because the module name <literal>C</literal> only exists for a
      short scope, it's easy to read and remember what
      <literal>C</literal> stands for. Rebinding modules to very short
      names at the toplevel of your module is usually a mistake.
    </para>
  </sect1>
  <sect1 id="including-modules">
    <title>Including modules</title>
    <para>
      While opening a module affects the environment used to search for
      identifiers, <emphasis>including</emphasis> a module is a way of
      actually adding new identifiers to a module proper. Consider the
      following simple module for representing a range of intervals.
    </para>
    <programlisting language="ocaml">
...part 3 of files-modules-and-programs/main.topscript
# module Interval = struct
    type t = | Interval of int * int
             | Empty

    let create low high =
      if high &lt; low then Empty else Interval (low,high)
  end;; 
module Interval :
  sig type t = Interval of int * int | Empty val create : int -&gt; int -&gt; t end
</programlisting>
    <para>
      We can use the <literal>include</literal> directive to create a
      new, extended version of the <literal>Interval</literal> module.
    </para>
    <programlisting language="ocaml">
...part 4 of files-modules-and-programs/main.topscript
# module Extended_interval = struct
    include Interval

    let contains t x =
      match t with
      | Empty -&gt; false
      | Interval (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high
  end;; 
module Extended_interval :
  sig
    type t = Interval.t = Interval of int * int | Empty
    val create : int -&gt; int -&gt; t
    val contains : t -&gt; int -&gt; bool
  end
# Extended_interval.contains (Extended_interval.create 3 10) 4;; 
- : bool = true
</programlisting>
    <para>
      The difference between <literal>include</literal> and
      <literal>open</literal> is that we've done more than change how
      identifiers are searched for: we've changed what's in the module.
      If we'd used <literal>open</literal>, we'd have gotten a quite
      different result.
    </para>
    <programlisting language="ocaml">
...part 5 of files-modules-and-programs/main.topscript
# module Extended_interval = struct
    open Interval

    let contains t x =
      match t with
      | Empty -&gt; false
      | Interval (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high
  end;; 
module Extended_interval :
  sig val contains : Extended_interval.t -&gt; int -&gt; bool end
# Extended_interval.contains (Extended_interval.create 3 10) 4;; 
Characters 28-52:
Error: Unbound value Extended_interval.create
</programlisting>
    <para>
      To consider a more realistic example, imagine you wanted to build
      an extended version of the <literal>List</literal> module, where
      you've added some functionality not present in the module as
      distributed in Core. <literal>include</literal> allows us to do
      just that.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs/ext_list.ml  *)
open Core.Std

(* The new function we're going to add *)
let rec intersperse list el =
  match list with
  | [] | [ _ ]   -&gt; list
  | x :: y :: tl -&gt; x :: el :: intersperse (y::tl) el

(* The remainder of the list module *)
include List
</programlisting>
    <para>
      Now, what about the interface of this new module? It turns out
      that include works on the signature language as well, so we can
      pull essentially the same trick to write an <literal>mli</literal>
      for this new module. The only trick is that we need to get our
      hands on the signature for the list module, which can be done
      using <literal>module type of</literal>.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs/ext_list.mli  *)
open Core.Std

(* Include the interface of the list module from Core *)
include (module type of List)

(* Signature of function we're adding *)
val intersperse : 'a list -&gt; 'a -&gt; 'a list
</programlisting>
    <para>
      Note that the order of declarations in the <literal>mli</literal>
      does not need to match the order of declarations in the
      <literal>ml</literal>. Also, the order of declarations in the
      <literal>ml</literal> is quite important in that it determines
      what values are shadowed. If we wanted to replace a function in
      <literal>List</literal> with a new function of the same name, the
      declaration of that function in the <literal>ml</literal> would
      have to come after the <literal>include List</literal>
      declaration.
    </para>
    <para>
      And we can now use <literal>Ext_list</literal> as a replacement
      for <literal>List</literal>. If we want to use
      <literal>Ext_list</literal> in preference to
      <literal>List</literal> in our project, we can create a file of
      common definitions:
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs/common.ml  *)
module List = Ext_list
</programlisting>
    <para>
      And if we then put <literal>open Common</literal> after
      <literal>open Core.Std</literal> at the top of each file in our
      project, then references to <literal>List</literal> will
      automatically go to <literal>Ext_list</literal> instead.
    </para>
  </sect1>
  <sect1 id="common-errors-with-modules">
    <title>Common errors with modules</title>
    <para>
      When OCaml compiles a program with an <literal>ml</literal> and an
      <literal>mli</literal>, it will complain if it detects a mismatch
      between the two. Here are some of the common errors you'll run
      into.
    </para>
    <sect2 id="type-mismatches">
      <title>Type mismatches</title>
      <para>
        The simplest kind of error is where the type specified in the
        signature does not match up with the type in the implementation
        of the module. As an example, if we replace the
        <literal>val</literal> declaration in
        <literal>counter.mli</literal> by swapping the types of the
        first two arguments:
      </para>
      <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-sig-mismatch/counter.mli (starting from part 1) *)
(** Bump the frequency count for the given string. *)
val touch : string -&gt; t -&gt; t
</programlisting>
      <para>
        and we try to compile, we'll get the following error.
      </para>
      <programlisting>
# running files-modules-and-programs-freq-with-sig-mismatch/build.out.sh
$ corebuild freq.byte
File &quot;freq.ml&quot;, line 4, characters 53-66:
Error: This expression has type string -&gt; Counter.t -&gt; Counter.t
       but an expression was expected of type
         Counter.t -&gt; string -&gt; Counter.t
       Type string is not compatible with type Counter.t 
Command exited with code 2.
</programlisting>
      <para>
        This error message is a bit intimidating at first, and it takes
        a bit of thought to see why the first type for touch (which
        comes from the implementation) doesn't match the second one
        (which comes from the interface). The key thing to remember is
        that <literal>t</literal> is a
        <literal>Core.Std.Map.t</literal>, at which point you can see
        that the error is a mismatch in the order of arguments to
        <literal>touch</literal>.
      </para>
      <para>
        There's no denying that learning to decode such error messages
        is difficult at first, and takes some getting used to. But in
        time, decoding these errors becomes second nature.
      </para>
    </sect2>
    <sect2 id="missing-definitions">
      <title>Missing definitions</title>
      <para>
        We might decide that we want a new function in
        <literal>Counter</literal> for pulling out the frequency count
        of a given string. We can update the <literal>mli</literal> by
        adding the following line.
      </para>
      <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-missing-def/counter.mli (starting from part 1) *)
val count : t -&gt; string -&gt; int
</programlisting>
      <para>
        Now, if we try to compile without actually adding the
        implementation, we'll get this error:
      </para>
      <programlisting>
# running files-modules-and-programs-freq-with-missing-def/build.out.sh
$ corebuild freq.byte
File &quot;counter.ml&quot;, line 1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       The field `count' is required but not provided
Command exited with code 2.
</programlisting>
      <para>
        A missing type definition will lead to a similar error.
      </para>
    </sect2>
    <sect2 id="type-definition-mismatches">
      <title>Type definition mismatches</title>
      <para>
        Type definitions that show up in an <literal>mli</literal> need
        to match up with corresponding definitions in the
        <literal>ml</literal>. Consider again the example of the type
        <literal>median</literal>. The order of the declaration of
        variants matters to the OCaml compiler, so the definition of
        <literal>median</literal> in the implementation listing those
        options in a different order:
      </para>
      <programlisting language="ocaml">
(* files-modules-and-programs-freq-with-type-mismatch/counter.mli (starting from part 1) *)
(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Before_and_after of string * string
              | Median of string
</programlisting>
      <para>
        will lead to a compilation error:
      </para>
      <programlisting>
# running files-modules-and-programs-freq-with-type-mismatch/build.out.sh
$ corebuild freq.byte
File &quot;counter.ml&quot;, line 1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       Type declarations do not match:
         type median = Median of string | Before_and_after of string * string
       is not included in
         type median = Before_and_after of string * string | Median of string
       File &quot;counter.ml&quot;, line 18, characters 5-84: Actual declaration
       Fields number 1 have different names, Median and Before_and_after.
Command exited with code 2.
</programlisting>
      <para>
        Order is similarly important in other parts of the signature,
        including the order in which record fields are declared and the
        order of arguments (including labeled and optional arguments) to
        a function.
      </para>
    </sect2>
    <sect2 id="cyclic-dependencies">
      <title>Cyclic dependencies</title>
      <para>
        In most cases, OCaml doesn't allow cyclic dependencies,
        <emphasis>i.e.</emphasis>, a collection of definitions that all
        refer to each other. If you want to create such definitions, you
        typically have to mark them specially. For example, when
        defining a set of mutually recursive values (like the definition
        of <literal>is_even</literal> and <literal>is_odd</literal> in
        <xref linkend="recursive-functions"/>), you need to
        define them using <literal>let rec</literal> rather than
        ordinary <literal>let</literal>.
      </para>
      <para>
        The same is true at the module level. By default, cyclic
        dependencies between modules are not allowed, and indeed, cyclic
        dependencies among files are never allowed. Recursive modules
        are possible, but are a rare case and we won't discuss them
        further here.
      </para>
      <para>
        The simplest case of this is that a module can not directly
        refer to itself (although definitions within a module can refer
        to each other in the ordinary way). So, if we tried to add a
        reference to <literal>Counter</literal> from within
        <literal>counter.ml</literal>
      </para>
      <programlisting language="ocaml">
(* files-modules-and-programs-freq-cyclic1/counter.ml (starting from part 1) *)
let singleton l = Counter.touch Counter.empty
</programlisting>
      <para>
        we'll see this error when we try to build:
      </para>
      <programlisting>
# running files-modules-and-programs-freq-cyclic1/build.out.sh
$ corebuild freq.byte
File &quot;counter.ml&quot;, line 18, characters 18-31:
Error: Unbound module Counter
Command exited with code 2.
</programlisting>
      <para>
        The problem manifests in a different way if we create cyclic
        references between files. We could create such a situation by
        adding a reference to <literal>Freq</literal> from
        <literal>counter.ml</literal>, <emphasis>e.g.</emphasis>, by
        adding the following line.
      </para>
      <programlisting language="ocaml">
(* files-modules-and-programs-freq-cyclic2/counter.ml (starting from part 1) *)
let _build_counts = Freq.build_counts
</programlisting>
      <para>
        In this case, <literal>ocamlbuild</literal> (which is invoked by
        the <literal>corebuild</literal> script) will notice the error
        and complain explicitly about the cycle.
      </para>
      <programlisting>
# running files-modules-and-programs-freq-cyclic2/build.out.sh
$ corebuild freq.byte
Circular dependencies: &quot;freq.cmo&quot; already seen in
  [ &quot;counter.cmo&quot;; &quot;freq.cmo&quot; ]

</programlisting>
    </sect2>
  </sect1>
</chapter><chapter id="records">
  <title>Records</title>
  <para>
    One of OCaml's best features is its concise and expressive system
    for declaring new datatypes, and records are a key element of that
    system. We discussed records briefly in
    <xref linkend="a-guided-tour"/>, but this chapter will go
    into more depth, covering the details of how records work, as well
    as advice on how to use them effectively in your software designs.
  </para>
  <para>
    A record represents a collection of values stored together as one,
    where each component is identified by a different field name. The
    basic syntax for a record type declaration is as follows.
  </para>
  <programlisting language="html">
type &lt;record-name&gt; =
  { &lt;field&gt; : &lt;type&gt; ;
    &lt;field&gt; : &lt;type&gt; ;
    ...
  }
</programlisting>
  <para>
    Note that record field names must start with a lower-case letter.
  </para>
  <para>
    Here's a simple example, a <literal>host_info</literal> record that
    summarizes information about a given computer.
  </para>
  <programlisting language="ocaml">
# script records/main.topscript
$ utop
# type host_info =
    { hostname   : string;
      os_name    : string;
      cpu_arch   : string;
      timestamp  : Time.t;
    };; 
type host_info = {
  hostname : string;
  os_name : string;
  cpu_arch : string;
  timestamp : Time.t;
}
</programlisting>
  <para>
    We can construct a <literal>host_info</literal> just as easily. The
    following code uses the <literal>Shell</literal> module from
    <literal>Core_extended</literal> to dispatch commands to the shell
    to extract the information we need about the computer we're running
    on, and the <literal>Time.now</literal> call from Core's
    <literal>Time</literal> module.
  </para>
  <programlisting language="ocaml">
...part 1 of records/main.topscript
# #require &quot;core_extended&quot;;; 

/home/rwo/.opam/4.01.0dev+trunk/lib/pcre: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/pcre/pcre.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/textutils: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/textutils/textutils.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/custom_printf/custom_printf.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/core_extended: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/core_extended/core_extended.cma: loaded
# open Core_extended.Std;; 
# let my_host =
    let sh = Shell.sh_one_exn in
    { hostname   = sh &quot;hostname&quot;;
      os_name    = sh &quot;uname -s&quot;;
      cpu_arch   = sh &quot;uname -p&quot;;
      timestamp  = Time.now ();
    };; 
val my_host : host_info =
  {hostname = &quot;ocaml-www1&quot;; os_name = &quot;Linux&quot;; cpu_arch = &quot;unknown&quot;;
   timestamp = 2013-08-11 22:06:05.098029+01:00}
</programlisting>
  <para>
    You might wonder how the compiler inferred that
    <literal>my_host</literal> is of type <literal>host_info</literal>.
    The hook that the compiler uses in this case to figure out the type
    is the record field name. Later in the chapter, we'll talk about
    what happens when there is more than one record type in scope with
    the same field name.
  </para>
  <para>
    Once we have a record value in hand, we can extract elements from
    the record field using dot-notation.
  </para>
  <programlisting language="ocaml">
...part 2 of records/main.topscript
# my_host.cpu_arch;; 
- : string = &quot;unknown&quot;
</programlisting>
  <para>
    When declaring an OCaml type, you always have the option of
    parameterizing it by a polymorphic type. Records are no different in
    this regard. So, for example, here's a type one might use to
    timestamp arbitrary items.
  </para>
  <programlisting language="ocaml">
...part 3 of records/main.topscript
# type 'a timestamped = { item: 'a; time: Time.t };; 
type 'a timestamped = { item : 'a; time : Time.t; }
</programlisting>
  <para>
    We can then write polymorphic functions that operate over this
    parameterized type.
  </para>
  <programlisting language="ocaml">
...part 4 of records/main.topscript
# let first_timestamped list =
    List.reduce list ~f:(fun a b -&gt; if a.time &lt; b.time then a else b)
  ;; 
val first_timestamped : 'a timestamped list -&gt; 'a timestamped option = &lt;fun&gt;
</programlisting>
  <sect1 id="patterns-and-exhaustiveness">
    <title>Patterns and exhaustiveness</title>
    <para>
      Another way of getting information out of a record is by using a
      pattern match, as in the definition of
      <literal>host_info_to_string</literal> below.
    </para>
    <programlisting language="ocaml">
...part 5 of records/main.topscript
# let host_info_to_string { hostname = h; os_name = os;
                            cpu_arch = c; timestamp = ts;
                          } =
       sprintf &quot;%s (%s / %s, on %s)&quot; h os c (Time.to_sec_string ts);; 
val host_info_to_string : host_info -&gt; string = &lt;fun&gt;
# host_info_to_string my_host;; 
- : string = &quot;ocaml-www1 (Linux / unknown, on 2013-08-11 22:06:05)&quot;
</programlisting>
    <para>
      Note that the pattern that we used had only a single case, rather
      than using several cases separated by <literal>|</literal>'s. We
      needed only one pattern because record patterns are
      <emphasis>irrefutable</emphasis>, meaning that a record pattern
      match will never fail at runtime. This makes sense, because the
      set of fields available in a record is always the same. In
      general, patterns for types with a fixed structure, like records
      and tuples, are irrefutable, unlike types with variable structure
      like lists and variants.
    </para>
    <para>
      Another important characteristic of record patterns is that they
      don't need to be complete; a pattern can mention only a subset of
      the fields in the record. This can be convenient, but it can also
      be error prone. In particular, this means that when new fields are
      added to the record, code that should be updated to react to the
      presence of those new fields will not be flagged by the compiler.
    </para>
    <para>
      As an example, imagine that we wanted to add a new field to our
      <literal>host_info</literal> record called
      <literal>os_release</literal>, as shown below.
    </para>
    <programlisting language="ocaml">
...part 6 of records/main.topscript
# type host_info =
    { hostname   : string;
      os_name    : string;
      cpu_arch   : string;
      os_release : string;
      timestamp  : Time.t;
    } ;; 
type host_info = {
  hostname : string;
  os_name : string;
  cpu_arch : string;
  os_release : string;
  timestamp : Time.t;
}
</programlisting>
    <para>
      The code for <literal>host_info_to_string</literal> would continue
      to compile without change. In this particular case, it's pretty
      clear that you might want to update
      <literal>host_info_to_string</literal> in order to include
      <literal>os_release</literal>, and it would be nice if the type
      system would give you a warning about the change.
    </para>
    <para>
      Happily, OCaml does offer an optional warning for missing fields
      in a record pattern. With that warning turned on (which you can do
      in the toplevel by typing
      <literal>#warnings &quot;+9&quot;</literal>), the compiler will
      warn about the missing field.
    </para>
    <programlisting language="ocaml">
...part 7 of records/main.topscript
# #warnings &quot;+9&quot;;; 
# let host_info_to_string { hostname = h; os_name = os;
                            cpu_arch = c; timestamp = ts;
                          } =
    sprintf &quot;%s (%s / %s, on %s)&quot; h os c (Time.to_sec_string ts);; 

Characters 24-139:
Warning 9: the following labels are not bound in this record pattern:
os_release
Either bind these labels explicitly or add '; _' to the pattern.
val host_info_to_string : host_info -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      We can disable the warning for a given pattern by explicitly
      acknowledging that we are ignoring extra fields. This is done by
      adding an underscore to the pattern, as shown below.
    </para>
    <programlisting language="ocaml">
...part 8 of records/main.topscript
# let host_info_to_string { hostname = h; os_name = os;
                            cpu_arch = c; timestamp = ts; _
                          } =
    sprintf &quot;%s (%s / %s, on %s)&quot; h os c (Time.to_sec_string ts);; 
val host_info_to_string : host_info -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      It's a good idea to enable the warning for incomplete record
      matches, and to explicitly disable it with an <literal>_</literal>
      where necessary.
    </para>
    <note> <title> 
    Compiler warnings
    </title>
    <para>
      The OCaml compiler is packed full of useful warnings that can be
      enabled and disabled separately. For example, we could have found
      out about warning 9, which was discussed above, as follows:
    </para>
    <programlisting>
# running records/warn_help.out.sh
$ ocaml -warn-help | egrep '\b9\b'
  9 Missing fields in a record pattern.
  R Synonym for warning 9.
</programlisting>
    <para>
      You should think of OCaml's warnings as a powerful set of optional
      static analysis tools, and eagerly enable them in your build
      environment. You don't typically enable all warnings, but the
      defaults that ship with the compiler are pretty good.
    </para>
    <para>
      The warnings used for building the examples in this book are
      specified with the following flag:
      <literal>-w @A-4-33-41-42-43-34-44</literal>.
    </para>
    <para>
      The syntax of this can be found by running
      <literal>ocaml -help</literal>, but this particular invocation
      turns on all warnings as errors, disabling only the numbers listed
      explicitly after the <literal>A</literal>.
    </para>
    <para>
      Treating warnings as errors (<emphasis>i.e.</emphasis>, making
      OCaml fail to compile any code that triggers a warning) is good
      practice, since without it, warnings are too often ignored during
      development. When preparing a package for distribution, however,
      this is a bad idea, since the list of warnings may grow from one
      release of the compiler to another, and so this may lead your
      package to fail to compile on newer compiler releases.
    </para>
    </note>

  </sect1>
  <sect1 id="field-punning">
    <title>Field punning</title>
    <para>
      When the name of a variable coincides with the name of a record
      field, OCaml provides some handy syntactic shortcuts. For example,
      the pattern in the following function binds all of the fields in
      question to variables of the same name. This is called
      <emphasis>field punning</emphasis>.
    </para>
    <programlisting language="ocaml">
...part 9 of records/main.topscript
# let host_info_to_string { hostname; os_name; cpu_arch; timestamp; _ } =
     sprintf &quot;%s (%s / %s) &lt;%s&gt;&quot; hostname os_name cpu_arch
       (Time.to_string timestamp);; 
val host_info_to_string : host_info -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      Field punning can also be used to construct a record. Consider the
      following code for generating a <literal>host_info</literal>
      record.
    </para>
    <programlisting language="ocaml">
...part 10 of records/main.topscript
# let my_host =
    let sh cmd = Shell.sh_one_exn cmd in
    let hostname   = sh &quot;hostname&quot; in
    let os_name    = sh &quot;uname -s&quot; in
    let cpu_arch   = sh &quot;uname -p&quot; in
    let os_release = sh &quot;uname -r&quot; in
    let timestamp  = Time.now () in
    { hostname; os_name; cpu_arch; os_release; timestamp };; 
val my_host : host_info =
  {hostname = &quot;ocaml-www1&quot;; os_name = &quot;Linux&quot;; cpu_arch = &quot;unknown&quot;;
   os_release = &quot;3.2.0-1-amd64&quot;;
   timestamp = 2013-08-11 22:06:11.410322+01:00}
</programlisting>
    <para>
      In the above code, we defined variables corresponding to the
      record fields first, and then the record declaration itself simply
      listed the fields that needed to be included.
    </para>
    <para>
      You can take advantage of both field punning and label punning
      when writing a function for constructing a record from labeled
      arguments, as shown below.
    </para>
    <programlisting language="ocaml">
...part 11 of records/main.topscript
# let create_host_info ~hostname ~os_name ~cpu_arch ~os_release =
    { os_name; cpu_arch; os_release;
      hostname = String.lowercase hostname;
      timestamp = Time.now () };; 
val create_host_info :
  hostname:string -&gt;
  os_name:string -&gt; cpu_arch:string -&gt; os_release:string -&gt; host_info = &lt;fun&gt;
</programlisting>
    <para>
      This is considerably more concise than what you would get without
      punning at all.
    </para>
    <programlisting language="ocaml">
...part 12 of records/main.topscript
# let create_host_info
    ~hostname:hostname ~os_name:os_name
    ~cpu_arch:cpu_arch ~os_release:os_release =
    { os_name = os_name;
      cpu_arch = cpu_arch;
      os_release = os_release;
      hostname = String.lowercase hostname;
      timestamp = Time.now () };; 
val create_host_info :
  hostname:string -&gt;
  os_name:string -&gt; cpu_arch:string -&gt; os_release:string -&gt; host_info = &lt;fun&gt;
</programlisting>
    <para>
      Together, labeled arguments, field names, and field and label
      punning, encourage a style where you propagate the same names
      throughout your code-base. This is generally good practice, since
      it encourages consistent naming, which makes it easier to navigate
      the source.
    </para>
  </sect1>
  <sect1 id="reusing-field-names">
    <title>Reusing field names</title>
    <para>
      Defining records with the same field names can be problematic.
      Let's consider a simple example: building types to represent the
      protocol used for a logging server.
    </para>
    <para>
      We'll describe three message types: <literal>log_entry</literal>,
      <literal>heartbeat</literal> and <literal>logon</literal>. The
      <literal>log_entry</literal> message is used to deliver a log
      entry to the server; the <literal>logon</literal> message is sent
      to initiate a connection, and includes the identity of the user
      connecting and credentials used for authentication; and the
      <literal>heartbeat</literal> message is periodically sent by the
      client to demonstrate to the server that the client is alive and
      connected. All of these messages include a session id and the time
      the message was generated.
    </para>
    <programlisting language="ocaml">
...part 13 of records/main.topscript
# type log_entry =
    { session_id: string;
      time: Time.t;
      important: bool;
      message: string;
    }
  type heartbeat =
    { session_id: string;
      time: Time.t;
      status_message: string;
    }
  type logon =
    { session_id: string;
      time: Time.t;
      user: string;
      credentials: string;
    }
;; 
type log_entry = {
  session_id : string;
  time : Time.t;
  important : bool;
  message : string;
}
type heartbeat = {
  session_id : string;
  time : Time.t;
  status_message : string;
}
type logon = {
  session_id : string;
  time : Time.t;
  user : string;
  credentials : string;
}
</programlisting>
    <para>
      Reusing field names can lead to some ambiguity. For example, if we
      want to write a function to grab the session_id from a record,
      what type will it have?
    </para>
    <programlisting language="ocaml">
...part 14 of records/main.topscript
# let get_session_id t = t.session_id;; 
val get_session_id : logon -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      In this case, OCaml just picks the most recent definition of that
      record field. We can force OCaml to assume we're dealing with a
      different type (say, a <literal>heartbeat</literal>) using a type
      annotation.
    </para>
    <programlisting language="ocaml">
...part 15 of records/main.topscript
# let get_heartbeat_session_id (t:heartbeat) = t.session_id;; 
val get_heartbeat_session_id : heartbeat -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      While it's possible to resolve ambiguous field names using type
      annotations, the ambiguity can be a bit confusing. Consider the
      following functions for grabbing the session id and status from a
      heartbeat.
    </para>
    <programlisting language="ocaml">
...part 16 of records/main.topscript
# let status_and_session t = (t.status_message, t.session_id);; 
val status_and_session : heartbeat -&gt; string * string = &lt;fun&gt;
# let session_and_status t = (t.session_id, t.status_message);; 
Characters 44-58:
Error: The record type logon has no field status_message
# let session_and_status (t:heartbeat) = (t.session_id, t.status_message);; 
val session_and_status : heartbeat -&gt; string * string = &lt;fun&gt;
</programlisting>
    <para>
      Why did the first definition succeed without a type annotation and
      the second one fail? The difference is that in the first case, the
      type-checker considered the <literal>status_message</literal>
      field first and thus concluded that the record was a
      <literal>heartbeat</literal>. When the order was switched, the
      <literal>session_id</literal> field was considered first, and so
      that drove the type to be considered to be a
      <literal>logon</literal>, at which point
      <literal>t.status_message</literal> no longer made sense.
    </para>
    <para>
      We can avoid this ambiguity altogether, either by using
      non-overlapping field names or, more generally, by minting a
      module for each type. Packing types into modules is a broadly
      useful idiom (and one used quite extensively by Core), providing
      for each type a name-space within which to put related values.
      When using this style, it is standard practice to name the type
      associated with the module <literal>t</literal>. Using this style
      we would write:
    </para>
    <programlisting language="ocaml">
...part 17 of records/main.topscript
# module Log_entry = struct
    type t =
      { session_id: string;
        time: Time.t;
        important: bool;
        message: string;
      }
  end
  module Heartbeat = struct
    type t =
      { session_id: string;
        time: Time.t;
        status_message: string;
      }
  end
  module Logon = struct
    type t =
      { session_id: string;
        time: Time.t;
        user: string;
        credentials: string;
      }
  end;; 
module Log_entry :
  sig
    type t = {
      session_id : string;
      time : Time.t;
      important : bool;
      message : string;
    }
  end
module Heartbeat :
  sig
    type t = { session_id : string; time : Time.t; status_message : string; }
  end
module Logon :
  sig
    type t = {
      session_id : string;
      time : Time.t;
      user : string;
      credentials : string;
    }
  end
</programlisting>
    <para>
      Now, our log-entry-creation function can be rendered as follows.
    </para>
    <programlisting language="ocaml">
...part 18 of records/main.topscript
# let create_log_entry ~session_id ~important message =
     { Log_entry.time = Time.now (); Log_entry.session_id;
       Log_entry.important; Log_entry.message }
  ;; 
val create_log_entry :
  session_id:string -&gt; important:bool -&gt; string -&gt; Log_entry.t = &lt;fun&gt;
</programlisting>
    <para>
      The module name <literal>Log_entry</literal> is required to
      qualify the fields, because this function is outside of the
      <literal>Log_entry</literal> module where the record was defined.
      OCaml only requires the module qualification for one record field,
      however, so we can write this more concisely. Note that we are
      allowed to insert whitespace between the module-path and the field
      name.
    </para>
    <programlisting language="ocaml">
...part 19 of records/main.topscript
# let create_log_entry ~session_id ~important message =
     { Log_entry.
       time = Time.now (); session_id; important; message }
  ;; 
val create_log_entry :
  session_id:string -&gt; important:bool -&gt; string -&gt; Log_entry.t = &lt;fun&gt;
</programlisting>
    <para>
      This is not restricted to constructing a record; we can use the
      same trick when pattern matching.
    </para>
    <programlisting language="ocaml">
...part 20 of records/main.topscript
# let message_to_string { Log_entry.important; message; _ } =
    if important then String.uppercase message else message
  ;; 
val message_to_string : Log_entry.t -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      When using dot-notation for accessing record fields, we can
      qualify the field by the module directly.
    </para>
    <programlisting language="ocaml">
...part 21 of records/main.topscript
# let is_important t = t.Log_entry.important;; 
val is_important : Log_entry.t -&gt; bool = &lt;fun&gt;
</programlisting>
    <para>
      The syntax here is a little surprising when you first encounter
      it. The thing to keep in mind is that the dot is being used in two
      ways: the first dot is a record field access, with everything to
      the right of the dot being interpreted as a field name; the second
      dot is accessing the contents of a module, referring to the record
      field <literal>important</literal> from within the module
      <literal>Log_entry</literal>. The fact that
      <literal>Log_entry</literal> is capitalized and so can't be a
      field name is what disambiguates the two uses.
    </para>
    <para>
      For functions defined within the module where a given record is
      defined, the module qualification goes away entirely.
    </para>
  </sect1>
  <sect1 id="functional-updates">
    <title>Functional updates</title>
    <para>
      Fairly often, you will find yourself wanting to create a new
      record that differs from an existing record in only a subset of
      the fields. For example, imagine our logging server had a record
      type for representing the state of a given client, including when
      the last heartbeat was received from that client. The following
      defines a type for representing this information, as well as a
      function for updating the client information when a new heartbeat
      arrives.
    </para>
    <programlisting language="ocaml">
...part 22 of records/main.topscript
# type client_info =
   { addr: Unix.Inet_addr.t;
     port: int;
     user: string;
     credentials: string;
     last_heartbeat_time: Time.t;
   };; 
type client_info = {
  addr : UnixLabels.inet_addr;
  port : int;
  user : string;
  credentials : string;
  last_heartbeat_time : Time.t;
}
# let register_heartbeat t hb =
      { addr = t.addr;
        port = t.port;
        user = t.user;
        credentials = t.credentials;
        last_heartbeat_time = hb.Heartbeat.time;
      };; 
val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; client_info = &lt;fun&gt;
</programlisting>
    <para>
      This is fairly verbose, given that there's only one field that we
      actually want to change, and all the others are just being copied
      over from <literal>t</literal>. We can use OCaml's
      <emphasis>functional update</emphasis> syntax to do this more
      tersely. The syntax of a functional update is as follows.
    </para>
    <programlisting language="html">
{ &lt;record&gt; with &lt;field&gt; = &lt;value&gt;;
                &lt;field&gt; = &lt;value&gt;;
                ...
}
</programlisting>
    <para>
      The purpose of the functional update is to create a new record
      based on an existing one, with a set of field changes layered on
      top.
    </para>
    <para>
      Given this, we can rewrite <literal>register_heartbeat</literal>
      more concisely.
    </para>
    <programlisting language="ocaml">
...part 23 of records/main.topscript
# let register_heartbeat t hb =
    { t with last_heartbeat_time = hb.Heartbeat.time };; 
val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; client_info = &lt;fun&gt;
</programlisting>
    <para>
      Functional updates make your code independent of the identity of
      the fields in the record that are not changing. This is often what
      you want, but it has downsides as well. In particular, if you
      change the definition of your record to have more fields, the type
      system will not prompt you to reconsider whether your update code
      should affect those fields. Consider what happens if we decided to
      add a field for the status message received on the last heartbeat.
    </para>
    <programlisting language="ocaml">
...part 24 of records/main.topscript
# type client_info =
   { addr: Unix.Inet_addr.t;
     port: int;
     user: string;
     credentials: string;
     last_heartbeat_time: Time.t;
     last_heartbeat_status: string;
   };; 
type client_info = {
  addr : UnixLabels.inet_addr;
  port : int;
  user : string;
  credentials : string;
  last_heartbeat_time : Time.t;
  last_heartbeat_status : string;
}
</programlisting>
    <para>
      The original implementation of
      <literal>register_heartbeat</literal> would now be invalid, and
      thus the compiler would warn us to think about how to handle this
      new field. But the version using a functional update continues to
      compile as is, even though it incorrectly ignores the new field.
      The correct thing to do would be to update the code as follows.
    </para>
    <programlisting language="ocaml">
...part 25 of records/main.topscript
# let register_heartbeat t hb =
    { t with last_heartbeat_time   = hb.Heartbeat.time;
             last_heartbeat_status = hb.Heartbeat.status_message;
    };; 
val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; client_info = &lt;fun&gt;
</programlisting>
  </sect1>
  <sect1 id="mutable-fields">
    <title>Mutable fields</title>
    <para>
      Like most OCaml values, records are immutable by default. You can,
      however, declare individual record fields as mutable. In the
      following, we've made the last two fields of
      <literal>client_info</literal> mutable.
    </para>
    <programlisting language="ocaml">
...part 26 of records/main.topscript
# type client_info =
   { addr: Unix.Inet_addr.t;
     port: int;
     user: string;
     credentials: string;
     mutable last_heartbeat_time: Time.t;
     mutable last_heartbeat_status: string;
   };; 
type client_info = {
  addr : UnixLabels.inet_addr;
  port : int;
  user : string;
  credentials : string;
  mutable last_heartbeat_time : Time.t;
  mutable last_heartbeat_status : string;
}
</programlisting>
    <para>
      We then use the <literal>&lt;-</literal> operator for actually
      changing the state. The side-effecting version of
      <literal>register_heartbeat</literal> would be written as follows.
    </para>
    <programlisting language="ocaml">
...part 27 of records/main.topscript
# let register_heartbeat t hb =
    t.last_heartbeat_time   &lt;- hb.Heartbeat.time;
    t.last_heartbeat_status &lt;- hb.Heartbeat.status_message
  ;; 
val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; unit = &lt;fun&gt;
</programlisting>
    <para>
      Note that mutable assignment, and thus the
      <literal>&lt;-</literal> operator, is not needed for
      initialization, because all fields of a record, including mutable
      ones, are specified when the record is created.
    </para>
    <para>
      OCaml's policy of immutable-by-default is a good one, but
      imperative programming does have its place. We'll discuss more
      about how (and when) to use OCaml's imperative features in
      <xref linkend="imperative-programming"/>.
    </para>
  </sect1>
  <sect1 id="first-class-fields">
    <title>First-class fields</title>
    <para>
      Consider the following function for extracting the usernames from
      a list of <literal>Logon</literal> messages.
    </para>
    <programlisting language="ocaml">
...part 28 of records/main.topscript
# let get_users logons =
     List.dedup (List.map logons ~f:(fun x -&gt; x.Logon.user));; 
val get_users : Logon.t list -&gt; string list = &lt;fun&gt;
</programlisting>
    <para>
      Here, we wrote a small function
      <literal>(fun x -&gt; x.Logon.user)</literal> to access the
      <literal>user</literal> field. This kind of accessor function is a
      common enough pattern that it would be convenient to generate them
      automatically. The <literal>fieldslib</literal> syntax extension
      that ships with <literal>Core</literal> does just that.
    </para>
    <para>
      The <literal>with fields</literal> annotation at the end of the
      declaration of a record type will cause the extension to be
      applied to a given type declaration. So, for example, we could
      have defined <literal>Logon</literal> as follows.
    </para>
    <programlisting language="ocaml">
# script records/main-29.rawscript
$ utop
# module Logon = struct
    type t =
      { session_id: string;
        time: Time.t;
        user: string;
        credentials: string;
      }
    with fields
  end;;
module Logon :
  sig
    type t = {
      session_id : string;
      time : Time.t;
      user : string;
      credentials : string;
    }
    val credentials : t -&gt; string
    val user : t -&gt; string
    val time : t -&gt; Time.t
    val session_id : t -&gt; string
    module Fields :
      sig
        val names : string list
        val credentials :
          ([&lt; `Read | `Set_and_create ], t, string) Field.t_with_perm
        val user :
          ([&lt; `Read | `Set_and_create ], t, string) Field.t_with_perm
        val time :
          ([&lt; `Read | `Set_and_create ], t, Time.t) Field.t_with_perm
        val session_id :
          ([&lt; `Read | `Set_and_create ], t, string) Field.t_with_perm

        [ ... many definitions omitted ... ]

      end
  end
</programlisting>
    <para>
      Note that this will generate a <emphasis>lot</emphasis> of output,
      because <literal>fieldslib</literal> generates a large collection
      of helper functions for working with record fields. We'll only
      discuss a few of these; you can learn about the remainder from the
      documentation that comes with <literal>fieldslib</literal>.
    </para>
    <para>
      One of the functions we obtain is <literal>Logon.user</literal>,
      which we can use to extract the user field from a logon message.
    </para>
    <programlisting language="ocaml">
...part 30 of records/main.topscript
# let get_users logons = List.dedup (List.map logons ~f:Logon.user);; 
val get_users : Logon.t list -&gt; string list = &lt;fun&gt;
</programlisting>
    <para>
      In addition to generating field accessor functions,
      <literal>fieldslib</literal> also creates a sub-module called
      <literal>Fields</literal> that contains a first-class
      representative of each field, in the form of a value of type
      <literal>Field.t</literal>. The <literal>Field</literal> module
      provides the following functions:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>Field.name</literal>, which returns the name of a
          field
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>Field.get</literal>, which returns the content of a
          field
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>Field.fset</literal>, which does a functional update
          of a field
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>Field.setter</literal>, which returns
          <literal>None</literal> if the field is not mutable or
          <literal>Some f</literal> if it is, where <literal>f</literal>
          is a function for mutating that field.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      A <literal>Field.t</literal> has two type parameters: the first
      for the type of the record, and the second for the type of the
      field in question. Thus, the type of
      <literal>Logon.Fields.session_id</literal> is
      <literal>(Logon.t, string) Field.t</literal>, whereas the type of
      <literal>Logon.Fields.time</literal> is
      <literal>(Logon.t, Time.t) Field.t</literal>. Thus, if you call
      <literal>Field.get</literal> on
      <literal>Logon.Fields.user</literal>, you'll get a function for
      extracting the <literal>user</literal> field from a
      <literal>Logon.t</literal>.
    </para>
    <programlisting language="ocaml">
...part 31 of records/main.topscript
# Field.get Logon.Fields.user;; 
- : Logon.t -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      Thus, first parameter of the <literal>Field.t</literal>
      corresponds to the record you pass to <literal>get</literal>, and
      the second argument corresponds to the value contained in the
      field, which is also the return type of <literal>get</literal>.
    </para>
    <para>
      The type of <literal>Field.get</literal> is a little more
      complicated than you might naively expect from the above, as you
      can see below.
    </para>
    <programlisting language="ocaml">
...part 32 of records/main.topscript
# Field.get;; 
- : ('b, 'r, 'a) Field.t_with_perm -&gt; 'r -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      The type is <literal>Field.t_with_perm</literal> rather than a
      simple <literal>Field.t</literal> because fields have a notion of
      access control associated with them because there are some special
      cases where we may expose the ability to read a field but not the
      ability to do a functional update.
    </para>
    <para>
      We can use first-class fields to do things like write a generic
      function for displaying a record field.
    </para>
    <programlisting language="ocaml">
...part 33 of records/main.topscript
# let show_field field to_string record =
    let name = Field.name field in
    let field_string = to_string (Field.get field record) in
    name ^ &quot;: &quot; ^ field_string
  ;; 
val show_field :
  ('a, 'b, 'c) Field.t_with_perm -&gt; ('c -&gt; string) -&gt; 'b -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      This takes three arguments: the <literal>Field.t</literal>, a
      function for converting the contents of the field in question to a
      string, and a record from which the field can be grabbed.
    </para>
    <para>
      Here's an example of <literal>show_field</literal> in action.
    </para>
    <programlisting language="ocaml">
...part 34 of records/main.topscript
# let logon = { Logon.
                session_id = &quot;26685&quot;;
                time = Time.now ();
                user = &quot;yminsky&quot;;
                credentials = &quot;Xy2d9W&quot;; }
  ;; 
val logon : Logon.t =
  {Logon.session_id = &quot;26685&quot;; time = 2013-08-11 22:06:16.571369+01:00;
   user = &quot;yminsky&quot;; credentials = &quot;Xy2d9W&quot;}
# show_field Logon.Fields.user Fn.id logon;; 
- : string = &quot;user: yminsky&quot;
# show_field Logon.Fields.time Time.to_string logon;; 
- : string = &quot;time: 2013-08-11 22:06:16.571369+01:00&quot;
</programlisting>
    <para>
      As a side note, the above is our first use of the
      <literal>Fn</literal> module (short for &quot;function&quot;)
      which provides a collection of useful primitives for dealing with
      functions. <literal>Fn.id</literal> is the identity function.
    </para>
    <para>
      <literal>fieldslib</literal> also provides higher-level operators,
      like <literal>Fields.fold</literal> and
      <literal>Fields.iter</literal>, which let you iterate over all the
      fields of a record. So, for example, in the case of
      <literal>Logon.t</literal>, the field iterator has the following
      type.
    </para>
    <programlisting language="ocaml">
...part 35 of records/main.topscript
# Logon.Fields.iter;; 
- : session_id:(([&lt; `Read | `Set_and_create ], Logon.t, string)
                Field.t_with_perm -&gt; 'a) -&gt;
    time:(([&lt; `Read | `Set_and_create ], Logon.t, Time.t) Field.t_with_perm -&gt;
          'b) -&gt;
    user:(([&lt; `Read | `Set_and_create ], Logon.t, string) Field.t_with_perm -&gt;
          'c) -&gt;
    credentials:(([&lt; `Read | `Set_and_create ], Logon.t, string)
                 Field.t_with_perm -&gt; 'd) -&gt;
    'd
= &lt;fun&gt;
</programlisting>
    <para>
      This is a bit daunting to look at, largely because of the access
      control markers, but the structure is actually pretty simple. Each
      labeled argument is a function that takes a first-class field of
      the necessary type as an argument. Note that
      <literal>iter</literal> passes each of these callbacks the
      <literal>Field.t</literal>, not the contents of the specific
      record field. The contents of the field, though, can be looked up
      using the combination of the record and the
      <literal>Field.t</literal>.
    </para>
    <para>
      Now, let's use <literal>Logon.Fields.iter</literal> and
      <literal>show_field</literal> to print out all the fields of a
      <literal>Logon</literal> record.
    </para>
    <programlisting language="ocaml">
...part 36 of records/main.topscript
# let print_logon logon =
    let print to_string field =
      printf &quot;%s\n&quot; (show_field field to_string logon)
    in
    Logon.Fields.iter
      ~session_id:(print Fn.id)
      ~time:(print Time.to_string)
      ~user:(print Fn.id)
      ~credentials:(print Fn.id)
  ;; 
val print_logon : Logon.t -&gt; unit = &lt;fun&gt;
# print_logon logon;; 

session_id: 26685
time: 2013-08-11 22:06:16.571369+01:00
user: yminsky
credentials: Xy2d9W
- : unit = ()
</programlisting>
    <para>
      One nice side effect of this approach is that it helps you adapt
      your code when the fields of a record change. If you were to add a
      field to <literal>Logon.t</literal>, the type of
      <literal>Logon.Fields.iter</literal> would change along with it,
      acquiring a new argument. Any code using
      <literal>Logon.Fields.iter</literal> won't compile until it's
      fixed to take this new argument into account.
    </para>
    <para>
      This exhaustion guarantee is a valuable one. Field iterators are
      useful for a variety of record-related tasks, from building record
      validation functions to scaffolding the definition of a web-form
      from a record type, and such applications can benefit from the
      guarantee that all fields of the record type in question have been
      considered.
    </para>
  </sect1>
</chapter><chapter id="variants">
  <title>Variants</title>
  <para>
    Variant types are one of the most useful features of OCaml, and also
    one of the most unusual. They let you represent data that may take
    on multiple different forms, where each form is marked by an
    explicit tag. As we'll see, when combined with pattern matching,
    variants give you a powerful way of representing complex data and of
    organizing the case-analysis on that information.
  </para>
  <para>
    The basic syntax of a variant type declaration is as follows.
  </para>
  <programlisting language="html">
type &lt;variant&gt; =
  | &lt;Tag&gt; [ of &lt;type&gt; [* &lt;type&gt;]... ]
  | &lt;Tag&gt; [ of &lt;type&gt; [* &lt;type&gt;]... ]
  | ...
</programlisting>
  <para>
    Each row starts with a tag that identifies that case, and in
    addition, there may be a collection of fields, each with its own
    type, that is associated with a given tag.
  </para>
  <para>
    Let's consider a concrete example of how variants can be useful.
    Almost all terminals support a set of 8 basic colors, and we can
    represent those colors using a variant. Each color is declared as a
    simple tag, with pipes used to separate the different cases. Note
    that variant tags must be capitalized.
  </para>
  <programlisting language="ocaml">
# script variants/main.topscript
$ utop
# type basic_color =
   | Black | Red | Green | Yellow | Blue | Magenta | Cyan | White ;; 
type basic_color =
    Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
# Cyan ;; 
- : basic_color = Cyan
# [Blue; Magenta; Red] ;; 
- : basic_color list = [Blue; Magenta; Red]
</programlisting>
  <para>
    The following function uses pattern matching to convert a
    <literal>basic_color</literal> to a corresponding integer. The
    exhaustiveness checking on pattern matches means that the compiler
    will warn us if we miss a color.
  </para>
  <programlisting language="ocaml">
...part 1 of variants/main.topscript
# let basic_color_to_int = function
  | Black -&gt; 0 | Red     -&gt; 1 | Green -&gt; 2 | Yellow -&gt; 3
  | Blue  -&gt; 4 | Magenta -&gt; 5 | Cyan  -&gt; 6 | White  -&gt; 7 ;; 
val basic_color_to_int : basic_color -&gt; int = &lt;fun&gt;
# List.map ~f:basic_color_to_int [Blue;Red];; 
- : int list = [4; 1]
</programlisting>
  <para>
    Using the above, we can generate escape codes to change the color of
    a given string displayed in a terminal.
  </para>
  <programlisting language="ocaml">
...part 2 of variants/main.topscript
# let color_by_number number text =
    sprintf &quot;\027[38;5;%dm%s\027[0m&quot; number text;; 
val color_by_number : int -&gt; string -&gt; string = &lt;fun&gt;
# let blue = color_by_number (basic_color_to_int Blue) &quot;Blue&quot;;; 
val blue : string = &quot;\027[38;5;4mBlue\027[0m&quot;
# (* printf &quot;Hello %s World!\n&quot; blue*) ();; 
- : unit = ()
</programlisting>
  <para>
    On most terminals, that word &quot;Blue&quot; will be rendered in
    blue.
  </para>
  <para>
    In this example, the cases of the variant are simple tags with no
    associated data. This is substantively the same as the enumerations
    found in languages like C and Java. But as we'll see, variants can
    do considerably more than represent a simple enumeration. Indeed, an
    enumeration isn't enough to effectively describe the full set of
    colors that a modern terminal can display. Many terminals, including
    the venerable <literal>xterm</literal>, support 256 different
    colors, broken up into the following groups.
  </para>
  <itemizedlist>
    <listitem>
      <para>
        The 8 basic colors, in regular and bold versions.
      </para>
    </listitem>
    <listitem>
      <para>
        A 6 × 6 × 6 RGB color cube
      </para>
    </listitem>
    <listitem>
      <para>
        A 24-level grayscale ramp
      </para>
    </listitem>
  </itemizedlist>
  <para>
    We'll also represent this more complicated color-space as a variant,
    but this time, the different tags will have arguments which describe
    the data available in each case. Note that variants can have
    multiple arguments, which are separated by <literal>*</literal>'s.
  </para>
  <programlisting language="ocaml">
...part 3 of variants/main.topscript
# type weight = Regular | Bold
  type color =
  | Basic of basic_color * weight (* basic colors, regular and bold *)
  | RGB   of int * int * int       (* 6x6x6 color cube *)
  | Gray  of int                   (* 24 grayscale levels *)
;; 
type weight = Regular | Bold
type color =
    Basic of basic_color * weight
  | RGB of int * int * int
  | Gray of int
# [RGB (250,70,70); Basic (Green, Regular)];; 
- : color list = [RGB (250, 70, 70); Basic (Green, Regular)]
</programlisting>
  <para>
    Once again, we'll use pattern matching to convert a color to a
    corresponding integer. But in this case, the pattern matching does
    more than separate out the different cases; it also allows us to
    extract the data associated with each tag.
  </para>
  <programlisting language="ocaml">
...part 4 of variants/main.topscript
# let color_to_int = function
    | Basic (basic_color,weight) -&gt;
      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in
      base + basic_color_to_int basic_color
    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | Gray i -&gt; 232 + i ;; 
val color_to_int : color -&gt; int = &lt;fun&gt;
</programlisting>
  <para>
    Now, we can print text using the full set of available colors.
  </para>
  <programlisting language="ocaml">
...part 5 of variants/main.topscript
# let color_print color s =
     printf &quot;%s\n&quot; (color_by_number (color_to_int color) s);; 
val color_print : color -&gt; string -&gt; unit = &lt;fun&gt;
# (* color_print (Basic (Red,Bold)) &quot;A bold red!&quot;*) ();; 
- : unit = ()
# (* color_print (Gray 4) &quot;A muted gray...&quot; *) ();; 
- : unit = ()
</programlisting>
  <note><title>
  Catch-all cases and refactoring
  </title>
  <para>
    OCaml's type system can act as a refactoring tool, by warning you of
    places where your code needs to be updated to match an interface
    change. This is particularly valuable in the context of variants.
  </para>
  <para>
    Consider what would happen if we were to change the definition of
    <literal>color</literal> to the following.
  </para>
  <programlisting language="ocaml">
...part 1 of variants/catch_all.topscript
# type color =
  | Basic of basic_color     (* basic colors *)
  | Bold  of basic_color     (* bold basic colors *)
  | RGB   of int * int * int (* 6x6x6 color cube *)
  | Gray  of int             (* 24 grayscale levels *)
;; 
type color =
    Basic of basic_color
  | Bold of basic_color
  | RGB of int * int * int
  | Gray of int
</programlisting>
  <para>
    We've essentially broken out the <literal>Basic</literal> case into
    two cases, <literal>Basic</literal> and <literal>Bold</literal>, and
    <literal>Basic</literal> has changed from having two arguments to
    one. <literal>color_to_int</literal> as we wrote it still expects
    the old structure of the variant, and if we try to compile that same
    code again, the compiler will notice the discrepancy.
  </para>
  <programlisting language="ocaml">
...part 2 of variants/catch_all.topscript
# let color_to_int = function
    | Basic (basic_color,weight) -&gt;
      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in
      base + basic_color_to_int basic_color
    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | Gray i -&gt; 232 + i ;; 
Characters 34-60:
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type basic_color
</programlisting>
  <para>
    Here, the compiler is complaining that the <literal>Basic</literal>
    tag is used with the wrong number of arguments. If we fix that,
    however, the compiler flag will flag a second problem, which is that
    we haven't handled the new <literal>Bold</literal> tag.
  </para>
  <programlisting language="ocaml">
...part 3 of variants/catch_all.topscript
# let color_to_int = function
    | Basic basic_color -&gt; basic_color_to_int basic_color
    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | Gray i -&gt; 232 + i ;; 

Characters 19-154:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Bold _
val color_to_int : color -&gt; int = &lt;fun&gt;
</programlisting>
  <para>
    Fixing this now leads us to the correct implementation.
  </para>
  <programlisting language="ocaml">
...part 4 of variants/catch_all.topscript
# let color_to_int = function
    | Basic basic_color -&gt; basic_color_to_int basic_color
    | Bold  basic_color -&gt; 8 + basic_color_to_int basic_color
    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | Gray i -&gt; 232 + i ;; 
val color_to_int : color -&gt; int = &lt;fun&gt;
</programlisting>
  <para>
    As we've seen, the type errors identified the things that needed to
    be fixed to complete the refactoring of the code. This is
    fantastically useful, but for it to work well and reliably, you need
    to write your code in a way that maximizes the compiler's chances of
    helping you find the bugs. To this end, a useful rule of thumb is to
    avoid catch-all cases in pattern matches.
  </para>
  <para>
    Here's an example that illustrates how catch-all cases interact with
    exhaustion checks. Imagine we wanted a version of
    <literal>color_to_int</literal> that works on older terminals by
    rendering the first 16 colors (the 8 <literal>basic_color</literal>s
    in regular and bold) in the normal way, but rendering everything
    else as white. We might have written the function as follows.
  </para>
  <programlisting language="ocaml">
...part 5 of variants/catch_all.topscript
# let oldschool_color_to_int = function
    | Basic (basic_color,weight) -&gt;
      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in
      base + basic_color_to_int basic_color
    | _ -&gt; basic_color_to_int White;; 
Characters 44-70:
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type basic_color
</programlisting>
  <para>
    But because the catch-all case encompasses all possibilities, the
    type system will no longer warn us that we have missed the new
    <literal>Bold</literal> case when we change the type to include it.
    We can get this check back by avoiding the catch-all case, and
    instead being explicit about the tags that are ignored.
  </para>
  </note>
  <sect1 id="combining-records-and-variants">
    <title>Combining records and variants</title>
    <para>
      The term <emphasis>algebraic data types</emphasis> is often used
      to describe a collection of types that includes variants, records
      and tuples. Algebraic data types act as a peculiarly useful and
      powerful language for describing data. At the heart of their
      utility is the fact that they combine two different kinds of
      types: <emphasis>product types</emphasis>, like tuples and
      records, which combine multiple different types together and are
      mathematically similar to cartesian products; and <emphasis>sum
      types</emphasis>, like variants, which let you combine multiple
      different possibilities into one type, and are mathematically
      similar to disjoint unions.
    </para>
    <para>
      Algebraic data types gain much of their power from the ability to
      construct layered combination of sums and products. Let's see what
      we can achieve with this by revisiting the logging server types
      that were described in <xref linkend="records"/>. We'll
      start by reminding ourselves of the definition of
      <literal>Log_entry.t</literal>.
    </para>
    <programlisting language="ocaml">
...part 1 of variants/logger.topscript
# module Log_entry = struct
    type t =
      { session_id: string;
        time: Time.t;
        important: bool;
        message: string;
      }
  end
  ;; 
module Log_entry :
  sig
    type t = {
      session_id : string;
      time : Time.t;
      important : bool;
      message : string;
    }
  end
</programlisting>
    <para>
      This record type combines multiple pieces of data into one value.
      In particular, a single <literal>Log_entry.t</literal> has a
      <literal>session_id</literal> <emphasis>and</emphasis> a
      <literal>time</literal> <emphasis>and</emphasis> an
      <literal>important</literal> flag <emphasis>and</emphasis> a
      <literal>message</literal>. More generally, you can think of
      record types as acting as conjunctions. Variants, on the other
      hand, are disjunctions, letting you represent multiple
      possibilities, as in the following example.
    </para>
    <programlisting language="ocaml">
...part 2 of variants/logger.topscript
# type client_message = | Logon of Logon.t
                        | Heartbeat of Heartbeat.t
                        | Log_entry of Log_entry.t
  ;; 
type client_message =
    Logon of Logon.t
  | Heartbeat of Heartbeat.t
  | Log_entry of Log_entry.t
</programlisting>
    <para>
      A <literal>client_message</literal> is a <literal>Logon</literal>
      <emphasis>or</emphasis> a <literal>Heartbeat</literal>
      <emphasis>or</emphasis> a <literal>Log_entry</literal>. If we want
      to write code that processes messages generically, rather than
      code specialized to a fixed message type, we need something like
      <literal>client_message</literal> to act as one overarching type
      for the different possible messages. We can then match on the
      <literal>client_message</literal> to determine the type of the
      particular message being dealt with.
    </para>
    <para>
      You can increase the precision of your types by using variants to
      represent differences between types, and records to represent
      shared structure. Consider the following function that takes a
      list of <literal>client_message</literal>s and returns all
      messages generated by a given user. The code in question is
      implemented by folding over the list of messages, where the
      accumulator is a pair of:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          the set of session identifiers for the user that have been
          seen thus far.
        </para>
      </listitem>
      <listitem>
        <para>
          the set of messages so far that are associated with the user.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Here's the concrete code.
    </para>
    <programlisting language="ocaml">
...part 3 of variants/logger.topscript
# let messages_for_user user messages =
    let (user_messages,_) =
      List.fold messages ~init:([],String.Set.empty)
        ~f:(fun ((messages,user_sessions) as acc) message -&gt;
          match message with
          | Logon m -&gt;
            if m.Logon.user = user then
              (message::messages, Set.add user_sessions m.Logon.session_id)
            else acc
          | Heartbeat _ | Log_entry _ -&gt;
            let session_id = match message with
              | Logon     m -&gt; m.Logon.session_id
              | Heartbeat m -&gt; m.Heartbeat.session_id
              | Log_entry m -&gt; m.Log_entry.session_id
            in
            if Set.mem user_sessions session_id then
              (message::messages,user_sessions)
            else acc
        )
    in
    List.rev user_messages
  ;; 
val messages_for_user : string -&gt; client_message list -&gt; client_message list =
  &lt;fun&gt;
</programlisting>
    <para>
      There's one awkward bit about the code above, which is the
      calculation of the session ids. In particular, we have the
      repetitive bit of code where we compute the
      <literal>session_id</literal>. This code effectively computes the
      session id for each underlying message type. The repetition in
      this case isn't that bad, but would become problematic in larger
      and more complicated examples. Also, we had to include code for
      the <literal>Logon</literal> case, even though it can't actually
      come up.
    </para>
    <para>
      We can improve the code by refactoring our types to explicitly
      separate the parts that are shared from those that are common. The
      first step is to cut down the definitions of the per-message
      records to just contain the unique components of each message.
    </para>
    <programlisting language="ocaml">
...part 4 of variants/logger.topscript
# module Log_entry = struct
    type t = { important: bool;
               message: string;
             }
  end
  module Heartbeat = struct
    type t = { status_message: string; }
  end
  module Logon = struct
    type t = { user: string;
               credentials: string;
             }
  end ;; 
module Log_entry : sig type t = { important : bool; message : string; } end
module Heartbeat : sig type t = { status_message : string; } end
module Logon : sig type t = { user : string; credentials : string; } end
</programlisting>
    <para>
      We can then define a variant type that covers the different
      possible unique components.
    </para>
    <programlisting language="ocaml">
...part 5 of variants/logger.topscript
# type details =
    | Logon of Logon.t
    | Heartbeat of Heartbeat.t
    | Log_entry of Log_entry.t
 ;; 
type details =
    Logon of Logon.t
  | Heartbeat of Heartbeat.t
  | Log_entry of Log_entry.t
</programlisting>
    <para>
      Separately, we need a record that contains the fields that are
      common across all messages.
    </para>
    <programlisting language="ocaml">
...part 6 of variants/logger.topscript
# module Common = struct
    type t = { session_id: string;
               time: Time.t;
             }
  end ;; 
module Common : sig type t = { session_id : string; time : Time.t; } end
</programlisting>
    <para>
      A full message can then be represented as a pair of a
      <literal>Common.t</literal> and a <literal>details</literal>.
      Using this, we can rewrite our example above as follows:
    </para>
    <programlisting language="ocaml">
...part 7 of variants/logger.topscript
# let messages_for_user user messages =
    let (user_messages,_) =
      List.fold messages ~init:([],String.Set.empty)
        ~f:(fun ((messages,user_sessions) as acc) ((common,details) as message) -&gt;
          let session_id = common.Common.session_id in
          match details with
          | Logon m -&gt;
            if m.Logon.user = user then
              (message::messages, Set.add user_sessions session_id)
            else acc
          | Heartbeat _ | Log_entry _ -&gt;
            if Set.mem user_sessions session_id then
              (message::messages,user_sessions)
            else acc
        )
    in
    List.rev user_messages
  ;; 
val messages_for_user :
  string -&gt; (Common.t * details) list -&gt; (Common.t * details) list = &lt;fun&gt;
</programlisting>
    <para>
      Note that the more complex match statement for computing the
      session id has been replaced with the simple expression
      <literal>common.Common.session_id</literal>.
    </para>
    <para>
      In addition, this design allows us to essentially downcast to the
      specific message type once we know what it is, and then dispatch
      code to handle just that message type. In particular, while we use
      the type <literal>Common.t * details</literal> to represent an
      arbitrary message, we can use
      <literal>Common.t * Logon.t</literal> to represent a logon
      message. Thus, if we had functions for handling individual message
      types, we could write a dispatch function as follows.
    </para>
    <programlisting language="ocaml">
...part 8 of variants/logger.topscript
# let handle_message server_state (common,details) =
    match details with
    | Log_entry m -&gt; handle_log_entry server_state (common,m)
    | Logon     m -&gt; handle_logon     server_state (common,m)
    | Heartbeat m -&gt; handle_heartbeat server_state (common,m)
  ;; 
Characters 95-111:
Error: Unbound value handle_log_entry
</programlisting>
    <para>
      And it's explicit at the type level that
      <literal>handle_log_entry</literal> sees only
      <literal>Log_entry</literal> messages,
      <literal>handle_logon</literal> sees only <literal>Logon</literal>
      messages, etc.
    </para>
  </sect1>
  <sect1 id="variants-and-recursive-data-structures">
    <title>Variants and recursive data structures</title>
    <para>
      Another common application of variants is to represent tree-like
      recursive data structures. We'll show how this can be done by
      walking through the design of a simple Boolean expression
      language. Such a language can be useful anywhere you need to
      specify filters, which are used in everything from packet
      analyzers to mail clients.
    </para>
    <para>
      An expression in this language will be defined by the variant
      <literal>expr</literal>, with one tag for each kind of expression
      we want to support.
    </para>
    <programlisting language="ocaml">
# script variants/blang.topscript
$ utop
# type 'a expr =
    | Base  of 'a
    | Const of bool
    | And   of 'a expr list
    | Or    of 'a expr list
    | Not   of 'a expr
  ;; 
type 'a expr =
    Base of 'a
  | Const of bool
  | And of 'a expr list
  | Or of 'a expr list
  | Not of 'a expr
</programlisting>
    <para>
      Note that the definition of the type <literal>expr</literal> is
      recursive, meaning that a <literal>expr</literal> may contain
      other <literal>expr</literal>s. Also, <literal>expr</literal> is
      parameterized by a polymorphic type <literal>'a</literal> which is
      used for specifying the type of the value that goes under the
      <literal>Base</literal> tag.
    </para>
    <para>
      The purpose of each tag is pretty straightforward.
      <literal>And</literal>, <literal>Or</literal> and
      <literal>Not</literal> are the basic operators for building up
      Boolean expressions, and <literal>Const</literal> lets you enter
      the constants <literal>true</literal> and
      <literal>false</literal>.
    </para>
    <para>
      The <literal>Base</literal> tag is what allows you to tie the
      <literal>expr</literal> to your application, by letting you
      specify an element of some base predicate type, whose truth or
      falsehood is determined by your application. If you were writing a
      filter language for an email processor, your base predicates might
      specify the tests you would run against an email, as in the
      following example.
    </para>
    <programlisting language="ocaml">
...part 1 of variants/blang.topscript
# type mail_field = To | From | CC | Date | Subject
  type mail_predicate = { field: mail_field;
                          contains: string }
  ;; 
type mail_field = To | From | CC | Date | Subject
type mail_predicate = { field : mail_field; contains : string; }
</programlisting>
    <para>
      Using the above, we can construct a simple expression with
      <literal>mail_predicate</literal> as its base predicate.
    </para>
    <programlisting language="ocaml">
...part 2 of variants/blang.topscript
# let test field contains = Base { field; contains };; 
val test : mail_field -&gt; string -&gt; mail_predicate expr = &lt;fun&gt;
# And [ Or [ test To &quot;doligez&quot;; test CC &quot;doligez&quot; ];
        test Subject &quot;runtime&quot;;
      ]
  ;; 
- : mail_predicate expr =
And
 [Or
   [Base {field = To; contains = &quot;doligez&quot;};
    Base {field = CC; contains = &quot;doligez&quot;}];
  Base {field = Subject; contains = &quot;runtime&quot;}]
</programlisting>
    <para>
      Being able to construct such expressions isn't enough; we also
      need to be able to evaluate such an expression. The following code
      shows how you could write a general-purpose evaluator for these
      expressions.
    </para>
    <programlisting language="ocaml">
...part 3 of variants/blang.topscript
# let rec eval expr base_eval =
    (* a shortcut, so we don't need to repeatedly pass [base_eval]
       explicitly to [eval] *)
    let eval' expr = eval expr base_eval in
    match expr with
    | Base  base   -&gt; base_eval base
    | Const bool   -&gt; bool
    | And   exprs -&gt; List.for_all exprs ~f:eval'
    | Or    exprs -&gt; List.exists  exprs ~f:eval'
    | Not   expr  -&gt; not (eval' expr)
  ;; 
val eval : 'a expr -&gt; ('a -&gt; bool) -&gt; bool = &lt;fun&gt;
</programlisting>
    <para>
      The structure of the code is pretty straightforward—we're just
      pattern matching over the structure of the data, doing the
      appropriate calculation based on which tag we see. To use this
      evaluator on a concrete example, we just need to write the
      <literal>base_eval</literal> function which is capable of
      evaluating a base predicate.
    </para>
    <para>
      Another useful operation on expressions is simplification. The
      following simplification code is based on having some simplifying
      constructors that mirror the tags used to construct a tree. Then
      the simplification function is responsible for rebuilding the tree
      using these constructors.
    </para>
    <programlisting language="ocaml">
...part 4 of variants/blang.topscript
# let and_ l =
    if List.mem l (Const false) then Const false
    else
      match List.filter l ~f:((&lt;&gt;) (Const true)) with
      | [] -&gt; Const true
      | [ x ] -&gt; x
      | l -&gt; And l

  let or_ l =
    if List.mem l (Const true) then Const true
    else
      match List.filter l ~f:((&lt;&gt;) (Const false)) with
      | [] -&gt; Const false
      | [x] -&gt; x
      | l -&gt; Or l

  let not_ = function
    | Const b -&gt; Const (not b)
    | e -&gt; Not e
  ;; 
val and_ : 'a expr list -&gt; 'a expr = &lt;fun&gt;
val or_ : 'a expr list -&gt; 'a expr = &lt;fun&gt;
val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;
</programlisting>
    <para>
      Now, we can write a simplification routine that brings these
      together.
    </para>
    <programlisting language="ocaml">
...part 5 of variants/blang.topscript
# let rec simplify = function
    | Base _ | Const _ as x -&gt; x
    | And l -&gt; and_ (List.map ~f:simplify l)
    | Or l  -&gt; or_  (List.map ~f:simplify l)
    | Not e -&gt; not_ (simplify e)
  ;; 
val simplify : 'a expr -&gt; 'a expr = &lt;fun&gt;
</programlisting>
    <para>
      We can now apply this to a boolean expression and see how good of
      a job it does at simplifying it.
    </para>
    <programlisting language="ocaml">
...part 6 of variants/blang.topscript
# simplify (Not (And [ Or [Base &quot;it's snowing&quot;; Const true];
                       Base &quot;it's raining&quot;]));; 
- : string expr = Not (Base &quot;it's raining&quot;)
</programlisting>
    <para>
      Here, it correctly converted the <literal>Or</literal> branch to
      <literal>Const true</literal>, and then eliminated the
      <literal>And</literal>, entirely, since the <literal>And</literal>
      then had only one non-trivial component.
    </para>
    <para>
      There are some simplifications it misses, however. In particular,
      see what happens if we add a double negation in.
    </para>
    <programlisting language="ocaml">
...part 7 of variants/blang.topscript
# simplify (Not (And [ Or [Base &quot;it's snowing&quot;; Const true];
                       Not (Not (Base &quot;it's raining&quot;))]));; 
- : string expr = Not (Not (Not (Base &quot;it's raining&quot;)))
</programlisting>
    <para>
      It fails to remove the double negation, and it's easy to see why.
      The <literal>not_</literal> function has a catch-all case, so it
      ignores everything but the one case it explicitly considers, that
      of the negation of a constant. Catch-all cases are generally a bad
      idea, and if we make the code more explicit, we see that the
      missing of the double-negation is more obvious.
    </para>
    <programlisting language="ocaml">
...part 8 of variants/blang.topscript
# let not_ = function
    | Const b -&gt; Const (not b)
    | (Base _ | And _ | Or _ | Not _) as e -&gt; Not e
  ;; 
val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;
</programlisting>
    <para>
      We can of course fix this by handling simply adding an explicit
      case for double-negation.
    </para>
    <programlisting language="ocaml">
...part 9 of variants/blang.topscript
# let not_ = function
    | Const b -&gt; Const (not b)
    | Not e -&gt; e
    | (Base _ | And _ | Or _ ) as e -&gt; Not e
  ;; 
val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;
</programlisting>
    <para>
      The example of a boolean expression language is more than a toy.
      There's a module very much in this spirit in Core called
      <literal>Blang</literal> (short for &quot;boolean language&quot;),
      and it gets a lot of practical use in a variety of applications.
      The simplification algorithm in particular is useful when you want
      to use it to specialize the evaluation of expressions for which
      the evaluation of some of the base predicates is already known.
    </para>
    <para>
      More generally, using variants to build recursive data structures
      is a common technique, and shows up everywhere from designing
      little languages to building complex data structures.
    </para>
  </sect1>
  <sect1 id="polymorphic-variants">
    <title>Polymorphic variants</title>
    <para>
      In addition to the ordinary variants we've seen so far, OCaml also
      supports so-called <emphasis>polymorphic variants</emphasis>. As
      we'll see, polymorphic variants are more flexible and
      syntactically more lightweight than ordinary variants, but that
      extra power comes at a cost.
    </para>
    <para>
      Syntactically, polymorphic variants are distinguished from
      ordinary variants by the leading backtick. And unlike ordinary
      variants, polymorphic variants can be used without an explicit
      type declaration.
    </para>
    <programlisting language="ocaml">
...part 6 of variants/main.topscript
# let three = `Int 3;; 
val three : [&gt; `Int of int ] = `Int 3
# let four = `Float 4.;; 
val four : [&gt; `Float of float ] = `Float 4.
# let nan = `Not_a_number;; 
val nan : [&gt; `Not_a_number ] = `Not_a_number
# [three; four; nan];; 
- : [&gt; `Float of float | `Int of int | `Not_a_number ] list =
[`Int 3; `Float 4.; `Not_a_number]
</programlisting>
    <para>
      As you can see, polymorphic variant types are inferred
      automatically, and when we combine variants with different tags,
      the compiler infers a new type that knows about all of those tags.
      Note that in the above example, the tag name
      (<emphasis>e.g.</emphasis>, <literal>`Int</literal>) matches the
      type name (<literal>int</literal>). This is a common convention in
      OCaml.
    </para>
    <para>
      The type system will complain, if it sees incompatible uses of the
      same tag:
    </para>
    <programlisting language="ocaml">
...part 7 of variants/main.topscript
# let five = `Int &quot;five&quot;;; 
val five : [&gt; `Int of string ] = `Int &quot;five&quot;
# [three; four; five];; 
Characters 14-18:
Error: This expression has type [&gt; `Int of string ]
       but an expression was expected of type
         [&gt; `Float of float | `Int of int ]
       Types for tag `Int are incompatible
</programlisting>
    <para>
      The <literal>&gt;</literal> at the beginning of the variant types
      above is critical, because it marks the types as being open to
      combination with other variant types. We can read the type
      <literal>[&gt; `Int of string | `Float of float]</literal> as
      describing a variant whose tags include
      <literal>`Int of string</literal> and
      <literal>`Float of float</literal>, but may include more tags as
      well. In other words, you can roughly translate
      <literal>&gt;</literal> to mean: &quot;these tags or more&quot;.
    </para>
    <para>
      OCaml will in some cases infer a variant type with
      <literal>&lt;</literal>, to indicate &quot;these tags or
      less&quot;, as in the following example.
    </para>
    <programlisting language="ocaml">
...part 8 of variants/main.topscript
# let is_positive = function
     | `Int   x -&gt; x &gt; 0
     | `Float x -&gt; x &gt; 0.
  ;; 
val is_positive : [&lt; `Float of float | `Int of int ] -&gt; bool = &lt;fun&gt;
</programlisting>
    <para>
      The <literal>&lt;</literal> is there because
      <literal>is_positive</literal> has no way of dealing with values
      that have tags other than <literal>`Float of float</literal> or
      <literal>`Int of int</literal>.
    </para>
    <para>
      We can think of these <literal>&lt;</literal> and
      <literal>&gt;</literal> markers as indications of upper and lower
      bounds on the tags involved. If the same set of tags are both an
      upper and a lower bound, we end up with an
      <emphasis>exact</emphasis> polymorphic variant type, which has
      neither marker. For example:
    </para>
    <programlisting language="ocaml">
...part 9 of variants/main.topscript
# let exact = List.filter ~f:is_positive [three;four];; 
val exact : [ `Float of float | `Int of int ] list = [`Int 3; `Float 4.]
</programlisting>
    <para>
      Perhaps surprisingly, we can also create polymorphic variant types
      that have different upper and lower bounds. Note that
      <literal>Ok</literal> and <literal>Error</literal> in the
      following example come from the <literal>Result.t</literal> type
      from Core.
    </para>
    <programlisting language="ocaml">
...part 10 of variants/main.topscript
# let is_positive = function
     | `Int   x -&gt; Ok (x &gt; 0)
     | `Float x -&gt; Ok (x &gt; 0.)
     | `Not_a_number -&gt; Error &quot;not a number&quot;;; 
val is_positive :
  [&lt; `Float of float | `Int of int | `Not_a_number ] -&gt;
  (bool, string) Result.t = &lt;fun&gt;
# List.filter [three; four] ~f:(fun x -&gt;
     match is_positive x with Error _ -&gt; false | Ok b -&gt; b);; 
- : [&lt; `Float of float | `Int of int | `Not_a_number &gt; `Float `Int ] list =
[`Int 3; `Float 4.]
</programlisting>
    <para>
      Here, the inferred type states that the tags can be no more than
      <literal>`Float</literal>, <literal>`Int</literal> and
      <literal>`Not_a_number</literal>, and must contain at least
      <literal>`Float</literal> and <literal>`Int</literal>. As you can
      already start to see, polymorphic variants can lead to fairly
      complex inferred types.
    </para>
    <sect2 id="example-terminal-colors-redux">
      <title>Example: Terminal colors redux</title>
      <para>
        To see how to use polymorphic variants in practice, we'll return
        to terminal colors. Imagine that we have a new terminal type
        that adds yet more colors, say, by adding an alpha channel so
        you can specify translucent colors. We could model this extended
        set of colors as follows, using an ordinary variant.
      </para>
      <programlisting language="ocaml">
...part 11 of variants/main.topscript
# type extended_color =
    | Basic of basic_color * weight  (* basic colors, regular and bold *)
    | RGB   of int * int * int       (* 6x6x6 color space *)
    | Gray  of int                   (* 24 grayscale levels *)
    | RGBA  of int * int * int * int (* 6x6x6x6 color space *)
  ;; 
type extended_color =
    Basic of basic_color * weight
  | RGB of int * int * int
  | Gray of int
  | RGBA of int * int * int * int
</programlisting>
      <para>
        We want to write a function
        <literal>extended_color_to_int</literal>, that works like
        <literal>color_to_int</literal> for all of the old kinds of
        colors, with new logic only for handling colors that include an
        alpha channel. One might try to write such a function as
        follows.
      </para>
      <programlisting language="ocaml">
...part 12 of variants/main.topscript
# let extended_color_to_int = function
    | RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
    | (Basic _ | RGB _ | Gray _) as color -&gt; color_to_int color
  ;; 
Characters 154-159:
Error: This expression has type extended_color
       but an expression was expected of type color
</programlisting>
      <para>
        The code looks reasonable enough, but it leads to a type error
        because <literal>extended_color</literal> and
        <literal>color</literal> are in the compiler's view distinct and
        unrelated types. The compiler doesn't, for example, recognize
        any equality between the <literal>Basic</literal> tag in the two
        types.
      </para>
      <para>
        What we want to do is to share tags between two different
        variant types, and polymorphic variants let us do this in a
        natural way. First, let's rewrite
        <literal>basic_color_to_int</literal> and
        <literal>color_to_int</literal> using polymorphic variants. The
        translation here is pretty straightforward.
      </para>
      <programlisting language="ocaml">
...part 13 of variants/main.topscript
# let basic_color_to_int = function
    | `Black -&gt; 0 | `Red     -&gt; 1 | `Green -&gt; 2 | `Yellow -&gt; 3
    | `Blue  -&gt; 4 | `Magenta -&gt; 5 | `Cyan  -&gt; 6 | `White  -&gt; 7

  let color_to_int = function
    | `Basic (basic_color,weight) -&gt;
      let base = match weight with `Bold -&gt; 8 | `Regular -&gt; 0 in
      base + basic_color_to_int basic_color
    | `RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | `Gray i -&gt; 232 + i
 ;; 
val basic_color_to_int :
  [&lt; `Black | `Blue | `Cyan | `Green | `Magenta | `Red | `White | `Yellow ] -&gt;
  int = &lt;fun&gt;
val color_to_int :
  [&lt; `Basic of
       [&lt; `Black
        | `Blue
        | `Cyan
        | `Green
        | `Magenta
        | `Red
        | `White
        | `Yellow ] *
       [&lt; `Bold | `Regular ]
   | `Gray of int
   | `RGB of int * int * int ] -&gt;
  int = &lt;fun&gt;
</programlisting>
      <para>
        Now we can try writing <literal>extended_color_to_int</literal>.
        The key issue with this code is that
        <literal>extended_color_to_int</literal> needs to invoke
        <literal>color_to_int</literal> with a narrower type,
        <emphasis>i.e.</emphasis>, one that includes fewer tags. Written
        properly, this narrowing can be done via a pattern match. In
        particular, in the following code, the type of the variable
        <literal>color</literal> includes only the tags
        <literal>`Basic</literal>, <literal>`RGB</literal> and
        <literal>`Gray</literal>, and not <literal>`RGBA</literal>.
      </para>
      <programlisting language="ocaml">
...part 14 of variants/main.topscript
# let extended_color_to_int = function
    | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
    | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color
  ;; 
val extended_color_to_int :
  [&lt; `Basic of
       [&lt; `Black
        | `Blue
        | `Cyan
        | `Green
        | `Magenta
        | `Red
        | `White
        | `Yellow ] *
       [&lt; `Bold | `Regular ]
   | `Gray of int
   | `RGB of int * int * int
   | `RGBA of int * int * int * int ] -&gt;
  int = &lt;fun&gt;
</programlisting>
      <para>
        The above code is more delicately balanced than one might
        imagine. In particular, if we use a catch-all case instead of an
        explicit enumeration of the cases, the type is no longer
        narrowed, and so compilation fails.
      </para>
      <programlisting language="ocaml">
...part 15 of variants/main.topscript
# let extended_color_to_int = function
    | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
    | color -&gt; color_to_int color
  ;; 
Characters 125-130:
Error: This expression has type [&gt; `RGBA of int * int * int * int ]
       but an expression was expected of type
         [&lt; `Basic of
              [&lt; `Black
               | `Blue
               | `Cyan
               | `Green
               | `Magenta
               | `Red
               | `White
               | `Yellow ] *
              [&lt; `Bold | `Regular ]
          | `Gray of int
          | `RGB of int * int * int ]
       The second variant type does not allow tag(s) `RGBA
</programlisting>
      <note>
      <title>
      Polymorphic variants and catch-all cases
      </title>
      <para>
        As we saw with the definition of <literal>is_positive</literal>,
        a match statement can lead to the inference of an upper bound on
        a variant type, limiting the possible tags to those that can be
        handled by the match. If we add a catch-all case to our match
        statement, we end up with a function with a lower bound.
      </para>
      <programlisting language="ocaml">
...part 16 of variants/main.topscript
# let is_positive_permissive = function
     | `Int   x -&gt; Ok (x &gt; 0)
     | `Float x -&gt; Ok (x &gt; 0.)
     | _ -&gt; Error &quot;Unknown number type&quot;
  ;; 
val is_positive_permissive :
  [&gt; `Float of float | `Int of int ] -&gt; (bool, string) Result.t = &lt;fun&gt;
# is_positive_permissive (`Int 0);; 
- : (bool, string) Result.t = Ok false
# is_positive_permissive (`Ratio (3,4));; 
- : (bool, string) Result.t = Error &quot;Unknown number type&quot;
</programlisting>
      <para>
        Catch-all cases are error-prone even with ordinary variants, but
        they are especially so with polymorphic variants. That's because
        you have no way of bounding what tags your function might have
        to deal with. Such code is particularly vulnerable to typos. For
        instance, if code that uses
        <literal>is_positive_permissive</literal> passes in
        <literal>Float</literal> misspelled as <literal>Floot</literal>,
        the erroneous code will compile without complaint.
      </para>
      <programlisting language="ocaml">
...part 17 of variants/main.topscript
# is_positive_permissive (`Floot 3.5);; 
- : (bool, string) Result.t = Error &quot;Unknown number type&quot;
</programlisting>
      <para>
        With ordinary variants, such a typo would have been caught as an
        unknown tag. As a general matter, one should be wary about
        mixing catch-all cases and polymorphic variants.
      </para>
      </note>
      <para>
        Let's consider how we might turn our code into a proper library
        with an implementation in an <literal>ml</literal> file and an
        interface in a separate <literal>mli</literal>, as we saw in
        <xref linkend="files-modules-and-programs"/>. Let's
        start with the <literal>mli</literal>.
      </para>
      <programlisting language="ocaml">
# script variants-termcol/terminal_color.mli
$ utop
open Core.Std

type basic_color =
  [ `Black   | `Blue | `Cyan  | `Green
  | `Magenta | `Red  | `White | `Yellow ]

type color =
  [ `Basic of basic_color * [ `Bold | `Regular ]
  | `Gray of int
  | `RGB  of int * int * int ]

type extended_color =
  [ color
  | `RGBA of int * int * int * int ]

val color_to_int          : color -&gt; int
val extended_color_to_int : extended_color -&gt; int
</programlisting>
      <para>
        Here, <literal>extended_color</literal> is defined as an
        explicit extension of <literal>color</literal>. Also, notice
        that we defined all of these types as exact variants. We can
        implement this library as follows.
      </para>
      <programlisting language="ocaml">
# script variants-termcol/terminal_color.ml
$ utop
open Core.Std

type basic_color =
  [ `Black   | `Blue | `Cyan  | `Green
  | `Magenta | `Red  | `White | `Yellow ]

type color =
  [ `Basic of basic_color * [ `Bold | `Regular ]
  | `Gray of int
  | `RGB  of int * int * int ]

type extended_color =
  [ color
  | `RGBA of int * int * int * int ]

let basic_color_to_int = function
  | `Black -&gt; 0 | `Red     -&gt; 1 | `Green -&gt; 2 | `Yellow -&gt; 3
  | `Blue  -&gt; 4 | `Magenta -&gt; 5 | `Cyan  -&gt; 6 | `White  -&gt; 7

let color_to_int = function
  | `Basic (basic_color,weight) -&gt;
    let base = match weight with `Bold -&gt; 8 | `Regular -&gt; 0 in
    base + basic_color_to_int basic_color
  | `RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
  | `Gray i -&gt; 232 + i

let extended_color_to_int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | `Grey x -&gt; 2000 + x
  | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color
</programlisting>
      <para>
        In the above code, we did something funny to the definition of
        <literal>extended_color_to_int</literal>, that underlines some
        of the downsides of polymorphic variants. In particular, we
        added some special-case handling for the color gray, rather than
        using <literal>color_to_int</literal>. Unfortunately, we
        misspelled <literal>Gray</literal> as <literal>Grey</literal>.
        This is exactly the kind of error that the compiler would catch
        with ordinary variants, but with polymorphic variants, this
        compiles without issue. All that happened was that the compiler
        inferred a wider type for
        <literal>extended_color_to_int</literal>, which happens to be
        compatible with the narrower type that was listed in the
        <literal>mli</literal>.
      </para>
      <para>
        If we add an explicit type annotation to the code itself (rather
        than just in the <literal>mli</literal>), then the compiler has
        enough information to warn us.
      </para>
      <programlisting language="ocaml">
...part 1 of variants-termcol-annotated/terminal_color.ml
let extended_color_to_int : extended_color -&gt; int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | `Grey x -&gt; 2000 + x
  | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color
</programlisting>
      <para>
        In particular, the compiler will complain that the
        <literal>`Grey</literal> case is unused.
      </para>
      <programlisting>
# running variants-termcol-annotated/build.out.sh
$ corebuild terminal_color.native
File &quot;terminal_color.ml&quot;, line 30, characters 4-11:
Error: This pattern matches values of type [? `Grey of 'a ]
       but a pattern was expected which matches values of type extended_color
       The second variant type does not allow tag(s) `Grey
Command exited with code 2.
</programlisting>
      <para>
        Once we have type definitions at our disposal, we can revisit
        the question of how we write the pattern match that narrows the
        type. In particular, we can explicitly use the type name as part
        of the pattern match, by prefixing it with a
        <literal>#</literal>.
      </para>
      <programlisting language="ocaml">
...part 1 of variants-termcol-fixed/terminal_color.ml
let extended_color_to_int : extended_color -&gt; int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | #color as color -&gt; color_to_int color
</programlisting>
      <para>
        This is useful when you want to narrow down to a type whose
        definition is long, and you don't want the verbosity of writing
        the tags down explicitly in the match.
      </para>
    </sect2>
    <sect2 id="when-to-use-polymorphic-variants">
      <title>When to use polymorphic variants</title>
      <para>
        At first glance, polymorphic variants look like a strict
        improvement over ordinary variants. You can do everything that
        ordinary variants can do, plus it's more flexible and more
        concise. What's not to like?
      </para>
      <para>
        In reality, regular variants are the more pragmatic choice most
        of the time. That's because the flexibility of polymorphic
        variants comes at a price. Here are some of the downsides.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis>Complexity:</emphasis> As we've seen, the typing
            rules for polymorphic variants are a lot more complicated
            than they are for regular variants. This means that heavy
            use of polymorphic variants can leave you scratching your
            head trying to figure out why a given piece of code did or
            didn't compile. It can also lead to absurdly long and hard
            to decode error messages. Indeed, concision at the value
            level is often balanced out by more verbosity at the type
            level.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>Error-finding:</emphasis> Polymorphic variants are
            type-safe, but the typing discipline that they impose is, by
            dint of its flexibility, less likely to catch bugs in your
            program.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>Efficiency:</emphasis> This isn't a huge effect,
            but polymorphic variants are somewhat heavier than regular
            variants, and OCaml can't generate code for matching on
            polymorphic variants that is quite as efficient as what it
            generated for regular variants.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        All that said, polymorphic variants are still a useful and
        powerful feature, but it's worth understanding their
        limitations, and how to use them sensibly and modestly.
      </para>
      <para>
        Probably the safest and most common use-case for polymorphic
        variants is where ordinary variants would be sufficient, but are
        syntactically too heavyweight. For example, you often want to
        create a variant type for encoding the inputs or outputs to a
        function, where it's not worth declaring a separate type for it.
        Polymorphic variants are very useful here, and as long as there
        are type annotations that constrain these to have explicit,
        exact types, this tends to work well.
      </para>
      <para>
        Variants are most problematic exactly where you take full
        advantage of their power; in particular, when you take advantage
        of the ability of polymorphic variant types to overlap in the
        tags they support. This ties into OCaml's support for subtyping.
        As we'll discuss further when we cover objects in
        <xref linkend="objects"/>, subtyping brings in a lot
        of complexity, and most of the time, that's complexity you want
        to avoid.
      </para>
    </sect2>
  </sect1>
</chapter><chapter id="error-handling">
  <title>Error Handling</title>
  <para>
    Nobody likes dealing with errors. It's tedious, it's easy to get
    wrong, and it's usually just not as fun as planning out how your
    program is going to succeed. But error handling is important, and
    however much you don't like thinking about it, having your software
    fail due to poor error handling code is worse.
  </para>
  <para>
    Thankfully, OCaml has powerful tools for handling errors reliably
    and with a minimum of pain. In this chapter we'll discuss some of
    the different approaches in OCaml to handling errors, and give some
    advice on how to design interfaces that make error handling easier.
  </para>
  <para>
    We'll start by describing the two basic approaches for reporting
    errors in OCaml: error-aware return types and exceptions.
  </para>
  <sect1 id="error-aware-return-types">
    <title>Error-aware return types</title>
    <para>
      The best way in OCaml to signal an error is to include that error
      in your return value. Consider the type of the
      <literal>find</literal> function in the <literal>List</literal>
      module.
    </para>
    <programlisting language="ocaml">
# script error-handling/main.topscript
$ utop
# List.find;; 
- : 'a list -&gt; f:('a -&gt; bool) -&gt; 'a option = &lt;fun&gt;
</programlisting>
    <para>
      The option in the return type indicates that the function may not
      succeed in finding a suitable element, as you can see below.
    </para>
    <programlisting language="ocaml">
...part 1 of error-handling/main.topscript
# List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 2) ;; 
- : int option = Some 2
# List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 10) ;; 
- : int option = None
</programlisting>
    <para>
      Having errors be explicit in the return values of your functions
      tells the caller that there is an error that needs to be handled.
      The caller can then handle the error explicitly, either recovering
      from the error or propagating it onward.
    </para>
    <para>
      Consider the <literal>compute_bounds</literal> function defined
      below. The function takes a list and a comparison function, and
      returns upper and lower bounds for the list by finding the
      smallest and largest element on the list.
      <literal>List.hd</literal> and <literal>List.last</literal>, which
      return <literal>None</literal> when they encounter an empty list,
      are used to extract the largest and smallest element of the list.
    </para>
    <programlisting language="ocaml">
...part 2 of error-handling/main.topscript
# let compute_bounds ~cmp list =
    let sorted = List.sort ~cmp list in
    match List.hd sorted, List.last sorted with
    | None,_ | _, None -&gt; None
    | Some x, Some y -&gt; Some (x,y)
  ;; 
val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =
  &lt;fun&gt;
</programlisting>
    <para>
      The match statement is used to handle the error cases, propagating
      a None in <literal>hd</literal> or <literal>last</literal> into
      the return value of <literal>compute_bounds</literal>.
    </para>
    <para>
      On the other hand, in <literal>find_mismatches</literal> below,
      errors encountered during the computation do not propagate to the
      return value of the function. <literal>find_mismatches</literal>
      takes two hash tables as arguments, and searches for keys that
      have different data in one table than in the other. As such, the
      failure to find a key in one table isn't a failure of any sort.
    </para>
    <programlisting language="ocaml">
...part 3 of error-handling/main.topscript
# let find_mismatches table1 table2 =
     Hashtbl.fold table1 ~init:[] ~f:(fun ~key ~data mismatches -&gt;
        match Hashtbl.find table2 key with
        | Some data' when data' &lt;&gt; data -&gt; key :: mismatches
        | _ -&gt; mismatches
     )
 ;; 
val find_mismatches : ('a, 'b) Hashtbl.t -&gt; ('a, 'b) Hashtbl.t -&gt; 'a list =
  &lt;fun&gt;
</programlisting>
    <para>
      The use of options to encode errors underlines the fact that it's
      not clear whether a particular outcome, like not finding something
      on a list, is an error or is just another valid outcome. This
      depends on the larger context of your program, and thus is not
      something that a general purpose library can know in advance. One
      of the advantages of error-aware return types is that they work
      well in both situations.
    </para>
    <sect2 id="encoding-errors-with-result">
      <title>Encoding errors with <literal>Result</literal></title>
      <para>
        Options aren't always a sufficiently expressive way to report
        errors. Specifically, when you encode an error as
        <literal>None</literal>, there's nowhere to say anything about
        the nature of the error.
      </para>
      <para>
        <literal>Result.t</literal> is meant to address this deficiency.
        The type is defined as follows.
      </para>
      <programlisting language="ocaml">
(* error-handling/result.mli  *)
module Result : sig
   type ('a,'b) t = | Ok of 'a
                    | Error of 'b
end
</programlisting>
      <para>
        A <literal>Result.t</literal> is essentially an option augmented
        with the ability to store other information in the error case.
        Like <literal>Some</literal> and <literal>None</literal> for
        options, the constructors <literal>Ok</literal> and
        <literal>Error</literal> are promoted to the toplevel by
        <literal>Core.Std</literal>. As such, we can write:
      </para>
      <programlisting language="ocaml">
...part 4 of error-handling/main.topscript
# [ Ok 3; Error &quot;abject failure&quot;; Ok 4 ];; 
- : (int, string) Result.t list = [Ok 3; Error &quot;abject failure&quot;; Ok 4]
</programlisting>
      <para>
        without first opening the <literal>Result</literal> module.
      </para>
    </sect2>
    <sect2 id="error-and-or_error">
      <title><literal>Error</literal> and
      <literal>Or_error</literal></title>
      <para>
        <literal>Result.t</literal> gives you complete freedom to choose
        the type of value you use to represent errors, but it's often
        useful to standardize on an error type. Among other things, this
        makes it easier to write utility functions to automate common
        error handling patterns.
      </para>
      <para>
        But which type to choose? Is it better to represent errors as
        strings? Some more structured representation like XML? Or
        something else entirely?
      </para>
      <para>
        Core's answer to this question is the <literal>Error.t</literal>
        type, which tries to forge a good compromise between efficiency,
        convenience, and control over the presentation of errors.
      </para>
      <para>
        It might not be obvious at first why efficiency is an issue at
        all. But generating error messages is an expensive business. An
        ASCII representation of a value can be quite time-consuming to
        construct, particularly if it includes expensive-to-convert
        numerical data.
      </para>
      <para>
        <literal>Error</literal> gets around this issue through
        laziness. In particular, an <literal>Error.t</literal> allows
        you to put off generation of the error string until and unless
        you need it, which means a lot of the time you never have to
        construct it at all. You can of course construct an error
        directly from a string:
      </para>
      <programlisting language="ocaml">
...part 5 of error-handling/main.topscript
# Error.of_string &quot;something went wrong&quot;;; 
- : Error.t = something went wrong
</programlisting>
      <para>
        But you can also construct an <literal>Error.t</literal> from a
        <emphasis>thunk</emphasis>, <emphasis>i.e.</emphasis>, a
        function that takes a single argument of type
        <literal>unit</literal>.
      </para>
      <programlisting language="ocaml">
...part 6 of error-handling/main.topscript
# Error.of_thunk (fun () -&gt;
    sprintf &quot;something went wrong: %f&quot; 32.3343);; 
- : Error.t = something went wrong: 32.334300
</programlisting>
      <para>
        In this case, we can benefit from the laziness of
        <literal>Error</literal>, since the thunk won't be called unless
        the <literal>Error.t</literal> is converted to a string.
      </para>
      <para>
        The most common way to create <literal>Error.t</literal>s is
        using <emphasis>s-expressions</emphasis>. An s-expression is a
        balanced parenthetical expression where the leaves of the
        expressions are strings. Thus, the following is a simple
        s-expression:
      </para>
      <programlisting language="scheme">
;; error-handling/sexpr.scm.scm
(This (is an) (s expression))
</programlisting>
      <para>
        S-expressions are supported by the <literal>sexplib</literal>
        package that is distributed with Core, and is the most common
        serialization format used in Core. Indeed, most types in Core
        come with built-in s-expression converters. Here's an example of
        creating an error using the sexp converter for times,
        <literal>Time.sexp_of_t</literal>.
      </para>
      <programlisting language="ocaml">
...part 7 of error-handling/main.topscript
# Error.create &quot;Something failed a long time ago&quot; Time.epoch Time.sexp_of_t;; 
- : Error.t =
Something failed a long time ago: (1970-01-01 01:00:00.000000+01:00)
</programlisting>
      <para>
        Note that the time isn't actually serialized into an
        s-expression until the error is printed out. We're not
        restricted to doing this kind of error reporting with built-in
        types. This will be discussed in more detail in
        <xref linkend="data-serialization-with-s-expressions"/>,
        but Sexplib comes with a language extension that can
        autogenerate sexp-converters for newly generated types, as shown
        below.
      </para>
      <programlisting language="ocaml">
...part 8 of error-handling/main.topscript
# let custom_to_sexp = &lt;:sexp_of&lt;float * string list * int&gt;&gt;;; 
val custom_to_sexp : float * string list * int -&gt; Sexp.t = &lt;fun&gt;
# custom_to_sexp (3.5, [&quot;a&quot;;&quot;b&quot;;&quot;c&quot;], 6034);; 
- : Sexp.t = (3.5 (a b c) 6034)
</programlisting>
      <para>
        We can use this same idiom for generating an error.
      </para>
      <programlisting language="ocaml">
...part 9 of error-handling/main.topscript
# Error.create &quot;Something went terribly wrong&quot;
    (3.5, [&quot;a&quot;;&quot;b&quot;;&quot;c&quot;], 6034)
    &lt;:sexp_of&lt;float * string list * int&gt;&gt; ;; 
- : Error.t = Something went terribly wrong: (3.5(a b c)6034)
</programlisting>
      <para>
        <literal>Error</literal> also supports operations for
        transforming errors. For example, it's often useful to augment
        an error with some extra information about the context of the
        error or to combine multiple errors together.
        <literal>Error.tag</literal> and
        <literal>Error.of_list</literal> fulfill these roles, as you can
        see below.
      </para>
      <programlisting language="ocaml">
...part 10 of error-handling/main.topscript
# Error.tag
    (Error.of_list [ Error.of_string &quot;Your tires were slashed&quot;;
                     Error.of_string &quot;Your windshield was smashed&quot; ])
    &quot;over the weekend&quot;
  ;; 
- : Error.t =
over the weekend: Your tires were slashed; Your windshield was smashed
</programlisting>
      <para>
        The type <literal>'a Or_error.t</literal> is just a shorthand
        for <literal>('a,Error.t) Result.t</literal>, and it is, after
        <literal>option</literal>, the most common way of returning
        errors in Core.
      </para>
    </sect2>
    <sect2 id="bind-and-other-error-handling-idioms">
      <title><literal>bind</literal> and other error-handling
      idioms</title>
      <para>
        As you write more error handling code in OCaml, you'll discover
        that certain patterns start to emerge. A number of these common
        patterns have been codified by functions in modules like
        <literal>Option</literal> and <literal>Result</literal>. One
        particularly useful pattern is built around the function
        <literal>bind</literal>, which is both an ordinary function and
        an infix operator <literal>&gt;&gt;=</literal>. Here's the
        definition of <literal>bind</literal> for options.
      </para>
      <programlisting language="ocaml">
...part 11 of error-handling/main.topscript
# let bind option f =
    match option with
    | None -&gt; None
    | Some x -&gt; f x
  ;; 
val bind : 'a option -&gt; ('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;
</programlisting>
      <para>
        As you can see, <literal>bind None f</literal> returns
        <literal>None</literal> without calling <literal>f</literal>,
        and <literal>bind (Some x) f</literal> returns
        <literal>f x</literal>. Perhaps surprisingly,
        <literal>bind</literal> can be used as a way of sequencing
        together error-producing functions so that the first one to
        produce an error terminates the computation. Here's a rewrite of
        <literal>compute_bounds</literal> to use a nested series of
        <literal>bind</literal>s.
      </para>
      <programlisting language="ocaml">
...part 12 of error-handling/main.topscript
# let compute_bounds ~cmp list =
    let sorted = List.sort ~cmp list in
    Option.bind (List.hd sorted) (fun first -&gt;
      Option.bind (List.last sorted) (fun last -&gt;
        Some (first,last)))
  ;; 
val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =
  &lt;fun&gt;
</programlisting>
      <para>
        The above code is a little bit hard to swallow, however, on a
        syntactic level. We can make it easier to read, and drop some of
        the parentheses, by using the infix operator form of bind, which
        we get access to by locally opening
        <literal>Option.Monad_infix</literal>. The module is called
        <literal>Monad_infix</literal> because the bind operator is part
        of a sub-interface called <literal>Monad</literal>, which we'll
        talk about more in
        <xref linkend="concurrent-programming-with-async"/>.
      </para>
      <programlisting language="ocaml">
...part 13 of error-handling/main.topscript
# let compute_bounds ~cmp list =
    let open Option.Monad_infix in
    let sorted = List.sort ~cmp list in
    List.hd sorted   &gt;&gt;= fun first -&gt;
    List.last sorted &gt;&gt;= fun last  -&gt;
    Some (first,last)
  ;; 
val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =
  &lt;fun&gt;
</programlisting>
      <para>
        This use of <literal>bind</literal> isn't really materially
        better than the one we started with, and indeed, for small
        examples like this, direct matching of options is generally
        better than using <literal>bind</literal>. But for large complex
        examples with many stages of error-handling, the bind idiom
        becomes clearer and easier to manage.
      </para>
      <para>
        There are other useful idioms encoded in the functions in
        <literal>Option</literal>. One example is
        <literal>Option.both</literal>, which takes two optional values
        and produces a new optional pair that is <literal>None</literal>
        if either of its arguments are <literal>None</literal>. Using
        <literal>Option.both</literal>, we can make
        <literal>compute_bounds</literal> even shorter.
      </para>
      <programlisting language="ocaml">
...part 14 of error-handling/main.topscript
# let compute_bounds ~cmp list =
    let sorted = List.sort ~cmp list in
    Option.both (List.hd sorted) (List.last sorted)
  ;; 
val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =
  &lt;fun&gt;
</programlisting>
      <para>
        These error-handling functions are valuable because they let you
        express your error handling both explicitly and concisely. We've
        only discussed these functions in the context of the
        <literal>Option</literal> module, but similar functionality is
        available in both <literal>Result</literal> and
        <literal>Or_error</literal>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="exceptions">
    <title>Exceptions</title>
    <para>
      Exceptions in OCaml are not that different from exceptions in many
      other languages, like Java, C# and Python. Exceptions are a way to
      terminate a computation and report an error, while providing a
      mechanism to catch and handle (and possibly recover from)
      exceptions that are triggered by sub-computations.
    </para>
    <para>
      You can trigger an exception by, for example, dividing an integer
      by zero:
    </para>
    <programlisting language="ocaml">
...part 15 of error-handling/main.topscript
# 3 / 0;; 
Exception: Division_by_zero.
</programlisting>
    <para>
      And an exception can terminate a computation even if it happens
      nested somewhere deep within it.
    </para>
    <programlisting language="ocaml">
...part 16 of error-handling/main.topscript
# List.map ~f:(fun x -&gt; 100 / x) [1;3;0;4];; 
Exception: Division_by_zero.
</programlisting>
    <para>
      If we put a <literal>printf</literal> in the middle of the
      computation, we can see that <literal>List.map</literal> is
      interrupted part way through it's execution, never getting to the
      end of the list.
    </para>
    <programlisting language="ocaml">
...part 17 of error-handling/main.topscript
# List.map ~f:(fun x -&gt; printf &quot;%d\n%!&quot; x; 100 / x) [1;3;0;4];; 

1
3
0
Exception: Division_by_zero.
</programlisting>
    <para>
      In addition to built-in exceptions like
      <literal>Divide_by_zero</literal>, OCaml lets you define your own.
    </para>
    <programlisting language="ocaml">
...part 18 of error-handling/main.topscript
# exception Key_not_found of string;; 
exception Key_not_found of string
# raise (Key_not_found &quot;a&quot;);; 
Exception: Key_not_found(&quot;a&quot;).
</programlisting>
    <para>
      Exceptions are ordinary values, and can be manipulated just like
      other OCaml values, as you can see below.
    </para>
    <programlisting language="ocaml">
...part 19 of error-handling/main.topscript
# let exceptions = [ Not_found; Division_by_zero; Key_not_found &quot;b&quot; ];; 
val exceptions : exn list = [Not_found; Division_by_zero; Key_not_found(&quot;b&quot;)]
# List.filter exceptions  ~f:(function
    | Key_not_found _ | Not_found -&gt; true
    | _ -&gt; false);; 
- : exn list = [Not_found; Key_not_found(&quot;b&quot;)]
</programlisting>
    <para>
      All exceptions are of type <literal>exn</literal>, and that type
      is a similar to a variant type of the kind we encountered in
      <xref linkend="variants"/>. The biggest difference is
      that it is an open type, meaning that new tags can be added at any
      time, by any part of the program. As such, you can never have a
      match on an exception that is guaranteed to exhaustively list all
      values.
    </para>
    <para>
      Here's an example of a function for looking up a key in an
      <emphasis>association list</emphasis>, <emphasis>i.e.</emphasis> a
      list of key/value pairs which uses this newly-defined exception:
    </para>
    <programlisting language="ocaml">
...part 20 of error-handling/main.topscript
# let rec find_exn alist key = match alist with
    | [] -&gt; raise (Key_not_found key)
    | (key',data) :: tl -&gt; if key = key' then data else find_exn tl key
  ;; 
val find_exn : (string * 'a) list -&gt; string -&gt; 'a = &lt;fun&gt;
# let alist = [(&quot;a&quot;,1); (&quot;b&quot;,2)];; 
val alist : (string * int) list = [(&quot;a&quot;, 1); (&quot;b&quot;, 2)]
# find_exn alist &quot;a&quot;;; 
- : int = 1
# find_exn alist &quot;c&quot;;; 
Exception: Key_not_found(&quot;c&quot;).
</programlisting>
    <para>
      Note that we named the function <literal>find_exn</literal> to
      warn the user that the function routinely throws exceptions, a
      convention that is used heavily in Core.
    </para>
    <para>
      In the above example, <literal>raise</literal> throws the
      exception, thus terminating the computation. The type of raise is
      a bit surprising when you first see it:
    </para>
    <programlisting language="ocaml">
...part 21 of error-handling/main.topscript
# raise;; 
- : exn -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      The return type of <literal>'a</literal> suggests that
      <literal>raise</literal> could return a value of any type. That
      seems impossible, and it is. Really, <literal>raise</literal> has
      this type because it never returns at all. This behavior isn't
      restricted to functions like <literal>raise</literal> that
      terminate by throwing exceptions. Here's another example of a
      function that doesn't return a value.
    </para>
    <programlisting language="ocaml">
...part 22 of error-handling/main.topscript
# let rec forever () = forever ();; 
val forever : unit -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      <literal>forever</literal> doesn't return a value for a different
      reason: it is an infinite loop.
    </para>
    <para>
      This all matters because it means that the return type of
      <literal>raise</literal> can be whatever it needs to be to fit in
      to the context it is called in. Thus, the type system will let us
      throw an exception anywhere in a program.
    </para>
    <note>
    <title>
    Declaring exceptions using <literal>with sexp</literal>
    </title>
    <para>
      OCaml can't always generate a useful textual representation of an
      exception. For example:
    </para>
    <programlisting language="ocaml">
...part 23 of error-handling/main.topscript
# exception Wrong_date of Date.t;; 
exception Wrong_date of Date.t
# Wrong_date (Date.of_string &quot;2011-02-23&quot;);; 
- : exn = Wrong_date(_)
</programlisting>
    <para>
      But if we declare the exception using <literal>with sexp</literal>
      (and the constituent types have sexp converters), we'll get
      something with more information.
    </para>
    <programlisting language="ocaml">
...part 24 of error-handling/main.topscript
# exception Wrong_date of Date.t with sexp;; 
exception Wrong_date of Date.t
# Wrong_date (Date.of_string &quot;2011-02-23&quot;);; 
- : exn = (//toplevel//.Wrong_date 2011-02-23)
</programlisting>
    <para>
      The period in front of <literal>Wrong_date</literal> is there
      because the representation generated by
      <literal>with sexp</literal> includes the full module path of the
      module where the exception in question is defined. In this case,
      since we've declared the exception at the toplevel, that module
      path is trivial.
    </para>
    <para>
      This is all part of the support for s-expressions provided by the
      Sexplib library and syntax-extension, which is described in more
      detail in
      <xref linkend="data-serialization-with-s-expressions"/>.
    </para>
    </note>
    <sect2 id="helper-functions-for-throwing-exceptions">
      <title>Helper functions for throwing exceptions</title>
      <para>
        OCaml and Core provide a number of helper functions to simplify
        the task of throwing exceptions. The simplest one is
        <literal>failwith</literal>, which could be defined as follows:
      </para>
      <programlisting language="ocaml">
...part 25 of error-handling/main.topscript
# let failwith msg = raise (Failure msg);; 
val failwith : string -&gt; 'a = &lt;fun&gt;
</programlisting>
      <para>
        There are several other useful functions for raising exceptions,
        which can be found in the API documentation for the
        <literal>Common</literal> and <literal>Exn</literal> modules in
        Core.
      </para>
      <para>
        Another important way of throwing an exception is the
        <literal>assert</literal> directive. <literal>assert</literal>
        is used for situations where a violation of the condition in
        question indicates a bug. Consider the following piece of code
        for zipping together two lists.
      </para>
      <programlisting language="ocaml">
...part 26 of error-handling/main.topscript
# let merge_lists xs ys ~f =
    if List.length xs &lt;&gt; List.length ys then None
    else
      let rec loop xs ys =
        match xs,ys with
        | [],[] -&gt; []
        | x::xs, y::ys -&gt; f x y :: loop xs ys
        | _ -&gt; assert false
      in
      Some (loop xs ys)
   ;; 
val merge_lists : 'a list -&gt; 'b list -&gt; f:('a -&gt; 'b -&gt; 'c) -&gt; 'c list option =
  &lt;fun&gt;
# merge_lists [1;2;3] [-1;1;2] ~f:(+);; 
- : int list option = Some [0; 3; 5]
# merge_lists [1;2;3] [-1;1] ~f:(+);; 
- : int list option = None
</programlisting>
      <para>
        Here we use <literal>assert false</literal>, which means that
        the assert is guaranteed to trigger. In general, one can put an
        arbitrary condition in the assertion.
      </para>
      <para>
        In this case, the assert can never be triggered because we have
        a check that makes sure that the lists are of the same length
        before we call <literal>loop</literal>. If we change the code so
        that we drop this test, then we can trigger the assert.
      </para>
      <programlisting language="ocaml">
...part 27 of error-handling/main.topscript
# let merge_lists xs ys ~f =
    let rec loop xs ys =
      match xs,ys with
      | [],[] -&gt; []
      | x::xs, y::ys -&gt; f x y :: loop xs ys
      | _ -&gt; assert false
    in
    loop xs ys
  ;; 
val merge_lists : 'a list -&gt; 'b list -&gt; f:('a -&gt; 'b -&gt; 'c) -&gt; 'c list = &lt;fun&gt;
# merge_lists [1;2;3] [-1] ~f:(+);; 
Exception: (Assert_failure //toplevel// 5 13).
</programlisting>
      <para>
        This shows what's special about <literal>assert</literal>, which
        is that it captures the line number and character offset of the
        source location from which the assertion was made.
      </para>
    </sect2>
    <sect2 id="exception-handlers">
      <title>Exception handlers</title>
      <para>
        So far, we've only seen exceptions fully terminate the execution
        of a computation. But often, we want a program to be able to
        respond to and recover from an exception. This is achieved
        through the use of <emphasis>exception handlers</emphasis>.
      </para>
      <para>
        In OCaml, an exception handler is declared using a
        <literal>try</literal>/<literal>with</literal> statement. Here's
        the basic syntax.
      </para>
      <programlisting language="html">
try &lt;expr&gt; with
| &lt;pat1&gt; -&gt; &lt;expr1&gt;
| &lt;pat2&gt; -&gt; &lt;expr2&gt;
...
</programlisting>
      <para>
        A <literal>try/with</literal> clause first evaluates its body,
        <literal>&lt;expr&gt;</literal>. If no exception is thrown, then
        the result of evaluating the body is what the entire
        <literal>try/with</literal> clause evaluates to.
      </para>
      <para>
        But if the evaluation of the body throws an exception, then the
        exception will be fed to the pattern match statements following
        the <literal>with</literal>. If the exception matches a pattern,
        then we consider the exception caught, and the
        <literal>try/with</literal> clause evaluates to the expression
        on the right-hand side of the matching pattern.
      </para>
      <para>
        Otherwise, the original exception continues up the stack of
        function calls, to be handled by the next outer exception
        handler. If the exception is never caught, it terminates the
        program.
      </para>
    </sect2>
    <sect2 id="cleaning-up-in-the-presence-of-exceptions">
      <title>Cleaning up in the presence of exceptions</title>
      <para>
        One headache with exceptions is that they can terminate your
        execution at unexpected places, leaving your program in an
        awkward state. Consider the following function for loading a
        file full of reminders, formatted as s-expressions.
      </para>
      <programlisting language="ocaml">
...part 28 of error-handling/main.topscript
# let reminders_of_sexp =
    &lt;:of_sexp&lt;(Time.t * string) list&gt;&gt;
  ;; 
val reminders_of_sexp : Sexp.t -&gt; (Time.t * string) list = &lt;fun&gt;
# let load_reminders filename =
    let inc = In_channel.create filename in
    let reminders = reminders_of_sexp (Sexp.input_sexp inc) in
    In_channel.close inc;
    reminders
  ;; 
val load_reminders : string -&gt; (Time.t * string) list = &lt;fun&gt;
</programlisting>
      <para>
        The problem with this code is that the function that loads the
        s-expression and parses it into a list of
        <literal>Time.t</literal>/<literal>string</literal> pairs might
        throw an exception if the file in question is malformed.
        Unfortunately, that means that the
        <literal>In_channel.t</literal> that was opened will never be
        closed, leading to a file-descriptor leak.
      </para>
      <para>
        We can fix this using Core's <literal>protect</literal>
        function. The purpose of <literal>protect</literal> is to ensure
        that the <literal>finally</literal> thunk will be called when
        <literal>f</literal> exits, whether it exits normally or with an
        exception. This is similar to the <literal>try/finally</literal>
        construct available in many programming languages, but it is
        implemented in a library, rather than being a built-in
        primitive. Here's how it could be used to fix
        <literal>load_reminders</literal>.
      </para>
      <programlisting language="ocaml">
...part 29 of error-handling/main.topscript
# let load_reminders filename =
    let inc = In_channel.create filename in
    protect ~f:(fun () -&gt; reminders_of_sexp (Sexp.input_sexp inc))
      ~finally:(fun () -&gt; In_channel.close inc)
  ;; 
val load_reminders : string -&gt; (Time.t * string) list = &lt;fun&gt;
</programlisting>
      <para>
        This is a common enough problem that
        <literal>In_channel</literal> has a function called
        <literal>with_file</literal> that automates this pattern.
      </para>
      <programlisting language="ocaml">
...part 30 of error-handling/main.topscript
# let reminders_of_sexp filename =
    In_channel.with_file filename ~f:(fun inc -&gt;
      reminders_of_sexp (Sexp.input_sexp inc))
  ;; 
val reminders_of_sexp : string -&gt; (Time.t * string) list = &lt;fun&gt;
</programlisting>
      <para>
        <literal>In_channel.with_file</literal> is actually built on top
        of <literal>protect</literal> so that it can clean up after
        itself in the presence of exceptions.
      </para>
    </sect2>
    <sect2 id="catching-specific-exceptions">
      <title>Catching specific exceptions</title>
      <para>
        OCaml's exception-handling system allows you to tune your
        error-recovery logic to the particular error that was thrown.
        For example, <literal>List.find_exn</literal> throws
        <literal>Not_found</literal> when the element in question can't
        be found. Let's look at an example of how you could take
        advantage of this. In particular, consider the following
        function
      </para>
      <programlisting language="ocaml">
...part 31 of error-handling/main.topscript
# let lookup_weight ~compute_weight alist key =
    try
      let data = List.Assoc.find_exn alist key in
      compute_weight data
    with
      Not_found -&gt; 0. ;; 
val lookup_weight :
  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =
  &lt;fun&gt;
</programlisting>
      <para>
        As you can see from the type, <literal>lookup_weight</literal>
        takes an association list, a key for looking up a corresponding
        value in that list, and a function for computing a
        floating-point weight from the looked-up value. If no value is
        found, then a weight of <literal>0.</literal> should be
        returned.
      </para>
      <para>
        The use of exceptions in this code, however, presents some
        problems. In particular, what happens if
        <literal>compute_weight</literal> throws an exception? Ideally,
        <literal>lookup_weight</literal> should propagate that exception
        on, but if the exception happens to be
        <literal>Not_found</literal>, then that's not what will happen:
      </para>
      <programlisting language="ocaml">
...part 32 of error-handling/main.topscript
# lookup_weight ~compute_weight:(fun _ -&gt; raise Not_found)
    [&quot;a&quot;,3; &quot;b&quot;,4] &quot;a&quot; ;; 
- : float = 0.
</programlisting>
      <para>
        This kind of problem is hard to detect in advance, because the
        type system doesn't tell you what exceptions a given function
        might throw. For this reason, it's generally better to avoid
        relying on the identity of the exception to determine the nature
        of a failure. A better approach is to narrow the scope of the
        exception handler, so that when it fires it's very clear what
        part of the code failed.
      </para>
      <programlisting language="ocaml">
...part 33 of error-handling/main.topscript
# let lookup_weight ~compute_weight alist key =
    match
      try Some (List.Assoc.find_exn alist key)
      with _ -&gt; None
    with
    | None -&gt; 0.
    | Some data -&gt; compute_weight data ;; 
val lookup_weight :
  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =
  &lt;fun&gt;
</programlisting>
      <para>
        At which point, it makes sense to simply use the non-exception
        throwing function, <literal>List.Assoc.find</literal>, instead.
      </para>
      <programlisting language="ocaml">
...part 34 of error-handling/main.topscript
# let lookup_weight ~compute_weight alist key =
    match List.Assoc.find alist key with
    | None -&gt; 0.
    | Some data -&gt; compute_weight data ;; 
val lookup_weight :
  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =
  &lt;fun&gt;
</programlisting>
    </sect2>
    <sect2 id="backtraces">
      <title>Backtraces</title>
      <para>
        A big part of the value of exceptions is that they provide
        useful debugging information in the form of a stack backtrace.
        Consider the following simple program.
      </para>
      <programlisting language="ocaml">
(* error-handling/blow_up.ml  *)
open Core.Std
exception Empty_list

let list_max = function
  | [] -&gt; raise Empty_list
  | hd :: tl -&gt; List.fold tl ~init:hd ~f:(Int.max)

let () =
  printf &quot;%d\n&quot; (list_max [1;2;3]);
  printf &quot;%d\n&quot; (list_max [])
</programlisting>
      <para>
        If we build and run this program, we'll get a stack backtrace
        that will give you some information about where the error
        occurred, and the stack of function calls that were in place at
        the time of the error.
      </para>
      <programlisting>
# running error-handling/build_blow_up.out.sh
$ corebuild blow_up.byte
$ ./blow_up.byte
3
Fatal error: exception Blow_up.Empty_list
Raised at file &quot;blow_up.ml&quot;, line 5, characters 16-26
Called from file &quot;blow_up.ml&quot;, line 10, characters 17-28
</programlisting>
      <para>
        You can also capture a backtrace within your program by calling
        <literal>Exn.backtrace</literal>, which returns the backtrace of
        the most recently thrown exception. This is useful for reporting
        detailed information on errors that did not cause your program
        to fail.
      </para>
      <para>
        This works well if you have backtraces enabled, but that isn't
        always the case. In fact, by default, OCaml has backtraces
        turned off, and even if you have them turned on at runtime, you
        can't get backtraces unless you have compiled with debugging
        symbols. Core reverses the default, so if you're linking in
        Core, you will have backtraces enabled at runtime.
      </para>
      <para>
        Even using Core and compiling with debugging symbols, you can
        turn backtraces off by setting the
        <literal>OCAMLRUNPARAM</literal> environment variable to be
        empty.
      </para>
      <programlisting>
# running error-handling/build_blow_up_notrace.out.sh
$ corebuild blow_up.byte
$ OCAMLRUNPARAM= ./blow_up.byte
3
Fatal error: exception Blow_up.Empty_list
</programlisting>
      <para>
        The resulting error message is considerably less informative.
        You can also turn backtraces off in your code by calling
        <literal>Backtrace.Exn.set_recording false</literal>.
      </para>
      <para>
        There is a legitimate reasons to run without backtraces: speed.
        OCaml's exceptions are fairly fast, but they're even faster
        still if you disable backtraces. Here's a simple benchmark that
        shows the effect, using the <literal>core_bench</literal>
        package.
      </para>
      <programlisting language="ocaml">
(* error-handling/exn_cost.ml  *)
open Core.Std
open Core_bench.Std

let simple_computation () =
  List.range 0 10
  |&gt; List.fold ~init:0 ~f:(fun sum x -&gt; sum + x * x)
  |&gt; ignore

let simple_with_handler () =
  try simple_computation () with Exit -&gt; ()

let end_with_exn () =
  try
    simple_computation ();
    raise Exit
  with Exit -&gt; ()

let () =
  [ Bench.Test.create ~name:&quot;simple computation&quot;
      (fun () -&gt; simple_computation ());
    Bench.Test.create ~name:&quot;simple computation w/handler&quot;
      (fun () -&gt; simple_with_handler ());
    Bench.Test.create ~name:&quot;end with exn&quot;
      (fun () -&gt; end_with_exn ());
  ]
  |&gt; Bench.make_command
  |&gt; Command.run
</programlisting>
      <para>
        We're testing three cases here: a simple computation with no
        exceptions; the same computation with an exception handler but
        no thrown exceptions; and finally the same computation where we
        use the exception to do the control flow back to the caller.
      </para>
      <para>
        If we run this with stacktraces on, the benchmark results look
        like this.
      </para>
      <programlisting>
# running error-handling/run_exn_cost.out.sh
$ corebuild -pkg core_bench exn_cost.native
$ ./exn_cost.native -ascii cycles
Estimated testing time 30s (change using -quota SECS).
                                                                
  Name                           Cycles   Time (ns)   % of max  
 ------------------------------ -------- ----------- ---------- 
  simple computation                279         116      76.68  
  simple computation w/handler      308         129      84.64  
  end with exn                      364         152     100.00  
                                                                
</programlisting>
      <para>
        Here, we see that we lose something like 20 cycles to adding an
        exception handler, and 30 more to actually throwing and catching
        an exception. If we turn backtraces off, then the results look
        like this.
      </para>
      <programlisting>
# running error-handling/run_exn_cost_notrace.out.sh
$ OCAMLRUNPARAM= ./exn_cost.native -ascii cycles
Estimated testing time 30s (change using -quota SECS).
                                                                
  Name                           Cycles   Time (ns)   % of max  
 ------------------------------ -------- ----------- ---------- 
  simple computation                279         117      83.46  
  simple computation w/handler      308         129      92.11  
  end with exn                      335         140     100.00  
                                                                
</programlisting>
      <para>
        Here, the handler costs about the same, at 20 cycles, but the
        exception itself costs only 20, as opposed to 30 additional
        cycles. All told, this should only matter if you're using
        exceptions routinely as part of your flow control, which is in
        most cases a stylistic mistake anyway.
      </para>
    </sect2>
    <sect2 id="from-exceptions-to-error-aware-types-and-back-again">
      <title>From exceptions to error-aware types and back again</title>
      <para>
        Both exceptions and error-aware types are necessary parts of
        programming in OCaml. As such, you often need to move between
        these two worlds. Happily, Core comes with some useful helper
        functions to help you do just that. For example, given a piece
        of code that can throw an exception, you can capture that
        exception into an option as follows:
      </para>
      <programlisting language="ocaml">
...part 35 of error-handling/main.topscript
# let find alist key =
    Option.try_with (fun () -&gt; find_exn alist key) ;; 
val find : (string * 'a) list -&gt; string -&gt; 'a option = &lt;fun&gt;
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;c&quot;;; 
- : int option = None
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;b&quot;;; 
- : int option = Some 2
</programlisting>
      <para>
        And <literal>Result</literal> and <literal>Or_error</literal>
        have similar <literal>try_with</literal> functions. So, we could
        write:
      </para>
      <programlisting language="ocaml">
...part 36 of error-handling/main.topscript
# let find alist key =
    Result.try_with (fun () -&gt; find_exn alist key) ;; 
val find : (string * 'a) list -&gt; string -&gt; ('a, exn) Result.t = &lt;fun&gt;
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;c&quot;;; 
- : (int, exn) Result.t = Core.Std.Result.Error Key_not_found(&quot;c&quot;)
</programlisting>
      <para>
        And then we can re-raise that exception:
      </para>
      <programlisting language="ocaml">
...part 37 of error-handling/main.topscript
# Result.ok_exn (find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;b&quot;);; 
- : int = 2
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="choosing-an-error-handling-strategy">
    <title>Choosing an error handling strategy</title>
    <para>
      Given that OCaml supports both exceptions and error-aware return
      types, how do you choose between them? The key is to think about
      the tradeoff between concision and explicitness.
    </para>
    <para>
      Exceptions are more concise because they allow you to defer the
      job of error handling to some larger scope, and because they don't
      clutter up your types. But this same concision comes at a cost:
      exceptions are all too easy to ignore. Error-aware return types,
      on the other hand, are fully manifest in your type definitions,
      making the errors that your code might generate explicit and
      impossible to ignore.
    </para>
    <para>
      The right tradeoff depends on your application. If you're writing
      a rough and ready program where getting it done quickly is key,
      and failure is not that expensive, then using exceptions
      extensively may be the way to go. If, on the other hand, you're
      writing production software whose failure is costly, then you
      should probably lean in the direction of using error-aware return
      types.
    </para>
    <para>
      To be clear, it doesn't make sense to avoid exceptions entirely.
      The old maxim of &quot;use exceptions for exceptional
      conditions&quot; applies. If an error occurs sufficiently rarely,
      then throwing an exception may well be the right behavior.
    </para>
    <para>
      Also, for errors that are omnipresent, error-aware return types
      may also be overkill. A good example is out-of-memory errors,
      which can occur anywhere, and so you'd need to use error-aware
      return types everywhere to capture those. And having every
      operation marked as one that might fail is no more explicit than
      having none of them marked.
    </para>
    <para>
      In short, for errors that are a foreseeable and ordinary part of
      the execution of your production code and that are not
      omnipresent, error aware return types are typically the right
      solution.
    </para>
  </sect1>
</chapter><chapter id="imperative-programming-1">
  <title>Imperative Programming</title>
  <para>
    Most of the code shown so far in this book, and indeed, most OCaml
    code in general, is <emphasis>pure</emphasis>. Pure code works
    without mutating the program's internal state, performing I/O,
    reading the clock, or in any other way interacting with changeable
    parts of the world. Thus, a pure function behaves like a
    mathematical function, always returning the same results when given
    the same inputs, and never affecting the world except insofar as it
    returns the value of its computation.
    <emphasis>Imperative</emphasis> code, on the other hand, operates by
    side-effects that modify a program's internal state or interact with
    the outside world. An imperative function has a new effect, and
    potentially returns different results, every time it's called.
  </para>
  <para>
    Pure code is the default in OCaml, and for good reason—it's
    generally easier to reason about, less error prone and more
    composable. But imperative code is of fundamental importance to any
    practical programming language because real-world tasks require that
    you interact with the outside world, which is by its nature
    imperative. Imperative programming can also be important for
    performance. While pure code is quite efficient in OCaml, there are
    many algorithms that can only be implemented efficiently using
    imperative techniques.
  </para>
  <para>
    OCaml offers a happy compromise here, making it easy and natural to
    program in a pure style, but also providing great support for
    imperative programming where you need it. This chapter will walk you
    through OCaml's imperative features, and help you use them to their
    fullest.
  </para>
  <sect1 id="example-imperative-dictionaries">
    <title>Example: Imperative dictionaries</title>
    <para>
      We'll start with the implementation of a simple imperative
      dictionary, <emphasis>i.e.</emphasis>, a mutable mapping from keys
      to values. This is really for illustration purposes; both Core and
      the standard library provide imperative dictionaries, and for most
      real world tasks, you should use one of those implementations.
      There's more advice on using Core's implementation in particular
      in <xref linkend="maps-and-hash-tables"/>.
    </para>
    <para>
      Our dictionary, like those in Core and the standard library, will
      be implemented as a hash table. In particular, we'll use an
      <emphasis>open hashing</emphasis> scheme, which is to say the hash
      table will be an array of buckets, each bucket containing a list
      of key/value pairs that have been hashed into that bucket.
    </para>
    <para>
      Here's the interface we'll match, provided as an
      <literal>mli</literal>. Here, the type
      <literal>('a, 'b) t</literal> is used for a dictionary with keys
      of type <literal>'a</literal> and data of type
      <literal>'b</literal>.
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dictionary.mli (starting from part 1) *)
(* file: dictionary.mli *)
open Core.Std

type ('a, 'b) t

val create : unit -&gt; ('a, 'b) t
val length : ('a, 'b) t -&gt; int
val add    : ('a, 'b) t -&gt; key:'a -&gt; data:'b -&gt; unit
val find   : ('a, 'b) t -&gt; 'a -&gt; 'b option
val iter   : ('a, 'b) t -&gt; f:(key:'a -&gt; data:'b -&gt; unit) -&gt; unit
val remove : ('a, 'b) t -&gt; 'a -&gt; unit
</programlisting>
    <para>
      The <literal>mli</literal> also includes a collection of helper
      functions whose purpose and behavior should be largely inferrable
      from their names and type signatures. Notice that a number of the
      functions, in particular, ones like <literal>add</literal> that
      modify the dictionary, return unit. This is typical of functions
      that act by side-effect.
    </para>
    <para>
      We'll now walk through the implementation (contained in the
      corresponding <literal>ml</literal> file) piece by piece,
      explaining different imperative constructs as they come up.
    </para>
    <para>
      Our first step is to define the type of a dictionary as a record
      with two fields.
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dictionary.ml (starting from part 1) *)
(* file: dictionary.ml *)
open Core.Std

type ('a, 'b) t = { mutable length: int;
                    buckets: ('a * 'b) list array;
                  }
</programlisting>
    <para>
      The first field, <literal>length</literal> is declared as mutable.
      In OCaml, records are immutable by default, but individual fields
      are mutable when marked as such. The second field,
      <literal>buckets</literal>, is immutable, but contains an array,
      which is itself a mutable data structure, as we'll see.
    </para>
    <para>
      Now we'll start putting together the basic functions for
      manipulating a dictionary.
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dictionary.ml (starting from part 2) *)
let num_buckets = 17

let hash_bucket key = (Hashtbl.hash key) mod num_buckets

let create () =
  { length = 0;
    buckets = Array.create ~len:num_buckets [];
  }

let length t = t.length

let find t key =
  List.find_map t.buckets.(hash_bucket key)
    ~f:(fun (key',data) -&gt; if key' = key then Some data else None)
</programlisting>
    <para>
      Note that <literal>num_buckets</literal> is a constant. That's
      because, for simplicity's sake, we're using a fixed-length bucket
      array. For a practical implementation, the length of the array
      would have to be able to grow as the number of elements in the
      dictionary increases.
    </para>
    <para>
      The function <literal>hash_bucket</literal> is used throughout the
      rest of the module to choose the position in the array that a
      given key should be stored at. It is implemented on top of
      <literal>Hashtbl.hash</literal>, which is a hash function provided
      by the OCaml runtime that can be applied to values of any type.
      Thus, its own type is polymorphic:
      <literal>'a -&gt; int</literal>.
    </para>
    <para>
      The other functions defined above are fairly straightforward:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>create</literal> creates an empty dictionary.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>length</literal> grabs the length from the
          corresponding record field, thus returning the number of
          entries stored in the dictionary.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>find</literal> looks for a matching key in the table
          and returns the corresponding value if found as an option.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Another bit of syntax has popped up in <literal>find</literal>: we
      write <literal>array.(index)</literal> to grab a value from an
      array. Also, <literal>find</literal> uses
      <literal>List.find_map</literal>, which you can see the type of by
      typing it into the toplevel:
    </para>
    <programlisting language="ocaml">
...part 1 of imperative-programming/examples.topscript
# List.find_map;; 
- : 'a list -&gt; f:('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;
</programlisting>
    <para>
      <literal>List.find_map</literal> iterates over the elements of the
      list, calling <literal>f</literal> on each one until a
      <literal>Some</literal> is returned by <literal>f</literal>, at
      which point the value returned by <literal>f</literal> is returned
      by <literal>find_map</literal>. If <literal>f</literal> returns
      <literal>None</literal> on all values, then
      <literal>None</literal> is returned by
      <literal>find_map</literal>.
    </para>
    <para>
      Now let's look at the implementation of <literal>iter</literal>:
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dictionary.ml (starting from part 3) *)
let iter t ~f =
  for i = 0 to Array.length t.buckets - 1 do
    List.iter t.buckets.(i) ~f:(fun (key, data) -&gt; f ~key ~data)
  done
</programlisting>
    <para>
      <literal>iter</literal> is designed to walk over all the entries
      in the dictionary. In particular, <literal>iter t ~f</literal>
      will call <literal>f</literal> for each key/value pair in
      dictionary <literal>t</literal>. Note that <literal>f</literal>
      must return <literal>unit</literal>, since it is expected to work
      by side effect rather than by returning a value, and the overall
      <literal>iter</literal> function returns <literal>unit</literal>
      as well.
    </para>
    <para>
      The code for <literal>iter</literal> uses two forms of iteration:
      a <literal>for</literal> loop to walk over the array of buckets;
      and within that loop a call to <literal>List.iter</literal> to
      walk over the values in a given bucket. We could have done the
      outer loop with a recursive function instead of a
      <literal>for</literal> loop, but <literal>for</literal> loops are
      syntactically convenient, and are more familiar and idiomatic in
      the context of imperative code.
    </para>
    <para>
      The following code is for adding and removing mappings from the
      dictionary.
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dictionary.ml (starting from part 4) *)
let bucket_has_key t i key =
  List.exists t.buckets.(i) ~f:(fun (key',_) -&gt; key' = key)

let add t ~key ~data =
  let i = hash_bucket key in
  let replace = bucket_has_key t i key in
  let filtered_bucket =
    if replace then
      List.filter t.buckets.(i) ~f:(fun (key',_) -&gt; key' &lt;&gt; key)
    else
      t.buckets.(i)
  in
  t.buckets.(i) &lt;- (key, data) :: filtered_bucket;
  if not replace then t.length &lt;- t.length + 1

let remove t key =
  let i = hash_bucket key in
  if bucket_has_key t i key then (
    let filtered_bucket =
      List.filter t.buckets.(i) ~f:(fun (key',_) -&gt; key' &lt;&gt; key)
    in
    t.buckets.(i) &lt;- filtered_bucket;
    t.length &lt;- t.length - 1
  )
</programlisting>
    <para>
      This above code is made more complicated by the fact that we need
      to detect whether we are overwriting or removing an existing
      binding, so we can decide whether <literal>t.length</literal>
      needs to be changed. The helper function
      <literal>bucket_has_key</literal> is used for this purpose.
    </para>
    <para>
      Another piece of syntax shows up in both <literal>add</literal>
      and <literal>remove</literal>: the use of the
      <literal>&lt;-</literal> operator to update elements of an array
      (<literal>array.(i) &lt;- expr</literal>) and for updating a
      record field (<literal>record.field &lt;- expression</literal>).
    </para>
    <para>
      We also use a single semicolon, <literal>;</literal>, as a
      sequencing operator, to allow us to do a sequence of
      side-effecting operations in a row: first, update the bucket, then
      update the count. We could have done this using let bindings:
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dictionary2.ml (starting from part 1) *)
let () = t.buckets.(i) &lt;- (key, data) :: filtered_bucket in
  if not replace then t.length &lt;- t.length + 1
</programlisting>
    <para>
      but <literal>;</literal> is more concise and idiomatic. More
      generally,
    </para>
    <programlisting language="html">
&lt;expr1&gt;;
&lt;expr2&gt;;
...
&lt;exprN&gt;
</programlisting>
    <para>
      is equivalent to
    </para>
    <programlisting language="html">
let () = &lt;expr1&gt; in
let () = &lt;expr2&gt; in
...
&lt;exprN&gt;
</programlisting>
    <para>
      When a sequence expression <literal>expr1; expr2</literal> is
      evaluated, <literal>expr1</literal> is evaluated first, and then
      <literal>expr2</literal>. The expression <literal>expr1</literal>
      should have type <literal>unit</literal> (though this is a warning
      rather than a hard restriction), and the value of
      <literal>expr2</literal> is returned as the value of the entire
      sequence. For example, the sequence
      <literal>print_string &quot;hello world&quot;; 1 + 2</literal>
      first prints the string
      <literal>&quot;hello world&quot;</literal>, then returns the
      integer <literal>3</literal>.
    </para>
    <para>
      Note also that we do all of the side-effecting operations at the
      very end of each function. This is good practice because it
      minimizes the chance that such operations will be interrupted with
      an exception, leaving the data structure in an inconsistent state.
    </para>
  </sect1>
  <sect1 id="primitive-mutable-data">
    <title>Primitive mutable data</title>
    <para>
      Now that we've looked at a complete example, let's take a more
      systematic look at imperative programming in OCaml. We encountered
      two different forms of mutable data above: records with mutable
      fields and arrays. We'll now discuss these in more detail, along
      with the other primitive forms of mutable data that are available
      in OCaml.
    </para>
    <sect2 id="array-like-data">
      <title>Array-like data</title>
      <para>
        OCaml supports a number of array-like data structures;
        <emphasis>i.e.</emphasis>, mutable integer-indexed containers
        that provide constant-time access to their elements. We'll
        discuss several of them below.
      </para>
      <sect3 id="ordinary-arrays">
        <title>Ordinary arrays</title>
        <para>
          The <literal>array</literal> type is used for general purpose
          polymorphic arrays. The <literal>Array</literal> module has a
          variety of utility functions for interacting with arrays,
          including a number of mutating operations. These include
          <literal>Array.set</literal>, for setting an individual
          element, and <literal>Array.blit</literal>, for efficiently
          copying values from one range of indices to another.
        </para>
        <para>
          Arrays also come with special syntax for retrieving an element
          from an array:
        </para>
        <programlisting language="html">
&lt;array_expr&gt;.(&lt;index_expr&gt;)
</programlisting>
        <para>
          and for setting an element in an array:
        </para>
        <programlisting language="html">
&lt;array_expr&gt;.(&lt;index_expr&gt;) &lt;- &lt;value_expr&gt;
</programlisting>
        <para>
          Out-of-bounds accesses for arrays (and indeed for all the
          array-like data structures) will lead to an exception being
          thrown.
        </para>
        <para>
          Array literals are written using <literal>[|</literal> and
          <literal>|]</literal> as delimiters. Thus,
          <literal>[| 1; 2; 3 |]</literal> is a literal integer array.
        </para>
      </sect3>
      <sect3 id="strings">
        <title>Strings</title>
        <para>
          Strings are essentially byte-arrays which are often used for
          textual data. The main advantage of using a
          <literal>string</literal> in place of a
          <literal>Char.t array</literal> (a <literal>Char.t</literal>
          is an 8-bit character) is that the former is considerably more
          space efficient; an array uses one word—8 bytes on a 64-bit
          machine—to store a single entry, whereas strings use one byte
          per character.
        </para>
        <para>
          Strings also come with their own syntax for getting and
          setting values:
        </para>
        <programlisting language="html">
&lt;string_expr&gt;.[&lt;index_expr&gt;]
&lt;string_expr&gt;.[&lt;index_expr&gt;] &lt;- &lt;char_expr&gt;
</programlisting>
        <para>
          And string literals are bounded by quotes. There's also a
          module <literal>String</literal> where you'll find useful
          functions for working with strings.
        </para>
      </sect3>
      <sect3 id="bigarrays">
        <title>Bigarrays</title>
        <para>
          A <literal>Bigarray.t</literal> is a handle to a block of
          memory stored outside of the OCaml heap. These are mostly
          useful for interacting with C or Fortran libraries, and are
          discussed in
          <xref linkend="memory-representation-of-values"/>.
          Bigarrays too have their own getting and setting syntax:
        </para>
        <programlisting language="html">
&lt;bigarray_expr&gt;.{&lt;index_expr&gt;}
&lt;bigarray_expr&gt;.{&lt;index_expr&gt;} &lt;- &lt;value_expr&gt;
</programlisting>
      </sect3>
    </sect2>
    <sect2 id="mutable-record-and-object-fields-and-ref-cells">
      <title>Mutable record and object fields and ref cells</title>
      <para>
        As we've seen, records are immutable by default, but individual
        record fields can be declared as mutable. These mutable fields
        can be set using the <literal>&lt;-</literal> operator,
        <emphasis>i.e.</emphasis>,
        <literal>record.field &lt;- expr</literal>.
      </para>
      <para>
        As we'll see in <xref linkend="objects"/>, fields of
        an object can similarly be declared as mutable, and can then be
        modified in much the same way as record fields.
      </para>
      <sect3 id="ref-cells">
        <title>Ref cells</title>
        <para>
          Variables in OCaml are never mutable—they can refer to mutable
          data, but what the variable points to can't be changed.
          Sometimes, though, you want to do exactly what you would do
          with a mutable variable in another language: define a single,
          mutable value. In OCaml this is typically achieved using a
          <literal>ref</literal>, which is essentially a container with
          a single mutable polymorphic field.
        </para>
        <para>
          The definition for the ref type is as follows:
        </para>
        <programlisting language="ocaml">
...part 1 of imperative-programming/ref.topscript
# type 'a ref = { mutable contents : 'a };; 
type 'a ref = { mutable contents : 'a; }
</programlisting>
        <para>
          The standard library defines the following operators for
          working with refs.
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <literal>ref expr</literal> constructs a reference cell
              containing the value defined by the expression
              <literal>expr</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>!refcell</literal> returns the contents of the
              reference cell.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>refcell := expr</literal> replaces the contents
              of the reference cell.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          You can see these in action below.
        </para>
        <programlisting language="ocaml">
...part 3 of imperative-programming/ref.topscript
# let x = ref 1;; 
val x : int ref = {contents = 1}
# !x;; 
- : int = 1
# x := !x + 1;; 
- : unit = ()
# !x;; 
- : int = 2
</programlisting>
        <para>
          The above are just ordinary OCaml functions which could be
          defined as follows.
        </para>
        <programlisting language="ocaml">
...part 2 of imperative-programming/ref.topscript
# let ref x = { contents = x };; 
val ref : 'a -&gt; 'a ref = &lt;fun&gt;
# let (!) r = r.contents;; 
val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;
# let (:=) r x = r.contents &lt;- x;; 
val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;
</programlisting>
      </sect3>
    </sect2>
    <sect2 id="foreign-functions">
      <title>Foreign functions</title>
      <para>
        Another source of imperative operations in OCaml is resources
        that come from interfacing with external libraries through
        OCaml's foreign function interface (FFI). The FFI opens OCaml up
        to imperative constructs that are exported by system calls or
        other external libraries. Many of these come built in, like
        access to the <literal>write</literal> system call, or to the
        <literal>clock</literal>; while others come from user libraries,
        like LAPACK bindings.
      </para>
    </sect2>
  </sect1>
  <sect1 id="for-and-while-loops-1">
    <title><literal>for</literal> and <literal>while</literal>
    loops</title>
    <para>
      OCaml provides support for traditional imperative looping
      constructs, in particular, <literal>for</literal> and
      <literal>while</literal> loops, even though neither of them is
      strictly necessary. Anything you can do with such a loop you can
      also do with a recursive function, and you can also write
      higher-order functions like <literal>Array.iter</literal> that
      cover much of the same ground.
    </para>
    <para>
      Nonetheless, explicit <literal>for</literal> and
      <literal>while</literal> loops are both more idiomatic for
      imperative programming and often more concise.
    </para>
    <para>
      The <literal>for</literal> loop is the simpler of the two. Indeed,
      we've already seen the <literal>for</literal> loop in action—the
      <literal>iter</literal> function in <literal>Dictionary</literal>
      is built using it. Here's a simple example of
      <literal>for</literal>.
    </para>
    <programlisting language="ocaml">
...part 1 of imperative-programming/for.topscript
# for i = 0 to 3 do printf &quot;i = %d\n&quot; i done;; 

i = 0
i = 1
i = 2
i = 3
- : unit = ()
</programlisting>
    <para>
      As you can see, the upper and lower bounds are inclusive. We can
      also use <literal>downto</literal> to iterate in the other
      direction.
    </para>
    <programlisting language="ocaml">
...part 2 of imperative-programming/for.topscript
# for i = 3 downto 0 do printf &quot;i = %d\n&quot; i done;; 

i = 3
i = 2
i = 1
i = 0
- : unit = ()
</programlisting>
    <para>
      Note that the loop variable of a <literal>for</literal> loop,
      <literal>i</literal> in this case, is immutable in the scope of
      the loop, and is also local to the loop, <literal>i.e.</literal>,
      it can't be referenced outside of the loop.
    </para>
    <para>
      OCaml also supports <literal>while</literal> loops, which include
      a condition and a body. The loop first evaluates the condition,
      and then, if it evaluates to true, evaluates the body and starts
      the loop again. Here's a simple example of a function for
      reversing an array in-place.
    </para>
    <programlisting language="ocaml">
...part 3 of imperative-programming/for.topscript
# let rev_inplace ar =
  let i = ref 0 in
  let j = ref (Array.length ar - 1) in
  (* terminate when the upper and lower indices meet *)
  while !i &lt; !j do
    (* swap the two elements *)
    let tmp = ar.(!i) in
    ar.(!i) &lt;- ar.(!j);
    ar.(!j) &lt;- tmp;
    (* bump the indices *)
    incr i;
    decr j
  done
;; 
val rev_inplace : 'a array -&gt; unit = &lt;fun&gt;
# let nums = [|1;2;3;4;5|];; 
val nums : int array = [|1; 2; 3; 4; 5|]
# rev_inplace nums;; 
- : unit = ()
# nums;; 
- : int array = [|5; 4; 3; 2; 1|]
</programlisting>
    <para>
      In the above, we used <literal>incr</literal> and
      <literal>decr</literal>, which are built-in functions for
      incrementing and decrementing an <literal>int ref</literal> by
      one, respectively.
    </para>
  </sect1>
  <sect1 id="example-doubly-linked-lists">
    <title>Example: Doubly-linked lists</title>
    <para>
      Another common imperative data structure is the doubly-linked
      list. Doubly-linked lists can be traversed in both directions and
      elements can be added and removed from the list in constant time.
      Core defines a doubly-linked list (the module is called
      <literal>Doubly_linked</literal>), but we'll define our own linked
      list library as an illustration.
    </para>
    <para>
      Here's the <literal>mli</literal> of the module we'll build.
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dlist.mli  *)
(* file: dlist.mli *)
open Core.Std

type 'a t
type 'a element

(** Basic list operations  *)
val create   : unit -&gt; 'a t
val is_empty : 'a t -&gt; bool

(** Navigation using [element]s *)
val first : 'a t -&gt; 'a element option
val next  : 'a element -&gt; 'a element option
val prev  : 'a element -&gt; 'a element option
val value : 'a element -&gt; 'a

(** Whole-data-structure iteration *)
val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
val find_el : 'a t -&gt; f:('a -&gt; bool) -&gt; 'a element option

(** Mutation *)
val insert_first : 'a t -&gt; 'a -&gt; 'a element
val insert_after : 'a element -&gt; 'a -&gt; 'a element
val remove : 'a t -&gt; 'a element -&gt; unit
</programlisting>
    <para>
      Note that there are two types defined here:
      <literal>'a t</literal>, the type of a list, and
      <literal>'a element</literal>, the type of an element. Elements
      act as pointers to the interior of a list, and allow us to
      navigate the list and give us a point at which to apply mutating
      operations.
    </para>
    <para>
      Now let's look at the implementation. We'll start by defining
      <literal>'a element</literal> and <literal>'a t</literal>.
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dlist.ml (starting from part 1) *)
(* file: dlist.ml *)
open Core.Std

type 'a element =
  { value : 'a;
    mutable next : 'a element option;
    mutable prev : 'a element option
  }

type 'a t = 'a element option ref
</programlisting>
    <para>
      An <literal>'a element</literal> is a record containing the value
      to be stored in that node as well as optional (and mutable) fields
      pointing to the previous and next elements. At the beginning of
      the list, the <literal>prev</literal> field is
      <literal>None</literal>, and at the end of the list, the
      <literal>next</literal> field is <literal>None</literal>.
    </para>
    <para>
      The type of the list itself, <literal>'a t</literal>, is a mutable
      reference to an optional <literal>element</literal>. This
      reference is <literal>None</literal> if the list is empty, and
      <literal>Some</literal> otherwise.
    </para>
    <para>
      Now we can define a few basic functions that operate on lists and
      elements.
    </para>
    <programlisting language="ocaml">
(* imperative-programming/dlist.ml (starting from part 2) *)
let create () = ref None
let is_empty t = !t = None

let value elt = elt.value

let first t = !t
let next elt = elt.next
let prev elt = elt.prev
</programlisting>
    <para>
      These all follow relatively straight-forwardly from our type
      definitions.
    </para>
    <note><title> 
    Cyclic data structures
    </title>
    <para>
      Doubly-linked lists are a cyclic data structure, meaning that it
      is possible to follow a nontrivial sequence of pointers that
      closes in on itself. In general, building cyclic data structures
      requires the use of side-effects. This is done by constructing the
      data elements first, and then adding cycles using assignment
      afterwards.
    </para>
    <para>
      There is an exception to this, though: you can construct
      fixed-size cyclic data-structures using
      <literal>let rec</literal>.
    </para>
    <programlisting language="ocaml">
...part 2 of imperative-programming/examples.topscript
# let rec endless_loop = 1 :: 2 :: 3 :: endless_loop;; 
val endless_loop : int list =
  [1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   ...]
</programlisting>
    <para>
      This approach is quite limited, however. General purpose cyclic
      data structures require mutation.
    </para>
    </note>
    <sect2 id="modifying-the-list">
      <title>Modifying the list</title>
      <para>
        Now, we'll start considering operations that mutate the list,
        starting with <literal>insert_first</literal>, which inserts an
        element at the front of the list.
      </para>
      <programlisting language="ocaml">
(* imperative-programming/dlist.ml (starting from part 3) *)
let insert_first t value =
  let new_elt = { prev = None; next = !t; value } in
  begin match !t with
  | Some old_first -&gt; old_first.prev &lt;- Some new_elt
  | None -&gt; ()
  end;
  t := Some new_elt;
  new_elt
</programlisting>
      <para>
        <literal>insert_first</literal> first defines a new element
        <literal>new_elt</literal>, and then links it into the list,
        finally setting the list itself to point to
        <literal>new_elt</literal>. Note that the precedence of a
        <literal>match</literal> expression is very low, so to separate
        it from the following assignment
        (<literal>t := Some new_elt</literal>) we surround the match
        with <literal>begin ... end</literal>. We could have used
        parenthesis for the same purpose. Without some kind of
        bracketing, the final assignment would incorrectly become part
        of the <literal>None -&gt; ...</literal> case.
      </para>
      <para>
        We can use <literal>insert_after</literal> to insert elements
        later in the list. <literal>insert_after</literal> takes as
        arguments both an <literal>element</literal> after which to
        insert the new node, and a value to insert.
      </para>
      <programlisting language="ocaml">
(* imperative-programming/dlist.ml (starting from part 4) *)
let insert_after elt value =
  let new_elt = { value; prev = Some elt; next = elt.next } in
  begin match elt.next with
  | Some old_next -&gt; old_next.prev &lt;- Some new_elt
  | None -&gt; ()
  end;
  elt.next &lt;- Some new_elt;
  new_elt
</programlisting>
      <para>
        Finally, we need a <literal>remove</literal> function.
      </para>
      <programlisting language="ocaml">
(* imperative-programming/dlist.ml (starting from part 5) *)
let remove t elt =
  let { prev; next; _ } = elt in
  begin match prev with
  | Some prev -&gt; prev.next &lt;- next
  | None -&gt; t := next
  end;
  begin match next with
  | Some next -&gt; next.prev &lt;- prev;
  | None -&gt; ()
  end;
  elt.prev &lt;- None;
  elt.next &lt;- None
</programlisting>
      <para>
        Note that the above code is careful to change the
        <literal>prev</literal> pointer of the following element, and
        the <literal>next</literal> pointer of the previous element, if
        they exist. If there's no previous element, then the list
        pointer itself is updated. In any case, the next and previous
        pointers of the element itself are set to
        <literal>None</literal>.
      </para>
      <para>
        These functions are more fragile than they may seem. In
        particular, misuse of the interface may lead to corrupted data.
        For example, double-removing an element will cause the main list
        reference to be set to <literal>None</literal>, thus emptying
        the list. Similar problems arise from removing an element from a
        list it doesn't belong to.
      </para>
      <para>
        This shouldn't be a big surprise. Complex imperative data
        structures can be quite tricky; considerably trickier than their
        pure equivalents. The issues described above can be dealt with
        by more careful error detection, and such error correction is
        taken care of in modules like Core's
        <literal>Doubly_linked</literal>. You should use imperative data
        structures from a well-designed library when you can. And when
        you can't, you should make sure that the code you write is
        careful about error detection.
      </para>
    </sect2>
    <sect2 id="iteration-functions">
      <title>Iteration functions</title>
      <para>
        When defining containers like lists, dictionaries and trees,
        you'll typically want to define a set of iteration functions,
        like <literal>iter</literal>, <literal>map</literal>, and
        <literal>fold</literal>, which let you concisely express common
        iteration patterns.
      </para>
      <para>
        <literal>Dlist</literal> has two such iterators:
        <literal>iter</literal>, the goal of which is to call a
        <literal>unit</literal> producing function on every element of
        the list, in order; and <literal>find_el</literal>, which runs a
        provided test function on each values stored in the list,
        returning the first <literal>element</literal> that passes the
        test. Both <literal>iter</literal> and
        <literal>find_el</literal> are implemented using simple
        recursive loops that use <literal>next</literal> to walk from
        element to element, and <literal>value</literal> to extract the
        element from a given node.
      </para>
      <programlisting language="ocaml">
(* imperative-programming/dlist.ml (starting from part 6) *)
let iter t ~f =
  let rec loop = function
    | None -&gt; ()
    | Some el -&gt; f (value el); loop (next el)
  in
  loop !t

let find_el t ~f =
  let rec loop = function
    | None -&gt; None
    | Some elt -&gt;
      if f (value elt) then Some elt
      else loop (next elt)
  in
  loop !t
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="laziness-and-other-benign-effects">
    <title>Laziness and other benign effects</title>
    <para>
      There are many instances where you basically want to program in a
      pure style, but you want to make limited use of side-effects to
      improve the performance of your code, without really changing
      anything else. Such side effects are sometimes called
      <emphasis>benign effects</emphasis>, and they are a useful way of
      leveraging OCaml's imperative features while still maintaining
      most of the benefits of pure programming.
    </para>
    <para>
      One of the simplest benign effect is
      <emphasis>laziness</emphasis>. A lazy value is one that is not
      computed until it is actually needed. In OCaml, lazy values are
      created using the <literal>lazy</literal> keyword, which can be
      used to prefix any expression, returning a value of type
      <literal>'a Lazy.t</literal>. The evaluation of that expression is
      delayed until forced with the <literal>Lazy.force</literal>
      function.
    </para>
    <programlisting language="ocaml">
...part 1 of imperative-programming/lazy.topscript
# let v = lazy (print_string &quot;performing lazy computation\n&quot;; sqrt 16.);; 
val v : float lazy_t = &lt;lazy&gt;
# Lazy.force v;; 

performing lazy computation
- : float = 4.
# Lazy.force v;; 
- : float = 4.
</programlisting>
    <para>
      You can see from the print statement that the actual computation
      was performed only once, and only after <literal>force</literal>
      had been called.
    </para>
    <para>
      To better understand how laziness works, let's walk through the
      implementation of our own lazy type. We'll start by declaring
      types to represent a lazy value.
    </para>
    <programlisting language="ocaml">
...part 2 of imperative-programming/lazy.topscript
# type 'a lazy_state =
  | Delayed of (unit -&gt; 'a)
  | Value of 'a
  | Exn of exn
;; 
type 'a lazy_state = Delayed of (unit -&gt; 'a) | Value of 'a | Exn of exn
</programlisting>
    <para>
      A <literal>lazy_state</literal> represents the possible states of
      a lazy value. A lazy value is <literal>Delayed</literal> before it
      has been run, where <literal>Delayed</literal> holds a function
      for computing the value in question. A lazy value is in the
      <literal>Value</literal> state when it has been forced and the
      computation ended normally. The <literal>Exn</literal> case is for
      when the lazy value has been forced, but the computation ended
      with an exception. A lazy value is simply a <literal>ref</literal>
      containing a <literal>lazy_state</literal>, where the
      <literal>ref</literal> makes it possible to change from being in
      the <literal>Delayed</literal> state to being in the
      <literal>Value</literal> or <literal>Exn</literal> states.
    </para>
    <para>
      We can create a lazy value based on a thunk,
      <emphasis>i.e.</emphasis>, a function that takes a unit argument.
      Wrapping an expression in a thunk is another way to suspend the
      computation of an expression.
    </para>
    <programlisting language="ocaml">
...part 3 of imperative-programming/lazy.topscript
# let create_lazy f = ref (Delayed f);; 
val create_lazy : (unit -&gt; 'a) -&gt; 'a lazy_state ref = &lt;fun&gt;
# let v = create_lazy
  (fun () -&gt; print_string &quot;performing lazy computation\n&quot;; sqrt 16.);; 
val v : float lazy_state ref = {contents = Delayed &lt;fun&gt;}
</programlisting>
    <para>
      Now we just need a way to force a lazy value. The following
      function does just that.
    </para>
    <programlisting language="ocaml">
...part 4 of imperative-programming/lazy.topscript
# let force v =
  match !v with
  | Value x -&gt; x
  | Exn e -&gt; raise e
  | Delayed f -&gt;
    try
      let x = f () in
      v := Value x;
      x
    with exn -&gt;
      v := Exn exn;
      raise exn
   ;; 
val force : 'a lazy_state ref -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      Which we can use in the same way we used
      <literal>Lazy.force</literal>:
    </para>
    <programlisting language="ocaml">
...part 5 of imperative-programming/lazy.topscript
# force v;; 

performing lazy computation
- : float = 4.
# force v;; 
- : float = 4.
</programlisting>
    <para>
      The main user-visible difference between our implementation of
      laziness and the built-in version is syntax. Rather than writing
      <literal>create_lazy (fun () -&gt; sqrt 16.)</literal>, we can
      with the built-in <literal>lazy</literal> just write
      <literal>lazy (sqrt 16.)</literal>.
    </para>
    <sect2 id="memoization-and-dynamic-programming">
      <title>Memoization and dynamic programming</title>
      <para>
        Another benign effect is <emphasis>memoization</emphasis>. A
        memoized function remembers the result of previous invocations
        of the function so that they can be returned without further
        computation when the same arguments are presented again.
      </para>
      <para>
        Here's a function that takes as an argument an arbitrary
        single-argument function and returns a memoized version of that
        function. Here we'll use Core's <literal>Hashtbl</literal>
        module, rather than our toy <literal>Dictionary</literal>.
      </para>
      <programlisting language="ocaml">
...part 1 of imperative-programming/memo.topscript
# let memoize f =
  let table = Hashtbl.Poly.create () in
  (fun x -&gt;
    match Hashtbl.find table x with
    | Some y -&gt; y
    | None -&gt;
      let y = f x in
      Hashtbl.add_exn table ~key:x ~data:y;
      y
  );; 
val memoize : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
</programlisting>
      <para>
        The code above is a bit tricky. <literal>memoize</literal> takes
        as its argument a function <literal>f</literal>, and then
        allocates a hash table (called <literal>table</literal>) and
        returns a new function as the memoized version of
        <literal>f</literal>. When called, this new function looks in
        <literal>table</literal> first, and if it fails to find a value,
        calls <literal>f</literal> and stashes the result in
        <literal>table</literal>. Note that <literal>table</literal>
        doesn't go out of scope as long as the function returned by
        <literal>memoize</literal> is in scope.
      </para>
      <para>
        Memoization can be useful whenever you have a function that is
        expensive to recompute, and you don't mind caching old values
        indefinitely. One important caution: every time you create a
        memoized function, there's something of a built-in memory leak.
        As long as you hold on to the memoized function, you're holding
        every result it has returned thus far.
      </para>
      <para>
        Memoization is also useful for efficiently implementing some
        recursive algorithms. One good example is the algorithm for
        computing the <emphasis>edit distance</emphasis> (also called
        the Levenshtein distance) between two strings. The edit distance
        is the number of single-character changes (including letter
        switches, insertions and deletions) required to convert one
        string to the other. This kind of distance metric can be useful
        for a variety of approximate string matching problems, like
        spell checkers.
      </para>
      <para>
        Consider the following code for computing the edit distance.
        Understanding the algorithm isn't important here, but you should
        pay attention to the structure of the recursive calls.
      </para>
      <programlisting language="ocaml">
...part 2 of imperative-programming/memo.topscript
# let rec edit_distance s t =
  match String.length s, String.length t with
  | (0,x) | (x,0) -&gt; x
  | (len_s,len_t) -&gt;
    let s' = String.drop_suffix s 1 in
    let t' = String.drop_suffix t 1 in
    let cost_to_drop_both =
      if s.[len_s - 1] = t.[len_t - 1] then 0 else 1
    in
    List.reduce_exn ~f:Int.min
      [ edit_distance s' t  + 1
      ; edit_distance s  t' + 1
      ; edit_distance s' t' + cost_to_drop_both
      ]
;; 
val edit_distance : string -&gt; string -&gt; int = &lt;fun&gt;
# edit_distance &quot;OCaml&quot; &quot;ocaml&quot;;; 
- : int = 2
</programlisting>
      <para>
        The thing to note is that if you call
        <literal>edit_distance &quot;OCaml&quot; &quot;ocaml&quot;</literal>,
        then that will in turn dispatch the following calls:
      </para>
      <programlisting>
edit_distance &quot;OCam&quot; &quot;ocaml&quot;
edit_distance &quot;OCaml&quot; &quot;ocam&quot;
edit_distance &quot;OCam&quot; &quot;ocam&quot;
</programlisting>
      <para>
        And these calls will in turn dispatch other calls:
      </para>
      <programlisting>
edit_distance &quot;OCam&quot; &quot;ocaml&quot;
   edit_distance &quot;OCa&quot; &quot;ocaml&quot;
   edit_distance &quot;OCam&quot; &quot;ocam&quot;
   edit_distance &quot;OCa&quot; &quot;ocam&quot;
edit_distance &quot;OCaml&quot; &quot;ocam&quot;
   edit_distance &quot;OCam&quot; &quot;ocam&quot;
   edit_distance &quot;OCaml&quot; &quot;oca&quot;
   edit_distance &quot;OCam&quot; &quot;oca&quot;
edit_distance &quot;OCam&quot; &quot;ocam&quot;
   edit_distance &quot;OCa&quot; &quot;ocam&quot;
   edit_distance &quot;OCam&quot; &quot;oca&quot;
   edit_distance &quot;OCa&quot; &quot;oca&quot;
</programlisting>
      <para>
        As you can see, some of these calls are repeats. For example,
        there are two different calls to
        <literal>edit_distance &quot;OCam&quot; &quot;oca&quot;</literal>.
        The number of redundant calls grows exponentially with the size
        of the strings, meaning that our implementation of
        <literal>edit_distance</literal> is brutally slow for large
        strings. We can see this by writing a small timing function.
      </para>
      <programlisting language="ocaml">
...part 3 of imperative-programming/memo.topscript
# let time f =
  let start = Time.now () in
  let x = f () in
  let stop = Time.now () in
  printf &quot;Time: %s\n&quot; (Time.Span.to_string (Time.diff stop start));
  x ;; 
val time : (unit -&gt; 'a) -&gt; 'a = &lt;fun&gt;
</programlisting>
      <para>
        And now we can use this to try out some examples.
      </para>
      <programlisting language="ocaml">
...part 4 of imperative-programming/memo.topscript
# time (fun () -&gt; edit_distance &quot;OCaml&quot; &quot;ocaml&quot;);; 

Time: 1.4112ms
- : int = 2
# time (fun () -&gt; edit_distance &quot;OCaml 4.01&quot; &quot;ocaml 4.01&quot;);; 

Time: 6.78466s
- : int = 2
</programlisting>
      <para>
        Just those few extra characters made it almost four thousand
        times slower!
      </para>
      <para>
        Memoization would be a huge help here, but to fix the problem,
        we need to memoize the calls that
        <literal>edit_distance</literal> makes to itself. This technique
        is sometimes referred to as <emphasis>dynamic
        programming</emphasis>. To see how to do this, let's step away
        from <literal>edit_distance</literal>, and instead consider a
        much simpler example: computing the nth element of the Fibonacci
        sequence. The Fibonacci sequence by definition starts out with
        two <literal>1</literal>'s, with every subsequent element being
        the sum of the previous two. The classic recursive definition of
        Fibonacci is as follows:
      </para>
      <programlisting language="ocaml">
...part 1 of imperative-programming/fib.topscript
# let rec fib i =
  if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2);; 
val fib : int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This is, however, exponentially slow, for the same reason that
        <literal>edit_distance</literal> was slow: we end up making many
        redundant calls to <literal>fib</literal>. It shows up quite
        dramatically in the performance.
      </para>
      <programlisting language="ocaml">
...part 2 of imperative-programming/fib.topscript
# time (fun () -&gt; fib 20);; 

Time: 0.858068ms
- : int = 10946
# time (fun () -&gt; fib 40);; 

Time: 12.7729s
- : int = 165580141
</programlisting>
      <para>
        Here, <literal>fib 40</literal> takes almost a minute to
        compute, as opposed to five <emphasis>milliseconds</emphasis>
        for <literal>fib 20</literal>.
      </para>
      <para>
        So, how can we use memoization to make this faster? The tricky
        bit is that we need to insert the memoization before the
        recursive calls within <literal>fib</literal>. We can't just
        define <literal>fib</literal> in the ordinary way and memoize it
        after the fact and expect the first call to
        <literal>fib</literal> to be improved (though of course repeated
        calls will be improved).
      </para>
      <programlisting language="ocaml">
...part 3 of imperative-programming/fib.topscript
# let fib = memoize fib;; 
val fib : int -&gt; int = &lt;fun&gt;
# time (fun () -&gt; fib 40);; 

Time: 12.7729s
- : int = 165580141
# time (fun () -&gt; fib 40);; 

Time: 0.00286102ms
- : int = 165580141
</programlisting>
      <para>
        In order to make <literal>fib</literal> fast, our first step
        will be to rewrite <literal>fib</literal> in a way that unwinds
        the recursion. The following version expects as its first
        argument a function (called <literal>fib</literal>) that will be
        called in lieu of the usual recursive call.
      </para>
      <programlisting language="ocaml">
...part 4 of imperative-programming/fib.topscript
# let fib_norec fib i =
  if i &lt;= 1 then i
  else fib (i - 1) + fib (i - 2) ;; 
val fib_norec : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        We can now turn this back into an ordinary Fibonacci function by
        tying the recursive knot, as shown below.
      </para>
      <programlisting language="ocaml">
...part 5 of imperative-programming/fib.topscript
# let rec fib i = fib_norec fib i;; 
val fib : int -&gt; int = &lt;fun&gt;
# fib 5;; 
- : int = 5
</programlisting>
      <para>
        We can even write a polymorphic function that we'll call
        <literal>make_rec</literal> that can tie the recursive knot for
        any function of this form.
      </para>
      <programlisting language="ocaml">
...part 6 of imperative-programming/fib.topscript
# let make_rec f_norec =
  let rec f x = f_norec f x in
  f
;; 
val make_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
# let fib = make_rec fib_norec;; 
val fib : int -&gt; int = &lt;fun&gt;
# fib 5;; 
- : int = 5
</programlisting>
      <para>
        This is a pretty strange piece of code, and it may take a few
        minutes of thought to figure out what's going on. Like
        <literal>fib_norec</literal>, the function
        <literal>f_norec</literal> passed into
        <literal>make_rec</literal> is a function that isn't recursive,
        but takes as an argument a function that it will call. What
        <literal>make_rec</literal> does is to essentially feed
        <literal>f_norec</literal> to itself, thus making it a true
        recursive function.
      </para>
      <para>
        This is clever enough, but all we've really done is find a new
        way to implement the same old slow Fibonacci function. To make
        it faster, we need variant on <literal>make_rec</literal> that
        inserts memoization when it ties the recursive knot. We'll call
        that function <literal>memo_rec</literal>.
      </para>
      <programlisting language="ocaml">
...part 7 of imperative-programming/fib.topscript
# let memo_rec f_norec x =
   let fref = ref (fun _ -&gt; assert false) in
   let f = memoize (fun x -&gt; f_norec !fref x) in
   fref := f;
   f x
;; 
val memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
</programlisting>
      <para>
        Note that <literal>memo_rec</literal> has the same signature as
        <literal>make_rec</literal>.
      </para>
      <para>
        We're using the reference here as a way of tying the recursive
        knot without using a <literal>let rec</literal>, which for
        reasons we'll describe later wouldn't work here.
      </para>
      <para>
        Using <literal>memo_rec</literal>, we can now build an efficient
        version of <literal>fib</literal>.
      </para>
      <programlisting language="ocaml">
...part 8 of imperative-programming/fib.topscript
# let fib = memo_rec fib_norec;; 
val fib : int -&gt; int = &lt;fun&gt;
# time (fun () -&gt; fib 40);; 

Time: 0.056982ms
- : int = 102334155
</programlisting>
      <para>
        And as you can see, the exponential time complexity is now gone.
      </para>
      <para>
        The memory behavior here is important. If you look back at the
        definition of <literal>memo_rec</literal>, you'll see that the
        call to memo_rec does not trigger a call to
        <literal>memoize</literal>. Only when the final argument to
        <literal>fib</literal> is presented does
        <literal>memoize</literal> get called, and the result of that
        call falls out of scope when the <literal>fib</literal> call
        returns. That means that, unlike ordinary memoization, calling
        <literal>memo_rec</literal> on a function does not create a
        memory leak—the memoization table is collected after the
        computation completes.
      </para>
      <para>
        We can use <literal>memo_rec</literal> as part of a single
        declaration that makes this look like it's little more than a
        special form of <literal>let rec</literal>.
      </para>
      <programlisting language="ocaml">
...part 9 of imperative-programming/fib.topscript
# let fib = memo_rec (fun fib i -&gt;
  if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2));; 
val fib : int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        Memoization is overkill for implementing Fibonacci, and indeed,
        the <literal>fib</literal> defined above is not especially
        efficient, allocating space linear in the number passed in to
        <literal>fib</literal>. It's easy enough to write a Fibonacci
        function that takes a constant amount of space.
      </para>
      <para>
        But memoization is a good approach for optimizing
        <literal>edit_distance</literal>, and we can apply the same
        approach we used on <literal>fib</literal> here. We will need to
        change <literal>edit_distance</literal> to take a pair of
        strings as a single argument, since <literal>memo_rec</literal>
        only works on single-argument functions. (We can always recover
        the original interface with a wrapper function.) With just that
        change and the addition of the <literal>memo_rec</literal> call,
        we can get a memoized version of
        <literal>edit_distance</literal>:
      </para>
      <programlisting language="ocaml">
...part 6 of imperative-programming/memo.topscript
# let edit_distance = memo_rec (fun edit_distance (s,t) -&gt;
  match String.length s, String.length t with
  | (0,x) | (x,0) -&gt; x
  | (len_s,len_t) -&gt;
    let s' = String.drop_suffix s 1 in
    let t' = String.drop_suffix t 1 in
    let cost_to_drop_both =
      if s.[len_s - 1] = t.[len_t - 1] then 0 else 1
    in
    List.reduce_exn ~f:Int.min
      [ edit_distance (s',t ) + 1
      ; edit_distance (s ,t') + 1
      ; edit_distance (s',t') + cost_to_drop_both
      ]) ;; 
val edit_distance : string * string -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This new version of <literal>edit_distance</literal> is much
        more efficient than the one we started with; the following call
        is about ten thousand times faster than it was without
        memoization.
      </para>
      <programlisting language="ocaml">
...part 7 of imperative-programming/memo.topscript
# time (fun () -&gt; edit_distance (&quot;OCaml 4.01&quot;,&quot;ocaml 4.01&quot;));; 

Time: 0.49901ms
- : int = 2
</programlisting>
      <note> <title> 
      Limitations of <literal>let rec</literal>
      </title>
      <para>
        You might wonder why we didn't tie the recursive knot in
        <literal>memo_rec</literal> using <literal>let rec</literal>, as
        we did for <literal>make_rec</literal> earlier. Here's code that
        tries to do just that:
      </para>
      <programlisting language="ocaml">
...part 1 of imperative-programming/letrec.topscript
# let memo_rec f_norec =
     let rec f = memoize (fun x -&gt; f_norec f x) in
     f
  ;; 
Characters 40-70:
Error: This kind of expression is not allowed as right-hand side of `let rec'
</programlisting>
      <para>
        OCaml rejects the definition because OCaml, as a strict
        language, has limits on what it can put on the right hand side
        of a <literal>let rec</literal>. In particular, imagine how the
        following code snippet would be compiled.
      </para>
      <programlisting language="ocaml">
(* imperative-programming/let_rec.ml  *)
let rec x = x + 1
</programlisting>
      <para>
        Note that <literal>x</literal> is an ordinary value, not a
        function. As such, it's not clear how to execute this code. In
        some sense, you could imagine it compiling down to an infinite
        loop, but there's no looping control structure to make that
        happen.
      </para>
      <para>
        To avoid such cases, the compiler only allows three possible
        constructs to show up on the right-hand side of a
        <literal>let rec</literal>: a function definition, a
        constructor, or the lazy keyword. This excludes some reasonable
        things, like our definition of <literal>memo_rec</literal>, but
        it also blocks things that don't make sense, like our definition
        of <literal>x</literal>.
      </para>
      <para>
        It's worth noting that these restrictions don't show up in a
        lazy language like Haskell. Indeed, we can make something like
        our definition of <literal>x</literal> work if we use OCaml's
        laziness:
      </para>
      <programlisting language="ocaml">
...part 2 of imperative-programming/letrec.topscript
# let rec x = lazy (Lazy.force x + 1);; 
val x : int lazy_t = &lt;lazy&gt;
</programlisting>
      <para>
        Of course, actually trying to compute this will fail. OCaml's
        <literal>lazy</literal> throws an exception when a lazy value
        tries to force itself as part of its own evaluation.
      </para>
      <programlisting language="ocaml">
...part 3 of imperative-programming/letrec.topscript
# Lazy.force x;; 
Exception: Lazy.Undefined.
</programlisting>
      <para>
        But we can also create useful recursive definitions with
        <literal>lazy</literal>. In particular, we can use laziness to
        make our definition of <literal>memo_rec</literal> work without
        explicit mutation.
      </para>
      <programlisting language="ocaml">
...part 5 of imperative-programming/letrec.topscript
# let lazy_memo_rec f_norec x =
   let rec f = lazy (memoize (fun x -&gt; f_norec (Lazy.force f) x)) in
   (Lazy.force f) x
;; 
val lazy_memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
# time (fun () -&gt; lazy_memo_rec fib_norec 40);; 

Time: 0.0631809ms
- : int = 102334155
</programlisting>
      <para>
        Laziness is more constrained than explicit mutation, and so in
        some cases can lead to code whose behavior is easier to think
        about.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="input-and-output">
    <title>Input and output</title>
    <para>
      Imperative programming is about more than modifying in-memory
      data-structures. Any function that doesn't boil down to a
      deterministic transformation from its arguments to its return
      value is imperative in nature. That includes not only things that
      mutate your program's data, but also operations that interact with
      the world outside of your program. An important example of this
      kind of interaction is I/O, <emphasis>i.e.</emphasis>, operations
      for reading or writing data to things like files, terminal input
      and output, and network sockets.
    </para>
    <para>
      There are multiple I/O libraries in OCaml. In this section we'll
      discuss OCaml's buffered I/O library that can be used through the
      <literal>In_channel</literal> and <literal>Out_channel</literal>
      modules in Core. Other I/O primitives are also available through
      the <literal>Unix</literal> module in Core as well as
      <literal>Async</literal>, the asynchronous I/O library that is
      covered in
      <xref linkend="concurrent-programming-with-async"/>.
      Most of the functionality in Core's <literal>In_channel</literal>,
      <literal>Out_channel</literal> (and in Core's
      <literal>Unix</literal> module) derives from the standard library,
      but we'll use Core's interfaces here.
    </para>
    <sect2 id="terminal-io">
      <title>Terminal I/O</title>
      <para>
        OCaml's buffered I/O library is organized around two types:
        <literal>in_channel</literal>, for channels you read from, and
        <literal>out_channel</literal>, for channels you write to.
        <literal>In_channel</literal> and <literal>Out_channel</literal>
        modules only have direct support for channels corresponding to
        files and terminals; other kinds of channels can be created
        through the <literal>Unix</literal> module.
      </para>
      <para>
        We'll start our discussion of I/O by focusing on the terminal.
        Following the UNIX model, communication with the terminal is
        organized around three channels, which correspond to the three
        standard file descriptors in Unix:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>In_channel.stdin</literal>. The &quot;standard
            input&quot; channel. By default, input comes from the
            terminal, which handles keyboard input.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>Out_channel.stdout</literal>. The &quot;standard
            output&quot; channel. By default, output written to
            <literal>stdout</literal> appears on the user terminal.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>Out_channel.stderr</literal>. The &quot;standard
            error&quot; channel. This is similar to
            <literal>stdout</literal>, but is intended for error
            messages.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The values <literal>stdin</literal>, <literal>stdout</literal>
        and <literal>stderr</literal> are useful enough that they are
        also available in the global name-space directly, without having
        to go through the <literal>In_channel</literal> and
        <literal>Out_channel</literal> modules.
      </para>
      <para>
        Let's see this in action in a simple interactive application.
        The following program, <literal>time_converter</literal>,
        prompts the user for a timezone, and then prints out the current
        time in that timezone. Here, we use Core's
        <literal>Zone</literal> module for looking up a timezone, and
        the <literal>Time</literal> module for computing the current
        time and printing it out in the timezone in question.
      </para>
      <programlisting language="ocaml">
(* imperative-programming/time_converter.ml  *)
(* file: time_converter.ml *)
open Core.Std

let () =
  Out_channel.output_string stdout &quot;Pick a timezone: &quot;;
  Out_channel.flush stdout;
  match In_channel.input_line stdin with
  | None -&gt; failwith &quot;No timezone provided&quot;
  | Some zone_string -&gt;
    let zone = Zone.find_exn zone_string in
    let time_string = Time.to_localized_string (Time.now ()) zone in
    Out_channel.output_string stdout
      (String.concat
         [&quot;The time in &quot;;Zone.to_string zone;&quot; is &quot;; time_string;&quot;\n&quot;]);
    Out_channel.flush stdout
</programlisting>
      <para>
        We can build this program (using <literal>ocamlbuild</literal>
        with the <literal>_tags</literal> file described in
        <xref linkend="single-file-programs"/>) and run it,
        you'll see that it prompts you for input, as follows:
      </para>
      <programlisting>
# running imperative-programming/time_converter.out.sh
$ ./time_converter.byte
Pick a timezone:
</programlisting>
      <para>
        You can then type in the name of a timezone and hit return, and
        it will print out the current time in the timezone in question.
      </para>
      <programlisting>
# running imperative-programming/time_converter2.out.sh
Pick a timezone: Europe/London
The time in Europe/London is 2013-03-06 02:15:13.602033
</programlisting>
      <para>
        We called <literal>Out_channel.flush</literal> on
        <literal>stdout</literal> because
        <literal>out_channel</literal>s are buffered, which is to say
        that OCaml doesn't immediately do a write every time you call
        <literal>output_string</literal>. Instead, writes are buffered
        until either enough has been written to trigger the flushing of
        the buffers, or until a flush is explicitly requested. This
        greatly increases the efficiency of the writing process, by
        reducing the number of system calls.
      </para>
      <para>
        Note that <literal>In_channel.input_line</literal> returns a
        <literal>string option</literal>, with <literal>None</literal>
        indicating that the input stream has ended
        (<emphasis>i.e.</emphasis>, an end-of-file condition).
        <literal>Out_channel.output_string</literal> is used to print
        the final output, and <literal>Out_channel.flush</literal> is
        called to flush that output to the screen. The final flush is
        not technically required, since the program ends after that
        instruction, at which point all remaining output will be flushed
        anyway, but the flush is nonetheless good practice.
      </para>
    </sect2>
    <sect2 id="formatted-output-with-printf">
      <title>Formatted output with <literal>printf</literal></title>
      <para>
        Generating output with functions like
        <literal>Out_channel.output_string</literal> is simple and easy
        to understand, but can be a bit verbose. OCaml also supports
        formatted output using the <literal>printf</literal> function,
        which is modeled after <literal>printf</literal> in the C
        standard library. <literal>printf</literal> takes a
        <emphasis>format string</emphasis> that describe what to print
        and how to format it, as well as arguments to be printed, as
        determined by the formatting directives embedded in the format
        string. So, for example, we can write:
      </para>
      <programlisting language="ocaml">
...part 1 of imperative-programming/printf.topscript
# printf &quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;
    3 4.5 &quot;five&quot;;; 

3 is an integer, 4.5 is a float, &quot;five&quot; is a string
- : unit = ()
</programlisting>
      <para>
        Importantly, and unlike C's <literal>printf</literal>, the
        <literal>printf</literal> in OCaml is type-safe. In particular,
        if we provide an argument whose type doesn't match what's
        presented in the format string, we'll get a type error.
      </para>
      <programlisting language="ocaml">
...part 2 of imperative-programming/printf.topscript
# printf &quot;An integer: %i\n&quot; 4.5;; 
Characters 26-29:
Error: This expression has type float but an expression was expected of type
         int
</programlisting>
      <note> <title> 
      Understanding format strings
      </title>
      <para>
        The format strings used by <literal>printf</literal> turn out to
        be quite different from ordinary strings. This difference ties
        to the fact that OCaml format strings, unlike their equivalent
        in C, are type-safe. In particular, the compiler checks that the
        types referred to by the format string match the types of the
        rest of the arguments passed to <literal>printf</literal>.
      </para>
      <para>
        To check this, OCaml needs to analyze the contents of the format
        string at compile time, which means the format string needs to
        be available as a string literal at compile time. Indeed, if you
        try to pass an ordinary string to <literal>printf</literal>, the
        compiler will complain.
      </para>
      <programlisting language="ocaml">
...part 3 of imperative-programming/printf.topscript
# let fmt = &quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;;; 
val fmt : string = &quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;
# printf fmt 3 4.5 &quot;five&quot;;; 
Characters 7-10:
Error: This expression has type string but an expression was expected of type
         ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit) format =
           ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit, unit, unit, unit)
           format6
</programlisting>
      <para>
        If OCaml infers that a given string literal is a format string,
        then it parses it at compile time as such, choosing its type in
        accordance with the formatting directives it finds. Thus, if we
        add a type-annotation indicating that the string we're defining
        is actually a format string, it will be interpreted as such:
      </para>
      <programlisting language="ocaml">
...part 4 of imperative-programming/printf.topscript
# let fmt : ('a, 'b, 'c) format =
  &quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;;; 
val fmt : (int -&gt; float -&gt; string -&gt; 'c, 'b, 'c) format = &lt;abstr&gt;
</programlisting>
      <para>
        And accordingly, we can pass it to <literal>printf</literal>.
      </para>
      <programlisting language="ocaml">
...part 4 of imperative-programming/printf.topscript
# let fmt : ('a, 'b, 'c) format =
  &quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;;; 
val fmt : (int -&gt; float -&gt; string -&gt; 'c, 'b, 'c) format = &lt;abstr&gt;
</programlisting>
      <para>
        If this looks different from everything else you've seen so far,
        that's because it is. This is really a special case in the type
        system. Most of the time, you don't need to worry about this
        special handling of format strings—you can just use
        <literal>printf</literal> and not worry about the details. But
        it's useful to keep the broad outlines of the story in the back
        of your head.
      </para>
      </note>
      <para>
        Now let's see how we can rewrite our time conversion program to
        be a little more concise using <literal>printf</literal>.
      </para>
      <programlisting language="ocaml">
(* imperative-programming/time_converter2.ml  *)
(* file: time_converter.ml *)
open Core.Std

let () =
  printf &quot;Pick a timezone: %!&quot;;
  match In_channel.input_line stdin with
  | None -&gt; failwith &quot;No timezone provided&quot;
  | Some zone_string -&gt;
    let zone = Zone.find_exn zone_string in
    let time_string = Time.to_localized_string (Time.now ()) zone in
    printf &quot;The time in %s is %s.\n%!&quot; (Zone.to_string zone) time_string
</programlisting>
      <para>
        In the above example, we've used only two formatting directives:
        <literal>%s</literal>, for including a string, and
        <literal>%!</literal> which causes <literal>printf</literal> to
        flush the channel.
      </para>
      <para>
        <literal>printf</literal>'s formatting directives offer a
        significant amount of control, allowing you to specify things
        like:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            alignment and padding
          </para>
        </listitem>
        <listitem>
          <para>
            escaping rules for strings
          </para>
        </listitem>
        <listitem>
          <para>
            whether numbers should be formatted in decimal, hex or
            binary
          </para>
        </listitem>
        <listitem>
          <para>
            precision of float conversions
          </para>
        </listitem>
      </itemizedlist>
      <para>
        There are also <literal>printf</literal>-style functions that
        target outputs other than <literal>stdout</literal>, including:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>eprintf</literal>, which prints to
            <literal>stderr</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fprintf</literal>, which prints to an arbitrary
            <literal>out_channel</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>sprintf</literal>, which returns a formatted string
          </para>
        </listitem>
      </itemizedlist>
      <para>
        All of this, and a good deal more, is described in the API
        documentation for the <literal>Printf</literal> module in the
        OCaml Manual.
      </para>
    </sect2>
    <sect2 id="file-io">
      <title>File I/O</title>
      <para>
        Another common use of <literal>in_channel</literal>s and
        <literal>out_channel</literal>s is for working with files.
        Here's a couple of functions, one that creates a file full of
        numbers, and the other that reads in such a file and returns the
        sum of those numbers.
      </para>
      <programlisting language="ocaml">
...part 1 of imperative-programming/file.topscript
# let create_number_file filename numbers =
  let outc = Out_channel.create filename in
  List.iter numbers ~f:(fun x -&gt; fprintf outc &quot;%d\n&quot; x);
  Out_channel.close outc
;; 
val create_number_file : string -&gt; int list -&gt; unit = &lt;fun&gt;
# let sum_file filename =
   let file = In_channel.create filename in
   let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in
   let sum = List.fold ~init:0 ~f:(+) numbers in
   In_channel.close file;
   sum
;; 
val sum_file : string -&gt; int = &lt;fun&gt;
# create_number_file &quot;numbers.txt&quot; [1;2;3;4;5];; 
- : unit = ()
# sum_file &quot;numbers.txt&quot;;; 
- : int = 15
</programlisting>
      <para>
        For both of these functions we followed the same basic sequence:
        we first create the channel, then use the channel, and finally
        close the channel. The closing of the channel is important,
        since without it, we won't release resources associated with the
        file back to the operating system.
      </para>
      <para>
        One problem with the code above is that if it throws an
        exception in the middle of its work, it won't actually close the
        file. If we try to read a file that doesn't actually contain
        numbers, we'll see such an error:
      </para>
      <programlisting language="ocaml">
...part 2 of imperative-programming/file.topscript
# sum_file &quot;/etc/hosts&quot;;; 
Exception: (Failure &quot;Int.of_string: \&quot;127.0.0.1    localhost\&quot;&quot;).
</programlisting>
      <para>
        And if we do this over and over in a loop, we'll eventually run
        out of file descriptors.
      </para>
      <programlisting language="ocaml">
...part 3 of imperative-programming/file.topscript
# for i = 1 to 10000 do try ignore (sum_file &quot;/etc/hosts&quot;) with _ -&gt; () done;; 
- : unit = ()
# sum_file &quot;numbers.txt&quot;;; 
Exception: (Sys_error &quot;numbers.txt: Too many open files&quot;).
</programlisting>
      <para>
        And now, you'll need to restart your toplevel if you want to
        open any more files!
      </para>
      <para>
        To avoid this, we need to make sure that our code cleans up
        after itself. We can do this using the
        <literal>protect</literal> function described in
        <xref linkend="error-handling"/>, as follows.
      </para>
      <programlisting language="ocaml">
...part 1 of imperative-programming/file2.topscript
# let sum_file filename =
  let file = In_channel.create filename in
  protect ~f:(fun () -&gt;
      let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in
      List.fold ~init:0 ~f:(+) numbers)
    ~finally:(fun () -&gt; In_channel.close file)
;; 
val sum_file : string -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        And now, the file descriptor leak is gone:
      </para>
      <programlisting language="ocaml">
...part 2 of imperative-programming/file2.topscript
# for i = 1 to 10000 do try ignore (sum_file &quot;/etc/hosts&quot;) with _ -&gt; () done;; 
- : unit = ()
# sum_file &quot;numbers.txt&quot;;; 
- : int = 15
</programlisting>
      <para>
        This is really an example of a more general complexity of
        imperative programming. When programming imperatively, you need
        to be quite careful to make sure that exceptions don't leave you
        in an awkward state.
      </para>
      <para>
        <literal>In_channel</literal> also supports some idioms that
        handle some of the details of this for you. For example, the
        <literal>with_file</literal> function takes a filename and a
        function for processing that file, and takes care of the opening
        and closing of the file transparently.
      </para>
      <programlisting language="ocaml">
...part 3 of imperative-programming/file2.topscript
# let sum_file filename =
   In_channel.with_file filename ~f:(fun file -&gt;
     let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in
     List.fold ~init:0 ~f:(+) numbers)
;; 
val sum_file : string -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        Another misfeature of our implementation of
        <literal>sum_file</literal> is that we read the entire file into
        memory before processing it. For a large file, it's more
        efficient to process a line at a time. You can use the
        <literal>In_channel.fold_lines</literal> function to do just
        that.
      </para>
      <programlisting language="ocaml">
...part 4 of imperative-programming/file2.topscript
# let sum_file filename =
   In_channel.with_file filename ~f:(fun file -&gt;
     In_channel.fold_lines file ~init:0 ~f:(fun sum line -&gt;
       sum + Int.of_string line))
;; 
val sum_file : string -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This is just a taste of the functionality of
        <literal>In_channel</literal> and
        <literal>Out_channel</literal>. To get a fuller understanding
        you should review the API documentation for those modules.
      </para>
    </sect2>
  </sect1>
  <sect1 id="order-of-evaluation">
    <title>Order of evaluation</title>
    <para>
      The order in which expressions are evaluated is an important part
      of the definition of a programming language, and it is
      particularly important when programming imperatively. Most
      programming languages you're likely to have encountered are
      <emphasis>strict</emphasis>, and OCaml is too. In a strict
      language, when you bind an identifier to the result of some
      expression, the expression is evaluated before the variable is
      defined. Similarly, if you call a function on a set of arguments,
      those arguments are evaluated before they are passed to the
      function.
    </para>
    <para>
      Consider the following simple example. Here, we have a collection
      of angles and we want to determine if any of them have a negative
      <literal>sin</literal>. The following snippet of code would answer
      that question.
    </para>
    <programlisting language="ocaml">
...part 1 of imperative-programming/order.topscript
# let x = sin 120. in
let y = sin 75.  in
let z = sin 128. in
List.exists ~f:(fun x -&gt; x &lt; 0.) [x;y;z]
;; 
- : bool = true
</programlisting>
    <para>
      In some sense, we don't really need to compute the
      <literal>sin 128.</literal>, because <literal>sin 75.</literal> is
      negative, so we could know the answer before even computing
      <literal>sin 128.</literal>.
    </para>
    <para>
      It doesn't have to be this way. Using the <literal>lazy</literal>
      keyword, we can write the original computation so that
      <literal>sin 128.</literal> won't ever be computed.
    </para>
    <programlisting language="ocaml">
...part 2 of imperative-programming/order.topscript
# let x = lazy (sin 120.) in
let y = lazy (sin 75.)  in
let z = lazy (sin 128.) in
List.exists ~f:(fun x -&gt; Lazy.force x &lt; 0.) [x;y;z]
;; 
- : bool = true
</programlisting>
    <para>
      We can confirm that fact by a few well placed
      <literal>printf</literal>s.
    </para>
    <programlisting language="ocaml">
...part 3 of imperative-programming/order.topscript
# let x = lazy (printf &quot;1\n&quot;; sin 120.) in
let y = lazy (printf &quot;2\n&quot;; sin 75.)  in
let z = lazy (printf &quot;3\n&quot;; sin 128.) in
List.exists ~f:(fun x -&gt; Lazy.force x &lt; 0.) [x;y;z]
;; 

1
2
- : bool = true
</programlisting>
    <para>
      OCaml is strict by default for a good reason: Lazy evaluation and
      imperative programming generally don't mix well, because laziness
      makes it harder to reason about when a given side effect is going
      to occur. Understanding the order of side-effects is essential to
      reasoning about the behavior of an imperative program.
    </para>
    <para>
      In a strict language, we know that expressions that are bound by a
      sequence of let-bindings will be evaluated in the order that
      they're defined. But what about the evaluation order within a
      single expression? Officially, the answer is that evaluation order
      within an expression is undefined. In practice, OCaml has only one
      compiler, and that behavior is a kind of <emphasis>de
      facto</emphasis> standard. Unfortunately, the evaluation order in
      this case is often the opposite of what one might expect.
    </para>
    <para>
      Consider the following example.
    </para>
    <programlisting language="ocaml">
...part 4 of imperative-programming/order.topscript
# List.exists ~f:(fun x -&gt; x &lt; 0.)
  [ (printf &quot;1\n&quot;; sin 120.);
    (printf &quot;2\n&quot;; sin 75.);
    (printf &quot;3\n&quot;; sin 128.); ]
;; 

3
2
1
- : bool = true
</programlisting>
    <para>
      Here, you can see that the sub-expression that came last was
      actually evaluated first! This is generally the case for many
      different kinds of expressions. If you want to make sure of the
      evaluation order of different sub-expressions, you should express
      them as a series of <literal>let</literal> bindings.
    </para>
  </sect1>
  <sect1 id="side-effects-and-weak-polymorphism">
    <title>Side-effects and weak polymorphism</title>
    <para>
      Consider the following simple imperative function.
    </para>
    <programlisting language="ocaml">
...part 1 of imperative-programming/weak.topscript
# let remember =
  let cache = ref None in
  (fun x -&gt;
     match !cache with
     | Some y -&gt; y
     | None -&gt; cache := Some x; x)
;; 
val remember : '_a -&gt; '_a = &lt;fun&gt;
</programlisting>
    <para>
      <literal>remember</literal> simply caches the first value that's
      passed to it, returning that value on every call. Note that we've
      carefully written <literal>remember</literal> so that
      <literal>cache</literal> is created and initialized once, and is
      shared across invocations of <literal>remember</literal>.
    </para>
    <para>
      <literal>remember</literal> is not a terribly useful function, but
      it raises an interesting question: what type should it have?
    </para>
    <para>
      On its first call, <literal>remember</literal> returns the same
      value its passed, which means its input type and return type
      should match. Accordingly, <literal>remember</literal> should have
      the type <literal>t -&gt; t</literal> for some type
      <literal>t</literal>. There's nothing about
      <literal>remember</literal> that ties the choice of
      <literal>t</literal> to any particular type, so you might expect
      OCaml to generalize, replacing <literal>t</literal> with a
      polymorphic type variable. It's this kind of generalization that
      gives us polymorphic types in the first place. The identity
      function, as an example, gets a polymorphic type in this way.
    </para>
    <programlisting language="ocaml">
...part 2 of imperative-programming/weak.topscript
# let identity x = x;; 
val identity : 'a -&gt; 'a = &lt;fun&gt;
# identity 3;; 
- : int = 3
# identity &quot;five&quot;;; 
- : string = &quot;five&quot;
</programlisting>
    <para>
      As you can see, the polymorphic type of
      <literal>identity</literal> lets it operate on values with
      different types.
    </para>
    <para>
      This is not what happens with <literal>remember</literal>, though.
      As you can see from the <literal>utop</literal> output above, the
      type that OCaml infers for <literal>remember</literal>, which
      looks almost, but not quite, like the type of the identity
      function. Here it is again:
    </para>
    <programlisting language="ocaml">
(* imperative-programming/remember_type.ml  *)
val remember : '_a -&gt; '_a = &lt;fun&gt;
</programlisting>
    <para>
      The underscore in the type variable <literal>'_a</literal> tells
      us that the variable is only <emphasis>weakly
      polymorphic</emphasis>, which is to say that it can be used with
      any <emphasis>single</emphasis> type. That makes sense, because,
      unlike <literal>identity</literal>, <literal>remember</literal>
      always returns the value it was passed on its first invocation,
      which means it can only be used with one type.
    </para>
    <para>
      OCaml will convert a weakly polymorphic variable to a concrete
      type as soon as it gets a clue as to what concrete type it is to
      be used as, as you can see below.
    </para>
    <programlisting language="ocaml">
...part 3 of imperative-programming/weak.topscript
# let remember_three () = remember 3;; 
val remember_three : unit -&gt; int = &lt;fun&gt;
# remember;; 
- : int -&gt; int = &lt;fun&gt;
# remember &quot;avocado&quot;;; 
Characters 9-18:
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
    <para>
      Note that the type of <literal>remember</literal> was settled by
      the definition of <literal>remember_three</literal>, even though
      <literal>remember_three</literal> was never called!
    </para>
    <sect2 id="the-value-restriction">
      <title>The value restriction</title>
      <para>
        So, when does the compiler infer weakly polymorphic types? As
        we've seen, we need weakly polymorphic types when a value of
        unknown type is stored in a persistent mutable cell. Because the
        type system isn't precise enough to determine all cases where
        this might happen, OCaml uses a rough rule to flag cases where
        it's sure there are no persistent refs, and to only infer
        polymorphic types in those cases. This rule is called
        <emphasis>the value restriction</emphasis>.
      </para>
      <para>
        The core of the value restriction is the observation that some
        kinds of simple values by their nature can't contain refs,
        including:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Constants (<emphasis>i.e.</emphasis>, things like integer
            and floating-point literals)
          </para>
        </listitem>
        <listitem>
          <para>
            Constructors that contain only other simple values
          </para>
        </listitem>
        <listitem>
          <para>
            Function declarations, <emphasis>i.e.</emphasis>,
            expressions that begin with <literal>fun</literal> or
            <literal>function</literal>, or, the equivalent let binding,
            <literal>let f x = ...</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>let</literal> bindings of the form
            <literal>let var = &lt;expr1&gt; in &lt;expr2&gt;</literal>,
            where both <literal>&lt;expr1&gt;</literal> and
            <literal>&lt;expr2&gt;</literal> are simple values.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Thus, the following expression is a simple value, and as a
        result, the types of values contained within it are allowed to
        be polymorphic.
      </para>
      <programlisting language="ocaml">
...part 1 of imperative-programming/value_restriction.topscript
# (fun x -&gt; [x;x]);; 
- : 'a -&gt; 'a list = &lt;fun&gt;
</programlisting>
      <para>
        But, if we write down an expression that isn't a simple value by
        the above definition, we'll get different results. For example,
        consider what happens if we try to memoize the function defined
        above.
      </para>
      <programlisting language="ocaml">
...part 2 of imperative-programming/value_restriction.topscript
# memoize (fun x -&gt; [x;x]);; 
- : '_a -&gt; '_a list = &lt;fun&gt;
</programlisting>
      <para>
        The memoized version of the function does in fact need to be
        restricted to a single type, because it uses mutable state
        behind the scenes to cache values returned by previous
        invocations of the function. But OCaml would make the same
        determination even if the function in question did no such
        thing. Consider this example:
      </para>
      <programlisting language="ocaml">
...part 3 of imperative-programming/value_restriction.topscript
# identity (fun x -&gt; [x;x]);; 
- : '_a -&gt; '_a list = &lt;fun&gt;
</programlisting>
      <para>
        It would be safe to infer a weakly polymorphic variable here,
        but because OCaml's type system doesn't distinguish between pure
        and impure functions, it can't separate those two cases.
      </para>
      <para>
        The value restriction doesn't require that there is no mutable
        state, only that there is no <emphasis>persistent</emphasis>
        mutable state that could share values between uses of the same
        function. Thus, a function that produces a fresh reference every
        time it's called can have a fully polymorphic type:
      </para>
      <programlisting language="ocaml">
...part 4 of imperative-programming/value_restriction.topscript
# let f () = ref None;; 
val f : unit -&gt; 'a option ref = &lt;fun&gt;
</programlisting>
      <para>
        But a function that has a mutable cache that persists across
        calls, like memoize, can only be weakly polymorphic.
      </para>
    </sect2>
    <sect2 id="partial-application-and-the-value-restriction">
      <title>Partial application and the value restriction</title>
      <para>
        Most of the time, when the value restriction kicks in, it's for
        a good reason, <emphasis>i.e.</emphasis>, it's because the value
        in question can actually only safely be used with a single type.
        But sometimes, the value restriction kicks in when you don't
        want it. The most common such case is partially applied
        functions. A partially applied function, like any function
        application, is not a simple value, and as such, functions
        created by partial application are sometimes less general than
        you might expect.
      </para>
      <para>
        Consider the <literal>List.init</literal> function, which is
        used for creating lists where each element is created by calling
        a function on the index of that element.
      </para>
      <programlisting language="ocaml">
...part 5 of imperative-programming/value_restriction.topscript
# List.init;; 
- : int -&gt; f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;
# List.init 10 ~f:Int.to_string;; 
- : string list = [&quot;0&quot;; &quot;1&quot;; &quot;2&quot;; &quot;3&quot;; &quot;4&quot;; &quot;5&quot;; &quot;6&quot;; &quot;7&quot;; &quot;8&quot;; &quot;9&quot;]
</programlisting>
      <para>
        Imagine we wanted to create a specialized version of
        <literal>List.init</literal> that always created lists of length
        10. We could do that using partial application, as follows.
      </para>
      <programlisting language="ocaml">
...part 6 of imperative-programming/value_restriction.topscript
# let list_init_10 = List.init 10;; 
val list_init_10 : f:(int -&gt; '_a) -&gt; '_a list = &lt;fun&gt;
</programlisting>
      <para>
        As you can see, we now infer a weakly polymorphic type for the
        resulting function, and for good reason. There's nothing that
        tells us that <literal>List.init</literal> isn't creating a
        persistent <literal>ref</literal> somewhere inside of it that
        would be shared across multiple calls to
        <literal>list_init_10</literal>. We can eliminate this
        possibility, and at the same time get the compiler to infer a
        polymorphic type, by using explicit variables rather than
        partial application.
      </para>
      <programlisting language="ocaml">
...part 7 of imperative-programming/value_restriction.topscript
# let list_init_10 ~f = List.init 10 ~f;; 
val list_init_10 : f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;
</programlisting>
      <para>
        This transformation is referred to as <emphasis>eta
        expansion</emphasis>, and is often useful to resolve problems
        that arise from the value restriction.
      </para>
    </sect2>
    <sect2 id="relaxing-the-value-restriction">
      <title>Relaxing the value restriction</title>
      <para>
        OCaml is actually a little better at inferring polymorphic types
        than is implied above. The value restriction as we described it
        above is basically a syntactic check: there are a few operations
        that you can do that count as simple values, and anything that's
        a simple value can be generalized.
      </para>
      <para>
        But OCaml actually has a relaxed version of the value
        restriction that can make some use of type information to allow
        polymorphic types for things that are not simple values.
      </para>
      <para>
        For example, we saw above that a function application, even a
        simple application of the identity function, is not a simple
        value and thus can turn a polymorphic value into a weakly
        polymorphic one.
      </para>
      <programlisting language="ocaml">
...part 8 of imperative-programming/value_restriction.topscript
# identity (fun x -&gt; [x;x]);; 
- : '_a -&gt; '_a list = &lt;fun&gt;
</programlisting>
      <para>
        But that's not always the case. When the type of the returned
        value is immutable, then OCaml can typically infer a fully
        polymorphic type.
      </para>
      <programlisting language="ocaml">
...part 9 of imperative-programming/value_restriction.topscript
# identity [];; 
- : 'a list = []
</programlisting>
      <para>
        On the other hand, if the returned type is potentially mutable,
        then the result will be weakly polymorphic.
      </para>
      <programlisting language="ocaml">
...part 10 of imperative-programming/value_restriction.topscript
# [||];; 
- : 'a array = [||]
# identity [||];; 
- : '_a array = [||]
</programlisting>
      <para>
        A more important example of this comes up when defining abstract
        data types. Consider the following simple data-structure for an
        immutable list type that supports constant-time concatenation.
      </para>
      <programlisting language="ocaml">
...part 11 of imperative-programming/value_restriction.topscript
# module Concat_list : sig
  type 'a t
  val empty : 'a t
  val singleton : 'a -&gt; 'a t
  val concat  : 'a t -&gt; 'a t -&gt; 'a t  (* constant time *)
  val to_list : 'a t -&gt; 'a list       (* linear time   *)
end = struct

  type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t

  let empty = Empty
  let singleton x = Singleton x
  let concat x y = Concat (x,y)

  let rec to_list_with_tail t tail =
    match t with
    | Empty -&gt; tail
    | Singleton x -&gt; x :: tail
    | Concat (x,y) -&gt; to_list_with_tail x (to_list_with_tail y tail)

  let to_list t =
    to_list_with_tail t []

end;; 
module Concat_list :
  sig
    type 'a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat : 'a t -&gt; 'a t -&gt; 'a t
    val to_list : 'a t -&gt; 'a list
  end
</programlisting>
      <para>
        The details of the implementation don't matter so much, but it's
        important to note that a <literal>Concat_list.t</literal> is
        unquestionably an immutable value. However, when it comes to the
        value restriction, OCaml treats it as if it were mutable.
      </para>
      <programlisting language="ocaml">
...part 12 of imperative-programming/value_restriction.topscript
# Concat_list.empty;; 
- : 'a Concat_list.t = &lt;abstr&gt;
# identity Concat_list.empty;; 
- : '_a Concat_list.t = &lt;abstr&gt;
</programlisting>
      <para>
        The issue here is that the signature, by virtue of being
        abstract, has obscured the fact that
        <literal>Concat_list.t</literal> is in fact an immutable
        data-type. We can resolve this in one of two ways: either by
        making the type concrete (<emphasis>i.e.</emphasis>, exposing
        the implementation in the <literal>mli</literal>), which is
        often not desirable; or by marking the type variable in question
        as <emphasis>covariant</emphasis>. We'll learn more about
        variance and covariance in <xref linkend="objects"/>,
        but for now, you can think of it as an annotation which can be
        put in the interface of a pure data structure.
      </para>
      <para>
        Thus, if we replace <literal>type 'a t</literal> in the
        interface with <literal>type +'a t</literal>, that will make it
        explicit in the interface that the data-structure doesn't
        contain any persistent references to values of type
        <literal>'a</literal>, at which point, OCaml can infer
        polymorphic types for expressions of this type that are not
        simple values.
      </para>
      <programlisting language="ocaml">
...part 13 of imperative-programming/value_restriction.topscript
# module Concat_list : sig
  type +'a t
  val empty : 'a t
  val singleton : 'a -&gt; 'a t
  val concat  : 'a t -&gt; 'a t -&gt; 'a t (* constant time *)
  val to_list : 'a t -&gt; 'a list       (* linear time   *)
end = struct

  type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t

  let empty = Empty
  let singleton x = Singleton x
  let concat x y = Concat (x,y)

  let rec to_list_with_tail t tail =
    match t with
    | Empty -&gt; tail
    | Singleton x -&gt; x :: tail
    | Concat (x,y) -&gt; to_list_with_tail x (to_list_with_tail y tail)

  let to_list t =
    to_list_with_tail t []

end;; 
module Concat_list :
  sig
    type +'a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat : 'a t -&gt; 'a t -&gt; 'a t
    val to_list : 'a t -&gt; 'a list
  end
# 
identity Concat_list.empty;; 
- : 'a Concat_list.t = &lt;abstr&gt;
</programlisting>
    </sect2>
  </sect1>
</chapter><chapter id="functors">
  <title>Functors</title>
  <para>
    Up until now, we've seen OCaml's modules play an important but
    limited role. In particular, we've seen them as a mechanism for
    organizing code into units with specified interfaces. But OCaml's
    module system can do much more than that, serving as a powerful tool
    for building generic code and structuring large-scale systems. Much
    of that power comes from functors.
  </para>
  <para>
    Functors are, roughly speaking, functions from modules to modules,
    and they can be used to solve a variety of code-structuring
    problems, including:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis>Dependency injection</emphasis>, or making the
        implementations of some components of a system swappable. This
        is particularly useful when you want to mock up parts of your
        system for testing and simulation purposes.
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis>Auto-extension of modules</emphasis>. Functors give
        you a way of extending existing modules with new functionality
        in a standardized way. For example, you might want to add a slew
        of comparison operators derived from a base comparison function.
        To do this by hand would require a lot of repetitive code for
        each type, but functors let you write this logic just once and
        apply it to many different types.
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis>Instantiating modules with state</emphasis>. Modules
        can contain mutable state, and that means that you'll
        occasionally want to have multiple instantiations of a
        particular module, each with its own separate and independent
        mutable state. Functors let you automate the construction of
        such modules.
      </para>
    </listitem>
  </itemizedlist>
  <sect1 id="a-trivial-example">
    <title>A trivial example</title>
    <para>
      Let's create a functor that takes a module containing a single
      integer variable <literal>x</literal>, and returns a new module
      with <literal>x</literal> incremented by one. This is not actually
      a useful example, but it's a good way to walk through the basic
      mechanics of functors.
    </para>
    <para>
      First, let's define a signature for a module that contains a
      single value of type <literal>int</literal>.
    </para>
    <programlisting language="ocaml">
# script functors/main.topscript
$ utop
# module type X_int = sig val x : int end;; 
module type X_int = sig val x : int end
</programlisting>
    <para>
      Now we can define our functor. We'll use <literal>X_int</literal>
      both to constrain the argument to the functor, and to constrain
      the module returned by the functor.
    </para>
    <programlisting language="ocaml">
...part 1 of functors/main.topscript
# module Increment (M : X_int) : X_int = struct
    let x = M.x + 1
  end;; 
module Increment : functor (M : X_int) -&gt; X_int
</programlisting>
    <para>
      One thing that immediately jumps out is that functors are more
      syntactically heavyweight than ordinary functions. For one thing,
      functors require explicit (module) type annotations, which
      ordinary functions do not. Technically, only the type on the input
      is mandatory, although in practice, you should usually constrain
      the module returned by the functor, just as you should use an
      <literal>mli</literal>, even though it's not mandatory.
    </para>
    <para>
      The following shows what happens when we omit the module type for
      the output of the functor.
    </para>
    <programlisting language="ocaml">
...part 2 of functors/main.topscript
# module Increment (M : X_int) = struct
    let x = M.x + 1
  end;; 
module Increment : functor (M : X_int) -&gt; sig val x : int end
</programlisting>
    <para>
      We can see that the inferred module type of the output is now
      written out explicitly, rather than being a reference to the named
      signature <literal>X_int</literal>.
    </para>
    <para>
      We can now use <literal>Increment</literal> to define new modules.
    </para>
    <programlisting language="ocaml">
...part 3 of functors/main.topscript
# module Three = struct let x = 3 end;; 
module Three : sig val x : int end
# module Four = Increment(Three);; 
module Four : sig val x : int end
# Four.x - Three.x;; 
- : int = 1
</programlisting>
    <para>
      In this case, we applied <literal>Increment</literal> to a module
      whose signature is exactly equal to <literal>X_int</literal>. But
      we can apply <literal>Increment</literal> to any module that
      <emphasis>satisfies</emphasis> the interface
      <literal>X_int</literal>, in the same way that the contents of an
      <literal>ml</literal> file must satisfy the
      <literal>mli</literal>. That means that the module type can omit
      some information available in the module, either by dropping
      fields or by leaving some fields abstract. Here's an example:
    </para>
    <programlisting language="ocaml">
...part 4 of functors/main.topscript
# module Three_and_more = struct
    let x = 3
    let y = &quot;three&quot;
  end;; 
module Three_and_more : sig val x : int val y : string end
# module Four = Increment(Three_and_more);; 
module Four : sig val x : int end
</programlisting>
    <para>
      The rules for determining whether a module matches a given
      signature are similar in spirit to the rules in an object-oriented
      language that determine whether an object satisfies a given
      interface. As in an object-oriented context, the extra information
      that doesn't match the signature you're looking for (in this case,
      the variable <literal>y</literal>), is simply ignored.
    </para>
  </sect1>
  <sect1 id="a-bigger-example-computing-with-intervals">
    <title>A bigger example: computing with intervals</title>
    <para>
      Let's consider a more realistic example of how to use functors: a
      library for computing with intervals. Intervals are a common
      computational object, and they come up in different contexts and
      for different types. You might need to work with intervals of
      floating point values, or strings, or times, and in each of these
      cases, you want similar operations: testing for emptiness,
      checking for containment, intersecting intervals, and so on.
    </para>
    <para>
      Let's see how to use functors to build a generic interval library
      that can be used with any type that supports a total ordering on
      the underlying set over which you want to build intervals.
    </para>
    <para>
      First we'll define a module type that captures the information
      we'll need about the endpoints of the intervals. This interface,
      which we'll call <literal>Comparable</literal>, contains just two
      things: a comparison function, and the type of the values to be
      compared.
    </para>
    <programlisting language="ocaml">
...part 5 of functors/main.topscript
# module type Comparable = sig
    type t
    val compare : t -&gt; t -&gt; int
  end ;; 
module type Comparable = sig type t val compare : t -&gt; t -&gt; int end
</programlisting>
    <para>
      The comparison function follows the standard OCaml idiom for such
      functions, returning <literal>0</literal> if the two elements are
      equal, a positive number if the first element is larger than the
      second, and a negative number if the first element is smaller than
      the second. Thus, we could rewrite the standard comparison
      functions on top of <literal>compare</literal> as shown below.
    </para>
    <programlisting language="ocaml">
(* functors/compare_example.ml  *)
compare x y &lt; 0     (* x &lt; y *)
compare x y = 0     (* x = y *)
compare x y &gt; 0     (* x &gt; y *)
</programlisting>
    <para>
      (This idiom is a bit of a historical error. It would be better if
      compare returned a variant with three cases for less than, greater
      than and equal. But it's a well-established idiom at this point,
      and unlikely to change.)
    </para>
    <para>
      The functor for creating the interval module is shown below. We
      represent an interval with a variant type, which is either
      <literal>Empty</literal> or <literal>Interval (x,y)</literal>,
      where <literal>x</literal> and <literal>y</literal> are the bounds
      of the interval. In addition to the type, the functor contains
      implementations of a number of useful primitives for interacting
      with intervals.
    </para>
    <programlisting language="ocaml">
...part 6 of functors/main.topscript
# module Make_interval(Endpoint : Comparable) = struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    (** [create low high] creates a new interval from [low] to
        [high].  If [low &gt; high], then the interval is empty *)
    let create low high =
      if Endpoint.compare low high &gt; 0 then Empty
      else Interval (low,high)

    (** Returns true iff the interval is empty *)
    let is_empty = function
      | Empty -&gt; true
      | Interval _ -&gt; false

    (** [contains t x] returns true iff [x] is contained in the
        interval [t] *)
    let contains t x =
      match t with
      | Empty -&gt; false
      | Interval (l,h) -&gt;
        Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

    (** [intersect t1 t2] returns the intersection of the two input
        intervals *)
    let intersect t1 t2 =
      let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
      let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
      match t1,t2 with
      | Empty, _ | _, Empty -&gt; Empty
      | Interval (l1,h1), Interval (l2,h2) -&gt;
        create (max l1 l2) (min h1 h2)

  end ;; 
module Make_interval :
  functor (Endpoint : Comparable) -&gt;
    sig
      type t = Interval of Endpoint.t * Endpoint.t | Empty
      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; Endpoint.t -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end
</programlisting>
    <para>
      We can instantiate the functor by applying it to a module with the
      right signature. In the following, rather than name the module
      first and then call the functor, we provide the functor input as
      an anonymous module.
    </para>
    <programlisting language="ocaml">
...part 7 of functors/main.topscript
# module Int_interval =
    Make_interval(struct
      type t = int
      let compare = Int.compare
    end);; 
module Int_interval :
  sig
    type t = Interval of int * int | Empty
    val create : int -&gt; int -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; int -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
    <para>
      If the input interface for your functor is aligned with the
      standards of the libraries you use, then you don't need to
      construct a custom module to feed to the functor. In this case, we
      can directly use the <literal>Int</literal> or
      <literal>String</literal> modules provided by Core.
    </para>
    <programlisting language="ocaml">
...part 8 of functors/main.topscript
# module Int_interval = Make_interval(Int) ;; 
module Int_interval :
  sig
    type t = Make_interval(Core.Std.Int).t = Interval of int * int | Empty
    val create : int -&gt; int -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; int -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
# module String_interval = Make_interval(String) ;; 
module String_interval :
  sig
    type t =
      Make_interval(Core.Std.String).t =
        Interval of string * string
      | Empty
    val create : string -&gt; string -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; string -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
    <para>
      This works because many modules in Core, including
      <literal>Int</literal> and <literal>String</literal>, satisfy an
      extended version of the <literal>Comparable</literal> signature
      described above. Such standardized signatures are good practice,
      both because they makes functors easier to use, and because they
      make your codebase generally easier to navigate.
    </para>
    <para>
      Now we can use the newly defined <literal>Int_interval</literal>
      module like any ordinary module.
    </para>
    <programlisting language="ocaml">
...part 9 of functors/main.topscript
# let i1 = Int_interval.create 3 8;; 
val i1 : Int_interval.t = Int_interval.Interval (3, 8)
# let i2 = Int_interval.create 4 10;; 
val i2 : Int_interval.t = Int_interval.Interval (4, 10)
# Int_interval.intersect i1 i2;; 
- : Int_interval.t = Int_interval.Interval (4, 8)
</programlisting>
    <para>
      This design gives us the freedom to use any comparison function we
      want for comparing the endpoints. We could, for example, create a
      type of integer interval with the order of the comparison
      reversed, as follows:
    </para>
    <programlisting language="ocaml">
...part 10 of functors/main.topscript
# module Rev_int_interval =
    Make_interval(struct
      type t = int
      let compare x y = Int.compare y x
    end);; 
module Rev_int_interval :
  sig
    type t = Interval of int * int | Empty
    val create : int -&gt; int -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; int -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
    <para>
      The behavior of <literal>Rev_int_interval</literal> is of course
      different from <literal>Int_interval</literal>, as we can see
      below.
    </para>
    <programlisting language="ocaml">
...part 11 of functors/main.topscript
# let interval = Int_interval.create 4 3;; 
val interval : Int_interval.t = Int_interval.Empty
# let rev_interval = Rev_int_interval.create 4 3;; 
val rev_interval : Rev_int_interval.t = Rev_int_interval.Interval (4, 3)
</programlisting>
    <para>
      Importantly, <literal>Rev_int_interval.t</literal> is a different
      type than <literal>Int_interval.t</literal>, even though its
      physical representation is the same. Indeed, the type system will
      prevent us from confusing them.
    </para>
    <programlisting language="ocaml">
...part 12 of functors/main.topscript
# Int_interval.contains rev_interval 3;; 
Characters 22-34:
Error: This expression has type Rev_int_interval.t
       but an expression was expected of type Int_interval.t
</programlisting>
    <para>
      This is important, because confusing the two kinds of intervals
      would be a semantic error, and it's an easy one to make. The
      ability of functors to mint new types is a useful trick that comes
      up a lot.
    </para>
    <sect2 id="making-the-functor-abstract">
      <title>Making the functor abstract</title>
      <para>
        There's a problem with <literal>Make_interval</literal>. The
        code we wrote depends on the invariant that the upper bound of
        an interval is greater than its lower bound, but that invariant
        can be violated. The invariant is enforced by the create
        function, but because <literal>Interval.t</literal> is not
        abstract, we can bypass the <literal>create</literal> function.
      </para>
      <programlisting language="ocaml">
...part 13 of functors/main.topscript
# Int_interval.create 4 3       (* going through create *);; 
- : Int_interval.t = Int_interval.Empty
# Int_interval.Interval (4,3)   (* bypassing create *);; 
- : Int_interval.t = Int_interval.Interval (4, 3)
</programlisting>
      <para>
        To make <literal>Int_interval.t</literal> abstract, we need to
        restrict the output of <literal>Make_interval</literal> with an
        interface. Here's an explicit interface that we can use for that
        purpose.
      </para>
      <programlisting language="ocaml">
...part 14 of functors/main.topscript
# module type Interval_intf = sig
   type t
   type endpoint
   val create : endpoint -&gt; endpoint -&gt; t
   val is_empty : t -&gt; bool
   val contains : t -&gt; endpoint -&gt; bool
   val intersect : t -&gt; t -&gt; t
  end;; 
module type Interval_intf =
  sig
    type t
    type endpoint
    val create : endpoint -&gt; endpoint -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; endpoint -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
      <para>
        This interface includes the type <literal>endpoint</literal> to
        give us a way of referring to the endpoint type. Given this
        interface, we can redo our definition of
        <literal>Make_interval</literal>. Notice that we added the type
        <literal>endpoint</literal> to the implementation of the module
        to match <literal>Interval_intf</literal>.
      </para>
      <programlisting language="ocaml">
# script functors/main-15.rawscript
$ utop
# module Make_interval(Endpoint : Comparable) : Interval_intf = struct
    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;
  module Make_interval : functor (Endpoint : Comparable) -&gt; Interval_intf
</programlisting>
    </sect2>
    <sect2 id="sharing-constraints">
      <title>Sharing constraints</title>
      <para>
        The resulting module is abstract, but it's unfortunately too
        abstract. In particular, we haven't exposed the type
        <literal>endpoint</literal>, which means that we can't even
        construct an interval anymore.
      </para>
      <programlisting language="ocaml">
...part 16 of functors/main.topscript
# module Int_interval = Make_interval(Int);; 
module Int_interval :
  sig
    type t = Make_interval(Core.Std.Int).t
    type endpoint = Make_interval(Core.Std.Int).endpoint
    val create : endpoint -&gt; endpoint -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; endpoint -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
# Int_interval.create 3 4;; 
Characters 20-21:
Error: This expression has type int but an expression was expected of type
         Int_interval.endpoint
</programlisting>
      <para>
        To fix this, we need to expose the fact that
        <literal>endpoint</literal> is equal to <literal>Int.t</literal>
        (or more generally, <literal>Endpoint.t</literal>, where
        <literal>Endpoint</literal> is the argument to the functor). One
        way of doing this is through a <emphasis>sharing
        constraint</emphasis>, which allows you to tell the compiler to
        expose the fact that a given type is equal to some other type.
        The syntax for a simple sharing constraint is as follows.
      </para>
      <programlisting language="html">
&lt;Module_type&gt; with type &lt;type&gt; = &lt;type'&gt;
</programlisting>
      <para>
        The result of this expression is a new signature that's been
        modified so that it exposes the fact that
        <literal>&lt;type&gt;</literal> defined inside of the module
        type is equal to <literal>&lt;type'&gt;</literal> whose
        definition is outside of it. One can also apply multiple sharing
        constraints to the same signature.
      </para>
      <programlisting language="html">
&lt;Module_type&gt; with type &lt;type1&gt; = &lt;type1'&gt; and &lt;type2&gt; = &lt;type2'&gt;
</programlisting>
      <para>
        We can use a sharing constraint to create a specialized version
        of <literal>Interval_intf</literal> for integer intervals.
      </para>
      <programlisting language="ocaml">
...part 17 of functors/main.topscript
# module type Int_interval_intf =
    Interval_intf with type endpoint = int;; 
module type Int_interval_intf =
  sig
    type t
    type endpoint = int
    val create : endpoint -&gt; endpoint -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; endpoint -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
      <para>
        We can also use sharing constraints in the context of a functor.
        The most common use case is where you want to expose that some
        of the types of the module being generated by the functor are
        related to the types in the module fed to the functor.
      </para>
      <para>
        In this case, we'd like to expose an equality between the type
        <literal>endpoint</literal> in the new module and the type
        <literal>Endpoint.t</literal>, from the module
        <literal>Endpoint</literal> that is the functor argument. We can
        do this as follows.
      </para>
      <programlisting language="ocaml">
# script functors/main-18.rawscript
$ utop
# module Make_interval(Endpoint : Comparable)
      : (Interval_intf with type endpoint = Endpoint.t)
  = struct

    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;
module Make_interval :
  functor (Endpoint : Comparable) -&gt;
    sig
      type t
      type endpoint = Endpoint.t
      val create : endpoint -&gt; endpoint -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; endpoint -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end
</programlisting>
      <para>
        So now, the interface is as it was, except that
        <literal>endpoint</literal> is now known to be equal to
        <literal>Endpoint.t</literal>. As a result of that type
        equality, we can again do things that require that
        <literal>endpoint</literal> be exposed, like constructing
        intervals.
      </para>
      <programlisting language="ocaml">
...part 19 of functors/main.topscript
# let i = Int_interval.create 3 4;; 
Characters 28-29:
Error: This expression has type int but an expression was expected of type
         Int_interval.endpoint
# Int_interval.contains i 5;; 
Characters 22-23:
Error: Unbound value i
</programlisting>
    </sect2>
    <sect2 id="destructive-substitution">
      <title>Destructive substitution</title>
      <para>
        Sharing constraints basically do the job, but they have some
        downsides. In particular, we've now been stuck with the useless
        type declaration of <literal>endpoint</literal> that clutters up
        both the interface and the implementation. A better solution
        would be to modify the <literal>Interval_intf</literal>
        signature by replacing <literal>endpoint</literal> with
        <literal>Endpoint.t</literal> everywhere it shows up, and
        deleting the definition of <literal>endpoint</literal> from the
        signature. We can do just this using what's called
        <emphasis>destructive substitution</emphasis>. Here's the basic
        syntax.
      </para>
      <programlisting language="html">
&lt;Module_type&gt; with type &lt;type&gt; := &lt;type'&gt;
</programlisting>
      <para>
        The following shows how we could use this with
        <literal>Make_interval</literal>.
      </para>
      <programlisting language="ocaml">
...part 20 of functors/main.topscript
# module type Int_interval_intf =
    Interval_intf with type endpoint := int;; 
module type Int_interval_intf =
  sig
    type t
    val create : int -&gt; int -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; int -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
      <para>
        There's now no <literal>endpoint</literal> type: all of its
        occurrences of have been replaced by <literal>int</literal>. As
        with sharing constraints, we can also use this in the context of
        a functor.
      </para>
      <programlisting language="ocaml">
# script functors/main-21.rawscript
$ utop
# module Make_interval(Endpoint : Comparable)
    : Interval_intf with type endpoint := Endpoint.t =
  struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;
  module Make_interval :
    functor (Endpoint : Comparable) -&gt;
    sig
      type t
      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; Endpoint.t -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end
</programlisting>
      <para>
        The interface is precisely what we want: the type
        <literal>t</literal> is abstract, the type of the endpoint is
        exposed, so we can create values of type
        <literal>Int_interval.t</literal> using the creation function,
        but not directly using the constructors and thereby violating
        the invariants of the module, as you can see below.
      </para>
      <programlisting language="ocaml">
...part 22 of functors/main.topscript
# module Int_interval = Make_interval(Int);; 
module Int_interval :
  sig
    type t = Make_interval(Core.Std.Int).t
    val create : int -&gt; int -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; int -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
# Int_interval.create 3 4;; 
- : Int_interval.t = &lt;abstr&gt;
# Int_interval.Interval (4,3);; 
Characters 13-21:
Error: Unbound constructor Int_interval.Interval
</programlisting>
      <para>
        In addition, the <literal>endpoint</literal> type is gone from
        the interface, meaning we no longer need to define the
        <literal>endpoint</literal> type alias in the body of the
        module.
      </para>
      <para>
        It's worth noting that the name is somewhat misleading, in that
        there's nothing destructive about destructive substitution; it's
        really just a way of creating a new signature by transforming an
        existing one.
      </para>
    </sect2>
    <sect2 id="using-multiple-interfaces">
      <title>Using multiple interfaces</title>
      <para>
        Another feature that we might want for our interval module is
        the ability to <emphasis>serialize</emphasis>,
        <emphasis>i.e.</emphasis>, to be able to read and write
        intervals as a stream of bytes. In this case, we'll do this by
        converting to and from s-expressions, which were mentioned
        already in <xref linkend="error-handling"/>. To
        recall, an s-expression is essentially a parenthesized
        expression whose atoms are strings, and it is a serialization
        format that is used commonly in Core. Here's an example.
      </para>
      <programlisting language="ocaml">
...part 23 of functors/main.topscript
# Sexp.of_string &quot;(This is (an s-expression))&quot;;; 
- : Sexp.t = (This is (an s-expression))
</programlisting>
      <para>
        Core comes with a syntax extension called
        <literal>sexplib</literal> which can autogenerate s-expression
        conversion functions from a type declaration. Attaching
        <literal>with sexp</literal> to a type definition signals to the
        extension to generate the converters. Thus, we can write:
      </para>
      <programlisting language="ocaml">
...part 24 of functors/main.topscript
# type some_type = int * string list with sexp;; 
type some_type = int * string list
val some_type_of_sexp : Sexp.t -&gt; int * string list = &lt;fun&gt;
val sexp_of_some_type : int * string list -&gt; Sexp.t = &lt;fun&gt;
# sexp_of_some_type (33, [&quot;one&quot;; &quot;two&quot;]);; 
- : Sexp.t = (33 (one two))
# Sexp.of_string &quot;(44 (five six))&quot; |&gt; some_type_of_sexp;; 
- : int * string list = (44, [&quot;five&quot;; &quot;six&quot;])
</programlisting>
      <para>
        We'll discuss s-expressions and <literal>sexplib</literal> in
        more detail in
        <xref linkend="data-serialization-with-s-expressions"/>,
        but for now, let's see what happens if we attach the
        <literal>with sexp</literal> declaration to the definition of
        <literal>t</literal> within the functor.
      </para>
      <programlisting language="ocaml">
# script functors/main-25.rawscript
$ utop
# module Make_interval(Endpoint : Comparable)
    : (Interval_intf with type endpoint := Endpoint.t) = struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty
    with sexp

    ...

  end ;;
  Characters 136-146:
    Error: Unbound value Endpoint.t_of_sexp
</programlisting>
      <para>
        The problem is that <literal>with sexp</literal> adds code for
        defining the s-expression converters, and that code assumes that
        <literal>Endpoint</literal> has the appropriate sexp-conversion
        functions for <literal>Endpoint.t</literal>. But all we know
        about <literal>Endpoint</literal> is that it satisfies the
        <literal>Comparable</literal> interface, which doesn't say
        anything about s-expressions.
      </para>
      <para>
        Happily, Core comes with a built in interface for just this
        purpose called <literal>Sexpable</literal>, which is defined as
        follows:
      </para>
      <programlisting language="ocaml">
(* functors/sexpable.ml  *)
module type Sexpable = sig
  type t
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
end
</programlisting>
      <para>
        We can modify <literal>Make_interval</literal> to use the
        <literal>Sexpable</literal> interface, for both its input and
        its output. First, let's create an extended version of the
        <literal>Interval_intf</literal> interface that includes the
        functions from the Sexpable interface. We can do this using
        destructive substitution on the <literal>Sexpable</literal>
        interface, to avoid having multiple distinct type
        <literal>t</literal>'s clashing with each other.
      </para>
      <programlisting language="ocaml">
...part 26 of functors/main.topscript
# module type Interval_intf_with_sexp = sig
   include Interval_intf
   include Sexpable with type t := t
  end;; 
module type Interval_intf_with_sexp =
  sig
    type t
    type endpoint
    val create : endpoint -&gt; endpoint -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; endpoint -&gt; bool
    val intersect : t -&gt; t -&gt; t
    val t_of_sexp : Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
  end
</programlisting>
      <para>
        Equivalently, we can define a type <literal>t</literal> within
        our new module, and apply destructive substitutions to all of
        the included interfaces, <literal>Interval_intf</literal>
        included, as shown below. This is somewhat cleaner when
        combining multiple interfaces, since it correctly reflects that
        all of the signatures are being handled equivalently.
      </para>
      <programlisting language="ocaml">
...part 27 of functors/main.topscript
# module type Interval_intf_with_sexp = sig
   type t
   include Interval_intf with type t := t
   include Sexpable      with type t := t
  end;; 
module type Interval_intf_with_sexp =
  sig
    type t
    type endpoint
    val create : endpoint -&gt; endpoint -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; endpoint -&gt; bool
    val intersect : t -&gt; t -&gt; t
    val t_of_sexp : Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
  end
</programlisting>
      <para>
        Now we can write the functor itself. We have been careful to
        override the sexp-converter here to ensure that the data
        structure's invariants are still maintained when reading in from
        an s-expression.
      </para>
      <programlisting language="ocaml">
...part 28 of functors/main.topscript
# module Make_interval(Endpoint : sig
                         type t
                         include Comparable with type t := t
                         include Sexpable   with type t := t
                       end)
    : (Interval_intf_with_sexp with type endpoint := Endpoint.t)
  = struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty
    with sexp

    (** [create low high] creates a new interval from [low] to
        [high].  If [low &gt; high], then the interval is empty *)
    let create low high =
      if Endpoint.compare low high &gt; 0 then Empty
      else Interval (low,high)

    (* put a wrapper around the autogenerated [t_of_sexp] to enforce
       the invariants of the data structure *)
    let t_of_sexp sexp =
      match t_of_sexp sexp with
      | Empty -&gt; Empty
      | Interval (x,y) -&gt; create x y

    (** Returns true iff the interval is empty *)
    let is_empty = function
      | Empty -&gt; true
      | Interval _ -&gt; false

    (** [contains t x] returns true iff [x] is contained in the
        interval [t] *)
    let contains t x =
      match t with
      | Empty -&gt; false
      | Interval (l,h) -&gt;
        Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

    (** [intersect t1 t2] returns the intersection of the two input
        intervals *)
    let intersect t1 t2 =
      let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
      let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
      match t1,t2 with
      | Empty, _ | _, Empty -&gt; Empty
      | Interval (l1,h1), Interval (l2,h2) -&gt;
        create (max l1 l2) (min h1 h2)
  end;; 
module Make_interval :
  functor
    (Endpoint : sig
                  type t
                  val compare : t -&gt; t -&gt; int
                  val t_of_sexp : Sexp.t -&gt; t
                  val sexp_of_t : t -&gt; Sexp.t
                end) -&gt;
    sig
      type t
      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; Endpoint.t -&gt; bool
      val intersect : t -&gt; t -&gt; t
      val t_of_sexp : Sexp.t -&gt; t
      val sexp_of_t : t -&gt; Sexp.t
    end
</programlisting>
      <para>
        And now, we can use that sexp-converter in the ordinary way:
      </para>
      <programlisting language="ocaml">
...part 29 of functors/main.topscript
# module Int_interval = Make_interval(Int) ;; 
module Int_interval :
  sig
    type t = Make_interval(Core.Std.Int).t
    val create : int -&gt; int -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; int -&gt; bool
    val intersect : t -&gt; t -&gt; t
    val t_of_sexp : Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
  end
# Int_interval.sexp_of_t (Int_interval.create 3 4);; 
- : Sexp.t = (Interval 3 4)
# Int_interval.sexp_of_t (Int_interval.create 4 3);; 
- : Sexp.t = Empty
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="extending-modules">
    <title>Extending modules</title>
    <para>
      Another common use of functors is to generate type-specific
      functionality for a given module in a standardized way. Let's see
      how this works in the context of a functional queue, which is just
      a functional version of a FIFO (first-in, first-out) queue. Being
      functional, operations on the queue return new queues, rather than
      modifying the queues that were passed in.
    </para>
    <para>
      Here's a reasonable <literal>mli</literal> for such a module.
    </para>
    <programlisting language="ocaml">
(* functors/fqueue.mli  *)
type 'a t

val empty : 'a t

(** [enqueue el q] adds [el] to the back of [q] *)
val enqueue : 'a t -&gt; 'a -&gt; 'a t

(** [dequeue q] returns None if the [q] is empty, otherwise returns
    the first element of the queue and the remainder of the queue *)
val dequeue : 'a t -&gt; ('a * 'a t) option

(** Folds over the queue, from front to back *)
val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc
</programlisting>
    <para>
      The <literal>Fqueue.fold</literal> function above requires some
      explanation. It follows the same pattern as the
      <literal>List.fold</literal> function we described in
      <xref linkend="using-the-list-module-effectively"/>.
      Essentially, <literal>Fqueue.fold q ~init ~f</literal> walks over
      the elements of <literal>q</literal> from front to back, starting
      with an accumulator of <literal>init</literal> and using
      <literal>f</literal> to update the accumulator value as it walks
      over the queue, returning the final value of the accumulator at
      the end of the computation. Fold is a quite powerful operation, as
      we'll see.
    </para>
    <para>
      Now let's implement <literal>Fqueue</literal>. A standard trick is
      for the <literal>Fqueue</literal> to maintain an input and an
      output list, so that one can efficiently
      <literal>enqueue</literal> on the input list and efficiently
      dequeue from the output list. If you attempt to dequeue when the
      output list is empty, the input list is reversed and becomes the
      new output list. Here's an implementation that uses that trick.
    </para>
    <programlisting language="ocaml">
(* functors/fqueue.ml  *)
open Core.Std

type 'a t = 'a list * 'a list

let empty = ([],[])

let enqueue (in_list, out_list) x =
  (x :: in_list,out_list)

let dequeue (in_list, out_list) =
  match out_list with
  | hd :: tl -&gt; Some (hd, (in_list, tl))
  | [] -&gt;
    match List.rev in_list with
    | [] -&gt; None
    | hd :: tl -&gt; Some (hd, ([], tl))

let fold (in_list, out_list) ~init ~f =
  let after_out = List.fold ~init ~f out_list in
  List.fold_right ~init:after_out ~f:(fun x acc -&gt; f acc x) in_list
</programlisting>
    <para>
      One problem with <literal>Fqueue</literal> is that the interface
      is quite skeletal. There are lots of useful helper functions that
      one might want that aren't there. The list module, by way of
      contrast, has functions like <literal>List.iter</literal>, which
      runs a function on each element; and
      <literal>List.for_all</literal>, which returns true if and only if
      the given predicate evaluates to <literal>true</literal> on every
      element of the list. Such helper functions come up for pretty much
      every container type, and implementing them over and over is a
      dull and repetitive affair.
    </para>
    <para>
      As it happens, many of these helper functions can be derived
      mechanically from just the fold function we already implemented.
      Rather than write all of these helper functions by hand for every
      new container type, we can instead use a functor that will let us
      add this functionality to any container that has a
      <literal>fold</literal> function.
    </para>
    <para>
      We'll create a new module, <literal>Foldable</literal> that
      automates the process of adding helper functions to a
      fold-supporting container. As you can see,
      <literal>Foldable</literal> contains a module signature
      <literal>S</literal> which defines the signature that is required
      to support folding; and a functor <literal>Extend</literal> that
      allows one to extend any module that matches
      <literal>Foldable.S</literal>.
    </para>
    <programlisting language="ocaml">
(* functors/foldable.ml  *)
open Core.Std

module type S = sig
  type 'a t
  val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc
end

module type Extension = sig
  type 'a t
  val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
  val length  : 'a t -&gt; int
  val count   : 'a t -&gt; f:('a -&gt; bool) -&gt; int
  val for_all : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
  val exists  : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
end

(* For extending a Foldable module *)
module Extend(Arg : S)
  : (Extension with type 'a t := 'a Arg.t) =
struct
  open Arg

  let iter t ~f =
    fold t ~init:() ~f:(fun () a -&gt; f a)

  let length t =
    fold t ~init:0  ~f:(fun acc _ -&gt; acc + 1)

  let count t ~f =
    fold t ~init:0  ~f:(fun count x -&gt; count + if f x then 1 else 0)

  exception Short_circuit

  let for_all c ~f =
    try iter c ~f:(fun x -&gt; if not (f x) then raise Short_circuit); true
    with Short_circuit -&gt; false

  let exists c ~f =
    try iter c ~f:(fun x -&gt; if f x then raise Short_circuit); false
    with Short_circuit -&gt; true
end
</programlisting>
    <para>
      Now we can apply this to <literal>Fqueue</literal>. We can rewrite
      the interface of <literal>Fqueue</literal> as follows.
    </para>
    <programlisting language="ocaml">
(* functors/extended_fqueue.mli  *)
type 'a t
include (module type of Fqueue) with type 'a t := 'a t
include Foldable.Extension with type 'a t := 'a t
</programlisting>
    <para>
      In order to apply the functor, we'll put the definition of
      <literal>Fqueue</literal> in a sub-module called
      <literal>T</literal>, and then call
      <literal>Foldable.Extend</literal> on <literal>T</literal>.
    </para>
    <programlisting language="ocaml">
(* functors/extended_fqueue.ml  *)
include Fqueue
include Foldable.Extend(Fqueue)
</programlisting>
    <para>
      Core comes with a number of functors for extending modules that
      follow this same basic pattern, including:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>Container.Make</literal>, which is very similar to
          <literal>Foldable.Extend</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>Comparable.Make</literal>, which adds a variety of
          helper functions and types for types that have a comparison
          function.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>Hashable.Make</literal> for adding hash-based data
          structures like hash sets and hash heaps for types that have
          hash functions.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>Monad.Make</literal> for so-called monadic libraries,
          like the ones discussed in
          <xref linkend="error-handling"/> and
          <xref linkend="concurrent-programming-with-async"/>.
          Here, the functor is used to provide a collection of standard
          helper functions based on the <literal>bind</literal> and
          <literal>return</literal> operators.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      These functors come in handy when you want to add the same kind of
      functionality that is commonly available in Core to your own
      types.
    </para>
  </sect1>
</chapter><chapter id="first-class-modules">
  <title>First-Class Modules</title>
  <para>
    You can think of OCaml as being broken up into two parts: a core
    language that is concerned with values and types, and a module
    language that is concerned with modules and module signatures. These
    sub-languages are stratified, in that modules can contain types and
    values, but ordinary values can't contain modules or module types.
    That means you can't do things like define a variable whose value is
    a module, or a function that takes a module as an argument.
  </para>
  <para>
    OCaml provides a way around this stratification in the form of
    <emphasis>first-class modules</emphasis>. First-class modules are
    ordinary values that can be created from and converted back to
    regular modules.
  </para>
  <para>
    First-class modules are a sophisticated technique, and you'll need
    to get comfortable with some advanced aspects of the language to use
    them effectively. But it's worth learning, because letting modules
    into the core language is quite powerful, increasing the range of
    what you can express and making it easier to build flexible and
    modular systems.
  </para>
  <sect1 id="working-with-first-class-modules">
    <title>Working with first-class modules</title>
    <para>
      We'll start out by covering the basic mechanics of first-class
      modules by working through some toy examples. We'll get to more
      realistic examples in the next section.
    </para>
    <para>
      In that light, consider the following signature of a module with a
      single integer variable.
    </para>
    <programlisting language="ocaml">
# script fcm/main.topscript
$ utop
# module type X_int = sig val x : int end;; 
module type X_int = sig val x : int end
</programlisting>
    <para>
      We can also create a module that matches this signature.
    </para>
    <programlisting language="ocaml">
...part 1 of fcm/main.topscript
# module Three : X_int = struct let x = 3 end;; 
module Three : X_int
# Three.x;; 
- : int = 3
</programlisting>
    <para>
      A first-class module is created by packaging up a module with a
      signature that it satisfies. This is done using the
      <literal>module</literal> keyword, using the following syntax:
    </para>
    <programlisting language="html">
(module &lt;Module&gt; : &lt;Module_type&gt;)
</programlisting>
    <para>
      So, we can convert <literal>Three</literal> into a first-class
      module as follows.
    </para>
    <programlisting language="ocaml">
...part 2 of fcm/main.topscript
# let three = (module Three : X_int);; 
val three : (module X_int) = &lt;module&gt;
</programlisting>
    <para>
      The module type doesn't need to be part of the construction of a
      first-class module if it can be inferred. Thus, we can write:
    </para>
    <programlisting language="ocaml">
...part 3 of fcm/main.topscript
# module Four = struct let x = 4 end;; 
module Four : sig val x : int end
# let numbers = [ three; (module Four) ];; 
val numbers : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]
</programlisting>
    <para>
      We can also create a first-class module from an anonymous module:
    </para>
    <programlisting language="ocaml">
...part 4 of fcm/main.topscript
# let numbers = [three; (module struct let x = 4 end)];; 
val numbers : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]
</programlisting>
    <para>
      In order to access the contents of a first-class module, you need
      to unpack it into an ordinary module. This can be done using the
      <literal>val</literal> keyword, using this syntax:
    </para>
    <programlisting language="html">
(val &lt;first_class_module&gt; : &lt;Module_type&gt;)
</programlisting>
    <para>
      And here's an example.
    </para>
    <programlisting language="ocaml">
...part 5 of fcm/main.topscript
# module New_three = (val three : X_int) ;; 
module New_three : X_int
# New_three.x;; 
- : int = 3
</programlisting>
    <note> <title> 
    Equality of first-class module types
    </title>
    <para>
      The type of the first-class module, <emphasis>e.g.</emphasis>,
      <literal>(module X_int)</literal>, is based on the fully-qualified
      name of the signature that was used to construct it. A first-class
      module based on a signature with a different name, even if it is
      substantively the same signature, will result in a distinct type,
      as you can see below.
    </para>
    <programlisting language="ocaml">
...part 6 of fcm/main.topscript
# module type Y_int = X_int;; 
module type Y_int = X_int
# let five = (module struct let x = 5 end : Y_int);; 
val five : (module Y_int) = &lt;module&gt;
# [three; five];; 
Characters 8-12:
Error: This expression has type (module Y_int)
       but an expression was expected of type (module X_int)
</programlisting>
    <para>
      Even though their types as first-class modules are distinct, the
      underlying module types are compatible (indeed, identical), so we
      can unify the types by unpacking and repacking the module.
    </para>
    <programlisting language="ocaml">
...part 7 of fcm/main.topscript
# [three; (module (val five))];; 
- : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]
</programlisting>
    <para>
      The way in which type equality for first-class modules is
      determined can be confusing. One common and problematic case is
      that of creating an alias of a module type defined elsewhere. This
      is often done to improve readability, and can happen both through
      an explicit declaration of a module type or implicitly through an
      <literal>include</literal> declaration. In both cases, this has
      the unintended side effect of making first-class modules built off
      of the alias incompatible with those built off of the original
      module type. To deal with this, one should be disciplined in how
      one refers to signatures when constructing first-class modules.
    </para>
    </note>
    <para>
      We can also write ordinary functions which consume and create
      first class modules. The following shows the definition of two
      functions: <literal>to_int</literal>, which converts a
      <literal>(module X_int)</literal> into an <literal>int</literal>;
      and <literal>plus</literal>, which returns the sum of two
      <literal>(module X_int)</literal>s.
    </para>
    <programlisting language="ocaml">
...part 8 of fcm/main.topscript
# let to_int m =
    let module M = (val m : X_int) in
    M.x
  ;; 
val to_int : (module X_int) -&gt; int = &lt;fun&gt;
# let plus m1 m2 =
    (module struct
       let x = to_int m1 + to_int m2
     end : X_int)
  ;; 
val plus : (module X_int) -&gt; (module X_int) -&gt; (module X_int) = &lt;fun&gt;
</programlisting>
    <para>
      With these functions in hand, we can now work with values of type
      <literal>(module X_int)</literal> in a more natural style, taking
      advantage of the concision and simplicity of the core language.
    </para>
    <programlisting language="ocaml">
...part 9 of fcm/main.topscript
# let six = plus three three;; 
val six : (module X_int) = &lt;module&gt;
# to_int (List.fold ~init:six ~f:plus [three;three]);; 
- : int = 12
</programlisting>
    <para>
      There are some useful syntactic shortcuts when dealing with first
      class modules. One notable one is that you can do the conversion
      to an ordinary module within a pattern match. Thus, we can rewrite
      the <literal>to_int</literal> function as follows.
    </para>
    <programlisting language="ocaml">
...part 10 of fcm/main.topscript
# let to_int (module M : X_int) = M.x ;; 
val to_int : (module X_int) -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      First-class modules can contain types and functions in addition to
      simple values like <literal>int</literal>. Here's an interface
      that contains a type and a corresponding <literal>bump</literal>
      operation that takes a value of the type and produces a new one.
    </para>
    <programlisting language="ocaml">
...part 11 of fcm/main.topscript
# module type Bumpable = sig
    type t
    val bump : t -&gt; t
  end;; 
module type Bumpable = sig type t val bump : t -&gt; t end
</programlisting>
    <para>
      We can create multiple instances of this module with different
      undelrying types.
    </para>
    <programlisting language="ocaml">
...part 12 of fcm/main.topscript
# module Int_bumper = struct
    type t = int
    let bump n = n + 1
  end;; 
module Int_bumper : sig type t = int val bump : t -&gt; t end
# module Float_bumper = struct
     type t = float
     let bump n = n +. 1.
  end;; 
module Float_bumper : sig type t = float val bump : t -&gt; t end
</programlisting>
    <para>
      And we can convert these to first-class modules.
    </para>
    <programlisting language="ocaml">
...part 13 of fcm/main.topscript
# let int_bumper = (module Int_bumper : Bumpable);; 
val int_bumper : (module Bumpable) = &lt;module&gt;
</programlisting>
    <para>
      But you can't do much with <literal>int_bumper</literal>, since
      <literal>int_bumper</literal> is fully abstract, so that we can no
      longer recover the fact that the type in question is
      <literal>int</literal>. This means you can't really do much with
      it, as you can see below.
    </para>
    <programlisting language="ocaml">
...part 14 of fcm/main.topscript
# let (module Bumpable) = int_bumper in Bumpable.bump 3;; 
Characters 52-53:
Error: This expression has type int but an expression was expected of type
         Bumpable.t
</programlisting>
    <para>
      To make <literal>int_bumber</literal> usable, we need to expose
      the type, which we can do as follows.
    </para>
    <programlisting language="ocaml">
...part 15 of fcm/main.topscript
# let int_bumper = (module Int_bumper : Bumpable with type t = int);; 
val int_bumper : (module Bumpable with type t = int) = &lt;module&gt;
# let float_bumper = (module Float_bumper : Bumpable with type t = float);; 
val float_bumper : (module Bumpable with type t = float) = &lt;module&gt;
</programlisting>
    <para>
      The sharing constraints we've added above make the resulting
      first-class modules polymorphic in the type <literal>t</literal>.
      As a result, we can now use these values on values of the matching
      type.
    </para>
    <programlisting language="ocaml">
...part 16 of fcm/main.topscript
# let (module Bumpable) = int_bumper in Bumpable.bump 3;; 
- : int = 4
# let (module Bumpable) = float_bumper in Bumpable.bump 3.5;; 
- : float = 4.5
</programlisting>
    <para>
      We can also write functions that use such first-class modules
      polymorphically. The following function takes two arguments: a
      <literal>Bumpable</literal> module, and a list of elements of the
      same type as the type <literal>t</literal> of the module.
    </para>
    <programlisting language="ocaml">
...part 17 of fcm/main.topscript
# let bump_list
       (type a)
       (module B : Bumpable with type t = a)
       (l: a list)
    =
    List.map ~f:B.bump l
  ;; 
val bump_list : (module Bumpable with type t = 'a) -&gt; 'a list -&gt; 'a list =
  &lt;fun&gt;
</programlisting>
    <para>
      Here, we used a feature of OCaml that hasn't come up before: a
      <emphasis>locally abstract type</emphasis>. For any function, you
      can declare a pseudo-parameter of the form
      <literal>(type a)</literal> for any type name <literal>a</literal>
      which introduces a fresh type that acts like an abstract type
      within the context of the function. Here, we used that type as
      part of a sharing constraint that ties the type
      <literal>B.t</literal> with the type of the elements of the list
      passed in.
    </para>
    <para>
      The resulting function is polymorphic in both the type of the list
      element and the type <literal>Bumpable.t</literal>. We can see
      this function in action below.
    </para>
    <programlisting language="ocaml">
...part 18 of fcm/main.topscript
# bump_list int_bumper [1;2;3];; 
- : int list = [2; 3; 4]
# bump_list float_bumper [1.5;2.5;3.5];; 
- : float list = [2.5; 3.5; 4.5]
</programlisting>
    <para>
      Polymorphic first-class modules are important because they allow
      you to connect the types associated with a first-class module to
      the types of other values you're working with.
    </para>
    <note><title> 
    More on locally abstract types
    </title>
    <para>
      One of the key properties of locally abstract types is that
      they're dealt with as abstract types in the function they're
      defined within, but are polymorphic from the outside. Consider the
      following example.
    </para>
    <programlisting language="ocaml">
...part 19 of fcm/main.topscript
# let wrap_in_list (type a) (x:a) = [x];; 
val wrap_in_list : 'a -&gt; 'a list = &lt;fun&gt;
</programlisting>
    <para>
      This compiles successfully because the type <literal>a</literal>
      is used in a way that is compatible with it being abstract, but
      the type of the function that is inferred is polymorphic.
    </para>
    <para>
      If, on the other hand, we try to use the type <literal>a</literal>
      as equivalent to some concrete type, say, <literal>int</literal>,
      then the compiler will complain.
    </para>
    <programlisting language="ocaml">
...part 20 of fcm/main.topscript
# let wrap_int_in_list (type a) (x:a) = x + x;; 
Characters 38-39:
Error: This expression has type a but an expression was expected of type int
</programlisting>
    <para>
      One common use of locally abstract types is to create a new type
      that can be used in constructing a module. Here's an example of
      doing this to create a new first-class module.
    </para>
    <programlisting language="ocaml">
...part 21 of fcm/main.topscript
# module type Comparable = sig
    type t
    val compare : t -&gt; t -&gt; int
  end ;; 
module type Comparable = sig type t val compare : t -&gt; t -&gt; int end
# let create_comparable (type a) compare =
    (module struct
       type t = a
       let compare = compare
     end : Comparable with type t = a)
  ;; 
val create_comparable :
  ('a -&gt; 'a -&gt; int) -&gt; (module Comparable with type t = 'a) = &lt;fun&gt;
# create_comparable Int.compare;; 
- : (module Comparable with type t = int) = &lt;module&gt;
# create_comparable Float.compare;; 
- : (module Comparable with type t = float) = &lt;module&gt;
</programlisting>
    <para>
      Here, what we effectively do is capture a polymorphic type and
      export it as a concrete type within a module.
    </para>
    <para>
      This technique is useful beyond first-class modules. For example,
      we can use the same approach to construct a local module to be fed
      to a functor.
    </para>
    </note>
  </sect1>
  <sect1 id="example-a-query-handling-framework">
    <title>Example: A query handling framework</title>
    <para>
      Now let's look at first-class modules in the context of a more
      complete and realistic example. In particular, consider the
      following signature for a module that implements a query handler.
    </para>
    <programlisting language="ocaml">
# script fcm/query_handler.topscript
$ utop
# module type Query_handler = sig

    (** Configuration for a query handler.  Note that this can be
        converted to and from an s-expression *)
    type config with sexp

    (** The name of the query-handling service *)
    val name : string

    (** The state o fthe query handler *)
    type t

    (** Create a new query handler from a config *)
    val create : config -&gt; t

    (** Evaluate a given query, where both input and output are
        s-expressions *)
    val eval : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t
  end;; 
module type Query_handler =
  sig
    type config
    val name : string
    type t
    val create : config -&gt; t
    val eval : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t
    val config_of_sexp : Sexp.t -&gt; config
    val sexp_of_config : config -&gt; Sexp.t
  end
</programlisting>
    <para>
      In the above we use s-expressions as the format for queries and
      responses, as well for the config. S-expressions are a simple,
      flexible, and human-readable serialization format commonly used in
      Core. We'll cover s-expressions in more detail in
      <xref linkend="data-serialization-with-s-expressions"/>,
      but for now, it's enough to think of them as balanced
      parenthetical expressions whose atomic values are strings,
      <emphasis>e.g.</emphasis>,
      <literal>(this (is an) (s expression))</literal>.
    </para>
    <para>
      In addition, we use the <literal>sexplib</literal> syntax
      extension which extends OCaml by adding the
      <literal>with sexp</literal> declaration. When attached to a type
      in a signature, <literal>with sexp</literal> adds declarations of
      s-expression converters, <emphasis>e.g.</emphasis>,
    </para>
    <programlisting language="ocaml">
...part 1 of fcm/query_handler.topscript
# module type M = sig type t with sexp end;; 
module type M =
  sig type t val t_of_sexp : Sexp.t -&gt; t val sexp_of_t : t -&gt; Sexp.t end
</programlisting>
    <para>
      In a module, <literal>with sexp</literal> adds the implementation
      of those functions. Thus, we can write
    </para>
    <programlisting language="ocaml">
...part 2 of fcm/query_handler.topscript
# type u = { a: int; b: float } with sexp;; 
type u = { a : int; b : float; }
val u_of_sexp : Sexp.t -&gt; u = &lt;fun&gt;
val sexp_of_u : u -&gt; Sexp.t = &lt;fun&gt;
# sexp_of_u {a=3;b=7.};; 
- : Sexp.t = ((a 3) (b 7))
# u_of_sexp (Sexp.of_string &quot;((a 43) (b 3.4))&quot;);; 
- : u = {a = 43; b = 3.4}
</programlisting>
    <para>
      This is all described in more detail in
      <xref linkend="data-serialization-with-s-expressions"/>.
    </para>
    <sect2 id="implementing-a-query-handler">
      <title>Implementing a query handler</title>
      <para>
        Let's look at some examples of query handlers that satisfy this
        interface. The following handler produces unique integer ids by
        keeping an internal counter which it bumps every time it
        produces a new value. The input to the query in this case is
        just the trivial s-expression <literal>()</literal>, otherwise
        known as <literal>Sexp.unit</literal>.
      </para>
      <programlisting language="ocaml">
...part 3 of fcm/query_handler.topscript
# module Unique = struct
    type config = int with sexp
    type t = { mutable next_id: int }

    let name = &quot;unique&quot;
    let create start_at = { next_id = start_at }

    let eval t sexp =
      match Or_error.try_with (fun () -&gt; unit_of_sexp sexp) with
      | Error _ as err -&gt; err
      | Ok () -&gt;
        let response = Ok (Int.sexp_of_t t.next_id) in
        t.next_id &lt;- t.next_id + 1;
        response
  end;; 
module Unique :
  sig
    type config = int
    val config_of_sexp : Sexp.t -&gt; config
    val sexp_of_config : config -&gt; Sexp.t
    type t = { mutable next_id : config; }
    val name : string
    val create : config -&gt; t
    val eval : t -&gt; Sexp.t -&gt; (Sexp.t, Error.t) Result.t
  end
</programlisting>
      <para>
        We can use this module to create an instance of the
        <literal>Unique</literal> query handler and interact with it.
      </para>
      <programlisting language="ocaml">
...part 4 of fcm/query_handler.topscript
# let unique = Unique.create 0;; 
val unique : Unique.t = {Unique.next_id = 0}
# Unique.eval unique Sexp.unit;; 
- : (Sexp.t, Error.t) Result.t = Ok 0
# Unique.eval unique Sexp.unit;; 
- : (Sexp.t, Error.t) Result.t = Ok 1
</programlisting>
      <para>
        Here's another example: a query handler that does directory
        listings. Here, the config is the default directory that
        relative paths are interpreted within.
      </para>
      <programlisting language="ocaml">
...part 5 of fcm/query_handler.topscript
# module List_dir = struct
    type config = string with sexp
    type t = { cwd: string }

    (** [is_abs p] Returns true if [p] is an absolute path  *)
    let is_abs p =
      String.length p &gt; 0 &amp;&amp; p.[0] = '/'

    let name = &quot;ls&quot;
    let create cwd = { cwd }

    let eval t sexp =
      match Or_error.try_with (fun () -&gt; string_of_sexp sexp) with
      | Error _ as err -&gt; err
      | Ok dir -&gt;
        let dir =
          if is_abs dir then dir
          else Filename.concat t.cwd dir
        in
        Ok (Array.sexp_of_t String.sexp_of_t (Sys.readdir dir))
  end;; 
module List_dir :
  sig
    type config = string
    val config_of_sexp : Sexp.t -&gt; config
    val sexp_of_config : config -&gt; Sexp.t
    type t = { cwd : config; }
    val is_abs : config -&gt; bool
    val name : config
    val create : config -&gt; t
    val eval : t -&gt; Sexp.t -&gt; (Sexp.t, Error.t) Result.t
  end
</programlisting>
      <para>
        Again, we can create an instance of this query handler and
        interact with it directly.
      </para>
      <programlisting language="ocaml">
...part 6 of fcm/query_handler.topscript
# let list_dir = List_dir.create &quot;/var&quot;;; 
val list_dir : List_dir.t = {List_dir.cwd = &quot;/var&quot;}
# List_dir.eval list_dir (sexp_of_string &quot;.&quot;);; 
- : (Sexp.t, Error.t) Result.t =
Ok (lib mail cache www spool run log lock opt local backups tmp)
# List_dir.eval list_dir (sexp_of_string &quot;yp&quot;);; 
Exception: (Sys_error &quot;/var/yp: No such file or directory&quot;).
</programlisting>
    </sect2>
    <sect2 id="dispatching-to-multiple-query-handlers">
      <title>Dispatching to multiple query handlers</title>
      <para>
        Now, what if we want to dispatch queries to any of an arbitrary
        collection of handlers? Ideally, we'd just like to pass in the
        handlers as a simple data structure like a list. This is awkward
        to do with modules and functors alone, but it's quite natural
        with first-class modules. The first thing we'll need to do is
        create a signature that combines a
        <literal>Query_handler</literal> module with an instantiated
        query handler.
      </para>
      <programlisting language="ocaml">
...part 7 of fcm/query_handler.topscript
# module type Query_handler_instance = sig
    module Query_handler : Query_handler
    val this : Query_handler.t
  end;; 
module type Query_handler_instance =
  sig module Query_handler : Query_handler val this : Query_handler.t end
</programlisting>
      <para>
        With this signature, we can create a first-class module that
        encompasses both an instance of the query and the matching
        operations for working with that query.
      </para>
      <para>
        We can create an instance as follows.
      </para>
      <programlisting language="ocaml">
...part 8 of fcm/query_handler.topscript
# let unique_instance =
    (module struct
       module Query_handler = Unique
       let this = Unique.create 0
     end : Query_handler_instance);; 
val unique_instance : (module Query_handler_instance) = &lt;module&gt;
</programlisting>
      <para>
        Constructing instances in this way is a little verbose, but we
        can write a function that eliminates most of this boilerplate.
        Note that we are again making use of a locally abstract type.
      </para>
      <programlisting language="ocaml">
...part 9 of fcm/query_handler.topscript
# let build_instance
        (type a)
        (module Q : Query_handler with type config = a)
        config
    =
    (module struct
       module Query_handler = Q
       let this = Q.create config
     end : Query_handler_instance)
  ;; 
val build_instance :
  (module Query_handler with type config = 'a) -&gt;
  'a -&gt; (module Query_handler_instance) = &lt;fun&gt;
</programlisting>
      <para>
        Using <literal>build_instance</literal>, constructing a new
        instance becomes a one-liner:
      </para>
      <programlisting language="ocaml">
...part 10 of fcm/query_handler.topscript
# let unique_instance = build_instance (module Unique) 0;; 
val unique_instance : (module Query_handler_instance) = &lt;module&gt;
# let list_dir_instance = build_instance (module List_dir)  &quot;/var&quot;;; 
val list_dir_instance : (module Query_handler_instance) = &lt;module&gt;
</programlisting>
      <para>
        The following code lets you dispatch queries to one of a list of
        query handler instances. We assume that the shape of the query
        is as follows:
      </para>
      <programlisting language="scheme">
;; fcm/query-syntax.scm.scm
(query-name query)
</programlisting>
      <para>
        where <literal>query-name</literal> is the name used to
        determine which query handler to dispatch the query to, and
        <literal>query</literal> is the body of the query.
      </para>
      <para>
        The first thing we'll need is a function that takes a list of
        query handler instances and constructs a dispatch table from it.
      </para>
      <programlisting language="ocaml">
...part 11 of fcm/query_handler.topscript
# let build_dispatch_table handlers =
    let table = String.Table.create () in
    List.iter handlers
      ~f:(fun ((module I : Query_handler_instance) as instance) -&gt;
        Hashtbl.replace table ~key:I.Query_handler.name ~data:instance);
    table
  ;; 
val build_dispatch_table :
  (module Query_handler_instance) list -&gt;
  (module Query_handler_instance) String.Table.t = &lt;fun&gt;
</programlisting>
      <para>
        Now, we need a function that dispatches to a handler using a
        dispatch table.
      </para>
      <programlisting language="ocaml">
...part 12 of fcm/query_handler.topscript
# let dispatch dispatch_table name_and_query =
    match name_and_query with
    | Sexp.List [Sexp.Atom name; query] -&gt;
      begin match Hashtbl.find dispatch_table name with
      | None -&gt;
        Or_error.error &quot;Could not find matching handler&quot;
          name String.sexp_of_t
      | Some (module I : Query_handler_instance) -&gt;
        I.Query_handler.eval I.this query
      end
    | _ -&gt;
      Or_error.error_string &quot;malformed query&quot;
  ;; 
val dispatch :
  (string, (module Query_handler_instance)) Hashtbl.t -&gt;
  Sexp.t -&gt; Sexp.t Or_error.t = &lt;fun&gt;
</programlisting>
      <para>
        This function interacts with an instance by unpacking it into a
        module <literal>I</literal> and then using the query handler
        instance (<literal>I.this</literal>) in concert with the
        associated module (<literal>I.Query_handler</literal>).
      </para>
      <para>
        The bundling together of the module and the value is in many
        ways reminiscent of object-oriented languages. One key
        difference, is that first-class modules allow you to package up
        more than just a functions or methods. As we've seen, you can
        also include types and even modules. We've only used it in a
        small way here, but this extra power allows you to build more
        sophisticated components that involve multiple interdependent
        types and values.
      </para>
      <para>
        Now let's turn this into a complete, running example, by adding
        a command-line interface, as shown below.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler.topscript (starting from part 13) *)
# let rec cli dispatch_table =
    printf &quot;&gt;&gt;&gt; %!&quot;;
    let result =
      match In_channel.input_line stdin with
      | None -&gt; `Stop
      | Some line -&gt;
        match Or_error.try_with (fun () -&gt; Sexp.of_string line) with
        | Error e -&gt; `Continue (Error.to_string_hum e)
        | Ok (Sexp.Atom &quot;quit&quot;) -&gt; `Stop
        | Ok query -&gt;
          begin match dispatch dispatch_table query with
          | Error e -&gt; `Continue (Error.to_string_hum e)
          | Ok s    -&gt; `Continue (Sexp.to_string_hum s)
          end;
    in
    match result with
    | `Stop -&gt; ()
    | `Continue msg -&gt;
      printf &quot;%s\n%!&quot; msg;
      cli dispatch_table
  ;; 
val cli : (string, (module Query_handler_instance)) Hashtbl.t -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        We can most effectively run this command-line interface from a
        standalone program, which we can do by putting the above code in
        a file along with following command to launch the interface.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler.ml (starting from part 1) *)
let () =
  cli (build_dispatch_table [unique_instance; list_dir_instance])
</programlisting>
      <para>
        Here's an example of a session with this program.
      </para>
      <programlisting>
# running fcm/query_example.rawscript.sh
$ ./query_handler.byte 
&gt;&gt;&gt; (unique ())
0
&gt;&gt;&gt; (unique ())
1
&gt;&gt;&gt; (ls .)
(agentx at audit backups db empty folders jabberd lib log mail msgs named
 netboot pgsql_socket_alt root rpc run rwho spool tmp vm yp)
&gt;&gt;&gt; (ls vm)
(sleepimage swapfile0 swapfile1 swapfile2 swapfile3 swapfile4 swapfile5
 swapfile6)
</programlisting>
    </sect2>
    <sect2 id="loading-and-unloading-query-handlers">
      <title>Loading and unloading query handlers</title>
      <para>
        One of the advantages of first-class modules is that they afford
        a great deal of dynamism and flexibility. For example, it's a
        fairly simple matter to change our design to allow query
        handlers to be loaded and unloaded at runtime.
      </para>
      <para>
        We'll do this by creating a query handler whose job is to
        control the set of active query handlers. The module in question
        will be called <literal>Loader</literal>, and its configuration
        is a list of known <literal>Query_handler</literal> modules.
        Here are the basic types.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler_core.ml (starting from part 1) *)
module Loader = struct
  type config = (module Query_handler) list sexp_opaque
  with sexp

  type t = { known  : (module Query_handler)          String.Table.t
           ; active : (module Query_handler_instance) String.Table.t
           }

  let name = &quot;loader&quot;
</programlisting>
      <para>
        Note that a <literal>Loader.t</literal> has two hash tables: one
        containing the known query handler modules, and one containing
        the active query handler instances. The
        <literal>Loader.t</literal> will be responsible for creating new
        instances and adding them to the table, as well as for removing
        instances, all in response to user queries.
      </para>
      <para>
        Next, we'll need a function for creating a
        <literal>Loader.t</literal>. This function requires the list of
        known query handler modules. Note that the table of active
        modules starts out as empty.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler_core.ml (starting from part 2) *)
let create known_list =
    let active = String.Table.create () in
    let known  = String.Table.create () in
    List.iter known_list
      ~f:(fun ((module Q : Query_handler) as q) -&gt;
        Hashtbl.replace known ~key:Q.name ~data:q);
    { known; active }
</programlisting>
      <para>
        Now we'll start writing out the functions for manipulating the
        table of active query handlers. We'll start with the function
        for loading an instance. Note that it takes as an argument both
        the name of the query handler, and the configuration for
        instantiating that handler, in the form of an s-expression.
        These are used for creating a first-class module of type
        <literal>(module Query_handler_instance)</literal>, which is
        then added to the active table.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler_core.ml (starting from part 3) *)
let load t handler_name config =
    if Hashtbl.mem t.active handler_name then
      Or_error.error &quot;Can't re-register an active handler&quot;
        handler_name String.sexp_of_t
    else
      match Hashtbl.find t.known handler_name with
      | None -&gt;
        Or_error.error &quot;Unknown handler&quot; handler_name String.sexp_of_t
      | Some (module Q : Query_handler) -&gt;
        let instance =
          (module struct
             module Query_handler = Q
             let this = Q.create (Q.config_of_sexp config)
           end : Query_handler_instance)
        in
        Hashtbl.replace t.active ~key:handler_name ~data:instance;
        Ok Sexp.unit
</programlisting>
      <para>
        Since the <literal>load</literal> function will refuse to
        <literal>load</literal> an already active handler, we also need
        the ability to unload a handler. Note that the handler
        explicitly refuses to unload itself.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler_core.ml (starting from part 4) *)
let unload t handler_name =
    if not (Hashtbl.mem t.active handler_name) then
      Or_error.error &quot;Handler not active&quot; handler_name String.sexp_of_t
    else if handler_name = name then
      Or_error.error_string &quot;It's unwise to unload yourself&quot;
    else (
      Hashtbl.remove t.active handler_name;
      Ok Sexp.unit
    )
</programlisting>
      <para>
        Finally, we need to implement the <literal>eval</literal>
        function, which will determine the query interface presented to
        the user. We'll do this by creating a variant type, and using
        the s-expression converter generated for that type to parse the
        query from the user.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler_core.ml (starting from part 5) *)
type request =
    | Load of string * Sexp.t
    | Unload of string
    | Known_services
    | Active_services
  with sexp
</programlisting>
      <para>
        The eval function itself is fairly straight-forward, dispatching
        to the appropriate functions to respond to each type of query.
        Note that we use write
        <literal>&lt;sexp_of&lt;string list&gt;&gt;</literal> to
        autogenerate a function for converting a list of strings to an
        s-expression. This is part of the sexplib package described in
        <xref linkend="data-serialization-with-s-expressions"/>.
      </para>
      <para>
        This function ends the definition of the
        <literal>Loader</literal> module.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler_core.ml (starting from part 6) *)
let eval t sexp =
    match Or_error.try_with (fun () -&gt; request_of_sexp sexp) with
    | Error _ as err -&gt; err
    | Ok resp -&gt;
      match resp with
      | Load (name,config) -&gt; load   t name config
      | Unload name        -&gt; unload t name
      | Known_services -&gt;
        Ok (&lt;:sexp_of&lt;string list&gt;&gt; (Hashtbl.keys t.known))
      | Active_services -&gt;
        Ok (&lt;:sexp_of&lt;string list&gt;&gt; (Hashtbl.keys t.active))
end
</programlisting>
      <para>
        Finally, we can put this all together with the command line
        interface. We first create an instance of the loader query
        handler, and then add that instance to the loader's active
        table. We can then just launch the command-line interface,
        passing it the active table.
      </para>
      <programlisting language="ocaml">
(* fcm/query_handler_loader.ml (starting from part 1) *)
let () =
  let loader = Loader.create [(module Unique); (module List_dir)] in
  let loader_instance =
    (module struct
       module Query_handler = Loader
       let this = loader
     end : Query_handler_instance)
  in
  Hashtbl.replace loader.Loader.active
    ~key:Loader.name ~data:loader_instance;
  cli loader.Loader.active
</programlisting>
      <para>
        Now link this into a command line interface to experiment with
        it.
      </para>
      <programlisting>
# running fcm/build_query_handler_loader.out.sh
$ corebuild query_handler_loader.byte
</programlisting>
      <para>
        The resulting command line interface behaves much as you'd
        expect, starting out with no query handlers available, but
        giving you the ability to load and unload them. Here's an
        example of it in action. As you can see, we start out with
        <literal>loader</literal> itself as the only active handler.
      </para>
      <programlisting>
# running fcm/loader_cli1.out.sh
$ ./query_handler_loader.byte
&gt;&gt;&gt; (loader known_services)
(ls unique)
&gt;&gt;&gt; (loader active_services)
(loader)
</programlisting>
      <para>
        If we try to use one of the inactive queries, it will fail.
      </para>
      <programlisting>
# running fcm/loader_cli2.out.sh
&gt;&gt;&gt; (ls .)
Could not find matching handler: ls
</programlisting>
      <para>
        But, we can load the <literal>ls</literal> handler with a config
        of our choice, at which point, it will be available for use. And
        once we unload it, it will be unavailable yet again, and could
        be reloaded with a different config.
      </para>
      <programlisting>
# running fcm/loader_cli3.out.sh
&gt;&gt;&gt; (loader (load ls /var))
()
&gt;&gt;&gt; (ls /var)
(agentx at audit backups db empty folders jabberd lib log mail msgs named
 netboot pgsql_socket_alt root rpc run rwho spool tmp vm yp)
&gt;&gt;&gt; (loader (unload ls))
()
&gt;&gt;&gt; (ls /var)
Could not find matching handler: ls
</programlisting>
      <para>
        Notably, the loader can't be itself loaded (since it's not on
        the list of known handlers), and can't be unloaded.
      </para>
      <programlisting>
# running fcm/loader_cli4.out.sh
&gt;&gt;&gt; (loader (unload loader))
It's unwise to unload yourself
</programlisting>
      <para>
        We can push this dynamism yet further using libraries like
        <literal>ocaml_plugin</literal>, which use OCaml's dynamic
        linking facilities to allow a program to compile and load an
        OCaml source file as a first-class module. Thus, one could
        extend <literal>Loader</literal> to loads entirely new query
        handlers from disk on demand.
      </para>
    </sect2>
  </sect1>
  <sect1 id="living-without-first-class-modules">
    <title>Living without first-class modules</title>
    <para>
      It's worth noting that most designs that can be done with
      first-class modules can be simulated without them, with some level
      of awkwardness. For example, we could rewrite our query handler
      example without first-class modules using the following types:
    </para>
    <programlisting language="ocaml">
...part 14 of fcm/query_handler.topscript
# type query_handler_instance = { name : string
                                ; eval : Sexp.t -&gt; Sexp.t Or_error.t
                                }
  type query_handler = Sexp.t -&gt; query_handler_instance
  ;; 
type query_handler_instance = {
  name : string;
  eval : Sexp.t -&gt; Sexp.t Or_error.t;
}
type query_handler = Sexp.t -&gt; query_handler_instance
</programlisting>
    <para>
      The idea here is that we hide the true types of the objects in
      question behind the functions stored in the closure. Thus, we
      could put the <literal>Unique</literal> query handler into this
      framework as follows.
    </para>
    <programlisting language="ocaml">
...part 15 of fcm/query_handler.topscript
# let unique_handler config_sexp =
    let config = Unique.config_of_sexp config_sexp in
    let unique = Unique.create config in
    { name = Unique.name
    ; eval = (fun config -&gt; Unique.eval unique config)
    }
  ;; 
val unique_handler : Sexp.t -&gt; query_handler_instance = &lt;fun&gt;
</programlisting>
    <para>
      For an example on this scale, the above approach is completely
      reasonable, and first-class modules are not really necessary. But
      the more functionality you need to hide away behind a set of
      closures, and the more complicated the relationships between the
      different types in question, the more awkward this approach
      becomes, and the better it is to use first-class modules.
    </para>
  </sect1>
</chapter><chapter id="objects">
  <title>Objects</title>
  <para>
    We've already seen several tools that OCaml provides for organizing
    programs, particularly modules. In addition, OCaml also supports
    object-oriented programming. There are objects, classes, and their
    associated types. In this chapter, we'll introduce you to OCaml
    objects and subtyping. In the next chapter
    <xref linkend="classes"/>, we'll introduce you to classes
    and inheritance.
  </para>
  <note>
  <title>
  What is Object-Oriented Programming?
  </title>
  <para>
    Object-oriented programming (often shorted to OOP) is a programming
    style that encapsulates computation and data within logical
    <emphasis>objects</emphasis>. Each object contains some data stored
    in <emphasis>fields</emphasis>, and has <emphasis>method</emphasis>
    functions that can be invoked against the data within the object
    (also called &quot;sending a message&quot; to the object). The code
    definition behind an object is called a <emphasis>class</emphasis>,
    and objects are constructed from a class definition by calling a
    constructor with the data that the object will use to build itself.
  </para>
  <para>
    There are five fundamental properties that differentiate OOP from
    other styles:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis>Abstraction</emphasis>: the details of the
        implementation are hidden in the object, and the external
        interface is just the set of publicly-accessible methods.
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis>Dynamic lookup</emphasis>: when a message is sent to
        an object, the method to be executed is determined by the
        implementation of the object, not by some static property of the
        program. In other words, different objects may react to the same
        message in different ways.
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis>Subtyping</emphasis>: if an object
        <literal>a</literal> has all the functionality of an object
        <literal>b</literal>, then we may use <literal>a</literal> in
        any context where <literal>b</literal> is expected.
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis>Inheritance</emphasis>: the definition of one kind of
        object can be reused to produce a new kind of object. This new
        definition can override some behavior, but also share code with
        its parent.
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis>Open recursion</emphasis>: an object's methods can
        invoke another method in the same object using a special
        variable (often called <literal>self</literal> or
        <literal>this</literal>). When objects are created from classes,
        these calls use dynamic lookup, allowing a method defined in one
        class to invoke methods defined in another class that inherits
        from the first.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    Almost every notable modern programming language has been influenced
    by OOP, and you'll have run across these terms if you've ever used
    C++, Java, C#, Ruby, Python or JavaScript.
  </para>
  </note>
  <sect1 id="ocaml-objects">
    <title>OCaml objects</title>
    <para>
      If you already know about object oriented programming in a
      language like Java or C++, the OCaml object system may come as a
      surprise. Foremost is the complete separation of objects, and
      their types, from the class system in OCaml. In a language like
      Java, a class name is also used as the type of objects created by
      instantiating it, and the relationships between these object types
      correspond to inheritance. For example, if we implement a class
      <literal>Deque</literal> in Java by inheriting from a class
      <literal>Stack</literal>, we would be allowed to pass a deque
      anywhere a stack is expected.
    </para>
    <para>
      OCaml is entirely different. Classes are used to construct objects
      and support inheritance, but classes are not types. Instead,
      objects have <emphasis>object types</emphasis>, and if you want to
      use objects, you aren't required to use classes at all. Here's an
      example of a simple object.
    </para>
    <programlisting language="ocaml">
...part 1 of objects/stack.topscript
# let s = object
  val mutable v = [0; 2]

  method pop =
    match v with
    | hd :: tl -&gt; 
       v &lt;- tl;
       Some hd
    | [] -&gt; None

  method push hd = 
    v &lt;- hd :: v
end;; 
val s : &lt; pop : int option; push : int -&gt; unit &gt; = &lt;obj&gt;
</programlisting>
    <para>
      The object has an integer list value <literal>v</literal>, a
      method <literal>pop</literal> that returns the head of
      <literal>v</literal>, and a method <literal>push</literal> that
      adds an integer to the head of <literal>v</literal>.
    </para>
    <para>
      The object type is enclosed in angle brackets
      <literal>&lt; ... &gt;</literal>, containing just the types of the
      methods. Fields, like <literal>v</literal>, are not part of the
      public interface of an object. All interaction with an object is
      through its methods. The syntax for a method invocation uses the
      <literal>#</literal> character.
    </para>
    <programlisting language="ocaml">
...part 2 of objects/stack.topscript
# s#pop;; 
- : int option = Some 0
# s#push 4;; 
- : unit = ()
# s#pop;; 
- : int option = Some 4
</programlisting>
    <para>
      Note that unlike functions, methods can have zero parameters,
      since the method call is routed to a concrete object instance.
      That's why the <literal>push</literal> and <literal>pop</literal>
      methods do not have a <literal>unit</literal> argument, as the
      equivalent functional versions would.
    </para>
    <para>
      Objects can also be constructed by functions. If we want to
      specify the initial value of the object, we can define a function
      that takes the value and returns an object.
    </para>
    <programlisting language="ocaml">
...part 3 of objects/stack.topscript
# let stack init = object
  val mutable v = init

  method pop =
    match v with
      hd :: tl -&gt; 
        v &lt;- tl;
        Some hd
    | [] -&gt; None

  method push hd = 
    v &lt;- hd :: v
end;; 
val stack : 'a list -&gt; &lt; pop : 'a option; push : 'a -&gt; unit &gt; = &lt;fun&gt;
# let s = stack [3; 2; 1];; 
val s : &lt; pop : int option; push : int -&gt; unit &gt; = &lt;obj&gt;
# s#pop;; 
- : int option = Some 3
</programlisting>
    <para>
      Note that the types of the function <literal>stack</literal> and
      the returned object now use the polymorphic type
      <literal>'a</literal>. When <literal>stack</literal> is invoked on
      a concrete value <literal>[3; 2; 1]</literal>, we get the same
      object type as before, with type <literal>int</literal> for the
      values on the stack.
    </para>
  </sect1>
  <sect1 id="object-polymorphism">
    <title>Object polymorphism</title>
    <para>
      Like polymorphic variants, methods can be used without an explicit
      type declaration.
    </para>
    <programlisting language="ocaml">
...part 1 of objects/polymorphism.topscript
# let area sq = sq#width * sq#width;; 
val area : &lt; width : int; .. &gt; -&gt; int = &lt;fun&gt;
# let minimize sq : unit = sq#resize 1;; 
val minimize : &lt; resize : int -&gt; unit; .. &gt; -&gt; unit = &lt;fun&gt;
# let limit sq = 
  if (area sq) &gt; 100 then minimize sq;; 
val limit : &lt; resize : int -&gt; unit; width : int; .. &gt; -&gt; unit = &lt;fun&gt;
</programlisting>
    <para>
      As you can see object types are inferred automatically from the
      methods that are invoked on them.
    </para>
    <para>
      The type system will complain if it sees incompatible uses of the
      same method:
    </para>
    <programlisting language="ocaml">
...part 2 of objects/polymorphism.topscript
# let toggle sq b : unit = 
  if b then sq#resize `Fullscreen
  else minimize sq;; 
Characters 76-78:
Error: This expression has type &lt; resize : [&gt; `Fullscreen ] -&gt; unit; .. &gt;
       but an expression was expected of type &lt; resize : int -&gt; unit; .. &gt;
       Types for method resize are incompatible
</programlisting>
    <para>
      The <literal>..</literal> in the inferred object types are
      ellipses, standing for other unspecified methods that the object
      may have. The type <literal>&lt; width : float; .. &gt;</literal>
      specifies an object that must have at least a
      <literal>width</literal> method, and possibly some others as well.
      Such object types are said to be <emphasis>open</emphasis>.
    </para>
    <para>
      We can manually <emphasis>close</emphasis> an object type using a
      type annotation:
    </para>
    <programlisting language="ocaml">
...part 3 of objects/polymorphism.topscript
# let area_closed (sq: &lt; width : int &gt;) = sq#width * sq#width;; 
val area_closed : &lt; width : int &gt; -&gt; int = &lt;fun&gt;
# let sq = object
  method width = 30 
  method name = &quot;sq&quot; 
end;; 
val sq : &lt; name : string; width : int &gt; = &lt;obj&gt;
# area_closed sq;; 
Characters 12-14:
Error: This expression has type &lt; name : string; width : int &gt;
       but an expression was expected of type &lt; width : int &gt;
       The second object type has no method name
</programlisting>
    <note>
    <title>
    Elisions are polymorphic
    </title>
    <para>
      The <literal>..</literal> in an open object type is an elision,
      standing for &quot;possibly more methods.&quot; It may not be
      apparent from the syntax, but an elided object type is actually
      polymorphic. For example, if we try to write a type definition, we
      get an &quot;unbound type variable&quot; error.
    </para>
    <programlisting language="ocaml">
...part 4 of objects/polymorphism.topscript
# type square = &lt; width : int; ..&gt;;; 
Characters 5-32:
Error: A type variable is unbound in this type declaration.
In type &lt; width : int; .. &gt; as 'a the variable 'a is unbound
</programlisting>
    <para>
      This is because <literal>..</literal> is really a special kind of
      type variable called a <emphasis>row variable</emphasis>.
    </para>
    <para>
      This kind of typing scheme using row variables is called
      <emphasis>row polymorphism</emphasis>. Row polymorphism is also
      used in polymorphic variant types, and there is a close
      relationship between objects and polymorphic variants: objects are
      to records what polymorphic variants are to ordinary variants.
    </para>
    </note>
    <para>
      An object of type
      <literal>&lt; pop : int option; .. &gt;</literal> can be any
      object with a method <literal>pop : int option</literal>, it
      doesn't matter how it is implemented. When the method
      <literal>#pop</literal> is invoked, the actual method that is run
      is determined by the object.
    </para>
    <programlisting language="ocaml">
...part 4 of objects/stack.topscript
# let print_pop st = Option.iter ~f:(printf &quot;Popped: %d\n&quot;) st#pop;; 
val print_pop : &lt; pop : int option; .. &gt; -&gt; unit = &lt;fun&gt;
# print_pop (stack [5;4;3;2;1]);; 

Popped: 5
- : unit = ()
# let t = object
  method pop = Some (Float.to_int (Time.to_float (Time.now ())))
end;; 
val t : &lt; pop : int option &gt; = &lt;obj&gt;
# print_pop t;; 

Popped: 1376255219
- : unit = ()
</programlisting>
  </sect1>
  <sect1 id="immutable-objects">
    <title>Immutable objects</title>
    <para>
      Many people consider object-oriented programming to be
      intrinsically imperative, where an object is like a state machine.
      Sending a message to an object causes it to change state, possibly
      sending messages to other objects.
    </para>
    <para>
      Indeed, in many programs, this makes sense, but it is by no means
      required. Let's define a function that creates immutable stack
      objects.
    </para>
    <programlisting language="ocaml">
...part 1 of objects/immutable.topscript
# let imm_stack init = object
  val v = init

  method pop =
    match v with
    | hd :: tl -&gt; Some (hd, {&lt; v = tl &gt;})
    | [] -&gt; None 

  method push hd = 
    {&lt; v = hd :: v &gt;}
end;; 
val imm_stack :
  'a list -&gt; (&lt; pop : ('a * 'b) option; push : 'a -&gt; 'b &gt; as 'b) = &lt;fun&gt;
</programlisting>
    <para>
      The key parts of this implementation are in the
      <literal>pop</literal> and <literal>push</literal> methods. The
      expression <literal>{&lt; ... &gt;}</literal> produces a copy of
      the current object, with the same type, and the specified fields
      updated. In other words, the <literal>push hd</literal> method
      produces a copy of the object, with <literal>v</literal> replaced
      by <literal>hd :: v</literal>. The original object is not
      modified.
    </para>
    <programlisting language="ocaml">
...part 2 of objects/immutable.topscript
# let s = imm_stack [3; 2; 1];; 
val s : &lt; pop : (int * 'a) option; push : int -&gt; 'a &gt; as 'a = &lt;obj&gt;
# let t = s#push 4;; 
val t : &lt; pop : (int * 'a) option; push : int -&gt; 'a &gt; as 'a = &lt;obj&gt;
# s#pop;; 
- : (int * (&lt; pop : 'a; push : int -&gt; 'b &gt; as 'b)) option as 'a =
Some (3, &lt;obj&gt;)
# t#pop;; 
- : (int * (&lt; pop : 'a; push : int -&gt; 'b &gt; as 'b)) option as 'a =
Some (4, &lt;obj&gt;)
</programlisting>
    <para>
      There are some restriction on the use of the expression
      <literal>{&lt; ... &gt;}</literal>. It can be used only within a
      method body, and only the values of fields may be updated. Method
      implementations are fixed at the time the object is created, they
      cannot be changed dynamically.
    </para>
  </sect1>
  <sect1 id="when-to-use-objects">
    <title>When to use objects</title>
    <para>
      You might wonder when to use objects in OCaml, which has a
      multitude of alternative mechanisms to express the similar
      concepts. First-class modules are more expressive (a module can
      include types, while classes and objects cannot). Modules,
      functors, and datatypes also offer a wide range of ways to express
      program structure. In fact, many seasoned OCaml programmers rarely
      use classes and objects, if at all.
    </para>
    <para>
      Objects have some advantages over records: they don't require type
      definitions and their support for row polymorphism makes them more
      flexible. However, the heavy syntax and additional runtime cost
      means that objects are rarely used in place of records.
    </para>
    <para>
      The real benefits of objects come from the class system. Classes
      support inheritance and open recursion. Open recursion allows
      interdependent parts of an object to be defined separately. This
      works because calls between the methods of an object are
      determined when the object is instantiated, a form of
      <emphasis>late</emphasis> binding. This makes it possible (and
      necessary) for one method to refer to other methods in the object
      without knowing statically how they will be implemented.
    </para>
    <para>
      In contrast, modules use early binding. If you want to
      parameterize your module code so that some part of it can be
      implemented later, you would write a function or functor. This is
      more explicit, but often more verbose than overriding a method in
      a class.
    </para>
    <para>
      In general, a rule of thumb is: use classes and objects in
      situations where open recursion is a big win. Two good examples
      are Xavier Leroy's
      <ulink url="http://gallium.inria.fr/~xleroy/software.html#cryptokit">Cryptokit</ulink>,
      which provides a variety of cryptographic primitives that can be
      combined in building-block style, and the
      <ulink url="http://cristal.inria.fr/camlimages/">Camlimages</ulink>
      library which manipulates various graphical file formats.
      Camlimages also provides a module-based version of the same
      library, letting you choose between functional and object-oriented
      styles depending on your problem domain.
    </para>
    <para>
      We'll introduce you to classes, and examples using open recursion,
      in <xref linkend="classes"/>.
    </para>
  </sect1>
  <sect1 id="subtyping">
    <title>Subtyping</title>
    <para>
      Subtyping is a central concept in object-oriented programming. It
      governs when an object with one type <emphasis>A</emphasis> can be
      used in an expression that expects an object of another type
      <emphasis>B</emphasis>. When this is true, we say that
      <emphasis>A</emphasis> is a <emphasis>subtype</emphasis> of
      <emphasis>B</emphasis>. Actually, more concretely, subtyping
      restricts when the coercion operator <literal>e :&gt; t</literal>
      can be applied. This coercion works only if the expression
      <literal>e</literal> has some type <literal>s</literal> and
      <literal>s</literal> is a subtype of <literal>t</literal>.
    </para>
    <sect2 id="width-subtyping">
      <title>Width subtyping</title>
      <para>
        To explore this, let's define some simple object types for
        geometric shapes. The generic type <literal>shape</literal> has
        a method to compute the area, and <literal>square</literal> and
        <literal>circle</literal> are specific kinds of shape.
      </para>
      <programlisting language="ocaml">
(* objects/subtyping.ml (starting from part 1) *)
type shape = &lt; area : float &gt;

type square = &lt; area : float; width : int &gt;

let square w = object
  method area = Float.of_int (w * w)
  method width = w
end

type circle = &lt; area : float; radius : int &gt;

let circle r = object
  method area = 3.14 *. (Float.of_int r) ** 2.0
  method radius = r
end
</programlisting>
      <para>
        A <literal>square</literal> has a method <literal>area</literal>
        just like a <literal>shape</literal>, and an additional method
        <literal>width</literal>. Still, we expect a
        <literal>square</literal> to be a <literal>shape</literal>, and
        it is. The coercion <literal>:&gt;</literal> must be explicit.
      </para>
      <programlisting language="ocaml">
...part 1 of objects/subtyping.topscript
# let shape w : shape = square w;; 
Characters 22-30:
Error: This expression has type &lt; area : float; width : int &gt;
       but an expression was expected of type shape
       The second object type has no method width
# let shape w : shape = (square w :&gt; shape);; 
val shape : int -&gt; shape = &lt;fun&gt;
</programlisting>
      <para>
        This form of object subtyping is called
        <emphasis>width</emphasis> subtyping. Width subtyping means that
        an object type <emphasis>A</emphasis> is a subtype of
        <emphasis>B</emphasis>, if <emphasis>A</emphasis> has all of the
        methods of <emphasis>B</emphasis>, and possibly more. A
        <literal>square</literal> is a subtype of
        <literal>shape</literal> because it implements all of the
        methods of <literal>shape</literal> (the <literal>area</literal>
        method).
      </para>
    </sect2>
    <sect2 id="depth-subtyping">
      <title>Depth subtyping</title>
      <para>
        We can also use <emphasis>depth</emphasis> subtyping with
        objects. Depth subtyping, in its most general form, says that an
        object type <literal>&lt; m: t1 &gt;</literal> is a subtype of
        <literal>&lt; m: t2 &gt;</literal> iff <literal>t1</literal> is
        a subtype of <literal>t2</literal>.
      </para>
      <para>
        For example, we can create two objects with a
        <literal>shape</literal> method:
      </para>
      <programlisting language="ocaml">
...part 2 of objects/subtyping.topscript
# let coin = object
  method shape = circle 5
  method color = &quot;silver&quot;
end;; 
val coin : &lt; color : string; shape : &lt; area : float; radius : int &gt; &gt; = &lt;obj&gt;
# let map = object
  method shape = square 10
end;; 
val map : &lt; shape : &lt; area : float; width : int &gt; &gt; = &lt;obj&gt;
</programlisting>
      <para>
        Both these objects have a <literal>shape</literal> method whose
        type is a subtype of the <literal>shape</literal> type, so they
        can both be coerced into the object type
        <literal>&lt; shape : shape &gt;</literal>
      </para>
      <programlisting language="ocaml">
...part 3 of objects/subtyping.topscript
# type item = &lt; shape : shape &gt;;; 
type item = &lt; shape : shape &gt;
# let items = [ (coin :&gt; item) ; (map :&gt; item) ];; 
val items : item list = [&lt;obj&gt;; &lt;obj&gt;]
</programlisting>
    </sect2>
    <sect2 id="polymorphic-variant-subtyping">
      <title>Polymorphic variant subtyping</title>
      <para>
        Subtyping can also be used to coerce a polymorphic variant into
        a larger polymorphic variant type. A polymorphic variant type
        <emphasis>A</emphasis> is a subtype of <emphasis>B</emphasis>,
        if the tags of <emphasis>A</emphasis> are a subset of the tags
        of <emphasis>B</emphasis>.
      </para>
      <programlisting language="ocaml">
...part 4 of objects/subtyping.topscript
# type num = [ `Int of int | `Float of float ];; 
type num = [ `Float of float | `Int of int ]
# type const = [ num | `String of string ];; 
type const = [ `Float of float | `Int of int | `String of string ]
# let n : num = `Int 3;; 
val n : num = `Int 3
# let c : const = (n :&gt; const);; 
val c : const = `Int 3
</programlisting>
    </sect2>
    <sect2 id="variance">
      <title>Variance</title>
      <para>
        What about types built from object types? If a
        <literal>square</literal> is a <literal>shape</literal>, we
        expect a <literal>square list</literal> to be a
        <literal>shape list</literal>. OCaml does indeed allow such
        coercions:
      </para>
      <programlisting language="ocaml">
...part 5 of objects/subtyping.topscript
# let squares: square list = [ square 10; square 20 ];; 
val squares : square list = [&lt;obj&gt;; &lt;obj&gt;]
# let shapes: shape list = (squares :&gt; shape list);; 
val shapes : shape list = [&lt;obj&gt;; &lt;obj&gt;]
</programlisting>
      <para>
        Note that this relies on lists being immutable. It would not be
        safe to treat a <literal>square array</literal> as a
        <literal>shape array</literal> because it would allow you to
        store non-square shapes into what should be an array of squares.
        OCaml recognizes this and does not allow the coercion:
      </para>
      <programlisting language="ocaml">
...part 6 of objects/subtyping.topscript
# let square_array: square array = [| square 10; square 20 |];; 
val square_array : square array = [|&lt;obj&gt;; &lt;obj&gt;|]
# let shape_array: shape array = (square_array :&gt; shape array);; 
Characters 31-60:
Error: Type square array is not a subtype of shape array 
       Type square = &lt; area : float; width : int &gt;
       is not compatible with type shape = &lt; area : float &gt; 
       The second object type has no method width
</programlisting>
      <para>
        We say that <literal>'a list</literal> is
        <emphasis>covariant</emphasis> (in <literal>'a</literal>),
        whilst <literal>'a array</literal> is
        <emphasis>invariant</emphasis>.
      </para>
      <para>
        Subtyping function types requires a third class of variance. A
        function with type <literal>square -&gt; string</literal> cannot
        be used with type <literal>shape -&gt; string</literal> because
        it expects its argument to be a <literal>square</literal> and
        would not know what to do with a <literal>circle</literal>.
        However, a function with type
        <literal>shape -&gt; string</literal> <emphasis>can</emphasis>
        safely be used with type <literal>square -&gt; string</literal>.
      </para>
      <programlisting language="ocaml">
...part 7 of objects/subtyping.topscript
# let shape_to_string: shape -&gt; string = 
    fun s -&gt; sprintf &quot;Shape(%F)&quot; s#area;; 
val shape_to_string : shape -&gt; string = &lt;fun&gt;
# let square_to_string: square -&gt; string = 
    (shape_to_string :&gt; square -&gt; string);; 
val square_to_string : square -&gt; string = &lt;fun&gt;
</programlisting>
      <para>
        We say that <literal>'a -&gt; string</literal> is
        <emphasis>contravariant</emphasis> in <literal>'a</literal>. In
        general, function types are contravariant in their arguments and
        covariant in their results.
      </para>
      <note>
      <title>
      Variance annotations
      </title>
      <para>
        OCaml works out the variance of a type using that type's
        definition.
      </para>
      <programlisting language="ocaml">
...part 8 of objects/subtyping.topscript
# module Either = struct
  type ('a, 'b) t = 
      Left of 'a
    | Right of 'b
  let left x = Left x
  let right x = Right x
end;; 
module Either :
  sig
    type ('a, 'b) t = Left of 'a | Right of 'b
    val left : 'a -&gt; ('a, 'b) t
    val right : 'a -&gt; ('b, 'a) t
  end
# (Either.left (square 40) :&gt; (shape, shape) Either.t);; 
- : (shape, shape) Either.t = Either.Left &lt;obj&gt;
</programlisting>
      <para>
        However, if the definition is hidden by a signature then OCaml
        is forced to assume that the type is invariant.
      </para>
      <programlisting language="ocaml">
...part 9 of objects/subtyping.topscript
# module AbstractEither : sig 
  type ('a, 'b) t
  val left: 'a -&gt; ('a, 'b) t
  val right: 'b -&gt; ('a, 'b) t
end = Either;; 
module AbstractEither :
  sig
    type ('a, 'b) t
    val left : 'a -&gt; ('a, 'b) t
    val right : 'b -&gt; ('a, 'b) t
  end
# (AbstractEither.left (square 40) :&gt; (shape, shape) AbstractEither.t);; 
Characters 1-32:
Error: This expression cannot be coerced to type
         (shape, shape) AbstractEither.t;
       it has type (&lt; area : float; width : int &gt;, 'a) AbstractEither.t
       but is here used with type (shape, shape) AbstractEither.t
       Type &lt; area : float; width : int &gt; is not compatible with type
         shape = &lt; area : float &gt; 
       The second object type has no method width
</programlisting>
      <para>
        We can fix this by adding <emphasis>variance
        annotations</emphasis> to the type's parameters in the
        signature: <literal>+</literal> for covariance or
        <literal>-</literal> for contravariance.
      </para>
      <programlisting language="ocaml">
...part 10 of objects/subtyping.topscript
# module VarEither : sig 
  type (+'a, +'b) t
  val left: 'a -&gt; ('a, 'b) t
  val right: 'b -&gt; ('a, 'b) t
end = Either;; 
module VarEither :
  sig
    type (+'a, +'b) t
    val left : 'a -&gt; ('a, 'b) t
    val right : 'b -&gt; ('a, 'b) t
  end
# (VarEither.left (square 40) :&gt; (shape, shape) VarEither.t);; 
- : (shape, shape) VarEither.t = &lt;abstr&gt;
</programlisting>
      </note>
      <para>
        For a more concrete example of variance, let's create some
        stacks containing shapes by applying our
        <literal>stack</literal> function to some squares and some
        circles.
      </para>
      <programlisting language="ocaml">
(* objects/subtyping.ml (starting from part 2) *)
type 'a stack = &lt; pop: 'a option; push: 'a -&gt; unit &gt;

let square_stack: square stack = stack [square 30; square 10]

let circle_stack: circle stack = stack [circle 20; circle 40]
</programlisting>
      <para>
        If we wanted to write a function that took a list of such stacks
        and found the total area of their shapes, we might try:
      </para>
      <programlisting language="ocaml">
...part 11 of objects/subtyping.topscript
# let total_area (shape_stacks: shape stack list) =
  let stack_area acc st = 
    let rec loop acc =
      match st#pop with
      | Some s -&gt; loop (acc +. s#area)
      | None -&gt; acc
    in
      loop acc
  in
    List.fold ~init:0.0 ~f:stack_area shape_stacks;; 
val total_area : shape stack list -&gt; float = &lt;fun&gt;
</programlisting>
      <para>
        However, when we try to apply this function to our objects we
        get an error:
      </para>
      <programlisting language="ocaml">
...part 12 of objects/subtyping.topscript
# total_area [(square_stack :&gt; shape stack); (circle_stack :&gt; shape stack)];; 
Characters 12-41:
Error: Type square stack = &lt; pop : square option; push : square -&gt; unit &gt;
       is not a subtype of
         shape stack = &lt; pop : shape option; push : shape -&gt; unit &gt; 
       Type shape = &lt; area : float &gt; is not a subtype of
         square = &lt; area : float; width : int &gt; 
</programlisting>
      <para>
        As you can see, <literal>square stack</literal> and
        <literal>circle stack</literal> are not subtypes of
        <literal>shape stack</literal>. The problem is with the
        <literal>push</literal> method. For
        <literal>shape stack</literal>, the <literal>push</literal>
        method takes an arbitrary <literal>shape</literal>. So if we
        could coerce a <literal>square stack</literal> to a
        <literal>shape stack</literal>, then it would be possible to
        push an arbitrary shape onto <literal>square stack</literal>,
        which would be an error.
      </para>
      <para>
        Another way of looking at this is that
        <literal>&lt; push: 'a -&gt; unit; .. &gt;</literal> is
        contravariant in <literal>'a</literal>, so
        <literal>&lt; push: square -&gt; unit; pop: square option &gt;</literal>
        cannot be a subtype of
        <literal>&lt; push: shape -&gt; unit; pop: shape option &gt;</literal>.
      </para>
      <para>
        Still, the <literal>total_area</literal> function should be
        fine, in principle. It doesn't call <literal>push</literal>, so
        it isn't making that error. To make it work, we need to use a
        more precise type that indicates we are not going to be using
        the set method. We define a type
        <literal>readonly_stack</literal> and confirm that we can coerce
        the list of stacks to it.
      </para>
      <programlisting language="ocaml">
...part 13 of objects/subtyping.topscript
# type 'a readonly_stack = &lt; pop : 'a option &gt;;; 
type 'a readonly_stack = &lt; pop : 'a option &gt;
# let total_area (shape_stacks: shape readonly_stack list) =
  let stack_area acc st = 
    let rec loop acc =
      match st#pop with
      | Some s -&gt; loop (acc +. s#area)
      | None -&gt; acc
    in
      loop acc
  in
    List.fold ~init:0.0 ~f:stack_area shape_stacks;; 
val total_area : shape readonly_stack list -&gt; float = &lt;fun&gt;
# total_area [(square_stack :&gt; shape readonly_stack); (circle_stack :&gt; shape readonly_stack)];; 
- : float = 7280.
</programlisting>
      <para>
        Aspects of this section may seem fairly complicated, but it
        should be pointed out that this typing
        <emphasis>works</emphasis>, and in the end the type annotations
        are fairly minor. In most typed object-oriented languages, these
        coercions would simply not be possible. For example, in C++, a
        STL type <literal>list&lt;T&gt;</literal> is invariant in
        <literal>T</literal>, so it is simply not possible to use
        <literal>list&lt;square&gt;</literal> where
        <literal>list&lt;shape&gt;</literal> is expected (at least
        safely). The situation is similar in Java, although Java has an
        escape hatch that allows the program to fall back to dynamic
        typing. The situation in OCaml is much better; it works, it is
        statically checked, and the annotations are pretty simple.
      </para>
    </sect2>
    <sect2 id="narrowing">
      <title>Narrowing</title>
      <para>
        Narrowing, also called <emphasis>down casting</emphasis>, is the
        ability to coerce an object to one of its subtypes. For example,
        if we have a list of shapes <literal>shape list</literal>, we
        might know (for some reason) what the actual type of each shape
        is. Perhaps we know that all objects in the list have type
        <literal>square</literal>. In this case,
        <emphasis>narrowing</emphasis> would allow the re-casting of the
        object from type <literal>shape</literal> to type
        <literal>square</literal>. Many languages support narrowing
        through dynamic type checking. For example, in Java, a coercion
        <literal>(Square) x</literal> is allowed if the value
        <literal>x</literal> has type <literal>Square</literal> or one
        of its subtypes; otherwise the coercion throws an exception.
      </para>
      <para>
        Narrowing is <emphasis>not permitted</emphasis> in OCaml.
        Period.
      </para>
      <para>
        Why? There are two reasonable explanations, one based on a
        design principle, and another technical (the technical reason is
        simple: it is hard to implement).
      </para>
      <para>
        The design argument is this: narrowing violates abstraction. In
        fact, with a structural typing system like in OCaml, narrowing
        would essentially provide the ability to enumerate the methods
        in an object. To check whether an object <literal>obj</literal>
        has some method <literal>foo : int</literal>, one would attempt
        a coercion <literal>(obj :&gt; &lt; foo : int &gt;)</literal>.
      </para>
      <para>
        More commonly, narrowing leads to poor object-oriented style.
        Consider the following Java code, which returns the name of a
        shape object.
      </para>
      <programlisting language="java">
String GetShapeName(Shape s) {
  if (s instanceof Square) {
    return &quot;Square&quot;;
  } else if (s instanceof Circle) {
    return &quot;Circle&quot;;
  } else {
    return &quot;Other&quot;;
  }
}
</programlisting>
      <para>
        Most programmers would consider this code to be
        &quot;wrong.&quot; Instead of performing a case analysis on the
        type of object, it would be better to define a method to return
        the name of the shape. Instead of calling
        <literal>GetShapeName(s)</literal>, we should call
        <literal>s.Name()</literal> instead.
      </para>
      <para>
        However, the situation is not always so obvious. The following
        code checks whether an array of shapes looks like a
        &quot;barbell,&quot; composed of two <literal>Circle</literal>
        objects separated by a <literal>Line</literal>, where the
        circles have the same radius.
      </para>
      <programlisting language="java">
boolean IsBarbell(Shape[] s) {
  return s.length == 3 &amp;&amp; (s[0] instanceof Circle) &amp;&amp;
    (s[1] instanceof Line) &amp;&amp; (s[2] instanceof Circle) &amp;&amp;
        ((Circle) s[0]).radius() == ((Circle) s[2]).radius();
}
</programlisting>
      <para>
        In this case, it is much less clear how to augment the
        <literal>Shape</literal> class to support this kind of pattern
        analysis. It is also not obvious that object-oriented
        programming is well-suited for this situation. Pattern matching
        seems like a better fit.
      </para>
      <programlisting language="ocaml">
(* objects/is_barbell.ml  *)
let is_barbell =
  function
  | [Circle r1; Line _; Circle r2] when r1 = r2 -&gt; true
  | _ -&gt; false
</programlisting>
      <para>
        Regardless, there is a solution if you find yourself in this
        situation, which is to augment the classes with variants. You
        can define a method <literal>variant</literal> that injects the
        actual object into a variant type.
      </para>
      <programlisting language="ocaml">
(* objects/narrowing.ml (starting from part 1) *)
type shape = &lt; variant : repr; area : float&gt;
and circle = &lt; variant : repr; area : float; radius : int &gt;
and line = &lt; variant : repr; area : float; length : int &gt;
and repr =
 | Circle of circle
 | Line of line;;

let is_barbell = function
 | [s1; s2; s3] -&gt;
   (match s1#variant, s2#variant, s3#variant with
     | Circle c1, Line _, Circle c2 when c1#radius = c2#radius -&gt; true
     | _ -&gt; false)
 | _ -&gt; false;;
</programlisting>
      <para>
        This pattern works, but it has drawbacks. In particular, the
        recursive type definition should make it clear that this pattern
        is essentially equivalent to using variants, and that objects do
        not provide much value here.
      </para>
    </sect2>
    <sect2 id="subtyping-vs.-row-polymorphism">
      <title>Subtyping vs. row polymorphism</title>
      <para>
        There is considerable overlap between subtyping and row
        polymorphism. Both mechanisms allow you to write functions that
        can be applied to objects of different types. In these cases,
        row polymorphism is usually preferred over subtyping because it
        does not require explicit coercions, and it preserves more type
        information, allowing functions like the following:
      </para>
      <programlisting language="ocaml">
...part 1 of objects/row_polymorphism.topscript
# let remove_large l =
  List.filter ~f:(fun s -&gt; s#area &lt;= 100.) l;; 
val remove_large : (&lt; area : float; .. &gt; as 'a) list -&gt; 'a list = &lt;fun&gt;
</programlisting>
      <para>
        The return type of this function is built from the open object
        type of its argument, preserving any additional methods that it
        may have.
      </para>
      <programlisting language="ocaml">
...part 2 of objects/row_polymorphism.topscript
# let squares : &lt; area : float; width : int &gt; list = 
  [square 5; square 15; square 10];; 
val squares : &lt; area : float; width : int &gt; list = [&lt;obj&gt;; &lt;obj&gt;; &lt;obj&gt;]
# remove_large squares;; 
- : &lt; area : float; width : int &gt; list = [&lt;obj&gt;; &lt;obj&gt;]
</programlisting>
      <para>
        Writing a similar function with a closed type and applying it
        using subtyping does not preserve the methods of the argument:
        the returned object is only known to have an
        <literal>area</literal> method.
      </para>
      <programlisting language="ocaml">
...part 3 of objects/row_polymorphism.topscript
# let remove_large (l: &lt; area : float &gt; list) = 
  List.filter ~f:(fun s -&gt; s#area &lt;= 100.) l;; 
val remove_large : &lt; area : float &gt; list -&gt; &lt; area : float &gt; list = &lt;fun&gt;
# remove_large (squares :&gt; &lt; area : float &gt; list );; 
- : &lt; area : float &gt; list = [&lt;obj&gt;; &lt;obj&gt;]
</programlisting>
      <para>
        However, there are some situations where we cannot use row
        polymorphism. In particular, row polymorphism cannot be used to
        place different types of object in the same container. For
        example, lists of heterogeneous elements cannot be created using
        row polymorphism:
      </para>
      <programlisting language="ocaml">
...part 4 of objects/row_polymorphism.topscript
# let hlist: &lt; area: float; ..&gt; list = [square 10; circle 30];; 
Characters 49-58:
Error: This expression has type &lt; area : float; radius : int &gt;
       but an expression was expected of type &lt; area : float; width : int &gt;
       The second object type has no method radius
</programlisting>
      <para>
        Similarly, we cannot use row polymorphism to store different
        types of object in the same reference:
      </para>
      <programlisting language="ocaml">
...part 5 of objects/row_polymorphism.topscript
# let shape_ref: &lt; area: float; ..&gt; ref = ref (square 40);; 
val shape_ref : &lt; area : float; width : int &gt; ref = {contents = &lt;obj&gt;}
# shape_ref := circle 20;; 
Characters 13-22:
Error: This expression has type &lt; area : float; radius : int &gt;
       but an expression was expected of type &lt; area : float; width : int &gt;
       The second object type has no method radius
</programlisting>
      <para>
        In both these cases we must use subtyping:
      </para>
      <programlisting language="ocaml">
...part 6 of objects/row_polymorphism.topscript
# let hlist: shape list = [(square 10 :&gt; shape); (circle 30 :&gt; shape)];; 
Characters 11-16:
Error: Unbound type constructor shape
# let shape_ref: shape ref = ref (square 40 :&gt; shape);; 
Characters 15-20:
Error: Unbound type constructor shape
# shape_ref := (circle 20 :&gt; shape);; 
Characters 27-32:
Error: Unbound type constructor shape
</programlisting>
      <note>
      <title>
      Production note
      </title>
      <para>
        This chapter contains significant external contributions from
        Leo White.
      </para>
      </note>

    </sect2>
  </sect1>
</chapter><chapter id="classes">
  <title>Classes</title>
  <para>
    Programming with objects directly is great for encapsulation, but
    one of the main goals of object-oriented programming is code re-use
    through inheritance. For inheritance, we need to introduce
    <emphasis>classes</emphasis>. In object-oriented programming, a
    class is a &quot;recipe&quot; for creating objects. The recipe can
    be changed by adding new methods and fields, or it can be changed by
    modifying existing methods.
  </para>
  <sect1 id="ocaml-classes">
    <title>OCaml classes</title>
    <para>
      In OCaml, class definitions must be defined as toplevel statements
      in a module. The syntax for a class definition uses the keyword
      <literal>class</literal>.
    </para>
    <programlisting language="ocaml">
(* classes/istack.topscript  *)
# class istack = object
    val mutable v = [0; 2]

    method pop =
      match v with
        hd :: tl -&gt;
          v &lt;- tl;
          Some hd
      | [] -&gt; None

    method push hd =
      v &lt;- hd :: v
  end ;; 
class istack :
  object
    val mutable v : int list
    method pop : int option
    method push : int -&gt; unit
  end
</programlisting>
    <para>
      The <literal>class istack : object ... end</literal> result shows
      that we have created a class <literal>istack</literal> with
      <emphasis>class type</emphasis> <literal>object ... end</literal>.
      Like module types, class types are completely separate from
      regular OCaml types (e.g. <literal>int</literal>,
      <literal>string</literal>, <literal>list</literal>) and, in
      particular, should not be confused with object types (e.g.
      <literal>&lt; get : int; .. &gt;</literal>). The class type
      describes the class itself rather than the objects that the class
      creates. This particular class type specifies that the
      <literal>istack</literal> class defines a mutable field
      <literal>v</literal>, a method <literal>pop</literal> that returns
      an <literal>int option</literal>, and a method
      <literal>push</literal> with type
      <literal>int -&gt; unit</literal>.
    </para>
    <para>
      To produce an object, classes are instantiated with the keyword
      <literal>new</literal>.
    </para>
    <programlisting language="ocaml">
(* classes/istack.topscript (starting from part 1) *)
# let s = new istack ;; 
val s : istack = &lt;obj&gt;
# s#pop ;; 
- : int option = Some 0
# s#push 5 ;; 
- : unit = ()
# s#pop ;; 
- : int option = Some 5
</programlisting>
    <para>
      You may have noticed that the object <literal>s</literal> has been
      given the type <literal>istack</literal>. But wait, we've stressed
      <emphasis>classes are not types</emphasis>, so what's up with
      that? In fact, what we've said is entirely true, classes and class
      names <emphasis>are not</emphasis> types. However, for
      convenience, the definition of the class <literal>istack</literal>
      also defines an object type <literal>istack</literal> with the
      same methods as the class. This type definition is equivalent to:
    </para>
    <programlisting language="ocaml">
(* classes/istack.topscript (starting from part 2) *)
# type istack = &lt; pop: int option; push: int -&gt; unit &gt; ;; 
type istack = &lt; pop : int option; push : int -&gt; unit &gt;
</programlisting>
    <para>
      Note that this type represents any object with these methods:
      objects created using the <literal>istack</literal> class will
      have this type, but objects with this type may not have been
      created by the <literal>istack</literal> class.
    </para>
  </sect1>
  <sect1 id="class-parameters-and-polymorphism">
    <title>Class parameters and polymorphism</title>
    <para>
      A class definition serves as the <emphasis>constructor</emphasis>
      for the class. In general, a class definition may have parameters
      that must be provided as arguments when the object is created with
      <literal>new</literal>.
    </para>
    <para>
      Let's implement a variant of the <literal>istack</literal> class
      that can hold any values, not just integers. When defining the
      class, the type parameters are placed in square brackets before
      the class name in the class definition. We also add a parameter
      <literal>init</literal> for the initial contents of the stack.
    </para>
    <programlisting language="ocaml">
# script classes/stack.topscript
$ utop
# class ['a] stack init = object
    val mutable v : 'a list = init

    method pop =
      match v with
        hd :: tl -&gt;
          v &lt;- tl;
          Some hd
      | [] -&gt; None

    method push hd =
      v &lt;- hd :: v
end ;; 
class ['a] stack :
  'a list -&gt;
  object
    val mutable v : 'a list
    method pop : 'a option
    method push : 'a -&gt; unit
  end
</programlisting>
    <para>
      Note that the type parameter <literal>['a]</literal> in the
      definition uses square brackets, but for other uses of the type
      they are omited (or replaced with parentheses if there is more
      than one type parameter).
    </para>
    <para>
      The type annotation on the declaration of <literal>v</literal> is
      used to constrain type inference. If we omit this annotation, the
      type inferred for the class will be &quot;too polymorphic&quot;:
      <literal>init</literal> could have some type
      <literal>'b list</literal>.
    </para>
    <programlisting language="ocaml">
...part 1 of classes/stack.topscript
# class ['a] stack init = object
      val mutable v = init
    
      method pop = 
        match v with
          hd :: tl -&gt; 
            v &lt;- tl;
            Some hd
        | [] -&gt; None

      method push hd = 
        v &lt;- hd :: v
  end ;; 
Characters 6-16:
Error: Some type variables are unbound in this type:
         class ['a] stack :
           'b list -&gt;
           object
             val mutable v : 'b list
             method pop : 'b option
             method push : 'b -&gt; unit
           end
       The method pop has type 'b option where 'b is unbound
</programlisting>
    <para>
      In general, we need to provide enough constraints so that the
      compiler will infer the correct type. We can add type constraints
      to the parameters, to the fields, and to the methods. It is a
      matter of preference how many constraints to add. You can add type
      constraints in all three places, but the extra text may not help
      clarity. A convenient middle ground is to annotate the fields
      and/or class parameters, and add constraints to methods only if
      necessary.
    </para>
  </sect1>
  <sect1 id="object-types-as-interfaces">
    <title>Object types as interfaces</title>
    <para>
      We may wish to traverse the elements on our stack. One common
      style for doing this in object-oriented languages is to define a
      class for an <literal>iterator</literal> object. An iterator
      provides a generic mechanism to inspect and traverse the elements
      of a collection.
    </para>
    <para>
      There are two common styles for defining abstract interfaces like
      this. In Java, an iterator would normally be specified with an
      interface, which specifies a set of method types.
    </para>
    <programlisting language="java">
// Java-style iterator, specified as an interface.
interface &lt;T&gt; iterator {
  T Get();
  boolean HasValue();
  void Next();
};
</programlisting>
    <para>
      In languages without interfaces, like C++, the specification would
      normally use <emphasis>abstract</emphasis> classes to specify the
      methods without implementing them (C++ uses the &quot;= 0&quot;
      definition to mean &quot;not implemented&quot;).
    </para>
    <programlisting language="cpp">
// Abstract class definition in C++.
template&lt;typename T&gt;
class Iterator {
 public:
  virtual ~Iterator() {}
  virtual T get() const = 0;
  virtual bool has_value() const = 0;
  virtual void next() = 0;
};
</programlisting>
    <para>
      OCaml supports both styles. In fact, OCaml is more flexible than
      these approaches because an object type can be implemented by any
      object with the appropriate methods; it does not have to be
      specified by the object's class <emphasis>a priori</emphasis>.
      We'll leave abstract classes for later. Let's demonstrate the
      technique using object types.
    </para>
    <para>
      First, we'll define an object type <literal>iterator</literal>
      that specifies the methods in an iterator.
    </para>
    <programlisting language="ocaml">
# script classes/iter.topscript
$ utop
# type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt; ;; 
type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;
</programlisting>
    <para>
      Next, we'll define an actual iterator for lists. We can use this
      to iterate over the contents of our stack.
    </para>
    <programlisting language="ocaml">
...part 1 of classes/iter.topscript
# class ['a] list_iterator init =
  object
    val mutable current : 'a list = init

    method has_value = current &lt;&gt; []

    method get =
      match current with
        hd :: tl -&gt; hd
      | [] -&gt; raise (Invalid_argument &quot;no value&quot;)

    method next =
      match current with
        hd :: tl -&gt; current &lt;- tl
      | [] -&gt; raise (Invalid_argument &quot;no value&quot;)
   end  ;; 
class ['a] list_iterator :
  'a list -&gt;
  object
    val mutable current : 'a list
    method get : 'a
    method has_value : bool
    method next : unit
  end
</programlisting>
    <para>
      Finally, we add a method <literal>iterator</literal> to the
      <literal>stack</literal> class to produce an iterator. To do so,
      we construct a <literal>list_iterator</literal> that refers to the
      current contents of the stack.
    </para>
    <programlisting language="ocaml">
...part 2 of classes/iter.topscript
# class ['a] stack init = object
    val mutable v : 'a list = init

    method pop =
      match v with
        hd :: tl -&gt;
          v &lt;- tl;
          Some hd
      | [] -&gt; None

    method push hd =
      v &lt;- hd :: v

    method iterator : 'a iterator =
      new list_iterator v
end ;; 
class ['a] stack :
  'a list -&gt;
  object
    val mutable v : 'a list
    method iterator : 'a iterator
    method pop : 'a option
    method push : 'a -&gt; unit
  end
</programlisting>
    <para>
      Now we can build a new stack, push some values to it, and iterate
      over them.
    </para>
    <programlisting language="ocaml">
...part 3 of classes/iter.topscript
# let s = new stack [] ;; 
val s : '_a stack = &lt;obj&gt;
# s#push 5 ;; 
- : unit = ()
# s#push 4 ;; 
- : unit = ()
# let it = s#iterator ;; 
val it : int iterator = &lt;obj&gt;
# it#get ;; 
- : int = 4
# it#next ;; 
- : unit = ()
# it#get ;; 
- : int = 5
# it#next ;; 
- : unit = ()
# it#has_value ;; 
- : bool = false
</programlisting>
    <sect2 id="functional-iterators">
      <title>Functional iterators</title>
      <para>
        In practise, most OCaml programmers avoid iterator objects in
        favor of functional-style techniques. For example, the
        alternative stack class below takes a function
        <literal>f</literal> and applies it to each of the elements on
        the stack.
      </para>
      <programlisting language="ocaml">
...part 4 of classes/iter.topscript
# class ['a] stack init = object
    val mutable v : 'a list = init

    method pop =
      match v with
        hd :: tl -&gt;
          v &lt;- tl;
          Some hd
      | [] -&gt; None

    method push hd =
      v &lt;- hd :: v

   method iter f = 
     List.iter ~f v end ;; 
class ['a] stack :
  'a list -&gt;
  object
    val mutable v : 'a list
    method iter : ('a -&gt; unit) -&gt; unit
    method pop : 'a option
    method push : 'a -&gt; unit
  end
</programlisting>
      <para>
        What about functional operations like <literal>map</literal> and
        <literal>fold</literal>? In general, these methods take a
        function that produces a value of some other type than the
        elements of the set.
      </para>
      <para>
        For example, a <literal>fold</literal> method for our
        <literal>['a] stack</literal> class should have type
        <literal>('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</literal>,
        where the <literal>'b</literal> is polymorphic. To express a
        polymorphic method type like this we must use a type quantifier,
        as shown in the following example.
      </para>
      <programlisting language="ocaml">
...part 5 of classes/iter.topscript
# class ['a] stack init = object
    val mutable v : 'a list = init

    method pop =
      match v with
        hd :: tl -&gt;
          v &lt;- tl;
          Some hd
      | [] -&gt; None

    method push hd =
      v &lt;- hd :: v

    method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b =
     (fun f init -&gt; List.fold ~f ~init v) 
  end ;; 
class ['a] stack :
  'a list -&gt;
  object
    val mutable v : 'a list
    method fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b
    method pop : 'a option
    method push : 'a -&gt; unit
  end
</programlisting>
      <para>
        The type quantifier <literal>'b.</literal> can be read as
        &quot;for all <literal>'b</literal>&quot;. Type quantifiers can
        only be used <emphasis>directly after</emphasis> the method
        name, which means that method parameters must be expressed using
        a <literal>fun</literal> or <literal>function</literal>
        expression.
      </para>
    </sect2>
  </sect1>
  <sect1 id="inheritance">
    <title>Inheritance</title>
    <para>
      Inheritance uses an existing class to define a new one. For
      example, the following class definition inherits from our stack
      class for strings and adds a new method <literal>print</literal>
      that prints all the strings on the stack.
    </para>
    <programlisting language="ocaml">
...part 2 of classes/stack.topscript
# class sstack init = object
    inherit [string] stack init

    method print =
      List.iter ~f:print_string v
  end ;; 
class sstack :
  string list -&gt;
  object
    val mutable v : string list
    method pop : string option
    method print : unit
    method push : string -&gt; unit
  end
</programlisting>
    <para>
      A class can override methods from classes it inherits. For
      example, this class creates stacks of integers that double the
      integers before they are pushed onto the stack.
    </para>
    <programlisting language="ocaml">
...part 3 of classes/stack.topscript
# class double_stack init = object
    inherit [int] stack init as super

    method push hd =
      super#push (hd * 2)
  end ;; 
class double_stack :
  int list -&gt;
  object
    val mutable v : int list
    method pop : int option
    method push : int -&gt; unit
  end
</programlisting>
    <para>
      The <literal>as super</literal> statement above creates a special
      object called <literal>super</literal> which can be used to call
      superclass methods. Note that <literal>super</literal> is not a
      real object and can only be used to call methods.
    </para>
  </sect1>
  <sect1 id="class-types">
    <title>Class types</title>
    <para>
      To allow code in a different file or module to inherit from a
      class we must expose it and give it a class type. What is the
      class type?
    </para>
    <para>
      As an example, let's wrap up our <literal>stack</literal> class in
      an explicit module (we'll use explicit modules for illustration,
      but the process is similar when we want to define a
      <literal>.mli</literal> file). In keeping with the usual style for
      modules, we define a type <literal>'a t</literal> to represent the
      type of our stacks.
    </para>
    <programlisting language="ocaml">
(* classes/class_types_stack.ml  *)
module Stack = struct
  class ['a] stack init = object
    ...    
  end

  type 'a t = 'a stack

  let make init = new stack init
end
</programlisting>
    <para>
      We have multiple choices in defining the module type, depending on
      how much of the implementation we want to expose. At one extreme,
      a maximally-abstract signature would completely hide the class
      definitions.
    </para>
    <programlisting language="ocaml">
(* classes/class_types_stack.ml (starting from part 1) *)
module AbstractStack : sig
   type 'a t = &lt; pop: 'a option; push: 'a -&gt; unit &gt;

   val make : unit -&gt; 'a t
end = Stack
</programlisting>
    <para>
      The abstract signature is simple because we ignore the classes.
      But what if we want to include them in the signature, so that
      other modules can inherit from the class definitions? For this, we
      need to specify types for the classes, called <emphasis>class
      types</emphasis>.
    </para>
    <para>
      Class types do not appear in mainstream object-oriented
      programming languages, so you may not be familiar with them, but
      the concept is pretty simple. A class type specifies the type of
      each of the visible parts of the class, including both fields and
      methods. Just like for module types, you don't have to give a type
      for everything; anything you omit will be hidden.
    </para>
    <programlisting language="ocaml">
(* classes/class_types_stack.ml (starting from part 2) *)
module VisibleStack : sig
  
  type 'a t = &lt; pop: 'a option; push: 'a -&gt; unit &gt;

  class ['a] stack :
  object
    val mutable v : 'a list
    method pop : 'a option
    method push : 'a -&gt; unit
  end

  val make : unit -&gt; 'a t
end = Stack
</programlisting>
    <para>
      In this signature, we've chosen to make everything visible. The
      class type for <literal>stack</literal> specifies the types of the
      field <literal>v</literal>, as well as the types of each of the
      methods.
    </para>
  </sect1>
  <sect1 id="open-recursion">
    <title>Open recursion</title>
    <para>
      Open recursion allows an object's methods to invoke other methods
      on the same object. These calls are looked up dynamically allowing
      a method in one class to call a method from another class, if both
      classes are inherited by the same object. This allows mutually
      recursive parts of an object to be defined separately.
    </para>
    <para>
      This ability to define mutually recursive methods from separate
      components is a key feature of classes: achieving similar
      functionality with datatypes or modules is much more cumbersome
      and verbose.
    </para>
    <para>
      For example, consider writing recursive functions over a simple
      document format. This format is represented as a tree with three
      different types of node:
    </para>
    <programlisting language="ocaml">
(* classes/doc.ml  *)
type doc =
    Heading of string
  | Paragraph of text_item list
  | Definition of string list_item list

and text_item =
    Raw of string
  | Bold of text_item list
  | Enumerate of int list_item list
  | Quote of doc

and 'a list_item = 
  { tag: 'a;
    text: text_item list }
</programlisting>
    <para>
      It is quite easy to write a function that operates by recursively
      traversing this data. However, what if you need to write many
      similar recursive functions? How can you factor out the common
      parts of these functions to avoid repetitive boilerplate?
    </para>
    <para>
      The simplest way is to use classes and open recursion. For
      example, the following class defines objects which fold over the
      document data:
    </para>
    <programlisting language="ocaml">
(* classes/doc.ml (starting from part 1) *)
open Core.Std

class ['a] folder = object(self)
  method doc acc =
    function
      Heading _ -&gt; acc
    | Paragraph text -&gt; List.fold ~f:self#text_item ~init:acc text
    | Definition list -&gt; List.fold ~f:self#list_item ~init:acc list

  method list_item: 'b. 'a -&gt; 'b list_item -&gt; 'a = 
    fun acc {tag; text} -&gt;
      List.fold ~f:self#text_item ~init:acc text

  method text_item acc =
    function
      Raw _ -&gt; acc
    | Bold text -&gt; List.fold ~f:self#text_item ~init:acc text
    | Enumerate list -&gt; List.fold ~f:self#list_item ~init:acc list
    | Quote doc -&gt; self#doc acc doc
end
</programlisting>
    <para>
      The <literal>object (self)</literal> syntax binds
      <literal>self</literal> to the current object, allowing the
      <literal>doc</literal>, <literal>list_item</literal> and
      <literal>text_item</literal> methods to call each other.
    </para>
    <para>
      By inheriting from this class we can create functions which fold
      over the document data. For example, the
      <literal>count_doc</literal> function counts the number of bold
      tags in the document that are not within a list:
    </para>
    <programlisting language="ocaml">
(* classes/doc.ml (starting from part 2) *)
class counter = object
  inherit [int] folder as super

  method list_item acc li = acc

  method text_item acc ti =
    let acc = super#text_item acc ti in
    match ti with
      Bold _ -&gt; acc + 1
    | _ -&gt; acc
end

let count_doc = (new counter)#doc
</programlisting>
    <para>
      Note how the <literal>super</literal> special object is used in
      <literal>text_item</literal> to call the
      <literal>[int] folder</literal> class's
      <literal>text_item</literal> method to fold over the children of
      the <literal>text_item</literal> node.
    </para>
  </sect1>
  <sect1 id="private-methods">
    <title>Private methods</title>
    <para>
      Methods can be declared <emphasis>private</emphasis>, which means
      that they may be called by subclasses, but they are not visible
      otherwise (similar to a <emphasis>protected</emphasis> method in
      C++).
    </para>
    <para>
      For example, we may want to include methods in our
      <literal>folder</literal> class for handling each of the different
      cases in <literal>doc</literal> and <literal>text_item</literal>.
      However, we may not want to force subclasses of
      <literal>folder</literal> to expose these methods as they probably
      shouldn't be called directly.
    </para>
    <programlisting language="ocaml">
(* classes/doc.ml (starting from part 3) *)
class ['a] folder2 = object(self)
  method doc acc =
    function
      Heading str -&gt; self#heading acc str
    | Paragraph text -&gt; self#paragraph acc text
    | Definition list -&gt; self#definition acc list

  method list_item: 'b. 'a -&gt; 'b list_item -&gt; 'a =
    fun acc {tag; text} -&gt;
      List.fold ~f:self#text_item ~init:acc text

  method text_item acc =
    function
      Raw str -&gt; self#raw acc str
    | Bold text -&gt; self#bold acc text
    | Enumerate list -&gt; self#enumerate acc list
    | Quote doc -&gt; self#quote acc doc

  method private heading acc str = acc
  method private paragraph acc text =
    List.fold ~f:self#text_item ~init:acc text
  method private definition acc list =
    List.fold ~f:self#list_item ~init:acc list

  method private raw acc str = acc
  method private bold acc text = 
    List.fold ~f:self#text_item ~init:acc text
  method private enumerate acc list = 
    List.fold ~f:self#list_item ~init:acc list
  method private quote acc doc = self#doc acc doc
end

let f :
  &lt; doc : int -&gt; doc -&gt; int;
    list_item : 'a . int -&gt; 'a list_item -&gt; int;
    text_item : int -&gt; text_item -&gt; int &gt;  = new folder2
</programlisting>
    <para>
      The final statement that builds the value <literal>f</literal>
      shows how the instantiation of a <literal>folder2</literal> object
      has a type that hides the private methods.
    </para>
    <para>
      To be precise, the private methods are part of the class type, but
      not part of the object type. This means, for example, that the
      object <literal>f</literal> has no method <literal>bold</literal>.
      However, the private methods are available to subclasses: we can
      use them to simplify our <literal>counter</literal> class.
    </para>
    <programlisting language="ocaml">
(* classes/doc.ml (starting from part 4) *)
class counter_with_private_method = object
  inherit [int] folder2 as super

  method list_item acc li = acc

  method private bold acc txt = 
    let acc = super#bold acc txt in
    acc + 1
end
</programlisting>
    <para>
      The key property of private methods is that they are visible to
      subclasses, but not anywhere else. If you want the stronger
      guarantee that a method is <emphasis>really</emphasis> private,
      not even accessible in subclasses, you can use an explicit class
      type that omits the method. In the following code, the private
      methods are explicitly omitted from the class type of
      <literal>counter_with_sig</literal>, and can't be invoked in
      subclasses of <literal>counter_with_sig</literal>.
    </para>
    <programlisting language="ocaml">
(* classes/doc.ml (starting from part 5) *)
class counter_with_sig : object
  method doc : int -&gt; doc -&gt; int
  method list_item : int -&gt; 'b list_item -&gt; int
  method text_item : int -&gt; text_item -&gt; int
end = object
  inherit [int] folder2 as super

  method list_item acc li = acc

  method private bold acc txt = 
    let acc = super#bold acc txt in
    acc + 1
end
</programlisting>
  </sect1>
  <sect1 id="binary-methods">
    <title>Binary methods</title>
    <para>
      A <emphasis>binary method</emphasis> is a method that takes an
      object of <literal>self</literal> type. One common example is
      defining a method for equality.
    </para>
    <programlisting language="ocaml">
# script classes/binary.topscript
$ utop
# class square w =
  object (self : 'self) 
    method width = w
    method area = Float.of_int (self#width * self#width)
    method equals (other : 'self) = other#width = self#width
  end ;; 
class square :
  int -&gt;
  object ('a)
    method area : float
    method equals : 'a -&gt; bool
    method width : int
  end
# class circle r =
  object (self : 'self)
    method radius = r
    method area = 3.14 *. (Float.of_int self#radius) ** 2.0
    method equals (other : 'self) = other#radius = self#radius
  end ;; 
class circle :
  int -&gt;
  object ('a)
    method area : float
    method equals : 'a -&gt; bool
    method radius : int
  end
</programlisting>
    <para>
      Note how we can use the type annotation
      <literal>(self: 'self)</literal> to obtain the type of the current
      object.
    </para>
    <para>
      We can now test different object instances for equality by using
      the <literal>equals</literal> binary method.
    </para>
    <programlisting language="ocaml">
...part 1 of classes/binary.topscript
# (new square 5)#equals (new square 5) ;; 
- : bool = true
# (new circle 10)#equals (new circle 7) ;; 
- : bool = false
</programlisting>
    <para>
      This works, but there is a problem lurking here. The method
      <literal>equals</literal> takes an object of the exact type
      <literal>square</literal> or <literal>circle</literal>. Because of
      this, we can't define a common base class <literal>shape</literal>
      that also includes an equality method.
    </para>
    <programlisting language="ocaml">
...part 2 of classes/binary.topscript
# type shape = &lt; equals : shape -&gt; bool; area : float &gt; ;; 
type shape = &lt; area : float; equals : shape -&gt; bool &gt;
# (new square 5 :&gt; shape) ;; 
Characters -1-23:
Error: Type square = &lt; area : float; equals : square -&gt; bool; width : int &gt;
       is not a subtype of shape = &lt; area : float; equals : shape -&gt; bool &gt; 
       Type shape = &lt; area : float; equals : shape -&gt; bool &gt;
       is not a subtype of
         square = &lt; area : float; equals : square -&gt; bool; width : int &gt; 
</programlisting>
    <para>
      The problem is that a <literal>square</literal> expects to be
      compared with a <literal>square</literal>, not an arbitrary shape;
      similarly for <literal>circle</literal>. This problem is
      fundamental. Many languages solve it either with narrowing (with
      dynamic type checking), or by method overloading. Since OCaml has
      neither of these, what can we do?
    </para>
    <para>
      Since the problematic method is equality, one proposal we could
      consider is is to just drop it from the base type
      <literal>shape</literal> and use polymorphic equality instead.
      However, the built-in polymorphic equality has very poor behavior
      when applied to objects.
    </para>
    <programlisting language="ocaml">
...part 3 of classes/binary.topscript
# (object method area = 5 end) = (object method area = 5 end) ;; 
- : bool = false
</programlisting>
    <para>
      The problem here is that two objects are considered equal by the
      built-in polymorphic equality if and only if they are physically
      equal. There are other reasons not to use the built-in polymorphic
      equality, but these false negatives are a showstopper.
    </para>
    <para>
      If we want to define equality for shapes in general, the remaining
      solution is to use the same approach as we described for
      narrowing. That is, introduce a
      <emphasis>representation</emphasis> type implemented using
      variants, and implement the comparison based on the representation
      type.
    </para>
    <programlisting language="ocaml">
...part 4 of classes/binary.topscript
# type shape_repr =
 | Square of int
 | Circle of int ;; 
type shape_repr = Square of int | Circle of int
# type shape =
  &lt; repr : shape_repr; equals : shape -&gt; bool; area : float &gt; ;; 
type shape = &lt; area : float; equals : shape -&gt; bool; repr : shape_repr &gt;
# class square w =
  object (self : 'self) 
    method width = w
    method area = Float.of_int (self#width * self#width)
    method repr = Square self#width
    method equals (other : 'self) = other#repr = self#repr
  end ;; 
class square :
  int -&gt;
  object ('a)
    method area : float
    method equals : 'a -&gt; bool
    method repr : shape_repr
    method width : int
  end
</programlisting>
    <para>
      The binary method <literal>equals</literal> is now implemented in
      terms of the concrete type <literal>shape_repr</literal>. In fact,
      the objects are now isomorphic to the
      <literal>shape_repr</literal> type. When using this pattern, you
      will not be able to hide the <literal>repr</literal> method, but
      you can hide the type definition using the module system.
    </para>
    <programlisting language="ocaml">
(* classes/binary_module.ml  *)
module Shapes : sig
  type shape_repr
  type shape =
    &lt; repr : shape_repr; equals : shape -&gt; bool; area: float &gt;

  class square : int -&gt;
    object
      method width : int
      method area : float
      method repr : shape_repr
      method equals : shape -&gt; bool
    end
end = struct
  type shape_repr = Square of int | Circle of int 
  ...
end
</programlisting>
  </sect1>
  <sect1 id="virtual-classes-and-methods">
    <title>Virtual classes and methods</title>
    <para>
      A <emphasis>virtual</emphasis> class is a class where some methods
      or fields are declared, but not implemented. This should not be
      confused with the word <literal>virtual</literal> as it is used in
      C++. A <literal>virtual</literal> method in C++ uses dynamic
      dispatch, while regular non-virtual methods are statically
      dispatched. In OCaml, <emphasis>all</emphasis> methods use dynamic
      dispatch, but the keyword <literal>virtual</literal> means that
      the method or field is not implemented. A class containing virtual
      methods must also be flagged <literal>virtual</literal> and cannot
      be directly instantiated (i.e. no object of this class can be
      created).
    </para>
    <para>
      To explore this, let's extend our shapes examples to simple
      interactive graphics. We will use the Async concurrency library
      and the
      <ulink url="http://github.com/lpw25/async_graphics/">Async_graphics</ulink>
      library, which provides an asynchronous interface to OCaml's built
      in Graphics library. Concurrent programming with Async will be
      explored later in
      <xref linkend="concurrent-programming-with-async"/>; for
      now you can safely ignore the details. You just need to run
      <literal>opam install async_graphics</literal> to get the library
      installed on your system.
    </para>
    <para>
      We will give each shape a <literal>draw</literal> method that
      describes how to draw the shape on the
      <literal>Async_graphics</literal> display:
    </para>
    <programlisting language="ocaml">
(* classes-async/shapes.ml  *)
open Core.Std
open Async.Std
open Async_graphics

type drawable = &lt; draw: unit &gt;
</programlisting>
    <sect2 id="create-some-simple-shapes">
      <title>Create some simple shapes</title>
      <para>
        Now let's add classes for making squares and circles. We include
        an <literal>on_click</literal> method for adding event handlers
        to the shapes.
      </para>
      <programlisting language="ocaml">
(* classes-async/verbose_shapes.ml  *)
open Core.Std
open Async.Std
open Async_graphics

class square w x y = object (self)
  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  val mutable width = w
  method width = width

  method draw = fill_rect x y width width

  method private contains x' y' =
    x &lt;= x' &amp;&amp; x' &lt;= x + width &amp;&amp;
      y &lt;= y' &amp;&amp; y' &lt;= y + width

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev -&gt;
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end
</programlisting>
      <para>
        The <literal>square</literal> class is pretty straightforward,
        and the <literal>circle</literal> class below also looks very
        similar.
      </para>
      <programlisting language="ocaml">
(* classes-async/verbose_shapes.ml (starting from part 1) *)
class circle r x y = object (self)
  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  val mutable radius = r
  method radius = radius

  method draw = fill_circle x y radius

  method private contains x' y' =
    let dx = abs (x' - x) in
    let dy = abs (y' - y) in
    let dist = sqrt (Float.of_int ((dx * dx) + (dy * dy))) in
      dist &lt;= (Float.of_int radius)

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev -&gt;
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end
</programlisting>
      <para>
        These classes have a lot in common, and it would be useful to
        factor out this common functionality into a superclass. We can
        easily move the definitions of <literal>x</literal> and
        <literal>y</literal> into a superclass, but what about
        <literal>on_click</literal>? Its definition depends on
        <literal>contains</literal> which has a different definition in
        each class. The solution is to create a
        <emphasis>virtual</emphasis> class. This class will declare a
        <literal>contains</literal> method, but leave its definition to
        the subclasses.
      </para>
      <para>
        Here is the more succinct definition, starting with a virtual
        <literal>shape</literal> class that implements
        <literal>on_click</literal> and <literal>on_mousedown</literal>.
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 1) *)
class virtual shape x y = object (self)
  method virtual private contains: int -&gt; int -&gt; bool

  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev -&gt;  
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)

  method on_mousedown ?start ?stop f =
    on_mousedown ?start ?stop
      (fun ev -&gt;
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end
</programlisting>
      <para>
        Now we can define <literal>square</literal> and
        <literal>circle</literal> by inheriting from
        <literal>shape</literal>.
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 2) *)
class square w x y = object
  inherit shape x y

  val mutable width = w
  method width = width

  method draw = fill_rect x y width width

  method private contains x' y' = 
    x &lt;= x' &amp;&amp; x' &lt;= x + width &amp;&amp;
    y &lt;= y' &amp;&amp; y' &lt;= y + width 
end 

class circle r x y = object
  inherit shape x y

  val mutable radius = r
  method radius = radius

  method draw = fill_circle x y radius

  method private contains x' y' =
    let dx = abs (x' - x) in
    let dy = abs (y' - y) in
    let dist = sqrt (Float.of_int ((dx * dx) + (dy * dy))) in
    dist &lt;= (Float.of_int radius)
end
</programlisting>
      <para>
        One way to view a <literal>virtual</literal> class is that it is
        like a functor, where the &quot;inputs&quot; are the declared,
        but not defined, virtual methods and fields. The functor
        application is implemented through inheritance, when virtual
        methods are given concrete implementations.
      </para>
    </sect2>
  </sect1>
  <sect1 id="initializers">
    <title>Initializers</title>
    <para>
      You can execute expressions during the instantiation of a class by
      placing them before the object expression or in the initial value
      of a field:
    </para>
    <programlisting language="ocaml">
# script classes/initializer.topscript
$ utop
# class obj x = 
    let () = printf &quot;Creating obj %d\n&quot; x in
    object 
      val field = printf &quot;Initializing field\n&quot;; x
    end ;; 
class obj : int -&gt; object val field : int end
# let o = new obj 3 ;; 

Creating obj 3
Initializing field
val o : obj = &lt;obj&gt;
</programlisting>
    <para>
      However, these expressions are executed before the object has been
      created, and cannot refer to the methods of the object. If you
      need to use an object's methods during instantiation you can use
      an initializer. An initializer is an expression that will be
      executed during instantiation but after the object has been
      created.
    </para>
    <para>
      For example, suppose we wanted to extend our previous shapes
      module with a <literal>growing_circle</literal> class for circles
      that expand when clicked. We could inherit from
      <literal>circle</literal> and used the inherited
      <literal>on_click</literal> to add a handler for click events.
    </para>
    <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 3) *)
class growing_circle r x y = object (self)
  inherit circle r x y

  initializer
    self#on_click (fun _x _y -&gt; radius &lt;- radius * 2)
end
</programlisting>
  </sect1>
  <sect1 id="multiple-inheritance">
    <title>Multiple inheritance</title>
    <para>
      When a class inherits from more than one superclass, it is using
      <emphasis>multiple inheritance</emphasis>. Multiple inheritance
      extends the variety of ways in which classes can be combined, and
      it can be quite useful, particularly with virtual classes.
      However, it can be tricky to use, particularly when the
      inheritance hierarchy is a graph rather than a tree, so it should
      be used with care.
    </para>
    <sect2 id="how-names-are-resolved">
      <title>How names are resolved</title>
      <para>
        The main trickiness of multiple inheritance is due to
        naming—what happens when a method or field with some name is
        defined in more than one class?
      </para>
      <para>
        If there is one thing to remember about inheritance in OCaml, it
        is this: inheritance is like textual inclusion. If there is more
        than one definition for a name, the last definition wins.
      </para>
      <para>
        For example, consider this class which inherits from
        <literal>square</literal> and defines a new
        <literal>draw</literal> method that uses
        <literal>draw_rect</literal> instead of
        <literal>fill_rect</literal> to draw the square.
      </para>
      <programlisting language="ocaml">
(* classes-async/multiple_inheritance.ml (starting from part 1) *)
class square_outline w x y = object
  inherit square w x y
  method draw = draw_rect x y width width
end
</programlisting>
      <para>
        Since the <literal>inherit</literal> declaration comes before
        the method definition, the new <literal>draw</literal> method
        overrides the old one, and the square is drawn using
        <literal>draw_rect</literal>. But, what if we had defined
        <literal>square_outline</literal> as follows?
      </para>
      <programlisting language="ocaml">
(* classes-async/multiple_inheritance_wrong.ml (starting from part 1) *)
class square_outline w x y = object
  method draw = draw_rect x y w w
  inherit square w x y
end
</programlisting>
      <para>
        Here the <literal>inherit</literal> declaration comes after the
        method definition, so the <literal>draw</literal> method from
        <literal>square</literal> will override the other definition,
        and the square will be drawn using <literal>fill_rect</literal>.
      </para>
      <para>
        To reiterate, to understand what inheritance means, replace each
        <literal>inherit</literal> directive with its definition, and
        take the last definition of each method or field. Note that the
        methods and fields added by an inheritance are those listed in
        its class type, so private methods that are hidden by the type
        will not be included.
      </para>
    </sect2>
    <sect2 id="mixins">
      <title>Mixins</title>
      <para>
        When should you use multiple inheritance? If you ask multiple
        people, you're likely to get multiple (perhaps heated) answers.
        Some will argue that multiple inheritance is overly complicated;
        others will argue that inheritance is problematic in general,
        and one should use object composition instead. But regardless of
        who you talk to, you will rarely hear that multiple inheritance
        is great and you should use it widely.
      </para>
      <para>
        In any case, if you're programming with objects, there's one
        general pattern for multiple inheritance that is both useful and
        reasonably simple, the <emphasis>mixin</emphasis> pattern.
        Generically, a <emphasis>mixin</emphasis> is just a virtual
        class that implements a feature based on another one. If you
        have a class that implements methods <emphasis>A</emphasis>, and
        you have a mixin <emphasis>M</emphasis> that provides methods
        <emphasis>B</emphasis> from <emphasis>A</emphasis>, then you can
        inherit from <emphasis>M</emphasis>—&quot;mixing&quot; it in—to
        get features <emphasis>B</emphasis>.
      </para>
      <para>
        That's too abstract, so let's give some examples based on our
        interactive shapes. We may wish to allow a shape to be dragged
        by the mouse. We can define this functionality for any object
        which has mutable <literal>x</literal> and <literal>y</literal>
        fields and an <literal>on_mousedown</literal> method for adding
        event handlers:
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 4) *)
class virtual draggable = object (self)
  method virtual on_mousedown: 
    ?start:unit Deferred.t -&gt; 
    ?stop:unit Deferred.t -&gt; 
    (int -&gt; int -&gt; unit) -&gt; unit
  val virtual mutable x: int  
  val virtual mutable y: int  

  val mutable dragging = false
  method dragging = dragging

  initializer 
    self#on_mousedown 
      (fun mouse_x mouse_y -&gt;
         let offset_x = x - mouse_x in
         let offset_y = y - mouse_y in
         let mouse_up = Ivar.create () in
         let stop = Ivar.read mouse_up in
         dragging &lt;- true;
         on_mouseup ~stop
           (fun _ -&gt;
              Ivar.fill mouse_up ();
              dragging &lt;- false);
         on_mousemove ~stop
           (fun ev -&gt;
              x &lt;- ev.mouse_x + offset_x;
              y &lt;- ev.mouse_y + offset_y))
end
</programlisting>
      <para>
        This allows us to create draggable shapes using multiple
        inheritance.
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 5) *)
class small_square = object
  inherit square 20 40 40
  inherit draggable 
end
</programlisting>
      <para>
        We can also use mixins to create animated shapes. Each animated
        shape has a list of update functions to be called during
        animation. We create an <literal>animated</literal> mixin to
        provide this update list and ensure that the functions in it are
        called regular intervals when the shape is animated.
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 6) *)
class virtual animated span = object (self)
  method virtual on_click: 
    ?start:unit Deferred.t -&gt; 
    ?stop:unit Deferred.t -&gt; 
    (int -&gt; int -&gt; unit) -&gt; unit
  val mutable updates: (int -&gt; unit) list = []
  val mutable step = 0
  val mutable running = false

  method running = running

  method animate =
    step &lt;- 0;
    running &lt;- true;
    let stop =
      Clock.after span
      &gt;&gt;| fun () -&gt; running &lt;- false 
    in
    Clock.every ~stop (Time.Span.of_sec (1.0 /. 24.0))
      (fun () -&gt;
         step &lt;- step + 1;
         List.iter ~f:(fun f -&gt; f step) updates
      )

  initializer
    self#on_click (fun _x _y -&gt; if not self#running then self#animate)
end
</programlisting>
      <para>
        We use initializers to add functions to this update list. For
        example, this class will produce circles that move to the right
        for a second when clicked:
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 7) *)
class my_circle = object
  inherit circle 20 50 50
  inherit animated Time.Span.second
  initializer updates &lt;- [fun _ -&gt; x &lt;- x + 5]
end
</programlisting>
      <para>
        These initializers can also be added using mixins:
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 8) *)
class virtual linear x' y' = object
  val virtual mutable updates: (int -&gt; unit) list
  val virtual mutable x: int
  val virtual mutable y: int

  initializer
    let update _ =
      x &lt;- x + x';
      y &lt;- y + y'
    in
    updates &lt;- update :: updates
end

let pi = (atan 1.0) *. 4.0

class virtual harmonic offset x' y' = object
  val virtual mutable updates: (int -&gt; unit) list
  val virtual mutable x: int
  val virtual mutable y: int

  initializer
    let update step =
      let m = sin (offset +. ((Float.of_int step) *. (pi /. 64.))) in
      let x' = Float.to_int (m *. Float.of_int x') in
      let y' = Float.to_int (m *. Float.of_int y') in
      x &lt;- x + x';
      y &lt;- y + y'
    in
    updates &lt;- update :: updates
end
</programlisting>
      <para>
        Since the <literal>linear</literal> and
        <literal>harmonic</literal> mixins are only used for there
        side-effects, they can be inherited multiple times within the
        same object to produce a variety of different animations.
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 9) *)
class my_square x y = object
  inherit square 40 x y
  inherit draggable
  inherit animated (Time.Span.of_int_sec 5)
  inherit linear 5 0
  inherit harmonic 0.0 7 ~-10
end

let my_circle = object
  inherit circle 30 250 250
  inherit animated (Time.Span.minute)
  inherit harmonic 0.0 10 0
  inherit harmonic (pi /. 2.0) 0 10
end
</programlisting>
    </sect2>
    <sect2 id="displaying-the-animated-shapes">
      <title>Displaying the animated shapes</title>
      <para>
        We finish our shapes module by creating a
        <literal>main</literal> function to draw some shapes on the
        graphical display, and running that function using the Async
        scheduler.
      </para>
      <programlisting language="ocaml">
(* classes-async/shapes.ml (starting from part 10) *)
let main () =
  let shapes = [ 
     (my_circle :&gt; drawable); 
     (new my_square 50 350 :&gt; drawable); 
     (new my_square 50 200 :&gt; drawable);
     (new growing_circle 20 70 70 :&gt; drawable);
  ] in
  let repaint () =
    clear_graph ();
    List.iter ~f:(fun s -&gt; s#draw) shapes;
    synchronize ()
  in 
    open_graph &quot;&quot;;
    auto_synchronize false;
    Clock.every (Time.Span.of_sec (1.0 /. 24.0)) repaint

let () = never_returns (Scheduler.go_main ~main ())
</programlisting>
      <para>
        Our <literal>main</literal> function creates a list of shapes to
        be displayed and defines a <literal>repaint</literal> function
        that actually draws them on the display. We then open a
        graphical display and ask Async to run
        <literal>repaint</literal> at regular intervals.
      </para>
      <para>
        Finally, build the binary by linking against the
        <literal>async_graphics</literal> package, which will pull in
        all the other dependencies.
      </para>
      <programlisting>
# running classes-async/build_shapes.out.sh
$ corebuild -pkg async_graphics shapes.native
</programlisting>
      <para>
        When you run the binary, a new graphical window should appear
        (on MacOS X, you will need to install the X11 package first,
        which you will be prompted for). Try clicking on the various
        widgets, and gasp in awe at the sophisticated animations that
        unfold as a result.
      </para>
      <para>
        The graphics library described here is the one built into OCaml,
        and is more useful as a learning tool than anything else. There
        are several third-party libraries that provide more
        sophisticated bindings to various graphics subsystems.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <ulink url="http://lablgtk.forge.ocamlcore.org">Lablgtk</ulink>
            is a strongly-typed interface to the GTK widget library.
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="https://forge.ocamlcore.org/projects/lablgl/">LablGL</ulink>
            is an interface between OCaml and OpenGL, a widely supported
            standard for 3D rendering.
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://ocsigen.org/js_of_ocaml/api/Js">js_of_ocaml</ulink>
            compiles OCaml code to Javascript, and has bindings to
            WebGL. This is the emerging standard for 3D rendering in web
            browsers.
          </para>
        </listitem>
      </itemizedlist>
      <note>
      <title>
      Production note
      </title>
      <para>
        This chapter contains significant external contributions from
        Leo White.
      </para>
      </note>

    </sect2>
  </sect1>
</chapter></part><part label="II"><title>Tools and Techniques</title><partintro><para>Part II builds on the basics by working through useful tools and techniques for using OCaml. 
     Here you'll pick up useful techniques for building networked systems, as well as functional 
     design patterns that help combine different features of the language to good effect.</para><para>The focus throughout this section is on networked systems, and among other examples we'll 
      build a running example that will perform Internet queries using the DuckDuckGo search engine.</para></partintro><chapter id="maps-and-hash-tables">
  <title>Maps and Hash Tables</title>
  <para>
    Lots of programming problems require dealing with data organized as
    key/value pairs. Maybe the simplest way of representing such data in
    OCaml is an <emphasis>association list</emphasis>, which is simply a
    list of pairs of keys and values. For example, you could represent a
    mapping between the 10 digits and their English names as follows.
  </para>
  <programlisting language="ocaml">
...part 1 of maps-and-hash-tables/main.topscript
# let digit_alist =
    [ 0, &quot;zero&quot;; 1, &quot;one&quot;; 2, &quot;two&quot;  ; 3, &quot;three&quot;; 4, &quot;four&quot;
    ; 5, &quot;five&quot;; 6, &quot;six&quot;; 7, &quot;seven&quot;; 8, &quot;eight&quot;; 9, &quot;nine&quot; ]
  ;; 
val digit_alist : (int * string) list =
  [(0, &quot;zero&quot;); (1, &quot;one&quot;); (2, &quot;two&quot;); (3, &quot;three&quot;); (4, &quot;four&quot;);
   (5, &quot;five&quot;); (6, &quot;six&quot;); (7, &quot;seven&quot;); (8, &quot;eight&quot;); (9, &quot;nine&quot;)]
</programlisting>
  <para>
    We can use functions from the <literal>List.Assoc</literal> module
    to manipulate such an association list.
  </para>
  <programlisting language="ocaml">
...part 2 of maps-and-hash-tables/main.topscript
# List.Assoc.find digit_alist 6;; 
- : string option = Some &quot;six&quot;
# List.Assoc.find digit_alist 22;; 
- : string option = None
# List.Assoc.add digit_alist 0 &quot;zilch&quot;;; 
- : (int, string) List.Assoc.t =
[(0, &quot;zilch&quot;); (1, &quot;one&quot;); (2, &quot;two&quot;); (3, &quot;three&quot;); (4, &quot;four&quot;);
 (5, &quot;five&quot;); (6, &quot;six&quot;); (7, &quot;seven&quot;); (8, &quot;eight&quot;); (9, &quot;nine&quot;)]
</programlisting>
  <para>
    Association lists are simple and easy to use, but their performance
    is not ideal, since almost every non-trivial operation on an
    association list requires a linear-time scan of the list.
  </para>
  <para>
    In this chapter, we'll talk about two more efficient alternatives to
    association lists: <emphasis>maps</emphasis> and <emphasis>hash
    tables</emphasis>. A map is an immutable tree-based data structure
    where most operations take time logarithmic in the size of the map,
    whereas a hash table is a mutable data structure where most
    operations have constant time complexity. We'll describe both of
    these data structures in detail, and provide some advice as to how
    to choose between them.
  </para>
  <sect1 id="maps">
    <title>Maps</title>
    <para>
      Let's consider an example of how one might use a map in practice.
      In <xref linkend="files-modules-and-programs"/>, we
      showed a module <literal>Counter</literal> for keeping frequency
      counts on a set of strings. Here's the interface.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-fast/counter.mli  *)
open Core.Std

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(* Converts the set of frequency counts to an association list.  Every strings
   in the list will show up at most once, and the integers will be at least
   1. *)
val to_list : t -&gt; (string * int) list
</programlisting>
    <para>
      The intended behavior here is straightforward.
      <literal>Counter.empty</literal> represents an empty collection of
      frequency counts; <literal>touch</literal> increments the
      frequency count of the specified string by 1; and
      <literal>to_list</literal> returns the list of non-zero
      frequencies.
    </para>
    <para>
      Here's the implementation.
    </para>
    <programlisting language="ocaml">
(* files-modules-and-programs-freq-fast/counter.ml  *)
open Core.Std

type t = int String.Map.t

let empty = String.Map.empty

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t ~key:s ~data:(count + 1)
</programlisting>
    <para>
      Note that in some places the above code refers to
      <literal>String.Map.t</literal>, and in others
      <literal>Map.t</literal>. This has to do with the fact that maps
      are implemented as ordered binary trees, and as such, need a way
      of comparing keys.
    </para>
    <para>
      To deal with this, a map, once created, stores the necessary
      comparison function within the data structure. Thus, operations
      like <literal>Map.find</literal> or <literal>Map.add</literal>
      that access the contents of a map or create a new map from an
      existing one, do so by using the comparison function embedded
      within the map.
    </para>
    <para>
      But in order to get a map in the first place, you need to get your
      hands on the comparison function somehow. For this reason, modules
      like <literal>String</literal> contain a <literal>Map</literal>
      sub-module that have values like
      <literal>String.Map.empty</literal> and
      <literal>String.Map.of_alist</literal> that are specialized to
      strings, and thus have access to a string comparison function.
      Such a <literal>Map</literal> sub-module is included in every
      module that satisfies the <literal>Comparable.S</literal>
      interface from Core.
    </para>
    <sect2 id="creating-maps-with-comparators">
      <title>Creating maps with comparators</title>
      <para>
        The specialized <literal>Map</literal> sub-module is convenient,
        but it's not the only way of creating a
        <literal>Map.t</literal>. The information required to compare
        values of a given type is wrapped up in a value called a
        <emphasis>comparator</emphasis>, that can be used to create maps
        using the <literal>Map</literal> module directly.
      </para>
      <programlisting language="ocaml">
...part 3 of maps-and-hash-tables/main.topscript
# let digit_map = Map.of_alist_exn digit_alist
                     ~comparator:Int.comparator;; 
val digit_map : (int, string, Int.comparator) Map.t = &lt;abstr&gt;
# Map.find digit_map 3;; 
- : string option = Some &quot;three&quot;
</programlisting>
      <para>
        The above uses <literal>Map.of_alist_exn</literal> which creates
        a map from an association list, throwing an exception if there
        are duplicate keys in the list.
      </para>
      <para>
        The comparator is only required for operations that create maps
        from scratch. Operations that update an existing map simply
        inherit the comparator of the map they start with.
      </para>
      <programlisting language="ocaml">
...part 4 of maps-and-hash-tables/main.topscript
# let zilch_map = Map.add digit_map ~key:0 ~data:&quot;zilch&quot;;; 
val zilch_map : (int, string, Int.comparator) Map.t = &lt;abstr&gt;
</programlisting>
      <para>
        The type <literal>Map.t</literal> has three type parameters: one
        for the key, one for the value, and one to identify the
        comparator. Indeed, the type <literal>'a Int.Map.t</literal> is
        just a type alias for
        <literal>(int,'a,Int.comparator) Map.t</literal>
      </para>
      <para>
        Including the comparator in the type is important because
        operations that work on multiple maps at the same time often
        require that the maps share their comparison function. Consider,
        for example, <literal>Map.symmetric_diff</literal>, which
        computes a summary of the differences between two maps.
      </para>
      <programlisting language="ocaml">
...part 5 of maps-and-hash-tables/main.topscript
# let left = String.Map.of_alist_exn [&quot;foo&quot;,1; &quot;bar&quot;,3; &quot;snoo&quot;, 0]
  let right = String.Map.of_alist_exn [&quot;foo&quot;,0; &quot;snoo&quot;, 0]
  let diff = Map.symmetric_diff ~data_equal:Int.equal left right
  ;; 
val left : int String.Map.t = &lt;abstr&gt;
val right : int String.Map.t = &lt;abstr&gt;
val diff :
  (string * [ `Left of int | `Right of int | `Unequal of int * int ]) list =
  [(&quot;foo&quot;, `Unequal (1, 0)); (&quot;bar&quot;, `Left 3)]
</programlisting>
      <para>
        The type of <literal>Map.symmetric_diff</literal>, shown below,
        requires that the two maps it compares have the same comparator
        type. Each comparator has a fresh abstract type, so the type of
        a comparator identifies the comparator uniquely.
      </para>
      <programlisting language="ocaml">
...part 6 of maps-and-hash-tables/main.topscript
# Map.symmetric_diff;; 
- : ('k, 'v, 'cmp) Map.t -&gt;
    ('k, 'v, 'cmp) Map.t -&gt;
    data_equal:('v -&gt; 'v -&gt; bool) -&gt;
    ('k * [ `Left of 'v | `Right of 'v | `Unequal of 'v * 'v ]) list
= &lt;fun&gt;
</programlisting>
      <para>
        This constraint is important because the algorithm that
        <literal>Map.symmetric_diff</literal> uses depends on the fact
        that both maps have the same comparator.
      </para>
      <para>
        We can create a new comparator using the
        <literal>Comparator.Make</literal> functor, which takes as its
        input a module containing the type of the object to be compared,
        sexp-converter functions, and a comparison function. The sexp
        converters are included in the comparator to make it possible
        for users of the comparator to generate better error messages.
        Here's an example.
      </para>
      <programlisting language="ocaml">
...part 7 of maps-and-hash-tables/main.topscript
# module Reverse = Comparator.Make(struct
    type t = string
    let sexp_of_t = String.sexp_of_t
    let t_of_sexp = String.t_of_sexp
    let compare x y = String.compare y x
  end);; 
module Reverse :
  sig
    type t = string
    val compare : t -&gt; t -&gt; int
    val t_of_sexp : Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
    type comparator
    val comparator : (t, comparator) Comparator.t_
  end
</programlisting>
      <para>
        As you can see below, both <literal>Reverse.comparator</literal>
        and <literal>String.comparator</literal> can be used to create
        maps with a key type of <literal>string</literal>.
      </para>
      <programlisting language="ocaml">
...part 8 of maps-and-hash-tables/main.topscript
# let alist = [&quot;foo&quot;, 0; &quot;snoo&quot;, 3];; 
val alist : (string * int) list = [(&quot;foo&quot;, 0); (&quot;snoo&quot;, 3)]
# let ord_map = Map.of_alist_exn ~comparator:String.comparator alist;; 
val ord_map : (string, int, String.comparator) Map.t = &lt;abstr&gt;
# let rev_map = Map.of_alist_exn ~comparator:Reverse.comparator alist;; 
val rev_map : (string, int, Reverse.comparator) Map.t = &lt;abstr&gt;
</programlisting>
      <para>
        <literal>Map.min_elt</literal> returns the key and value for the
        smallest key in the map, which lets us see that these two maps
        do indeed use different comparison functions.
      </para>
      <programlisting language="ocaml">
...part 9 of maps-and-hash-tables/main.topscript
# Map.min_elt ord_map;; 
- : (string * int) option = Some (&quot;foo&quot;, 0)
# Map.min_elt rev_map;; 
- : (string * int) option = Some (&quot;snoo&quot;, 3)
</programlisting>
      <para>
        And accordingly, if we try to use
        <literal>Map.symmetric_diff</literal> on these two maps, we'll
        get a compile-timer error.
      </para>
      <programlisting language="ocaml">
...part 10 of maps-and-hash-tables/main.topscript
# Map.symmetric_diff ord_map rev_map;; 
Characters 27-34:
Error: This expression has type (string, int, Reverse.comparator) Map.t
       but an expression was expected of type
         (string, int, String.comparator) Map.t
       Type Reverse.comparator is not compatible with type String.comparator 
</programlisting>
    </sect2>
    <sect2 id="trees">
      <title>Trees</title>
      <para>
        As we've discussed, maps carry within them the comparator that
        they were created with. Sometimes, often for space efficiency
        reasons, you want a version of the map data structure that
        doesn't include the comparator. You can get such a
        representation with <literal>Map.to_tree</literal>, which
        returns just the tree that the map is built out of, and not
        including the comparator.
      </para>
      <programlisting language="ocaml">
...part 11 of maps-and-hash-tables/main.topscript
# let ord_tree = Map.to_tree ord_map;; 
val ord_tree : (string, int, String.comparator) Map.Tree.t = &lt;abstr&gt;
</programlisting>
      <para>
        Even though a <literal>Map.Tree.t</literal> doesn't physically
        include a comparator, it does include the comparator in its
        type. This is what is known as a <emphasis>phantom type
        parameter</emphasis>, because it reflects something about the
        logic of the value in question, even though it doesn't
        correspond to any values directly represented in the underlying
        physical structure of the value.
      </para>
      <para>
        Since the comparator isn't included in the tree, we need to
        provide the comparator explicitly when we, say, search for a
        key, as shown below.
      </para>
      <programlisting language="ocaml">
...part 12 of maps-and-hash-tables/main.topscript
# Map.Tree.find ~comparator:String.comparator ord_tree &quot;snoo&quot;;; 
- : int option = Some 3
</programlisting>
      <para>
        The algorithm of <literal>Map.Tree.find</literal> depends on the
        fact that it's using the same comparator when looking a value up
        as you were when you stored it. That's the invariant that the
        phantom type is there to enforce. As you can see below, using
        the wrong comparator will lead to a type error.
      </para>
      <programlisting language="ocaml">
...part 13 of maps-and-hash-tables/main.topscript
# Map.Tree.find ~comparator:Reverse.comparator ord_tree &quot;snoo&quot;;; 
Characters 45-53:
Error: This expression has type (string, int, String.comparator) Map.Tree.t
       but an expression was expected of type
         (string, int, Reverse.comparator) Map.Tree.t
       Type String.comparator is not compatible with type Reverse.comparator 
</programlisting>
    </sect2>
    <sect2 id="the-polymorphic-comparator">
      <title>The polymorphic comparator</title>
      <para>
        We don't need to generate specialized comparators for every type
        we want to build a map on. We can instead use a comparator based
        on OCaml's built-in polymorphic comparison function, which was
        discussed in <xref linkend="lists-and-patterns"/>.
        This comparator is found in the
        <literal>Comparator.Poly</literal> module, allowing us to write:
      </para>
      <programlisting language="ocaml">
...part 14 of maps-and-hash-tables/main.topscript
# Map.of_alist_exn ~comparator:Comparator.Poly.comparator digit_alist;; 
- : (int, string, Comparator.Poly.comparator) Map.t = &lt;abstr&gt;
</programlisting>
      <para>
        Or, equivalently:
      </para>
      <programlisting language="ocaml">
...part 15 of maps-and-hash-tables/main.topscript
# Map.Poly.of_alist_exn digit_alist;; 
- : (int, string) Map.Poly.t = &lt;abstr&gt;
</programlisting>
      <para>
        Note that maps based on the polymorphic comparator are not
        equivalent to those based on the type-specific comparators from
        the point of view of the type system. Thus, the compiler rejects
        the following:
      </para>
      <programlisting language="ocaml">
...part 16 of maps-and-hash-tables/main.topscript
# Map.symmetric_diff (Map.Poly.singleton 3 &quot;three&quot;)
                     (Int.Map.singleton  3 &quot;four&quot; ) ;; 
Characters 72-99:
Error: This expression has type
         string Int.Map.t = (int, string, Int.comparator) Map.t
       but an expression was expected of type
         (int, string, Comparator.Poly.comparator) Map.t
       Type Int.comparator is not compatible with type
         Comparator.Poly.comparator 
</programlisting>
      <para>
        This is rejected for good reason: there's no guarantee that the
        comparator associated with a given type will order things in the
        same way that polymorphic compare does.
      </para>
      <note>
      <title> 
      <literal>=</literal>, <literal>==</literal>, and
      <literal>phys_equal</literal>
      </title>
      <para>
        If you come from a C/C++ background, you'll probably reflexively
        use <literal>==</literal> to test two values for equality. In
        OCaml, the <literal>==</literal> operator tests for
        <emphasis>physical</emphasis> equality while the
        <literal>=</literal> operator tests for
        <emphasis>structural</emphasis> equality.
      </para>
      <para>
        The physical equality test will match if two data structures
        have precisely the same pointer in memory. Two data structures
        that have identical contents but are constructed separately will
        not match using <literal>==</literal>.
      </para>
      <para>
        The <literal>=</literal> structural equality operator
        recursively inspects each field in the two values and tests them
        individually for equality. Crucially, if your data structure is
        cyclical (that is, a value recursively points back to another
        field within the same structure), the <literal>=</literal>
        operator will never terminate, and your program will hang! You
        therefore must use the physical equality operator or write a
        custom comparison function when comparing recursive values.
      </para>
      <para>
        It's quite easy to mix up the use of <literal>=</literal> and
        <literal>==</literal>, so Core disables the
        <literal>==</literal> operator and provides the more explicit
        <literal>phys_equal</literal> function instead. You'll see a
        type error if you use <literal>==</literal> anywhere in code
        that opens <literal>Core.Std</literal>.
      </para>
      <programlisting language="ocaml">
# script maps-and-hash-tables/core_phys_equal.topscript
$ utop
# open Core.Std ;; 
# 1 == 2 ;; 
Characters -1-1:
Error: This expression has type int but an expression was expected of type
         [ `Consider_using_phys_equal ]
# phys_equal 1 2 ;; 
- : bool = false
</programlisting>
      <para>
        If you feel like hanging your OCaml interpreter, you can verify
        what happens with recursive values and structural equality for
        yourself:
      </para>
      <programlisting language="ocaml">
# script maps-and-hash-tables/phys_equal.rawscript
$ utop
# type t1 = { foo1:int; bar1:t2 } and t2 = { foo2:int; bar2:t1 } ;;
type t1 = { foo1 : int; bar1 : t2; }
and t2 = { foo2 : int; bar2 : t1; }
# let rec v1 = { foo1=1; bar1=v2 } and v2 = { foo2=2; bar2=v1 } ;;
&lt;lots of text&gt;
# v1 == v1;;
- : bool = true
# phys_equal v1 v1;;
- : bool = true
# v1 = v1 ;;
&lt;press ^Z and kill the process now&gt;
</programlisting>
      </note>
    </sect2>
    <sect2 id="sets">
      <title>Sets</title>
      <para>
        Sometimes, instead of keeping track of a set of key/value pairs,
        you just want a data-type for keeping track of a set of keys.
        You could build this on top of a map by representing a set of
        values by a map whose data type is <literal>unit</literal>. But
        a more idiomatic (and efficient) solution is to use Core's set
        type, which is similar in design and spirit to the map type,
        while having an API better tuned to working with sets, and a
        lower memory footprint. Here's a simple example:
      </para>
      <programlisting language="ocaml">
...part 17 of maps-and-hash-tables/main.topscript
# let dedup ~comparator l =
    List.fold l ~init:(Set.empty ~comparator) ~f:Set.add
    |&gt; Set.to_list
  ;; 
val dedup :
  comparator:('a, 'b) Core_kernel.Comparator.t_ -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
# dedup ~comparator:Int.comparator [8;3;2;3;7;8;10];; 
- : int list = [2; 3; 7; 8; 10]
</programlisting>
      <para>
        In addition to the operators you would expect to have for maps,
        sets support the traditional set operations, including union,
        intersection and set difference. And, as with maps, we can
        create sets based on type-specific comparators or on the
        polymorphic comparator.
      </para>
      <warning> <title> 
      The perils of polymorphic compare
      </title>
      <para>
        Polymorphic compare is highly convenient, but it has serious
        downsides as well, and should be used with care. In particular,
        polymorphic compare has a fixed algorithm for comparing values
        of any type, and that algorithm can sometimes yield surprising
        results.
      </para>
      <para>
        To understand what's wrong with polymorphic compare, you need to
        understand a bit about how it works. Polymorphic compare is
        <emphasis>structural</emphasis>, in that it operates directly on
        the runtime-representation of OCaml values, walking the
        structure of the values in question without regard for their
        type.
      </para>
      <para>
        This is convenient because it provides a comparison function
        that works for most OCaml values, and largely behaves as you
        would expect. For example, on <literal>int</literal>s and
        <literal>float</literal>s it acts as you would expect a numeric
        comparison function to act. For simple containers like strings
        and lists and arrays it operates as a lexicographic comparison.
        And except for closures and values from outside of the OCaml
        heap, it works on almost every OCaml type.
      </para>
      <para>
        But sometimes, a structural comparison is not what you want.
        Sets are a great example of this. Consider the following two
        sets.
      </para>
      <programlisting language="ocaml">
...part 18 of maps-and-hash-tables/main.topscript
# let (s1,s2) = (Int.Set.of_list [1;2],
                 Int.Set.of_list [2;1]);; 
val s1 : Int.Set.t = &lt;abstr&gt;
val s2 : Int.Set.t = &lt;abstr&gt;
</programlisting>
      <para>
        Logically, these two sets should be equal, and that's the result
        that you get if you call <literal>Set.equal</literal> on them.
      </para>
      <programlisting language="ocaml">
...part 19 of maps-and-hash-tables/main.topscript
# Set.equal s1 s2;; 
- : bool = true
</programlisting>
      <para>
        But because the elements were added in different orders, the
        layout of the trees underlying the sets will be different. As
        such, a structural comparison function will conclude that
        they're different.
      </para>
      <para>
        Let's see what happens if we use polymorphic compare to test for
        equality by way of the <literal>=</literal> operator. Comparing
        the maps directly will fail at runtime because the comparators
        stored within the sets contain function values.
      </para>
      <programlisting language="ocaml">
...part 20 of maps-and-hash-tables/main.topscript
# s1 = s2;; 
Exception: (Invalid_argument &quot;equal: functional value&quot;).
</programlisting>
      <para>
        We can however use the function <literal>Set.to_tree</literal>
        to expose the underlying tree without the attached comparator.
      </para>
      <programlisting language="ocaml">
...part 21 of maps-and-hash-tables/main.topscript
# Set.to_tree s1 = Set.to_tree s2;; 
- : bool = false
</programlisting>
      <para>
        This can cause real and quite subtle bugs. If, for example, you
        use a map whose keys contain sets, then the map built with the
        polymorphic comparator will behave incorrectly, separating out
        keys that should be aggregated together. Even worse, it will
        work sometimes and fail others, since if the sets are built in a
        consistent order, then they will work as expected, but once the
        order changes, the behavior will change.
      </para>
      <para>
        For this reason, it's preferable to avoid polymorphic compare
        for serious applications.
      </para>
      </warning>
    </sect2>
    <sect2 id="satisfying-the-comparable.s-interface">
      <title>Satisfying the <literal>Comparable.S</literal>
      interface</title>
      <para>
        Core's <literal>Comparable.S</literal> interface includes a lot
        of useful functionality, including support for working with maps
        and sets. In particular, <literal>Comparable.S</literal>
        requires the presence of the <literal>Map</literal> and
        <literal>Set</literal> sub-modules as well as a comparator.
      </para>
      <para>
        <literal>Comparable.S</literal> is satisfied by most of the
        types in Core, but the question arises of how to satisfy the
        comparable interface for a new type that you design. Certainly
        implementing all of the required functionality from scratch
        would be an absurd amount of work.
      </para>
      <para>
        The module <literal>Comparable</literal> contains a number of
        functors to help you do just this. The simplest one of these is
        <literal>Comparable.Make</literal>, which takes as an input any
        module that satisfies the following interface:
      </para>
      <programlisting language="ocaml">
(* maps-and-hash-tables/comparable.ml  *)
module type Comparable = sig
  type t
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
  val compare : t -&gt; t -&gt; int
end
</programlisting>
      <para>
        In other words, it expects a type with a comparison function as
        well as functions for converting to and from
        <emphasis>s-expressions</emphasis>. S-expressions are a
        serialization format used commonly in Core, and are required
        here to enable better error messages. We'll discuss
        s-expressions more in
        <xref linkend="data-serialization-with-s-expressions"/>,
        but in the meantime, we can just use the
        <literal>with sexp</literal> declaration that comes from the
        <literal>sexplib</literal> syntax extension to create
        s-expression converters for us.
      </para>
      <para>
        The following example shows how this all fits together,
        following the same basic pattern for using functors described in
        <xref linkend="extending-modules"/>.
      </para>
      <programlisting language="ocaml">
# script maps-and-hash-tables/main-22.rawscript
$ utop
# module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp
      let compare t1 t2 =
        let c = Int.Set.compare t1.foo t2.foo in
        if c &lt;&gt; 0 then c else String.compare t1.bar t2.bar
    end
    include T
    include Comparable.Make(T)
  end;;
module Foo_and_bar :
sig
  type t = { foo : Int.Set.t; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

    ...

end
</programlisting>
      <para>
        We don't include the full response from the top-level because it
        is quite lengthy, but <literal>Foo_and_bar</literal> does
        satisfy <literal>Comparable.S</literal>.
      </para>
      <para>
        In the above, we wrote the comparison function by hand, but this
        isn't strictly necessary. Core ships with a syntax extension
        called <literal>comparelib</literal> which will create a
        comparison function from a type definition. Using it, we can
        rewrite the above example as follows.
      </para>
      <programlisting language="ocaml">
# script maps-and-hash-tables/main-23.rawscript
$ utop
# module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp, compare
    end
    include T
    include Comparable.Make(T)
  end;;
module Foo_and_bar :
sig
  type t = { foo : Int.Set.t; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

  ...

end
</programlisting>
      <para>
        The comparison function created by <literal>comparelib</literal>
        for a given type will call out to the comparison functions for
        its component types. As a result, the <literal>foo</literal>
        field will be compared using <literal>Int.Set.compare</literal>.
        This is different, and saner, than the structural comparison
        done by polymorphic compare.
      </para>
      <para>
        If you want your comparison function to behave in a specific
        way, you should still write your own comparison function by
        hand; but if all you want is a total order suitable for creating
        maps and sets with, then <literal>comparelib</literal> is a good
        way to go.
      </para>
      <para>
        You can also satisfy the <literal>Comparable.S</literal>
        interface using polymorphic compare.
      </para>
      <programlisting language="ocaml">
# script maps-and-hash-tables/main-24.rawscript
$ utop
# module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp
    end
    include T
    include Comparable.Poly(T)
  end;;
module Foo_and_bar :
sig
  type t = { foo : int; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

  ...

end

</programlisting>
      <para>
        That said, for reasons we discussed earlier, polymorphic compare
        should be used sparingly.
      </para>
    </sect2>
  </sect1>
  <sect1 id="hash-tables">
    <title>Hash tables</title>
    <para>
      Hash tables are the imperative cousin of maps. We walked over a
      basic hash table implementation in
      <xref linkend="imperative-programming-1"/>, so in this
      section we'll mostly discuss the pragmatics of Core's
      <literal>Hashtbl</literal> module. We'll cover this material more
      briefly than we did with maps, because many of the concepts are
      shared.
    </para>
    <para>
      Hash tables differ from maps in a few key ways. First, hash tables
      are mutable, meaning that adding a key/value pair to a hash table
      modifies the table, rather than creating a new table with the
      binding added. Second, hash tables generally have better
      time-complexity than maps, providing constant time lookup and
      modifications as opposed to logarithmic for maps. And finally,
      just as maps depend on having a comparison function for creating
      the ordered binary tree that underlies a map, hash tables depend
      on having a <emphasis>hash function</emphasis>,
      <emphasis>i.e.</emphasis>, a function for converting a key to an
      integer.
    </para>
    <warning> <title> 
    Time complexity of hash tables
    </title>
    <para>
      The statement that hash tables provide constant-time access hides
      some complexities. First of all, any hash table implementation,
      OCaml's included, needs to resize the table when it gets too full.
      A resize requires allocating a new backing array for the hash
      table and copying over all entries, and so it is quite an
      expensive operation. That means adding a new element to the table
      is only <emphasis>amortized</emphasis> constant, which is to say,
      it's constant on average over a long sequence of additions, but
      some of the individual additions can be quite expensive.
    </para>
    <para>
      Another hidden cost of hash tables has to do with the hash
      function you use. If you end up with a pathologically bad hash
      function that hashes all of your data to the same number, then all
      of your insertions will hash to the same underlying bucket,
      meaning you no longer get constant-time access at all. Core's hash
      table implementation uses binary trees for the hash-buckets, so
      this case only leads to logarithmic time, rather than quadratic
      for a traditional hash table.
    </para>
    <para>
      The logarithmic behavior of Core's hash tables in the presence of
      hash collisions also helps protect against some denial-of-service
      attacks. One well-known type of attack is to send queries to a
      service with carefully chosen keys to cause many collisions. This,
      in combination with the the quadratic behavior of hash tables, can
      cause the service to become unresponsive due to high CPU load.
      Core's hash tables would be much less susceptible to such an
      attack, because the amount of degradation would be far less.
    </para>
    </warning>
    <para>
      When creating a hash table, we need to provide a value of type
      <emphasis>hashable</emphasis> which includes among other things
      the function for hashing the key type. This is analogous to the
      comparator used for creating maps.
    </para>
    <programlisting language="ocaml">
...part 25 of maps-and-hash-tables/main.topscript
# let table = Hashtbl.create ~hashable:String.hashable ();; 
val table : (string, '_a) Hashtbl.t = &lt;abstr&gt;
# Hashtbl.replace table ~key:&quot;three&quot; ~data:3;; 
- : unit = ()
# Hashtbl.find table &quot;three&quot;;; 
- : int option = Some 3
</programlisting>
    <para>
      The <literal>hashable</literal> value is included as part of the
      <literal>Hashable.S</literal> interface, which is satisfied by
      most types in Core. The <literal>Hashable.S</literal> interface
      also includes a <literal>Table</literal> sub-module which provides
      more convenient creation functions.
    </para>
    <programlisting language="ocaml">
...part 26 of maps-and-hash-tables/main.topscript
# let table = String.Table.create ();; 
val table : '_a String.Table.t = &lt;abstr&gt;
</programlisting>
    <para>
      There is also a polymorphic <literal>hashable</literal> value,
      corresponding to the polymorphic hash function provided by the
      OCaml runtime, for cases where you don't have a hash function for
      your specific type.
    </para>
    <programlisting language="ocaml">
...part 27 of maps-and-hash-tables/main.topscript
# let table = Hashtbl.create ~hashable:Hashtbl.Poly.hashable ();; 
val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;
</programlisting>
    <para>
      Or, equivalently:
    </para>
    <programlisting language="ocaml">
...part 28 of maps-and-hash-tables/main.topscript
# let table = Hashtbl.Poly.create ();; 
val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;
</programlisting>
    <para>
      Note that, unlike the comparators used with maps and sets,
      hashables don't show up in the type of a
      <literal>Hashtbl.t</literal>. That's because hash tables don't
      have operations that operate on multiple hash tables that depend
      on those tables having the same hash function, in the way that
      <literal>Map.symmetric_diff</literal> and
      <literal>Set.union</literal> depend on their arguments using the
      same comparison function.
    </para>
    <warning> <title> 
    Collisions with the polymorphic hash function
    </title>
    <para>
      OCaml's polymorphic hash function works by walking over the
      data-structure its given using a breadth-first traversal that is
      bounded in the number of nodes its willing to traverse. By
      default, that bound is set at 10 &quot;meaningful&quot; nodes,
      essentially...
    </para>
    <para>
      The bound on the traversal, means that the hash function may
      ignore part of the data-structure, and this can lead to
      pathological cases where every value you store has the same hash
      value. By default, OCaml's hash function will stop after it has
      found ten nodes it can extract data from. We'll demonstrate this
      below, using the function <literal>List.range</literal> to
      allocate lists of integers of different length.
    </para>
    <programlisting language="ocaml">
...part 29 of maps-and-hash-tables/main.topscript
# Caml.Hashtbl.hash (List.range 0 9);; 
- : int = 209331808
# Caml.Hashtbl.hash (List.range 0 10);; 
- : int = 182325193
# Caml.Hashtbl.hash (List.range 0 11);; 
- : int = 182325193
# Caml.Hashtbl.hash (List.range 0 100);; 
- : int = 182325193
</programlisting>
    <para>
      As you can see, the hash function stops after the first 10
      elements. The same can happen with any large data structure,
      including records and arrays. When building hash functions over
      large custom data-structures, it is generally a good idea to write
      one's own hash function, <emphasis>e.g.</emphasis>,
    </para>
    </warning>

    <sect2 id="satisfying-the-hashable.s-interface">
      <title>Satisfying the <literal>Hashable.S</literal>
      interface</title>
      <para>
        Most types in Core satisfy the <literal>Hashable.S</literal>
        interface, but as with the <literal>Comparable.S</literal>
        interface, the question remains of how one should satisfy this
        interface with a new type. Again, the answer is to use a functor
        to build the necessary functionality; in this case,
        <literal>Hashable.Make</literal>. Note that we use OCaml's
        <literal>lxor</literal> operator for doing the
        &quot;logical&quot; (<emphasis>i.e.</emphasis>, bit-wise)
        exclusive-or of the hashes from the component values.
      </para>
      <programlisting language="ocaml">
# script maps-and-hash-tables/main-30.rawscript
$ utop
# module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Hashable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp, compare
      let hash t =
        (Int.hash t.foo) lxor (String.hash t.bar)
    end
    include T
    include Hashable.Make(T)
  end;;
module Foo_and_bar :
sig
  type t = { foo : int; bar : string; }
  module Hashable : sig type t = t end
  val hash : t -&gt; int
  val compare : t -&gt; t -&gt; int
  val hashable : t Pooled_hashtbl.Hashable.t

  ...

end
</programlisting>
      <para>
        Note that in order to satisfy hashable, one also needs to
        provide a comparison function. That's because Core's hash tables
        use an ordered binary tree data-structure for the hash-buckets,
        so that performance of the table degrades gracefully in the case
        of pathologically bad choice of hash function.
      </para>
      <para>
        There is currently no analogue of <literal>comparelib</literal>
        for auto-generation of hash-functions, so you do need to either
        write the hash-function by hand, or use the built-in polymorphic
        hash function, <literal>Hashtbl.hash</literal>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="choosing-between-maps-and-hash-tables">
    <title>Choosing between maps and hash tables</title>
    <para>
      Maps and hash tables overlap enough in functionality that it's not
      always clear when to choose one or the other. Maps, by virtue of
      being immutable, are generally the default choice in OCaml. OCaml
      also has good support for imperative programming, though, and when
      programming in an imperative idiom, hash tables are often the more
      natural choice.
    </para>
    <para>
      Programming idioms aside, there are significant performance
      differences between maps and hash tables as well. For code that is
      dominated by updates and lookups, hash tables are a clear
      performance win, and the win is clearer the larger the size of the
      tables.
    </para>
    <para>
      The best way of answering a performance question is by running a
      benchmark, so let's do just that. The following benchmark uses the
      <literal>core_bench</literal> library, and it compares maps and
      hash tables under a very simple workload. Here, we're keeping
      track of a set of 1000 different integer keys, and cycling over
      the keys and updating the values they contain. Note that we use
      the <literal>Map.change</literal> and
      <literal>Hashtbl.change</literal> functions to update the
      respective data structures.
    </para>
    <programlisting language="ocaml">
(* maps-and-hash-tables/map_vs_hash.ml  *)
open Core.Std
open Core_bench.Std

let map_iter ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0 then ()
    else loop (i - 1)
           (Map.change map (i mod num_keys) (fun current -&gt;
              Some (1 + Option.value ~default:0 current)))
  in
  loop iterations Int.Map.empty

let table_iter ~num_keys ~iterations =
  let table = Int.Table.create ~size:num_keys () in
  let rec loop i =
    if i &lt;= 0 then ()
    else (
      Hashtbl.change table (i mod num_keys) (fun current -&gt;
        Some (1 + Option.value ~default:0 current));
      loop (i - 1)
    )
  in
  loop iterations

let tests ~num_keys ~iterations =
  let test name f = Bench.Test.create f ~name in
  [ test &quot;map&quot;   (fun () -&gt; map_iter   ~num_keys ~iterations)
  ; test &quot;table&quot; (fun () -&gt; table_iter ~num_keys ~iterations)
  ]

let () =
  tests ~num_keys:1000 ~iterations:100_000
  |&gt; Bench.make_command
  |&gt; Command.run
</programlisting>
    <para>
      The results, shown below, show the hash table version to be around
      four times faster than the map version.
    </para>
    <programlisting>
# running maps-and-hash-tables/run_map_vs_hash.out.sh
$ corebuild -pkg core_bench map_vs_hash.native
$ ./map_vs_hash.native -ascii -clear-columns name time speedup
Estimated testing time 20s (change using -quota SECS).
                                
  Name     Time (ns)   Speedup  
 ------- ------------ --------- 
  map     31_644_032      1.00  
  table    7_211_672      4.39  
                                
</programlisting>
    <para>
      We can make the speedup smaller or larger depending on the details
      of the test; for example, it will vary with the number of distinct
      keys. But overall, for code that is heavy on sequences of querying
      and updating a set of key/value pairs, hash tables will
      significantly outperform maps.
    </para>
    <para>
      Hash tables are not always the faster choice, though. In
      particular, maps are often more performant in situations where you
      need to keep multiple related versions of the data structure in
      memory at once. In particular, if you create map
      <literal>m'</literal> by calling <literal>Map.add</literal> on
      some other map <literal>m</literal>, then <literal>m</literal> and
      <literal>m'</literal> can be used independently, and in fact share
      most of their underlying storage. Thus, if you need to keep in
      memory at the same time multiple different related collections of
      key/value pairs, then a map is typically a much more efficient
      data structure to do it with.
    </para>
    <para>
      Here's a benchmark that demonstrates this. In it, we create a list
      of maps (or hash tables) that are built up by iteratively applying
      updates, starting from an empty map. In the hash table
      implementation, we do this by calling
      <literal>Hashtbl.copy</literal> to get the list entries.
    </para>
    <programlisting language="ocaml">
(* maps-and-hash-tables/map_vs_hash2.ml  *)
open Core.Std
open Core_bench.Std

let create_maps ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0 then []
    else
      let new_map =
        Map.change map (i mod num_keys) (fun current -&gt;
          Some (1 + Option.value ~default:0 current))
      in
      new_map :: loop (i - 1) new_map
  in
  loop iterations Int.Map.empty

let create_tables ~num_keys ~iterations =
  let table = Int.Table.create ~size:num_keys () in
  let rec loop i =
    if i &lt;= 0 then []
    else (
      Hashtbl.change table (i mod num_keys) (fun current -&gt;
        Some (1 + Option.value ~default:0 current));
      let new_table = Hashtbl.copy table in
      new_table :: loop (i - 1)
    )
  in
  loop iterations

let tests ~num_keys ~iterations =
  let test name f = Bench.Test.create f ~name in
  [ test &quot;map&quot;   (fun () -&gt; ignore (create_maps   ~num_keys ~iterations))
  ; test &quot;table&quot; (fun () -&gt; ignore (create_tables ~num_keys ~iterations))
  ]

let () =
  tests ~num_keys:50 ~iterations:1000
  |&gt; Bench.make_command
  |&gt; Command.run
</programlisting>
    <para>
      Unsurprisingly, maps perform far better than hash tables on this
      benchmark, in this case by more than a factor of ten.
    </para>
    <programlisting>
# running maps-and-hash-tables/run_map_vs_hash2.out.sh
$ corebuild -pkg core_bench map_vs_hash2.native
$ ./map_vs_hash2.native -ascii -clear-columns name time speedup
Estimated testing time 20s (change using -quota SECS).
                               
  Name    Time (ns)   Speedup  
 ------- ----------- --------- 
  map       218_180     12.04  
  table   2_627_099      1.00  
                               
</programlisting>
    <para>
      These numbers can be made more extreme by increasing the size of
      the tables or the length of the list.
    </para>
    <para>
      As you can see, the relative performance of trees and maps depends
      a great deal on the details of how they're used, and so whether to
      choose one data structure or the other will depend on the details
      of the application.
    </para>
  </sect1>
</chapter><chapter id="command-line-parsing">
  <title>Command Line Parsing</title>
  <para>
    Many of the OCaml programs that you'll write will end up as binaries
    that need to be run from a command prompt. Any non-trivial
    command-line should support a collection of basic features:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        Parsing of command line arguments.
      </para>
    </listitem>
    <listitem>
      <para>
        Generation of error messages in response to incorrect inputs.
      </para>
    </listitem>
    <listitem>
      <para>
        Help for all the available options.
      </para>
    </listitem>
    <listitem>
      <para>
        Interactive auto-completion of commands to assist the user.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    It's tedious and error-prone to code all this manually for every
    program you write. Core provides the Command library that simplifies
    all of this by letting you declare all your command-line options in
    one place, and deriving all of the above functionality from that
    declaration.
  </para>
  <para>
    Command is simple to use for simple applications, but also also
    scales well as your needs grow more complex. In particular, Command
    provides a sophisticated subcommand mode that groups related
    commands together as the complexity of your user interface grows.
    You may already be familiar with this command-line style from the
    Git or Mercurial version control systems.
  </para>
  <para>
    In this chapter, we'll:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        Learn how to use Command to construct basic and grouped
        command-line interfaces.
      </para>
    </listitem>
    <listitem>
      <para>
        See examples that extend the cryptographic utility from
        <xref linkend="classes"/> and build a simple
        equivalent to the <literal>md5</literal> and
        <literal>shasum</literal> utilities.
      </para>
    </listitem>
    <listitem>
      <para>
        Demonstrate how <emphasis>functional combinators</emphasis> can
        be used to declare complex command line interfaces in a
        type-safe and elegant way.
      </para>
    </listitem>
  </itemizedlist>
  <sect1 id="basic-command-line-parsing">
    <title>Basic command-line parsing</title>
    <para>
      Let's start by working through a clone of the
      <literal>md5sum</literal> command that is present on most Linux
      installations (the equivalent command on MacOS X is simply
      <literal>md5</literal>). The function defined below reads in the
      contents of a file, applies the MD5 one-way cryptographic hash
      function to the data, and outputs an ASCII hex representation of
      the result.
    </para>
    <programlisting language="ocaml">
(* command-line-parsing/basic_md5.ml  *)
open Core.Std

let do_hash file =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )
</programlisting>
    <para>
      The <literal>do_hash</literal> function accepts a
      <literal>filename</literal> parameter and prints the
      human-readable MD5 string to the console standard output. The
      first step towards turning this function into a command-line
      program is to declare all the possible command-line arguments in a
      <emphasis>specification</emphasis>.
      <literal>Command.Spec</literal> defines combinators that can be
      chained together to define optional flags and positional
      arguments, what types they should map to, and whether to take
      special actions (such as pausing for interactive input) if certain
      inputs are encountered.
    </para>
    <sect2 id="anonymous-arguments">
      <title>Anonymous arguments</title>
      <para>
        Let's build the specification for a single argument that is
        passed directly on the command-line. This is known as an
        <emphasis>anonymous</emphasis> argument.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5.ml (starting from part 1) *)
let spec =
  let open Command.Spec in
  empty
  +&gt; anon (&quot;filename&quot; %: string)
</programlisting>
      <para>
        The <literal>Command.Spec</literal> module defines the tools
        you'll need to build up a command-line specification. We start
        with the <literal>empty</literal> value, and add parameters to
        that using the <literal>+&gt;</literal> combinator. (Both of
        these values come from <literal>Command.Spec</literal>.)
      </para>
      <para>
        In this case, we defined a single anonymous argument called
        <literal>filename</literal> which takes a value of type
        <literal>string</literal>. Anonymous parameters are created
        using the <literal>%:</literal> operator, which binds a textual
        name (used in the help text to identify the parameter) to an
        OCaml conversion function that parses the command-line string
        fragments into a higher-level OCaml data type. In the example
        above this is just <literal>Command.Spec.string</literal>, but
        we'll see more complex conversion options later in the chapter.
      </para>
    </sect2>
    <sect2 id="defining-basic-commands">
      <title>Defining basic commands</title>
      <para>
        Once we've defined a specification, we need to put it to work on
        real input. The simplest way is to directly create a
        command-line interface via the <literal>Command.basic</literal>
        module.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5.ml (starting from part 2) *)
let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    ~readme:(fun () -&gt; &quot;More detailed information&quot;)
    spec
    (fun filename () -&gt; do_hash filename)
</programlisting>
      <para>
        <literal>Command.basic</literal> defines a complete command-line
        interface that takes the following extra arguments, in addition
        to the ones defined in the specification.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>summary</literal> is a required one-line
            description to go at the top of the command help screen.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>readme</literal> is for longer help text when the
            command is called with <literal>-help</literal>. The
            <literal>readme</literal> argument is a function that is
            only evaluated when the help text is actually needed.
          </para>
        </listitem>
        <listitem>
          <para>
            The specification and the callback function follow as
            non-labeled arguments.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The callback function is where all the work happens after the
        command-line parsing is complete. This function is applied with
        the arguments containing the parsed command-line values, and it
        takes over as the main thread of the application. The callback's
        arguments are passed in the same order as they were bound in the
        specification (using the <literal>+&gt;</literal> operator).
      </para>
      <note>
      <title>
      The extra <literal>unit</literal> argument to callbacks
      </title>
      <para>
        The callback above needs an extra <literal>unit</literal>
        argument after <literal>filename</literal>. This is to ensure
        that specifications can work even when they are empty
        (<emphasis>i.e.</emphasis> the
        <literal>Command.Spec.empty</literal> value).
      </para>
      <para>
        Every OCaml function needs at least one argument, so the final
        <literal>unit</literal> guarantees that it will not be evaluated
        immediately as a value if there are no other arguments.
      </para>
      </note>
    </sect2>
    <sect2 id="running-basic-commands">
      <title>Running basic commands</title>
      <para>
        Once we've defined the basic command, running it is just one
        function call away.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5.ml (starting from part 3) *)
let () =
  Command.run ~version:&quot;1.0&quot; ~build_info:&quot;RWO&quot; command
</programlisting>
      <para>
        <literal>Command.run</literal> takes a couple of optional
        arguments that are useful to identify which version of the
        binary you are running in production. Let's build the complete
        MD5 example first so that we can see this in action. Makes sure
        to run <literal>opam install cryptokit</literal> if you didn't
        do so when reading <xref linkend="classes"/>.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/build_basic_md5.out  *)
$ corebuild -pkg cryptokit basic_md5.native
</programlisting>
      <para>
        You can now query the version information for the binary you
        just compiled.
      </para>
      <programlisting>
# running command-line-parsing/get_basic_md5_version.out.sh
$ ./basic_md5.native -version
1.0
$ ./basic_md5.native -build-info
RWO
</programlisting>
      <para>
        The versions that you see in the output were defined via the
        optional arguments to <literal>Command.run</literal>. You can
        leave these blank in your own programs or get your build system
        to generate them directly from your version control system
        (<emphasis>e.g.</emphasis> by running <literal>hg id</literal>
        to generate a build revision number, in the case of Mercurial).
      </para>
      <programlisting>
# running command-line-parsing/get_basic_md5_help.out.sh
$ ./basic_md5.native
Generate an MD5 hash of the input data

  basic_md5.native FILENAME

More detailed information

=== flags ===

  [-build-info]  print info about this build and exit
  [-version]     print the version of this build and exit
  [-help]        print this help text and exit
                 (alias: -?)

missing anonymous argument: FILENAME
</programlisting>
      <para>
        When we invoke this binary without any arguments, it helpfully
        displays all of the command-line options available, along with a
        message to the standard error that informs you that a required
        argument <literal>filename</literal> is missing.
      </para>
      <para>
        If you do supply the <literal>filename</literal> argument, then
        <literal>do_hash</literal> is called with the argument and the
        MD5 output is displayed to the standard output.
      </para>
      <programlisting>
# running command-line-parsing/run_basic_md5.out.sh
$ &lt;userinput&gt;./basic_md5.native ./basic_md5.native&lt;/userinput&gt;
b5ee7de449a2e0c6c01d4f2d898926de
</programlisting>
      <para>
        And that's all it took to build our little MD5 utility! Here's a
        complete version of the example we just walked through, but made
        slightly more succinct by removing intermediate variables.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5_succinct.ml  *)
open Core.Std

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    ~readme:(fun () -&gt; &quot;More detailed information&quot;)
    Command.Spec.(empty +&gt; anon (&quot;filename&quot; %: string))
    do_hash

let () =
  Command.run ~version:&quot;1.0&quot; ~build_info:&quot;RWO&quot; command
</programlisting>
      <para>
        Now that we have the basics in place, the rest of the chapter
        will examine some of the more advanced features of Command.
      </para>
    </sect2>
  </sect1>
  <sect1 id="argument-types">
    <title>Argument types</title>
    <para>
      You aren't just limited to parsing command lines as strings, of
      course. <literal>Command.Spec</literal> defines several other
      conversion functions that validate and parse input into various
      types.
    </para>
    <informaltable>
      <tgroup cols="3">
        <colspec align="left"/>
        <colspec align="left"/>
        <colspec align="left"/>
        <thead>
          <row>
            <entry>
              Argument type
            </entry>
            <entry>
              OCaml type
            </entry>
            <entry>
              Example
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <literal>string</literal>
            </entry>
            <entry>
              <literal>string</literal>
            </entry>
            <entry>
              <literal>foo</literal>
            </entry>
          </row>
          <row>
            <entry>
              <literal>int</literal>
            </entry>
            <entry>
              <literal>int</literal>
            </entry>
            <entry>
              <literal>123</literal>
            </entry>
          </row>
          <row>
            <entry>
              <literal>float</literal>
            </entry>
            <entry>
              <literal>float</literal>
            </entry>
            <entry>
              <literal>123.01</literal>
            </entry>
          </row>
          <row>
            <entry>
              <literal>bool</literal>
            </entry>
            <entry>
              <literal>bool</literal>
            </entry>
            <entry>
              <literal>true</literal>
            </entry>
          </row>
          <row>
            <entry>
              <literal>date</literal>
            </entry>
            <entry>
              <literal>Date.t</literal>
            </entry>
            <entry>
              <literal>2013-12-25</literal>
            </entry>
          </row>
          <row>
            <entry>
              <literal>time_span</literal>
            </entry>
            <entry>
              <literal>Span.t</literal>
            </entry>
            <entry>
              <literal>5s</literal>
            </entry>
          </row>
          <row>
            <entry>
              <literal>file</literal>
            </entry>
            <entry>
              <literal>string</literal>
            </entry>
            <entry>
              <literal>/etc/passwd</literal>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      We can tighten up the specification of the command to
      <literal>file</literal> to reflect that the argument must be a
      valid filename, and not just any string.
    </para>
    <programlisting language="ocaml">
(* command-line-parsing/basic_md5_as_filename.ml (starting from part 1) *)
let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    ~readme:(fun () -&gt; &quot;More detailed information&quot;)
    Command.Spec.(empty +&gt; anon (&quot;filename&quot; %: file))
    do_hash

let () =
  Command.run ~version:&quot;1.0&quot; ~build_info:&quot;RWO&quot; command
</programlisting>
    <para>
      Running this with a non-existent filename will now output an error
      if the file doesn't exist. As a bonus, it also enables interactive
      command-line completion to work on the filename argument
      (explained later in the chapter).
    </para>
    <programlisting>
# running command-line-parsing/run_basic_md5_as_filename.out.sh
$ ./basic_md5_as_filename.native nonexistent
Uncaught exception:
  
  (Sys_error &quot;nonexistent: No such file or directory&quot;)

Raised by primitive operation at file &quot;pervasives.ml&quot;, line 292, characters 20-46
Called from file &quot;lib/in_channel.ml&quot;, line 19, characters 46-65
Called from file &quot;lib/exn.ml&quot;, line 87, characters 6-10
</programlisting>
    <sect2 id="defining-custom-argument-types">
      <title>Defining custom argument types</title>
      <para>
        We can also define our own argument types if the predefined ones
        aren't sufficient. For instance, let's make a
        <literal>regular_file</literal> argument type that ensures that
        the input file isn't a character device or some other odd UNIX
        file type that can't be fully read.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5_with_custom_arg.ml  *)
open Core.Std

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let regular_file =
  Command.Spec.Arg_type.create
    (fun filename -&gt;
       match Sys.is_file filename with
       | `Yes -&gt; filename
       | `No | `Unknown -&gt;
         eprintf &quot;'%s' is not a regular file.\n%!&quot; filename;
         exit 1
    )

let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    ~readme:(fun () -&gt; &quot;More detailed information&quot;)
    Command.Spec.(empty +&gt; anon (&quot;filename&quot; %: regular_file))
    do_hash

let () =
  Command.run ~version:&quot;1.0&quot; ~build_info:&quot;RWO&quot; command
</programlisting>
      <para>
        The <literal>regular_file</literal> function transforms a
        <literal>filename</literal> string parameter into the same
        string, but first checks that the file exists and is a regular
        file type. When you build and run this code, you will see the
        new error messages if you try to open a special device such as
        <literal>/dev/null</literal>.
      </para>
      <programlisting>
# running command-line-parsing/run_basic_md5_with_custom_arg.out.sh
$ ./basic_md5_with_custom_arg.native /etc/passwd
8cfb68a5622dd12932df658a54698aad
$ ./basic_md5_with_custom_arg.native /dev/null
'/dev/null' is not a regular file.
</programlisting>
    </sect2>
    <sect2 id="optional-and-default-arguments">
      <title>Optional and default arguments</title>
      <para>
        A more realistic MD5 binary could also read from the standard
        input if a <literal>filename</literal> isn't specified.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5_with_optional_file_broken.ml (starting from part 1) *)
let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    ~readme:(fun () -&gt; &quot;More detailed information&quot;)
    Command.Spec.(empty +&gt; anon (maybe (&quot;filename&quot; %: string)))
    do_hash

let () =
  Command.run ~version:&quot;1.0&quot; ~build_info:&quot;RWO&quot; command
</programlisting>
      <para>
        This just wraps the <literal>filename</literal> argument
        declaration in the <literal>maybe</literal> function to mark it
        as an optional argument. However, building this results in a
        compile-time error.
      </para>
      <programlisting>
# running command-line-parsing/build_basic_md5_with_optional_file_broken.out.sh
$ ocamlbuild -use-ocamlfind -pkg cryptokit,core -tag thread basic_md5_with_optional_file_broken.native
File &quot;basic_md5_with_optional_file_broken.ml&quot;, line 18, characters 4-11:
Error: This expression has type string -&gt; unit -&gt; unit
       but an expression was expected of type string option -&gt; unit -&gt; unit
       Type string is not compatible with type string option 
Command exited with code 2.
</programlisting>
      <para>
        This is because changing the argument type has also changed the
        type of the callback function. It now wants a
        <literal>string option</literal> instead of a
        <literal>string</literal> since the value has become optional.
        We can adapt our example to use the new information and read
        from standard input if no file is specified.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5_with_optional_file.ml  *)
open Core.Std

let get_inchan = function
  | None | Some &quot;-&quot; -&gt;
    In_channel.stdin
  | Some filename -&gt;
    In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    ~readme:(fun () -&gt; &quot;More detailed information&quot;)
    Command.Spec.(empty +&gt; anon (maybe (&quot;filename&quot; %: file)))
    do_hash

let () =
  Command.run ~version:&quot;1.0&quot; ~build_info:&quot;RWO&quot; command
</programlisting>
      <para>
        The <literal>filename</literal> parameter to
        <literal>do_hash</literal> is now a
        <literal>string option</literal> type. This is resolved into an
        input channel via <literal>get_file_data</literal> to determine
        whether to open the standard input or a file, and then the rest
        of the command is similar to our previous examples.
      </para>
      <para>
        Another possible way to handle this would be to supply a dash as
        the default filename if one isn't specified. The
        <literal>maybe_with_default</literal> function can do just this,
        with the benefit of not having to change the callback parameter
        type (which may be a problem in more complex applications).
      </para>
      <para>
        The example below behaves exactly the same as the previous
        example, but replaces <literal>maybe</literal> with
        <literal>maybe_with_default</literal>.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5_with_default_file.ml  *)
open Core.Std

let get_inchan = function
  | &quot;-&quot;      -&gt; In_channel.stdin
  | filename -&gt; In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    ~readme:(fun () -&gt; &quot;More detailed information&quot;)
    Command.Spec.(
      empty
      +&gt; anon (maybe_with_default &quot;-&quot; (&quot;filename&quot; %: file))
    )
    do_hash

let () =
  Command.run ~version:&quot;1.0&quot; ~build_info:&quot;RWO&quot; command
</programlisting>
      <para>
        Building and running both against a system file confirms that
        they have the same behavior.
      </para>
      <programlisting>
# running command-line-parsing/run_basic_and_default_md5.out.sh
$ cat /etc/passwd | ./basic_md5_with_optional_file.native
8cfb68a5622dd12932df658a54698aad
$ cat /etc/passwd | ./basic_md5_with_default_file.native
8cfb68a5622dd12932df658a54698aad
</programlisting>
    </sect2>
    <sect2 id="sequences-of-arguments">
      <title>Sequences of arguments</title>
      <para>
        One last transformation that's useful is to obtain lists of
        anonymous arguments rather than a single one. As an example,
        let's modify our MD5 code to take a collection of files to
        process on the command line.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/basic_md5_sequence.ml  *)
open Core.Std

let do_hash filename ic =
  let open Cryptokit in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; fun md5 -&gt; printf &quot;MD5 (%s) = %s\n&quot; filename md5

let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    ~readme:(fun () -&gt; &quot;More detailed information&quot;)
    Command.Spec.(empty +&gt; anon (sequence (&quot;filename&quot; %: file)))
    (fun files () -&gt;
       match files with
       | [] -&gt; do_hash &quot;-&quot; In_channel.stdin
       | _  -&gt;
         List.iter files ~f:(fun file -&gt;
           In_channel.with_file ~f:(do_hash file) file
         )
    )

let () =
  Command.run ~version:&quot;1.0&quot; ~build_info:&quot;RWO&quot; command
</programlisting>
      <para>
        The callback function is a little more complex now to handle the
        extra options. The <literal>files</literal> are now a
        <literal>string list</literal>, and an empty list reverts to
        using standard input just as our previous
        <literal>maybe</literal> and
        <literal>maybe_with_default</literal> examples did. If the list
        of files isn't empty, then it opens up each file and runs them
        through <literal>do_hash</literal> sequentially.
      </para>
    </sect2>
  </sect1>
  <sect1 id="adding-labeled-flags-to-the-command-line">
    <title>Adding labeled flags to the command line</title>
    <para>
      You aren't just limited to anonymous arguments on the
      command-line. A <emphasis>flag</emphasis> is a named field that
      can be followed by an optional argument. These flags can appear in
      any order on the command-line, or multiple times, depending on how
      they're declared in the specification.
    </para>
    <para>
      Let's add two arguments to our <literal>md5</literal> command that
      mimics the MacOS X version. A <literal>-s</literal> flag specifies
      the string to be hashed directly on the command-line and
      <literal>-t</literal> runs a self-test. The complete example is
      below.
    </para>
    <programlisting language="ocaml">
(* command-line-parsing/basic_md5_with_flags.ml  *)
open Core.Std
open Cryptokit

let checksum_from_string buf =
  hash_string (Hash.md5 ()) buf
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let checksum_from_file filename =
  let ic = match filename with
    | &quot;-&quot; -&gt; In_channel.stdin
    | _   -&gt; In_channel.create ~binary:true filename
  in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:&quot;Generate an MD5 hash of the input data&quot;
    Command.Spec.(
      empty
      +&gt; flag &quot;-s&quot; (optional string) ~doc:&quot;string Checksum the given string&quot;
      +&gt; flag &quot;-t&quot; no_arg ~doc:&quot; run a built-in time trial&quot;
      +&gt; anon (maybe_with_default &quot;-&quot; (&quot;filename&quot; %: file))
    )
    (fun use_string trial filename () -&gt;
       match trial with
       | true -&gt; printf &quot;Running time trial\n&quot;
       | false -&gt; begin
           match use_string with
           | Some buf -&gt; checksum_from_string buf
           | None -&gt; checksum_from_file filename
         end
    )

let () = Command.run command
</programlisting>
    <para>
      The specification now uses the <literal>flag</literal> function to
      define the two new labeled command-line arguments. The
      <literal>doc</literal> string is formatted so that the first word
      is the short name that appears in the usage text, with the
      remainder being the full help text. Notice that the
      <literal>-t</literal> flag has no argument, and so we prepend its
      <literal>doc</literal> text with a blank space. The help text for
      the above code looks like this.
    </para>
    <programlisting>
# running command-line-parsing/run_basic_md5_flags_help.out.sh
$ ./basic_md5_with_flags.native -help
Generate an MD5 hash of the input data

  basic_md5_with_flags.native [FILENAME]

=== flags ===

  [-s string]    Checksum the given string
  [-t]           run a built-in time trial
  [-build-info]  print info about this build and exit
  [-version]     print the version of this build and exit
  [-help]        print this help text and exit
                 (alias: -?)

$ ./basic_md5_with_flags.native -s &quot;ocaml rocks&quot;
5a118fe92ac3b6c7854c595ecf6419cb
</programlisting>
    <para>
      The <literal>-s</literal> flag in our specification requires a
      <literal>string</literal> argument and isn't optional. The Command
      parser outputs an error message if the flag isn't supplied, as
      with the anonymous arguments in earlier examples. Here's a list of
      some of the functions that you can wrap flags in to control how
      they are parsed.
    </para>
    <informaltable>
      <tgroup cols="2">
        <colspec align="left"/>
        <colspec align="left"/>
        <thead>
          <row>
            <entry>
              Flag function
            </entry>
            <entry>
              OCaml type
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <literal>required</literal> <emphasis>arg</emphasis>
            </entry>
            <entry>
              <emphasis>arg</emphasis> and error if not present
            </entry>
          </row>
          <row>
            <entry>
              <literal>optional</literal> <emphasis>arg</emphasis>
            </entry>
            <entry>
              <emphasis>arg</emphasis> <literal>option</literal>
            </entry>
          </row>
          <row>
            <entry>
              <literal>optional_with_default</literal>
              <emphasis>val</emphasis> <emphasis>arg</emphasis>
            </entry>
            <entry>
              <emphasis>arg</emphasis> with default
              <emphasis>val</emphasis> if not present
            </entry>
          </row>
          <row>
            <entry>
              <literal>listed</literal> <emphasis>arg</emphasis>
            </entry>
            <entry>
              <emphasis>arg</emphasis> <literal>list</literal>, flag may
              appear multiple times
            </entry>
          </row>
          <row>
            <entry>
              <literal>no_arg</literal>
            </entry>
            <entry>
              <literal>bool</literal> that is true if flag is present.
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      The flags affect the type of the callback function in exactly the
      same way as anonymous arguments do. This lets you change the
      specification and ensure that all the callback functions are
      updated appropriately, without runtime errors.
    </para>
  </sect1>
  <sect1 id="grouping-sub-commands-together">
    <title>Grouping sub-commands together</title>
    <para>
      You can get pretty far by using flags and anonymous arguments to
      assemble complex command-line interfaces. After a while though,
      too many options can make the program very confusing for newcomers
      to your application. One way to solve this is by grouping common
      operations together and adding some hierarchy to the command-line
      interface.
    </para>
    <para>
      You'll have run across this style already when using the OPAM
      package manager (or, in the non-OCaml world, the Git or Mercurial
      commands). OPAM exposes commands in this form.
    </para>
    <programlisting>
# running command-line-parsing/opam.out.sh
$ opam config env
$ opam remote list -k git
$ opam install --help
$ opam install cryptokit --verbose
</programlisting>
    <para>
      The <literal>config</literal>, <literal>remote</literal> and
      <literal>install</literal> keywords form a logical grouping of
      commands that factor out a set of flags and arguments. This lets
      you prevent flags that are specific to a particular sub-command
      from leaking into the general configuration space.
    </para>
    <para>
      This usually only becomes a concern when your application
      organically grows features. Luckily, it's simple to extend your
      application to do this in Command: just swap the
      <literal>Command.basic</literal> for
      <literal>Command.group</literal>, which takes an association list
      of specifications and handles the sub-command parsing and help
      output for you.
    </para>
    <programlisting language="ocaml">
# script command-line-parsing/group.topscript
$ utop
# Command.basic ;; 
- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t
= &lt;fun&gt;
# Command.group ;; 
- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt; (string * Command.t) list -&gt; Command.t
= &lt;fun&gt;
</programlisting>
    <para>
      The <literal>group</literal> signature accepts a list of basic
      <literal>Command.t</literal> values and their corresponding names.
      When executed, it looks for the appropriate sub-command from the
      name list, and dispatches it to the right command handler.
    </para>
    <para>
      Let's build the outline of a calendar tool that does a few
      operations over dates from the command-line. We first need to
      define a command that adds days to an input date and prints the
      resulting date.
    </para>
    <programlisting language="ocaml">
(* command-line-parsing/cal_add_days.ml  *)
open Core.Std

let add =
  Command.basic
    ~summary:&quot;Add [days] to the [base] date and print day&quot;
    Command.Spec.(
      empty
      +&gt; anon (&quot;base&quot; %: date)
      +&gt; anon (&quot;days&quot; %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add
</programlisting>
    <para>
      Everything in this command should be familiar to you by now. Once
      you've tested it and made sure it works, we can define another new
      command that takes the difference of two dates. However, instead
      of creating a new binary, we group both operations as sub-commands
      using <literal>Command.group</literal>.
    </para>
    <programlisting language="ocaml">
(* command-line-parsing/cal_add_sub_days.ml  *)
open Core.Std

let add =
  Command.basic ~summary:&quot;Add [days] to the [base] date&quot;
    Command.Spec.(
      empty
      +&gt; anon (&quot;base&quot; %: date)
      +&gt; anon (&quot;days&quot; %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff =
  Command.basic ~summary:&quot;Show days between [date1] and [date2]&quot;
    Command.Spec.(
      empty
      +&gt; anon (&quot;date1&quot; %: date)
      +&gt; anon (&quot;date2&quot; %: date)
    )
    (fun date1 date2 () -&gt;
       Date.diff date1 date2
       |&gt; printf &quot;%d days\n&quot;
    )

let command =
  Command.group ~summary:&quot;Manipulate dates&quot;
    [ &quot;add&quot;, add; &quot;diff&quot;, diff ]

let () = Command.run command
</programlisting>
    <para>
      And that's all you really need to add sub-command support! Let's
      build the example first in the usual way and inspect the help
      output, which now reflects the sub-commands we just added.
    </para>
    <programlisting language="ocaml">
(* command-line-parsing/build_cal_add_sub_days.out  *)
$ corebuild cal_add_sub_days.native
$ ./cal_add_sub_days.native -help
Manipulate dates

  cal_add_sub_days.native SUBCOMMAND

=== subcommands ===

  add      Add [days] to the [base] date
  diff     Show days between [date1] and [date2]
  version  print version information
  help     explain a given subcommand (perhaps recursively)

</programlisting>
    <para>
      We can invoke the two commands we just defined to verify that they
      work and see the date parsing in action.
    </para>
    <programlisting>
# running command-line-parsing/run_cal_add_sub_days.out.sh
$ &lt;userinput&gt;./cal_add_sub_days.native add 2012-12-25 40&lt;/userinput&gt;
2013-02-03
$ &lt;userinput&gt;./cal_add_sub_days.native diff 2012-12-25 2012-11-01&lt;/userinput&gt;
54 days
</programlisting>
  </sect1>
  <sect1 id="advanced-control-over-parsing">
    <title>Advanced control over parsing</title>
    <para>
      The functions for generating a specification may seem like magic.
      In particular, even if you know how to use them, it's not entirely
      clear how they work, and in particular, why the types work out the
      way they do.
    </para>
    <para>
      Understanding the details of how these specifications fit together
      becomes more useful as your command line interfaces get more
      complex. In particular, you may want to factor out common
      functionality between specifications, or interrupt the parsing to
      perform special processing, such as requesting an interactive
      passphrase from the user before proceeding. All of this is helped
      by a deeper understanding of the Command library.
    </para>
    <para>
      In the following, we'll explain the logic behind the combinators
      we've already described and show you some new combinators that let
      you use Command even more effectively.
    </para>
    <sect2 id="the-types-behind-command.spec">
      <title>The types behind <literal>Command.Spec</literal></title>
      <para>
        The Command module's safety relies on the specification's output
        values precisely matching the callback function which invokes
        the main program. In order to prevent any such mismatches,
        Command uses some interesting type machinery to guarantee they
        remain in sync. You don't have to understand this section to use
        the more advanced combinators, but it'll help you debug type
        errors as you use Command more.
      </para>
      <para>
        The <literal>Command.Spec.t</literal> type looks deceptively
        simple: <literal>('a, 'b) t</literal>. You can think of
        <literal>('a, 'b) t</literal> here as a function of type
        <literal>'a -&gt; 'b</literal>, but embellished with information
        about:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            how to parse the command line
          </para>
        </listitem>
        <listitem>
          <para>
            what the command does and how to call it
          </para>
        </listitem>
        <listitem>
          <para>
            how to auto-complete a partial command line
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The type of a specification transforms a <literal>'a</literal>
        to a <literal>'b</literal> value. For instance, a value of
        <literal>Spec.t</literal> might have type
        <literal>(arg1 -&gt; ... -&gt; argN -&gt; 'r, 'r) Spec.t</literal>.
      </para>
      <para>
        Such a value transforms a main function of type
        <literal>arg1 -&gt; ... -&gt; argN -&gt; 'r</literal> by
        supplying all the argument values, leaving a main function that
        returns a value of type <literal>'r</literal>. Let's look at
        some examples of specs, and their types:
      </para>
      <programlisting language="ocaml">
# script command-line-parsing/command_types.topscript
$ utop
# Command.Spec.empty ;; 
- : ('m, 'm) Command.Spec.t = &lt;abstr&gt;
# Command.Spec.(empty +&gt; anon (&quot;foo&quot; %: int)) ;; 
- : (int -&gt; '_a, '_a) Command.Spec.t = &lt;abstr&gt;
</programlisting>
      <para>
        The empty specification is simple as it doesn't add any
        parameters to the callback type. The second example adds an
        <literal>int</literal> anonymous parameter that is reflected in
        the inferred type. One forms a command by combining a spec of
        type <literal>('main, unit) Spec.t</literal> with a function of
        type <literal>'main</literal>. The combinators we've shown so
        far incrementally build the type of <literal>'main</literal>
        according to the command-line parameters it expects, so the
        resulting type of <literal>'main</literal> is something like
        <literal>arg1 -&gt; ... -&gt; argN -&gt; unit</literal>.
      </para>
      <para>
        The type of <literal>Command.basic</literal> should make more
        sense now:
      </para>
      <programlisting language="ocaml">
# script command-line-parsing/basic.topscript
$ utop
# Command.basic ;; 
- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t
= &lt;fun&gt;
</programlisting>
      <para>
        The parameters to <literal>Spec.t</literal> are important here.
        They show that the callback function for a spec should consume
        identical arguments to the supplied <literal>main</literal>
        function, except for an additional <literal>unit</literal>
        argument. This final <literal>unit</literal> is there to make
        sure the callback is evaluated as a function, since if zero
        command-line arguments are specified (<emphasis>i.e.</emphasis>
        <literal>Spec.empty</literal>), the callback would otherwise
        have no arguments and be evaluated immediately. That's why you
        have to supply an additional <literal>()</literal> to the
        callback function in all the previous examples.
      </para>
    </sect2>
    <sect2 id="composing-specification-fragments-together">
      <title>Composing specification fragments together</title>
      <para>
        If you want to factor out common command-line operations, the
        <literal>++</literal> operator will append two specifications
        together. Let's add some dummy verbosity and debug flags to our
        calendar application to illustrate this.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/cal_append.ml  *)
open Core.Std

let add ~common =
  Command.basic ~summary:&quot;Add [days] to the [base] date&quot;
    Command.Spec.(
      empty
      +&gt; anon (&quot;base&quot; %: date)
      +&gt; anon (&quot;days&quot; %: int)
      ++ common
    )
    (fun base span debug verbose () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff ~common =
  Command.basic ~summary:&quot;Show days between [date2] and [date1]&quot;
    Command.Spec.(
      empty
      +&gt; anon (&quot;date1&quot; %: date)
      +&gt; anon (&quot;date2&quot; %: date)
      ++ common
    )
    (fun date1 date2 debug verbose () -&gt;
       Date.diff date1 date2
       |&gt; printf &quot;%d days\n&quot;
    )
</programlisting>
      <para>
        The definitions of the specifications are very similar to the
        earlier example, except that they append a
        <literal>common</literal> parameter after each specification. We
        can supply these flags when defining the groups.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/cal_append.ml (starting from part 1) *)
let () =
  let common =
    Command.Spec.(
      empty
      +&gt; flag &quot;-d&quot; (optional_with_default false bool) ~doc:&quot; Debug mode&quot;
      +&gt; flag &quot;-v&quot; (optional_with_default false bool) ~doc:&quot; Verbose output&quot;
    )
  in
  List.map ~f:(fun (name, cmd) -&gt; (name, cmd ~common))
    [ &quot;add&quot;, add; &quot;diff&quot;, diff ]
  |&gt; Command.group ~summary:&quot;Manipulate dates&quot;
  |&gt; Command.run
</programlisting>
      <para>
        Both of these flags will now be applied and passed to all the
        callback functions. This makes code refactoring a breeze by
        using the compiler to spot places where you use commands. Just
        add a parameter to the common definition, run the compiler, and
        fix type errors until everything works again.
      </para>
      <para>
        For example, if we remove the <literal>verbose</literal> flag
        and recompile, we'll get this impressively long type error:
      </para>
      <programlisting>
# running command-line-parsing/build_cal_append_broken.out.sh
$ ocamlbuild -use-ocamlfind -tag thread -pkg core cal_append_broken.native
File &quot;cal_append_broken.ml&quot;, line 38, characters 46-52:
Error: This expression has type
         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit -&gt; unit) Command.Spec.t
       but an expression was expected of type
         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit) Command.Spec.t
       Type unit -&gt; unit is not compatible with type unit 
Command exited with code 2.
</programlisting>
      <para>
        While this does look scary, the key line to scan is the last
        one, where it's telling you that you have supplied too many
        arguments in the callback function
        (<literal>unit -&gt; unit</literal> vs <literal>unit</literal>).
        If you started with a working program and made this single
        change, you typically don't even need to read the type error, as
        the filename and location information is sufficient to make the
        obvious fix.
      </para>
    </sect2>
    <sect2 id="prompting-for-interactive-input">
      <title>Prompting for interactive input</title>
      <para>
        The <literal>step</literal> combinator lets you control the
        normal course of parsing by supplying a function that maps
        callback arguments to a new set of values. For instance, let's
        revisit our first calendar application that added a number of
        days onto a supplied base date.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/cal_add_days.ml  *)
open Core.Std

let add =
  Command.basic
    ~summary:&quot;Add [days] to the [base] date and print day&quot;
    Command.Spec.(
      empty
      +&gt; anon (&quot;base&quot; %: date)
      +&gt; anon (&quot;days&quot; %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add
</programlisting>
      <para>
        This program requires you to specify both the
        <literal>base</literal> date and the number of
        <literal>days</literal> to add onto it. If
        <literal>days</literal> isn't supplied on the command-line, an
        error is output. Now let's modify it to interactively prompt for
        a number of days if only the <literal>base</literal> date is
        supplied.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/cal_add_interactive.ml  *)
open Core.Std

let add_days base span () =
  Date.add_days base span
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:&quot;Add [days] to the [base] date and print day&quot;
    Command.Spec.( 
      step 
        (fun m base days -&gt;
           match days with
           | Some days -&gt;
             m base days
           | None -&gt;
             print_endline &quot;enter days: &quot;;
             read_int ()
             |&gt; m base
        )
      +&gt; anon (&quot;base&quot; %: date)
      +&gt; anon (maybe (&quot;days&quot; %: int))
    )
    add_days

let () = Command.run add
</programlisting>
      <para>
        The <literal>days</literal> anonymous argument is now an
        optional integer in the spec, and we want to transform it into a
        non-optional value before calling our
        <literal>add_days</literal> callback. The
        <literal>step</literal> combinator lets us perform this
        transformation by applying its supplied callback function first.
        In the example, the callback first checks if
        <literal>day</literal> is defined. If it's undefined, then it
        interactively reads an integer from the standard input.
      </para>
      <para>
        The first <literal>m</literal> argument to the
        <literal>step</literal> callback is the next callback function
        in the chain. The transformation is completed by calling
        <literal>m base days</literal> to continue processing with the
        new values we've just calculated. The <literal>days</literal>
        value that is passed onto the next callback now has a
        non-optional <literal>int</literal> type.
      </para>
      <programlisting>
# running command-line-parsing/build_and_run_cal_add_interactive.out.sh
$ ocamlbuild -use-ocamlfind -tag thread -pkg core cal_add_interactive.native
$ ./cal_add_interactive.native 2013-12-01
enter days:
35
2014-01-05
</programlisting>
      <para>
        The transformation means that the <literal>add_days</literal>
        callback can just keep its original definition of
        <literal>Date.t -&gt; int -&gt; unit</literal>. The
        <literal>step</literal> function transformed the
        <literal>int option</literal> argument from the parsing into an
        <literal>int</literal> suitable for <literal>add_days</literal>.
        This transformation is explicitly represented in the type of the
        <literal>step</literal> return value:
      </para>
      <programlisting language="ocaml">
# script command-line-parsing/step.topscript
$ utop
# open Command.Spec ;; 
# step (fun m (base:Date.t) days -&gt;
  match days with
  | Some days -&gt; m base days
  | None -&gt;
     print_endline &quot;enter days: &quot;;
     m base (read_int ())) ;; 
- : (Date.t -&gt; int -&gt; '_a, Date.t -&gt; int option -&gt; '_a) t = &lt;abstr&gt;
</programlisting>
      <para>
        The first half of the <literal>Spec.t</literal> shows that the
        callback type is <literal>Date.t -&gt; int</literal>, whereas
        the resulting value expected from the next specification in the
        chain is a <literal>Date.t -&gt; int option</literal>.
      </para>
    </sect2>
    <sect2 id="adding-labeled-arguments-to-callbacks">
      <title>Adding labeled arguments to callbacks</title>
      <para>
        The <literal>step</literal> chaining lets you control the types
        of your callbacks very easily. This can help you match existing
        interfaces or make things more explicit by adding labeled
        arguments.
      </para>
      <programlisting language="ocaml">
(* command-line-parsing/cal_add_labels.ml  *)
open Core.Std

let add_days ~base_date ~num_days () =
  Date.add_days base_date num_days
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:&quot;Add [days] to the [base] date and print day&quot;
    Command.Spec.( 
      step (fun m base days -&gt; m ~base_date:base ~num_days:days)
      +&gt; anon (&quot;base&quot; %: date)
      +&gt; anon (&quot;days&quot; %: int)
    )
    add_days

let () = Command.run add
</programlisting>
      <para>
        This <literal>cal_add_labels</literal> example goes back to our
        non-interactive calendar addition program, but the
        <literal>add_days</literal> main function now expects labeled
        arguments. The <literal>step</literal> function in the
        specification simply converts the default
        <literal>base</literal> and <literal>days</literal> arguments
        into a labeled function.
      </para>
      <para>
        Labelled arguments are more verbose but can also help prevent
        errors with command-line arguments with similar types but
        different names and purposes. It's good form to use labels when
        you have a lot of otherwise anonymous <literal>int</literal> and
        <literal>string</literal> arguments.
      </para>
    </sect2>
  </sect1>
  <sect1 id="command-line-auto-completion-with-bash">
    <title>Command-line auto-completion with
    <literal>bash</literal></title>
    <para>
      Modern UNIX shells usually have a tab-completion feature to
      interactively help you figure out how to build a command-line.
      These work by pressing the <literal>&lt;tab&gt;</literal> key in
      the middle of typing a command, and seeing the options that pop
      up. You've probably used this most often to find the files in the
      current directory, but it can actually be extended for other parts
      of the command too.
    </para>
    <para>
      The precise mechanism for autocompletion varies depending on what
      shell you are using, but we'll assume you are using the most
      common one: <literal>bash</literal>. This is the default
      interactive shell on most Linux distributions and Mac OS X, but
      you may need to switch to it on *BSD or Windows (when using
      Cygwin). The rest of this section assumes that you're using
      <literal>bash</literal>.
    </para>
    <para>
      Bash autocompletion isn't always installed by default, so check
      your OS package manager to see if you have it available.
    </para>
    <informaltable>
      <tgroup cols="3">
        <colspec align="left"/>
        <colspec align="left"/>
        <colspec align="left"/>
        <thead>
          <row>
            <entry>
              Operating System
            </entry>
            <entry>
              Package Manager
            </entry>
            <entry>
              Package
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              Debian Linux
            </entry>
            <entry>
              <literal>apt</literal>
            </entry>
            <entry>
              <literal>bash-completion</literal>
            </entry>
          </row>
          <row>
            <entry>
              Mac OS X
            </entry>
            <entry>
              Homebrew
            </entry>
            <entry>
              <literal>bash-completion</literal>
            </entry>
          </row>
          <row>
            <entry>
              FreeBSD
            </entry>
            <entry>
              Ports System
            </entry>
            <entry>
              <filename>/usr/ports/shells/bash-completion</filename>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      Once bash completion is installed and configured, check that it
      works by typing the <literal>ssh</literal> command, and pressing
      <literal>&lt;tab&gt;</literal>. This should show you the list of
      known hosts from your <literal>~/.ssh/known_hosts</literal> file.
      If it lists some hosts that you've recently connected to, you can
      continue on. If it lists the files in your current directory
      instead, then check your OS documentation to configure completion
      correctly.
    </para>
    <para>
      One last bit of information you'll need to find is the location of
      the <literal>bash_completion.d</literal> directory. This is where
      all the shell fragments that contain the completion logic are
      held. On Linux, this is often in
      <literal>/etc/bash_completion.d</literal>, and in Homebrew on Mac
      OS X it would be
      <literal>/usr/local/etc/bash_completion.d</literal> by default.
    </para>
    <sect2 id="generating-completion-fragments-from-command">
      <title>Generating completion fragments from Command</title>
      <para>
        The Command library has a declarative description of all the
        possible valid options, and it can use this information to
        generate a shell script which provides completion support for
        that command. To generate the fragment, just run the command
        with the <literal>COMMAND_OUTPUT_INSTALLATION_BASH</literal>
        environment variable set to any value.
      </para>
      <para>
        For example, let's try it on our MD5 example from earlier,
        assuming that the binary is called
        <literal>basic_md5_with_flags</literal> in the current
        directory.
      </para>
      <programlisting>
# running command-line-parsing/md5_completion.out.sh
$ env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./basic_md5_with_flags.native
function _jsautocom_15563 {
  export COMP_CWORD
  COMP_WORDS[0]=./basic_md5_with_flags.native
  COMPREPLY=($(&quot;${COMP_WORDS[@]}&quot;))
}
complete -F _jsautocom_15563 ./basic_md5_with_flags.native
</programlisting>
      <para>
        Recall that we used the <literal>Arg_type.file</literal> to
        specify the argument type. This also supplies the completion
        logic so that you can just press <literal>&lt;tab&gt;</literal>
        to complete files in your current directory.
      </para>
    </sect2>
    <sect2 id="installing-the-completion-fragment">
      <title>Installing the completion fragment</title>
      <para>
        You don't need to worry about what the output script above
        actually does (unless you have an unhealthy fascination with
        shell scripting internals, that is). Instead, redirect the
        output to a file in your current directory and source it into
        your current shell.
      </para>
      <programlisting>
# running command-line-parsing/cal_completion.out.sh
$ env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./cal_add_sub_days.native &gt; cal.cmd
$ . cal.cmd
$ ./cal_add_sub_days.native &lt;tab&gt;
add      diff     help     version
</programlisting>
      <para>
        Command completion support works for flags and grouped commands,
        and is very useful when building larger command-line interfaces.
        Don't forget to install the shell fragment into your global
        <literal>bash_completion.d</literal> directory if you want it to
        be loaded in all of your login shells.
      </para>
      <note>
      <title>
      Installing a generic completion handler
      </title>
      <para>
        Sadly, <literal>bash</literal> doesn't support installing a
        generic handler for all Command-based applications. This means
        that you have to install the completion script for every
        application, but you should be able to automate this in the
        build and packaging system for your application.
      </para>
      <para>
        It will help to check out how other applications that install
        tab-completion scripts and following their lead, as the details
        are very OS-specific.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="alternative-command-line-parsers">
    <title>Alternative command-line parsers</title>
    <para>
      This rounds up our tour of the Command library. This isn't the
      only way to parse command-line arguments of course; there are
      several alternatives available on OPAM. Three of the most
      prominent ones are introduced below.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          The <literal>Arg</literal> module from the OCaml standard
          library, which is used by the compiler itself to handle its
          command-line interface. Command is generally more featureful
          than Arg (mainly via support for sub-commands, the
          <literal>step</literal> combinator to transform inputs, and
          help generation), but there's absolutely nothing wrong with
          using Arg either.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      You can use the <literal>Command.Spec.flags_of_args_exn</literal>
      function to convert Arg specifications into ones compatible with
      Command. This is quite often used to help port older non-Core code
      into the Core standard library world.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <ulink url="https://forge.ocamlcore.org/projects/ocaml-getopt/">ocaml-getopt</ulink>
          provides the general command-line syntax of GNU
          <literal>getopt</literal> and <literal>getopt_long</literal>.
          The GNU conventions are widely used in the open-source world,
          and this library lets your OCaml programs obey the same rules.
        </para>
      </listitem>
      <listitem>
        <para>
          <ulink url="http://erratique.ch/software/cmdliner">Cmdliner</ulink>
          is a mix between the Command and Getopt libraries. It allows
          for the declarative definition of command-line interfaces, but
          exposes a more <literal>getopt</literal>-like interface. It
          also automates the generation of UNIX <literal>man</literal>
          pages as part of the specification. Cmdliner is the parser
          used by OPAM to manage its command-line.
        </para>
      </listitem>
    </itemizedlist>
  </sect1>
</chapter><chapter id="handling-json-data">
  <title>Handling JSON data</title>
  <para>
    Data serialization, <emphasis>i.e.</emphasis> converting data to and
    from a sequence of bytes that's suitable for writing to disk or
    sending across the network, is an important and common programming
    task. You often have to match someone else's data format (such as
    XML), sometimes you need a highly efficient format, and other times
    you want something that is easy for humans to edit. To this end,
    OCaml libraries provide several techniques for data serialization
    depending on what your problem is.
  </para>
  <para>
    We'll start by using the popular and simple JSON data format and
    then look at other serialization formats later in the book. This
    chapter introduces you to a couple of new techniques that glue
    together the basic ideas from Part I of the book by using:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis>polymorphic variants</emphasis> to write more
        extensible libraries and protocols (but still retain the ability
        to extend them if needed)
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis>functional combinators</emphasis> to compose common
        operations over data structures in a type-safe way.
      </para>
    </listitem>
    <listitem>
      <para>
        external tools to generate boilerplate OCaml modules and
        signatures from external specification files.
      </para>
    </listitem>
  </itemizedlist>
  <sect1 id="json-basics">
    <title>JSON Basics</title>
    <para>
      JSON is a lightweight data-interchange format often used in web
      services and browsers. It's described in
      <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</ulink>,
      and is easier to parse and generate than alternatives such as XML.
      You'll run into JSON very often when working with modern web APIs,
      so we'll cover several different ways to manipulate it in this
      chapter.
    </para>
    <para>
      JSON consists of two basic structures: an unordered collection of
      key/value pairs, and an ordered list of values. Values can be
      strings, booleans, floats, integers or null. Let's see what a JSON
      record for an example book description looks like:
    </para>
    <programlisting language="json">
{
  &quot;title&quot;: &quot;Real World OCaml&quot;,
  &quot;tags&quot; : [ &quot;functional programming&quot;, &quot;ocaml&quot;, &quot;algorithms&quot; ],
  &quot;pages&quot;: 450,
  &quot;authors&quot;: [
    { &quot;name&quot;: &quot;Jason Hickey&quot;, &quot;affiliation&quot;: &quot;Google&quot; },
    { &quot;name&quot;: &quot;Anil Madhavapeddy&quot;, &quot;affiliation&quot;: &quot;Cambridge&quot;},
    { &quot;name&quot;: &quot;Yaron Minsky&quot;, &quot;affiliation&quot;: &quot;Jane Street&quot;}
  ],
  &quot;is_online&quot;: true
}
</programlisting>
    <para>
      The outermost JSON value is usually a record (delimited by the
      curly braces) and contains an unordered set of key/value pairs.
      The keys must be strings but values can be any JSON type. In the
      example above, <literal>tags</literal> is a string list, while the
      <literal>authors</literal> field contains a list of records.
      Unlike OCaml lists, JSON lists can contain multiple different JSON
      types within a single list.
    </para>
    <para>
      This free-form nature of JSON types is both a blessing and a
      curse. It's very easy to generate JSON values, but code that
      parses them also has to handle subtle variations in how the values
      are represented. For example, what if the <literal>pages</literal>
      value above is actually represented as a string value of
      <literal>&quot;450&quot;</literal> instead of an integer?
    </para>
    <para>
      Our first task is to parse the JSON into a more structured OCaml
      type so that we can use static typing more effectively. When
      manipulating JSON in Python or Ruby, you might write unit tests to
      check that you have handled unusual inputs. The OCaml model
      prefers compile-time static checking as well as unit tests. For
      example, using pattern matching can warn you if you've not checked
      that a value can be <literal>Null</literal> as well as contain an
      actual value.
    </para>
    <note>
    <title>
    Installing the Yojson library
    </title>
    <para>
      There are several JSON libraries available for OCaml. For this
      chapter, we've picked the
      <ulink url="http://mjambon.com/yojson.html"><literal>Yojson</literal></ulink>
      library by Martin Jambon. It's easiest to install via OPAM by
      running <literal>opam install yojson</literal>. See
      <xref linkend="installation"/> for installation
      instructions if you haven't already got OPAM. Once installed, you
      can open it in the <literal>utop</literal> toplevel by:
    </para>
    <programlisting language="ocaml">
# #require &quot;yojson&quot; ;; 

/home/rwo/.opam/4.01.0dev+trunk/lib/easy-format: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/easy-format/easy_format.cmo: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/biniou: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/biniou/biniou.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/yojson: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/yojson/yojson.cmo: loaded
# open Yojson ;; 
</programlisting>
    </note>
  </sect1>
  <sect1 id="parsing-json-with-yojson">
    <title>Parsing JSON with Yojson</title>
    <para>
      The JSON specification has very few data types, and the
      <literal>Yojson.Basic.json</literal> type shown below is
      sufficient to express any valid JSON structure.
    </para>
    <programlisting language="ocaml">
(* json/yojson_basic.mli  *)
type json = [
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Int of int
  | `List of json list
  | `Null
  | `String of string
]
</programlisting>
    <para>
      Some interesting properties should leap out at you after reading
      this definition:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Some of the type definitions are
          <emphasis>recursive</emphasis> (that is, one of the algebraic
          data types includes a reference to the name of the type being
          defined). <literal>Assoc</literal> types can contain
          references to further JSON values and the
          <literal>List</literal> type can contain JSON values of
          different types, unlike the OCaml <literal>list</literal>
          whose contents must be of a uniform type.
        </para>
      </listitem>
      <listitem>
        <para>
          The definition specifically includes a <literal>Null</literal>
          variant for empty fields. OCaml doesn't allow null values by
          default, so this must be encoded like any other value.
        </para>
      </listitem>
      <listitem>
        <para>
          The type definition uses polymorphic variants and not normal
          variants. This will become significant later when we extend it
          with custom extensions to the JSON format.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Let's parse the earlier JSON example into this type now. The first
      stop is the <literal>Yojson.Basic</literal> documentation, where
      we find these helpful functions:
    </para>
    <programlisting language="ocaml">
(* json/yojson_basic.mli (starting from part 1) *)
val from_string : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt;
   string -&gt; json
(* Read a JSON value from a string.
   [buf]   : use this buffer at will during parsing instead of
             creating a new one. 
   [fname] : data file name to be used in error messages. It does not 
             have to be a real file. 
   [lnum]  : number of the first line of input. Default is 1. *)

val from_file : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; 
   string -&gt; json
(* Read a JSON value from a file. See [from_string] for the meaning of the optional
   arguments. *)

val from_channel : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt;
  in_channel -&gt; json
  (** Read a JSON value from a channel.
      See [from_string] for the meaning of the optional arguments. *)
</programlisting>
    <para>
      When first reading these interfaces, you can generally ignore the
      optional arguments (which have the question marks in the type
      signature), as they will be filled in with sensible values. In the
      above signature, the optional arguments offer finer control over
      the memory buffer allocation and error messages from parsing
      incorrect JSON.
    </para>
    <para>
      The type signature for these functions with the optional elements
      removed makes their purpose much clearer. The three ways of
      parsing JSON are either directly from a string, from a file on a
      filesystem, or via a buffered input channel.
    </para>
    <programlisting language="ocaml">
(* json/yojson_basic_simple.mli  *)
val from_string  : string     -&gt; json
val from_file    : string     -&gt; json
val from_channel : in_channel -&gt; json
</programlisting>
    <para>
      The next example shows both the string and file functions in
      action, assuming the JSON record is stored in a file called
      <literal>book.json</literal>.
    </para>
    <programlisting language="ocaml">
(* json/read_json.ml  *)
open Core.Std

let () =
  (* Read JSON file into an OCaml string *)
  let buf = In_channel.read_all &quot;book.json&quot; in
  (* Use the string JSON constructor *)
  let json1 = Yojson.Basic.from_string buf in
  (* Use the file JSON constructor *)
  let json2 = Yojson.Basic.from_file &quot;book.json&quot; in
  (* Test that the two values are the same *)
  print_endline (if json1 = json2 then &quot;OK&quot; else &quot;FAIL&quot;)
</programlisting>
    <para>
      You can build this by running <command>corebuild</command>.
    </para>
    <programlisting>
# running json/run_read_json.out.sh
$ corebuild -pkg yojson read_json.native
$ ./read_json.native
OK
</programlisting>
    <para>
      The <literal>from_file</literal> function accepts an input
      filename and takes care of opening and closing it for you. It's
      far more common to use <literal>from_string</literal> to construct
      JSON values though, since these strings come in via a network
      connection (we'll see more of this in
      <xref linkend="concurrent-programming-with-async"/>) or
      a database. Finally, the example checks that the two input
      mechanisms actually resulted in the same OCaml data structure.
    </para>
  </sect1>
  <sect1 id="selecting-values-from-json-structures">
    <title>Selecting values from JSON structures</title>
    <para>
      Now that we've figured out how to parse the example JSON into an
      OCaml value, let's manipulate it from OCaml code and extract
      specific fields.
    </para>
    <programlisting language="ocaml">
(* json/parse_book.ml  *)
open Core.Std

let () =
  (* Read the JSON file *)
  let json = Yojson.Basic.from_file &quot;book.json&quot; in

  (* Locally open the JSON manipulation functions *)
  let open Yojson.Basic.Util in
  let title = json |&gt; member &quot;title&quot; |&gt; to_string in
  let tags = json |&gt; member &quot;tags&quot; |&gt; to_list |&gt; filter_string in
  let pages = json |&gt; member &quot;pages&quot; |&gt; to_int in
  let is_online = json |&gt; member &quot;is_online&quot; |&gt; to_bool_option in
  let is_translated = json |&gt; member &quot;is_translated&quot; |&gt; to_bool_option in
  let authors = json |&gt; member &quot;authors&quot; |&gt; to_list in
  let names = List.map authors ~f:(fun json -&gt; member &quot;name&quot; json |&gt; to_string) in

  (* Print the results of the parsing *)
  printf &quot;Title: %s (%d)\n&quot; title pages;
  printf &quot;Authors: %s\n&quot; (String.concat ~sep:&quot;, &quot; names);
  printf &quot;Tags: %s\n&quot; (String.concat ~sep:&quot;, &quot; tags);
  let string_of_bool_option =
    function
    | None -&gt; &quot;&lt;none&gt;&quot;
    | Some true -&gt; &quot;yes&quot;
    | Some false -&gt; &quot;no&quot; in
  printf &quot;Online: %s\n&quot; (string_of_bool_option is_online);
  printf &quot;Translated: %s\n&quot; (string_of_bool_option is_translated)
</programlisting>
    <para>
      Build this with the same <literal>_tags</literal> file as the
      earlier example, and run <literal>ocamlbuild</literal> on the new
      file.
    </para>
    <programlisting>
# running json/run_parse_book.out.sh
$ corebuild -pkg yojson parse_book.native
$ ./parse_book.native
Title: Real World OCaml (450)
Authors: Jason Hickey, Anil Madhavapeddy, Yaron Minsky
Tags: functional programming, ocaml, algorithms
Online: yes
Translated: &lt;none&gt;
</programlisting>
    <para>
      This code introduces the <literal>Yojson.Basic.Util</literal>
      module, which contains <emphasis>combinator</emphasis> functions
      that let you easily map a JSON object into a more strongly-typed
      OCaml value.
    </para>
    <sidebar>
    <title>
    Functional Combinators
    </title>
    <para>
      Combinators are a design pattern that crops up quite often in
      functional programming. John Hughes defines them as &quot;a
      function which builds program fragments from program
      fragments&quot;. In a functional language, this generally means
      higher-order functions that combine other functions to apply
      useful transformations over values.
    </para>
    <para>
      You've already run across several of these in the
      <literal>List</literal> module:
    </para>
    <programlisting language="ocaml">
(* json/list_excerpt.mli  *)
val map  : 'a list -&gt; f:('a -&gt; 'b)   -&gt; 'b list
val fold : 'a list -&gt; init:'accum -&gt; f:('accum -&gt; 'a -&gt; 'accum) -&gt; 'accum
</programlisting>
    <para>
      <literal>map</literal> and <literal>fold</literal> are extremely
      common combinators that transform an input list by applying a
      function to each value of the list. The <literal>map</literal>
      combinator is simplest, with the resulting list being output
      directly. <literal>fold</literal> applies each value in the input
      list to a function that accumulates a single result, and returns
      that instead.
    </para>
    <programlisting language="ocaml">
(* json/list_excerpt.mli (starting from part 1) *)
val iter : 'a list -&gt; f:('a -&gt; unit) -&gt; unit
</programlisting>
    <para>
      <literal>iter</literal> is a more specialized combinator that is
      only useful in OCaml due to side-effects being allowed. The input
      function is applied to every value, but no result is supplied. The
      function must instead apply some side-effect such as changing a
      mutable record field or printing to the standard output.
    </para>
    </sidebar>
    <para>
      <literal>Yojson</literal> provides several combinators in the
      <literal>Yojson.Basic.Util</literal> module.
    </para>
    <informaltable>
      <tgroup cols="3">
        <colspec align="left"/>
        <colspec align="left"/>
        <colspec align="left"/>
        <thead>
          <row>
            <entry>
              Function
            </entry>
            <entry>
              Type
            </entry>
            <entry>
              Purpose
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              member
            </entry>
            <entry>
              <literal>string -&gt; json -&gt; json</literal>
            </entry>
            <entry>
              Select a named field from a JSON record.
            </entry>
          </row>
          <row>
            <entry>
              to_string
            </entry>
            <entry>
              <literal>json -&gt; string</literal>
            </entry>
            <entry>
              Convert a JSON value into an OCaml
              <literal>string</literal>. Raises an exception if this is
              impossible.
            </entry>
          </row>
          <row>
            <entry>
              to_int
            </entry>
            <entry>
              <literal>json -&gt; int</literal>
            </entry>
            <entry>
              Convert a JSON value into an OCaml <literal>int</literal>.
              Raises an exception if this is impossible.
            </entry>
          </row>
          <row>
            <entry>
              filter_string
            </entry>
            <entry>
              <literal>json list -&gt; string list</literal>
            </entry>
            <entry>
              Filter valid strings from a list of JSON fields, and
              return them as an OCaml list of strings.
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      We'll go through each of these uses one-by-one now. The examples
      below also use the <literal>|&gt;</literal> pipe-forward operator
      that we explained earlier in
      <xref linkend="variables-and-functions"/>. This lets us
      chain together multiple JSON selection functions and feed the
      output from one into the next one, without having to create
      separate <literal>let</literal> bindings for each one.
    </para>
    <para>
      Let's start with selecting a single <literal>title</literal> field
      from the record.
    </para>
    <programlisting language="ocaml">
...part 1 of json/parse_book.topscript
# open Yojson.Basic.Util ;; 
# let title = json |&gt; member &quot;title&quot; |&gt; to_string ;; 
val title : string = &quot;Real World OCaml&quot;
</programlisting>
    <para>
      The <literal>member</literal> function accepts a JSON object and
      named key and returns the JSON field associated with that key, or
      <literal>Null</literal>. Since we know that the
      <literal>title</literal> value is always a string in our example
      schema, we want to convert it to an OCaml string. The
      <literal>to_string</literal> function performs this conversion,
      and raises an exception if there is an unexpected JSON type. The
      <literal>|&gt;</literal> operator provides a convenient way to
      chain these operations together.
    </para>
    <programlisting language="ocaml">
...part 2 of json/parse_book.topscript
# let tags = json |&gt; member &quot;tags&quot; |&gt; to_list |&gt; filter_string ;; 
val tags : string list = [&quot;functional programming&quot;; &quot;ocaml&quot;; &quot;algorithms&quot;]
# let pages = json |&gt; member &quot;pages&quot; |&gt; to_int ;; 
val pages : int = 450
</programlisting>
    <para>
      The <literal>tags</literal> field is similar to
      <literal>title</literal>, but the field is a list of strings
      instead of a single one. Converting this to an OCaml
      <literal>string list</literal> is a two stage process. First, we
      convert the JSON <literal>List</literal> to an OCaml list of JSON
      values, and then filter out the <literal>String</literal> values
      as an OCaml <literal>string list</literal>. Remember that OCaml
      lists must contain values of the same type, so any JSON values
      that cannot be converted to a <literal>string</literal> will be
      skipped from the output of <literal>filter_string</literal>.
    </para>
    <programlisting language="ocaml">
...part 3 of json/parse_book.topscript
# let is_online = json |&gt; member &quot;is_online&quot; |&gt; to_bool_option ;; 
val is_online : bool option = Some true
# let is_translated = json |&gt; member &quot;is_translated&quot; |&gt; to_bool_option ;; 
val is_translated : bool option = None
</programlisting>
    <para>
      The <literal>is_online</literal> and
      <literal>is_translated</literal> fields are optional in our JSON
      schema, so no error should be raised if they are not present. The
      OCaml type is a <literal>bool option</literal> to reflect this,
      and can be extracted via <literal>to_bool_option</literal>. In our
      example JSON, only <literal>is_online</literal> is present and
      <literal>is_translated</literal> will be <literal>None</literal>.
    </para>
    <programlisting language="ocaml">
...part 4 of json/parse_book.topscript
# let authors = json |&gt; member &quot;authors&quot; |&gt; to_list ;; 
val authors : Yojson.Basic.json list =
  [`Assoc
     [(&quot;name&quot;, `String &quot;Jason Hickey&quot;); (&quot;affiliation&quot;, `String &quot;Google&quot;)];
   `Assoc
     [(&quot;name&quot;, `String &quot;Anil Madhavapeddy&quot;);
      (&quot;affiliation&quot;, `String &quot;Cambridge&quot;)];
   `Assoc
     [(&quot;name&quot;, `String &quot;Yaron Minsky&quot;);
      (&quot;affiliation&quot;, `String &quot;Jane Street&quot;)]]
</programlisting>
    <para>
      The final use of JSON combinators is to extract all the
      <literal>name</literal> fields from the list of authors. We first
      construct the <literal>author list</literal>, and then
      <literal>map</literal> it into a <literal>string list</literal>.
      Notice that the example explicitly binds
      <literal>authors</literal> to a variable name. It can also be
      written more succinctly using the pipe-forward operator:
    </para>
    <programlisting language="ocaml">
...part 5 of json/parse_book.topscript
# let names =
  json |&gt; member &quot;authors&quot; |&gt; to_list 
  |&gt; List.map ~f:(fun json -&gt; member &quot;name&quot; json |&gt; to_string) ;; 
val names : string list =
  [&quot;Jason Hickey&quot;; &quot;Anil Madhavapeddy&quot;; &quot;Yaron Minsky&quot;]
</programlisting>
    <para>
      This style of programming which omits variable names and chains
      functions together is known as <emphasis>point-free
      programming</emphasis>. It's a succinct style, but shouldn't be
      overused due to the increased difficulty of debugging intermediate
      values. If an explicit name is assigned to each stage of the
      transformations, debuggers in particular have an easier time
      making the program flow easier to represent to the programmer.
    </para>
    <para>
      This technique of using chained parsing functions is very powerful
      in combination with the OCaml type system. Many errors that don't
      make sense at runtime (for example, mixing up lists and objects)
      will be caught statically via a type error.
    </para>
  </sect1>
  <sect1 id="constructing-json-values">
    <title>Constructing JSON values</title>
    <para>
      Building and printing JSON values is pretty straightforward given
      the <literal>Yojson.Basic.json</literal> type. You can just
      construct values of type <literal>json</literal> and call the
      <literal>to_string</literal> function on them. Let's remind
      ourselves of the <literal>Yojson.Basic.json</literal> type again.
    </para>
    <programlisting language="ocaml">
type json = [
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Int of int
  | `List of json list
  | `Null
  | `String of string
]
</programlisting>
    <para>
      We can directly build a JSON value against this type and use the
      pretty-printing functions in the <literal>Yojson.Basic</literal>
      module to display JSON output.
    </para>
    <programlisting language="ocaml">
...part 1 of json/build_json.topscript
# let person = `Assoc [ (&quot;name&quot;, `String &quot;Anil&quot;) ] ;; 
val person : [&gt; `Assoc of (string * [&gt; `String of string ]) list ] =
  `Assoc [(&quot;name&quot;, `String &quot;Anil&quot;)]
</programlisting>
    <para>
      In the example above, we've constructed a simple JSON object that
      represents a single person. We haven't actually defined the type
      of <literal>person</literal> explicitly, as we're relying on the
      magic of polymorphic variants to make this all work.
    </para>
    <para>
      The OCaml type system infers a type for <literal>person</literal>
      based on how you construct its value. In this case, only the
      <literal>Assoc</literal> and <literal>String</literal> variants
      are used to define the record, and so the inferred type only
      contains these fields without knowledge of the other possible
      allowed variants in JSON records that you haven't used yet
      (<emphasis>e.g.</emphasis> <literal>Int</literal> or
      <literal>Null</literal>).
    </para>
    <programlisting language="ocaml">
...part 2 of json/build_json.topscript
# Yojson.Basic.pretty_to_string ;; 
- : ?std:bool -&gt; Yojson.Basic.json -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      The <literal>pretty_to_string</literal> function has a more
      explicit signature that requires an argument of type
      <literal>Yojson.Basic.json</literal>. When
      <literal>person</literal> is applied to
      <literal>pretty_to_string</literal>, the inferred type of
      <literal>person</literal> is statically checked against the
      structure of the <literal>json</literal> type to ensure that
      they're compatible.
    </para>
    <programlisting language="ocaml">
...part 3 of json/build_json.topscript
# Yojson.Basic.pretty_to_string person ;; 
- : string = &quot;{ \&quot;name\&quot;: \&quot;Anil\&quot; }&quot;
# Yojson.Basic.pretty_to_channel stdout person ;; 

{ &quot;name&quot;: &quot;Anil&quot; }- : unit = ()
</programlisting>
    <para>
      In this case, there are no problems. Our <literal>person</literal>
      value has an inferred type that is a valid sub-type of
      <literal>json</literal>, and so the conversion to a string just
      works without us ever having to explicitly specify a type for
      <literal>person</literal>. Type inference lets you write more
      succinct code without sacrificing runtime reliability, as all the
      uses of polymorphic variants are still checked at compile-time.
    </para>
    <sidebar>
    <title>
    Polymorphic variants and easier type checking
    </title>
    <para>
      One difficulty you will encounter is that type errors involving
      polymorphic variants can be quite verbose if you make a mistake in
      your code. For example, suppose you build an
      <literal>Assoc</literal> and mistakenly include a single value
      instead of a list of keys:
    </para>
    <programlisting language="ocaml">
...part 4 of json/build_json.topscript
# let person = `Assoc (&quot;name&quot;, `String &quot;Anil&quot;);; 
val person : [&gt; `Assoc of string * [&gt; `String of string ] ] =
  `Assoc (&quot;name&quot;, `String &quot;Anil&quot;)
# Yojson.Basic.pretty_to_string person ;; 
Characters 30-36:
Error: This expression has type
         [&gt; `Assoc of string * [&gt; `String of string ] ]
       but an expression was expected of type Yojson.Basic.json
       Types for tag `Assoc are incompatible
</programlisting>
    <para>
      The type error above is more verbose than it needs to be, which
      can be inconvenient to wade through for larger values. You can
      help the compiler to narrow down this error to a shorter form by
      adding explicit type annotations as a hint about your intentions.
    </para>
    <programlisting language="ocaml">
...part 5 of json/build_json.topscript
# let (person : Yojson.Basic.json) =
  `Assoc (&quot;name&quot;, `String &quot;Anil&quot;);; 
Characters 37-68:
Error: This expression has type 'a * 'b
       but an expression was expected of type
         (string * Yojson.Basic.json) list
</programlisting>
    <para>
      We've annotated <literal>person</literal> as being of type
      <literal>Yojson.Basic.json</literal>, and as a result the compiler
      spots that the argument to the <literal>Assoc</literal> variant
      has the incorrect type. This illustrates the strengths and
      weaknesses of polymorphic variants: they make it possible to
      easily subtype across module boundaries, but the error messages
      can be more confusing. However, a bit of careful manual type
      annotation is all it takes to make tracking down such issues much
      easier.
    </para>
    <para>
      We'll discuss more techniques like this that help you interpret
      type errors more easily in
      <xref linkend="the-compiler-frontend-parsing-and-type-checking"/>.
    </para>
    </sidebar>
  </sect1>
  <sect1 id="using-non-standard-json-extensions">
    <title>Using non-standard JSON extensions</title>
    <para>
      The standard JSON types are <emphasis>really</emphasis> basic, and
      OCaml types are far more expressive. Yojson supports an extended
      JSON format for those times when you're not interoperating with
      external systems and just want a convenient human-readable local
      format. The <literal>Yojson.Safe.json</literal> type is a superset
      of the <literal>Basic</literal> polymorphic variant, and looks
      like this:
    </para>
    <programlisting language="ocaml">
type json = [
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Floatlit of string
  | `Int of int
  | `Intlit of string
  | `List of json list
  | `Null
  | `String of string
  | `Stringlit of string
  | `Tuple of json list
  | `Variant of string * json option
]
</programlisting>
    <para>
      The <literal>Safe.json</literal> type includes all of the variants
      from <literal>Basic.json</literal> and extends it with a few more
      useful ones. A standard JSON type such as a
      <literal>String</literal> will type-check against both the
      <literal>Basic</literal> module and also the non-standard
      <literal>Safe</literal> module. If you use the extended values
      with the <literal>Basic</literal> module however, the compiler
      will reject your code until you make it compliant with the
      portable subset of JSON.
    </para>
    <para>
      Yojson supports the following JSON extensions:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          The <literal>lit</literal> suffix denotes that the value is
          stored as a JSON string. For example, a
          <literal>Floatlit</literal> will be stored as
          <literal>&quot;1.234&quot;</literal> instead of
          <literal>1.234</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <literal>Tuple</literal> type is stored as
          <literal>(&quot;abc&quot;, 123)</literal> instead of a list.
        </para>
      </listitem>
      <listitem>
        <para>
          The <literal>Variant</literal> type encodes OCaml variants
          more explicitly, as <literal>&lt;&quot;Foo&quot;&gt;</literal>
          or <literal>&lt;&quot;Bar&quot;:123&gt;</literal> for a
          variant with parameters.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The only purpose of these extensions is to have greater control
      over how OCaml values are represented in JSON (for instance,
      storing a floating-pointer number as a JSON string). The output
      still obeys the same standard format that can be easily exchanged
      with other languages.
    </para>
    <para>
      You can convert a <literal>Safe.json</literal> to a
      <literal>Basic.json</literal> type by using the
      <literal>to_basic</literal> function as follows.
    </para>
    <programlisting language="ocaml">
val to_basic : json -&gt; Yojson.Basic.json
(** Tuples are converted to JSON arrays, Variants are converted to
    JSON strings or arrays of a string (constructor) and a json value
    (argument). Long integers are converted to JSON strings.
    Examples:

    `Tuple [ `Int 1; `Float 2.3 ]   -&gt;    `List [ `Int 1; `Float 2.3 ]
    `Variant (&quot;A&quot;, None)            -&gt;    `String &quot;A&quot;
    `Variant (&quot;B&quot;, Some x)          -&gt;    `List [ `String &quot;B&quot;, x ]
    `Intlit &quot;12345678901234567890&quot;  -&gt;    `String &quot;12345678901234567890&quot;
 *)
</programlisting>
  </sect1>
  <sect1 id="automatically-mapping-json-to-ocaml-types">
    <title>Automatically mapping JSON to OCaml types</title>
    <para>
      The combinators described earlier make it easy to write functions
      that extract fields from JSON records, but the process is still
      pretty manual. When you implement larger specifications, it's much
      easier to generate the mappings from JSON schemas to OCaml values
      more mechanically than writing conversion functions individually.
    </para>
    <para>
      We'll cover an alternative JSON processing method that is better
      for larger-scale JSON handling now, using the
      <ulink url="http://mjambon.com/atd-biniou-intro.html">ATD</ulink>
      tool. This will introduce our first <emphasis>Domain Specific
      Language</emphasis> that compiles JSON specifications into OCaml
      modules, which are then used throughout your application.
    </para>
    <note>
    <title>
    Installing the ATDgen library and tool
    </title>
    <para>
      ATDgen installs some OCaml libraries that interface with Yojson,
      and also a command-line tool that generates code. It can all be
      installed via OPAM:
    </para>
    <programlisting>
# running json/install_atdgen.out.sh
$ opam install atdgen
$ atdgen -version
1.2.3
</programlisting>
    <para>
      The command-line tool will be installed within your
      <filename>~/.opam</filename> directory, and should already be on
      your <literal>PATH</literal> from running <command>opam config
      env</command>. See <xref linkend="installation"/> if
      this isn't working.
    </para>
    </note>
    <sect2 id="atd-basics">
      <title>ATD basics</title>
      <para>
        The idea behind ATD is to specify the format of the JSON in a
        separate file, and then run a compiler
        (<command>atdgen</command>) that outputs OCaml code to construct
        and parse JSON values. This means that you don't need to write
        any OCaml parsing code at all, as it will all be autogenerated
        for you.
      </para>
      <para>
        Let's go straight into looking at an example of how this works,
        by using a small portion of the GitHub API. GitHub is a popular
        code hosting and sharing website that provides a JSON-based web
        <ulink url="http://developer.github.com">API</ulink>. The ATD
        code fragment below describes the GitHub authorization API
        (which is based on a pseudo-standard web protocol known as
        OAuth).
      </para>
      <programlisting>
(* json/github.atd *)
type scope = [
    User &lt;json name=&quot;user&quot;&gt;
  | Public_repo &lt;json name=&quot;public_repo&quot;&gt;
  | Repo &lt;json name=&quot;repo&quot;&gt;
  | Repo_status &lt;json name=&quot;repo_status&quot;&gt;
  | Delete_repo &lt;json name=&quot;delete_repo&quot;&gt;
  | Gist &lt;json name=&quot;gist&quot;&gt;
]

type app = {
  name: string;
  url: string;
}  &lt;ocaml field_prefix=&quot;app_&quot;&gt;

type authorization_request = {
  scopes: scope list;
  note: string;
} &lt;ocaml field_prefix=&quot;auth_req_&quot;&gt;

type authorization_response = {
  scopes: scope list;
  token: string;
  app: app;
  url: string;
  id: int;
  ?note: string option;
  ?note_url: string option;
}
</programlisting>
      <para>
        The ATD specification syntax is deliberately quite similar to
        OCaml type definitions. Every JSON record is assigned a type
        name (<emphasis>e.g.</emphasis> <literal>app</literal> in the
        example above). You can also define variants that are similar to
        OCaml's variant types (<emphasis>e.g.</emphasis>
        <literal>scope</literal> in the example).
      </para>
    </sect2>
    <sect2 id="atd-annotations">
      <title>ATD annotations</title>
      <para>
        ATD deviates significantly from OCaml syntax due to its support
        for annotations within the specification. The annotations can
        customize the code that is generated for a particular target (of
        which the OCaml backend is of most interest to us).
      </para>
      <para>
        For example, the GitHub <literal>scope</literal> field above is
        defined as a variant type with each option starting with an
        uppercase letter as is conventional for OCaml variants. However,
        the the JSON values that come back from GitHub are actually
        lowercase, and so aren't exactly the same as the option name.
      </para>
      <para>
        The annotation
        <literal>&lt;json name=&quot;user&quot;&gt;</literal> signals
        that the JSON value of the field is <literal>user</literal>, but
        that the variable name of the parsed variant in OCaml should be
        <literal>User</literal>. These annotations are often useful to
        map JSON values to reserved keywords in OCaml
        (<emphasis>e.g.</emphasis> <literal>type</literal>).
      </para>
    </sect2>
    <sect2 id="compiling-atd-specifications-to-ocaml">
      <title>Compiling ATD specifications to OCaml</title>
      <para>
        The ATD specification we defined above can be compiled to OCaml
        code using the <command>atdgen</command> command-line tool.
        Let's run the compiler twice, to generate some OCaml type
        definitions and also a JSON serializing module that converts
        between input data and those type definitions.
      </para>
      <para>
        The <command>atdgen</command> command will generate some new
        files in your current directory. <literal>Github_t.ml</literal>
        and <literal>Github_t.mli</literal> will contain an OCaml module
        with types defines that correspond to the ATD file.
      </para>
      <programlisting>
# running json/build_github_atd.out.sh
$ atdgen -t github.atd
$ atdgen -j github.atd
$ ocamlfind ocamlc -package atd -i github_t.mli
type scope =
    [ `Delete_repo | `Gist | `Public_repo | `Repo | `Repo_status | `User ]
type app = { app_name : string; app_url : string; }
type authorization_request = {
  auth_req_scopes : scope list;
  auth_req_note : string;
}
type authorization_response = {
  scopes : scope list;
  token : string;
  app : app;
  url : string;
  id : int;
  note : string option;
  note_url : string option;
}
</programlisting>
      <para>
        There is an obvious correspondence to the ATD definition. Note
        that field names in OCaml records in the same module cannot
        shadow each other, and so we instruct ATDgen to prefix every
        field with a name that distinguishes it from other records in
        the same module. For example,
        <literal>&lt;ocaml field_prefix=&quot;auth_req_&quot;&gt;</literal>
        in the ATD spec prefixes every field name in the generated
        <literal>authorization_request</literal> record with
        <literal>auth_req</literal>.
      </para>
      <para>
        The <literal>Github_t</literal> module only contains the type
        definitions, while <literal>Github_j</literal> provides
        serialization functions to and from JSON. You can read the
        <literal>github_j.mli</literal> to see the full interface, but
        the important functions for most uses are the conversion
        functions to and from a string. For our example above, this
        looks like:
      </para>
      <programlisting language="ocaml">
(* json/github_j_excerpt.mli  *)
val string_of_authorization_request :
  ?len:int -&gt; authorization_request -&gt; string
  (** Serialize a value of type {!authorization_request}
      into a JSON string.
      @param len specifies the initial length
                 of the buffer used internally.
                 Default: 1024. *)

val string_of_authorization_response :
  ?len:int -&gt; authorization_response -&gt; string
  (** Serialize a value of type {!authorization_response}
      into a JSON string.
      @param len specifies the initial length
                 of the buffer used internally.
                 Default: 1024. *)
</programlisting>
      <para>
        This is pretty convenient! We've now written a single ATD file,
        and all the OCaml boilerplate to convert between JSON and a
        strongly typed record has been generated for us. You can control
        various aspects of the serializer by passing flags to
        <command>atdgen</command>. The important ones for JSON are:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>-j-std</literal>: Convert tuples and variants into
            standard JSON and refuse to print NaN and infinities. You
            should specify this if you intend to interoperate with
            services that aren't using ATD.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>-j-custom-fields FUNCTION</literal>: call a custom
            function for every unknown field encountered, instead of
            raising a parsing exception.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>-j-defaults</literal>: always explicitly output a
            JSON value if possible. This requires the default value for
            that field to be defined in the ATD specification.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The full
        <ulink url="http://mjambon.com/atdgen/atdgen-manual.html">ATD
        specification</ulink> is quite sophisticated and documented
        online. The ATD compiler can also target formats other than JSON
        and outputs code for other languages (such as Java) if you need
        more interoperability.
      </para>
      <para>
        There are also several similar projects that automate the code
        generation process. <ulink url="http://piqi.org">Piqi</ulink>
        supports conversions between XML. JSON, and the Google protobuf
        format, and <ulink url="http://thrift.apache.org">Thrift</ulink>
        supports many other programming languages and includes OCaml
        bindings.
      </para>
    </sect2>
    <sect2 id="example-querying-github-organization-information">
      <title>Example: Querying GitHub organization information</title>
      <para>
        Let's finish up with an example of some live JSON parsing from
        GitHub, and build a tool to query organization information via
        their API. Start by looking at the online
        <ulink url="http://developer.github.com/v3/orgs/">API
        documentation</ulink> for GitHub to see what the JSON schema for
        retrieving the organization information looks like.
      </para>
      <para>
        Now create an ATD file that covers the fields we need. Any extra
        fields present in the response will be ignored by the ATD
        parser, so we don't need a completely exhaustive specification
        of every field that GitHub might send back.
      </para>
      <programlisting>
(* json/github_org.atd *)
type org = {
  login: string;
  id: int;
  url: string;
  ?name: string option;
  ?blog: string option;
  ?email: string option;
  public_repos: int
}
</programlisting>
      <para>
        Let's build the OCaml type declaration first by calling
        <literal>atdgen -t</literal> on the specification file.
      </para>
      <programlisting>
# running json/generate_github_org_types.out.sh
$ atdgen -t github_org.atd
$ cat github_org_t.mli
(* Auto-generated from &quot;github_org.atd&quot; *)


type org = {
  login: string;
  id: int;
  url: string;
  name: string option;
  blog: string option;
  email: string option;
  public_repos: int
}
</programlisting>
      <para>
        The OCaml type has an obvious mapping to the ATD spec, but we
        still need the logic to convert JSON buffers to and from this
        type. Calling <literal>atdgen -j</literal> will generate this
        serialization code for us in a new file called
        <literal>github_org_j.ml</literal>.
      </para>
      <programlisting>
# running json/generate_github_org_json.out.sh
$ atdgen -j github_org.atd
$ cat github_org_j.mli
(* Auto-generated from &quot;github_org.atd&quot; *)


type org = Github_org_t.org = {
  login: string;
  id: int;
  url: string;
  name: string option;
  blog: string option;
  email: string option;
  public_repos: int
}

val write_org :
  Bi_outbuf.t -&gt; org -&gt; unit
  (** Output a JSON value of type {!org}. *)

val string_of_org :
  ?len:int -&gt; org -&gt; string
  (** Serialize a value of type {!org}
      into a JSON string.
      @param len specifies the initial length
                 of the buffer used internally.
                 Default: 1024. *)

val read_org :
  Yojson.Safe.lexer_state -&gt; Lexing.lexbuf -&gt; org
  (** Input JSON data of type {!org}. *)

val org_of_string :
  string -&gt; org
  (** Deserialize JSON data of type {!org}. *)

</programlisting>
      <para>
        The <literal>Github_org_j</literal> serializer interface
        contains everything we need to map to-and-from the OCaml types
        and JSON. The easiest way to use this interface is by using the
        <literal>string_of_org</literal> and
        <literal>org_of_string</literal> functions, but there are also
        more advanced low-level buffer functions available if you need
        higher performance (but we won't go into that in this tutorial).
      </para>
      <para>
        All we need to complete our example is an OCaml program that
        fetches the JSON and uses these modules to output a one-line
        summary. Our example below does just that.
      </para>
      <para>
        The code below calls the cURL command-line utility by using the
        <literal>Core_extended.Shell</literal> interface to run an
        external command and capture its output. You'll need to ensure
        that you have cURL installed on your system before running the
        example. You might also need to
        <literal>opam install core_extended</literal> if you haven't
        installed it previously.
      </para>
      <programlisting language="ocaml">
(* json/github_org_info.ml  *)
open Core.Std

let print_org file () =
  let url = sprintf &quot;https://api.github.com/orgs/%s&quot; file in
  Core_extended.Shell.run_full &quot;curl&quot; [url]
  |&gt; Github_org_j.org_of_string
  |&gt; fun org -&gt;
  let open Github_org_t in
  let name = Option.value ~default:&quot;???&quot; org.name in
  printf &quot;%s (%d) with %d public repos\n&quot;
    name org.id org.public_repos

let () =
  Command.basic ~summary:&quot;Print Github organization information&quot;
    Command.Spec.(empty +&gt; anon (&quot;organization&quot; %: string))
    print_org
  |&gt; Command.run
</programlisting>
      <para>
        Below is a short shell script that generates all of the OCaml
        code and also builds the final executable.
      </para>
      <programlisting language="ocaml">
(* json/build_github_org.out  *)
$ atdgen -t github_org.atd
$ atdgen -j github_org.atd
$ corebuild -pkg core_extended,yojson,atdgen github_org_info.native
File &quot;github_org_j.ml&quot;, line 19, characters 4-16:
Warning 32: unused value string_of__1.
</programlisting>
      <para>
        You can now run the command-line tool with a single argument to
        specify the name of the organization, and it will dynamically
        fetch the JSON from the web, parse it, and render the summary to
        your console.
      </para>
      <programlisting>
# running json/run_github_org.out.sh
$ ./github_org_info.native mirage
Mirage account (131943) with 36 public repos
$ ./github_org_info.native janestreet
??? (3384712) with 34 public repos
</programlisting>
      <para>
        The JSON returned from the <literal>janestreet</literal> query
        is missing an organization name, but this is explicitly
        reflected in the OCaml type since the ATD spec marked
        <literal>name</literal> as an optional field. Our OCaml code
        explicitly handles this case and doesn't have to worry about
        null-pointer exceptions. Similarly, the JSON integer for the
        <literal>id</literal> is mapped into a native OCaml integer via
        the ATD conversion.
      </para>
      <para>
        While this tool is obviously quite simple, the ability to
        specify optional and default fields is very powerful. Take a
        look at the full ATD specification for the GitHub API in the
        <ulink url="http://github.com/avsm/ocaml-github"><literal>ocaml-github</literal></ulink>
        repository online, which has lots of quirks typical in
        real-world web APIs.
      </para>
      <para>
        Our example shells out to <literal>curl</literal> on the
        command-line to obtain the JSON, which is rather inefficient.
        We'll explain how to integrate the HTTP fetch directly into your
        OCaml application later on in
        <xref linkend="concurrent-programming-with-async"/>.
      </para>
    </sect2>
  </sect1>
</chapter><chapter id="parsing-with-ocamllex-and-menhir">
  <title>Parsing with OCamllex and Menhir</title>
  <para>
    Many programming tasks start with the interpretion of some form of
    structured textual data. <emphasis>Parsing</emphasis> is the process
    of converting such data into data structures that are easy to
    program against. For simple formats, it's often enough to parse the
    data in an ad-hoc way, say, by breaking up the data into lines, and
    then using regular expressions for breaking those lines down into
    their component pieces.
  </para>
  <para>
    But this simplistic approach tends to fall down when parsing more
    complicated data, particularly data with the kind of recursive
    structure you find in full-blown programming languages or flexible
    data formats like JSON and XML. Parsing such formats accurately and
    efficiently while providing useful error messages is a complex task.
  </para>
  <para>
    Often, you can find an existing parsing library that handles these
    issues for you. But there are tools to help simplify the task when
    you do need to write a parser, in the form of <emphasis>parser
    generators</emphasis>. A parser generator creates a parser from a
    specification of the data format that you want to parse, and uses
    that to generate a parser.
  </para>
  <para>
    Parser generators have a long history, including tools like
    <command>lex</command> and <literal>yacc</literal> that date back to
    the early 1970's. OCaml has its own alternatives, including
    <command>ocamllex</command>, which replaces <command>lex</command>,
    and <command>ocamlyacc</command> and <command>menhir</command>,
    which are replacements for <literal>yacc</literal>. We'll explore
    these tools in the course of walking through the implementation of a
    parser for the JSON serialization format that we discussed in
    <xref linkend="handling-json-data"/>.
  </para>
  <para>
    Parsing is a broad and often intricate topic, and our purpose here
    is not to teach all of the theoretical issues, but to provide a
    pragmatic introduction of how to build a parser in OCaml.
  </para>
  <note>
  <title>
  Menhir <emphasis>vs</emphasis> <command>ocamlyacc</command>
  </title>
  <para>
    Menhir is an alternative parser generator that is generally superior
    to the venerable <command>ocamlyacc</command>, which dates back
    quite a few years. Menhir is mostly compatible with
    <command>ocamlyacc</command> grammars, and so you can usually just
    switch to Menhir and expect older code to work (with some minor
    differences described in the Menhir manual).
  </para>
  <para>
    The biggest advantage of Menhir is that its error messages are
    generally more human-comprehensible, and the parsers that it
    generates are fully reentrant and can be parameterized in OCaml
    modules more easily. We recommend that any new code you develop
    should use Menhir instead of <command>ocamlyacc</command>.
  </para>
  <para>
    Menhir isn't distributed directly with OCaml, but is available
    through OPAM by running <literal>opam install menhir</literal>.
  </para>
  </note>
  <sect1 id="lexing-and-parsing">
    <title>Lexing and parsing</title>
    <para>
      Parsing is traditionally broken down into two parts:
      <emphasis>lexical analysis</emphasis>, which is a kind of
      simplified parsing phase that converts a stream of characters into
      a stream of logical tokens; and full-on parsing, which involves
      converting a stream of tokens into the final representation, which
      is often in the form of a tree-like data-structure called an
      <emphasis>abstract syntax-tree</emphasis>, or AST.
    </para>
    <para>
      It's confusing that the term parsing is applied to both the
      overall process of converting textual data to structured data, and
      also more specifically to the second phase of converting a stream
      of tokens to an AST, so from here on in, we'll use the term
      parsing to refer only to this second phase.
    </para>
    <para>
      Let's consider lexing and parsing in the context of the JSON
      format. Here's an example of a snippet of text that represents a
      JSON object containing a string labeled <literal>title</literal>,
      and an array containing two objects, each with a name and array of
      zip codes.
    </para>
    <programlisting language="json">
{
  &quot;title&quot;: &quot;Cities&quot;,
  &quot;cities&quot;: [
    { &quot;name&quot;: &quot;Chicago&quot;,  &quot;zips&quot;: [60601] },
    { &quot;name&quot;: &quot;New York&quot;, &quot;zips&quot;: [10004] } 
  ]
}
</programlisting>
    <para>
      At a syntactic level, we can think of a JSON file as a series of
      simple logical units, like curly braces, square brackets, commas,
      colons, identifiers, numbers, and quoted strings. Thus, we could
      represent our JSON text as a sequence of tokens of the following
      type.
    </para>
    <programlisting language="ocaml">
(* parsing/manual_token_type.ml  *)
type token =
  | TRUE
  | STRING of string
  | RIGHT_BRACK
  | RIGHT_BRACE
  | NULL
  | LEFT_BRACK
  | LEFT_BRACE
  | INT of int
  | ID of string
  | FLOAT of float
  | FALSE
  | EOF
  | COMMA
  | COLON
</programlisting>
    <para>
      Note that this representation loses some information about the
      original text. For example, white space is not represented. It's
      common, and indeed useful, for the token stream to forget some
      details of the original text that are not required for
      understanding its meaning.
    </para>
    <para>
      If we converted the above example into a list of these tokens, it
      would look something like this.
    </para>
    <programlisting language="ocaml">
(* parsing/tokens.ml  *)
[ LEFT_BRACE; ID(&quot;title&quot;); COLON; STRING(&quot;Cities&quot;); COMMA; ID(&quot;cities&quot;); ...
</programlisting>
    <para>
      This kind of representation is easier to work with than the
      original text, since it gets rid of some unimportant syntactic
      details and adds useful structure. But it's still a good deal more
      low-level than the simple AST we used for representing JSON data
      in <xref linkend="handling-json-data"/>, shown below.
    </para>
    <programlisting language="ocaml">
(* parsing/json.ml  *)
type value = [
  | `Assoc of (string * value) list
  | `Bool of bool
  | `Float of float
  | `Int of int
  | `List of value list
  | `Null
  | `String of string
]
</programlisting>
    <para>
      This representation is much richer than our token stream,
      capturing the fact that JSON values can be nested inside each
      other, and that JSON has a variety of value types, including
      numbers, strings, arrays, and objects. The above type is
      effectively an AST, and the job of the parser we'll write will be
      to convert a token stream into a value of this type, as shown
      below.
    </para>
    <programlisting language="ocaml">
(* parsing/parsed_example.ml  *)
`Assoc
  [&quot;title&quot;, `String &quot;Cities&quot;;
   &quot;cities&quot;, `List
     [`Assoc [&quot;name&quot;, `String &quot;Chicago&quot;; &quot;zips&quot;, `List [`Int 60601]];
      `Assoc [&quot;name&quot;, `String &quot;New York&quot;; &quot;zips&quot;, `List [`Int 10004]]]]
</programlisting>
  </sect1>
  <sect1 id="defining-a-parser">
    <title>Defining a parser</title>
    <para>
      A parser-specification file has suffix <literal>.mly</literal> and
      contains several sections that are broken up by separator lines
      consisting of the characters <literal>%%</literal> on a line by
      themselves. The first section of the file is for declarations,
      including token and type specifications, precedence directives,
      and other output directives, and the second section is for
      specifying the grammar of the language to be parsed.
    </para>
    <para>
      We'll start by declaring the list of tokens. A token is declared
      using the syntax
      <literal>%token &lt;</literal><emphasis>type</emphasis><literal>&gt;</literal>
      <emphasis>uid</emphasis>, where the
      <literal>&lt;type&gt;</literal> is optional, and
      <emphasis>uid</emphasis> is a capitalized identifier. For JSON, we
      need tokens for numbers, strings, identifiers, and punctuation.
    </para>
    <programlisting language="ocaml">
(* parsing/parser.mly  *)
%token &lt;int&gt; INT
%token &lt;float&gt; FLOAT
%token &lt;string&gt; ID
%token &lt;string&gt; STRING
%token TRUE
%token FALSE
%token NULL
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_BRACK
%token RIGHT_BRACK
%token COLON
%token COMMA
%token EOF
</programlisting>
    <para>
      The
      <literal>&lt;</literal><emphasis>type</emphasis><literal>&gt;</literal>
      specifications mean that a token carries a value. The
      <literal>INT</literal> token carries an integer value with it,
      <literal>FLOAT</literal> has a <literal>float</literal> value, and
      <literal>STRING</literal> carries a <literal>string</literal>
      value. The remaining tokens, such as <literal>TRUE</literal>,
      <literal>FALSE</literal> or the punctuation, aren't associated
      with any value and so we can omit the
      <literal>&lt;</literal><emphasis>type</emphasis><literal>&gt;</literal>
      specification.
    </para>
    <sect2 id="describing-the-grammar">
      <title>Describing the grammar</title>
      <para>
        The next thing we need to do is to specify the grammar of a JSON
        expression. <command>menhir</command>, like many parsers,
        expresses grammars as <emphasis>context free
        grammars</emphasis>. (More precisely, <command>menhir</command>
        supports LR(1) grammars, but we will ignore that technical
        distinction here.) You can think of a context-free grammar as a
        set of abstract names, called <emphasis>non-terminal
        symbols</emphasis>, along with a collection of rules for
        transforming a non-terminal symbol into a sequence, where each
        element of the sequence is either a token or another
        non-terminal symbol. A sequence of tokens is parsable by a
        grammar if you can apply the grammar's rules to produce a series
        of transformations, starting at a distinguished <emphasis>start
        symbol</emphasis>, that produces the token sequence in question.
      </para>
      <para>
        We'll start describing the JSON grammar by declaring the start
        symbol to be the non-terminal symbol <literal>prog</literal>,
        and by declaring that when parsed, a <literal>prog</literal>
        value should be converted into an OCaml value of type
        <literal>Json.value option</literal>. We then end the
        declaration section of the parser with a <literal>%%</literal>.
      </para>
      <programlisting language="ocaml">
(* parsing/parser.mly (starting from part 1) *)
%start &lt;Json.value option&gt; prog
%%
</programlisting>
      <para>
        Once that's in place, we can start specifying the productions.
        In <command>menhir</command>, productions are organized into
        <emphasis>rules</emphasis>, where each rule lists all the
        possible productions for a given non-terminal. Here, for
        example, is the rule for <literal>prog</literal>.
      </para>
      <programlisting language="ocaml">
(* parsing/parser.mly (starting from part 2) *)
prog:
  | EOF       { None }
  | v = value { Some v }
  ;
</programlisting>
      <para>
        The syntax for this is reminiscent of an OCaml match statement.
        The pipes separate the individual productions, and the code in
        curly-braces is OCaml code that generates the OCaml value
        corresponding to the production in question. In the case of
        <literal>prog</literal>, we have two cases: either there's an
        <literal>EOF</literal>, which means the text is empty, and so
        there's no JSON value to read, and so we return the OCaml value
        <literal>None</literal>; or we have an instance of the
        <literal>value</literal> non-terminal, which corresponds to a
        well-formed JSON value, in which case we wrap the corresponding
        <literal>Json.value</literal> in a <literal>Some</literal> tag.
        Note that in the <literal>value</literal> case, we wrote
        <literal>v = value</literal> to bind the OCaml value that
        corresponds to to the variable <literal>v</literal>, which we
        can then use within the curly-braces for that production.
      </para>
      <para>
        Now let's consider a more complicated example, the rule for the
        <literal>value</literal> symbol.
      </para>
      <programlisting language="ocaml">
(* parsing/parser.mly (starting from part 3) *)
value:
  | LEFT_BRACE; obj = object_fields; RIGHT_BRACE
    { `Assoc obj }
  | LEFT_BRACK; vl = array_values; RIGHT_BRACK
    { `List vl }
  | s = STRING
    { `String s }
  | i = INT
    { `Int i }
  | x = FLOAT
    { `Float x }
  | TRUE
    { `Bool true }
  | FALSE
    { `Bool false }
  | NULL
    { `Null }
  ;
</programlisting>
      <para>
        According to these rules, a JSON <literal>value</literal> is
        either:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            an object bracketed by curly braces,
          </para>
        </listitem>
        <listitem>
          <para>
            an array bracketed by square braces,
          </para>
        </listitem>
        <listitem>
          <para>
            a string, integer, float, bool, or null value.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        In each of the productions, the OCaml code in curly-braces shows
        what to transform the object in question to. Note that we still
        have two non-terminals whose definitions we depend on here, but
        have not yet defined: <literal>object_fields</literal> and
        <literal>array_values</literal>. We'll look at how these are
        parsed next.
      </para>
    </sect2>
    <sect2 id="parsing-sequences">
      <title>Parsing sequences</title>
      <para>
        The rule for <literal>object_fields</literal> is shown below,
        and is really just a thin wrapper that reverses the list
        returned by the following rule for
        <literal>rev_object_fields</literal>. Note that the first
        production in <literal>rev_object_fields</literal> has an empty
        left-hand side. That's because what we're matching on in this
        case is an empty sequence of tokens. The comment
        <literal>/* empty */</literal> is used to make this clear.
        C-style comment syntax is used within the body of a rule.
      </para>
      <programlisting language="ocaml">
(* parsing/parser.mly (starting from part 4) *)
object_fields: obj = rev_object_fields { List.rev obj };

rev_object_fields:
  | /* empty */ { [] }
  | obj = rev_object_fields; COMMA; k = ID; COLON; v = value
    { (k, v) :: obj }
  ;
</programlisting>
      <para>
        The rules are structured as they are because
        <command>menhir</command> generates left-recursive parsers,
        which means that the constructed pushdown automaton uses less
        stack space with left-recursive definitions. The following
        right-recursive rule accepts the same input, but during parsing
        it requires linear stack space to read object field definitions.
      </para>
      <programlisting language="ocaml">
(* parsing/right_rec_rule.mly (starting from part 4) *)
/* Inefficient right-recursive rule */
object_fields:
  | /* empty */ { [] }
  | k = ID; COLON; v = value; COMMA; obj = object_fields
    { (k, v) :: obj }
</programlisting>
      <para>
        Alternatively, we could keep the left-recursive definition and
        simply construct the returned value in left-to-right order. This
        is is even less efficient, since the complexity of building thes
        list incrementally in this way is quadratic in the length of the
        list.
      </para>
      <programlisting language="ocaml">
(* parsing/quadratic_rule.mly (starting from part 4) *)
/* Quadratic left-recursive rule */
object_fields:
  | /* empty */ { [] }
  | obj = object_fields; COMMA; k = ID; COLON; v = value
    { obj @ [k, v] }
  ;
</programlisting>
      <para>
        Assembling lists like this is a pretty common requirement in
        most realistic grammars, and the above rules (while useful for
        illustrating how parsing works) are rather verbose. Menhir
        features an extended standard library of built-in rules to
        simplify this handling. These rules are detailed in the Menhir
        manual, and include optional values, pairs of values with
        optional separators, and lists of elements (also with optional
        separators).
      </para>
      <para>
        A version of the JSON grammar using these more succinct Menhir
        rules is shown below. Notice the use of
        <literal>separated_list</literal> to parse both JSON objects and
        lists with one rule.
      </para>
      <programlisting language="ocaml">
(* parsing/short_parser.mly (starting from part 1) *)
prog:
  | v = value { Some v }
  | EOF       { None   } ;

value:
  | LEFT_BRACE; obj = obj_fields; RIGHT_BRACE { `Assoc obj  }
  | LEFT_BRACK; vl = list_fields; RIGHT_BRACK { `List vl    }
  | s = STRING                                { `String s   }
  | i = INT                                   { `Int i      }
  | x = FLOAT                                 { `Float x    }
  | TRUE                                      { `Bool true  }
  | FALSE                                     { `Bool false }
  | NULL                                      { `Null       } ;

obj_fields:
    obj = separated_list(COMMA, obj_field)    { obj } ;

obj_field:
    k = STRING; COLON; v = value              { (k, v) } ;

list_fields:
    vl = separated_list(COMMA, value)         { vl } ;
</programlisting>
      <para>
        We can invoke <command>menhir</command> by using
        <command>corebuild</command> with the
        <literal>-use-menhir</literal> flag. This tells the build system
        to switch to using <command>menhir</command> instead of
        <command>ocamlyacc</command> to handle files with the
        <literal>.mly</literal> suffix.
      </para>
      <programlisting>
# running parsing/build_short_parser.out.sh
$ corebuild -use-menhir short_parser.mli
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' short_parser.mly &gt; short_parser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -w A-4-33-41-42-43-34-44 -strict-sequence -principal -g -annot -bin-annot -short-paths -thread -syntax camlp4o -package bin_prot.syntax -package sexplib.syntax,comparelib.syntax,fieldslib.syntax,variantslib.syntax -package core' --infer short_parser.mly
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="defining-a-lexer">
    <title>Defining a lexer</title>
    <para>
      For the next part, we need to define a lexer to tokenize the input
      text, meaning that we break the input into a sequence of words or
      tokens. For this, we'll define a lexer using
      <command>ocamllex</command>. In this case, the specification is
      placed in a file with a <literal>.mll</literal> suffix (we'll use
      the name <literal>lexer.mll</literal>). A lexer file has several
      parts in the following sequence.
    </para>
    <programlisting language="html">
{ OCaml code }
let definitions...
rules...
{ OCaml code }
</programlisting>
    <sect2 id="let-definitions-for-regular-expressions">
      <title>Let-definitions for regular expressions</title>
      <para>
        The OCaml code for the header and trailer is optional. The
        let-definitions are used to ease the definition of regular
        expressions by defining utility functions. They are optional,
        but very useful. To get started, let's define a utility function
        that can track the location of tokens across line breaks.
      </para>
      <programlisting language="ocaml">
(* parsing/lexer.mll  *)
{
open Lexing
open Parser

exception SyntaxError of string

let next_line lexbuf =
  let pos = lexbuf.lex_curr_p in
  lexbuf.lex_curr_p &lt;-
    { pos with pos_bol = lexbuf.lex_curr_pos;
               pos_lnum = pos.pos_lnum + 1
    }
}
</programlisting>
      <para>
        The <literal>Lexing</literal> module defines a
        <literal>lexbuf</literal> structure that holds all of the lexer
        state, including the current location within the source file.
        The <literal>next_line</literal> function simply accesses the
        <literal>lex_curr_p</literal> field that holds the current
        location and updates its line number. This is intended to be
        called from within the lexing regular expressions that we'll
        define next.
      </para>
      <para>
        To get started with our rules, we know that we'll need to match
        numbers and strings, so let's define names for the regular
        expressions that specify their form.
      </para>
      <programlisting language="ocaml">
(* parsing/lexer.mll (starting from part 1) *)
let int = '-'? ['1'-'9'] ['0'-'9']*
</programlisting>
      <para>
        An integer is a sequence of digits, optionally preceded by a
        minus sign. Leading zeroes are not allowed. The question mark
        means that the preceding symbol <literal>-</literal> is
        optional. The square brackets ['1'-'9'] define a character
        range, meaning that the first digit of the integer should be
        1-9. The final range <literal>['0'-'9']*</literal> includes the
        star <literal>*</literal>, which means zero-or-more occurrences
        of the characters 0-9. Read formally then, an
        <literal>int</literal> has an optional minus sign, followed by a
        digit in the range 1-9, followed by zero or more digits in the
        range 0-9.
      </para>
      <para>
        Floating-point numbers are similar, but we deal with decimal
        points and exponents. We can use multiple let-definitions for
        the different parts.
      </para>
      <programlisting language="ocaml">
(* parsing/lexer.mll (starting from part 2) *)
let digits = ['0'-'9']
let frac = '.' digits*
let exp = ['e' 'E'] ['-' '+']? digits+
let float = digits* frac? exp?
</programlisting>
      <para>
        The <literal>digits</literal> expression defines a single
        character regexp in the range 0-9. A fractional part
        <literal>frac</literal> has a compulsary decimal point followed
        by some optional digits; an exponent <literal>exp</literal>
        begins with an <literal>e</literal> followed by some digits; and
        a <literal>float</literal> has an integer part, and one, both or
        none of a <literal>frac</literal> and <literal>exp</literal>
        part.
      </para>
      <para>
        Finally, let's define identifiers and whitespace. An identifier
        (label), is an alphanumeric sequence not beginning with a digit.
      </para>
      <programlisting language="ocaml">
(* parsing/lexer.mll (starting from part 3) *)
let white = [' ' '\t']+
let newline = '\r' | '\n' | &quot;\r\n&quot;

let id = ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*
let hex = ['0'-'9' 'a'-'f' 'A'-'F']
</programlisting>
    </sect2>
    <sect2 id="lexing-rules">
      <title>Lexing rules</title>
      <para>
        The lexing rules are specified as a set of
        <literal>parse</literal> rules. A <literal>parse</literal> rule
        has a regular expression followed by OCaml code that defines a
        semantic action. Let's write the rule for JSON next.
      </para>
      <programlisting language="ocaml">
(* parsing/lexer.mll (starting from part 4) *)
rule read = parse
| white    { read lexbuf }
| newline  { next_line lexbuf; read lexbuf }
| int      { INT (int_of_string (Lexing.lexeme lexbuf)) }
| float    { FLOAT (float_of_string (Lexing.lexeme lexbuf)) }
| &quot;true&quot;   { TRUE }
| &quot;false&quot;  { FALSE }
| &quot;null&quot;   { NULL }
| '&quot;'      { read_string (Buffer.create 17) lexbuf }
| '{'      { LEFT_BRACE }
| '}'      { RIGHT_BRACE }
| '['      { LEFT_BRACK }
| ']'      { RIGHT_BRACK }
| ':'      { COLON }
| ','      { COMMA }
| _ { raise (SyntaxError (&quot;Unexpected char: &quot; ^ Lexing.lexeme lexbuf)) }
| eof      { EOF }
</programlisting>
      <para>
        The rules are structured very similarly to pattern matches,
        except that the variants are replaced by regular expressions on
        the left hand side. The right hand side clause is the parsed
        OCaml return value of that rule. The OCaml code for the rules
        has a parameter called <literal>lexbuf</literal> that defines
        the input, including the position in the input file, as well as
        the text that was matched by the regular expression.
      </para>
      <para>
        The first <literal>white { read lexbuf }</literal> calls the
        lexer recursively. That is, it skips the input whitespace and
        returns the following token. The action
        <literal>newline { next_line lexbuf; read lexbuf }</literal> is
        similar, but we use it to advance the line number for the lexer
        using the utility function that we defined at the top of the
        file. Let's skip to the third action.
      </para>
      <programlisting language="ocaml">
(* parsing/lexer_int_fragment.mll  *)
| int { INT (int_of_string (Lexing.lexeme lexbuf)) }
</programlisting>
      <para>
        This action specifies that when the input matches the
        <literal>int</literal> regular expression, then the lexer should
        return the expression
        <literal>INT (int_of_string (Lexing.lexeme lexbuf))</literal>.
        The expression <literal>Lexing.lexeme lexbuf</literal> returns
        the complete string matched by the regular expression. In this
        case, the string represents a number, so we use the
        <literal>int_of_string</literal> function to convert it to a
        number.
      </para>
      <para>
        There are actions for each different kind of token. The string
        expressions like <literal>&quot;true&quot; { TRUE }</literal>
        are used for keywords, and the special characters have actions
        too, like <literal>'{' { LEFT_BRACE }</literal>.
      </para>
      <para>
        Some of these patterns overlap. For example, the regular
        expression <literal>&quot;true&quot;</literal> is also matched
        by the <literal>id</literal> pattern.
        <command>ocamllex</command> used the following disambiguation
        when a prefix of the input is matched by more than one pattern.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            The longest match always wins. For example, the first input
            <literal>trueX: 167</literal> matches the regular expression
            <literal>&quot;true&quot;</literal> for 4 characters, and it
            matches <literal>id</literal> for 5 characters. The longer
            match wins, and the return value is
            <literal>ID &quot;trueX&quot;</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            If all matches have the same length, then the first action
            wins. If the input were <literal>true: 167</literal>, then
            both <literal>&quot;true&quot;</literal> and
            <literal>id</literal> match the first 4 characters;
            <literal>&quot;true&quot;</literal> is first, so the return
            value is <literal>TRUE</literal>.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2 id="recursive-rules">
      <title>Recursive rules</title>
      <para>
        Unlike many other lexer generators, <command>ocamllex</command>
        allows the definition of multiple lexers in the same file, and
        the definitions can be recursive. In this case, we use recursion
        to match string literals using the following rule definition.
      </para>
      <programlisting language="ocaml">
(* parsing/lexer.mll (starting from part 5) *)
and read_string buf = parse
| '&quot;' { STRING (Buffer.contents buf) }
| '\\' '/' { Buffer.add_char buf '/'; read_string buf lexbuf }
| '\\' '\\' { Buffer.add_char buf '\\'; read_string buf lexbuf }
| '\\' 'b' { Buffer.add_char buf '\b'; read_string buf lexbuf }
| '\\' 'f' { Buffer.add_char buf '\012'; read_string buf lexbuf }
| '\\' 'n' { Buffer.add_char buf '\n'; read_string buf lexbuf }
| '\\' 'r' { Buffer.add_char buf '\r'; read_string buf lexbuf }
| '\\' 't' { Buffer.add_char buf '\t'; read_string buf lexbuf }
| [^ '&quot;' '\\']+
  { Buffer.add_string buf (Lexing.lexeme lexbuf);
    read_string buf lexbuf
  }
| _ { raise (SyntaxError (&quot;Illegal string character: &quot; ^ Lexing.lexeme lexbuf)) }
| eof { raise (SyntaxError (&quot;String is not terminated&quot;)) }
</programlisting>
      <para>
        This rule takes a <literal>buf : Buffer.t</literal> as an
        argument. If we reach the terminating double quote
        <literal>&quot;</literal>, then we return the contents of the
        buffer as a <literal>STRING</literal>.
      </para>
      <para>
        The other cases are for handling the string contents. The action
        <literal>[^ '&quot;' '\\']+ { ... }</literal> matches normal
        input that does not contain a double-quote or backslash. The
        actions beginning with a backslash <literal>\</literal> define
        what to do for escape sequences. In each of these cases, the
        final step includes a recursive call to the lexer.
      </para>
      <para>
        That covers the lexer. Next, we need to combine the lexer with
        the parser to bring it all together.
      </para>
      <note>
      <title>
      Handling Unicode
      </title>
      <para>
        We've glossed over an important detail here: parsing Unicode
        characters to handle the full spectrum of the world's writing
        systems. OCaml has several third-party solutions to handling
        Unicode, with varying degrees of flexibility and complexity.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <ulink url="http://camomile.sourceforge.net">Camomile</ulink>
            supports the full spectrum of Unicode character types,
            conversion from around 200 encodings, and collation and
            locale-sensitive case mappings.
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.cduce.org/ulex">Ulex</ulink> is a
            lexer generator for Unicode that can serve as a
            Unicode-aware replacement for <command>ocamllex</command>.
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://erratique.ch/software/uutf">Uutf</ulink>
            is a non-blocking streaming Unicode codec for OCaml,
            available as a standalone library. It is accompanied by the
            <ulink url="http://erratique.ch/software/uunf">Uunf</ulink>
            text normalization and
            <ulink url="http://erratique.ch/software/uucd">Uucd</ulink>
            Unicode character database libraries. There is also a robust
            parser for
            <ulink url="http://erratique.ch/software/jsonm">JSON</ulink>
            available that illustrates the use of Uutf in your own
            libraries.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        All of these libraries are available via OPAM under their
        respective names.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="bringing-it-all-together">
    <title>Bringing it all together</title>
    <para>
      For the final part, we need to compose the lexer and parser. As we
      saw in the type definition in <literal>parser.mli</literal>, the
      parsing function expects a lexer of type
      <literal>Lexing.lexbuf -&gt; token</literal>, and it also expects
      a <literal>lexbuf</literal>.
    </para>
    <programlisting language="ocaml">
(* parsing/prog.mli  *)
val prog:(Lexing.lexbuf -&gt; token) -&gt; Lexing.lexbuf -&gt; Json.value option
</programlisting>
    <para>
      Before we start with the lexing, let's first define some functions
      to handle parsing errors. There are currently two errors:
      <literal>Parser.Error</literal> and
      <literal>Lexer.SyntaxError</literal>. A simple solution when
      encountering an error is to print the error and give up, which we
      do below.
    </para>
    <programlisting language="ocaml">
(* parsing-test/test.ml  *)
open Core.Std
open Lexer
open Lexing

let print_position outx lexbuf =
  let pos = lexbuf.lex_curr_p in
  fprintf outx &quot;%s:%d:%d&quot; pos.pos_fname
    pos.pos_lnum (pos.pos_cnum - pos.pos_bol + 1)

let parse_with_error lexbuf =
  try Parser.prog Lexer.read lexbuf with
  | SyntaxError msg -&gt;
    fprintf stderr &quot;%a: %s\n&quot; print_position lexbuf msg;
    None
  | Parser.Error -&gt;
    fprintf stderr &quot;%a: syntax error\n&quot; print_position lexbuf;
    exit (-1)
</programlisting>
    <para>
      The &quot;give up on the first error&quot; approach is easy to
      implement but isn't very friendly. In general, error handling can
      be pretty intricate, and we won't discuss it here. However, the
      Menhir parser defines additional mechanisms you can use to try and
      recover from errors. These are described in detail in its
      reference
      <ulink url="http://gallium.inria.fr/~fpottier/menhir/">manual</ulink>.
    </para>
    <para>
      The standard lexing library <literal>Lexing</literal> provides a
      function <literal>from_channel</literal> to read the input from a
      channel. The following function describes the structure, where the
      <literal>Lexing.from_channel</literal> function is used to
      construct a <literal>lexbuf</literal>, which is passed with the
      lexing function <literal>Lexer.read</literal> to the
      <literal>Parser.prog</literal> function.
      <literal>Parsing.prog</literal> returns <literal>None</literal>
      when it reaches end of file. We define a function
      <literal>Json.output_value</literal>, not shown here, to print a
      <literal>Json.value</literal>.
    </para>
    <programlisting language="ocaml">
(* parsing-test/test.ml (starting from part 1) *)
let rec parse_and_print lexbuf =
  match parse_with_error lexbuf with
  | Some value -&gt;
    printf &quot;%a\n&quot; Json.output_value value;
    parse_and_print lexbuf
  | None -&gt; ()

let loop filename () =
  let inx = In_channel.create filename in
  let lexbuf = Lexing.from_channel inx in
  lexbuf.lex_curr_p &lt;- { lexbuf.lex_curr_p with pos_fname = filename };
  parse_and_print lexbuf;
  In_channel.close inx
</programlisting>
    <para>
      Here's a test input file we can use to test the code we just
      wrote.
    </para>
    <programlisting language="json">
true
false
null
[1, 2, 3., 4.0, .5, 5.5e5, 6.3]
&quot;Hello World&quot;
{ &quot;field1&quot;: &quot;Hello&quot;,
  &quot;field2&quot;: 17e13,
  &quot;field3&quot;: [1, 2, 3],
  &quot;field4&quot;: { &quot;fieldA&quot;: 1, &quot;fieldB&quot;: &quot;Hello&quot; }
}
</programlisting>
    <para>
      Now build and run the example using this file, and you you can see
      the full parser in action.
    </para>
    <programlisting>
# running parsing-test/build_test.out.sh
$ ocamlbuild -use-menhir -tag thread -use-ocamlfind -pkg core test.native
/home/rwo/.opam/4.01.0dev+trunk/bin/ocamllex.opt -q lexer.mll
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' parser.mly &gt; parser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -thread -package core' --infer parser.mly
$ ./test.native test1.json
true
false
null
[1, 2, 3.000000, 4.000000, 0.500000, 550000.000000, 6.300000]
&quot;Hello World&quot;
{ field1: &quot;Hello&quot;, field2: 170000000000000.000000, field3: [1, 2, 3], field4: { fieldA: 1, fieldB: &quot;Hello&quot; } }
</programlisting>
    <para>
      With our simple error handling scheme, errors are fatal and cause
      the program to terminate with a non-zero exit code.
    </para>
    <programlisting>
# running parsing-test/run_broken_test.out.sh
$ cat test2.json
{ name: &quot;Chicago&quot;,
  zips: [12345,
}
{ name: &quot;New York&quot;,
  zips: [10004]
}
$ ./test.native test2.json
test2.json:3:2: syntax error
</programlisting>
    <para>
      That wraps up our parsing tutorial. As an aside, notice that the
      JSON polymorphic variant type that we defined in this chapter is
      actually structurally compatible with the Yojson representation
      explained earlier in
      <xref linkend="handling-json-data"/>. That means that
      you can take this parser and use it with the helper functions in
      Yojson to build more sophisticated applications.
    </para>
  </sect1>
</chapter><chapter id="data-serialization-with-s-expressions">
  <title>Data Serialization with S-Expressions</title>
  <para>
    We've already discussed the parsing of third-party data formats like
    JSON. Sometimes, though, you're less concerned with interoperating
    with specific file formats, and you instead want an easy to use,
    human-readable format that integrates well with OCaml and its
    libraries. Core's solution to this problem is to use s-expressions.
  </para>
  <para>
    S-expressions are nested parenthetical expressions whose atomic
    values are strings. They were first popularized by the Lisp
    programming language in the 1960s, and have remained one of the
    simplest and most effective ways to encode structured data. There's
    a full definition of them available
    <ulink url="http://people.csail.mit.edu/rivest/Sexp.txt">online</ulink>.
    An example s-expression might look like this.
  </para>
  <programlisting language="scheme">
;; sexpr/basic.scm.scm
(this (is an) (s expression))
</programlisting>
  <para>
    This chapter will show you how to:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        generate s-expressions from arbitrary OCaml types, thus giving
        you a human-readable format for persisting any values in your
        code.
      </para>
    </listitem>
    <listitem>
      <para>
        expose s-expressions across module interfaces, including with
        abstract types.
      </para>
    </listitem>
    <listitem>
      <para>
        generate good error messages for debugging malformed inputs.
      </para>
    </listitem>
    <listitem>
      <para>
        use custom type annotations to control the exact printing
        behavior for s-expression converters.
      </para>
    </listitem>
  </itemizedlist>
  <sect1 id="basic-usage">
    <title>Basic Usage</title>
    <para>
      OCaml values aren't directly converted to-and-from strings of
      s-expressions when you use Core. The s-expression is instead built
      up as an OCaml value which is later serialized into strings or
      memory buffers. The OCaml type of an s-expression is quite simple.
    </para>
    <programlisting language="ocaml">
(* sexpr/sexp.mli  *)
open Core.Std

module Sexp : sig
  type t = 
  | Atom of string
  | List of t list
end
</programlisting>
    <para>
      An s-expression can be thought of as a tree where each node
      contains a list of its children, and where the leaves of the tree
      are strings. Here's how we can use this type to represent the our
      example s-expression.
    </para>
    <programlisting language="ocaml">
# script sexpr/manually_making_sexp.topscript
$ utop
# type t = { foo: int; bar: float } ;; 
type t = { foo : int; bar : float; }
# let sexp_of_t t =
    let a x = Sexp.Atom x and l x = Sexp.List x in
    l [ l [a &quot;foo&quot;; Int.sexp_of_t t.foo  ];
        l [a &quot;bar&quot;; Float.sexp_of_t t.bar]; ] ;; 
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
# sexp_of_t { foo = 3; bar = -5.5 } ;; 
- : Sexp.t = ((foo 3) (bar -5.5))
</programlisting>
    <para>
      Core provides good support for <literal>s-expressions</literal> in
      its <literal>Sexp</literal> module, including functions for
      converting s-expressions to and from strings. If we do the same
      example above with Core's s-expression type, we'll see that the
      output in the top-level is easier to read.
    </para>
    <programlisting language="ocaml">
# script sexpr/print_sexp.topscript
$ utop
# let a x = Sexp.Atom x ;; 
val a : string -&gt; Sexp.t = &lt;fun&gt;
# let l x = Sexp.List x ;; 
val l : Sexp.t list -&gt; Sexp.t = &lt;fun&gt;
# let sexp = l [
    a &quot;this&quot;;
    l [a &quot;is&quot;; a &quot;an&quot;];
    l [ a &quot;s&quot;; a &quot;expression&quot;] ] ;; 
val sexp : Sexp.t = (this (is an) (s expression))
</programlisting>
    <para>
      This prints out nicely because Core registers a pretty printer
      with the toplevel. This pretty-printer uses Core's functions for
      converting s-expressions to and from strings.
    </para>
    <programlisting language="ocaml">
# script sexpr/sexp_printer.topscript
$ utop
# Sexp.of_string (&quot;(1 2 (3 4))&quot;) ;; 
- : Sexp.t = (1 2 (3 4))
# Sexp.to_string (Sexp.List [Sexp.Atom &quot;1&quot;; Sexp.Atom &quot;2&quot;]) ;; 
- : string = &quot;(1 2)&quot;
</programlisting>
    <para>
      In addition to providing the <literal>Sexp</literal> module, most
      of the base types in Core support conversion to and from
      s-expressions. For example, we can write:
    </para>
    <programlisting language="ocaml">
# script sexpr/to_from_sexp.topscript
$ utop
# Int.sexp_of_t 3 ;; 
- : Sexp.t = 3
# List.sexp_of_t ;; 
- : ('a -&gt; Sexp.t) -&gt; 'a list -&gt; Sexp.t = &lt;fun&gt;
# List.sexp_of_t Int.sexp_of_t [1; 2; 3] ;; 
- : Sexp.t = (1 2 3)
</programlisting>
    <para>
      Notice that <literal>List.sexp_of_t</literal> is polymorphic, and
      takes as its first argument another conversion function to handle
      the elements of the list to be converted. Core uses this scheme
      more generally for defining sexp-converters for polymorphic types.
    </para>
    <note>
    <title>
    More on toplevel printing
    </title>
    <para>
      The values of the s-expressions that we created above were printed
      properly as s-expressions in the toplevel, instead of as the tree
      of <literal>Atom</literal> and <literal>List</literal> variants
      that they're actually made of.
    </para>
    <para>
      This is due to OCaml's facility for installing custom
      <emphasis>toplevel printers</emphasis> that can rewrite some
      values into more toplevel-friendly equivalents. They are generally
      installed as <command>ocamlfind</command> packages ending in
      <literal>top</literal>.
    </para>
    <programlisting>
# running sexpr/list_top_packages.out.sh
$ ocamlfind list | grep top
compiler-libs.toplevel (version: [distributed with Ocaml])
core.top            (version: 109.37.00)
lwt.simple-top      (version: 2.4.3)
num-top             (version: 1.3.3)
sexplib.top         (version: 109.20.00)
uri.top             (version: 1.3.8)
</programlisting>
    <para>
      The <literal>core.top</literal> package (which you should have
      loaded by default in your <literal>.ocamlinit</literal> file)
      loads in printers for the Core extensions already, so you don't
      need to do anything special to use the Sexplib printer.
    </para>
    </note>
    <sect2 id="generating-s-expressions-from-ocaml-types">
      <title>Generating s-expressions from OCaml types</title>
      <para>
        But what if you want a function to convert some brand new type
        to an s-expression? You can of course write it yourself
        manually:
      </para>
      <programlisting language="ocaml">
# script sexpr/manually_making_sexp.topscript
$ utop
# type t = { foo: int; bar: float } ;; 
type t = { foo : int; bar : float; }
# let sexp_of_t t =
    let a x = Sexp.Atom x and l x = Sexp.List x in
    l [ l [a &quot;foo&quot;; Int.sexp_of_t t.foo  ];
        l [a &quot;bar&quot;; Float.sexp_of_t t.bar]; ] ;; 
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
# sexp_of_t { foo = 3; bar = -5.5 } ;; 
- : Sexp.t = ((foo 3) (bar -5.5))
</programlisting>
      <para>
        This is somewhat tiresome to write, and it gets more so when you
        consider the parser, <emphasis>i.e.</emphasis>,
        <literal>t_of_sexp</literal>, which is considerably more
        complex. Writing this kind of parsing and printing code by hand
        is mechanical and error prone, not to mention a drag.
      </para>
      <para>
        Given how mechanical the code is, you could imagine writing a
        program that inspected the type definition and autogenerated the
        conversion code for you. As it turns out, we can do just that
        using <literal>sexplib</literal>. The <literal>sexplib</literal>
        package, which is included with Core, provides both a library
        for manipulating s-expressions and a <emphasis>syntax
        extension</emphasis> for generating such conversion functions.
        With that syntax extension enabled, any type that has
        <literal>with sexp</literal> as an annotation will trigger the
        generation of the functions we want for free.
      </para>
      <programlisting language="ocaml">
# script sexpr/auto_making_sexp.topscript
$ utop
# type t = { foo: int; bar: float } with sexp ;; 
type t = { foo : int; bar : float; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
# t_of_sexp (Sexp.of_string &quot;((bar 35) (foo 3))&quot;) ;; 
- : t = {foo = 3; bar = 35.}
</programlisting>
      <para>
        The <literal>sexplib</literal> syntax extension sees the
        <literal>with sexp</literal> annotation replaces it with the
        definition of the conversions functions we see above.
      </para>
      <para>
        The syntax extension can be used outside of type declarations as
        well. As discussed in
        <xref linkend="error-handling"/>,
        <literal>with sexp</literal> can be attached to the declaration
        of an exception, which will improve the ability of Core to
        generate a useful string representation of an exception.
      </para>
      <programlisting language="ocaml">
...part 1 of sexpr/auto_making_sexp.topscript
# exception Bad_message of string list ;; 
exception Bad_message of string list
# Exn.to_string (Bad_message [&quot;1&quot;;&quot;2&quot;;&quot;3&quot;]) ;; 
- : string = &quot;(\&quot;Bad_message(_)\&quot;)&quot;
# exception Good_message of string list with sexp;; 
exception Good_message of string list
# Exn.to_string (Good_message [&quot;1&quot;;&quot;2&quot;;&quot;3&quot;]) ;; 
- : string = &quot;(//toplevel//.Good_message (1 2 3))&quot;
</programlisting>
      <para>
        You don't always have to declare a named type to create an
        s-expression converter. The following syntax lets you create one
        inline, as part of a larger expression.
      </para>
      <programlisting language="ocaml">
# script sexpr/inline_sexp.topscript
$ utop
# let l = [(1,&quot;one&quot;); (2,&quot;two&quot;)] ;; 
val l : (int * string) list = [(1, &quot;one&quot;); (2, &quot;two&quot;)]
# List.iter l ~f:(fun x -&gt;
    &lt;:sexp_of&lt;int * string&gt;&gt; x
    |&gt; Sexp.to_string
    |&gt; print_endline) ;; 

(1 one)
(2 two)
- : unit = ()
</programlisting>
      <para>
        The declaration
        <literal>&lt;:sexp_of&lt;int * string&gt;&gt;</literal> simply
        gets expanded to the sexp-converter for the type
        <literal>int * string</literal>. This is useful whenever you
        need a sexp-converter for an anonymous type.
      </para>
      <para>
        The syntax extensions bundled with Core almost all have the same
        basic structure: they autogenerate code based on type
        definitions, implementing functionality that you could in theory
        have implemented by hand, but with far less programmer effort.
      </para>
      <note> <title>
      Syntax extensions, <literal>camlp4</literal> and
      <literal>type_conv</literal>
      </title>
      <para>
        OCaml doesn't directly support generating code from type
        definitions. Instead, it supplies a powerful syntax extension
        mechanism known as <literal>camlp4</literal>, which lets you
        extend the grammar of the language. In the case of
        <literal>sexplib</literal>, <literal>camlp4</literal> is used to
        create s-expression conversion functions.
        <literal>camlp4</literal> is well integrated into the OCaml
        toolchain, and can be activated within the toplevel and also
        included in compilation using the <literal>-pp</literal>
        compiler flag.
      </para>
      <para>
        <literal>sexplib</literal> is part of a family of syntax
        extensions, including <literal>comparelib</literal>, described
        in <xref linkend="maps-and-hash-tables"/>, and
        <literal>fieldslib</literal>, described in
        <xref linkend="records"/>, that generate code based on
        type declarations, and are all based on a common library called
        <literal>type_conv</literal>. This library provides a common
        language for annotating types (<emphasis>e.g.</emphasis>, using
        the <literal>with</literal> notation) and utilities for working
        with type definitions. If you want to build your own type-driven
        syntax extension, you should consider basing it on
        <literal>type_conv</literal>.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="the-sexp-format">
    <title>The Sexp format</title>
    <para>
      The textual representation of s-expressions is pretty
      straightforward. An s-expression is written down as a nested
      parenthetical expression, with whitespace-separated strings as the
      atoms. Quotes are used for atoms that contain parentheses or
      spaces themselves; backslash is the escape character; and
      semicolons are used to introduce single-line comments. Thus, the
      following file, <literal>example.scm</literal>:
    </para>
    <programlisting language="scheme">
;; sexpr/example.scm.scm
;; example.scm

((foo 3.3) ;; This is a comment
 (bar &quot;this is () an \&quot; atom&quot;))
</programlisting>
    <para>
      can be loaded using sexplib. As you can see, the commented data is
      not part of the resulting s-expression.
    </para>
    <programlisting language="ocaml">
# script sexpr/example_load.topscript
$ utop
# Sexp.load_sexp &quot;example.scm&quot; ;; 
- : Sexp.t = ((foo 3.3) (bar &quot;this is () an \&quot; atom&quot;))
</programlisting>
    <para>
      All in, the s-expression format actually supports three comment
      syntaxes:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>;</literal>, which comments out everything to the end
          of a line
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>#|</literal> and <literal>|#</literal>, which are
          delimiters for commenting out a block
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>#;</literal>, which comments out the first complete
          s-expression that follows.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The following example shows all of these in action.
    </para>
    <programlisting language="scheme">
;; sexpr/comment_heavy.scm.scm
;; comment_heavy_example.scm
((this is included)
 ; (this is commented out
 (this stays)
 #; (all of this is commented
     out (even though it crosses lines.))
  (and #| block delimiters #| which can be nested |#
     will comment out
    an arbitrary multi-line block))) |#
   now we're done
   ))
</programlisting>
    <para>
      Again, loading the file as an s-expression drops the comments.
    </para>
    <programlisting language="ocaml">
...part 1 of sexpr/example_load.topscript
# Sexp.load_sexp &quot;comment_heavy.scm&quot; ;; 
- : Sexp.t = ((this is included) (this stays) (and now we're done))
</programlisting>
    <para>
      Note that the comments were dropped from the file upon reading.
      This is expected, since there's no place in the
      <literal>Sexp.t</literal> type to store comments.
    </para>
    <para>
      If we introduce an error into our s-expression, by, say, creating
      a file <literal>broken_example.scm</literal> which is
      <literal>example.scm</literal> without open-paren in front of
      <literal>bar</literal>, we'll get a parse error:
    </para>
    <programlisting language="ocaml">
...part 2 of sexpr/example_load.topscript
# Exn.handle_uncaught ~exit:false (fun () -&gt;
    ignore (Sexp.load_sexp &quot;example_broken.scm&quot;)) ;; 

Uncaught exception:
  
  (Sexplib.Sexp.Parse_error
   ((location parse) (err_msg &quot;unexpected character: ')'&quot;) (text_line 4)
    (text_char 29) (global_offset 78) (buf_pos 78)))

- : unit = ()
</programlisting>
    <para>
      In the above, we use <literal>Exn.handle_uncaught</literal> to
      make sure that the exception gets printed out in full detail. You
      should generally wrap every Core program in this handler to get
      good error messages for any unexpected exceptions.
    </para>
  </sect1>
  <sect1 id="sexp-converters">
    <title>Sexp converters</title>
    <para>
      The most important functionality provided by Sexplib is the
      auto-generation of converters for new types. We've seen a bit of
      how this works already, but let's walk through a complete example.
      Here's the source for the beginning of a library for representing
      integer intervals.
    </para>
    <programlisting language="ocaml">
(* sexpr/int_interval.ml  *)
(* Module for representing closed integer intervals *)
open Core.Std

(* Invariant: For any Range (x,y), y &gt;= x *)
type t =
  | Range of int * int
  | Empty
with sexp

let is_empty =
  function 
  | Empty -&gt; true 
  | Range _ -&gt; false

let create x y =
  if x &gt; y then
    Empty 
  else 
    Range (x,y)

let contains i x =
  match i with
  | Empty -&gt; false
  | Range (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high
</programlisting>
    <para>
      We can now use this module as follows.
    </para>
    <programlisting language="ocaml">
(* sexpr/test_interval.ml  *)
open Core.Std

let intervals =
  let module I = Int_interval in
  [ I.create 3 4;
    I.create 5 4; (* should be empty *)
    I.create 2 3;
    I.create 1 6;
  ]

let () =
  intervals
  |&gt; List.sexp_of_t Int_interval.sexp_of_t
  |&gt; Sexp.to_string_hum
  |&gt; print_endline
</programlisting>
    <para>
      But we're still missing something: we haven't created an
      <literal>mli</literal> signature for
      <literal>Int_interval</literal> yet. Note that we need to
      explicitly export the s-expression converters that were created
      within the <literal>ml</literal> file. For example, here's an
      interface that doesn't export the s-expression functions.
    </para>
    <programlisting language="ocaml">
(* sexpr/int_interval_nosexp.mli  *)
type t

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool
</programlisting>
    <para>
      Building this will give us the following error:
    </para>
    <programlisting>
# running sexpr/build_test_interval_nosexp.out.sh
$ ocamlbuild -use-ocamlfind -tag thread -syntax camlp4o -pkgs core,sexplib.syntax test_interval_nosexp.native
File &quot;test_interval_nosexp.ml&quot;, line 14, characters 20-42:
Error: Unbound value Int_interval.sexp_of_t
Command exited with code 2.
</programlisting>
    <para>
      We could export the types by hand in the signature, by writing the
      signatures for the extra functions generated by
      <literal>sexplib</literal>.
    </para>
    <programlisting language="ocaml">
(* sexpr/int_interval_manual_sexp.mli  *)
open Core.Std

type t
val t_of_sexp : Sexp.t -&gt; t
val sexp_of_t : t -&gt; Sexp.t

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool
</programlisting>
    <para>
      This isn't an ideal solution, as it makes you repeatedly expose
      these extra functions in every signature you create where you want
      to serialize values. Sexplib solves this by exposing the same
      syntax extension in signature definitions, so that we can just use
      the same <literal>with</literal> shorthand in the
      <literal>mli</literal> file. Here's the final version of the
      signature that does just this.
    </para>
    <programlisting language="ocaml">
(* sexpr/int_interval.mli  *)
type t with sexp

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool
</programlisting>
    <para>
      At this point <literal>test_interval.ml</literal> will compile
      again, and if we run it, we'll get the following output.
    </para>
    <programlisting language="ocaml">
(* sexpr/build_test_interval.out  *)
$ corebuild test_interval.native
$ ./test_interval.native
((Range 3 4) Empty (Range 2 3) (Range 1 6))
</programlisting>
    <sect2 id="preserving-invariants">
      <title>Preserving invariants</title>
      <para>
        One easy mistake to make when dealing with sexp converters is to
        ignore the fact that those converters can violate the invariants
        of your code. For example, the <literal>Int_interval</literal>
        module depends for the correctness of the
        <literal>is_empty</literal> check on the fact that for any value
        <literal>Range (x,y)</literal>, <literal>y</literal> is greater
        than or equal to <literal>x</literal>. The
        <literal>create</literal> function preserves this invariant, but
        the <literal>t_of_sexp</literal> function does not.
      </para>
      <para>
        We can fix this problem by overriding the autogenerated function
        and writing a custom sexp-converter that is based on the
        autogenerated converter.
      </para>
      <programlisting language="ocaml">
(* sexpr/sexp_override.ml  *)
type t =
  | Range of int * int
  | Empty
with sexp

let create x y =
  if x &gt; y then Empty else Range (x,y)

let t_of_sexp sexp =
  let t = t_of_sexp sexp in
  begin match t with
    | Empty -&gt; ()
    | Range (x,y) -&gt;
      if y &lt; x then of_sexp_error &quot;Upper and lower bound of Range swapped&quot; sexp
  end;
  t
</programlisting>
      <para>
        This trick of overriding an existing function definition with a
        new one is perfectly acceptable in OCaml. Function definitions
        are only recursive if the <literal>rec</literal> keyword is
        specified, and so in this case the inner
        <literal>t_of_sexp</literal> call will go to the earlier
        autogenerated definition that resulted from the
        <literal>type t with sexp</literal> definition.
      </para>
      <para>
        We call the function <literal>of_sexp_error</literal> to raise
        an exception because that improves the error reporting that
        Sexplib can provide when a conversion fails.
      </para>
    </sect2>
    <sect2 id="getting-good-error-messages">
      <title>Getting good error messages</title>
      <para>
        There are two steps to deserializing a type from an
        s-expression: first, converting the bytes in a file to an
        s-expression, and the second, converting that s-expression into
        the type in question. One problem with this is that it can be
        hard to localize errors to the right place using this scheme.
        Consider the following example:
      </para>
      <programlisting language="ocaml">
(* sexpr/read_foo.ml  *)
open Core.Std

type t = { 
  a: string;
  b: int;
  c: float option 
} with sexp

let run () =
  let t =
    Sexp.load_sexp &quot;foo_broken_example.scm&quot;
    |&gt; t_of_sexp
  in
  printf &quot;b is: %d\n%!&quot; t.b

let () =
  Exn.handle_uncaught ~exit:true run
</programlisting>
      <para>
        If you were to run this on a malformatted file, say, this one:
      </para>
      <programlisting language="scheme">
;; sexpr/foo_broken_example.scm.scm
((a &quot;&quot;)
 (b &quot;&quot;)
 (c 1.0))
</programlisting>
      <para>
        you'll get the following error:
      </para>
      <programlisting>
# running sexpr/build_read_foo.out.sh
$ ocamlbuild -use-ocamlfind -tag thread -syntax camlp4o -pkg core,sexplib.syntax read_foo.native
$ ./read_foo.native foo_example_broken.scm
Uncaught exception:
  
  (Sexplib.Conv.Of_sexp_error
   (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;) &quot;&quot;)

Raised at file &quot;lib/conv.ml&quot;, line 281, characters 36-72
Called from file &quot;lib/core_int.ml&quot;, line 6, characters 7-14
Called from file &quot;lib/std_internal.ml&quot;, line 115, characters 7-33
Called from file &quot;lib/exn.ml&quot;, line 87, characters 6-10
</programlisting>
      <para>
        If all you have is the error message and the string, it's not
        terribly informative. In particular, you know that the parsing
        error-ed out on the atom &quot;not-an-integer&quot;, but you
        don't know which one! In a large file, this kind of bad error
        message can be pure misery.
      </para>
      <para>
        But there's hope! If we make small change to the
        <literal>run</literal> function as follows:
      </para>
      <programlisting language="ocaml">
(* sexpr/read_foo_better_errors.ml  *)
open Core.Std

type t = { 
  a: string;
  b: int;
  c: float option 
} with sexp

let run () =
  let t = Sexp.load_sexp_conv_exn &quot;foo_broken_example.scm&quot; t_of_sexp in
  printf &quot;b is: %d\n%!&quot; t.b

let () =
  Exn.handle_uncaught ~exit:true run
</programlisting>
      <para>
        and run it again, we'll get the following much more helpful
        error message:
      </para>
      <programlisting>
# running sexpr/build_read_foo_better_errors.out.sh
$ ocamlbuild -use-ocamlfind -tag thread -syntax camlp4o -pkg core,sexplib.syntax read_foo_better_errors.native
$ ./read_foo_better_errors.native foo_example_broken.scm
Uncaught exception:
  
  (Sexplib.Conv.Of_sexp_error
   (Sexplib.Sexp.Annotated.Conv_exn foo_broken_example.scm:2:5
    (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;))
   &quot;&quot;)

Raised at file &quot;lib/pre_sexp.ml&quot;, line 1145, characters 12-58
Called from file &quot;lib/exn.ml&quot;, line 87, characters 6-10
</programlisting>
      <para>
        In the above error, &quot;foo_broken_example.scm:2:5&quot; tells
        us that the error occurred on
        &quot;foo_broken_example.scm&quot;, line 2, character 5, which
        is a much better start for figuring out what has gone wrong.
      </para>
    </sect2>
  </sect1>
  <sect1 id="sexp-conversion-directives">
    <title>Sexp-conversion directives</title>
    <para>
      Sexplib supports a collection of directives for modifying the
      default behavior of the autogenerated sexp-converters. These
      directives allow you to customize the way in which types are
      represented as s-expressions without having to write a custom
      parser.
    </para>
    <sect2 id="sexp_opaque">
      <title><literal>sexp_opaque</literal></title>
      <para>
        The most commonly used directive is
        <literal>sexp_opaque</literal>, whose purpose is to mark a given
        component of a type as being unconvertible. Anything marked with
        <literal>sexp_opaque</literal> will be presented as the atom
        <literal>&lt;opaque&gt;</literal> by the to-sexp converter, and
        will trigger an exception from the from-sexp converter.
      </para>
      <para>
        Note that the type of a component marked as opaque doesn't need
        to have a sexp-converter defined. Here, if we define a type
        without a sexp-converter, and then try to use another type with
        a sexp-converter, we'll error out:
      </para>
      <programlisting language="ocaml">
# script sexpr/sexp_opaque.topscript
$ utop
# type no_converter = int * int ;; 
type no_converter = int * int
# type t = { a: no_converter; b: string } with sexp ;; 
Characters 14-26:
Error: Unbound value no_converter_of_sexp
</programlisting>
      <para>
        But with <literal>sexp_opaque</literal>, we won't:
      </para>
      <programlisting language="ocaml">
...part 1 of sexpr/sexp_opaque.topscript
# type t = { a: no_converter sexp_opaque; b: string } with sexp ;; 
type t = { a : no_converter; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</programlisting>
      <para>
        And if we now convert a value of this type to an s-expression,
        we'll see the contents of field <literal>a</literal> marked as
        opaque:
      </para>
      <programlisting language="ocaml">
...part 2 of sexpr/sexp_opaque.topscript
# sexp_of_t { a = (3,4); b = &quot;foo&quot; } ;; 
- : Sexp.t = ((a &lt;opaque&gt;) (b foo))
</programlisting>
      <para>
        Note that the <literal>t_of_sexp</literal> function for an
        opaque type is generated, but will fail at runtime if it is
        used.
      </para>
      <programlisting language="ocaml">
...part 3 of sexpr/sexp_opaque.topscript
# t_of_sexp (Sexp.of_string &quot;((a whatever) (b foo))&quot;) ;; 
Exception:
(Sexplib.Conv.Of_sexp_error
 (Failure &quot;opaque_of_sexp: cannot convert opaque values&quot;) whatever).
</programlisting>
      <para>
        This is there to allow for s-expression converters to be created
        for types containing <literal>sexp_opaque</literal> values, and
        the resulting converters won't necessarily fail. For example, if
        we made the field containing a <literal>no_converter</literal> a
        list, the <literal>t_of_sexp</literal> function could still
        succeed when that list was empty, as shown below.
      </para>
      <programlisting language="ocaml">
...part 4 of sexpr/sexp_opaque.topscript
# type t = { a: no_converter sexp_opaque list; b: string } with sexp ;; 
type t = { a : no_converter list; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
# t_of_sexp (Sexp.of_string &quot;((a ()) (b foo))&quot;) ;; 
- : t = {a = []; b = &quot;foo&quot;}
</programlisting>
      <para>
        If you really only want to generate one direction of converter,
        one can do this by annotating the type with
        <literal>with sexp_of</literal> or
        <literal>with of_sexp</literal>, as shown below.
      </para>
      <programlisting language="ocaml">
...part 5 of sexpr/sexp_opaque.topscript
# type t = { a: no_converter sexp_opaque; b: string } with sexp_of ;; 
type t = { a : no_converter; b : string; }
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
# type t = { a: no_converter sexp_opaque; b: string } with of_sexp ;; 
type t = { a : no_converter; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
</programlisting>
    </sect2>
    <sect2 id="sexp_list">
      <title><literal>sexp_list</literal></title>
      <para>
        Sometimes, sexp-converters have more parentheses than one would
        ideally like. Consider, for example, the following variant type:
      </para>
      <programlisting language="ocaml">
# script sexpr/sexp_list.topscript
$ utop
# type compatible_versions =
  | Specific of string list
  | All with sexp ;; 
type compatible_versions = Specific of string list | All
val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;
val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;
# sexp_of_compatible_versions
  (Specific [&quot;3.12.0&quot;; &quot;3.12.1&quot;; &quot;3.13.0&quot;]) ;; 
- : Sexp.t = (Specific (3.12.0 3.12.1 3.13.0))
</programlisting>
      <para>
        You might prefer to make the syntax a bit less parenthesis-laden
        by dropping the parentheses around the list.
        <literal>sexp_list</literal> gives us this alternate syntax:
      </para>
      <programlisting language="ocaml">
...part 1 of sexpr/sexp_list.topscript
# type compatible_versions =
  | Specific of string sexp_list
  | All with sexp ;; 
type compatible_versions = Specific of string list | All
val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;
val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;
# sexp_of_compatible_versions
  (Specific [&quot;3.12.0&quot;; &quot;3.12.1&quot;; &quot;3.13.0&quot;]) ;; 
- : Sexp.t = (Specific 3.12.0 3.12.1 3.13.0)
</programlisting>
    </sect2>
    <sect2 id="sexp_option">
      <title><literal>sexp_option</literal></title>
      <para>
        Another common directive is <literal>sexp_option</literal>,
        which is used to to make a record field optional in the
        s-expression. Normally, optional values are represented either
        as <literal>()</literal> for <literal>None</literal>, or as
        <literal>(x)</literal> for <literal>Some x</literal>, and a
        record field containing an option would be rendered accordingly.
        For example:
      </para>
      <programlisting language="ocaml">
# script sexpr/sexp_option.topscript
$ utop
# type t = { a: int option; b: string } with sexp ;; 
type t = { a : int option; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
# sexp_of_t { a = None; b = &quot;hello&quot; } ;; 
- : Sexp.t = ((a ()) (b hello))
# sexp_of_t { a = Some 3; b = &quot;hello&quot; } ;; 
- : Sexp.t = ((a (3)) (b hello))
</programlisting>
      <para>
        But what if we want a field to be optional,
        <emphasis>i.e.</emphasis>, we want to allow it to be omitted
        from the record entirely? In that case, we can mark it with
        <literal>sexp_option</literal>:
      </para>
      <programlisting language="ocaml">
...part 1 of sexpr/sexp_option.topscript
# type t = { a: int sexp_option; b: string } with sexp ;; 
type t = { a : int option; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
# sexp_of_t { a = Some 3; b = &quot;hello&quot; } ;; 
- : Sexp.t = ((a 3) (b hello))
# sexp_of_t { a = None; b = &quot;hello&quot; } ;; 
- : Sexp.t = ((b hello))
</programlisting>
    </sect2>
    <sect2 id="specifying-defaults">
      <title>Specifying defaults</title>
      <para>
        The <literal>sexp_option</literal> declaration is really just an
        example of how one might want to deal with default values. With
        <literal>sexp_option</literal>, your type on the OCaml side is
        an option, with <literal>None</literal> representing the case
        where no value is provided. But you might want to allow other
        ways of filling in default values.
      </para>
      <para>
        Consider the following type which represents the configuration
        of a very simple web-server.
      </para>
      <programlisting language="ocaml">
# script sexpr/sexp_default.topscript
$ utop
# type http_server_config = {
     web_root: string;
     port: int;
     addr: string;
  } with sexp ;; 
type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
</programlisting>
      <para>
        One could imagine making some of these parameters optional; in
        particular, by default, we might want the web server to bind to
        port 80, and to listen as localhost. The sexp-syntax allows this
        as follows.
      </para>
      <programlisting language="ocaml">
...part 1 of sexpr/sexp_default.topscript
# type http_server_config = {
     web_root: string;
     port: int with default(80);
     addr: string with default(&quot;localhost&quot;);
  } with sexp ;; 
type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
</programlisting>
      <para>
        The top-level will echo back the type you just defined as usual,
        but also generate the additional conversion functions that let
        you convert to and from s-expressions.
      </para>
      <programlisting language="ocaml">
...part 2 of sexpr/sexp_default.topscript
# let cfg = http_server_config_of_sexp
   (Sexp.of_string &quot;((web_root /var/www/html))&quot;) ;; 
val cfg : http_server_config =
  {web_root = &quot;/var/www/html&quot;; port = 80; addr = &quot;localhost&quot;}
</programlisting>
      <para>
        When we convert the configuration back out to an s-expression,
        you'll notice that no data is dropped.
      </para>
      <programlisting language="ocaml">
...part 3 of sexpr/sexp_default.topscript
# sexp_of_http_server_config cfg ;; 
- : Sexp.t = ((web_root /var/www/html) (port 80) (addr localhost))
</programlisting>
      <para>
        We could make the generated s-expression also drop exported
        values, by using the <literal>sexp_drop_default</literal>
        directive.
      </para>
      <programlisting language="ocaml">
...part 4 of sexpr/sexp_default.topscript
# type http_server_config = {
     web_root: string;
     port: int with default(80), sexp_drop_default;
     addr: string with default(&quot;localhost&quot;), sexp_drop_default;
  } with sexp ;; 
type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
# let cfg = http_server_config_of_sexp
  (Sexp.of_string &quot;((web_root /var/www/html))&quot;) ;; 
val cfg : http_server_config =
  {web_root = &quot;/var/www/html&quot;; port = 80; addr = &quot;localhost&quot;}
# sexp_of_http_server_config cfg ;; 
- : Sexp.t = ((web_root /var/www/html))
</programlisting>
      <para>
        As you can see, the fields that are at their default values are
        simply omitted from the s-expression. On the other hand, if we
        convert a config with other values, then those values will be
        included in the s-expression.
      </para>
      <programlisting language="ocaml">
...part 5 of sexpr/sexp_default.topscript
# sexp_of_http_server_config { cfg with port = 8080 } ;; 
- : Sexp.t = ((web_root /var/www/html) (port 8080))
# sexp_of_http_server_config 
  { cfg with port = 8080; addr = &quot;192.168.0.1&quot; } ;; 
- : Sexp.t = ((web_root /var/www/html) (port 8080) (addr 192.168.0.1))
</programlisting>
      <para>
        This can be very useful in designing config file formats that
        are both reasonably terse and easy to generate and maintain. It
        can also be useful for backwards compatibility: if you add a new
        field to your config record, but you make that field optional,
        then you should still be able to parse older version of your
        config.
      </para>
    </sect2>
  </sect1>
</chapter><chapter id="concurrent-programming-with-async">
  <title>Concurrent Programming with Async</title>
  <para>
    The logic of building programs that interact with the outside world
    is often dominated by waiting: waiting for the click of a mouse, or
    for data to be fetched from disk, or for space to be available on an
    outgoing network buffer. Even mildly sophisticated interactive
    applications are typically <emphasis>concurrent</emphasis>, needing
    to wait for multiple different events at the same time, responding
    immediately to whatever event happens first.
  </para>
  <para>
    One approach to concurrency is to use preemptive system threads,
    which is the dominant approach in languages like Java or C#. In this
    model, each task that may require simultaneous waiting is given an
    operating system thread of its own, so it can block without stopping
    the entire program.
  </para>
  <para>
    Another approach is to have a single-threaded program where that
    single thread runs an <emphasis>event loop</emphasis>, whose job is
    to react to external events like timeouts or mouse clicks by
    invoking a callback function that has been registered for that
    purpose. This approach shows up in languages like JavaScript that
    have single-threaded runtimes as well as in many GUI toolkits.
  </para>
  <para>
    Each of these mechanisms has its own trade-offs. System threads
    require significant memory and other resources per thread. Also, the
    operating system can arbitrarily interleave the execution of system
    threads, requiring the programmer to carefully protect shared
    resources with locks and condition variables, which is exceedingly
    error-prone.
  </para>
  <para>
    Single-threaded event-driven systems, on the other hand, execute a
    single task at a time and do not require the same kind of complex
    synchronization that preemptive threads do. However, the inverted
    control structure of an event-driven program often means that your
    own control flow has to be threaded awkwardly through the system's
    event loop, leading to a maze of event callbacks.
  </para>
  <para>
    This chapter covers the Async library, which offers a hybrid model
    that aims to provide the best of both worlds, avoiding the
    performance compromises and synchronization woes of preemptive
    threads without the confusing inversion of control that usually
    comes with event-driven systems.
  </para>
  <sect1 id="async-basics">
    <title>Async basics</title>
    <para>
      Consider a typical function for doing I/O in Core.
    </para>
    <programlisting language="ocaml">
...part 1 of async/main.topscript
# In_channel.read_all;; 
- : string -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      Since the function returns a concrete string, it has to block
      until the read completes. The blocking nature of the call means
      that no progress can be made on anything else until the read is
      completed. Here's an example.
    </para>
    <programlisting language="ocaml">
...part 2 of async/main.topscript
# Out_channel.write_all &quot;test.txt&quot; ~data:&quot;This is only a test.&quot;;; 
- : unit = ()
# In_channel.read_all &quot;test.txt&quot;;; 
- : string = &quot;This is only a test.&quot;
</programlisting>
    <para>
      In Async, well-behaved functions never block. Instead, they return
      a value of type <literal>Deferred.t</literal> that acts as a
      placeholder that will eventually be filled in with the result. As
      an example, consider the signature of the Async equivalent of
      <literal>In_channel.read_all</literal>.
    </para>
    <programlisting language="ocaml">
...part 3 of async/main.topscript
# #require &quot;async&quot;;; 

/home/rwo/.opam/4.01.0dev+trunk/lib/herelib/herelib.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/async_core: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/async_core/async_core.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/async_unix: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/async_unix/async_unix.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/async_extra: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/async_extra/async_extra.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/async: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/async/async.cma: loaded
# open Async.Std;; 
# Reader.file_contents;; 
- : string -&gt; string Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      We first load the Async package in the toplevel using
      <literal>#require</literal>, and then open
      <literal>Async.Std</literal>, which adds a number of new
      identifiers and modules into our environment that make using Async
      more convenient. Opening <literal>Async.Std</literal> is standard
      practice for writing programs using Async, much like opening
      <literal>Core.Std</literal> is for using Core.
    </para>
    <para>
      A deferred is essentially a handle to a value that may be computed
      in the future. As such, if we call
      <literal>Reader.file_contents</literal>, the resulting deferred
      will initially be empty, as you can see by calling
      <literal>Deferred.peek</literal> on the resulting deferred.
    </para>
    <programlisting language="ocaml">
...part 4 of async/main.topscript
# let contents = Reader.file_contents &quot;test.txt&quot;;; 
val contents : string Deferred.t = &lt;abstr&gt;
# Deferred.peek contents;; 
- : string option = None
</programlisting>
    <para>
      The value in <literal>contents</literal> isn't yet determined in
      part because there's nothing running that could do the necessary
      I/O. When using Async, processing of I/O and other events is
      handled by the Async scheduler. When writing a standalone program,
      you need to start the scheduler explicitly, but utop knows about
      Async, and can start the scheduler automatically. More than that,
      utop knows about deferred values, and when you type in an
      expression of type <literal>Deferred.t</literal>, it will make
      sure the scheduler is running and block until the deferred is
      determined. Thus, we can write:
    </para>
    <programlisting language="ocaml">
...part 5 of async/main.topscript
# contents;; 
- : string = &quot;This is only a test.&quot;
</programlisting>
    <para>
      If we peek again, we'll see that the value of
      <literal>contents</literal> has been determined.
    </para>
    <programlisting language="ocaml">
...part 6 of async/main.topscript
# Deferred.peek contents;; 
- : string option = Some &quot;This is only a test.&quot;
</programlisting>
    <para>
      In order to do real work with deferreds, we need a way of
      sequencing deferred computations, which we do using
      <literal>Deferred.bind</literal>. First, let's consider the
      type-signature of bind.
    </para>
    <programlisting language="ocaml">
...part 7 of async/main.topscript
# Deferred.bind ;; 
- : 'a Deferred.t -&gt; ('a -&gt; 'b Deferred.t) -&gt; 'b Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      <literal>Deferred.bind d f</literal> takes a deferred value
      <literal>d</literal> and a function f that is to be run with the
      value of <literal>d</literal> once it's determined. You can think
      of <literal>Deferred.bind</literal> as a kind of sequencing
      operator, and what we're doing is essentially taking an
      asynchronous computation <literal>d</literal> and tacking on
      another stage comprised by the actions of the function
      <literal>f</literal>.
    </para>
    <para>
      At a more concrete level, the call to
      <literal>Deferred.bind</literal> returns a new deferred that
      becomes determined when the deferred returned by
      <literal>f</literal> is determined. It also implicitly registers
      with the scheduler an <emphasis>Async job</emphasis> that is
      responsible for running <literal>f</literal> once
      <literal>d</literal> is determined.
    </para>
    <para>
      Here's a simple use of bind for a function that replaces a file
      with an uppercase version of its contents.
    </para>
    <programlisting language="ocaml">
...part 8 of async/main.topscript
# let uppercase_file filename =
    Deferred.bind (Reader.file_contents filename)
     (fun text -&gt;
         Writer.save filename ~contents:(String.uppercase text))
  ;; 
val uppercase_file : string -&gt; unit Deferred.t = &lt;fun&gt;
# uppercase_file &quot;test.txt&quot;;; 
- : unit = ()
</programlisting>
    <para>
      Writing out <literal>Deferred.bind</literal> explicitly can be
      rather verbose, and so <literal>Async.Std</literal> includes an
      infix operator for it: <literal>&gt;&gt;=</literal>. Using this
      operator, we can rewrite <literal>uppercase_file</literal> as
      follows.
    </para>
    <programlisting language="ocaml">
...part 9 of async/main.topscript
# let uppercase_file filename =
    Reader.file_contents filename
    &gt;&gt;= fun text -&gt;
    Writer.save filename ~contents:(String.uppercase text)
  ;; 
val uppercase_file : string -&gt; unit Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      In the above we've dropped the parentheses around the function on
      the right-hand side of the bind, and we didn't add a level of
      indentation for the contents of that function. This is standard
      practice for using the bind operator.
    </para>
    <para>
      Now let's look at another potential use of bind. In this case,
      we'll write a function that counts the number of lines in a file.
    </para>
    <programlisting language="ocaml">
...part 10 of async/main.topscript
# let count_lines filename =
    Reader.file_contents filename
    &gt;&gt;= fun text -&gt;
    List.length (String.split text ~on:'\n')
  ;; 
Characters 85-125:
Error: This expression has type int but an expression was expected of type
         'a Deferred.t
</programlisting>
    <para>
      This looks reasonable enough, but as you can see, the compiler is
      unhappy with the code. The issue here is that bind expects a
      function that returns a deferred, but we've provided it a function
      that simply returns the result. To make these signatures match, we
      need a function for taking an ordinary value and wrapping it in a
      deferred. This function is a standard part of Async, and is called
      <literal>return</literal>:
    </para>
    <programlisting language="ocaml">
...part 11 of async/main.topscript
# return;; 
- : 'a -&gt; 'a Deferred.t = &lt;fun&gt;
# let three = return 3;; 
val three : int Deferred.t = &lt;abstr&gt;
# three;; 
- : int = 3
</programlisting>
    <para>
      Using <literal>return</literal>, we can make
      <literal>count_lines</literal> compile.
    </para>
    <programlisting language="ocaml">
...part 12 of async/main.topscript
# let count_lines filename =
    Reader.file_contents filename
    &gt;&gt;= fun text -&gt;
    return (List.length (String.split text ~on:'\n'))
  ;; 
val count_lines : string -&gt; int Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      Together, <literal>bind</literal> and <literal>return</literal>
      form a design pattern in functional programming known as a
      <emphasis>monad</emphasis>. You'll run across this signature in
      many applications beyond just threads. Indeed, we already ran
      across monads in
      <xref linkend="bind-and-other-error-handling-idioms"/>.
    </para>
    <para>
      Calling <literal>bind</literal> and <literal>return</literal>
      together is a fairly common pattern, and as such there is a
      standard shortcut for it called <literal>Deferred.map</literal>,
      which has the following signature:
    </para>
    <programlisting language="ocaml">
...part 13 of async/main.topscript
# Deferred.map;; 
- : 'a Deferred.t -&gt; f:('a -&gt; 'b) -&gt; 'b Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      and comes with its own infix equivalent,
      <literal>&gt;&gt;|</literal>. Using it, we can rewrite
      <literal>count_lines</literal> again a bit more succinctly:
    </para>
    <programlisting language="ocaml">
...part 14 of async/main.topscript
# let count_lines filename =
    Reader.file_contents filename
    &gt;&gt;| fun text -&gt;
    List.length (String.split text ~on:'\n')
  ;; 
val count_lines : string -&gt; int Deferred.t = &lt;fun&gt;
# count_lines &quot;/etc/hosts&quot;;; 
- : int = 12
</programlisting>
    <para>
      Note that <literal>count_lines</literal> returns a deferred, but
      <literal>utop</literal> waits for that deferred to become
      determined, and shows us the contents of the deferred instead.
    </para>
    <sect2 id="ivars-and-upon">
      <title>Ivars and upon</title>
      <para>
        Deferreds are usually built using combinations of
        <literal>bind</literal>, <literal>map</literal> and
        <literal>return</literal>, but sometimes you want to construct a
        deferred that you can determine explicitly with user-code. This
        is done using an <emphasis>ivar</emphasis>, which is a handle
        that lets you control precisely when a deferred becomes
        determined.
      </para>
      <para>
        There are three fundamental operations for working with an ivar;
        you can create one, using <literal>Ivar.create</literal>, you
        can read off the deferred that corresponds to the ivar in
        question, using <literal>Ivar.read</literal>, and you can fill
        an ivar, thus causing that deferred to become determined, using
        <literal>Ivar.fill</literal>. These operations are illustrated
        below.
      </para>
      <programlisting language="ocaml">
...part 15 of async/main.topscript
# let ivar = Ivar.create ();; 
val ivar : '_a Ivar.t = &lt;abstr&gt;
# let def = Ivar.read ivar;; 
val def : '_a Deferred.t = &lt;abstr&gt;
# Deferred.peek def;; 
- : '_a option = None
# Ivar.fill ivar &quot;Hello&quot;;; 
- : unit = ()
# Deferred.peek def;; 
- : string option = Some &quot;Hello&quot;
</programlisting>
      <para>
        Ivars are something of a low-level feature; operators like map,
        bind and return are typically easier to use and think about. But
        ivars can be useful when you want to build complicated
        synchronization patterns that can't be constructed naturally
        otherwise.
      </para>
      <para>
        As an example, imagine we wanted a way of scheduling a sequence
        of actions that would run after a fixed delay. In addition, we'd
        like to guarantee that these delayed actions are executed in the
        same order they were scheduled in. Here's a reasonable signature
        that captures this idea.
      </para>
      <programlisting language="ocaml">
...part 16 of async/main.topscript
# module type Delayer_intf = sig
    type t
    val create : Time.Span.t -&gt; t
    val schedule : t -&gt; (unit -&gt; 'a Deferred.t) -&gt; 'a Deferred.t
  end;; 
module type Delayer_intf =
  sig
    type t
    val create : Core.Span.t -&gt; t
    val schedule : t -&gt; (unit -&gt; 'a Deferred.t) -&gt; 'a Deferred.t
  end
</programlisting>
      <para>
        An action is handed to <literal>schedule</literal> in the form
        of a deferred-returning thunk (a thunk is a function whose
        argument is of type <literal>unit</literal>). A deferred is
        handed back to the caller of <literal>schedule</literal> that
        will eventually be filled with the contents of the deferred
        value returned by the thunk to be scheduled. To implement this,
        we'll use a new operator called <literal>upon</literal>, which
        has the following signature.
      </para>
      <programlisting language="ocaml">
...part 17 of async/main.topscript
# upon;; 
- : 'a Deferred.t -&gt; ('a -&gt; unit) -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        Like <literal>bind</literal> and <literal>return</literal>,
        <literal>upon</literal> schedules a callback to be executed when
        the deferred it is passed is determined; but unlike those calls,
        it doesn't create a new deferred for this callback to fill.
      </para>
      <para>
        Our delayer implementation is organized around a queue of
        thunks, where every call to <literal>schedule</literal> adds a
        thunk to the queue, and also schedules a job in the future to
        grab a thunk off the queue and run it. The waiting will be done
        using the function <literal>after</literal> which takes a time
        span and returns a deferred which becomes determined after that
        time span elapses.
      </para>
      <programlisting language="ocaml">
...part 18 of async/main.topscript
# module Delayer : Delayer_intf = struct
    type t = { delay: Time.Span.t;
               jobs: (unit -&gt; unit) Queue.t;
             }

    let create delay =
      { delay; jobs = Queue.create () }

    let schedule t thunk =
      let ivar = Ivar.create () in
      Queue.enqueue t.jobs (fun () -&gt;
        upon (thunk ()) (fun x -&gt; Ivar.fill ivar x));
      upon (after t.delay) (fun () -&gt;
        let job = Queue.dequeue_exn t.jobs in
        job ());
      Ivar.read ivar
  end;; 
module Delayer : Delayer_intf
</programlisting>
      <para>
        This code isn't particularly long, but it is a bit subtle. In
        particular, note how the queue of thunks is used to ensure that
        the enqueued actions are run in order, even if the thunks
        scheduled by <literal>upon</literal> are run out-of-order. This
        is kind of subtlety typical of code that involves ivars and
        <literal>upon</literal>, and because of this, you should stick
        to the simpler map/bind/return style of working with deferreds
        when you can.
      </para>
    </sect2>
  </sect1>
  <sect1 id="examples-an-echo-server">
    <title>Examples: an echo server</title>
    <para>
      Now that we have the basics of Async under our belt, let's look at
      a small standalone Async program. In particular, we'll write an
      echo server, <emphasis>i.e.</emphasis>, a program that accepts
      connections from clients and spits back whatever is sent to it.
    </para>
    <para>
      The first step is to create a function that can copy data from an
      input to an output. Here, we'll use Async's
      <literal>Reader</literal> and <literal>Writer</literal> modules
      which provide a convenient abstraction for working with input and
      output channels.
    </para>
    <programlisting language="ocaml">
(* async/echo.ml  *)
open Core.Std
open Async.Std

(* Copy data from the reader to the writer, using the provided buffer
   as scratch space *)
let rec copy_blocks buffer r w =
  Reader.read r buffer
  &gt;&gt;= function
  | `Eof -&gt; return ()
  | `Ok bytes_read -&gt;
    Writer.write w buffer ~len:bytes_read;
    Writer.flushed w
    &gt;&gt;= fun () -&gt;
    copy_blocks buffer r w
</programlisting>
    <para>
      Bind is used in the above code to sequence the operations: first,
      we call <literal>Reader.read</literal> to get a block of input.
      Then, when that's complete and if a new block was returned, we
      write that block to the writer. Finally, we wait until the
      writer's buffers are flushed, waiting on the deferred returned by
      <literal>Writer.flushed</literal>, at which point we recur. If we
      hit an end-of-file condition, the loop is ended. The deferred
      returned by a call to <literal>copy_blocks</literal> becomes
      determined only once the end-of-file condition is hit.
    </para>
    <para>
      One important aspect of how this is written is that it uses
      <emphasis>pushback</emphasis>, which is to say that if the writer
      can't make progress writing, the reader will stop reading. If you
      don't implement pushback in your servers, then a stopped client
      can cause your program to leak memory, since you'll need to
      allocate space for the data that's been read in but not yet
      written out.
    </para>
    <para>
      You might also be concerned that the chain of deferreds that is
      built up as you go through the loop would lead to a memory leak.
      After all, this code constructs an ever-growing chain of binds,
      each of which creates a deferred. In this case, however, all of
      the deferreds should become determined precisely when the final
      deferred in the chain is determined, in this case, when the
      <literal>Eof</literal> condition is hit. Because of this, we could
      safely replace all of these deferreds with a single deferred.
      Async has logic to do just this, and so there's no memory leak
      after all. This is essentially a form of tail-call optimization,
      lifted to the Async monad.
    </para>
    <para>
      <literal>copy_blocks</literal> provides the logic for handling a
      client connection, but we still need to set up a server to receive
      such connections and dispatch to <literal>copy_blocks</literal>.
      For this, we'll use Async's <literal>Tcp</literal> module, which
      has a collection of utilities for creating TCP clients and
      servers.
    </para>
    <programlisting language="ocaml">
(* async/echo.ml (starting from part 1) *)
(** Starts a TCP server, which listens on the specified port, invoking
    copy_blocks every time a client connects. *)
let run () =
  let host_and_port =
    Tcp.Server.create
      ~on_handler_error:`Raise
      (Tcp.on_port 8765)
      (fun _addr r w -&gt;
         let buffer = String.create (16 * 1024) in
         copy_blocks buffer r w)
  in
  ignore (host_and_port : (Socket.Address.Inet.t, int) Tcp.Server.t Deferred.t)
</programlisting>
    <para>
      The result of calling <literal>Tcp.Server.create</literal> is a
      <literal>Tcp.Server.t</literal>, which is a handle to the server
      that lets you shut the server down. We don't use that
      functionality here, so we explicitly ignore [server] to suppress
      the unused-variables error. We put in a type annotation around the
      ignored value to make the nature of the value we're ignoring
      explicit.
    </para>
    <para>
      The most important argument to
      <literal>Tcp.Server.create</literal> is the final one, which is
      the client connection handler. Notably, the above code does
      nothing explicit to close down the client connections when the
      communication is done. That's because the server will
      automatically shut down the connection once the deferred returned
      by the handler becomes determined.
    </para>
    <para>
      Finally, we need to initiate the server and start the Async
      scheduler.
    </para>
    <programlisting language="ocaml">
(* async/echo.ml (starting from part 2) *)
(* Call [run], and then start the scheduler *)
let () =
  run ();
  never_returns (Scheduler.go ())
</programlisting>
    <para>
      One of the most common newbie errors with Async is to forget to
      run the scheduler. It can be a bewildering mistake, because
      without the scheduler, your program won't do anything at all; even
      calls to <literal>printf</literal> won't actually reach the
      terminal.
    </para>
    <para>
      It's worth noting that even though we didn't spend much explicit
      effort on thinking about multiple clients, this server is able to
      handle many concurrent clients without further modification.
    </para>
    <para>
      Now that we have the echo server, we can connect to the echo
      server using the netcat tool, which is invoked as
      <literal>nc</literal>.
    </para>
    <programlisting>
# running async/run_echo.out.sh
$ ./echo.native &amp;
$ nc 127.0.0.1 8765
This is an echo server
This is an echo server
It repeats whatever I write.
It repeats whatever I write.
</programlisting>
    <note>
    <title>
    Functions that never return
    </title>
    <para>
      You might wonder what's going on with the call to
      <literal>never_returns</literal> above.
      <literal>never_returns</literal> is an idiom that comes from
      <literal>Core</literal> that is used to mark functions that don't
      return. Typically, a function that doesn't return is inferred as
      having return type <literal>'a</literal>.
    </para>
    <programlisting language="ocaml">
...part 19 of async/main.topscript
# let rec loop_forever () = loop_forever ();; 
val loop_forever : unit -&gt; 'a = &lt;fun&gt;
# let always_fail () = assert false;; 
val always_fail : unit -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      This can be surprising when you call a function like this
      expecting it to return unit, and really it never returns. The
      type-checker won't necessarily complain in such a case.
    </para>
    <programlisting language="ocaml">
...part 20 of async/main.topscript
# let do_stuff n =
    let x = 3 in
    if n &gt; 0 then loop_forever ();
    x + n
  ;; 
val do_stuff : int -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      With a name like <literal>loop_forever</literal>, the meaning is
      clear enough in this case. But with something like
      <literal>Scheduler.go</literal>, the fact that it never returns is
      less clear, and so we use the type system to make it more explicit
      by giving it a return type of <literal>never_returns</literal>. To
      make it clearer how this works, let's do the same trick with
      <literal>loop_forever</literal>.
    </para>
    <programlisting language="ocaml">
...part 21 of async/main.topscript
# let rec loop_forever () : never_returns = loop_forever ();; 
val loop_forever : unit -&gt; never_returns = &lt;fun&gt;
</programlisting>
    <para>
      The type <literal>never_returns</literal> is uninhabited, so a
      function can't return a value of type
      <literal>never_returns</literal>, which means only functions that
      never return can have it as their return type! Now, if we rewrite
      our <literal>do_stuff</literal> function, we'll get a helpful type
      error.
    </para>
    <programlisting language="ocaml">
...part 22 of async/main.topscript
# let do_stuff n =
    let x = 3 in
    if n &gt; 0 then loop_forever ();
    x + n
  ;; 
Characters 38-67:
Error: This expression has type unit but an expression was expected of type
         never_returns
</programlisting>
    <para>
      We can resolve the error by calling the function
      <literal>never_returns</literal>.
    </para>
    <programlisting language="ocaml">
...part 23 of async/main.topscript
# never_returns;; 
- : never_returns -&gt; 'a = &lt;fun&gt;
# let do_stuff n =
    let x = 3 in
    if n &gt; 0 then never_returns (loop_forever ());
    x + n
  ;; 
val do_stuff : int -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      Thus, we got the compilation to go through by explicitly marking
      in the source that the call to <literal>loop_forever</literal>
      never returns.
    </para>
    </note>
    <sect2 id="improving-the-echo-server">
      <title>Improving the echo server</title>
      <para>
        Let's try to go a little bit farther with our echo server. Let's
        walk through a few small improvements:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Add a proper command-line interface with
            <literal>Command</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            Add a flag to specify the port to listen on, and a flag to
            make the server echo back the capitalized version of
            whatever was sent to it.
          </para>
        </listitem>
        <listitem>
          <para>
            Simplify the code using Async's <literal>Pipe</literal>
            interface.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Here's the improved code below. There's both the
        <literal>run</literal> function, which which actually starts the
        server, and the command-line interface, which is the entry-point
        of the program. Note the use of
        <literal>Deferred.never</literal> in <literal>run</literal>,
        which returns a deferred that never becomes determined. In this
        case, we use <literal>Deferred.never</literal> because the
        server in question doesn't shut down.
      </para>
      <programlisting language="ocaml">
(* async/better_echo.ml  *)
open Core.Std
open Async.Std

let run ~uppercase ~port =
  let host_and_port =
    Tcp.Server.create
      ~on_handler_error:`Raise
      (Tcp.on_port port)
      (fun _addr r w -&gt;
        Pipe.transfer (Reader.pipe r) (Writer.pipe w)
           ~f:(if uppercase then String.uppercase else Fn.id))
  in
  ignore (host_and_port : (Socket.Address.Inet.t, int) Tcp.Server.t Deferred.t);
  Deferred.never ()

let () =
  Command.async_basic
    ~summary:&quot;Start an echo server&quot;
    Command.Spec.(
      empty
      +&gt; flag &quot;-uppercase&quot; no_arg
        ~doc:&quot; Convert to uppercase before echoing back&quot;
      +&gt; flag &quot;-port&quot; (optional_with_default 8765 int)
        ~doc:&quot; Port to listen on (default 8765)&quot;
    )
    (fun uppercase port () -&gt; run ~uppercase ~port)
  |&gt; Command.run
</programlisting>
      <para>
        The most notable change in the above code is the use of Async's
        <literal>Pipe</literal>. A <literal>Pipe</literal> is a
        communication channel that's used for connecting different parts
        of your program. You can think of it as a consumer/producer
        queue that uses deferreds for communicating when the pipe is
        ready to be read from or written to. Our use of pipes is fairly
        minimal here, but they are an important part of Async, so it's
        worth discussing them in some detail.
      </para>
      <para>
        Pipes are created in connected read/write pairs, as you can see
        below.
      </para>
      <programlisting language="ocaml">
...part 24 of async/main.topscript
# let (r,w) = Pipe.create ();; 
val r : '_a Pipe.Reader.t = &lt;abstr&gt;
val w : '_a Pipe.Writer.t = &lt;abstr&gt;
</programlisting>
      <para>
        <literal>r</literal> and <literal>w</literal> are really just
        read and write handles to the same underlying object. Note that
        <literal>r</literal> and <literal>w</literal> have weakly
        polymorphic types. That's because a pipe is mutable and so can
        contain elements of only one type, which will be settled by the
        compiler once we try to use the pipe for anything.
      </para>
      <para>
        If we just try and write to the writer, we'll see that we block
        indefinitely in utop. You can break out of the wait by hitting
        <literal>Control-C</literal>.
      </para>
      <programlisting language="ocaml">
# script async/pipe_write_break.rawscript
$ utop
# Pipe.write w &quot;Hello World!&quot;;;
Interrupted.
</programlisting>
      <para>
        The deferred returned by write completes on its own once the
        value written into the pipe has been read out:
      </para>
      <programlisting language="ocaml">
...part 25 of async/main.topscript
# let (r,w) = Pipe.create ();; 
val r : '_a Pipe.Reader.t = &lt;abstr&gt;
val w : '_a Pipe.Writer.t = &lt;abstr&gt;
# let write_complete = Pipe.write w &quot;Hello World!&quot;;; 
val write_complete : unit Deferred.t = &lt;abstr&gt;
# Pipe.read r;; 
- : [ `Eof | `Ok of string ] = `Ok &quot;Hello World!&quot;
# write_complete;; 
- : unit = ()
</programlisting>
      <para>
        In the function <literal>run</literal> above, we're taking
        advantage of one of the many utility functions provided for
        pipes in the <literal>Pipe</literal> module. In particular,
        we're using <literal>Pipe.transfer</literal> to set up a process
        that takes data from a reader-pipe and moves it to a
        writer-pipe. Here's the type of
        <literal>Pipe.transfer</literal>:
      </para>
      <programlisting language="ocaml">
...part 26 of async/main.topscript
# Pipe.transfer;; 
- : 'a Pipe.Reader.t -&gt; 'b Pipe.Writer.t -&gt; f:('a -&gt; 'b) -&gt; unit Deferred.t =
&lt;fun&gt;
</programlisting>
      <para>
        The two pipes being connected are generated by the
        <literal>Reader.pipe</literal> and
        <literal>Writer.pipe</literal> call respectively. Note that
        pushback is preserved throughout the process, so that if the
        writer gets blocked, the writer's pipe will stop pulling data
        from the reader's pipe, which will prevent the reader from
        reading in more data.
      </para>
      <para>
        Importantly, the deferred returned by
        <literal>Pipe.transfer</literal> becomes determined once the
        reader has been closed and the last element is transferred from
        the reader to the writer. Once that deferred becomes determined,
        the server will shut down that client connection. So, when a
        client disconnects, the rest of the shutdown happens
        transparently.
      </para>
      <para>
        The command-line parsing for this program is based on the
        <literal>Command</literal> library that we introduced in
        <xref linkend="command-line-parsing"/>. When you open
        <literal>Async.Std</literal>, the <literal>Command</literal>
        module has added to it the <literal>async_basic</literal> call:
      </para>
      <programlisting language="ocaml">
...part 27 of async/main.topscript
# Command.async_basic;; 
- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    ('a, unit -&gt; unit Deferred.t) Command.Spec.t -&gt; 'a -&gt; Command.t
= &lt;fun&gt;
</programlisting>
      <para>
        This differs from the ordinary <literal>Command.basic</literal>
        call in that the main function must return a
        <literal>Deferred.t</literal>, and that the running of the
        command (using <literal>Command.run</literal>) automatically
        starts the async scheduler, without requiring an explicit call
        to <literal>Scheduler.go</literal>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="example-searching-definitions-with-duckduckgo">
    <title>Example: searching definitions with DuckDuckGo</title>
    <para>
      DuckDuckGo is a search engine with a freely available search
      interface. In this section, we'll use Async to write a small
      command-line utility for querying DuckDuckGo to extract
      definitions for a collection of terms.
    </para>
    <para>
      Our code is going to rely on a number of other libraries, all of
      which can be installed using OPAM. Refer to
      <xref linkend="installation"/> if you need help on the
      installation. Here's the list of libraries we'll need.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>textwrap</literal>, a library for wrapping long
          lines. We'll use this for printing out our results.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>uri</literal>, a library for handling URI's, or
          &quot;Uniform Resource Identifiers&quot;, of which HTTP URL's
          are an example.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>yojson</literal>, a JSON parsing library that was
          described in <xref linkend="handling-json-data"/>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>cohttp</literal>, a library for creating HTTP clients
          and servers. We need Async support, which comes with the
          <literal>cohttp.async</literal> package.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Now let's dive into the implementation.
    </para>
    <sect2 id="uri-handling">
      <title>URI handling</title>
      <para>
        HTTP URLs, which identify endpoints across the web, are actually
        part of a more general family known as Uniform Resource
        Identifiers (URIs). The full URI specification is defined in
        <ulink url="http://tools.ietf.org/html/rfc3986">RFC3986</ulink>,
        and is rather complicated. Luckily, the <literal>uri</literal>
        library provides a strongly-typed interface which takes care of
        much of the hassle.
      </para>
      <para>
        We'll need a function for generating the URI's that we're going
        to use to query the DuckDuckGo servers.
      </para>
      <programlisting language="ocaml">
(* async/search.ml  *)
open Core.Std
open Async.Std

(* Generate a DuckDuckGo search URI from a query string *)
let query_uri query =
  let base_uri = Uri.of_string &quot;http://api.duckduckgo.com/?format=json&quot; in
  Uri.add_query_param base_uri (&quot;q&quot;, [query])
</programlisting>
      <para>
        A <literal>Uri.t</literal> is constructed from the
        <literal>Uri.of_string</literal> function, and a query parameter
        <literal>q</literal> is added with the desired search query. The
        library takes care of encoding the URI correctly when outputting
        it in the network protocol.
      </para>
    </sect2>
    <sect2 id="parsing-json-strings">
      <title>Parsing JSON strings</title>
      <para>
        The HTTP response from DuckDuckGo is in JSON, a common (and
        thankfully simple) format that is specified in
        <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</ulink>.
        We'll parse the JSON data using the Yojson library, which we
        already introduced in
        <xref linkend="handling-json-data"/>.
      </para>
      <para>
        We expect the response from DuckDuckGo to come across as a JSON
        record, which is represented by the <literal>Assoc</literal> tag
        in Yojson's JSON variant. We expect the definition itself to
        come across under either the key &quot;Abstract&quot; or
        &quot;Definition&quot;, and so the code below looks under both
        keys, returning the first one for which a non-empty value is
        defined.
      </para>
      <programlisting language="ocaml">
(* async/search.ml (starting from part 1) *)
(* Extract the &quot;Definition&quot; or &quot;Abstract&quot; field from the DuckDuckGo results *)
let get_definition_from_json json =
  match Yojson.Safe.from_string json with
  | `Assoc kv_list -&gt;
    let find key =
      begin match List.Assoc.find kv_list key with
      | None | Some (`String &quot;&quot;) -&gt; None
      | Some s -&gt; Some (Yojson.Safe.to_string s)
      end
    in
    begin match find &quot;Abstract&quot; with
    | Some _ as x -&gt; x
    | None -&gt; find &quot;Definition&quot;
    end
  | _ -&gt; None
</programlisting>
    </sect2>
    <sect2 id="executing-an-http-client-query">
      <title>Executing an HTTP client query</title>
      <para>
        Now let's look at the code for dispatching the search queries
        over HTTP, using the Cohttp library.
      </para>
      <programlisting language="ocaml">
(* async/search.ml (starting from part 2) *)
(* Execute the DuckDuckGo search *)
let get_definition word =
  Cohttp_async.Client.get (query_uri word)
  &gt;&gt;= fun (_, body) -&gt;
  Pipe.to_list body
  &gt;&gt;| fun strings -&gt;
  (word, get_definition_from_json (String.concat strings))
</programlisting>
      <para>
        To better understand what's going on, it's useful to look at the
        type for <literal>Cohttp_async.Client.get</literal>, which we
        can do in utop.
      </para>
      <programlisting language="ocaml">
...part 28 of async/main.topscript
# #require &quot;cohttp.async&quot;;; 

/home/rwo/.opam/4.01.0dev+trunk/lib/re: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/re/re.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/re/re_posix.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/re/re_emacs.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/re/re_str.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/uri: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/uri/uri.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/uri/services.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/cohttp: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/cohttp/cohttp.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/cohttp/cohttp_async.cma: loaded
# Cohttp_async.Client.get;; 
- : ?interrupt:unit Deferred.t -&gt;
    ?headers:Cohttp.Header.t -&gt;
    Uri.t -&gt; (Cohttp.Response.t * string Pipe.Reader.t) Deferred.t
= &lt;fun&gt;
</programlisting>
      <para>
        The <literal>get</literal> call takes as a required argument a
        URI, and returns a deferred value containing a
        <literal>Cohttp.Response.t</literal> (which we ignore) and a
        pipe reader to which the body of the request will be written to
        as it is received.
      </para>
      <para>
        In this case, the HTTP body probably isn't very large, so we
        call <literal>Pipe.to_list</literal> to collect the strings from
        the pipe as a single deferred list of strings. We then join
        those strings using <literal>String.concat</literal> and pass
        the result through our parsing function.
      </para>
      <para>
        Running a single search isn't that interesting from a
        concurrency perspective, so let's write code for dispatching
        multiple searches in parallel. First, we need code for
        formatting and printing out the search result.
      </para>
      <programlisting language="ocaml">
(* async/search.ml (starting from part 3) *)
(* Print out a word/definition pair *)
let print_result (word,definition) =
  printf &quot;%s\n%s\n\n%s\n\n&quot;
    word
    (String.init (String.length word) ~f:(fun _ -&gt; '-'))
    (match definition with
    | None -&gt; &quot;No definition found&quot;
    | Some def -&gt;
      String.concat ~sep:&quot;\n&quot;
        (Wrapper.wrap (Wrapper.make 70) def))
</programlisting>
      <para>
        We use the <literal>Wrapper</literal> module from the
        <literal>textwrap</literal> package to do the line-wrapping. It
        may not be obvious that this routine is using Async, but it
        does: the version of <literal>printf</literal> that's called
        here is actually Async's specialized <literal>printf</literal>
        that goes through the Async scheduler rather than printing
        directly. The original definition of <literal>printf</literal>
        is shadowed by this new one when you open
        <literal>Async.Std</literal>. An important side effect of this
        is that if you write an Async program and forget to start the
        scheduler, calls like <literal>printf</literal> won't actually
        generate any output!
      </para>
      <para>
        The next function dispatches the searches in parallel, waits for
        the results, and then prints.
      </para>
      <programlisting language="ocaml">
(* async/search.ml (starting from part 4) *)
(* Run many searches in parallel, printing out the results after they're all
   done. *)
let search_and_print words =
  Deferred.all (List.map words ~f:get_definition)
  &gt;&gt;| fun results -&gt;
  List.iter results ~f:print_result
</programlisting>
      <para>
        We used <literal>List.map</literal> to call
        <literal>get_definition</literal> on each word, and
        <literal>Deferred.all</literal> to wait for all the results.
        Here's the type of <literal>Deferred.all</literal>:
      </para>
      <programlisting language="ocaml">
...part 29 of async/main.topscript
# Deferred.all;; 
- : 'a Deferred.t list -&gt; 'a list Deferred.t = &lt;fun&gt;
</programlisting>
      <para>
        Note that the list returned by <literal>Deferred.all</literal>
        reflects the order of the deferreds passed to it. As such, the
        definitions will be printed out in the same order that the
        search words are passed in, no matter what orders the queries
        return in. We could rewrite this code to print out the results
        as they're received (and thus potentially out of order) as
        follows.
      </para>
      <programlisting language="ocaml">
(* async/search_out_of_order.ml (starting from part 1) *)
(* Run many searches in parallel, printing out the results as you go *)
let search_and_print words =
  Deferred.all_unit (List.map words ~f:(fun word -&gt;
    get_definition word &gt;&gt;| print_result))
</programlisting>
      <para>
        The difference is that we both dispatch the query and print out
        the result in the closure passed to <literal>map</literal>,
        rather than waiting for all of the results to get back and then
        printing them out together. We use
        <literal>Deferred.all_unit</literal>, which takes a list of
        <literal>unit</literal> deferreds and returns a single
        <literal>unit</literal> deferred that becomes determined when
        every deferred on the input list is determined. We can see the
        type of this function in utop.
      </para>
      <programlisting language="ocaml">
...part 30 of async/main.topscript
# Deferred.all_unit;; 
- : unit Deferred.t list -&gt; unit Deferred.t = &lt;fun&gt;
</programlisting>
      <para>
        Finally, we create a command line interface using
        <literal>Command.async_basic</literal>.
      </para>
      <programlisting language="ocaml">
(* async/search.ml (starting from part 5) *)
let () =
  Command.async_basic
    ~summary:&quot;Retrieve definitions from duckduckgo search engine&quot;
    Command.Spec.(
      empty
      +&gt; anon (sequence (&quot;word&quot; %: string))
    )
    (fun words () -&gt; search_and_print words)
  |&gt; Command.run
</programlisting>
      <para>
        And that's all we need to create a simple but usable definition
        searcher.
      </para>
      <programlisting>
# running async/run_search.out.sh
$ corebuild -pkg cohttp.async,yojson,textwrap search.native
$ ./search.native &quot;Concurrent Programming&quot; &quot;OCaml&quot;
Concurrent Programming
----------------------

&quot;Concurrent computing is a form of computing in which programs are
designed as collections of interacting computational processes that
may be executed in parallel.&quot;

OCaml
-----

&quot;OCaml, originally known as Objective Caml, is the main implementation
of the Caml programming language, created by Xavier Leroy, Jérôme
Vouillon, Damien Doligez, Didier Rémy and others in 1996.&quot;

</programlisting>
    </sect2>
  </sect1>
  <sect1 id="exception-handling">
    <title>Exception handling</title>
    <para>
      When programming with external resources, errors are everywhere:
      everything from a flaky server to a network outage to exhausting
      of local resources can lead to a runtime error. When programming
      in OCaml, some of these errors will show up explicitly in a
      function's return type, and some of them will show up as
      exceptions. We covered exception handling in OCaml in
      <xref linkend="exceptions"/>, but as we'll see,
      exception handling in a concurrent program presents some new
      challenges.
    </para>
    <para>
      Let's get a better sense of how exceptions work in Async by
      creating an asynchronous computation that (sometimes) fails with
      an exception. The function <literal>maybe_raise</literal> below
      blocks for half a second, and then either throws an exception or
      returns unit, alternating between the two behaviors on subsequent
      calls.
    </para>
    <programlisting language="ocaml">
...part 31 of async/main.topscript
# let maybe_raise =
    let should_fail = ref false in
    fun () -&gt;
      let will_fail = !should_fail in
      should_fail := not will_fail;
      after (Time.Span.of_sec 0.5)
      &gt;&gt;= fun () -&gt;
      if will_fail then raise Exit else return ()
 ;; 
val maybe_raise : unit -&gt; unit Deferred.t = &lt;fun&gt;
# maybe_raise ();; 
- : unit = ()
# maybe_raise ();; 
Exception:
(lib/monitor.ml.Error_
 ((exn Exit) (backtrace (&quot;&quot;))
  (monitor
   (((name block_on_async) (here ()) (id 46) (has_seen_error true)
     (someone_is_listening true) (kill_index 0))
    ((name main) (here ()) (id 1) (has_seen_error false)
     (someone_is_listening false) (kill_index 0)))))).
</programlisting>
    <para>
      In utop, the exception thrown by <literal>maybe_raise ()</literal>
      terminates the evaluation of just that expression, but in a
      standalone program, an uncaught exception would bring down the
      entire process.
    </para>
    <para>
      So, how could we capture and handle such an exception? You might
      try to do this using OCaml's built-in <literal>try/with</literal>
      statement, but as you can see below, that doesn't quite do the
      trick.
    </para>
    <programlisting language="ocaml">
...part 32 of async/main.topscript
# let handle_error () =
    try
      maybe_raise ()
      &gt;&gt;| fun () -&gt; &quot;success&quot;
    with _ -&gt; return &quot;failure&quot;
  ;; 
val handle_error : unit -&gt; string Deferred.t = &lt;fun&gt;
# handle_error ();; 
- : string = &quot;success&quot;
# handle_error ();; 
Exception:
(lib/monitor.ml.Error_
 ((exn Exit) (backtrace (&quot;&quot;))
  (monitor
   (((name block_on_async) (here ()) (id 50) (has_seen_error true)
     (someone_is_listening true) (kill_index 0))
    ((name main) (here ()) (id 1) (has_seen_error false)
     (someone_is_listening false) (kill_index 0)))))).
</programlisting>
    <para>
      This didn't work because <literal>try/with</literal> only captures
      exceptions that are thrown in the code directly executed within
      it, while <literal>maybe_raise</literal> schedules an Async job to
      run in the future, and it's that job that throws an exception.
    </para>
    <para>
      We can capture this kind of asynchronous error use the
      <literal>try_with</literal> function provided by Async:
    </para>
    <programlisting language="ocaml">
...part 33 of async/main.topscript
# let handle_error () =
    try_with (fun () -&gt; maybe_raise ())
    &gt;&gt;| function
    | Ok ()   -&gt; &quot;success&quot;
    | Error _ -&gt; &quot;failure&quot;
  ;; 
val handle_error : unit -&gt; string Deferred.t = &lt;fun&gt;
# handle_error ();; 
- : string = &quot;success&quot;
# handle_error ();; 
- : string = &quot;failure&quot;
</programlisting>
    <para>
      <literal>try_with f</literal> takes as its argument a
      deferred-returning thunk <literal>f</literal>, and returns a
      deferred that becomes determined either as <literal>Ok</literal>
      of whatever <literal>f</literal> returned, or
      <literal>Error exn</literal> if <literal>f</literal> threw an
      exception before its return value became determined.
    </para>
    <sect2 id="monitors">
      <title>Monitors</title>
      <para>
        <literal>try_with</literal> is a great way of handling
        exceptions in Async, but it's not the whole story. All of
        Async's exception-handling mechanisms,
        <literal>try_with</literal> included, are built on top of
        Async's system of <emphasis>monitors</emphasis>, which are
        inspired by the error-handling mechanism in Erlang of the same
        name. Monitors are fairly low-level and are only occasionally
        used directly, but it's nonetheless worth understanding how they
        work.
      </para>
      <para>
        In Async, a monitor is a context that determines what to do when
        there is an unhandled exception. Every Async job runs within the
        context of some monitor, which, when the job is running, is
        referred to as the current monitor. When a new Async job is
        scheduled, say, using <literal>bind</literal> or
        <literal>map</literal>, it inherits the current monitor of the
        job that spawned it.
      </para>
      <para>
        Monitors are arranged in a tree—when a new monitor is created
        (say, using <literal>Monitor.create</literal>) it is a child of
        the current monitor. You can explicitly run jobs within a
        monitor using <literal>within</literal>, which takes a thunk
        that returns a non-deferred value, or
        <literal>within'</literal>, which takes a thunk that returns a
        deferred. Here's an example.
      </para>
      <programlisting language="ocaml">
...part 34 of async/main.topscript
# let blow_up () =
    let monitor = Monitor.create ~name:&quot;blow up monitor&quot; () in
    within' ~monitor maybe_raise
  ;; 
val blow_up : unit -&gt; unit Deferred.t = &lt;fun&gt;
# blow_up ();; 
- : unit = ()
# blow_up ();; 
Exception:
(lib/monitor.ml.Error_
 ((exn Exit) (backtrace (&quot;&quot;))
  (monitor
   (((name &quot;blow up monitor&quot;) (here ()) (id 62) (has_seen_error true)
     (someone_is_listening false) (kill_index 0))
    ((name block_on_async) (here ()) (id 61) (has_seen_error false)
     (someone_is_listening true) (kill_index 0))
    ((name main) (here ()) (id 1) (has_seen_error false)
     (someone_is_listening false) (kill_index 0)))))).
</programlisting>
      <para>
        In addition to the ordinary stack-trace, the exception displays
        the trace of monitors through which the exception traveled,
        starting at the one we created, called &quot;blow up
        monitor&quot;. The other monitors you see come from utop's
        special handling of deferreds.
      </para>
      <para>
        Monitors can do more than just augment the error-trace of an
        exception. You can also use a monitor to explicitly handle
        errors delivered to that monitor. The
        <literal>Monitor.errors</literal> call is a particularly
        important one. It detaches the monitor from its parent, handing
        back the stream of errors that would otherwise have been
        delivered to the parent monitor. This allows one to do custom
        handling of errors, which may include re-raising errors to the
        parent. Here is a very simple example of a function that
        captures and ignores errors in the processes it spawns.
      </para>
      <programlisting language="ocaml">
# script async/main-35.rawscript
$ utop
# let swallow_error () =
    let monitor = Monitor.create () in
    Stream.iter (Monitor.errors monitor) ~f:(fun _exn -&gt;
      printf &quot;an error happened\n&quot;);
    within' ~monitor (fun () -&gt;
      after (Time.Span.of_sec 0.5) &gt;&gt;= fun () -&gt; failwith &quot;Kaboom!&quot;)
  ;;
val swallow_error : unit -&gt; 'a Deferred.t = &lt;fun&gt;
# swallow_error ();;
an error happened

</programlisting>
      <para>
        The message &quot;an error happened&quot; is printed out, but
        the deferred returned by <literal>swallow_error</literal> is
        never determined. This makes sense, since the calculation never
        actually completes, so there's no value to return. You can break
        out of this in utop by hitting <literal>Control-C</literal>.
      </para>
      <para>
        Here's an example of a monitor which passes some exceptions
        through to the parent, and handles others. Exceptions are sent
        to the parent using <literal>Monitor.send_exn</literal>, with
        <literal>Monitor.current</literal> being called to find the
        current monitor, which is the parent of the newly created
        monitor.
      </para>
      <programlisting language="ocaml">
...part 36 of async/main.topscript
# exception Ignore_me;; 
exception Ignore_me
# let swallow_some_errors exn_to_raise =
    let child_monitor  = Monitor.create  () in
    let parent_monitor = Monitor.current () in
    Stream.iter (Monitor.errors child_monitor) ~f:(fun error -&gt;
      match Monitor.extract_exn error with
      | Ignore_me -&gt; printf &quot;ignoring exn\n&quot;
      | _ -&gt; Monitor.send_exn parent_monitor error);
    within' ~monitor:child_monitor (fun () -&gt;
       after (Time.Span.of_sec 0.5)
       &gt;&gt;= fun () -&gt; raise exn_to_raise)
  ;; 
val swallow_some_errors : exn -&gt; 'a Deferred.t = &lt;fun&gt;
</programlisting>
      <para>
        Note that we use <literal>Monitor.extract_exn</literal> to grab
        the underlying exception that was thrown. Async wraps exceptions
        it catches with extra information, including the monitor trace,
        so you need to grab the underlying exception to match on it.
      </para>
      <para>
        If we pass in an exception other than
        <literal>Ignore_me</literal>, like, say, the built-in exception
        <literal>Not_found</literal>, then the exception will be passed
        to the parent monitor and delivered as usual.
      </para>
      <programlisting language="ocaml">
...part 37 of async/main.topscript
# swallow_some_errors Not_found;; 
Exception:
(lib/monitor.ml.Error_
 ((exn Not_found) (backtrace (&quot;&quot;))
  (monitor
   (((name (id 66)) (here ()) (id 66) (has_seen_error true)
     (someone_is_listening true) (kill_index 0))
    ((name block_on_async) (here ()) (id 65) (has_seen_error true)
     (someone_is_listening true) (kill_index 0))
    ((name main) (here ()) (id 1) (has_seen_error false)
     (someone_is_listening false) (kill_index 0)))))).
</programlisting>
      <para>
        If instead we use <literal>Ignore_me</literal>, the exception
        will be ignored, and we again see that the deferred never
        returns, but the exception was caught and ignored.
      </para>
      <programlisting language="ocaml">
# script async/main-38.rawscript
$ utop
# swallow_some_errors Ignore_me;;
ignoring exn
</programlisting>
      <para>
        In practice, you should rarely use monitors directly, instead
        using functions like <literal>try_with</literal> and
        <literal>Monitor.protect</literal> that are built on top of
        monitors. One example of a library that uses monitors directly
        is <literal>Tcp.Server.create</literal>, which tracks both
        exceptions thrown by the logic that handles the network
        connection and by the callback for responding to an individual
        request, in either case responding to an exception by closing
        the connection. It is for building this kind of custom error
        handling that monitors can be helpful.
      </para>
    </sect2>
    <sect2 id="example-handling-exceptions-with-duckduckgo">
      <title>Example: Handling exceptions with DuckDuckGo</title>
      <para>
        Let's now go back and improve the exception handling of our
        DuckDuckGo client. In particular, we'll change it so that any
        individual queries that fail are reported as such, without
        preventing other queries from succeeding.
      </para>
      <para>
        The search code as it is fails rarely, so let's make a change
        that allows us to trigger failures more predictably. We'll do
        this by making it possible to distribute the requests over
        multiple servers. Then, we'll handle the errors that occur when
        one of those servers is misspecified.
      </para>
      <para>
        First we'll need to change <literal>query_uri</literal> to take
        an argument specifying the server to connect to, as follows.
      </para>
      <programlisting language="ocaml">
(* async/search_with_configurable_server.ml (starting from part 1) *)
(* Generate a DuckDuckGo search URI from a query string *)
let query_uri ~server query =
  let base_uri =
    Uri.of_string (String.concat [&quot;http://&quot;;server;&quot;/?format=json&quot;])
  in
  Uri.add_query_param base_uri (&quot;q&quot;, [query])
</programlisting>
      <para>
        and then making the appropriate changes to get the list of
        servers on the command-line, and to distribute the search
        queries round-robin over the list of servers. Now, let's see
        what happens if we rebuild the application and run it giving it
        a list of servers, some of which won't respond to the query.
      </para>
      <programlisting>
# running async/run_search_with_configurable_server.out.sh
$ corebuild -pkg cohttp.async,yojson,textwrap search_with_configurable_server.native
$ ./search_with_configurable_server.native -servers localhost,api.duckduckgo.com &quot;Concurrent Programming&quot; OCaml
(&quot;unhandled exception&quot;
 ((lib/monitor.ml.Error_
   ((exn (&quot;Yojson.Json_error(\&quot;Blank input data\&quot;)&quot;))
    (backtrace
     (&quot;Raised at file \&quot;common.ml\&quot;, line 5, characters 25-39&quot;
      &quot;Called from file \&quot;search_with_configurable_server.ml\&quot;, line 14, characters 8-36&quot;
      &quot;Called from file \&quot;search_with_configurable_server.ml\&quot;, line 34, characters 9-57&quot;
      &quot;Called from file \&quot;lib/deferred.ml\&quot;, line 20, characters 62-65&quot;
      &quot;Called from file \&quot;lib/scheduler.ml\&quot;, line 125, characters 6-17&quot;
      &quot;Called from file \&quot;lib/jobs.ml\&quot;, line 65, characters 8-13&quot; &quot;&quot;))
    (monitor
     (((name main) (here ()) (id 1) (has_seen_error true)
       (someone_is_listening false) (kill_index 0))))))
  (Pid 18924)))
</programlisting>
      <para>
        As you can see, we got a &quot;Connection refused&quot; failure
        which ends the entire program, even though one of the two
        queries would have gone through successfully. We can handle the
        failures of individual connections separately by using the
        <literal>try_with</literal> function within each call to
        <literal>get_definition</literal>, as follows.
      </para>
      <programlisting language="ocaml">
(* async/search_with_error_handling.ml (starting from part 1) *)
(* Execute the DuckDuckGo search *)
let get_definition ~server word =
  try_with (fun () -&gt;
    Cohttp_async.Client.get (query_uri ~server word)
    &gt;&gt;= fun  (_, body) -&gt;
    Pipe.to_list body
    &gt;&gt;| fun strings -&gt;
    (word, get_definition_from_json (String.concat strings)))
  &gt;&gt;| function
  | Ok (word,result) -&gt; (word, Ok result)
  | Error _          -&gt; (word, Error &quot;Unexpected failure&quot;)
</programlisting>
      <para>
        Here, we use <literal>try_with</literal> to capture the
        exception, which we then use map (the
        <literal>&gt;&gt;|</literal> operator) to convert the error into
        the form we want: a pair whose first element is the word being
        searched for, and the second element is the (possibly erroneous)
        result.
      </para>
      <para>
        Now we just need to change the code for
        <literal>print_result</literal> so that it can handle the new
        type.
      </para>
      <programlisting language="ocaml">
(* async/search_with_error_handling.ml (starting from part 2) *)
(* Print out a word/definition pair *)
let print_result (word,definition) =
  printf &quot;%s\n%s\n\n%s\n\n&quot;
    word
    (String.init (String.length word) ~f:(fun _ -&gt; '-'))
    (match definition with
     | Error s -&gt; &quot;DuckDuckGo query failed: &quot; ^ s
     | Ok None -&gt; &quot;No definition found&quot;
     | Ok (Some def) -&gt;
       String.concat ~sep:&quot;\n&quot;
         (Wrapper.wrap (Wrapper.make 70) def))
</programlisting>
      <para>
        Now, if we run that same query, we'll get individualized
        handling of the connection failures:
      </para>
      <programlisting>
# running async/run_search_with_error_handling.out.sh
$ corebuild -pkg cohttp.async,yojson,textwrap search_with_error_handling.native
$ ./search_with_error_handling.native -servers localhost,api.duckduckgo.com &quot;Concurrent Programming&quot; OCaml
Concurrent Programming
----------------------

DuckDuckGo query failed: Unexpected failure

OCaml
-----

&quot;OCaml, originally known as Objective Caml, is the main implementation
of the Caml programming language, created by Xavier Leroy, Jérôme
Vouillon, Damien Doligez, Didier Rémy and others in 1996.&quot;

</programlisting>
      <para>
        Now, only the query that went to <literal>localhost</literal>
        failed.
      </para>
      <para>
        Note that in this code, we're relying on the fact that
        <literal>Cohttp_async.Client.get</literal> will clean up after
        itself after an exception, in particular by closing its file
        descriptors. If you need to implement such functionality
        directly, you may want to use the
        <literal>Monitor.protect</literal> call, which is analogous to
        the <literal>protect</literal> call described in
        <xref linkend="cleaning-up-in-the-presence-of-exceptions"/>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="timeouts-cancellation-and-choices">
    <title>Timeouts, cancellation and choices</title>
    <para>
      In a concurrent program, one often needs to combine results from
      multiple distinct concurrent sub-computations going on in the same
      program. We already saw this in our DuckDuckGo example, where we
      used <literal>Deferred.all</literal> and
      <literal>Deferred.all_unit</literal> to wait for a list of
      deferreds to become determined. Another useful primitive is
      <literal>Deferred.both</literal>, which lets you wait until two
      deferreds of different types have returned, returning both values
      as a tuple. Here, we use the function <literal>sec</literal>,
      which is shorthand for creating a time-span equal to a given
      number of seconds.
    </para>
    <programlisting language="ocaml">
...part 39 of async/main.topscript
# let string_and_float = Deferred.both
   (after (sec 0.5)  &gt;&gt;| fun () -&gt; &quot;A&quot;)
   (after (sec 0.25) &gt;&gt;| fun () -&gt; 32.33);; 
val string_and_float : (string * float) Deferred.t = &lt;abstr&gt;
# string_and_float;; 
- : string * float = (&quot;A&quot;, 32.33)
</programlisting>
    <para>
      Sometimes, however, we want to wait only for the first of multiple
      events to occur. This happens particularly often when dealing with
      timeouts. In that case, we can use the call
      <literal>Deferred.any</literal>, which, given a list of deferreds,
      returns a single deferred that will become determined once any of
      the values on the list is determined.
    </para>
    <programlisting language="ocaml">
...part 40 of async/main.topscript
# Deferred.any [ (after (sec 0.5) &gt;&gt;| fun () -&gt; &quot;half a second&quot;)
               ; (after (sec 10.) &gt;&gt;| fun () -&gt; &quot;ten seconds&quot;) ] ;; 
- : string = &quot;half a second&quot;
</programlisting>
    <para>
      Let's use this to add timeouts to our DuckDuckGo searches. We'll
      do this by writing a wrapper for <literal>get_definition</literal>
      that takes a timeout (in the form of a
      <literal>Time.Span.t</literal>) as an argument, and returns either
      the definition, or, if that takes too long, the timeout.
    </para>
    <programlisting language="ocaml">
(* async/search_with_timeout.ml (starting from part 1) *)
let get_definition_with_timeout ~server ~timeout word =
  Deferred.any
    [ (after timeout &gt;&gt;| fun () -&gt; (word,Error &quot;Timed out&quot;))
    ; (get_definition ~server word
       &gt;&gt;| fun (word,result) -&gt;
       let result' = match result with
         | Ok _ as x -&gt; x
         | Error _ -&gt; Error &quot;Unexpected failure&quot;
       in
       (word,result')
      )
    ]
</programlisting>
    <para>
      We use <literal>&gt;&gt;|</literal> above to transform the
      deferred values we're waiting for so that
      <literal>Deferred.any</literal> can choose between values of the
      same type.
    </para>
    <para>
      A problem with this code is that the HTTP query kicked off by
      <literal>get_definition</literal> is not actually shut down when
      the timeout fires. As such,
      <literal>get_definition_with_timeout</literal> essentially leaks
      an open connection. Happily, Cohttp does provide a way of shutting
      down a client. You can pass a deferred under the label
      <literal>interrupt</literal> to
      <literal>Cohttp_async.Client.get</literal>. Once
      <literal>interrupt</literal> is determined, the client connection
      will terminated and the corresponding connections closed.
    </para>
    <para>
      The following code shows how you can change
      <literal>get_definition</literal> and
      <literal>get_definition_with_timeout</literal> to cancel the
      <literal>get</literal> call if the timeout expires.
    </para>
    <programlisting language="ocaml">
(* async/search_with_timeout_no_leak_simple.ml (starting from part 1) *)
(* Execute the DuckDuckGo search *)
let get_definition ~server ~interrupt word =
  try_with (fun () -&gt;
    Cohttp_async.Client.get ~interrupt (query_uri ~server word)
    &gt;&gt;= fun  (_, body) -&gt;
    Pipe.to_list body
    &gt;&gt;| fun strings -&gt;
    (word, get_definition_from_json (String.concat strings)))
  &gt;&gt;| function
  | Ok (word,result) -&gt; (word, Ok result)
  | Error exn        -&gt; (word, Error exn)
</programlisting>
    <para>
      Next, we'll modify <literal>get_definition_with_timeout</literal>
      to create a deferred to pass in to
      <literal>get_definition</literal> which will become determined
      when our timeout expires.
    </para>
    <programlisting language="ocaml">
(* async/search_with_timeout_no_leak_simple.ml (starting from part 2) *)
let get_definition_with_timeout ~server ~timeout word =
  get_definition ~server ~interrupt:(after timeout) word
  &gt;&gt;| fun (word,result) -&gt;
  let result' = match result with
    | Ok _ as x -&gt; x
    | Error _ -&gt; Error &quot;Unexpected failure&quot;
  in
  (word,result')
</programlisting>
    <para>
      This will work, and will cause the connection to shutdown cleanly
      when we time out; but our code no longer explicitly knows whether
      or not the timeout has kicked in. In particular, the error message
      on a timeout will now be <literal>Unexpected failure</literal>
      rather than <literal>Timed out</literal>, which it was in our
      previous implementation. This is a minor issue in this case, but
      if we wanted to have special behavior in the case of a timeout, it
      would be a more serious issue.
    </para>
    <para>
      We can get more precise handling of timeouts using Async's
      <literal>choose</literal> operator, which lets you pick between a
      collection of different deferreds, reacting to exactly one of
      them. Each deferred is combined, using the function
      <literal>choice</literal>, with a function that is called if and
      only if that is the chosen deferred. Here's the type signature of
      <literal>choice</literal> and <literal>choose</literal>:
    </para>
    <programlisting language="ocaml">
...part 41 of async/main.topscript
# choice;; 
- : 'a Deferred.t -&gt; ('a -&gt; 'b) -&gt; 'b Deferred.choice = &lt;fun&gt;
# choose;; 
- : 'a Deferred.choice list -&gt; 'a Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      <literal>choose</literal> provides no guarantee that the
      <literal>choice</literal> built around the first deferred to
      become determined will in fact be chosen. But
      <literal>choose</literal> does guarantee that only one
      <literal>choice</literal> will be chosen, and only the chosen
      <literal>choice</literal> will execute the attached closure.
    </para>
    <para>
      In the following, we use <literal>choose</literal> to ensure that
      the <literal>interrupt</literal> deferred becomes determined if
      and only if the timeout-deferred is chosen. Here's the code.
    </para>
    <programlisting language="ocaml">
(* async/search_with_timeout_no_leak.ml (starting from part 2) *)
let get_definition_with_timeout ~server ~timeout word =
  let interrupt = Ivar.create () in
  choose
    [ choice (after timeout) (fun () -&gt;
       Ivar.fill interrupt ();
       (word,Error &quot;Timed out&quot;))
    ; choice (get_definition ~server ~interrupt:(Ivar.read interrupt) word)
        (fun (word,result) -&gt;
           let result' = match result with
             | Ok _ as x -&gt; x
             | Error _ -&gt; Error &quot;Unexpected failure&quot;
           in
           (word,result')
        )
    ]
</programlisting>
    <para>
      Now, if we run this with a suitably small timeout, we'll see that
      some queries succeed and some fail, and the timeouts are reported
      as such.
    </para>
    <programlisting>
# running async/run_search_with_timeout_no_leak.out.sh
$ corebuild -pkg cohttp.async,yojson,textwrap search_with_timeout_no_leak.native
$ ./search_with_timeout_no_leak.native &quot;concurrent programming&quot; ocaml -timeout 0.1s
concurrent programming
----------------------

DuckDuckGo query failed: Timed out

ocaml
-----

DuckDuckGo query failed: Timed out

</programlisting>
  </sect1>
  <sect1 id="working-with-system-threads">
    <title>Working with system threads</title>
    <para>
      OCaml does have built-in support for true system threads,
      <emphasis>i.e.</emphasis>, kernel-level threads whose interleaving
      is controlled by the kernel. We discussed in the beginning of the
      chapter why Async is generally a better choice than system
      threads, but even if you mostly use Async, OCaml's system threads
      are sometimes necessary, and it's worth understanding them.
    </para>
    <para>
      The most surprising aspect of OCaml's system threads is that they
      don't afford you any access to physical parallelism on the
      machine. That's because OCaml's runtime has a single runtime lock
      which at most one thread can be holding at a time.
    </para>
    <para>
      Given that threads don't provide physical parallelism, why are
      they useful at all?
    </para>
    <para>
      The most common reason for using system threads is that there are
      some operating system calls that have no non-blocking alternative,
      which means that you can't run them directly in a system like
      Async without blocking out the entire system. For this reason,
      Async maintains a thread pool for running such calls. Most of the
      time, as a user of Async you don't need to think about this, but
      it is happening under the covers.
    </para>
    <para>
      Another reasonably common reason to have multiple threads is to
      deal with non-OCaml libraries that have their own event loop or
      for whatever reason need their own threads. In that case, it's
      sometimes useful to run some OCaml code on the foreign thread as
      part of the communication to your main program. OCaml's foreign
      function interface is discussed in more detail in
      <xref linkend="foreign-function-interface"/>.
    </para>
    <para>
      Another occasional motivation for using true system threads is to
      interoperate with compute-intensive OCaml code that otherwise
      would block the Async runtime. In Async, if you have a
      long-running computation that never calls <literal>bind</literal>
      or <literal>map</literal>, then that computation will block out
      the entire system until it completes.
    </para>
    <para>
      One way of dealing with this is to explicitly break up the
      calculation into smaller pieces that are separated by binds. But
      sometimes this explicit yielding is impractical, since it may
      involve intrusive changes to an existing codebase. Another
      solution is to run the code in question in a separate thread.
      Async's <literal>In_thread</literal> module provides multiple
      facilities for doing just this, <literal>In_thread.run</literal>
      being the simplest. We can simply write
    </para>
    <programlisting language="ocaml">
...part 42 of async/main.topscript
# let def = In_thread.run (fun () -&gt; List.range 1 10);; 
val def : int list Deferred.t = &lt;abstr&gt;
# def;; 
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]
</programlisting>
    <para>
      to cause <literal>List.range 1 10</literal> to be run on one of
      Async's worker threads. When the computation is complete, the
      result is placed in the deferred, where it can be used in the
      ordinary way from Async.
    </para>
    <warning> 
    <title>
    Thread-safety and locking
    </title>
    <para>
      Once you start working with system threads, you'll need to be
      careful about locking your data-structures. Most mutable OCaml
      data-structures do not have well-defined semantics when accessed
      concurrently by multiple threads. The issues you can run into
      range from runtime exceptions to corrupted data-structures to, in
      some rare cases, segfaults. That means you should always use
      mutexes when sharing mutable data between different systems
      threads. Even data-structures that seem like they should be safe
      but are mutable under the covers, like lazy values, can have
      undefined behavior when accessed from multiple threads.
    </para>
    <para>
      There are two commonly available mutex packages for OCaml: the
      <literal>Mutex</literal> module that's part of the standard
      library, which is just a wrapper over OS-level mutexes, and
      <literal>Nano_mutex</literal>, a more efficient alternative that
      takes advantage of some of the locking done by the OCaml runtime
      to avoid needing to create an OS-level mutex much of the time. As
      a result, creating a <literal>Nano_mutex.t</literal> is 20x faster
      than creating a <literal>Mutex.t</literal>, and acquiring the
      mutex is about 40% faster.
    </para>
    </warning>
    <para>
      Interoperability between Async and system threads can be quite
      tricky, so let's work through some of the issues. Consider the
      following function which schedules itself to wake up every
      <literal>100ms</literal>, and keeps a list of the delays after
      which it actually woke up, until the deferred it was passed
      becomes determined. We can use this to see how responsive Async
      is.
    </para>
    <programlisting language="ocaml">
...part 43 of async/main.topscript
# let log_delays d =
    let start = Time.now () in
    let rec loop stamps =
      let delay = Time.diff (Time.now ()) start in
      match Deferred.peek d with
      | Some () -&gt; return (delay :: stamps)
      | None -&gt;
        after (sec 0.1)
        &gt;&gt;= fun () -&gt;
        loop (delay :: stamps)
    in
    loop [] &gt;&gt;| List.rev
  ;; 
val log_delays : unit Deferred.t -&gt; Core.Span.t list Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      If we feed this function a simple timeout, it works as you might
      expect.
    </para>
    <programlisting language="ocaml">
...part 44 of async/main.topscript
# log_delays (after (sec 1.));; 
- : Core.Span.t list =
[0.000953674ms; 100.237ms; 200.437ms; 300.63ms; 400.832ms; 501.034ms;
 601.233ms; 701.43ms; 801.631ms; 901.831ms; 1.00202s]
</programlisting>
    <para>
      Now, if instead of simply waiting a second, what if we have a busy
      loop running instead?
    </para>
    <programlisting language="ocaml">
...part 45 of async/main.topscript
# let busy_loop n =
    let x = ref None in
    for i = 1 to n * 100_000 do x := Some i done
  ;; 
val busy_loop : int -&gt; unit = &lt;fun&gt;
# log_delays (Deferred.unit &gt;&gt;| fun () -&gt; busy_loop 100);; 
- : Core.Span.t list = [0.000953674ms; 242.903ms]
</programlisting>
    <para>
      As you can see, instead of waking up ten times a second,
      <literal>log_delays</literal> is blocked out for much longer than
      that while <literal>busy_loop</literal> churns away.
    </para>
    <para>
      If, on the other hand, we use <literal>In_thread.run</literal> to
      offload this to a different system thread, the behavior will be
      different.
    </para>
    <programlisting language="ocaml">
...part 46 of async/main.topscript
# log_delays (In_thread.run (fun () -&gt; busy_loop 100));; 
- : Core.Span.t list = [0.000953674ms; 244.311ms]
</programlisting>
    <para>
      Now <literal>log_delays</literal> does get a chance to run, but
      not nearly as often as it would like to. The reason for this is
      that that now that we're using system threads, we are at the mercy
      of the operating system in terms of when each thread gets
      scheduled. The behavior becomes very dependent on the OS and how
      you configure the priority of your processes within the OS itself.
    </para>
    <para>
      Another tricky aspect of dealing with OCaml threads has to do with
      allocation. OCaml's threads only get a chance to give up the
      runtime lock when they interact with the allocator, so if there's
      a piece of code that doesn't allocate at all, then it will never
      allow any other OCaml thread to run. We can see this if we rewrite
      our busy-loop slightly so it doesn't allocate.
    </para>
    <programlisting language="ocaml">
...part 47 of async/main.topscript
# let noalloc_busy_loop n =
    let rec loop n =
      if n &lt;= 0 then ()
      else loop (n-1)
    in
    loop (n * 100_000)
  ;; 
val noalloc_busy_loop : int -&gt; unit = &lt;fun&gt;
# log_delays (In_thread.run (fun () -&gt; noalloc_busy_loop 500));; 
- : Core.Span.t list = [0.00214577ms; 916.779ms]
</programlisting>
    <para>
      Even though <literal>noalloc_busy_loop</literal> was running in a
      different thread, it didn't let <literal>log_delays</literal> run
      at all.
    </para>
    <para>
      Overall, combining Async and threads is quite tricky, but it can
      be done safely and easily if you follow the following hold:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          There is no shared mutable state between the various threads
          involved.
        </para>
      </listitem>
      <listitem>
        <para>
          The computations executed by <literal>In_thread.run</literal>
          do not make any calls to the async library.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      It is possible to safely use threads in ways that violate these
      constraints. In particular, foreign threads can acquire the Async
      lock using calls from the <literal>Thread_safe</literal> module in
      Async, and thereby run Async computations safely. This is a very
      flexible way of connecting threads to the Async world, but it's a
      complex use-case that is beyond the scope of this chapter.
    </para>
  </sect1>
</chapter></part><part label="III"><title>The Runtime System</title><partintro><para>Part III is all about understanding the compiler toolchain and runtime system in OCaml.  
     It's a remarkably simple system in comparison to other language runtimes (such as Java or 
     the .NET CLR).</para><para>You'll need to read this to build very high performance systems that have to minimise 
      resource usage or interface to C libraries. This is also where we talk about profiling and 
      debugging techniques using tools such as GNU gdb.</para></partintro><chapter id="foreign-function-interface">
  <title>Foreign Function Interface</title>
  <para>
    OCaml has several options available to interact with non-OCaml code.
    The compiler can link with external system libraries via C code and
    also produce standalone native object files that can be embedded
    within other non-OCaml applications.
  </para>
  <para>
    The mechanism by which code in one programming language can invoke
    routines in another different programming language is called a
    <emphasis>foreign function interface</emphasis>. This chapter will:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        show how to call routines in C libraries directly from your
        OCaml code.
      </para>
    </listitem>
    <listitem>
      <para>
        teach you how to build higher-level abstractions in OCaml from
        the low-level C bindings.
      </para>
    </listitem>
    <listitem>
      <para>
        work through some full examples for binding a terminal interface
        and UNIX date/time functions.
      </para>
    </listitem>
  </itemizedlist>
  <sect1 id="the-ctypes-library">
    <title>The Ctypes library</title>
    <para>
      The simplest foreign function interface in OCaml doesn't even
      require you to write any C code at all! The Ctypes library lets
      you define the C interface in pure OCaml, and the library then
      takes care of loading the C symbols and invoking the foreign
      function call.
    </para>
    <para>
      Let's dive straight into a realistic example to show you how the
      library looks. We'll create a binding to the Ncurses terminal
      toolkit, as it's widely available on most systems and doesn't have
      any complex dependencies.
    </para>
    <note>
    <title>
    Installing the Ctypes library
    </title>
    <para>
      You'll need to install the
      <ulink url="https://github.com/atgreen/libffi"><literal>libffi</literal></ulink>
      library as a prerequisite to using Ctypes. It's a fairly popular
      library and should be available in your OS package manager.
    </para>
    <para>
      A special note for Mac users: the version of
      <literal>libffi</literal> installed by default in MacOS X 10.8 is
      too old for some of the features that Ctypes needs. Use Homebrew
      to <literal>brew install libffi</literal> to get the latest
      version before installing the OCaml library.
    </para>
    <para>
      Once that's done, Ctypes is available via OPAM as usual.
    </para>
    <programlisting>
# running ffi/install.out.sh
$ brew install libffi     # for MacOS X users
$ opam install ctypes
$ utop
# require &quot;ctypes.foreign&quot; ;;
</programlisting>
    <para>
      You'll also need the Ncurses library for the first example. This
      comes pre-installed on many operating systems such as MacOS X and
      Debian Linux provides it as the <literal>ncurses-dev</literal>
      package.
    </para>
    </note>
  </sect1>
  <sect1 id="example-a-terminal-interface">
    <title>Example: a terminal interface</title>
    <para>
      Ncurses is a library to help build terminal-independent text
      interfaces in a reasonably efficient way. It's used in console
      mail clients like Mutt and Pine, and console web browsers such as
      Lynx.
    </para>
    <para>
      The full C interface is quite large and is explained in the online
      <ulink url="http://www.gnu.org/software/ncurses/">documentation</ulink>.
      We'll just use the small excerpt that's shown below since we just
      want to demonstrate Ctypes in action.
    </para>
    <programlisting language="c">
typedef struct _win_st WINDOW;
typedef unsigned int chtype;

WINDOW *initscr   (void);
WINDOW *newwin    (int, int, int, int);
void    endwin    (void);
void    refresh   (void);
void    wrefresh  (WINDOW *);
void    addstr (const char *);
int     mvwaddch  (WINDOW *, int, int, const chtype);
void    mvwaddstr (WINDOW *, int, int, char *);
void    box (WINDOW *, chtype, chtype);
int     cbreak (void);
</programlisting>
    <para>
      The Ncurses functions either operate on the current
      pseudo-terminal or on a window that has been created via
      <literal>newwin</literal>. The <literal>WINDOW</literal> structure
      holds the internal library state and is considered abstract
      outside of Ncurses. Ncurses clients just need to store the pointer
      somewhere and pass it back to Ncurses library calls, which in turn
      dereference its contents.
    </para>
    <para>
      Note that there are over 200 library calls in Ncurses, so we're
      only binding a select few for this example. The
      <literal>initscr</literal> and <literal>newwin</literal> create
      <literal>WINDOW</literal> pointers for the global and sub-windows
      respectively. The <literal>mvwaddrstr</literal> takes a window,
      x/y offsets and a string and writes to the screen at that
      location. The terminal is only updated after
      <literal>refresh</literal> or <literal>wrefresh</literal> are
      called.
    </para>
    <para>
      Ctypes provides an OCaml interface that lets you map these C
      functions to equivalent OCaml functions. The library takes care of
      converting OCaml function calls and arguments into the C calling
      convention, invoking the foreign call within the C library and
      finally returning the result as an OCaml value.
    </para>
    <para>
      Let's begin by defining the basic values we need, starting with
      the <literal>WINDOW</literal> state pointer.
    </para>
    <programlisting language="ocaml">
(* ffi/ncurses.ml  *)
open Ctypes

type window = unit ptr
let window : window typ = ptr void
</programlisting>
    <para>
      We don't know the internal representation of the window pointer,
      so we treat it as a C void pointer. We'll improve on this later on
      in the chapter, but that's good enough for now. The second
      statement defines an OCaml value that represents the
      <literal>WINDOW</literal> C pointer. This value is used later in
      the Ctypes function definitions.
    </para>
    <programlisting language="ocaml">
(* ffi/ncurses.ml (starting from part 1) *)
open Foreign

let initscr =
  foreign &quot;initscr&quot; (void @-&gt; returning window)
</programlisting>
    <para>
      That's all we need to invoke our first function call to
      <literal>initscr</literal> to initialize the terminal. The
      <literal>foreign</literal> function accepts two parameters:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          the C function call name, which is looked up using the
          <literal>dlsym</literal> POSIX function.
        </para>
      </listitem>
      <listitem>
        <para>
          a value that defines the complete set of C function arguments
          and its return type. The <literal>@-&gt;</literal> operator
          adds an argument to the C parameter list and
          <literal>returning</literal> terminates the parameter list
          with the return type.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The remainder of the Ncurses binding simply expands on these
      definitions.
    </para>
    <programlisting language="ocaml">
(* ffi/ncurses.ml (starting from part 2) *)
let newwin =
  foreign &quot;newwin&quot; 
    (int @-&gt; int @-&gt; int @-&gt; int @-&gt; returning window)

let endwin =
  foreign &quot;endwin&quot; (void @-&gt; returning void)

let refresh =
  foreign &quot;refresh&quot; (void @-&gt; returning void)

let wrefresh =
  foreign &quot;wrefresh&quot; (window @-&gt; returning void)

let addstr =
  foreign &quot;addstr&quot; (string @-&gt; returning void)

let mvwaddch =
  foreign &quot;mvwaddch&quot;
    (window @-&gt; int @-&gt; int @-&gt; char @-&gt; returning void)

let mvwaddstr =
  foreign &quot;mvwaddstr&quot;
    (window @-&gt; int @-&gt; int @-&gt; string @-&gt; returning void)

let box =
  foreign &quot;box&quot; (window @-&gt; char @-&gt; char @-&gt; returning void)

let cbreak =
  foreign &quot;cbreak&quot; (void @-&gt; returning int)
</programlisting>
    <para>
      These definitions are all straightforward mappings from the C
      declarations in the Ncurses header file. Note that the
      <literal>string</literal> and <literal>int</literal> values here
      are nothing to do with OCaml type declarations; instead, they are
      values that come from opening the <literal>Ctypes</literal> module
      at the top of the file.
    </para>
    <para>
      Most of the parameters in the Ncurses example represent fairly
      simple scalar C types except for <literal>window</literal> (a
      pointer to the library state), and <literal>string</literal>,
      which maps from OCaml strings that have a specific length onto C
      character buffers whose length is defined by a terminating null
      character that immediately follows the string data.
    </para>
    <para>
      The module signature for <literal>ncurses.mli</literal> looks much
      like a normal OCaml signature. You can infer it directly from the
      <literal>ncurses.ml</literal> by running a special build target.
    </para>
    <programlisting>
# running ffi/infer_ncurses.out.sh
$ corebuild -pkg ctypes.foreign ncurses.inferred.mli
$ cp _build/ncurses.inferred.mli .
</programlisting>
    <para>
      The <literal>inferred.mli</literal> target instructs the compiler
      to generate the default signature for a module file, and places it
      in the <literal>_build</literal> directory as a normal output. You
      should normally copy it out into your source directory and
      customize it improve its safety for external callers by making
      some of its internals more abstract.
    </para>
    <para>
      Here's the customized interface that we can safely use from other
      libraries.
    </para>
    <programlisting language="ocaml">
(* ffi/ncurses.mli  *)
type window
val window : window Ctypes.typ
val initscr : unit -&gt; window
val endwin : unit -&gt; unit
val refresh : unit -&gt; unit
val wrefresh : window -&gt; unit
val newwin : int -&gt; int -&gt; int -&gt; int -&gt; window
val mvwaddch : window -&gt; int -&gt; int -&gt; char -&gt; unit
val addstr : string -&gt; unit
val mvwaddstr : window -&gt; int -&gt; int -&gt; string -&gt; unit
val box : window -&gt; char -&gt; char -&gt; unit
val cbreak : unit -&gt; int
</programlisting>
    <para>
      The <literal>window</literal> type is left abstract in the
      signature to ensure that window pointers can only be constructed
      via the <literal>Ncurses.initscr</literal> function. This prevents
      void pointers obtained from other sources from being mistakenly
      passed to an Ncurses library call.
    </para>
    <para>
      Now compile a &quot;hello world&quot; terminal drawing program to
      tie this all together.
    </para>
    <programlisting language="ocaml">
(* ffi/hello.ml  *)
open Ncurses

let () =
  let main_window = initscr () in
  ignore(cbreak ());
  let small_window = newwin 10 10 5 5 in
  mvwaddstr main_window 1 2 &quot;Hello&quot;;
  mvwaddstr small_window 2 2 &quot;World&quot;;
  box small_window '\000' '\000';
  refresh ();
  Unix.sleep 1;
  wrefresh small_window;
  Unix.sleep 5;
  endwin ()
</programlisting>
    <para>
      The <literal>hello</literal> executable is compiled by linking
      with the <literal>ctypes.foreign</literal> OCamlfind package.
    </para>
    <programlisting>
# running ffi/build_hello.out.sh
$ corebuild -pkg ctypes.foreign -lflags -cclib,-lncurses hello.native 
</programlisting>
    <para>
      Running <literal>./hello.native</literal> should now display a
      Hello World in your terminal!
    </para>
    <note>
    <title>
    On build directives for Ctypes
    </title>
    <para>
      The command-line above include some important extra link
      directives. The <literal>-lflags</literal> instructs
      <literal>ocamlbuild</literal> to pass the next comma-separated set
      of arguments through to the <literal>ocaml</literal> command when
      linking a binary. OCaml in turn uses <literal>-cclib</literal> to
      pass directives through to the system compiler (normally
      <literal>gcc</literal> or <literal>clang</literal>). We first need
      to link to the <literal>ncurses</literal> C library to make the
      symbols available to Ctypes, and
      <literal>-cclib,-lncurses</literal> does that.
    </para>
    <para>
      On some distributions such as Ubuntu, you'll also need to add
      <literal>-cclib,-Xlinker,-cclib,--no-as-needed</literal> to the
      <literal>-lflags</literal> directive. <literal>-Xlinker</literal>
      is interpreted by the compiler as a directive for the system
      linker <literal>ld</literal>, to which it passes
      <literal>--no-as-needed</literal>. Several modern OS distributions
      (such as Ubuntu 11.10 onwards) configure the system linker to only
      link in libraries that directly contain symbols used by the
      program. However, when we use Ctypes, those symbols are not
      referenced until runtime, which results an exception due to the
      library not being available.
    </para>
    <para>
      The <literal>--no-as-needed</literal> flag disables this behavior
      and ensures all the specified libraries are linked despite not
      being directly used. The flag unfortunately doesn't work
      everywhere (notably, MacOS X should <emphasis>not</emphasis> have
      this passed to it).
    </para>
    </note>
    <para>
      Ctypes wouldn't be very useful if it were limited to only defining
      simple C types of course. It provides full support for C pointer
      arithmetic, pointer conversions, reading and writing through
      pointers, using OCaml functions as function pointers to C code, as
      well as struct and union definitions.
    </para>
    <para>
      We'll go over some of these features in more detail for the
      remainder of the chapter by using some POSIX date functions as
      running examples.
    </para>
  </sect1>
  <sect1 id="basic-scalar-c-types">
    <title>Basic scalar C types</title>
    <para>
      First, let's look at how to define basic scalar C types. Every C
      type is represented by an OCaml equivalent via the single type
      definition below.
    </para>
    <programlisting language="ocaml">
(* ctypes/ctypes.mli  *)
type 'a typ
</programlisting>
    <para>
      <literal>Ctypes.typ</literal> is the type of values that
      represents C types to OCaml. There are two types associated with
      each instance of <literal>typ</literal>:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          the C type used to store and pass values to the foreign
          library.
        </para>
      </listitem>
      <listitem>
        <para>
          the corresponding OCaml type. The <literal>'a</literal> type
          parameter contains the OCaml type such that a value of type
          <literal>t typ</literal> is used to read and write OCaml
          values of type <literal>t</literal>.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      There are various other uses of <literal>typ</literal> values
      within Ctypes, such as:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          constructing function types for binding native functions.
        </para>
      </listitem>
      <listitem>
        <para>
          constructing pointers for reading and writing locations in
          C-managed storage.
        </para>
      </listitem>
      <listitem>
        <para>
          describing component fields of structures, unions and arrays.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Here are the definitions for most of the standard C99 scalar
      types, including some platform-dependent ones.
    </para>
    <programlisting language="ocaml">
(* ctypes/ctypes.mli (starting from part 1) *)
val void      : unit typ
val char      : char typ
val schar     : int typ
val short     : int typ
val int       : int typ
val long      : long typ
val llong     : llong typ
val nativeint : nativeint typ

val int8_t    : int typ
val int16_t   : int typ
val int32_t   : int32 typ
val int64_t   : int64 typ
val uchar     : uchar typ
val uchar     : uchar typ
val uint8_t   : uint8 typ
val uint16_t  : uint16 typ
val uint32_t  : uint32 typ
val uint64_t  : uint64 typ
val size_t    : size_t typ
val ushort    : ushort typ
val uint      : uint typ
val ulong     : ulong typ
val ullong    : ullong typ

val float     : float typ
val double    : float typ
</programlisting>
    <para>
      These values are all of type <literal>'a typ</literal>, where the
      value name (<emphasis>e.g.</emphasis> <literal>void</literal>)
      tells you the C type and the <literal>'a</literal> component
      (<emphasis>e.g.</emphasis> <literal>unit</literal>) is the OCaml
      representation of that C type. Most of the mappings are
      straightforward, but some of them need a bit more explanation.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Void values appear in OCaml as the <literal>unit</literal>
          type. Using <literal>void</literal> in an argument or result
          type specification produces an OCaml function which accepts or
          returns unit. Dereferencing a pointer to
          <literal>void</literal> is an error, as in C, and will raise
          the <literal>IncompleteType</literal> exception.
        </para>
      </listitem>
      <listitem>
        <para>
          The C <literal>size_t</literal> type is an alias for one of
          the unsigned integer types. The actual size and alignment
          requirements for <literal>size_t</literal> varies between
          platforms. Ctypes provides an OCaml <literal>size_t</literal>
          type that is aliased to the appropriate integer type.
        </para>
      </listitem>
      <listitem>
        <para>
          OCaml only supports double-precision floating-point numbers,
          and so the C <literal>float</literal> and
          <literal>double</literal> functions both map onto the OCaml
          <literal>float</literal> type.
        </para>
      </listitem>
    </itemizedlist>
  </sect1>
  <sect1 id="pointers-and-arrays">
    <title>Pointers and arrays</title>
    <para>
      Pointers are at the heart of C, so they are necessarily part of
      Ctypes, which provides support for pointer arithmetic, pointer
      conversions, reading and writing through pointers, and passing and
      returning pointers to and from functions.
    </para>
    <para>
      We've already seen a simple use of pointers in the Ncurses
      example. Let's start a new example by binding the following POSIX
      functions.
    </para>
    <programlisting language="c">
time_t time(time_t *);
double difftime(time_t, time_t);
char *ctime(const time_t *timep);
</programlisting>
    <para>
      The <literal>time</literal> function returns the current calendar
      time and is a simple start. The first step is to open some of the
      Ctypes modules.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          The <literal>Ctypes</literal> module provides functions for
          describing C types in OCaml.
        </para>
      </listitem>
      <listitem>
        <para>
          The <literal>PosixTypes</literal> module includes some extra
          POSIX-specific types (such as <literal>time_t</literal>).
        </para>
      </listitem>
      <listitem>
        <para>
          The <literal>Foreign</literal> module exposes the
          <literal>foreign</literal> function that makes it possible to
          invoke C functions.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We can now create a binding to <literal>time</literal> directly
      from the top-level.
    </para>
    <programlisting language="ocaml">
# script ffi/posix.topscript
$ utop
# #require &quot;ctypes.foreign&quot; ;; 

/home/rwo/.opam/4.01.0dev+trunk/lib/ctypes: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/ctypes/ctypes.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/ctypes/ctypes-foreign.cma: loaded
# open Ctypes ;; 
# open PosixTypes ;; 
# open Foreign ;; 
# let time = foreign &quot;time&quot; (ptr time_t @-&gt; returning time_t) ;; 
val time : time_t ptr -&gt; time_t = &lt;fun&gt;
</programlisting>
    <para>
      The <literal>foreign</literal> function is the main link between
      OCaml and C. It takes two arguments: the name of the C function to
      bind, and a value describing the type of the bound function. In
      the <literal>time</literal> binding, the function type specifies
      one argument of type <literal>ptr time_t</literal> and a return
      type of <literal>time_t</literal>.
    </para>
    <para>
      We can now call <literal>time</literal> immediately in the same
      top-level. The argument is actually optional, so we'll just pass a
      null pointer that has been coerced into becoming a null pointer to
      <literal>time_t</literal>.
    </para>
    <programlisting language="ocaml">
...part 1 of ffi/posix.topscript
# let cur_time = time (from_voidp time_t null) ;; 
val cur_time : time_t = &lt;abstr&gt;
</programlisting>
    <para>
      Since we're going to call <literal>time</literal> a few times,
      let's create a wrapper function that passes the null pointer
      through.
    </para>
    <programlisting language="ocaml">
...part 2 of ffi/posix.topscript
# let time' () = time (from_voidp time_t null) ;; 
val time' : unit -&gt; time_t = &lt;fun&gt;
</programlisting>
    <para>
      Since <literal>time_t</literal> is an abstract type, we can't
      actually do anything useful with it directly. We need to bind a
      second function to do anything useful with the return values from
      <literal>time</literal>. We'll move on to
      <literal>difftime</literal>; the second C function in our
      prototype list above.
    </para>
    <programlisting language="ocaml">
...part 3 of ffi/posix.topscript
# let difftime =
    foreign &quot;difftime&quot; (time_t @-&gt; time_t @-&gt; returning double) ;; 
val difftime : time_t -&gt; time_t -&gt; float = &lt;fun&gt;
# let t1 =
    time' () in
    Unix.sleep 2;
    let t2 = time' () in 
    difftime t2 t1 ;; 
- : float = 2.
</programlisting>
    <para>
      The binding to <literal>difftime</literal> above is sufficient to
      compare two <literal>time_t</literal> values.
    </para>
    <sect2 id="allocating-typed-memory-for-pointers">
      <title>Allocating typed memory for pointers</title>
      <para>
        Let's look at a slightly less trivial example where we pass a
        non-null pointer to a function. Continuing with the theme from
        earlier, we'll bind to the <literal>ctime</literal> function
        which converts a <literal>time_t</literal> value to a
        human-readable string.
      </para>
      <programlisting language="ocaml">
...part 4 of ffi/posix.topscript
# let ctime = foreign &quot;ctime&quot; (ptr time_t @-&gt; returning string) ;; 
val ctime : time_t ptr -&gt; string = &lt;fun&gt;
</programlisting>
      <para>
        The binding is continued in the top-level to add to our growing
        collection. However, we can't just pass the result of
        <literal>time</literal> to <literal>ctime</literal>.
      </para>
      <programlisting language="ocaml">
...part 5 of ffi/posix.topscript
# ctime (time' ()) ;; 
Characters 7-15:
Error: This expression has type time_t but an expression was expected of type
         time_t ptr
</programlisting>
      <para>
        This is because <literal>ctime</literal> needs a pointer to the
        <literal>time_t</literal> rather than passing it by value. We
        thus need to allocate some memory for the
        <literal>time_t</literal> and obtain its memory address.
      </para>
      <programlisting language="ocaml">
...part 6 of ffi/posix.topscript
# let t_ptr = allocate time_t (time' ()) ;; 
val t_ptr : time_t ptr = &lt;abstr&gt;
</programlisting>
      <para>
        The <literal>allocate</literal> function takes the type of the
        memory to be allocated and the initial value, and it returns a
        suitably-typed pointer. We can now call <literal>ctime</literal>
        passing the pointer as an argument:
      </para>
      <programlisting language="ocaml">
...part 7 of ffi/posix.topscript
# ctime t_ptr ;; 
- : string = &quot;Sun Aug 11 22:10:43 2013\n&quot;
</programlisting>
    </sect2>
    <sect2 id="using-views-to-map-complex-values">
      <title>Using views to map complex values</title>
      <para>
        While scalar types typically have a 1:1 representation, other C
        types require extra work to convert them into OCaml. Views
        create new C type descriptions that have special behavior when
        used to read or write C values.
      </para>
      <para>
        We've already used one view in the definition of
        <literal>ctime</literal> earlier. The <literal>string</literal>
        view wraps the C type <literal>char *</literal> (written in
        OCaml as <literal>ptr char</literal>), and converts between the
        C and OCaml string representations each time the value is
        written or read.
      </para>
      <para>
        Here is the type signature of the <literal>Ctypes.view</literal>
        function.
      </para>
      <programlisting language="ocaml">
(* ctypes/ctypes.mli (starting from part 2) *)
val view :
  read:('a -&gt; 'b) -&gt;
  write:('b -&gt; 'a) -&gt;
  'a typ -&gt; 'b typ
</programlisting>
      <para>
        Ctypes has some internal low-level functions conversion
        functions that map between an OCaml <literal>string</literal>
        and a C character buffer by copying the contents into the
        respective data structure. They have the following type
        signature.
      </para>
      <programlisting language="ocaml">
(* ctypes/ctypes.mli (starting from part 3) *)
val string_of_char_ptr : char ptr -&gt; string
val char_ptr_of_string : string -&gt; char ptr
</programlisting>
      <para>
        Given these functions, the definition of the
        <literal>Ctypes.string</literal> value that uses views is quite
        simple.
      </para>
      <programlisting language="ocaml">
(* ctypes/ctypes_impl.ml  *)
let string = 
  view 
    ~read:string_of_char_ptr 
    ~write:char_ptr_of_string 
    (char ptr)
</programlisting>
      <para>
        The type of this <literal>string</literal> function is a normal
        <literal>typ</literal> with no external sign of the use of the
        view function.
      </para>
      <programlisting language="ocaml">
(* ctypes/ctypes.mli (starting from part 4) *)
val string    : string.typ
</programlisting>
      <note>
      <title>
      OCaml strings versus C character buffers
      </title>
      <para>
        Although OCaml strings may look like C character buffers from an
        interface perspective, they're very different in terms of their
        memory representations.
      </para>
      <para>
        OCaml strings are stored in the OCaml heap with a header that
        explicitly defines their length. C buffers are also
        fixed-length, but by convention a C string is terminated by a
        null (a <literal>\0</literal> byte) character. The C string
        functions calculate their length by scanning the buffer until
        the first null character is encountered.
      </para>
      <para>
        This means you need to be careful when passing OCaml strings to
        C buffers that don't contain any null values within the OCaml
        string, or else the C string will be truncated at the first null
        instance. Ctypes also defaults to a <emphasis>copying</emphasis>
        interface for strings, which means that you shouldn't use them
        when you want the library to mutate the buffer in-place. In that
        situation, use the Ctypes <literal>Bigarray</literal> support to
        pass memory by reference instead.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="structs-and-unions">
    <title>Structs and unions</title>
    <para>
      The C constructs <literal>struct</literal> and
      <literal>union</literal> make it possible to build new types from
      existing types. Ctypes contains counterparts that work similarly.
    </para>
    <sect2 id="defining-a-structure">
      <title>Defining a structure</title>
      <para>
        Let's improve the timer function that we wrote earlier. The
        POSIX function <literal>gettimeofday</literal> retrieves the
        time with microsecond resolution. The signature of
        <literal>gettimeofday</literal> is as follows, including the
        structure definitions.
      </para>
      <programlisting language="c">
struct timeval {
  long tv_sec;
  long tv_usec;
};

int gettimeofday(struct timeval *, struct timezone *tv);
</programlisting>
      <para>
        Using Ctypes, we can describe this type as follows in our
        top-level, continuing on from the previous definitions.
      </para>
      <programlisting language="ocaml">
...part 8 of ffi/posix.topscript
# type timeval ;; 
type timeval
# let timeval : timeval structure typ = structure &quot;timeval&quot; ;; 
val timeval : timeval structure typ = &lt;abstr&gt;
</programlisting>
      <para>
        The first command defines a new OCaml type
        <literal>timeval</literal> that we'll use to instantiate the
        OCaml version of the <literal>struct</literal>. Creating a new
        OCaml type to reflect the underlying C type in this way means
        that the structure we define will be distinct from other
        structures we define elsewhere, which helps to avoid getting
        them mixed up.
      </para>
      <para>
        The second command calls <literal>structure</literal> to create
        a fresh structure type. At this point the structure type is
        incomplete: we can add fields but cannot yet use it in
        <literal>foreign</literal> calls or use it to create values.
      </para>
    </sect2>
    <sect2 id="adding-fields-to-structures">
      <title>Adding fields to structures</title>
      <para>
        The <literal>timeval</literal> structure definition still
        doesn't have any fields, so we need to add those next.
      </para>
      <programlisting language="ocaml">
...part 9 of ffi/posix.topscript
# let tv_sec  = timeval *:* long ;; 
val tv_sec : (Signed.long, timeval structure) field = &lt;abstr&gt;
# let tv_usec = timeval *:* long ;; 
val tv_usec : (Signed.long, timeval structure) field = &lt;abstr&gt;
# seal timeval ;; 
- : unit = ()
</programlisting>
      <para>
        The <literal>*:*</literal> operator appends a field to the
        structure, as shown with <literal>tv_sec</literal> and
        <literal>tv_usec</literal> above. Structure fields are typed
        accessors that are associated with a particular structure, and
        they correspond to the labels in C. Note that there's no
        explicit requirement that the OCaml variable names for a field
        are the same as the corresponding C struct label names, but it
        helps avoid confusion.
      </para>
      <para>
        Every field addition mutates the structure variable and records
        a new size (the exact value of which depends on the type of the
        field that was just added). Once we <literal>seal</literal> the
        structure we will be able to create values using it, but adding
        fields to a sealed structure is an error.
      </para>
    </sect2>
    <sect2 id="incomplete-structure-definitions">
      <title>Incomplete structure definitions</title>
      <para>
        Since <literal>gettimeofday</literal> needs a
        <literal>struct timezone</literal> pointer for its second
        argument, we also need to define a second structure type.
      </para>
      <programlisting language="ocaml">
...part 10 of ffi/posix.topscript
# type timezone ;; 
type timezone
# let timezone : timezone structure typ = structure &quot;timezone&quot; ;; 
val timezone : timezone structure typ = &lt;abstr&gt;
</programlisting>
      <para>
        We don't ever need to create <literal>struct timezone</literal>
        values, so we can leave this struct as incomplete without adding
        any fields or sealing it. If you ever try to use it in a
        situation where its concrete size needs to be known, the library
        will raise an <literal>IncompleteType</literal> exception.
      </para>
      <para>
        We're finally ready to bind to <literal>gettimeofday</literal>
        now.
      </para>
      <programlisting language="ocaml">
...part 11 of ffi/posix.topscript
# let gettimeofday = foreign &quot;gettimeofday&quot;
    (ptr timeval @-&gt; ptr timezone @-&gt; returning_checking_errno int) ;; 
val gettimeofday : timeval structure ptr -&gt; timezone structure ptr -&gt; int =
  &lt;fun&gt;
</programlisting>
      <para>
        There's one other new feature here: the
        <literal>returning_checking_errno</literal> function behaves
        like <literal>returning</literal>, except that it checks whether
        the bound C function modifies the C error flag. Changes to
        <literal>errno</literal> are mapped into OCaml exceptions and
        raise a <literal>Unix.Unix_error</literal> exception just as the
        standard library functions do.
      </para>
      <para>
        As before we can create a wrapper to make
        <literal>gettimeofday</literal> easier to use. The functions
        <literal>make</literal>, <literal>addr</literal> and
        <literal>getf</literal> create a structure value, retrieve the
        address of a structure value, and retrieve the value of a field
        from a structure.
      </para>
      <programlisting language="ocaml">
...part 12 of ffi/posix.topscript
# let gettimeofday' () =
  let tv = make timeval in
  ignore(gettimeofday (addr tv) (from_voidp timezone null));
  let secs = Signed.Long.(to_int (getf tv tv_sec)) in
  let usecs = Signed.Long.(to_int (getf tv tv_usec)) in
  Pervasives.(float secs +. float usecs /. 1000000.0) ;; 
val gettimeofday' : unit -&gt; float = &lt;fun&gt;
# gettimeofday' () ;; 
- : float = 1376255444.09
</programlisting>
      <para>
        You need to be a little careful not to get all the open modules
        mixed up here. Both <literal>Pervasives</literal> and
        <literal>Ctypes</literal> define different
        <literal>float</literal> functions. The
        <literal>Ctypes</literal> module we opened up earlier overrides
        the <literal>Pervasives</literal> definition. As seen above
        though, you just need to locally open
        <literal>Pervasives</literal> again to bring the usual
        <literal>float</literal> function back in scope,
      </para>
      <sect3 id="recap-a-time-printing-command">
        <title>Recap: a time-printing command</title>
        <para>
          We built up a lot of bindings in the earlier section, so let's
          recap them with a complete example that ties it together with
          a command-line frontend.
        </para>
        <programlisting language="ocaml">
(* ffi/datetime.ml  *)
open Core.Std
open Ctypes
open PosixTypes
open Foreign

let time     = foreign &quot;time&quot; (ptr time_t @-&gt; returning time_t)
let difftime = foreign &quot;difftime&quot; (time_t @-&gt; time_t @-&gt; returning double)
let ctime    = foreign &quot;ctime&quot; (ptr time_t @-&gt; returning string)

type timeval
let timeval : timeval structure typ = structure &quot;timeval&quot;
let tv_sec   = timeval *:* long 
let tv_usec  = timeval *:* long 
let ()       = seal timeval

type timezone
let timezone : timezone structure typ = structure &quot;timezone&quot;

let gettimeofday = foreign &quot;gettimeofday&quot;
    (ptr timeval @-&gt; ptr timezone @-&gt; returning_checking_errno int)

let time' () = time (from_voidp time_t null)

let gettimeofday' () =
  let tv = make timeval in
  ignore(gettimeofday (addr tv) (from_voidp timezone null));
  let secs = Signed.Long.(to_int (getf tv tv_sec)) in
  let usecs = Signed.Long.(to_int (getf tv tv_usec)) in
  Pervasives.(float secs +. float usecs /. 1_000_000.)

let float_time () = printf &quot;%f%!\n&quot; (gettimeofday' ())

let ascii_time () =
  let t_ptr = allocate time_t (time' ()) in
  printf &quot;%s%!&quot; (ctime t_ptr)

let () =
  let open Command in
  basic ~summary:&quot;Display the current time in various formats&quot;
    Spec.(empty +&gt; flag &quot;-a&quot; no_arg ~doc:&quot; Human-readable output format&quot;)
    (fun human -&gt; if human then ascii_time else float_time)
  |&gt; Command.run
</programlisting>
        <para>
          This can be compiled and run in the usual way.
        </para>
        <programlisting language="ocaml">
(* ffi/build_datetime.out  *)
$ corebuild -pkg ctypes.foreign datetime.native
$ ./datetime.native
1376254883.481972
$ ./datetime.native -a
Sun Aug 11 22:01:23 2013
</programlisting>
        <sidebar>
        <title>
        Why do we need to use <literal>returning</literal>?
        </title>
        <para>
          The alert reader may be curious why all these function
          definitions have to be terminated by
          <literal>returning</literal>.
        </para>
        <programlisting language="ocaml">
(* ffi/return_frag.ml  *)
(* correct types *)
val time: ptr time_t @-&gt; returning time_t
val difftime: time_t @-&gt; time_t @-&gt; returning double
</programlisting>
        <para>
          The <literal>returning</literal> function may appear
          superfluous here. Why couldn't we simply give the types as
          follows?
        </para>
        <programlisting language="ocaml">
(* ffi/return_frag.ml (starting from part 1) *)
(* incorrect types *)
val time: ptr time_t @-&gt; time_t
val difftime: time_t @-&gt; time_t @-&gt; double
</programlisting>
        <para>
          The reason involves higher types and two differences between
          the way that functions are treated in OCaml and C. Functions
          are first-class values in OCaml, but not in C. For example, in
          C, it is possible to return a function pointer from a
          function, but not to return an actual function.
        </para>
        <para>
          Secondly, OCaml functions are typically defined in a curried
          style. The signature of a two-argument function is written as
          follows:
        </para>
        <programlisting language="ocaml">
(* ffi/return_frag.ml (starting from part 2) *)
val curried : int -&gt; int -&gt; int
</programlisting>
        <para>
          but this really means
        </para>
        <programlisting language="ocaml">
(* ffi/return_frag.ml (starting from part 3) *)
val curried : int -&gt; (int -&gt; int)
</programlisting>
        <para>
          and the arguments can be supplied one at a time to create a
          closure. In contrast, C functions receive their arguments all
          at once. The equivalent C function type is the following:
        </para>
        <programlisting language="c">
int uncurried_C(int, int);
</programlisting>
        <para>
          and the arguments must always be supplied together:
        </para>
        <programlisting language="c">
uncurried_C(3, 4);
</programlisting>
        <para>
          A C function that's written in curried style looks very
          different:
        </para>
        <programlisting language="c">
/* A function that accepts an int, and returns a function
   pointer that accepts a second int and returns an int. */
typedef int (function_t)(int);
function_t *curried_C(int);

/* supply both arguments */
curried_C(3)(4);

/* supply one argument at a time */
function_t *f = curried_C(3); f(4);
</programlisting>
        <para>
          The OCaml type of <literal>uncurried_C</literal> when bound by
          Ctypes is <literal>int -&gt; int -&gt; int</literal>: a
          two-argument function. The OCaml type of
          <literal>curried_C</literal> when bound by
          <literal>ctypes</literal> is
          <literal>int -&gt; (int -&gt; int)</literal>: a one-argument
          function that returns a one-argument function.
        </para>
        <para>
          In OCaml, of course, these types are absolutely equivalent.
          Since the OCaml types are the same but the C semantics are
          quite different, we need some kind of marker to distinguish
          the cases. This is the purpose of <literal>returning</literal>
          in function definitions.
        </para>
        </sidebar>
      </sect3>
    </sect2>
    <sect2 id="defining-arrays">
      <title>Defining arrays</title>
      <para>
        Arrays in C are contiguous blocks of the same value. Any of the
        basic types defined earlier can be allocated as blocks via the
        <literal>Array</literal> module.
      </para>
      <programlisting language="ocaml">
(* ctypes/ctypes.mli (starting from part 5) *)
module Array : sig
  type 'a t = 'a array

  val get : 'a t -&gt; int -&gt; 'a
  val set : 'a t -&gt; int -&gt; 'a -&gt; unit
  val of_list : 'a typ -&gt; 'a list -&gt; 'a t
  val to_list : 'a t -&gt; 'a list
  val length : 'a t -&gt; int
  val start : 'a t -&gt; 'a ptr
  val from_ptr : 'a ptr -&gt; int -&gt; 'a t
  val make : 'a typ -&gt; ?initial:'a -&gt; int -&gt; 'a t
end
</programlisting>
      <para>
        The array functions are similar to the standard library
        <literal>Array</literal> module except that they represent flat
        C arrays instead of OCaml ones.
      </para>
      <para>
        The conversion between arrays and lists still requires copying
        the values, and can be expensive for large data structures.
        Notice that you can also convert an array into a
        <literal>ptr</literal> pointer to the head of buffer, which can
        be useful if you need to pass the pointer and size arguments
        separately to a C function.
      </para>
      <para>
        Unions in C are named structures that can be mapped onto the
        same underlying memory. They are also fully supported in Ctypes,
        but we won't go into more detail here.
      </para>
      <sidebar>
      <title>
      Pointer operators for dereferencing and arithmetic
      </title>
      <para>
        Ctypes defines a number of operators that let you manipulate
        pointers and arrays just as you would in C. The Ctypes
        equivalents do have the benefit of being more strongly typed, of
        course.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left"/>
          <colspec align="left"/>
          <thead>
            <row>
              <entry>
                Operator
              </entry>
              <entry>
                Purpose
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <literal>!@ p</literal>
              </entry>
              <entry>
                Dereference the pointer <literal>p</literal>.
              </entry>
            </row>
            <row>
              <entry>
                <literal>p &lt;-@ v</literal>
              </entry>
              <entry>
                Write the value <literal>v</literal> to the address
                <literal>p</literal>.
              </entry>
            </row>
            <row>
              <entry>
                <literal>p +@ n</literal>
              </entry>
              <entry>
                If <literal>p</literal> points to an array element, then
                compute the address of the <literal>n</literal>th next
                element.
              </entry>
            </row>
            <row>
              <entry>
                <literal>p -@ n</literal>
              </entry>
              <entry>
                If <literal>p</literal> points to an array element, then
                compute the address of the <literal>n</literal>th
                previous element.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        There are also other useful non-operator functions available
        (see the Ctypes documentation), for example for pointer
        differencing and comparison.
      </para>
      </sidebar>
    </sect2>
  </sect1>
  <sect1 id="passing-functions-to-c">
    <title>Passing functions to C</title>
    <para>
      It's also straightforward to pass OCaml function values to C. The
      C standard library function <literal>qsort</literal> has the
      following signature that requires a function pointer to use.
    </para>
    <programlisting language="c">
void qsort(void *base, size_t nmemb, size_t size,
           int(*compar)(const void *, const void *));
</programlisting>
    <para>
      C programmers often use <literal>typedef</literal> to make type
      definitions involving function pointers easier to read. Using a
      typedef, the type of <literal>qsort</literal> looks a little more
      palatable.
    </para>
    <programlisting language="c">
typedef int(compare_t)(const void *, const void *);

void qsort(void *base, size_t nmemb, size_t size, compare_t *);
</programlisting>
    <para>
      This also happens to be a close mapping to the corresponding
      Ctypes definition. Since type descriptions are regular values, we
      can just use <literal>let</literal> in place of
      <literal>typedef</literal> and end up with working OCaml bindings
      to <literal>qsort</literal>.
    </para>
    <programlisting language="ocaml">
# script ffi/qsort.topscript
$ utop
# #require &quot;ctypes.foreign&quot; ;; 

/home/rwo/.opam/4.01.0dev+trunk/lib/ctypes: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/ctypes/ctypes.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/ctypes/ctypes-foreign.cma: loaded
# open Ctypes ;; 
# open PosixTypes ;; 
# open Foreign ;; 
# let compare_t = ptr void @-&gt; ptr void @-&gt; returning int ;; 
val compare_t : (unit ptr -&gt; unit ptr -&gt; int) fn = &lt;abstr&gt;
# let qsort = foreign &quot;qsort&quot;
   (ptr void @-&gt; size_t @-&gt; size_t @-&gt;
    funptr compare_t @-&gt; returning void) ;; 
val qsort :
  unit ptr -&gt; size_t -&gt; size_t -&gt; (unit ptr -&gt; unit ptr -&gt; int) -&gt; unit =
  &lt;fun&gt;
</programlisting>
    <para>
      We only use <literal>compare_t</literal> once (in the
      <literal>qsort</literal> definition), so you can choose to inline
      it in the OCaml code if you prefer. The resulting
      <literal>qsort</literal> value is a higher-order function, as
      shown by its type. As before, let's define a wrapper function to
      make <literal>qsort</literal> easier to use. The second and third
      arguments to <literal>qsort</literal> specify the length (number
      of elements) of the array and the element size.
    </para>
    <para>
      Arrays created using Ctypes have a richer runtime structure than C
      arrays, so we don't need to pass size information around.
      Furthermore, we can use OCaml polymorphism in place of the unsafe
      <literal>void ptr</literal> type.
    </para>
    <sect2 id="example-a-command-line-quicksort">
      <title>Example: a command-line quicksort</title>
      <para>
        Below is a command-line tool that uses the
        <literal>qsort</literal> binding to sort all of the integers
        supplied on the standard input.
      </para>
      <programlisting language="ocaml">
(* ffi/qsort.ml  *)
open Core.Std
open Ctypes
open PosixTypes
open Foreign

let compare_t = ptr void @-&gt; ptr void @-&gt; returning int

let qsort = foreign &quot;qsort&quot;
    (ptr void @-&gt; size_t @-&gt; size_t @-&gt; funptr compare_t @-&gt; 
       returning void)

let qsort' cmp arr =
  let open Unsigned.Size_t in
  let ty = Array.element_type arr in
  let len = of_int (Array.length arr) in
  let elsize = of_int (sizeof ty) in
  let start = to_voidp (Array.start arr) in
  let compare l r = cmp (!@ (from_voidp ty l)) (!@ (from_voidp ty r)) in
  qsort start len elsize compare;
  arr

let sort_stdin () =
  In_channel.input_lines stdin
  |&gt; List.map ~f:int_of_string
  |&gt; Array.of_list int
  |&gt; qsort' Int.compare
  |&gt; Array.to_list
  |&gt; List.iter ~f:(fun a -&gt; printf &quot;%d\n&quot; a)

let () =
  Command.basic ~summary:&quot;Sort integers on standard input&quot;
    Command.Spec.empty sort_stdin
  |&gt; Command.run
</programlisting>
      <para>
        Compile it in the usual way with corebuild and test it against
        some input data, and also build the inferred interface so we can
        examine it more closely.
      </para>
      <programlisting>
# running ffi/build_qsort.out.sh
$ corebuild -pkg ctypes.foreign qsort.native
$ cat input.txt
5
3
2
1
4
$ ./qsort.native &lt; input.txt
1
2
3
4
5
$ corebuild -pkg ctypes.foreign qsort.inferred.mli
$ cp _build/qsort.inferred.mli qsort.mli
</programlisting>
      <para>
        The inferred interface shows us the types of the raw
        <literal>qsort</literal> binding and also the
        <literal>qsort'</literal> wrapper function.
      </para>
      <programlisting language="ocaml">
(* ffi/qsort.mli  *)
val compare_t : (unit Ctypes.ptr -&gt; unit Ctypes.ptr -&gt; int) Ctypes.fn
val qsort :
  unit Ctypes.ptr -&gt;
  PosixTypes.size_t -&gt;
  PosixTypes.size_t -&gt; (unit Ctypes.ptr -&gt; unit Ctypes.ptr -&gt; int) -&gt; unit
val qsort' : ('a -&gt; 'a -&gt; int) -&gt; 'a Ctypes.array -&gt; 'a Ctypes.array
val sort_stdin : unit -&gt; unit
</programlisting>
      <para>
        The <literal>qsort'</literal> wrapper function has a much more
        canonical OCaml interface than the raw binding. It accepts a
        comparator function and a Ctypes array, and returns the same
        Ctypes array. It's not strictly required that it returns the
        array since it modifies it in-place, but it makes it easier to
        chain the function using the <literal>|&gt;</literal> operator
        (as <literal>sort_stdin</literal> does in the example).
      </para>
      <para>
        Using <literal>qsort'</literal> to sort arrays is
        straightforward. Our example code reads the standard input as a
        list, converts it to a C array, passes it through qsort, and
        outputs the result to the standard output. Again, remember to
        not confuse the <literal>Ctypes.Array</literal> module with the
        <literal>Core.Std.Array</literal> module: the former is in scope
        since we opened <literal>Ctypes</literal> at the start of the
        file.
      </para>
      <note>
      <title>
      Lifetime of allocated Ctypes
      </title>
      <para>
        Values allocated via Ctypes (<emphasis>i.e.</emphasis> using
        <literal>allocate</literal>, <literal>Array.make</literal> and
        so on) will not be garbage-collected as long as they are
        reachable from OCaml values. The system memory they occupy is
        freed when they do become unreachable, via a finalizer function
        registered with the GC.
      </para>
      <para>
        The definition of reachability for Ctypes values is a little
        different from conventional OCaml values though. The allocation
        functions return an OCaml-managed pointer to the value, and as
        long as some derivative pointer is still reachable by the GC,
        the value won't be collected.
      </para>
      <para>
        &quot;Derivative&quot; means a pointer that's computed from the
        original pointer via arithmetic, so a reachable reference to an
        array element or a structure field protects the whole object
        from collection.
      </para>
      <para>
        A corollary of the above rule is that pointers written into the
        C heap don't have any effect on reachability. For example, if
        you have a C-managed array of pointers to structs then you'll
        need some additional way of keeping the structs around to
        protect them from collection. You could achieve this via a
        global array of values on the OCaml side that would keep them
        live until they're no longer needed.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="learning-more-about-c-bindings">
    <title>Learning more about C bindings</title>
    <para>
      The Ctypes
      <ulink url="http://github.com/ocamllabs/ocaml-ctypes">distribution</ulink>
      contains a number of larger-scale examples, including:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          bindings to the POSIX <literal>fts</literal> API which
          demonstrates C callbacks more comprehensively.
        </para>
      </listitem>
      <listitem>
        <para>
          a more complete Ncurses binding than the example we opened the
          chapter with.
        </para>
      </listitem>
      <listitem>
        <para>
          a comprehensive test suite that covers the complete library,
          and can provide useful snippets for your own bindings.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      This chapter hasn't really needed you to understand the innards of
      OCaml at all. Ctypes does its best to make function bindings easy,
      but the rest of this part will also fill you in about how
      interactions with OCaml memory layout and the garbage collector
      work.
    </para>
    <note>
    <title>
    Production note
    </title>
    <para>
      This chapter contains significant contributions from Jeremy
      Yallop.
    </para>
    </note>
  </sect1>
</chapter><chapter id="memory-representation-of-values">
  <title>Memory Representation of Values</title>
  <para>
    The FFI interface we described in
    <xref linkend="foreign-function-interface"/> hides the
    precise details of how values are exchanged across C libraries and
    the OCaml runtime. There is a simple reason for this: using this
    interface directly is a delicate operation that requires
    understanding a few different moving parts before you can get it
    right. You first need to know the mapping between OCaml types and
    their runtime memory representation. You also need to ensure that
    your code is interfacing correctly with OCaml runtime's memory
    management.
  </para>
  <para>
    However, knowledge of the OCaml internals is useful beyond just
    writing foreign function interfaces. As you build and maintain more
    complex OCaml applications, you'll need to interface with various
    external system tools that operate on compiled OCaml binaries. For
    example, profiling tools report output based on the runtime memory
    layout and debuggers execute binaries without any knowledge of the
    static OCaml types. To use these tools effectively, you'll need to
    do some translation between the OCaml and C worlds.
  </para>
  <para>
    Luckily, the OCaml toolchain is very predictable. The compiler
    minimizes the amount of optimization magic that it performs, and
    relies instead on its straightforward execution model for good
    performance. With some experience, you can know rather precisely
    where a block of performance-critical OCaml code is spending its
    time.
  </para>
  <note>
  <title>
  Why do OCaml types disappear at runtime?
  </title>
  <para>
    The OCaml compiler runs through several phases during the
    compilation process. The first phase is syntax checking, during
    which source files are parsed into Abstract Syntax Trees (ASTs). The
    next stage is a <emphasis>type checking</emphasis> pass over the
    AST. In a validly typed program, a function cannot be applied with
    an unexpected type. For example, the
    <literal>print_endline</literal> function must receive a single
    <literal>string</literal> argument, and an <literal>int</literal>
    will result in a type error.
  </para>
  <para>
    Since OCaml verifies these properties at compile time, it doesn't
    need to keep track of as much information at runtime. Thus, later
    stages of the compiler can discard and simplify the type
    declarations to a much more minimal subset that's actually required
    to distinguish polymorphic values at runtime. This is a major
    performance win versus something like a Java or .NET method call,
    where the runtime must look up the concrete instance of the object
    and dispatch the method call. Those languages amortize some of the
    cost via &quot;Just-in-Time&quot; dynamic patching, but OCaml
    prefers runtime simplicity instead.
  </para>
  <para>
    We'll explain this compilation pipeline in more detail in
    <xref linkend="the-compiler-frontend-parsing-and-type-checking"/>
    and
    <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.
  </para>
  </note>
  <para>
    This chapter covers the precise mapping from OCaml types to runtime
    values and walks you through them via the toplevel. We'll cover how
    these values are managed by the runtime later on in
    <xref linkend="understanding-the-garbage-collector"/>.
  </para>
  <sect1 id="ocaml-blocks-and-values">
    <title>OCaml blocks and values</title>
    <para>
      A running OCaml program uses blocks of memory
      (<emphasis>i.e.</emphasis> contiguous sequences of words in RAM)
      to represent values such as tuples, records, closures or arrays.
      An OCaml program implicitly allocates a block of memory when such
      a value is created.
    </para>
    <programlisting language="ocaml">
# script memory-repr/simple_record.topscript
$ utop
# type t = { foo: int; bar: int } ;; 
type t = { foo : int; bar : int; }
# let x = { foo = 13; bar = 14 } ;; 
val x : t = {foo = 13; bar = 14}
</programlisting>
    <para>
      The type declaration <literal>t</literal> doesn't take up any
      memory at runtime, but the subsequent <literal>let</literal>
      binding allocates a new block of memory with two words of
      available space. One word holds the <literal>foo</literal> field
      and the other word holds the <literal>bar</literal> field. The
      OCaml compiler translates such an expression into an explicit
      allocation for the block from OCaml's runtime system.
    </para>
    <para>
      OCaml uses a uniform memory representation in which every OCaml
      variable is stored as a <emphasis>value</emphasis>. An OCaml value
      is a single memory word that is either an immediate integer or a
      pointer to some other memory. The OCaml runtime tracks all values
      so that it can free them when they are no longer needed. It thus
      needs to be able to distinguish between integer and pointer
      values, since it scans pointers to find further values but doesn't
      follow integers that don't point to anything meaningful beyond
      their immediate value.
    </para>
    <sect2 id="distinguishing-integer-and-pointers-at-runtime">
      <title>Distinguishing integer and pointers at runtime</title>
      <para>
        Wrapping primitives types (such as integers) inside another data
        structure that records extra metadata about the value is known
        as <emphasis>boxing</emphasis>. Values are boxed in order to
        make it easier for the garbage collector to do its job, but at
        the expense of an extra level of indirection to access the data
        within the boxed value.
      </para>
      <para>
        OCaml values don't all have to be boxed at runtime. Instead,
        values use a single tag bit per word to distinguish integers and
        pointers at runtime. The value is an integer if the lowest bit
        of the block word is non-zero, and a pointer if the lowest bit
        of the block word is zero. Several OCaml types map onto this
        integer representation, including <literal>bool</literal>,
        <literal>int</literal>, the empty list, <literal>unit</literal>,
        and variants without constructors.
      </para>
      <para>
        This representations means that integers are unboxed runtime
        values in OCaml so that they can be stored directly without
        having to allocate a wrapper block. They can be passed directly
        to other function calls in registers and are generally the
        cheapest and fastest values to use in OCaml.
      </para>
      <para>
        A value is treated as a memory pointer if its lowest bit is
        zero. A pointer value can still be stored unmodified despite
        this, since pointers are guaranteed to be word-aligned (with the
        bottom bits always being zero).
      </para>
      <para>
        The only problem that remains with this memory representation is
        distinguishing between pointers to OCaml values (which should be
        followed by the garbage collector) and pointers into the system
        heap to C values (which shouldn't be followed).
      </para>
      <para>
        The mechanism for this is simple, since the runtime system keeps
        track of the heap blocks it has allocated for OCaml values. If
        the pointer is inside a heap chunk that is marked as being
        managed by the OCaml runtime, it is assumed to point to an OCaml
        value. If it points outside the OCaml runtime area, it is
        treated as an opaque C pointer to some other system resource.
      </para>
      <note>
      <title>
      Some history about OCaml's word-aligned pointers
      </title>
      <para>
        The alert reader may be wondering how OCaml can guarantee that
        all of its pointers are word-aligned. In the old days when RISC
        chips such as Sparc, MIPS and Alpha were commonplace, unaligned
        memory accesses were forbidden by the instruction set
        architecture and would result in a CPU exception that terminated
        the program. Thus, all pointers were historically rounded off to
        the architecture word-size (usually 32- or 64-bits).
      </para>
      <para>
        Modern CISC processors such as the Intel x86 do support
        unaligned memory accesses, but the chip still runs faster if
        accesses are word-aligned. OCaml therefore simply mandates that
        all pointers be word-aligned, which guarantees that the bottom
        few bits of any valid pointer will be zero. Setting the bottom
        bit to a non-zero value is a simple way to mark an integer, at
        the cost of losing that single bit of precision.
      </para>
      <para>
        An even more alert reader will be wondering about the
        performance implications are for integer arithmetic using this
        tagged representation. Since the bottom bit is set, any
        operation on the integer has to shift the bottom bit right to
        recover the &quot;native&quot; value. The native code OCaml
        compiler generates efficient x86 assembly code in this case,
        taking advantage of modern processor instructions to hide the
        extra shifts where possible. Addition is a single
        <literal>LEA</literal> x86 instruction, subtraction can be two
        instructions, and multiplication is only a few more.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="blocks-and-values">
    <title>Blocks and values</title>
    <para>
      An OCaml <emphasis>block</emphasis> is the basic unit of
      allocation on the heap. A block consists of a one-word header
      (either 32- or 64-bits depending on the CPU architecture) followed
      by variable-length data that is either opaque bytes or an array of
      <emphasis>fields</emphasis>. The header has a multi-purpose tag
      byte that defines whether to interpret the subsequent data as
      opaque bytes or OCaml fields.
    </para>
    <para>
      The garbage collector never inspects opaque bytes. If the tag
      indicates an array of OCaml fields are present, their contents are
      all treated as more valid OCaml values. The garbage collector
      always inspects fields and follows them as part of the collection
      process described earlier.
    </para>
    <programlisting>
+------------------------+---------+----------+----------+----------+----
| size of block in words |  color  | tag byte | value[0] | value[1] | ...
+------------------------+---------+----------+----------+----------+----
 &lt;-either 22 or 54 bits-&gt; &lt;-2 bit-&gt; &lt;--8 bit--&gt;
</programlisting>
    <para>
      The <literal>size</literal> field records the length of the block
      in memory words. This is 22 bits on 32-bit platforms, which is the
      reason why OCaml strings are limited to 16MB on that architecture.
      If you need bigger strings, either switch to a 64-bit host, or use
      the <literal>Bigarray</literal> module.
    </para>
    <para>
      The 2-bit <literal>color</literal> field is used by the garbage
      collector to keep track of its state during mark-and-sweep
      collection. We'll come back to this field in
      <xref linkend="understanding-the-garbage-collector"/>.
      This tag isn't exposed to OCaml source code in any case.
    </para>
    <para>
      A block's tag byte is multi-purpose, and indicates whether the
      data array represents opaque bytes or fields. If a block's tag is
      greater than or equal to <literal>No_scan_tag</literal> (251),
      then the block's data are all opaque bytes, and are not scanned by
      the collector. The most common such block is the
      <literal>string</literal> type, which we describe in more detail
      later in this chapter.
    </para>
    <para>
      The exact representation of values inside a block depends on their
      static OCaml type. All OCaml types are distilled down into
      <literal>values</literal>, and summarized in the table below.
    </para>
    <informaltable>
      <tgroup cols="2">
        <colspec align="left"/>
        <colspec align="left"/>
        <thead>
          <row>
            <entry>
              OCaml Value
            </entry>
            <entry>
              Representation
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <literal>int</literal> or <literal>char</literal>
            </entry>
            <entry>
              directly as a value, shifted left by 1 bit, with the least
              significant bit set to 1
            </entry>
          </row>
          <row>
            <entry>
              <literal>unit</literal>, <literal>[]</literal>,
              <literal>false</literal>
            </entry>
            <entry>
              as OCaml <literal>int</literal> 0.
            </entry>
          </row>
          <row>
            <entry>
              <literal>true</literal>
            </entry>
            <entry>
              as OCaml <literal>int</literal> 1.
            </entry>
          </row>
          <row>
            <entry>
              <literal>Foo | Bar</literal>
            </entry>
            <entry>
              as ascending OCaml <literal>int</literal>s, starting from
              0.
            </entry>
          </row>
          <row>
            <entry>
              <literal>Foo | Bar of int</literal>
            </entry>
            <entry>
              variants with parameters are boxed, while variants with no
              parameters are unboxed.
            </entry>
          </row>
          <row>
            <entry>
              polymorphic variants
            </entry>
            <entry>
              variable space usage depending on the number of
              parameters.
            </entry>
          </row>
          <row>
            <entry>
              floating-point number
            </entry>
            <entry>
              as a block with a single field containing the
              double-precision float.
            </entry>
          </row>
          <row>
            <entry>
              string
            </entry>
            <entry>
              word-aligned byte arrays with an explicit length.
            </entry>
          </row>
          <row>
            <entry>
              <literal>[1; 2; 3]</literal>
            </entry>
            <entry>
              as <literal>1::2::3::[]</literal> where
              <literal>[]</literal> is an int, and
              <literal>h::t</literal> a block with tag 0 and two
              parameters.
            </entry>
          </row>
          <row>
            <entry>
              tuples, records and arrays
            </entry>
            <entry>
              an array of values. Arrays can be variable size, but
              structs and tuples are fixed size.
            </entry>
          </row>
          <row>
            <entry>
              records or arrays, all float
            </entry>
            <entry>
              special tag for unboxed arrays of floats, or records that
              only have <literal>float</literal> fields.
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <sect2 id="integers-characters-and-other-basic-types">
      <title>Integers, characters and other basic types</title>
      <para>
        Many basic types are efficiently stored as unboxed integers at
        runtime. The native <literal>int</literal> type is the most
        obvious, although it drops a single bit of precision due to the
        tag bit. Other atomic types such as <literal>unit</literal> and
        empty list <literal>[]</literal> value are stored as constant
        integers. Boolean values have a value of <literal>0</literal>
        and <literal>1</literal> for <literal>true</literal> and
        <literal>false</literal> respectively.
      </para>
      <para>
        These basic types such as empty lists and
        <literal>unit</literal> are very efficient to use since integers
        are never allocated on the heap. They can be passed directly in
        registers and not appear on the stack if you don't have too many
        parameters to your functions. Modern architectures such as
        <literal>x86_64</literal> have a lot of spare registers to
        further improve the efficiency of using unboxed integers.
      </para>
    </sect2>
  </sect1>
  <sect1 id="tuples-records-and-arrays">
    <title>Tuples, records and arrays</title>
    <programlisting>
+---------+----------+----------- - - - -
| header  | value[0] | value[1] | ....
+---------+----------+----------+- - - - -
</programlisting>
    <para>
      Tuples, records and arrays are all represented identically at
      runtime as a block with tag <literal>0</literal>. Tuples and
      records have constant sizes determined at compile-time, whereas
      arrays can be of variable length. While arrays are restricted to
      containing a single type of element in the OCaml type system, this
      is not required by the memory representation.
    </para>
    <para>
      You can check the difference between a block and a direct integer
      yourself using the <literal>Obj</literal> module, which exposes
      the internal representation of values to OCaml code.
    </para>
    <programlisting language="ocaml">
# script memory-repr/reprs.topscript
$ utop
# Obj.is_block (Obj.repr (1,2,3)) ;; 
- : bool = true
# Obj.is_block (Obj.repr 1) ;; 
- : bool = false
</programlisting>
    <para>
      The <literal>Obj.repr</literal> function retrieves the runtime
      representation of any OCaml value. <literal>Obj.is_block</literal>
      checks the bottom bit to determine if the value is a block header
      or an unboxed integer.
    </para>
    <sect2 id="floating-point-numbers-and-arrays">
      <title>Floating point numbers and arrays</title>
      <para>
        Floating point numbers in OCaml are always stored as full
        double-precision values. Individual floating-point values are
        stored as a block with a single field that contains the number.
        This block has the <literal>Double_tag</literal> set which
        signals to the collector that the floating-point value is not to
        be scanned.
      </para>
      <programlisting language="ocaml">
...part 1 of memory-repr/reprs.topscript
# Obj.tag (Obj.repr 1.0) ;; 
- : int = 253
# Obj.double_tag ;; 
- : int = 253
</programlisting>
      <para>
        Since each floating-point value is boxed in a separate memory
        block, it can be inefficient to handle large arrays of floats in
        comparison to unboxed integers. OCaml therefore special-cases
        records or arrays that contain <emphasis>only</emphasis>
        <literal>float</literal> types. These are stored in a block that
        contains the floats packed directly in the data section, with
        the <literal>Double_array_tag</literal> set to signal to the
        collector that the contents are not OCaml values.
      </para>
      <programlisting>
+---------+----------+----------- - - - -
| header  | float[0] | float[1] | ....
+---------+----------+----------+- - - - -
</programlisting>
      <para>
        First, let's check that float arrays do in fact have a different
        tag number from normal floating-point values.
      </para>
      <programlisting language="ocaml">
...part 2 of memory-repr/reprs.topscript
# Obj.double_tag ;; 
- : int = 253
# Obj.double_array_tag ;; 
- : int = 254
</programlisting>
      <para>
        This tells us that float arrays have a tag value of 254. Now
        let's test some sample values using the
        <literal>Obj.tag</literal> function to check that the allocated
        block has the expected runtime tag, and also use
        <literal>Obj.double_field</literal> to retrieve a float from
        within the block.
      </para>
      <programlisting language="ocaml">
...part 3 of memory-repr/reprs.topscript
# Obj.tag (Obj.repr [| 1.0; 2.0; 3.0 |]) ;; 
- : int = 254
# Obj.tag (Obj.repr (1.0, 2.0, 3.0) ) ;; 
- : int = 0
# Obj.double_field (Obj.repr [| 1.1; 2.2; 3.3 |]) 1 ;; 
- : float = 2.2
# Obj.double_field (Obj.repr 1.234) 0 ;; 
- : float = 1.234
</programlisting>
      <para>
        The first thing we tested above was that a float array has the
        correct unboxed float array tag value (254). However, the next
        line tests a tuple of floating point values instead, which are
        <emphasis>not</emphasis> optimized in the same way and have the
        normal tuple tag value (0).
      </para>
      <para>
        Only records and arrays can have the float array optimization,
        and for records every single field must be a float.
      </para>
    </sect2>
  </sect1>
  <sect1 id="variants-and-lists">
    <title>Variants and lists</title>
    <para>
      Basic variant types with no extra parameters for any of their
      branches are simply stored as an OCaml integer, starting with
      <literal>0</literal> for the first option and in ascending order.
    </para>
    <programlisting language="ocaml">
...part 4 of memory-repr/reprs.topscript
# type t = Apple | Orange | Pear ;; 
type t = Apple | Orange | Pear
# ((Obj.magic (Obj.repr Apple)) : int) ;; 
- : int = 0
# ((Obj.magic (Obj.repr Pear)) : int) ;; 
- : int = 2
# Obj.is_block (Obj.repr Apple) ;; 
- : bool = false
</programlisting>
    <para>
      <literal>Obj.magic</literal> unsafely forces a type cast between
      any two OCaml types; in this example the <literal>int</literal>
      type hint retrieves the runtime integer value. The
      <literal>Obj.is_block</literal> confirms that the value isn't a
      more complex block, but just an OCaml <literal>int</literal>.
    </para>
    <para>
      Variants that have parameters arguments are a little more complex.
      They are stored as blocks, with the value
      <emphasis>tags</emphasis> ascending from 0 (counting from leftmost
      variants with parameters). The parameters are stored as words in
      the block.
    </para>
    <programlisting language="ocaml">
...part 5 of memory-repr/reprs.topscript
# type t = Apple | Orange of int | Pear of string | Kiwi ;; 
type t = Apple | Orange of int | Pear of string | Kiwi
# Obj.is_block (Obj.repr (Orange 1234)) ;; 
- : bool = true
# Obj.tag (Obj.repr (Orange 1234)) ;; 
- : int = 0
# Obj.tag (Obj.repr (Pear &quot;xyz&quot;)) ;; 
- : int = 1
# (Obj.magic (Obj.field (Obj.repr (Orange 1234)) 0) : int) ;; 
- : int = 1234
# (Obj.magic (Obj.field (Obj.repr (Pear &quot;xyz&quot;)) 0) : string) ;; 
- : string = &quot;xyz&quot;
</programlisting>
    <para>
      In the above example, the <literal>Apple</literal> and
      <literal>Kiwi</literal> values are still stored as normal OCaml
      integers with values <literal>0</literal> and <literal>1</literal>
      respectively. The <literal>Orange</literal> and
      <literal>Pear</literal> values both have parameters, and are
      stored as blocks whose tags ascend from <literal>0</literal> (and
      so <literal>Pear</literal> has a tag of <literal>1</literal>, as
      the use of <literal>Obj.tag</literal> verifies). Finally, the
      parameters are fields which contain OCaml values within the block,
      and <literal>Obj.field</literal> can be used to retrieve them.
    </para>
    <para>
      Lists are stored with a representation that is exactly the same as
      if the list was written as a variant type with
      <literal>Head</literal> and <literal>Cons</literal>. The empty
      list <literal>[]</literal> is an integer <literal>0</literal>, and
      subsequent blocks have tag <literal>0</literal> and two
      parameters: a block with the current value, and a pointer to the
      rest of the list.
    </para>
    <warning>
    <title>
    <literal>Obj</literal> module considered harmful
    </title>
    <para>
      The <literal>Obj</literal> module is an undocumented module that
      exposes the internals of the OCaml compiler and runtime. It is
      very useful for examining and understanding how your code will
      behave at runtime, but should <emphasis>never</emphasis> be used
      for production code unless you understand the implications. The
      module bypasses the OCaml type system, making memory corruption
      and segmentation faults possible.
    </para>
    <para>
      Some theorem provers such as Coq do output code which uses
      <literal>Obj</literal> internally, but the external module
      signatures never expose it. Unless you too have a machine proof of
      correctness to accompany your use of <literal>Obj</literal>, stay
      away from it except for debugging!
    </para>
    </warning>
    <para>
      Due to this encoding, there is a limit around 240 variants with
      parameters that applies to each type definition, but the only
      limit on the number of variants without parameters is the size of
      the native integer (either 31- or 63-bits). This limit arises
      because of the size of the tag byte, and that some of the high
      numbered tags are reserved.
    </para>
  </sect1>
  <sect1 id="polymorphic-variants-1">
    <title>Polymorphic variants</title>
    <para>
      Polymorphic variants are more flexible than normal variants when
      writing code, but are slightly less efficient at runtime. This is
      because there isn't as much static compile-time information
      available to optimize their memory layout.
    </para>
    <para>
      A polymorphic variant without any parameters is stored as an
      unboxed integer and so only takes up one word of memory, just like
      a normal variant. This integer value is determined by applying a
      hash function to the <emphasis>name</emphasis> of the variant. The
      hash function isn't exposed directly by the compiler, but the
      <literal>type_conv</literal> library from Core provides an
      alternative implementation.
    </para>
    <programlisting language="ocaml">
...part 6 of memory-repr/reprs.topscript
# Pa_type_conv.hash_variant &quot;Foo&quot; ;; 
- : int = 3505894
# (Obj.magic (Obj.repr `Foo) : int) ;; 
- : int = 3505894
</programlisting>
    <para>
      The hash function is designed to give the same results on 32-bit
      and 64-bit architectures, so the memory representation is stable
      across different CPUs and host types.
    </para>
    <para>
      Polymorphic variants use more memory space than normal variants
      when parameters are included in the datatype constructors. Normal
      variants use the tag byte to encode the variant value and save the
      fields for the contents, but this single byte is insufficient to
      encode the hashed value for polymorphic variants. They must
      allocate a new block (with tag <literal>0</literal>) and store the
      value in there instead. Polymorphic variants with constructors
      thus use one word of memory more than normal variant constructors.
    </para>
    <para>
      Another inefficiency over normal variants is when a polymorphic
      variant constructor has more than one parameter. Normal variants
      hold parameters as a single flat block with multiple fields for
      each entry, but polymorphic variants must adopt a more flexible
      uniform memory representation since they may be reused in a
      different context across compilation units. They allocate a tuple
      block for the parameters that is pointed to from the argument
      field of the variant. There are thus three additional words for
      such variants, along with an extra memory indirection due to the
      tuple.
    </para>
    <para>
      The extra space usage is generally not significant in a typical
      application, and polymorphic variants offer a great deal more
      flexibility than normal variants. However, if you're writing code
      that demands high performance or must run within tight memory
      bounds, the runtime layout is at least very predictable. The OCaml
      compiler never switches memory representation due to optimization
      passes. This lets you predict the precise runtime layout by
      referring to these guidelines and your source code.
    </para>
  </sect1>
  <sect1 id="string-values">
    <title>String values</title>
    <para>
      Strings are standard OCaml blocks with the header size defining
      the size of the string in machine words. The
      <literal>String_tag</literal> (252) is higher than the
      <literal>No_scan_tag</literal>, indicating that the contents of
      the block are opaque to the collector. The block contents are the
      contents of the string, with padding bytes to align the block on a
      word boundary.
    </para>
    <programlisting>
+---------------+----------------+--------+-----------+
| header        | 'a' 'b' 'c' 'd' 'e' 'f' | '\O' '\1' |
+---------------+----------------+--------+-----------+
                L data                    L padding
</programlisting>
    <para>
      On a 32-bit machine, the padding is calculated based on the modulo
      of the string length and word size to ensure the result is
      word-aligned. A 64-bit machine extends the potential padding up to
      7 bytes instead of 3.
    </para>
    <informaltable>
      <tgroup cols="2">
        <colspec align="left"/>
        <colspec align="left"/>
        <thead>
          <row>
            <entry>
              String length mod 4
            </entry>
            <entry>
              Padding
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              0
            </entry>
            <entry>
              <literal>00 00 00 03</literal>
            </entry>
          </row>
          <row>
            <entry>
              1
            </entry>
            <entry>
              <literal>00 00 02</literal>
            </entry>
          </row>
          <row>
            <entry>
              2
            </entry>
            <entry>
              <literal>00 01</literal>
            </entry>
          </row>
          <row>
            <entry>
              3
            </entry>
            <entry>
              <literal>00</literal>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      This string representation is a clever way to ensure that the
      contents are always zero-terminated by the padding word, and still
      compute its length efficiently without scanning the whole string.
      The following formula is used:
    </para>
    <programlisting>
number_of_words_in_block * sizeof(word) - last_byte_of_block - 1
</programlisting>
    <para>
      The guaranteed <literal>NULL</literal>-termination comes in handy
      when passing a string to C, but is not relied upon to compute the
      length from OCaml code. OCaml strings can thus contain
      <literal>NULL</literal> bytes at any point within the string.
    </para>
    <para>
      Care should be taken that any C library functions that receive
      these buffers can also cope with arbitrary bytes within the buffer
      contents and are not expecting C strings. For instance, the C
      <literal>memcopy</literal> or <literal>memmove</literal> standard
      library functions can operate on arbitrary data, but
      <literal>strlen</literal> or <literal>strcpy</literal> both
      require a <literal>NULL</literal> terminated buffer and has no
      mechanism for encoding a <literal>NULL</literal> value within its
      contents.
    </para>
  </sect1>
  <sect1 id="custom-heap-blocks">
    <title>Custom heap blocks</title>
    <para>
      OCaml supports <emphasis>custom</emphasis> heap blocks via a
      <literal>Custom_tag</literal> that let the runtime perform
      user-defined operations over OCaml values. A custom block lives in
      the OCaml heap like an ordinary block and can be of whatever size
      the user desires. The <literal>Custom_tag</literal> (255) is
      higher than <literal>No_scan_tag</literal> and so isn't scanned by
      the garbage collector.
    </para>
    <para>
      The first word of the data within the custom block is a C pointer
      to a <literal>struct</literal> of custom operations. The custom
      block cannot have pointers to OCaml blocks and is opaque to the
      garbage collector.
    </para>
    <programlisting language="c">
struct custom_operations {
  char *identifier;
  void (*finalize)(value v);
  int (*compare)(value v1, value v2);
  intnat (*hash)(value v);
  void (*serialize)(value v,
                    /*out*/ uintnat * wsize_32 /*size in bytes*/,
                    /*out*/ uintnat * wsize_64 /*size in bytes*/);
  uintnat (*deserialize)(void * dst);
  int (*compare_ext)(value v1, value v2);
};
</programlisting>
    <para>
      The custom operations specify how the runtime should perform
      polymorphic comparison, hashing and binary marshalling. They also
      optionally contain a <emphasis>finalizer</emphasis> that the
      runtime calls just before the block is garbage collected. This
      finalizer has nothing to do with ordinary OCaml finalizers (as
      created by <literal>Gc.finalize</literal> and explained in
      <xref linkend="understanding-the-garbage-collector"/>).
      They are instead used to call C cleanup functions such as
      <literal>free</literal>.
    </para>
    <sect2 id="managing-external-memory-with-bigarray">
      <title>Managing external memory with Bigarray</title>
      <para>
        A common use of custom blocks is to manage external system
        memory directly from within OCaml. The Bigarray interface was
        originally intended to exchange data with Fortran code, and maps
        a block of system memory as a multi-dimensional array that can
        be accessed from OCaml. Bigarray operations work directly on the
        external memory without requiring it to be copied into the OCaml
        heap (which is a potentially expensive operation for large
        arrays).
      </para>
      <para>
        Bigarray sees a lot of use beyond just scientific computing, and
        several Core libraries use it for general-purpose I/O:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            The <literal>Iobuf</literal> module maps I/O buffers as a
            1-dimensional array of bytes. It provides a sliding window
            interface that lets consumer processes read from the buffer
            while it's being filled by producers. This lets OCaml use
            I/O buffers that have been externally allocated by the
            operating system without any extra data copying.
          </para>
        </listitem>
        <listitem>
          <para>
            The <literal>Bigstring</literal> module provides a
            <literal>String</literal>-like interface that uses
            <literal>Bigarray</literal> internally. The
            <literal>Bigbuffer</literal> collects these into extensible
            string buffers that can operate entirely on external system
            memory.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The
        <ulink url="https://bitbucket.org/mmottl/lacaml">Lacaml</ulink>
        library isn't part of Core, but provides the recommended
        interfaces to the widely used BLAS and LAPACK mathematical
        Fortran libraries. These allow developers to write
        high-performance numerical code for applications that require
        linear algebra. It supports large vectors and matrices, but with
        static typing safety of OCaml to make it easier to write safe
        algorithms.
      </para>
    </sect2>
  </sect1>
</chapter><chapter id="understanding-the-garbage-collector">
  <title>Understanding the Garbage Collector</title>
  <para>
    We've described the runtime format of individual OCaml variables
    earlier in
    <xref linkend="memory-representation-of-values"/>. When
    you execute your program, OCaml manages the lifecycle of these
    variables by regularly scanning allocated values and freeing them
    when they're no longer needed. This in turn means that your
    applications don't need to manually implement memory management and
    greatly reduces the likelihood of memory leaks creeping into your
    code.
  </para>
  <para>
    The OCaml runtime is a C library that provides routines that can be
    called from running OCaml programs. The runtime manages a
    <emphasis>heap</emphasis>, which is a collection of memory regions
    that it obtains from the operating system. The runtime uses this
    memory to hold <emphasis>heap blocks</emphasis> that it fills up
    with OCaml values in response to allocation requests by the OCaml
    program.
  </para>
  <sect1 id="mark-and-sweep-garbage-collection">
    <title>Mark and sweep garbage collection</title>
    <para>
      When there isn't enough memory available to satisfy an allocation
      request from the pool of allocated heap blocks, the runtime system
      invokes the <emphasis>garbage collector</emphasis> (or GC). An
      OCaml program can't explicitly free a value when it is done with
      it. Instead, the GC regularly determines which values are
      <emphasis>live</emphasis> and which values are
      <emphasis>dead</emphasis>, <emphasis>i.e.</emphasis> no longer in
      use. Dead values are collected and their memory made available for
      reuse by the application.
    </para>
    <para>
      The garbage collector doesn't keep constant track of values as
      they are allocated and used. Instead, it regularly scans them by
      starting from a set of <emphasis>root</emphasis> values that the
      application always has access to (such as the stack). The GC
      maintains a directed graph in which heap blocks are nodes, and
      there is an edge from heap block <literal>b1</literal> to heap
      block <literal>b2</literal> if some field of <literal>b1</literal>
      is a pointer to <literal>b2</literal>.
    </para>
    <para>
      All blocks reachable from the roots by following edges in the
      graph must be retained, and unreachable blocks can be reused by
      the application. The algorithm used by OCaml to perform this heap
      traversal is commonly known as <emphasis>mark and sweep</emphasis>
      garbage collection, and we'll explain it further now.
    </para>
  </sect1>
  <sect1 id="generational-garbage-collection">
    <title>Generational garbage collection</title>
    <para>
      The usual OCaml programming style involves allocating many small
      variables that are used for a short period of time and then never
      accessed again. OCaml takes advantage of this fact to improve
      performance by using a <emphasis>generational</emphasis> garbage
      collector.
    </para>
    <para>
      A generational GC maintains separate memory regions to hold blocks
      based on how long the blocks have been live. OCaml's heap is split
      in two such regions:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          a small fixed-size <emphasis>minor heap</emphasis> where most
          blocks are initially allocated.
        </para>
      </listitem>
      <listitem>
        <para>
          a larger variable-sized <emphasis>major heap</emphasis> for
          blocks that have been live longer.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      A typical functional programming style means that young blocks
      tend to die young and old blocks tend to stay around for longer
      than young ones. This is often referred to as the
      <emphasis>generational hypothesis</emphasis>.
    </para>
    <para>
      OCaml uses different memory layouts and garbage collection
      algorithms for the major and minor heaps to account for this
      generational difference. We'll explain how they differ in more
      detail next.
    </para>
    <sidebar>
    <title>
    The <literal>Gc</literal> module and
    <literal>OCAMLRUNPARAM</literal>
    </title>
    <para>
      OCaml provides several mechanisms to query and alter the behavior
      of the runtime system. The <literal>Gc</literal> module provides
      this functionality from within OCaml code, and we'll frequently
      refer to it in the rest of the chapter. As with several other
      standard library modules, Core alters the <literal>Gc</literal>
      interface from the standard OCaml library. We'll assume that
      you've opened <literal>Core.Std</literal> in our explanations.
    </para>
    <para>
      You can also control the behavior of OCaml programs by setting the
      <literal>OCAMLRUNPARAM</literal> environment variable before
      launching your application. This lets you set garbage collector
      parameters without recompiling, for example to benchmark the
      effects of different settings. The format of
      <literal>OCAMLRUNPARAM</literal> is documented in the
      <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual024.html">OCaml
      manual</ulink>.
    </para>
    </sidebar>
  </sect1>
  <sect1 id="the-fast-minor-heap">
    <title>The fast minor heap</title>
    <para>
      The minor heap is where most of your short-lived values are held.
      It consists of one contiguous chunk of virtual memory containing a
      sequence of OCaml blocks. If there is space, allocating a new
      block is a fast constant-time operation that requires just a
      couple of CPU instructions.
    </para>
    <para>
      To garbage collect the minor heap, OCaml uses <emphasis>copying
      collection</emphasis> to move all live blocks in the minor heap to
      the major heap. This takes work proportional to the number of live
      blocks in the minor heap, which is typically small according to
      the generational hypothesis. The minor collection <emphasis>stops
      the world</emphasis> (that it, halts the application) while it
      runs, which is why it's so important that it complete quickly to
      let the application resume running with minimal interruption.
    </para>
    <sect2 id="allocating-on-the-minor-heap">
      <title>Allocating on the minor heap</title>
      <para>
        The minor heap is a contiguous chunk of virtual memory that is
        usually a few megabytes in size so that it can be scanned
        quickly.
      </para>
      <programlisting>
                &lt;---- size ----&gt;
 base --- start ---------------- end
          limit      ptr &lt;------
                          blocks
</programlisting>
      <para>
        The runtime stores the boundaries of the minor heap in two
        pointers that delimit the start and end of the heap region
        (<literal>caml_young_start</literal> and
        <literal>caml_young_end</literal>, but we will drop the
        <literal>caml_young</literal> prefix for brevity). The
        <literal>base</literal> is the memory address returned by the
        system <literal>malloc</literal>, and <literal>start</literal>
        is aligned against the next nearest word boundary from
        <literal>base</literal> to make it easier to store OCaml values.
      </para>
      <para>
        In a fresh minor heap, the <literal>limit</literal> equals the
        <literal>start</literal> and the current <literal>ptr</literal>
        will equal the <literal>end</literal>. <literal>ptr</literal>
        decreases as blocks are allocated until it reaches
        <literal>limit</literal>, at which point a minor garbage
        collection is triggered.
      </para>
      <para>
        Allocating a block in the minor heap just requires
        <literal>ptr</literal> to be decremented by the size of the
        block (including the header) and checking that it's not less
        than <literal>limit</literal>. If there isn't enough space left
        for the block without decrementing past the
        <literal>limit</literal>, a minor garbage collection is
        triggered. This is a very fast check (with no branching) on most
        CPU architectures.
      </para>
      <para>
        You may wonder why <literal>limit</literal> is required at all,
        since it always seems to equal <literal>start</literal>. It's
        because the easiest way for the runtime to schedule a minor heap
        collection is by setting <literal>limit</literal> to equal
        <literal>end</literal>. The next allocation will never have
        enough space after this is done and will always trigger a
        garbage collection. There are various internal reasons for such
        early collections, such as handling pending UNIX signals, and
        they don't ordinally matter for application code.
      </para>
      <note>
      <title>
      Setting the size of the minor heap
      </title>
      <para>
        The default minor heap size in OCaml is normally 2MB on 64-bit
        platforms, but this is increased to 8MB if you use Core (which
        generally improves performance but at the cost of a bigger
        memory profile by default). This setting can be overridden
        unless overridden by the <literal>s=&lt;words&gt;</literal>
        argument to <literal>OCAMLRUNPARAM</literal>. You can change it
        after the program has started by calling the
        <literal>Gc.set</literal> function.
      </para>
      <programlisting language="ocaml">
# script gc/tune.topscript
$ utop
# let c = Gc.get () ;; 
val c : Gc.control =
  {Core.Std.Gc.Control.minor_heap_size = 1000000;
   major_heap_increment = 1000448; space_overhead = 100; verbose = 0;
   max_overhead = 500; stack_limit = 1048576; allocation_policy = 0}
# Gc.tune ~minor_heap_size:(262144 * 2) () ;; 
- : unit = ()
</programlisting>
      <para>
        Changing the GC size dynamically will trigger an immediate minor
        heap collection. Note that Core increases the default minor heap
        size from the standard OCaml installation quite significantly,
        and you'll want to reduce this if running in very
        memory-constrained environments.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="the-long-lived-major-heap">
    <title>The long-lived major heap</title>
    <para>
      The major heap is where the bulk of the longer-lived and larger
      values in your program are stored. It consists of any number of
      non-contiguous chunks of virtual memory, each containing live
      blocks interspersed with regions of free memory. The runtime
      system maintains a free-list data structure that indexes all the
      free memory that it has allocated, and uses it to satisfy
      allocation requests for OCaml blocks.
    </para>
    <para>
      The major heap is typically much larger than the minor heap and
      can scale to gigabytes in size. It is cleaned via a mark-and-sweep
      garbage collection algorithm that operates in several phases.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          The <emphasis>mark</emphasis> phase scans the block graph and
          marks all live blocks by setting a bit in the tag of the block
          header (known as the <emphasis>color</emphasis> tag).
        </para>
      </listitem>
      <listitem>
        <para>
          The <emphasis>sweep</emphasis> phase sequentially scans the
          heap chunks and identifies dead blocks that weren't marked
          earlier.
        </para>
      </listitem>
      <listitem>
        <para>
          The <emphasis>compact</emphasis> phase relocates live blocks
          into a freshly allocated heap to eliminate gaps in the free
          list. This prevents the fragmentation of heap blocks in
          long-running programs, and normally occurs much less
          frequently than the mark and sweep phases.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      A major garbage collection must also stop the world to ensure that
      blocks can be moved around without this being observed by the live
      application. The mark-and-sweep phases run incrementally over
      slices of the heap to avoid pausing the application for long
      periods of time, and also precede each slice with a fast minor
      collection. Only the compaction phase touches all the memory in
      one go, and is a relatively rare operation.
    </para>
    <sect2 id="allocating-on-the-major-heap">
      <title>Allocating on the major heap</title>
      <para>
        The major heap consists of a singly-linked list of contiguous
        memory chunks sorted in increasing order of virtual address.
        Each chunk is a single memory region allocated via
        <emphasis>malloc(3)</emphasis> and consists of a header and data
        area which contains OCaml heap chunks. A heap chunk header
        contains:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            the <emphasis>malloc</emphasis>'ed virtual address of the
            memory region containing the chunk.
          </para>
        </listitem>
        <listitem>
          <para>
            the size in bytes of the data area.
          </para>
        </listitem>
        <listitem>
          <para>
            an allocation size in bytes used during heap compaction to
            merge small blocks to defragment the heap.
          </para>
        </listitem>
        <listitem>
          <para>
            a link to the next heap chunk in the list.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Each chunk's data area starts on a page boundary and its size is
        a multiple of the page size (4KB). It contains a contiguous
        sequence of heap blocks which can be as small as one or two 4KB
        pages, but are usually allocated in 1MB chunks (or 512KB on
        32-bit architectures).
      </para>
      <note>
      <title>
      Controlling major heap growth
      </title>
      <para>
        The <literal>Gc</literal> module uses the
        <literal>major_heap_increment</literal> value to control the
        major heap growth. This defines the number of words to add to
        the major heap per expansion, and is the only memory allocation
        operation that the operating system observes from the OCaml
        runtime after initial startup (since the minor is fixed in
        size).
      </para>
      <para>
        If you anticipate allocating some large OCaml values, then
        setting the heap increment to a larger value will let the
        operating system return a contiguous block of memory. This is
        preferable to lots of smaller heap chunks that may be spread
        across different regions of virtual memory, and require more
        housekeeping in the OCaml runtime to keep track of them.
      </para>
      <programlisting language="ocaml">
...part 1 of gc/tune.topscript
# Gc.tune ~major_heap_increment:(1000448 * 4) () ;; 
- : unit = ()
</programlisting>
      </note>
      <para>
        Allocating an OCaml value on the major heap first checks the
        free list of blocks for a suitable region to place it. If there
        isn't enough room on the free list, the runtime expands the
        major heap by allocating a fresh heap chunk that will be large
        enough. That chunk is then added to the free list and the free
        list is checked again (and this time will definitely succeed).
      </para>
      <para>
        Remember that most allocations to the major heap will go via the
        minor heap, and only be promoted if they are still used by the
        program after a minor collection. The one exception to this is
        for values larger than 256 words (that is, 2kB on 64-bit
        platforms). These will be allocated directly on the major heap
        since an allocation on the minor heap would likely trigger an
        immediate collection and copy it to the major heap anyway.
      </para>
    </sect2>
    <sect2 id="memory-allocation-strategies">
      <title>Memory allocation strategies</title>
      <para>
        The major heap does its best to manage memory allocation as
        efficiently as possible, and relies on heap compaction to ensure
        that memory stays contiguous and unfragmented. The default
        allocation policy normally works fine for most applications, but
        it's worth bearing in mind that there are other options too.
      </para>
      <para>
        The free list of blocks is always checked first when allocating
        a new block in the major heap. The default free list search is
        called <emphasis>next-fit allocation</emphasis>, with an
        alternative <emphasis>first-fit</emphasis> algorithm also
        available.
      </para>
      <sect3 id="next-fit-allocation">
        <title>Next-fit allocation</title>
        <para>
          Next-fit allocation keeps a pointer to the block in the free
          list that was most recently used to satisfy a request. When a
          new request comes in, the allocator searches from the next
          block until the end of the free list, and then from the
          beginning of the free list up to that block.
        </para>
        <para>
          Next-fit allocation is the default allocation strategy. It's
          quite a cheap allocation mechanism since the same heap chunk
          can be reused across allocation requests until it runs out.
          This in turn means that there is good memory locality to use
          CPU caches better.
        </para>
      </sect3>
      <sect3 id="first-fit-allocation">
        <title>First-fit allocation</title>
        <para>
          If your programs allocates values of many varied sizes, you
          may sometimes find that your free list becomes fragmented. In
          this situation, the GC is forced to perform an expensive
          compaction despite there being free chunks, since none of the
          chunks alone are big enough to satisfy the request.
        </para>
        <para>
          First-fit allocation focuses on reducing memory fragmentation
          (and hence the number of compactions), but at the expense of
          slower memory allocation. Every allocation scans the free list
          from the beginning for a suitable free chunk, instead of
          reusing the most recent heap chunk as the next-fit allocator
          does.
        </para>
        <para>
          For some workloads that need more real-time behavior under
          load, the reduction in the frequency in heap compaction will
          outweigh the extra allocation cost.
        </para>
        <note>
        <title>
        Controlling the heap allocation policy
        </title>
        <para>
          You can set the heap allocation policy via the
          <literal>Gc.allocation_policy</literal> field. A value of
          <literal>0</literal> (the default) sets it to next-fit, and
          <literal>1</literal> to the first-fit allocator.
        </para>
        <para>
          The same behavior can be controlled at runtime by setting
          <literal>a=0</literal> or <literal>a=1</literal> in
          <literal>OCAMLRUNPARAM</literal>.
        </para>
        </note>
      </sect3>
    </sect2>
    <sect2 id="marking-and-scanning-the-heap">
      <title>Marking and scanning the heap</title>
      <para>
        The marking process can take a long time to run over the
        complete major heap, and has to pause the main application while
        it's active. It therefore runs incrementally by marking the heap
        in <emphasis>slices</emphasis>. Each value in the heap has a
        2-bit <emphasis>color</emphasis> field in its header that is
        used to store information about whether the value has been
        marked, so that the GC can resume easily between slices.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left"/>
          <colspec align="left"/>
          <thead>
            <row>
              <entry>
                Tag Color
              </entry>
              <entry>
                Block Status
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                blue
              </entry>
              <entry>
                on the free list and not currently in use
              </entry>
            </row>
            <row>
              <entry>
                white (during marking)
              </entry>
              <entry>
                not reached yet, but possibly reachable
              </entry>
            </row>
            <row>
              <entry>
                white (during sweeping)
              </entry>
              <entry>
                unreachable and can be freed
              </entry>
            </row>
            <row>
              <entry>
                gray
              </entry>
              <entry>
                reachable, but its fields have not been scanned
              </entry>
            </row>
            <row>
              <entry>
                black
              </entry>
              <entry>
                reachable, and its fields have been scanned
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        The color tags in the value headers store most of the state of
        the marking process, allowing it to be paused and resumed later.
        The GC and application alternate between marking a slice of the
        major heap and actually getting on with executing the program
        logic. The OCaml runtime calculates a sensible value for the
        size of each major heap slice based on the rate of allocation
        and available memory (see below).
      </para>
      <para>
        The marking process starts with a set of
        <emphasis>root</emphasis> values that are always live (such as
        the application stack). All values on the heap are initially
        marked as white values that are possibly reachable, but haven't
        been scanned yet. It recursively follows all the fields in the
        roots via a depth-first search, and pushes newly encountered
        white blocks onto an intermediate stack of <emphasis>gray
        values</emphasis> while it follows their fields. When a gray
        value's fields have all been followed it is popped off the stack
        and colored black.
      </para>
      <para>
        This process is repeated until the gray value stack is empty and
        there are no further values to mark. There's one important edge
        case in this process, though. The gray value stack can only grow
        to a certain size, after which the GC can no longer recurse into
        intermediate values since it has nowhere to store them while it
        follows their fields. If this happens, the heap is marked as
        <emphasis>impure</emphasis> and a more expensive check is
        initiated once the existing gray values have been processed.
      </para>
      <para>
        To mark an impure heap, the GC first marks it as pure and walks
        through the entire heap block-by-block in increasing order of
        memory address. If it finds a gray block, it adds it to the gray
        list and recursively marks it using the usual strategy for a
        pure heap. Once the scan of the complete heap is finished, the
        mark phase checks again whether the heap has again become
        impure, and repeats the scan until it is pure again. These
        full-heap scans will continue until a successful scan completes
        without overflowing the gray list.
      </para>
      <note>
      <title>
      Controlling major heap collections
      </title>
      <para>
        You can trigger a single slice of the major GC via the
        <literal>major_slice</literal> call. This performs a minor
        collection first, and then a single slice. The size of the slice
        is normally automatically computed by the GC to an appropriate
        value, and returns this value so that you can modify it in
        future calls if necessary.
      </para>
      <programlisting language="ocaml">
...part 2 of gc/tune.topscript
# Gc.major_slice 0 ;; 
- : int = 259895
# Gc.full_major () ;; 
- : unit = ()
</programlisting>
      <para>
        The <literal>space_overhead</literal> setting controls how
        aggressive the GC is about setting the slice size to a large
        size. This represents the proportion of memory used for live
        data that will be &quot;wasted&quot; because the GC doesn't
        immediately collect unreachable blocks. Core defaults this to
        <literal>100</literal> to reflect a typical system that isn't
        overly memory-constrained. Set this even higher if you have lots
        of memory, or lower to cause the GC to work harder and collect
        blocks faster at the expense of using more CPU time.
      </para>
      </note>
    </sect2>
    <sect2 id="heap-compaction">
      <title>Heap Compaction</title>
      <para>
        After a certain number of major GC cycles have completed, the
        heap may begin to be fragmented due to values being deallocated
        out of order from how they were allocated. This makes it harder
        for the GC to find a contiguous block of memory for fresh
        allocations, which in turn would require the heap to be grown
        unnecessarily.
      </para>
      <para>
        The heap compaction cycle avoids this by relocating all the
        values in the major heap into a fresh heap that places them all
        contiguously in memory again. A naive implementation of the
        algorithm would require extra memory to store the new heap, but
        OCaml performs the compaction in-place within the existing heap.
      </para>
      <note>
      <title>
      Controlling frequency of compactions
      </title>
      <para>
        The <literal>max_overhead</literal> setting in the
        <literal>Gc</literal> module defines the connection between free
        memory and allocated memory after which compaction is activated.
      </para>
      <para>
        A value of <literal>0</literal> triggers a compaction after
        every major garbage collection cycle, whereas the maximum value
        of <literal>1000000</literal> disables heap compaction
        completely. The default settings should be fine unless you have
        unusual allocation patterns that are causing a higher-than-usual
        rate of compactions.
      </para>
      <programlisting language="ocaml">
...part 3 of gc/tune.topscript
# Gc.tune ~max_overhead:0 () ;; 
- : unit = ()
</programlisting>
      </note>
    </sect2>
    <sect2 id="inter-generational-pointers">
      <title>Inter-generational pointers</title>
      <para>
        One complexity of generational collection arises from the fact
        that minor heap sweeps are much more frequent than major heap
        collections. In order to know which blocks in the minor heap are
        live, the collector must track which minor-heap blocks are
        directly pointed to by major-heap blocks. Without this
        information, each minor collection would also require scanning
        the much larger major heap.
      </para>
      <para>
        OCaml maintains a set of such <emphasis>inter-generational
        pointers</emphasis> to avoid this dependency between a major and
        minor heap collection. The compiler introduces a write barrier
        to update this so-called <emphasis>remembered set</emphasis>
        whenever a major-heap block is modified to point at a minor-heap
        block.
      </para>
      <sect3 id="the-mutable-write-barrier">
        <title>The mutable write barrier</title>
        <para>
          The write barrier can have profound implications for the
          structure of your code. It's one of the reasons why using
          immutable data structures and allocating a fresh copy with
          changes can sometimes be faster than mutating a record
          in-place.
        </para>
        <para>
          The OCaml compiler keeps track of any mutable types and adds a
          call to the runtime <literal>caml_modify</literal> function
          before making the change. This checks the location of target
          write and the value it's being changed to, and ensures that
          the remembered set is consistent. Although the write barrier
          is reasonably efficient, it can sometimes be slower than
          simply allocating a fresh value on the fast minor heap and
          doing some extra minor collections.
        </para>
        <para>
          Let's see this for ourselves with a simple test program.
          You'll need to install the Core benchmarking suite via
          <literal>opam install core_bench</literal> before you compile
          this code.
        </para>
        <programlisting language="ocaml">
(* gc/barrier_bench.ml  *)
open Core.Std
open Core_bench.Std

type t1 = { mutable iters1: int; mutable count1: float }
type t2 = { iters2: int; count2: float }

let rec test_mutable t1 =
  match t1.iters1 with
  |0 -&gt; ()
  |_ -&gt;
    t1.iters1 &lt;- t1.iters1 - 1;
    t1.count1 &lt;- t1.count1 +. 1.0;
    test_mutable t1

let rec test_immutable t2 =
  match t2.iters2 with
  |0 -&gt; ()
  |n -&gt;
    let iters2 = n - 1 in
    let count2 = t2.count2 +. 1.0 in
    test_immutable { iters2; count2 }

let () =
  let iters = 1000000 in
  let tests = [
    Bench.Test.create ~name:&quot;mutable&quot; 
      (fun () -&gt; test_mutable { iters1=iters; count1=0.0 });
    Bench.Test.create ~name:&quot;immutable&quot;
      (fun () -&gt; test_immutable { iters2=iters; count2=0.0 })
  ] in
  Bench.make_command tests |&gt; Command.run
</programlisting>
        <para>
          This program defines a type <literal>t1</literal> that is
          mutable and <literal>t2</literal> that is immutable. The
          benchmark loop iterates over both fields and increments a
          counter. Compile and execute this with some extra options to
          show the amount of garbage collection occurring.
        </para>
        <programlisting>
# running gc/run_barrier_bench.out.sh
$ corebuild -pkg core_bench barrier_bench.native
$ ./barrier_bench.native -ascii name alloc
Estimated testing time 20s (change using -quota SECS).
                                                                   
  Name        Time (ns)       Minor   Major   Promoted   % of max  
 ----------- ----------- ----------- ------- ---------- ---------- 
  mutable     6_306_192   2_000_004    9.05       9.05     100.00  
  immutable   4_682_185   5_000_005    0.03       0.03      74.25  
                                                                   
</programlisting>
        <para>
          There is a stark space/time tradeoff here. The mutable version
          takes significantly longer to complete than the immutable one,
          but allocates many fewer minor heap words than the immutable
          version. Minor allocation in OCaml is very fast and so it is
          often better to use immutable data structures in preference to
          the more conventional mutable versions. On the other hand, if
          you only rarely mutate a value, it can be faster to take the
          write barrier hit and not allocate at all.
        </para>
        <para>
          The only way to know for sure is to benchmark your program
          under real-world scenarios using
          <literal>Core_bench</literal>, and experiment with the
          tradeoffs. The command-line benchmark binaries have a number
          of useful options that affect garbage collection behavior.
        </para>
        <programlisting>
# running gc/show_barrier_bench_help.out.sh
$ ./barrier_bench.native -help
Benchmark for mutable, immutable

  barrier_bench.native [COLUMN ...]

Columns that can be specified are:
    name       - Name of the test.
    cycles     - Number of CPU cycles (RDTSC) taken.
    cycles-err - 95% confidence interval and R^2 error for cycles.
    ~cycles    - Cycles taken excluding major GC costs.
    time       - Number of nano secs taken.
    time-err   - 95% confidence interval and R^2 error for time.
    ~time      - Time (ns) taken excluding major GC costs.
    alloc      - Allocation of major, minor and promoted words.
    gc         - Show major and minor collections per 1000 runs.
    percentage - Relative execution time as a percentage.
    speedup    - Relative execution cost as a speedup.
    samples    - Number of samples collected for profiling.

R^2 error indicates how noisy the benchmark data is. A value of
1.0 means the amortized cost of benchmark is almost exactly predicated
and 0.0 means the reported values are not reliable at all.
Also see: http://en.wikipedia.org/wiki/Coefficient_of_determination

Major and Minor GC stats indicate how many collections happen per 1000
runs of the benchmarked function.

The following columns will be displayed by default:
    +name time percentage

To specify that a column should be displayed only if it has a non-trivial value,
prefix the column name with a '+'.

=== flags ===

  [-ascii]             Display data in simple ascii based tables.
  [-clear-columns]     Don't display default columns. Only show user specified
                       ones.
  [-display STYLE]     Table style (short, tall, line, blank or column). Default
                       short.
  [-geometric SCALE]   Use geometric sampling. (default 1.01)
  [-linear INCREMENT]  Use linear sampling to explore number of runs, example 1.
  [-no-compactions]    Disable GC compactions.
  [-quota SECS]        Time quota allowed per test (default 10s).
  [-save]              Save benchmark data to &lt;test name&gt;.txt files.
  [-stabilize-gc]      Stabilize GC between each sample capture.
  [-v]                 High verbosity level.
  [-width WIDTH]       width limit on column display (default 150).
  [-build-info]        print info about this build and exit
  [-version]           print the version of this build and exit
  [-help]              print this help text and exit
                       (alias: -?)

</programlisting>
        <para>
          The <literal>-no-compactions</literal> and
          <literal>-stabilize-gc</literal> options can help force a
          situation where your application has fragmented memory. This
          can simulate the behavior of a long-running application
          without you having to actually wait that long to recreate the
          behavior in a performance unit test.
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="attaching-finalizer-functions-to-values">
    <title>Attaching finalizer functions to values</title>
    <para>
      OCaml's automatic memory management guarantees that a value will
      eventually be freed when it's no longer in use, either via the
      garbage collector sweeping it or the program terminating. It's
      sometimes useful to run extra code just before a value is freed by
      the garbage collector, for example to check that a file descriptor
      has been closed, or that a log message is recorded.
    </para>
    <note>
    <title>
    What values can be finalized?
    </title>
    <para>
      Various values cannot have finalizers attached since they aren't
      heap-allocated. Some examples of values that are not
      heap-allocated are integers, constant constructors, booleans, the
      empty array, the empty list and the unit value. The exact list of
      what is heap-allocated or not is implementation-dependent, which
      is why Core provides the <literal>Heap_block</literal> module to
      explicitly check before attaching the finalizer.
    </para>
    <para>
      Some constant values can be heap-allocated but never deallocated
      during the lifetime of the program, for example a list of integer
      constants. <literal>Heap_block</literal> explicitly checks to see
      if the value is in the major or minor heap, and rejects most
      constant values. Compiler optimizations may also duplicate some
      immutable values such as floating-point values in arrays. These
      may be finalized while another duplicate copy is being used by the
      program.
    </para>
    <para>
      For this reason, attach finalizers only to values that you are
      explicitly sure are heap-allocated and aren't immutable. A common
      use is to attach them to file descriptors to ensure it is closed.
      However, the finalizer normally shouldn't be the primary way of
      closing the file descriptor, since it depends on the garbage
      collector running in order to collect the value. For a busy
      system, you can easily run out of a scarce resource such as file
      descriptors before the GC catches up.
    </para>
    </note>
    <para>
      Core provides a <literal>Heap_block</literal> module that
      dynamically checks if a given value is suitable for finalizing.
      This block is then passed to Async's
      <literal>Gc.add_finalizer</literal> function that schedules the
      finalizer safely with respect to all the other concurrent program
      threads.
    </para>
    <para>
      Let's explore this with a small example that finalizes values of
      different types, some of which are heap-allocated and others which
      are compile-time constants.
    </para>
    <programlisting language="ocaml">
(* gc/finalizer.ml  *)
open Core.Std
open Async.Std

let attach_finalizer n v =
  match Heap_block.create v with
  | None -&gt; printf &quot;%20s: FAIL\n%!&quot; n
  | Some hb -&gt;
    let final _ = printf &quot;%20s: OK\n%!&quot; n in
    Gc.add_finalizer hb final

type t = { foo: bool }

let main () =
  let alloced_float = Unix.gettimeofday () in
  let alloced_bool = alloced_float &gt; 0.0 in
  let alloced_string = String.create 4 in
  attach_finalizer &quot;immediate int&quot; 1;
  attach_finalizer &quot;immediate float&quot; 1.0;
  attach_finalizer &quot;immediate variant&quot; (`Foo &quot;hello&quot;);
  attach_finalizer &quot;immediate string&quot; &quot;hello world&quot;;
  attach_finalizer &quot;immediate record&quot; { foo=false };
  attach_finalizer &quot;allocated float&quot; alloced_float;
  attach_finalizer &quot;allocated bool&quot; alloced_bool;
  attach_finalizer &quot;allocated variant&quot; (`Foo alloced_bool);
  attach_finalizer &quot;allocated string&quot; alloced_string;
  attach_finalizer &quot;allocated record&quot; { foo=alloced_bool };
  Gc.compact ();
  return ()

let () =
  Command.async_basic ~summary:&quot;Testing finalizers&quot;
    Command.Spec.empty main
  |&gt; Command.run
</programlisting>
    <para>
      Building and running this should show the following output.
    </para>
    <programlisting language="ocaml">
(* gc/run_finalizer.out  *)
$ corebuild -pkg async finalizer.native
$ ./finalizer.native
       immediate int: FAIL
     immediate float: FAIL
   immediate variant: FAIL
    immediate string: FAIL
    immediate record: FAIL
      allocated bool: FAIL
    allocated record: OK
    allocated string: OK
   allocated variant: OK
     allocated float: OK
</programlisting>
    <para>
      The GC calls the finalization functions in the order of the
      deallocation. If several values become unreachable during the same
      GC cycle, the finalization functions will be called in the reverse
      order of the corresponding calls to
      <literal>add_finalizer</literal>. Each call to
      <literal>add_finalizer</literal> adds to the set of functions that
      are run when the value becomes unreachable. You can have many
      finalizers all pointing to the same heap block if you wish.
    </para>
    <para>
      After a garbage collection determines that a heap block
      <literal>b</literal> is unreachable, it removes from the set of
      finalizers all the functions associated with <literal>b</literal>,
      and serially applies each of those functions to
      <literal>b</literal>. Thus, every finalizer function attached to
      <literal>b</literal> will run at most once. However, program
      termination will not cause all the finalizers to be run before the
      runtime exits.
    </para>
    <para>
      The finalizer can use all features of OCaml, including assignments
      that make the value reachable again and thus prevent it from being
      garbage collected. It can also loop forever, which will cause
      other finalizers to be interleaved with it.
    </para>
    <note>
    <title>
    Production note
    </title>
    <para>
      This chapter contains significant contributions from Stephen
      Weeks.
    </para>
    </note>

  </sect1>
</chapter><chapter id="the-compiler-frontend-parsing-and-type-checking">
  <title>The Compiler Frontend: Parsing and Type Checking</title>
  <para>
    Compiling source code into executable programs is a fairly complex
    process that involves quite a few tools—preprocessors, compilers,
    runtime libraries, linkers and assemblers. It's important to
    understand how these fit together to help with your day-to-day
    workflow of developing, debugging and deploying applications.
  </para>
  <para>
    OCaml has a strong emphasis on static type safety and rejects source
    code that doesn't meet its requirements as early as possible. The
    compiler does this by running the source code through a series of
    checks and transformations. Each stage performs its job
    (<emphasis>e.g.</emphasis> type checking, optimization or code
    generation) and discards some information from the previous stage.
    The final native code output is low-level assembly code that doesn't
    know anything about the OCaml modules or objects that the compiler
    started with.
  </para>
  <para>
    You don't have to do all this manually, of course. The compiler
    frontends (<literal>ocamlc</literal> and
    <literal>ocamlopt</literal>) are invoked via the command-line and
    chain the stages together for you. Sometimes though, you'll need to
    dive into the toolchain to hunt down a bug or investigate a
    performance problem. This chapter explains the compiler pipeline in
    more depth so you understand how to harness the command-line tools
    effectively.
  </para>
  <para>
    In this chapter, we'll cover the following topics:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        the compilation pipeline and what each stage represents.
      </para>
    </listitem>
    <listitem>
      <para>
        source preprocessing via Camlp4 and the intermediate forms.
      </para>
    </listitem>
    <listitem>
      <para>
        the type-checking process, including module resolution.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    The details of the compilation process into executable code can be
    found next in
    <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.
  </para>
  <sect1 id="an-overview-of-the-toolchain">
    <title>An overview of the toolchain</title>
    <para>
      The OCaml tools accept textual source code as input, using
      filename extensions of <literal>.ml</literal> and
      <literal>.mli</literal> for modules and signatures respectively.
      We explained the basics of the build process earlier in
      <xref linkend="files-modules-and-programs"/>, so we'll
      assume you've built a few OCaml programs already by this point.
    </para>
    <para>
      Each source file represents a <emphasis>compilation
      unit</emphasis> that is built separately. The compiler generates
      intermediate files with different filename extensions to use as it
      advances through the compilation stages. The linker takes a
      collection of compiled units and produces a standalone executable
      or library archive that can be reused by other applications.
    </para>
    <para>
      The overall compilation pipeline looks like this:
    </para>
    <programlisting>
    Source code
        |
        | parsing and preprocessing
        |
        | camlp4 syntax extensions
        |
        v
    Parsetree (untyped AST)
        |
        | type inference and checking
        v
    Typedtree (type-annotated AST)
        |
        | pattern-matching compilation
        | elimination of modules and classes
        v
     Lambda
      /   \
     /     \ closure conversion, inlining, uncurrying,
    v       \  data representation strategy
 Bytecode    \
    |         +-----+
    |              Cmm
    |ocamlrun       |
    |               | code generation
    |               | assembly &amp; linking
    v               v
 Interpreted    Compiled
</programlisting>
    <para>
      Notice that the pipeline branches towards the end. OCaml has
      multiple compiler backends that reuse the early stages of
      compilation, but produce very different final outputs. The
      <emphasis>bytecode</emphasis> can be run by a portable
      interpreter, and can even be transformed into JavaScript (via
      <ulink url="http://ocsigen.org/js_of_ocaml">js_of_ocaml</ulink>)
      or C source code (via
      <ulink url="https://github.com/ocaml-bytes/ocamlcc">OCamlCC</ulink>).
      The <emphasis>native code</emphasis> compiler generates
      specialized executable binaries suitable for high-performance
      applications.
    </para>
    <sidebar>
    <title>
    Obtaining the compiler source code
    </title>
    <para>
      Although it's not necessary to understand the examples, you may
      find it useful to have a copy of the OCaml source tree checked out
      while you read through this chapter. The source code is available
      from multiple places:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Stable releases as zip and tar archives from the
          <ulink url="http://caml.inria.fr/download.en.html">OCaml
          download site</ulink>.
        </para>
      </listitem>
      <listitem>
        <para>
          A Subversion anonymous mirror of the main development sources
          available on the
          <ulink url="http://caml.inria.fr/ocaml/anonsvn.en.html">development
          resources</ulink> page online.
        </para>
      </listitem>
      <listitem>
        <para>
          A Git mirror of the Subversion repository with all the history
          and development branches included, browsable online at
          <ulink url="https://github.com/ocaml/ocaml">Github</ulink>.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The source tree is split up into sub-directories. The core
      compiler consists of:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>config/</literal>: configuration directives to tailor
          OCaml for your operating system and architecture.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>bytecomp/</literal> and <literal>byterun/</literal>:
          byte-code compiler and runtime, including the garbage
          collector.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>asmcomp/</literal> and <literal>asmrun/</literal>:
          native-code compiler and runtime. The native runtime symlinks
          many modules from the <literal>byterun</literal> directory to
          share code, most notably the garbage collector.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>parsing/</literal>: the OCaml lexer, parser and
          libraries for manipulating them.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>typing/</literal>: the static type checking
          implementation and type definitions.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>camlp4/</literal>: the source code macro
          preprocessor.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>driver/</literal>: command-line interfaces for the
          compiler tools.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      There are a number of tools and scripts also built alongside the
      core compiler:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>debugger/</literal>: the interactive byte-code
          debugger.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>toplevel/</literal>: interactive top-level console.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>emacs/</literal>: a <emphasis>caml-mode</emphasis>
          for the Emacs editor.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>stdlib/</literal>: the compiler standard library,
          including the <literal>Pervasives</literal> module.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>ocamlbuild/</literal>: build system that automates
          common OCaml compilation modes.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>otherlibs/</literal>: optional libraries such as the
          Unix and graphics modules.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>tools/</literal>: command-line utilities such as
          <literal>ocamldep</literal> that are installed with the
          compiler.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>testsuite/</literal>: regression tests for the core
          compiler.
        </para>
      </listitem>
    </itemizedlist>
    </sidebar>
    <para>
      We'll go through each of the compilation stages now and explain
      how that'll be useful to you during day-to-day OCaml development.
    </para>
  </sect1>
  <sect1 id="parsing-source-code">
    <title>Parsing source code</title>
    <para>
      When a source file is passed to the OCaml compiler, its first task
      is to parse the text into a more structured Abstract Syntax Tree
      (AST). The parsing logic is implemented in OCaml itself using the
      techniques described earlier in
      <xref linkend="parsing-with-ocamllex-and-menhir"/>. The
      lexer and parser rules can be found in the
      <literal>parsing</literal> directory in the source distribution.
    </para>
    <sect2 id="syntax-errors">
      <title>Syntax errors</title>
      <para>
        The OCaml parser's goal is to output a well-formed AST data
        structure to the next phase of compilation, and so it rejects
        any source code that doesn't match basic syntactic requirements.
        The compiler emits a <emphasis>syntax error</emphasis> in this
        situation, with a pointer to the filename and line and character
        number that's as close to the error as possible.
      </para>
      <para>
        Here's an example syntax error that we obtain by performing a
        module assignment as a statement instead of as a let-binding.
      </para>
      <programlisting language="ocaml">
(* front-end/broken_module.ml  *)
let () =
  module MyString = String;
  ()
</programlisting>
      <para>
        The above code results in a syntax error when compiled.
      </para>
      <programlisting>
# running front-end/build_broken_module.out.sh
$ ocamlc -c broken_module.ml
File &quot;broken_module.ml&quot;, line 2, characters 2-8:
Error: Syntax error
</programlisting>
      <para>
        The correct version of this source code creates the
        <literal>MyString</literal> module correctly via a local open,
        and compiles successfully.
      </para>
      <programlisting language="ocaml">
(* front-end/fixed_module.ml  *)
let () =
  let module MyString = String in
  ()
</programlisting>
      <para>
        The syntax error points to the line and character number of the
        first token that couldn't be parsed. In the broken example the
        <literal>module</literal> keyword isn't a valid token at that
        point in parsing, so the error location information is correct.
      </para>
    </sect2>
    <sect2 id="automatically-indenting-source-code">
      <title>Automatically indenting source code</title>
      <para>
        Sadly, syntax errors do get more inaccurate sometimes depending
        on the nature of your mistake. Try to spot the deliberate error
        in the following function definitions.
      </para>
      <programlisting language="ocaml">
(* front-end/follow_on_function.ml  *)
let concat_and_print x y =
  let v = x ^ y in
  print_endline v;
  v;

let add_and_print x y =
  let v = x + y in
  print_endline (string_of_int v);
  v

let () =
  let _x = add_and_print 1 2 in
  let _y = concat_and_print &quot;a&quot; &quot;b&quot; in
  ()
</programlisting>
      <para>
        When you compile this file you'll get a syntax error again.
      </para>
      <programlisting>
# running front-end/build_follow_on_function.out.sh
$ ocamlc -c follow_on_function.ml
File &quot;follow_on_function.ml&quot;, line 11, characters 0-3:
Error: Syntax error
</programlisting>
      <para>
        The line number in the error points to the end of the
        <literal>add_and_print</literal> function, but the actual error
        is at the end of the <emphasis>first</emphasis> function
        definition. There's an extra semicolon at the end of the first
        definition that causes the second definition to become part of
        the first <literal>let</literal> binding. This eventually
        results in a parsing error at the very end of the second
        function.
      </para>
      <para>
        This class of bug (due to a single errant character) can be hard
        to spot in a large body of code. Luckily, there's a great tool
        available via OPAM called <literal>ocp-indent</literal> that
        applies structured indenting rules to your source code on a
        line-by-line basis. This not only beautifies your code layout,
        but it also makes this syntax error much easier to locate.
      </para>
      <para>
        Let's run our erroneous file through
        <literal>ocp-indent</literal> and see how it processes it.
      </para>
      <programlisting>
# running front-end/indent_follow_on_function.out.sh
$ ocp-indent follow_on_function.ml
let concat_and_print x y =
  let v = x ^ y in
  print_endline v;
  v;

  let add_and_print x y =
    let v = x + y in
    print_endline (string_of_int v);
    v

let () =
  let _x = add_and_print 1 2 in
  let _y = concat_and_print &quot;a&quot; &quot;b&quot; in
  ()
</programlisting>
      <para>
        The <literal>add_and_print</literal> definition has been
        indented as if it were part of the first
        <literal>concat_and_print</literal> definition, and the errant
        semicolon is now much easier to spot. We just need to remove
        that semicolon and re-run <literal>ocp-indent</literal> to
        verify that the syntax is correct.
      </para>
      <programlisting>
# running front-end/indent_follow_on_function_fixed.out.sh
$ ocp-indent follow_on_function_fixed.ml
let concat_and_print x y =
  let v = x ^ y in
  print_endline v;
  v

let add_and_print x y =
  let v = x + y in
  print_endline (string_of_int v);
  v

let () =
  let _x = add_and_print 1 2 in
  let _y = concat_and_print &quot;a&quot; &quot;b&quot; in
  ()
</programlisting>
      <para>
        The <literal>ocp-indent</literal>
        <ulink url="https://github.com/OCamlPro/ocp-indent">homepage</ulink>
        documents how to integrate it with your favorite editor. All the
        Core libraries are formatted using it to ensure consistency, and
        it's a good idea to do this before publishing your own source
        code online.
      </para>
    </sect2>
    <sect2 id="generating-documentation-from-interfaces">
      <title>Generating documentation from interfaces</title>
      <para>
        Whitespace and source code comments are removed during parsing
        and aren't significant in determining the semantics of the
        program. However, other tools in the OCaml distribution can
        interpret comments for their own ends.
      </para>
      <para>
        The <command>ocamldoc</command> tool uses specially formatted
        comments in the source code to generate documentation bundles.
        These comments are combined with the function definitions and
        signatures and output as structured documentation in a variety
        of formats. It can generate HTML pages, LaTeX and PDF documents,
        UNIX manual pages and even module dependency graphs that can be
        viewed using
        <ulink url="http://www.graphviz.org">Graphviz</ulink>.
      </para>
      <para>
        Here's a sample of some source code that's been annotated with
        <command>ocamldoc</command> comments.
      </para>
      <programlisting language="ocaml">
(** example.ml: The first special comment of the file is the comment 
    associated with the whole module. *)

(** Comment for exception My_exception. *)
exception My_exception of (int -&gt; int) * int

(** Comment for type [weather]  *)
type weather =
  | Rain of int (** The comment for construtor Rain *)
  | Sun         (** The comment for constructor Sun *)

(** Find the current weather for a country
    @author Anil Madhavapeddy
    @param location The country to get the weather for.
*)
let what_is_the_weather_in location =
  match location with
  | `Cambridge  -&gt; Rain 100
  | `New_york   -&gt; Rain 20
  | `California -&gt; Sun
</programlisting>
      <para>
        The <command>ocamldoc</command> comments are distinguished by
        beginning with the double asterisk. There are formatting
        conventions for the contents of the comment to mark metadata.
        For instance, the <literal>@tag</literal> fields mark specific
        properties such as the author of that section of code.
      </para>
      <para>
        Try compiling the HTML documentation and UNIX man pages by
        running <command>ocamldoc</command> over the source file.
      </para>
      <programlisting>
# running front-end/build_ocamldoc.out.sh
$ mkdir -p html man/man3
$ ocamldoc -html -d html doc.ml
$ ocamldoc -man -d man/man3 doc.ml
$ man -M man Doc
</programlisting>
      <para>
        You should now have HTML files inside the
        <literal>html/</literal> directory and also be able to view the
        UNIX manual pages held in <literal>man/man3</literal>. There are
        quite a few comment formats and options to control the output
        for the various backends. Refer to the
        <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual029.html">OCaml
        manual</ulink> for the complete list.
      </para>
      <tip>
      <title>
      Using custom <command>ocamldoc</command> generators
      </title>
      <para>
        The default HTML output stylesheets from
        <command>ocamldoc</command> are pretty spartan and distinctly
        Web 1.0. The tool supports plugging in custom documentation
        generators, and there are several available that provide
        prettier or more detailed output.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <ulink url="http://argot.x9c.fr/">Argot</ulink> is an
            enhanced HTML generator that supports code folding and
            searching by name or type definition.
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="https://gitorious.org/ocamldoc-generators/ocamldoc-generators">ocamldoc-generators</ulink>
            add support for Bibtex references within comments and
            generating literate documentation that embeds the code
            alongside the comments.
          </para>
        </listitem>
        <listitem>
          <para>
            JSON output is available via a custom
            <ulink url="https://github.com/xen-org/ocamldoc-json">generator</ulink>
            in Xen.
          </para>
        </listitem>
      </itemizedlist>
      </tip>
    </sect2>
  </sect1>
  <sect1 id="preprocessing-source-code">
    <title>Preprocessing source code</title>
    <para>
      One powerful feature in OCaml is a facility to extend the standard
      language grammar without having to modify the compiler. You can
      roughly think of it as a type-safe version to the
      <literal>cpp</literal> preprocessor used in C/C++ to control
      conditional compilation directives.
    </para>
    <para>
      The OCaml distribution includes a system called Camlp4 for writing
      extensible parsers. This provides some OCaml libraries that are
      used to define grammars and also dynamically loadable syntax
      extensions of such grammars. Camlp4 modules register new language
      keywords and later transform these keywords (or indeed, any
      portion of the input program) into conventional OCaml code that
      can be understood by the rest of the compiler.
    </para>
    <para>
      We've already seen several Core libraries that use Camlp4:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>Fieldslib</literal> generates first-class values that
          represent fields of a record.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>Sexplib</literal> to convert types to textual
          s-expressions.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>Bin_prot</literal> for efficient binary conversion
          and parsing.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      These libraries all extend the language in quite a minimal way by
      adding a <literal>with</literal> keyword to type declarations to
      signify that extra code should be generated from that declaration.
      For example, here's a trivial use of Sexplib and Fieldslib.
    </para>
    <programlisting language="ocaml">
(* front-end/type_conv_example.ml  *)
open Sexplib.Std

type t = {
  foo: int;
  bar: string
} with sexp, fields
</programlisting>
    <para>
      Compiling this code will normally give you a syntax error if you
      do so without Camlp4 since the <literal>with</literal> keyword
      isn't normally allowed after a type definition.
    </para>
    <programlisting>
# running front-end/build_type_conv_without_camlp4.out.sh
$ ocamlfind ocamlc -c type_conv_example.ml
File &quot;type_conv_example.ml&quot;, line 6, characters 2-6:
Error: Syntax error
</programlisting>
    <para>
      Now add in the syntax extension packages for
      <literal>fieldslib</literal> and <literal>sexplib</literal>, and
      everything will compile again.
    </para>
    <programlisting>
# running front-end/build_type_conv_with_camlp4.out.sh
$ ocamlfind ocamlc -c -syntax camlp4o -package sexplib.syntax -package fieldslib.syntax type_conv_example.ml
</programlisting>
    <para>
      We've specified a couple of additional flags here. The
      <literal>-syntax</literal> flag directs
      <command>ocamlfind</command> to add the <literal>-pp</literal>
      flag to the compiler command-line. This flag instructs the
      compiler to run the preprocessor during its parsing phase.
    </para>
    <para>
      The <literal>-package</literal> flag imports other OCaml
      libraries. The <literal>.syntax</literal> suffix in the package
      name is a convention that indicates these libraries are
      preprocessors that should be run during parsing. The syntax
      extension modules are dynamically loaded into the
      <command>camlp4o</command> command which rewrites the input source
      code into conventional OCaml code that has no trace of the new
      keywords. The compiler then compiles this transformed code with no
      knowledge of the preprocessor's actions.
    </para>
    <para>
      Both Fieldslib and Sexplib need this new <literal>with</literal>
      keyword, but they both can't register the same extension. Instead,
      a library called Type_conv provides the common extension framework
      for them to use. Type_conv registers the <literal>with</literal>
      grammar extension to Camlp4, and the OCamlfind packaging ensures
      that it's loaded before Variantslib or Sexplib.
    </para>
    <para>
      The two extensions generate boilerplate OCaml code based on the
      type definition at compilation time. This avoids the performance
      hit of doing the code generation dynamically and also doesn't
      require a Just-In-Time (JIT) runtime that can be a source of
      unpredictable dynamic behavior. Instead, all the extra code is
      simply generated at compilation time via Camlp4, and type
      information can be discarded from the runtime image.
    </para>
    <para>
      The syntax extensions accept an input AST and output a modified
      one. If you're not familiar with the Camlp4 module in question,
      how do you figure out what changes it's made to your code? The
      obvious way is to read the documentation that accompanies the
      extension. Another approach is to use the top-level to explore the
      extension's behavior or run Camlp4 manually yourself to see the
      transformation in action. We'll show you how to do both of these
      now.
    </para>
    <sect2 id="using-camlp4-interactively">
      <title>Using Camlp4 interactively</title>
      <para>
        The <literal>utop</literal> top-level can run the phrases that
        you type through <literal>camlp4</literal> automatically. You
        should have at least these lines in your
        <literal>~/.ocamlinit</literal> file in your home directory (see
        <xref linkend="installation"/> for more information).
      </para>
      <programlisting language="ocaml">
# script front-end/camlp4_toplevel.topscript
$ utop
# #use &quot;topfind&quot; ;; 

- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require &quot;package&quot;;;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates &quot;p,q,...&quot;;;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
# #camlp4o ;; 
</programlisting>
      <para>
        The first directive loads the <command>ocamlfind</command>
        top-level interface that lets you require
        <command>ocamlfind</command> packages (including all their
        dependent packages). The second directive instructs the
        top-level to filter all phrases via Camlp4. You can now run
        <literal>utop</literal> and load the syntax extensions in. We'll
        use the <literal>comparelib</literal> syntax extension for our
        experiments.
      </para>
      <para>
        OCaml provides a built-in polymorphic comparison operator that
        inspects the runtime representation of two values to see if
        they're equal. As we noted in
        <xref linkend="maps-and-hash-tables"/>, the
        polymorphic comparison is less efficient than defining explicit
        comparison functions between values. However, it quickly become
        tedious to manually define comparison functions for complex type
        definitions.
      </para>
      <para>
        Let's see how <literal>comparelib</literal> solves this problem
        by running it in <literal>utop</literal>.
      </para>
      <programlisting language="ocaml">
...part 1 of front-end/camlp4_toplevel.topscript
# #require &quot;comparelib.syntax&quot; ;; 
# type t = { foo: string; bar : t } ;; 
type t = { foo : string; bar : t; }
# type t = { foo: string; bar: t } with compare ;; 
type t = { foo : string; bar : t; }
val compare : t -&gt; t -&gt; int = &lt;fun&gt;
val compare_t : t -&gt; t -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        The first definition of <literal>t</literal> is a standard OCaml
        phrase and results in the expected output. The second one
        includes the <literal>with compare</literal> directive. This is
        intercepted by <literal>comparelib</literal> and transformed
        into the original type definition with two new functions also
        included.
      </para>
    </sect2>
    <sect2 id="running-camlp4-from-the-command-line">
      <title>Running Camlp4 from the command line</title>
      <para>
        The top-level is a quick way to examine the signatures generated
        from the extensions, but how can we see what these new functions
        actually do? You can't do this from <literal>utop</literal>
        directly since it embeds the Camlp4 invocation as an automated
        part of its operation.
      </para>
      <para>
        Let's turn to the command-line to obtain the result of the
        <literal>comparelib</literal> transformation instead. Create a
        file that contains the type declaration from earlier.
      </para>
      <programlisting language="ocaml">
(* front-end/comparelib_test.ml  *)
type t = { 
  foo: string; 
  bar: t
} with compare
</programlisting>
      <para>
        We need to run the Camlp4 binary with the library paths to
        Comparelib and Type_conv. Let's use a small shell script to wrap
        this invocation.
      </para>
      <programlisting language="bash">
#!/bin/sh
# front-end/camlp4_dump.cmd
#!/bin/sh

OCAMLFIND=&quot;ocamlfind query -predicates syntax,preprocessor -r&quot;
INCLUDE=`$OCAMLFIND -i-format comparelib.syntax`
ARCHIVES=`$OCAMLFIND -a-format comparelib.syntax`
camlp4o -printer o $INCLUDE $ARCHIVES $1
</programlisting>
      <para>
        The script uses the <command>ocamlfind</command> package manager
        to list the include and library paths needed by
        <literal>comparelib</literal>. It then invokes the
        <command>camlp4o</command> preprocessor with these paths and
        outputs the resulting AST to the standard output.
      </para>
      <programlisting>
# running front-end/process_comparelib_test.out.sh
$ sh camlp4_dump.cmd comparelib_test.ml
type t = { foo : string; bar : t }

let _ = fun (_ : t) -&gt; ()
  
let rec compare : t -&gt; t -&gt; int =
  fun a__001_ b__002_ -&gt;
    if Pervasives.( == ) a__001_ b__002_
    then 0
    else
      (let ret =
         (Pervasives.compare : string -&gt; string -&gt; int) a__001_.foo
           b__002_.foo
       in
         if Pervasives.( &lt;&gt; ) ret 0
         then ret
         else compare a__001_.bar b__002_.bar)
  
let _ = compare
  
let compare_t = compare
  
let _ = compare_t
  

</programlisting>
      <para>
        The output contains the original type definition accompanied by
        some automatically generated code that implements an explicit
        comparison function for each field in the record. If you're
        using the extension in your compiler command-line, this
        generated code is then compiled as if you had typed it in
        yourself.
      </para>
      <para>
        Note that although the generated code uses
        <literal>Pervasives.compare</literal>, it is also annotated with
        a <literal>string</literal> type. This lets the compiler use a
        specialized string comparison function and not actually call the
        runtime polymorphic comparison function. This has implications
        for correctness too: recall from
        <xref linkend="maps-and-hash-tables"/> that
        <literal>comparelib</literal> provides reliable comparison
        functions that work for values that are logically the same but
        that have differing internal representations (e.g.
        <literal>Int.Set.t</literal>).
      </para>
      <note>
      <title>
      A style note: wildcards in <literal>let</literal> bindings
      </title>
      <para>
        You may have noticed the <literal>let _ = fun</literal>
        construct in the autogenerated code above. The underscore in a
        <literal>let</literal> binding is just the same as a wildcard
        underscore in a pattern match, and tells the compiler to accept
        any return value and discard it immediately.
      </para>
      <para>
        This is fine for mechanically generated code from Type_conv, but
        should be avoided in code that you write by hand. If it's a
        unit-returning expression, then write a <literal>unit</literal>
        binding explicitly instead. This will cause a type error if the
        expression changes type in the future (<emphasis>e.g.</emphasis>
        due to code refactoring).
      </para>
      <programlisting language="html">
let () = &lt;expr&gt;
</programlisting>
      <para>
        If the expression has a different type, then write it
        explicitly.
      </para>
      <programlisting language="ocaml">
(* front-end/let_notunit.ml  *)
let (_:some_type) = &lt;expr&gt;
let () = ignore (&lt;expr&gt; : some_type)
)(* if the expression returns a unit Deferred.t *)
let () = don't_wait_for (&lt;expr&gt;
</programlisting>
      <para>
        The last one is used to ignore Async expressions that should run
        in the background rather than blocking in the current thread.
      </para>
      <para>
        One other important reason for using wildcard matches is to bind
        a variable name to something that you want to use in future
        code, but don't want to use right away. This would normally
        generate an &quot;unused value&quot; compiler warning. These
        warnings are suppressed for any variable name that's prepended
        with an underscore.
      </para>
      <programlisting language="ocaml">
(* front-end/unused_var.ml  *)
let fn x y =
  let _z = x + y in
  ()
</programlisting>
      <para>
        Although you don't use <literal>_z</literal> in your code, this
        will never generate an unused variable warning.
      </para>
      </note>
    </sect2>
    <sect2 id="preprocessing-module-signatures">
      <title>Preprocessing module signatures</title>
      <para>
        Another useful feature of <literal>type_conv</literal> is that
        it can generate module signatures too. Copy the earlier type
        definition into a <literal>comparelib_test.mli</literal> that's
        got exactly the same content.
      </para>
      <programlisting language="ocaml">
(* front-end/comparelib_test.mli  *)
type t = { 
  foo: string; 
  bar: t
} with compare
</programlisting>
      <para>
        If you rerun the Camlp4 dumper script now, you'll see that
        different code is produced for signature files.
      </para>
      <programlisting>
# running front-end/process_comparelib_interface.out.sh
$ sh camlp4_dump.cmd comparelib_test.mli
type t = { foo : string; bar : t }

val compare : t -&gt; t -&gt; int
  

</programlisting>
      <para>
        The external signature generated by
        <literal>comparelib</literal> is much simpler than the actual
        code. Running Camlp4 directly on the original source code lets
        you see these all these transformations precisely.
      </para>
      <caution>
      <title>
      Don't overdo the syntax extensions
      </title>
      <para>
        Syntax extensions are a powerful extension mechanism that can
        completely alter your source code's layout and style. Core
        includes a very conservative set of extensions that take care to
        minimize the syntax changes. There are a number of third-party
        libraries that are much more ambitious—some introduce
        whitespace-sensitive indentation, while others build entirely
        new embedded languages using OCaml as a host language, and yet
        others introduce conditional compilation for macros or optional
        logging.
      </para>
      <para>
        While it's tempting to compress all your boiler-plate code into
        Camlp4 extensions, it can make your source code much harder for
        other people to quickly read and understand. Core mainly focuses
        on type-driven code generation using the
        <literal>type_conv</literal> extension and doesn't fundamentally
        change the OCaml syntax.
      </para>
      <para>
        Another thing to consider before deploying your own syntax
        extension is compatibility with other extensions. Two separate
        extensions can create a grammar clash that leads to odd syntax
        errors and hard-to-reproduce bugs. That's why most of Core's
        syntax extensions go through <literal>type_conv</literal>, which
        acts as a single point for extending the grammar via the
        <literal>with</literal> keyword.
      </para>
      </caution>
    </sect2>
    <sect2 id="further-reading-on-camlp4">
      <title>Further reading on Camlp4</title>
      <para>
        We've deliberately only shown you how to use Camlp4 extensions
        here, and not how to build your own. The full details of
        building new extensions are fairly daunting and could be the
        subject of an entirely new book.
      </para>
      <para>
        The best resources to get started are:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            a series of
            <ulink url="http://ambassadortothecomputers.blogspot.co.uk/p/reading-camlp4.html">blog
            posts</ulink> by Jake Donham describe the internals of
            Camlp4 and its syntax extension mechanism.
          </para>
        </listitem>
        <listitem>
          <para>
            the online
            <ulink url="http://brion.inria.fr/gallium/index.php/Camlp4">Camlp4
            wiki</ulink>.
          </para>
        </listitem>
        <listitem>
          <para>
            using OPAM to install existing Camlp4 extensions and
            inspecting their source code.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
  <sect1 id="static-type-checking">
    <title>Static type checking</title>
    <para>
      After obtaining a valid abstract syntax tree, the compiler has to
      verify that the code obeys the rules of the OCaml type system.
      Code that is syntactically correct but misuses values is rejected
      with an explanation of the problem.
    </para>
    <para>
      Although type checking is done in a single pass in OCaml, it
      actually consists of three distinct steps that happen
      simultaneously:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          an <emphasis>automatic type inference</emphasis> algorithm
          that calculates types for a module without requiring manual
          type annotations.
        </para>
      </listitem>
      <listitem>
        <para>
          a <emphasis>module system</emphasis> that combines software
          components with explicit knowledge of their type signatures.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>explicit subtyping</emphasis> checks for objects and
          polymorphic variants.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Automatic type inference lets you write succinct code for a
      particular task and have the compiler ensure that your use of
      variables is locally consistent.
    </para>
    <para>
      Type inference doesn't scale to very large code bases that depend
      on separate compilation of files. A small change in one module may
      ripple through thousands of other files and libraries and require
      all of them to be recompiled. The module system solves this by
      providing the facility to combine and manipulate explicit type
      signatures for modules within a large project, and also to reuse
      them via functors and first-class modules.
    </para>
    <para>
      Subtyping in OCaml objects is always an explicit operation (via
      the <literal>:&gt;</literal> operator). This means that it doesn't
      complicate the core type inference engine and can be tested as a
      separate concern.
    </para>
    <sect2 id="displaying-inferred-types-from-the-compiler">
      <title>Displaying inferred types from the compiler</title>
      <para>
        We've already seen how you can explore type inference directly
        from the top-level. It's also possible to generate type
        signatures for an entire file by asking the compiler to do the
        work for you. Create a file with a single type definition and
        value.
      </para>
      <programlisting language="ocaml">
(* front-end/typedef.ml  *)
type t = Foo | Bar
let v = Foo
</programlisting>
      <para>
        Now run the compiler with the <literal>-i</literal> flag to
        infer the type signature for that file. This runs the type
        checker but doesn't compile the code any further after
        displaying the interface to the standard output.
      </para>
      <programlisting>
# running front-end/infer_typedef.out.sh
$ ocamlc -i typedef.ml
type t = Foo | Bar
val v : t
</programlisting>
      <para>
        The output is the default signature for the module which
        represents the input file. It's often useful to redirect this
        output to an <literal>mli</literal> file to give you a starting
        signature to edit the external interface without having to type
        it all in by hand.
      </para>
      <para>
        The compiler stores a compiled version of the interface as a
        <literal>cmi</literal> file. This interface is either obtained
        from compiling an <literal>mli</literal> signature file for a
        module, or by the inferred type if there is only an
        <literal>ml</literal> implementation present.
      </para>
      <para>
        The compiler makes sure that your <literal>ml</literal> and
        <literal>mli</literal> files have compatible signatures. The
        type checker throws an immediate error if this isn't the case.
      </para>
      <programlisting>
# running front-end/conflicting_interfaces.out.sh
$ echo type t = Foo &gt; test.ml
$ echo type t = Bar &gt; test.mli
$ ocamlc -c test.mli test.ml
File &quot;test.ml&quot;, line 1:
Error: The implementation test.ml does not match the interface test.cmi:
       Type declarations do not match:
         type t = Foo
       is not included in
         type t = Bar
       File &quot;test.ml&quot;, line 1, characters 5-12: Actual declaration
       Fields number 1 have different names, Foo and Bar.
</programlisting>
      <note>
      <title>
      Which comes first: the <literal>ml</literal> or the
      <literal>mli</literal>?
      </title>
      <para>
        There are two schools of thought on which order OCaml code
        should be written in. It's very easy to begin writing code by
        starting with an <literal>ml</literal> file and using the type
        inference to guide you as you build up your functions. The
        <literal>mli</literal> file can then be generated as described
        above, and the exported functions documented.
      </para>
      <para>
        If you're writing code that spans multiple files, it's sometimes
        easier to start by writing all the <literal>mli</literal>
        signatures and checking that they type check against each other.
        Once the signatures are in place, you can write the
        implementations with the confidence that they'll all glue
        together correctly with no cyclic dependencies between the
        modules.
      </para>
      <para>
        As with any such stylistic debate, you should experiment with
        which system works best for you. Everyone agrees on one thing
        though: no matter what order you write them, production code
        should always explicitly define an <literal>mli</literal> file
        for every <literal>ml</literal> file in the project. It's also
        perfectly fine to have an <literal>mli</literal> file without a
        corresponding <literal>ml</literal> file if you're only
        declaring signatures (such as module types).
      </para>
      <para>
        Signature files provide a place to write succinct documentation
        and to abstract internal details that shouldn't be exported.
        Maintaining separate signature files also speeds up incremental
        compilation in larger code-bases, since recompiling a
        <literal>mli</literal> signature is much faster than a full
        compilation of the implementation to native code.
      </para>
      </note>
    </sect2>
    <sect2 id="type-inference-1">
      <title>Type inference</title>
      <para>
        Type inference is the process of determining the appropriate
        types for expressions based on their use. It's a feature that's
        partially present in many other languages such as Haskell and
        Scala, but OCaml embeds it as a fundamental feature throughout
        the core language.
      </para>
      <para>
        OCaml type inference is based on the Hindley-Milner algorithm,
        which is notable for its ability to infer the most general type
        for an expression without requiring any explicit type
        annotations. The algorithm can deduce multiple types for an
        expression, and has the notion of a <emphasis>principal
        type</emphasis> that is the most general choice from the
        possible inferences. Manual type annotations can specialize the
        type explicitly, but the automatic inference selects the most
        general type unless told otherwise.
      </para>
      <para>
        OCaml does have some language extensions which strain the limits
        of principal type inference, but by and large most programs you
        write will never <emphasis>require</emphasis> annotations
        (although they sometimes help the compiler produce better error
        messages).
      </para>
      <sect3 id="adding-type-annotations-to-find-errors">
        <title>Adding type annotations to find errors</title>
        <para>
          It's often said that the hardest part of writing OCaml code is
          getting past the type checker—but once the code does compile,
          it works correctly the first time! This is an exaggeration of
          course, but it can certainly feel true when moving from a
          dynamically typed language. The OCaml static type system
          protects you from certain classes of bugs such as memory
          errors and abstraction violations by rejecting your program at
          compilation time rather than by generating an error at
          runtime. Learning how to navigate the type checker's
          compile-time feedback is key to building robust libraries and
          applications that take full advantage of these static checks.
        </para>
        <para>
          There are a couple of tricks to make it easier to quickly
          locate type errors in your code. The first is to introduce
          manual type annotations to narrow down the source of your
          error more accurately. These annotations shouldn't actually
          change your types and can be removed once your code is
          correct. However, they act as anchors to locate errors while
          you're still writing your code.
        </para>
        <para>
          Manual type annotations are particularly useful if you use
          lots of polymorphic variants or objects. Type inference with
          row polymorphism can generate some very large signatures, and
          errors tend to propagate more widely than if you are using
          more explicitly typed variants or classes.
        </para>
        <para>
          For instance, consider this broken example that expresses some
          simple algebraic operations over integers.
        </para>
        <programlisting language="ocaml">
(* front-end/broken_poly.ml  *)
let rec algebra =
  function
  | `Add (x,y) -&gt; (algebra x) + (algebra y)
  | `Sub (x,y) -&gt; (algebra x) - (algebra y)
  | `Mul (x,y) -&gt; (algebra x) * (algebra y)
  | `Num x     -&gt; x

let _ =
  algebra (
    `Add (
      (`Num 0),
      (`Sub (
          (`Num 1),
          (`Mul (
              (`Nu 3),(`Num 2)
            ))
        ))
    ))
</programlisting>
        <para>
          There's a single character typo in the code so that it uses
          <literal>Nu</literal> instead of <literal>Num</literal>. The
          resulting type error is impressive.
        </para>
        <programlisting>
# running front-end/build_broken_poly.out.sh
$ ocamlc -c broken_poly.ml
File &quot;broken_poly.ml&quot;, line 9, characters 10-154:
Error: This expression has type
         [&gt; `Add of
              ([&lt; `Add of 'a * 'a
                | `Mul of 'a * 'a
                | `Num of int
                | `Sub of 'a * 'a
                &gt; `Num ]
               as 'a) *
              [&gt; `Sub of 'a * [&gt; `Mul of [&gt; `Nu of int ] * [&gt; `Num of int ] ] ] ]
       but an expression was expected of type 'a
       The second variant type does not allow tag(s) `Nu
</programlisting>
        <para>
          The type error is perfectly accurate, but rather verbose and
          with a line number that doesn't point to the exact location of
          the incorrect variant name. The best the compiler can do is to
          point you in the general direction of the
          <literal>algebra</literal> function application.
        </para>
        <para>
          This is because the type checker doesn't have enough
          information to match the inferred type of the
          <literal>algebra</literal> definition to its application a few
          lines down. It calculates types for both expressions
          separately, and when they don't match up, outputs the
          difference as best it can.
        </para>
        <para>
          Let's see what happens with an explicit type annotation to
          help the compiler out.
        </para>
        <programlisting language="ocaml">
(* front-end/broken_poly_with_annot.ml  *)
type t = [
  | `Add of t * t
  | `Sub of t * t
  | `Mul of t * t
  | `Num of int
]

let rec algebra (x:t) =
  match x with
  | `Add (x,y) -&gt; (algebra x) + (algebra y)
  | `Sub (x,y) -&gt; (algebra x) - (algebra y)
  | `Mul (x,y) -&gt; (algebra x) * (algebra y)
  | `Num x     -&gt; x

let _ =
  algebra (
    `Add (
      (`Num 0),
      (`Sub (
          (`Num 1),
          (`Mul (
              (`Nu 3),(`Num 2)
            ))
        ))
    ))
</programlisting>
        <para>
          This code contains exactly the same error as before, but we've
          added a closed type definition of the polymorphic variants,
          and a type annotation to the <literal>algebra</literal>
          definition. The compiler error we get is much more useful now.
        </para>
        <programlisting>
# running front-end/build_broken_poly_with_annot.out.sh
$ ocamlc -i broken_poly_with_annot.ml
File &quot;broken_poly_with_annot.ml&quot;, line 22, characters 14-21:
Error: This expression has type [&gt; `Nu of int ]
       but an expression was expected of type t
       The second variant type does not allow tag(s) `Nu
</programlisting>
        <para>
          This error points directly to the correct line number that
          contains the typo. Once you fix the problem, you can remove
          the manual annotations if you prefer more succinct code. You
          can also leave the annotations there of course, to help with
          future refactoring and debugging.
        </para>
      </sect3>
      <sect3 id="enforcing-principal-typing">
        <title>Enforcing principal typing</title>
        <para>
          The compiler also has a stricter <emphasis>principal type
          checking</emphasis> mode that is activated via the
          <literal>-principal</literal> flag. This warns about risky
          uses of type information to ensure that the type inference has
          one principal result. A type is considered risky if the
          success or failure of type inference depends on the order in
          which sub-expressions are typed.
        </para>
        <para>
          The principality check only affects a few language features:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              polymorphic methods for objects.
            </para>
          </listitem>
          <listitem>
            <para>
              permuting the order of labeled arguments in a function
              from their type definition.
            </para>
          </listitem>
          <listitem>
            <para>
              discarding optional labeled arguments.
            </para>
          </listitem>
          <listitem>
            <para>
              generalized algebraic data types (GADTs) present from
              OCaml 4.0 onwards.
            </para>
          </listitem>
          <listitem>
            <para>
              automatic disambiguation of record field and constructor
              names (since OCaml 4.1)
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Here's an example of principality warnings when used with
          record disambiguation.
        </para>
        <programlisting language="ocaml">
(* front-end/non_principal.ml  *)
type s = { foo: int; bar: unit }
type t = { foo: int }

let f x =
  x.bar;
  x.foo
</programlisting>
        <para>
          Inferring the signature with <literal>-principal</literal>
          will show you a new warning.
        </para>
        <programlisting>
# running front-end/build_non_principal.out.sh
$ ocamlc -i -principal non_principal.ml
File &quot;non_principal.ml&quot;, line 6, characters 4-7:
Warning 18: this type-based field disambiguation is not principal.
type s = { foo : int; bar : unit; }
type t = { foo : int; }
val f : s -&gt; int
</programlisting>
        <para>
          This example isn't principal since the inferred type for
          <literal>x.foo</literal> is guided by the inferred type of
          <literal>x.bar</literal>, whereas principal typing requires
          that each sub-expression's type can be calculated
          independently. If the <literal>x.bar</literal> use is removed
          from the definition of <literal>f</literal>, its argument
          would be of type <literal>t</literal> and not
          <literal>type s</literal>.
        </para>
        <para>
          You can fix this either by permuting the order of the type
          declarations, or by adding an explicit type annotation.
        </para>
        <programlisting language="ocaml">
(* front-end/principal.ml  *)
type s = { foo: int; bar: unit }
type t = { foo: int }

let f (x:s) =
  x.bar;
  x.foo
</programlisting>
        <para>
          There is now no ambiguity about the inferred types, since
          we've explicitly given the argument a type and the order of
          inference of the sub-expressions no longer matters.
        </para>
        <programlisting>
# running front-end/build_principal.out.sh
$ ocamlc -i -principal principal.ml
type s = { foo : int; bar : unit; }
type t = { foo : int; }
val f : s -&gt; int
</programlisting>
        <para>
          The <command>ocamlbuild</command> equivalent is to add the tag
          <literal>principal</literal> to your build. The
          <literal>corebuild</literal> wrapper script actually adds this
          by default, but it does no harm to explicitly repeat it, as
          below.
        </para>
        <programlisting>
# running principal/build_principal.out.sh
$ corebuild -tag principal principal.cmi non_principal.cmi
File &quot;non_principal.ml&quot;, line 6, characters 4-7:
Warning 18: this type-based field disambiguation is not principal.
</programlisting>
        <para>
          Ideally, all code should systematically use
          <literal>-principal</literal>. It reduces variance in type
          inference and enforces the notion of a single known type.
          However, there are drawbacks to this mode: type inference is
          slower and the <literal>cmi</literal> files become larger.
          This is generally only a problem if you use objects
          extensively, which usually have larger type signature to cover
          all their methods.
        </para>
        <para>
          As a result, the suggested approach is to only compile with
          <literal>-principal</literal> occasionally to check if your
          code is compliant. If compiling in principal mode works, it is
          guaranteed that the program will pass type checking in
          non-principal mode too.
        </para>
        <para>
          Bear in mind that the <literal>cmi</literal> files generated
          in principal mode differ from the default mode. Try to ensure
          that you compile your whole project with it activated. Getting
          the files mixed up won't let you violate type safety, but can
          result in the type checker failing unexpectedly very
          occasionally. In this case, just recompile with a clean source
          tree.
        </para>
      </sect3>
    </sect2>
    <sect2 id="modules-and-separate-compilation">
      <title>Modules and separate compilation</title>
      <para>
        The OCaml module system enables smaller components to be reused
        effectively in large projects while still retaining all the
        benefits of static type safety. We covered the basics of using
        modules earlier in
        <xref linkend="files-modules-and-programs"/>. The
        module language that operates over these signatures also extends
        to functors and first-class modules, described in
        <xref linkend="functors"/> and
        <xref linkend="first-class-modules"/> respectively.
      </para>
      <para>
        This section discusses how the compiler implements them in more
        detail. Modules are essential for larger projects that consist
        of many source files (also known as <emphasis>compilation
        units</emphasis>). It's impractical to recompile every single
        source file when changing just one or two files, and the module
        system minimizes such recompilation while still encouraging code
        reuse.
      </para>
      <sect3 id="the-mapping-between-files-and-modules">
        <title>The mapping between files and modules</title>
        <para>
          Individual compilation units provide a convenient way to break
          up a big module hierarchy into a collection of files. The
          relationship between files and modules can be explained
          directly in terms of the module system.
        </para>
        <para>
          Create a file called <literal>alice.ml</literal> with the
          following contents.
        </para>
        <programlisting language="ocaml">
(* front-end/alice.ml  *)
let friends = [ Bob.name ]
</programlisting>
        <para>
          and a corresponding signature file.
        </para>
        <programlisting language="ocaml">
(* front-end/alice.mli  *)
val friends : Bob.t list
</programlisting>
        <para>
          These two files are exactly analogous to including the
          following code directly in another module that references
          <literal>Alice</literal>.
        </para>
        <programlisting language="ocaml">
(* front-end/alice_combined.ml  *)
module Alice : sig
  val friends : Bob.t list
end = struct
  let friends = [ Bob.name ]
end
</programlisting>
      </sect3>
      <sect3 id="defining-a-module-search-path">
        <title>Defining a module search path</title>
        <para>
          In the example above, <literal>Alice</literal> also has a
          reference to another module <literal>Bob</literal>. For the
          overall type of <literal>Alice</literal> to be valid, the
          compiler also needs to check that the <literal>Bob</literal>
          module contains at least a <literal>Bob.name</literal> value
          and defines a <literal>Bob.t</literal> type.
        </para>
        <para>
          The type checker resolves such module references into concrete
          structures and signatures in order to unify types across
          module boundaries. It does this by searching a list of
          directories for a compiled interface file matching that
          module's name. For example, it will look for
          <literal>alice.cmi</literal> and <literal>bob.cmi</literal> on
          the search path, and use the first ones it encounters as the
          interfaces for <literal>Alice</literal> and
          <literal>Bob</literal>.
        </para>
        <para>
          The module search path is set by adding <literal>-I</literal>
          flags to the compiler command-line with the directory
          containing the <literal>cmi</literal> files as the argument.
          Manually specifying these flags gets complex when you have
          lots of libraries, and is the reason why the OCamlfind
          frontend to the compiler exists. OCamlfind automates the
          process of turning third-party package names and build
          descriptions into command-line flags that are passed to the
          compiler command-line.
        </para>
        <para>
          By default, only the current directory and the OCaml standard
          library will be searched for <literal>cmi</literal> files. The
          <literal>Pervasives</literal> module from the standard library
          will also be opened by default in every compilation unit. The
          standard library location is obtained by running
          <literal>ocamlc -where</literal>, and can be overridden by
          setting the <literal>CAMLLIB</literal> environment variable.
          Needless to say, don't override the default path unless you
          have a good reason to (such as setting up a cross-compilation
          environment).
        </para>
        <sidebar>
        <title>
        Inspecting compilation units with
        <literal>ocamlobjinfo</literal>
        </title>
        <para>
          For separate compilation to be sound, we need to ensure that
          all the <literal>cmi</literal> files used to type-check a
          module are the same across compilation runs. If they vary,
          this raises the possibility of two modules checking different
          type signatures for a common module with the same name. This
          in turn lets the program completely violate the static type
          system and can lead to memory corruption and crashes.
        </para>
        <para>
          OCaml guards against this by recording a MD5 checksum in every
          <literal>cmi</literal>. Let's examine our earlier
          <literal>typedef.ml</literal> more closely.
        </para>
        <programlisting>
# running front-end/typedef_objinfo.out.sh
$ ocamlc -c typedef.ml
$ ocamlobjinfo typedef.cmi
File typedef.cmi
Unit name: Typedef
Interfaces imported:
    bd274dc132ce5c3d8b6774d19cd373a6    Typedef
    36b5bc8227dc9914c6d9fd9bdcfadb45    Pervasives
</programlisting>
        <para>
          <literal>ocamlobjinfo</literal> examines the compiled
          interface and displays what other compilation units it depends
          on. In this case, we don't use any external modules other than
          <literal>Pervasives</literal>. Every module depends on
          <literal>Pervasives</literal> by default, unless you use the
          <literal>-nopervasives</literal> flag (this is an advanced
          use-case, and you shouldn't normally need it).
        </para>
        <para>
          The long alphanumeric identifier beside each module name is a
          hash calculated from all the types and values exported from
          that compilation unit. It's used during type-checking and
          linking to ensure that all of the compilation units have been
          compiled consistently against each other. A difference in the
          hashes means that a compilation unit with the same module name
          may have conflicting type signatures in different modules. The
          compiler will reject such programs with an error similar to
          this:
        </para>
        <programlisting>
# running front-end/inconsistent_compilation_units.out.sh
$ ocamlc -c foo.ml
File &quot;foo.ml&quot;, line 1, characters 0-1:
Error: The files /home/build/bar.cmi
       and /usr/lib/ocaml/map.cmi make inconsistent assumptions
       over interface Map
</programlisting>
        <para>
          This hash check is very conservative, but ensures that
          separate compilation remains type-safe all the way up to the
          final link phase. Your build system should ensure that you
          never see the error messages above, but if you do run into it,
          just clean out your intermediate files and recompile from
          scratch.
        </para>
        </sidebar>
      </sect3>
    </sect2>
    <sect2 id="packing-modules-together">
      <title>Packing modules together</title>
      <para>
        The module-to-file mapping described so far rigidly enforces a
        1:1 mapping between a top-level module and a file. It's often
        convenient to split larger modules into separate files to make
        editing and version control easier, but still compile them all
        into a single OCaml module.
      </para>
      <para>
        The <literal>-pack</literal> compiler option accepts a list of
        compiled object files (<literal>.cmo</literal> in bytecode and
        <literal>.cmx</literal> for native code) and their associated
        <literal>.cmi</literal> compiled interfaces, and combines them
        into a single module that contains them as sub-modules of the
        output. Packing thus generates an entirely new
        <literal>.cmo</literal> (or <literal>.cmx</literal> file) and
        <literal>.cmi</literal> that includes the input modules.
      </para>
      <para>
        Packing for native code introduces an additional requirement:
        the modules that are intended to be packed must be compiled with
        the <literal>-for-pack</literal> argument that specifies the
        eventual name of the pack. The easiest way to handle packing is
        to let <command>ocamlbuild</command> figure out the command-line
        arguments for you, so let's try that out next with a simple
        example.
      </para>
      <para>
        First, create a couple of toy modules called
        <literal>A.ml</literal> and <literal>B.ml</literal> that contain
        a single value. You will also need a <literal>_tags</literal>
        file that adds the <literal>-for-pack</literal> option for the
        <literal>cmx</literal> files (but careful to exclude the pack
        target itself). Finally, the <literal>X.mlpack</literal> file
        contains the list of modules that are intended to be packed
        under module <literal>X</literal>. There are special rules in
        <command>ocamlbuild</command> that tell it how to map
        <literal>%.mlpack</literal> files to the packed
        <literal>%.cmx</literal> or <literal>%.cmo</literal> equivalent.
      </para>
      <programlisting>
((typ console)(name packing/show_files.out))
</programlisting>
      <para>
        You can now run <literal>corebuild</literal> to build the
        <literal>X.cmx</literal> file directly, but let's create a new
        module to link against <literal>X</literal> to complete the
        example.
      </para>
      <programlisting language="ocaml">
(* packing/test.ml  *)
let v = X.A.v
let w = X.B.w
</programlisting>
      <para>
        You can now compile this test module and see that its inferred
        interface is the result of using the packed contents of
        <literal>X</literal>. We further verify this by examining the
        imported interfaces in <literal>Test</literal> and confirming
        that neither <literal>A</literal> nor <literal>B</literal> are
        mentioned in there and that only the packed <literal>X</literal>
        module is used.
      </para>
      <programlisting>
# running packing/build_test.out.sh
$ corebuild test.inferred.mli test.cmi
$ cat _build/test.inferred.mli
val v : string
val w : int
$ ocamlobjinfo _build/test.cmi
File _build/test.cmi
Unit name: Test
Interfaces imported:
    906fc1b74451f0c24ceaa085e0f26e5f    Test
    36b5bc8227dc9914c6d9fd9bdcfadb45    Pervasives
    25f4b4e10ec64c56b2987f5900045fec    X
</programlisting>
      <warning>
      <title>
      Packing and search paths
      </title>
      <para>
        One very common build error that happens with packing is
        confusion resulting from building the packed
        <literal>cmi</literal> in the same directory as the sub-modules.
        When you add this directory to your module search path, the
        sub-modules are also visible. If you forget to include the
        top-level prefix (e.g <literal>X.A</literal>) and instead use a
        sub-module directly (<literal>A</literal>), then this will
        compile and link fine.
      </para>
      <para>
        However, the types of <literal>A</literal> and
        <literal>X.A</literal> are <emphasis>not</emphasis>
        automatically equivalent, and so the type checker will complain
        if you attempt to mix-and-match the packed and unpacked versions
        of the library.
      </para>
      <para>
        This mostly only happens with unit tests since they are built at
        the same time as the library. You can avoid it by being aware of
        the need to open the packed module from the test, or only using
        the library after it has been installed (and hence not exposing
        the intermediate compiled modules).
      </para>
      </warning>
    </sect2>
    <sect2 id="shorter-module-paths-in-type-errors">
      <title>Shorter module paths in type errors</title>
      <para>
        Core uses the OCaml module system quite extensively to provide a
        complete replacement standard library. It collects these modules
        into a single <literal>Std</literal> module which provides a
        single module that needs to be opened to import the replacement
        modules and functions.
      </para>
      <para>
        There's one downside to this approach: type errors suddenly get
        much more verbose. We can see this if you run the vanilla OCaml
        top-level (not <literal>utop</literal>).
      </para>
      <programlisting>
# running front-end/short_paths_1.out.sh
$ ocaml
# List.map print_endline &quot;&quot; ;;
Error: This expression has type string but an expression was expected of type
         string list
</programlisting>
      <para>
        This type error without <literal>Core.Std</literal> has a
        straightforward type error. When we switch to Core, though, it
        gets more verbose.
      </para>
      <programlisting>
# running front-end/short_paths_2.out.sh
$ ocaml
# open Core.Std ;;
# List.map ~f:print_endline &quot;&quot; ;;
Error: This expression has type string but an expression was expected of type
         'a Core.Std.List.t = 'a list
</programlisting>
      <para>
        The default <literal>List</literal> module in OCaml is
        overridden by <literal>Core.Std.List</literal>. The compiler
        does its best to show the type equivalence, but at the cost of a
        more verbose error message.
      </para>
      <para>
        The compiler can remedy this via a so-called &quot;short
        paths&quot; heuristic. This causes the compiler to search all
        the type aliases for the shortest module path, and use that as
        the preferred output type. The option is activated by passing
        <literal>-short-paths</literal> to the compiler, and works on
        the top-level too.
      </para>
      <programlisting>
# running front-end/short_paths_3.out.sh
$ ocaml -short-paths
# open Core.Std;;
# List.map ~f:print_endline &quot;foo&quot;;;
Error: This expression has type string but an expression was expected of type
         'a list
</programlisting>
      <para>
        The <literal>utop</literal> enhanced top-level activates short
        paths by default, which is why you've not had to do this before
        in our interactive examples. However, the compiler doesn't
        default to the short path heuristic since there are some
        situations where the type aliasing information is useful to
        know, and would be lost in the error if the shortest module path
        is always picked.
      </para>
      <para>
        You'll need to choose for yourself if you prefer short paths or
        the default behavior in your own projects, and pass the
        <literal>-short-paths</literal> flag to the compiler if you need
        it.
      </para>
    </sect2>
  </sect1>
  <sect1 id="the-typed-syntax-tree">
    <title>The typed syntax tree</title>
    <para>
      When the type checking process has successfully completed, it is
      combined with the AST to form a <emphasis>typed abstract syntax
      tree</emphasis>. This contains precise location information for
      every token in the input file, and decorates each token with
      concrete type information.
    </para>
    <para>
      The compiler can output this as compiled <literal>cmt</literal>
      and <literal>cmti</literal> files that contain the typed AST for
      the implementation and signatures of a compilation unit. This is
      activated by passing the <literal>-bin-annot</literal> flag to the
      compiler.
    </para>
    <para>
      The <literal>cmt</literal> files are particularly useful for IDE
      tools to match up OCaml source code at a specific location to the
      inferred or external types.
    </para>
    <sect2 id="using-ocp-index-for-auto-completion">
      <title>Using ocp-index for auto-completion</title>
      <para>
        One such command-line tool to display auto-completion
        information in your editor is <literal>ocp-index</literal>.
        Install it via OPAM as follows.
      </para>
      <programlisting>
# running front-end/install_ocp_index.out.sh
$ opam install ocp-index
$ ocp-index
</programlisting>
      <para>
        Let's refer back to our Ncurses binding example from the
        beginning of
        <xref linkend="foreign-function-interface"/>. This
        module defined bindings for the Ncurses library. First, compile
        the interfaces with <literal>-bin-annot</literal> so that we can
        obtain the <literal>cmt</literal> and <literal>cmti</literal>
        files, and then run <literal>ocp-index</literal> in completion
        mode.
      </para>
      <programlisting language="ocaml">
(* ocp-index/index_ncurses.out  *)
$ corebuild -pkg ctypes.foreign -tag bin_annot ncurses.cmi
$ ocp-index complete -I . Ncur
Ncurses module
$ ocp-index complete -I . Ncurses.a
Ncurses.addstr val string -&gt; unit
$ ocp-index complete -I . Ncurses.
Ncurses.window val Ncurses.window Ctypes.typ
Ncurses.wrefresh val Ncurses.window -&gt; unit
Ncurses.initscr val unit -&gt; Ncurses.window
Ncurses.endwin val unit -&gt; unit
Ncurses.refresh val unit -&gt; unit
Ncurses.newwin val int -&gt; int -&gt; int -&gt; int -&gt; Ncurses.window
Ncurses.mvwaddch val Ncurses.window -&gt; int -&gt; int -&gt; char -&gt; unit
Ncurses.mvwaddstr val Ncurses.window -&gt; int -&gt; int -&gt; string -&gt; unit
Ncurses.addstr val string -&gt; unit
Ncurses.box val Ncurses.window -&gt; char -&gt; char -&gt; unit
Ncurses.cbreak val unit -&gt; int
</programlisting>
      <para>
        You need to pass
        <literal>ocp-indexz a set of directories to search for</literal>cmt`
        files in, and a fragment of text to autocomplete. As you can
        imagine, autocompletion is invaluable on larger codebases. See
        the
        <ulink url="https://github.com/ocamlpro/ocp-index">ocp-index</ulink>
        homepage for more information on how to integrate it with your
        favorite editor.
      </para>
    </sect2>
    <sect2 id="examining-the-typed-syntax-tree-directly">
      <title>Examining the typed syntax tree directly</title>
      <para>
        The compiler has a couple of advanced flags that can dump the
        raw output of the internal AST representation. You can't depend
        on these flags to give the same output across compiler
        revisions, but they are a useful learning tool.
      </para>
      <para>
        We'll use our toy <literal>typedef.ml</literal> again.
      </para>
      <programlisting language="ocaml">
(* front-end/typedef.ml  *)
type t = Foo | Bar
let v = Foo
</programlisting>
      <para>
        Let's first look at the untyped syntax tree that's generated
        from the parsing phase.
      </para>
      <programlisting>
# running front-end/parsetree_typedef.out.sh
$ ocamlc -dparsetree typedef.ml 2&gt;&amp;1
[
  structure_item (typedef.ml[1,0+0]..[1,0+18])
    Pstr_type
    [
      &quot;t&quot; (typedef.ml[1,0+5]..[1,0+6])
        type_declaration (typedef.ml[1,0+5]..[1,0+18])
          ptype_params =
            []
          ptype_cstrs =
            []
          ptype_kind =
            Ptype_variant
              [
                (typedef.ml[1,0+9]..[1,0+12])
                  &quot;Foo&quot; (typedef.ml[1,0+9]..[1,0+12])
                  []
                  None
                (typedef.ml[1,0+15]..[1,0+18])
                  &quot;Bar&quot; (typedef.ml[1,0+15]..[1,0+18])
                  []
                  None
              ]
          ptype_private = Public
          ptype_manifest =
            None
    ]
  structure_item (typedef.ml[2,19+0]..[2,19+11])
    Pstr_value Nonrec
    [
      &lt;def&gt;
        pattern (typedef.ml[2,19+4]..[2,19+5])
          Ppat_var &quot;v&quot; (typedef.ml[2,19+4]..[2,19+5])
        expression (typedef.ml[2,19+8]..[2,19+11])
          Pexp_construct &quot;Foo&quot; (typedef.ml[2,19+8]..[2,19+11])
          None
          false
    ]
]

</programlisting>
      <para>
        This is rather a lot of output for a simple two-line program,
        but it shows just how much structure the OCaml parser generates
        even from a small source file.
      </para>
      <para>
        Each portion of the AST is decorated with the precise location
        information (including the filename and character location of
        the token). This code hasn't been type checked yet, and so the
        raw tokens are all included.
      </para>
      <para>
        The typed AST that is normally output as a compiled
        <literal>cmt</literal> file can be displayed in a more
        developer-readable form via the <literal>-dtypedtree</literal>
        option.
      </para>
      <programlisting>
# running front-end/typedtree_typedef.out.sh
$ ocamlc -dtypedtree typedef.ml 2&gt;&amp;1
[
  structure_item (typedef.ml[1,0+0]..typedef.ml[1,0+18])
    Pstr_type
    [
      t/1008
        type_declaration (typedef.ml[1,0+5]..typedef.ml[1,0+18])
          ptype_params =
            []
          ptype_cstrs =
            []
          ptype_kind =
            Ptype_variant
              [
                &quot;Foo/1009&quot;
                  []
                &quot;Bar/1010&quot;
                  []
              ]
          ptype_private = Public
          ptype_manifest =
            None
    ]
  structure_item (typedef.ml[2,19+0]..typedef.ml[2,19+11])
    Pstr_value Nonrec
    [
      &lt;def&gt;
        pattern (typedef.ml[2,19+4]..typedef.ml[2,19+5])
          Ppat_var &quot;v/1011&quot;
        expression (typedef.ml[2,19+8]..typedef.ml[2,19+11])
          Pexp_construct &quot;Foo&quot;
          []
          false
    ]
]

</programlisting>
      <para>
        The typed AST is more explicit than the untyped syntax tree. For
        instance, the type declaration has been given a unique name
        (<literal>t/1008</literal>), as has the <literal>v</literal>
        value (<literal>v/1011</literal>).
      </para>
      <para>
        You'll rarely need to look at this raw output from the compiler
        unless you're building IDE tools such as
        <literal>ocp-index</literal>, or are hacking on extensions to
        the core compiler itself. However, it's useful to know that this
        intermediate form exists before we delve further into the code
        generation process next in
        <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.
      </para>
    </sect2>
  </sect1>
</chapter><chapter id="the-compiler-backend-byte-code-and-native-code">
  <title>The Compiler Backend: Byte-code and Native-code</title>
  <para>
    Once OCaml has passed the type checking stage, it can stop emitting
    syntax and type errors and begin the process of compiling the
    well-formed modules into executable code.
  </para>
  <para>
    In this chapter, we'll cover the following topics:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        the untyped intermediate lambda code where pattern matching is
        optimized.
      </para>
    </listitem>
    <listitem>
      <para>
        the bytecode <command>ocamlc</command> compiler and
        <command>ocamlrun</command> interpreter.
      </para>
    </listitem>
    <listitem>
      <para>
        the native code <command>ocamlopt</command> code generator, and
        debugging and profiling native code.
      </para>
    </listitem>
  </itemizedlist>
  <sect1 id="the-untyped-lambda-form">
    <title>The untyped lambda form</title>
    <para>
      The first code generation phase eliminates all the static type
      information into a simpler intermediate <emphasis>lambda
      form</emphasis>. The lambda form discards higher-level constructs
      such as modules and objects and replaces them with simpler values
      such as records and function pointers. Pattern matches are also
      analyzed and compiled into highly optimized automata.
    </para>
    <para>
      The lambda form is the key stage that discards the OCaml type
      information and maps the source code to the runtime memory model
      described in
      <xref linkend="memory-representation-of-values"/>. This
      stage also performs some optimizations, most notably converting
      pattern match statements into more optimized but low-level
      statements.
    </para>
    <sect2 id="pattern-matching-optimization">
      <title>Pattern matching optimization</title>
      <para>
        The compiler dumps the lambda form in an s-expression syntax if
        you add the <literal>-dlambda</literal> directive to the
        command-line. Let's use this to learn more about how the OCaml
        pattern matching engine works by building three different
        pattern matches and comparing their lambda forms.
      </para>
      <para>
        Let's start by creating a straightforward exhaustive pattern
        match using four normal variants.
      </para>
      <programlisting language="ocaml">
(* back-end/pattern_monomorphic_large.ml  *)
type t = | Alice | Bob | Charlie | David

let test v =
  match v with
  | Alice   -&gt; 100
  | Bob     -&gt; 101
  | Charlie -&gt; 102
  | David   -&gt; 103
</programlisting>
      <para>
        The lambda output for this code looks like this.
      </para>
      <programlisting>
# running back-end/lambda_for_pattern_monomorphic_large.out.sh
$ ocamlc -dlambda -c pattern_monomorphic_large.ml 2&gt;&amp;1
(setglobal Pattern_monomorphic_large!
  (let
    (test/1013
       (function v/1014
         (switch* v/1014
          case int 0: 100
          case int 1: 101
          case int 2: 102
          case int 3: 103)))
    (makeblock 0 test/1013)))
</programlisting>
      <para>
        It's not important to understand every detail of this internal
        form and it is explicitly undocumented since it can change
        across compiler revisions. Despite these caveats, some
        interesting points emerge from reading it.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            There are no mention of modules or types any more. Global
            values are created via <literal>setglobal</literal> and
            OCaml values are constructed by
            <literal>makeblock</literal>. The blocks are the runtime
            values you should remember from
            <xref linkend="memory-representation-of-values"/>.
          </para>
        </listitem>
        <listitem>
          <para>
            The pattern match has turned into a switch case that jumps
            to the right case depending on the header tag of
            <literal>v</literal>. Recall that variants without
            parameters are stored in memory as integers in the order
            which they appear. The pattern matching engine knows this
            and has transformed the pattern into an efficient jump
            table.
          </para>
        </listitem>
        <listitem>
          <para>
            Values are addressed by a unique name that distinguished
            shadowed values by appending a number
            (<emphasis>e.g.</emphasis> <literal>v/1014</literal>). The
            type safety checks in the earlier phase ensure that these
            low-level accesses never violate runtime memory safety, so
            this layer doesn't do any dynamic checks. Unwise use of
            unsafe features such as the <literal>Obj.magic</literal>
            module can still easily induce crashes at this level.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The compiler computes a jump table in order to handle all four
        cases. If we drop the number of variants to just two, then
        there's no need for the complexity of computing this table.
      </para>
      <programlisting language="ocaml">
(* back-end/pattern_monomorphic_small.ml  *)
type t = | Alice | Bob 

let test v =
  match v with
  | Alice   -&gt; 100
  | Bob     -&gt; 101
</programlisting>
      <para>
        The lambda output for this code is now quite different.
      </para>
      <programlisting language="ocaml">
(* back-end/lambda_for_pattern_monomorphic_small.out  *)
$ ocamlc -dlambda -c pattern_monomorphic_small.ml 2&gt;&amp;1
(setglobal Pattern_monomorphic_small!
  (let (test/1011 (function v/1012 (if (!= v/1012 0) 101 100)))
    (makeblock 0 test/1011)))
</programlisting>
      <para>
        The compiler emits simpler conditional jumps rather than setting
        up a jump table, since it statically determines that the range
        of possible variants is small enough. Finally, let's look at the
        same code, but with polymorphic variants instead of normal
        variants.
      </para>
      <programlisting language="ocaml">
(* back-end/pattern_polymorphic.ml  *)
let test v =
  match v with
  | `Alice   -&gt; 100
  | `Bob     -&gt; 101
  | `Charlie -&gt; 102
  | `David   -&gt; 103
  | `Eve     -&gt; 104
</programlisting>
      <para>
        The lambda form for this also shows up the runtime
        representation of polymorphic variants.
      </para>
      <programlisting language="ocaml">
(* back-end/lambda_for_pattern_polymorphic.out  *)
$ ocamlc -dlambda -c pattern_polymorphic.ml 2&gt;&amp;1
(setglobal Pattern_polymorphic!
  (let
    (test/1008
       (function v/1009
         (if (&gt;= v/1009 482771474) (if (&gt;= v/1009 884917024) 100 102)
           (if (&gt;= v/1009 3306965) 101 103))))
    (makeblock 0 test/1008)))
</programlisting>
      <para>
        We mentioned earlier in <xref linkend="variants"/>
        that pattern matching over polymorphic variants is slightly less
        efficient, and it should be clearer why this is the case now.
        Polymorphic variants have a runtime value that's calculated by
        hashing the variant name, and so the compiler can't use a jump
        table as it does for normal variants. Instead, it creates a
        decision tree that compares the hash values against the input
        variable in as few comparisons as possible.
      </para>
      <note>
      <title>
      Learning more about pattern matching compilation
      </title>
      <para>
        Pattern matching is an important part of OCaml programming.
        You'll often encounter deeply nested pattern matches over
        complex data structures in real code. A good paper that
        describes the fundamental algorithms implemented in OCaml is
        <ulink url="http://dl.acm.org/citation.cfm?id=507641">&quot;Optimizing
        pattern matching&quot;</ulink> by Fabrice Le Fessant and Luc
        Maranget.
      </para>
      <para>
        The paper describes the backtracking algorithm used in classical
        pattern matching compilation, and also several OCaml-specific
        optimizations such as the use of exhaustiveness information and
        control flow optimizations via static exceptions.
      </para>
      <para>
        It's not essential that you understand all of this just to use
        pattern matching of course, but it'll give you insight as to why
        pattern matching is such a lightweight language construct to use
        in OCaml code.
      </para>
      </note>

    </sect2>
    <sect2 id="benchmarking-pattern-matching">
      <title>Benchmarking pattern matching</title>
      <para>
        Let's benchmark these three pattern matching techniques to
        quantify their runtime costs more accurately. The
        <literal>Core_bench</literal> module runs the tests thousands of
        times and also calculates statistical variance of the results.
        You'll need to <literal>opam install core_bench</literal> to get
        the library.
      </para>
      <programlisting language="ocaml">
(* back-end-bench/bench_patterns.ml  *)
open Core.Std
open Core_bench.Std

type t = | Alice | Bob 
type s = | A | B | C | D | E

let polymorphic_pattern () =
  let test v =
    match v with
    | `Alice   -&gt; 100
    | `Bob     -&gt; 101
    | `Charlie -&gt; 102
    | `David   -&gt; 103
    | `Eve     -&gt; 104
  in
  List.iter ~f:(fun v -&gt; ignore(test v))
    [`Alice; `Bob; `Charlie; `David]

let monomorphic_pattern_small () =
  let test v =
    match v with
    | Alice   -&gt; 100
    | Bob     -&gt; 101 in
  List.iter ~f:(fun v -&gt; ignore(test v))
    [ Alice; Bob ]

let monomorphic_pattern_large () =
  let test v =
    match v with
    | A       -&gt; 100
    | B       -&gt; 101
    | C       -&gt; 102
    | D       -&gt; 103
    | E       -&gt; 104
  in
  List.iter ~f:(fun v -&gt; ignore(test v))
    [ A; B; C; D ]

let tests = [
  &quot;Polymorphic pattern&quot;, polymorphic_pattern;
  &quot;Monomorphic larger pattern&quot;, monomorphic_pattern_large;
  &quot;Monomorphic small pattern&quot;, monomorphic_pattern_small;
]

let () =
  List.map tests ~f:(fun (name,test) -&gt; Bench.Test.create ~name test)
  |&gt; Bench.make_command
  |&gt; Command.run
</programlisting>
      <para>
        Building and executing this example will run for around 30
        seconds by default, and you'll see the results summarized in a
        neat table.
      </para>
      <programlisting>
# running back-end-bench/run_bench_patterns.out.sh
$ corebuild -pkg core_bench bench_patterns.native
$ ./bench_patterns.native -ascii
Estimated testing time 30s (change using -quota SECS).
                                                     
  Name                         Time (ns)   % of max  
 ---------------------------- ----------- ---------- 
  Polymorphic pattern              31.58     100.00  
  Monomorphic larger pattern       29.24      92.58  
  Monomorphic small pattern        16.15      51.14  
                                                     
</programlisting>
      <para>
        These results confirm our earlier performance hypothesis
        obtained from inspecting the lambda code. The shortest running
        time comes from the small conditional pattern match and
        polymorphic variant pattern matching is the slowest. There isn't
        a hugely significant difference in these examples, but you can
        use the same techniques to peer into the innards of your own
        source code and narrow down any performance hotspots.
      </para>
      <para>
        The lambda form is primarily a stepping stone to the bytecode
        executable format that we'll cover next. It's often easier to
        look at the textual output from this stage than to wade through
        the native assembly code from compiled executables.
      </para>
    </sect2>
  </sect1>
  <sect1 id="generating-portable-bytecode">
    <title>Generating portable bytecode</title>
    <para>
      After the lambda form has been generated, we are very close to
      having executable code. The OCaml tool-chain branches into two
      separate compilers at this point. We'll describe the bytecode
      compiler first, which consists of two pieces:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <command>ocamlc</command> compiles files into a bytecode that
          is a close mapping to the lambda form.
        </para>
      </listitem>
      <listitem>
        <para>
          <command>ocamlrun</command> is a portable interpreter that
          executes the bytecode.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The big advantage of using bytecode is simplicity, portability and
      compilation speed. The mapping from the lambda form to bytecode is
      straightforward, and this results in predictable (but slow)
      execution speed.
    </para>
    <para>
      The bytecode interpreter implements a stack-based virtual machine.
      The OCaml stack and an associated accumulator stores values that
      consist of:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis>long</emphasis> values corresponding to an OCaml
          <literal>int</literal> type.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>block</emphasis> values that contain the block
          header and a memory address with the data fields that contain
          further OCaml values indexed by an integer.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>code offset</emphasis> values that are relative to
          the starting code address.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The interpreter virtual machine only has seven registers in total:
      the program counter, stack pointer, accumulator, exception and
      argument pointers, and environment and global data. You can
      display the bytecode instructions in textual form via
      <literal>-dinstr</literal>. Try this on one of our earlier pattern
      matching examples.
    </para>
    <programlisting>
# running back-end/instr_for_pattern_monomorphic_small.out.sh
$ ocamlc -dinstr pattern_monomorphic_small.ml 2&gt;&amp;1
    branch L2
L1: acc 0
    push
    const 0
    neqint
    branchifnot L3
    const 101
    return 1
L3: const 100
    return 1
L2: closure L1, 0
    push
    acc 0
    makeblock 1, 0
    pop 1
    setglobal Pattern_monomorphic_small!

</programlisting>
    <para>
      The bytecode above has been simplified from the lambda form into a
      set of simple instructions that are executed serially by the
      interpreter.
    </para>
    <para>
      There are around 140 instructions in total, but most are just
      minor variants of commonly encountered operations
      (<emphasis>e.g.</emphasis> function application at a specific
      arity). You can find full details
      <ulink url="http://cadmium.x9c.fr/distrib/caml-instructions.pdf">online</ulink>.
    </para>
    <note>
    <title>
    Where did the bytecode instruction set come from?
    </title>
    <para>
      The bytecode interpreter is much slower than compiled native code,
      but is still remarkably performant for an interpreter without a
      JIT compiler. Its efficiency can be traced back to Xavier Leroy's
      ground-breaking work in 1990 on
      <ulink url="http://hal.inria.fr/docs/00/07/00/49/PS/RT-0117.ps">&quot;The
      ZINC experiment: An Economical Implementation of the ML
      Language&quot;</ulink>.
    </para>
    <para>
      This paper laid the theoretical basis for the implementation of an
      instruction set for a strictly evaluated functional language such
      as OCaml. The bytecode interpreter in modern OCaml is still based
      on the ZINC model. The native code compiler uses a different model
      since it uses CPU registers for function calls instead of always
      passing arguments on the stack as the bytecode interpreter does.
    </para>
    <para>
      Understanding the reasoning behind the different implementations
      of the bytecode interpreter and the native compiler is a very
      useful exercise for any budding language hacker.
    </para>
    </note>
    <sect2 id="compiling-and-linking-bytecode">
      <title>Compiling and linking bytecode</title>
      <para>
        The <command>ocamlc</command> command compiles individual
        <literal>ml</literal> files into bytecode files that have a
        <literal>cmo</literal> extension. The compiled bytecode files
        are matched with the associated <literal>cmi</literal> interface
        which contains the type signature exported to other compilation
        units.
      </para>
      <para>
        A typical OCaml library consists of multiple source files, and
        hence multiple <literal>cmo</literal> files that all need to be
        passed as command-line arguments to use the library from other
        code. The compiler can combine these multiple files into a more
        convenient single archive file by using the
        <literal>-a</literal> flag. Bytecode archives are denoted by the
        <literal>cma</literal> extension.
      </para>
      <para>
        The individual objects in the library are linked as regular
        <literal>cmo</literal> files in the order specified when the
        library file was built. If an object file within the library
        isn't referenced elsewhere in the program, then it isn't
        included in the final binary unless the
        <literal>-linkall</literal> flag forces its inclusion. This
        behavior is analogous to how C handles object files and archives
        (<literal>.o</literal> and <literal>.a</literal> respectively).
      </para>
      <para>
        The bytecode files are then linked together with the OCaml
        standard library to produce an executable program. The order in
        which <literal>.cmo</literal> arguments are presented on the
        command line defines the order in which compilation units are
        initialized at runtime. Remember that OCaml has no single
        <literal>main</literal> function like C, so this link order is
        more important than in C programs.
      </para>
    </sect2>
    <sect2 id="executing-bytecode">
      <title>Executing bytecode</title>
      <para>
        The bytecode runtime comprises three parts: the bytecode
        interpreter, garbage collector, and a set of C functions that
        implement the primitive operations. The bytecode contains
        instructions to call these C functions when required.
      </para>
      <para>
        The OCaml linker produces bytecode that targets the standard
        OCaml runtime by default, and so needs to know about any C
        functions that are referenced from other libraries that aren't
        loaded by default.
      </para>
      <para>
        Information about these extra libraries can be specified while
        linking a bytecode archive.
      </para>
      <programlisting>
# running back-end-embed/link_dllib.out.sh
$ ocamlc -a -o mylib.cma a.cmo b.cmo -dllib -lmylib
</programlisting>
      <para>
        The <literal>dllib</literal> flag embeds the arguments in the
        archive file. Any subsequent packages linking this archive will
        also include the extra C linking directive. This in turn lets
        the interpreter dynamically load the external library symbols
        when it executes the bytecode.
      </para>
      <para>
        You can also generate a complete standalone executable that
        bundles the <command>ocamlrun</command> interpreter with the
        bytecode in a single binary. This is known as a <emphasis>custom
        runtime</emphasis> mode and is built as follows.
      </para>
      <programlisting>
# running back-end-embed/link_custom.out.sh
$ ocamlc -a -o mylib.cma -custom a.cmo b.cmo -cclib -lmylib
</programlisting>
      <para>
        OCamlbuild takes care of much of the details of this with its
        built-in rules. The <literal>%.byte</literal> rule that you've
        been using throughout the book builds a bytecode executable and
        adding the <literal>custom</literal> tag will bundle the
        interpreter with it too.
      </para>
      <para>
        The custom mode is the most similar mode to native code
        compilation, as both generate standalone executables. There are
        quite a few other options available for compiling bytecode
        (notably with shared libraries or building custom runtimes).
        Full details can be found in the
        <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual022.html">manual</ulink>.
      </para>
    </sect2>
    <sect2 id="embedding-ocaml-bytecode-in-c">
      <title>Embedding OCaml bytecode in C</title>
      <para>
        A consequence of using the bytecode compiler is that the final
        link phase must be performed by <command>ocamlc</command>.
        However, you might sometimes want to embed your OCaml code
        inside an existing C application. OCaml also supports this mode
        of operation via the <literal>-output-obj</literal> directive.
      </para>
      <para>
        This mode causes <command>ocamlc</command> to output a C object
        file that containing the bytecode for the OCaml part of the
        program, as well as a <literal>caml_startup</literal> function.
        All of the OCaml modules are linked into this object file as
        bytecode, just as they would be for an executable.
      </para>
      <para>
        This object file can then be linked with C code using the
        standard C compiler, and only needs the bytecode runtime library
        (which is installed as <literal>libcamlrun.a</literal>).
        Creating an executable just requires you to link the runtime
        library with the bytecode object file. Here's an example to show
        how it all fits together.
      </para>
      <para>
        Create two OCaml source files that contain a single print line.
      </para>
      <programlisting language="ocaml">
(* back-end-embed/embed_me1.ml  *)
let () = print_endline &quot;hello embedded world 1&quot;
</programlisting>
      <programlisting language="ocaml">
(* back-end-embed/embed_me2.ml  *)
let () = print_endline &quot;hello embedded world 2&quot;
</programlisting>
      <para>
        Next, create a C file which will be your main entry point.
      </para>
      <programlisting language="c">
#include &lt;stdio.h&gt;
#include &lt;caml/alloc.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/memory.h&gt;
#include &lt;caml/callback.h&gt;

int 
main (int argc, char **argv)
{
  printf(&quot;Before calling OCaml\n&quot;);
  fflush(stdout);
  caml_startup (argv);
  printf(&quot;After calling OCaml\n&quot;);
  return 0;
}
</programlisting>
      <para>
        Now compile the OCaml files into a standalone object file.
      </para>
      <programlisting>
# running back-end-embed/build_embed.out.sh
$ rm -f embed_out.c
$ ocamlc -output-obj -o embed_out.o embed_me1.ml embed_me2.ml
</programlisting>
      <para>
        After this point, you no longer need the OCaml compiler, as
        <literal>embed_out.o</literal> has all of the OCaml code
        compiled and linked into a single object file. Compile an output
        binary using <literal>gcc</literal> to test this out.
      </para>
      <programlisting>
# running back-end-embed/build_embed_binary.out.sh
$ gcc -fPIC -Wall -I`ocamlc -where` -L`ocamlc -where` -ltermcap -lm -ldl -o finalbc.native main.c embed_out.o -lcamlrun
$ ./finalbc.native
Before calling OCaml
hello embedded world 1
hello embedded world 2
After calling OCaml
</programlisting>
      <para>
        You can inspect the commands that <command>ocamlc</command> is
        invoking by adding <literal>-verbose</literal> to the command
        line to help figure out the GCC command-line if you get stuck.
        You can even obtain the C source code to the
        <literal>-output-obj</literal> result by specifying a
        <literal>.c</literal> output file extension instead of the
        <literal>.o</literal> we used earlier.
      </para>
      <programlisting>
# running back-end-embed/build_embed_c.out.sh
$ ocamlc -output-obj -o embed_out.c embed_me1.ml embed_me2.ml
</programlisting>
      <para>
        Embedding OCaml code like this lets you write OCaml that
        interfaces with any environment that works with a C compiler.
        You can even cross back from the C code into OCaml by using the
        <literal>Callback</literal> module to register named entry
        points in the OCaml code. This is explained in detail in the
        <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual033.html#toc149">interfacing
        with C</ulink> section of the OCaml manual.
      </para>
    </sect2>
  </sect1>
  <sect1 id="compiling-fast-native-code">
    <title>Compiling fast native code</title>
    <para>
      The native code compiler is ultimately the tool that most
      production OCaml code goes through. It compiles the lambda form
      into fast native code executables, with cross-module inlining and
      additional optimization passes that the bytecode interpreter
      doesn't perform. Care is taken to ensure compatibility with the
      bytecode runtime, so the same code should run identically when
      compiled with either toolchain.
    </para>
    <para>
      The <command>ocamlopt</command> command is the frontend to the
      native code compiler, and has a very similar interface to
      <command>ocamlc</command>. It also accepts <literal>ml</literal>
      and <literal>mli</literal> files, but compiles them to:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          A <literal>.o</literal> file containing native object code.
        </para>
      </listitem>
      <listitem>
        <para>
          A <literal>.cmx</literal> file containing extra information
          for linking and cross-module optimization.
        </para>
      </listitem>
      <listitem>
        <para>
          A <literal>.cmi</literal> compiled interface file that is the
          same as the bytecode compiler.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      When the compiler links modules together into an executable, it
      uses the contents of the <literal>cmx</literal> files to perform
      cross-module inlining across compilation units. This can be a
      significant speedup for standard library functions that are
      frequently used outside of their module.
    </para>
    <para>
      Collections of <literal>.cmx</literal> and <literal>.o</literal>
      files can also be be linked into a <literal>.cmxa</literal>
      archive by passing the <literal>-a</literal> flag to the compiler.
      However, unlike the bytecode version, you must keep the individual
      <literal>cmx</literal> files in the compiler search path so that
      they are available for cross-module inlining. If you don't do
      this, the compilation will still succeed, but you will have missed
      out on an important optimization and have slower binaries.
    </para>
    <sect2 id="inspecting-assembly-output">
      <title>Inspecting assembly output</title>
      <para>
        The native code compiler generates assembly language that is
        then passed to the system assembler for compiling into object
        files. You can get <command>ocamlopt</command> to output the
        assembly by passing the <literal>-S</literal> flag to the
        compiler command-line.
      </para>
      <para>
        The assembly code is highly architecture specific, so the
        discussion below assumes an Intel or AMD 64-bit platform. We've
        generated the example code using <literal>-inline 20</literal>
        and <literal>-nodynlink</literal> since it's best to generate
        assembly code with the full optimizations that the compiler
        supports. Even though these optimizations make the code a bit
        harder to read, it will give you a more accurate picture of what
        executes on the CPU. Don't forget that you can use the lambda
        code from earlier to get a slightly higher level picture of the
        code if you get lost in the more verbose assembly.
      </para>
      <sect3 id="the-impact-of-polymorphic-comparison">
        <title>The impact of polymorphic comparison</title>
        <para>
          We warned you earlier in
          <xref linkend="maps-and-hash-tables"/> that using
          polymorphic comparison is both convenient and perilous. Let's
          look at precisely what the difference is at the assembly
          language level now.
        </para>
        <para>
          First create a comparison function where we've explicitly
          annotated the types, so the compiler knows that only integers
          are being compared.
        </para>
        <programlisting language="ocaml">
(* back-end/compare_mono.ml  *)
let cmp (a:int) (b:int) =
  if a &gt; b then a else b
</programlisting>
        <para>
          Now compile this into assembly and read the resulting
          <literal>compare_mono.S</literal> file. This file extension
          may be lowercase on some platforms such as Linux.
        </para>
        <programlisting>
# running back-end/asm_from_compare_mono.out.sh
$ ocamlopt -inline 20 -nodynlink -S compare_mono.ml
</programlisting>
        <para>
          If you've never seen assembly language before then the
          contents may be rather scary. While you'll need to learn x86
          assembly to fully understand it, we'll try to give you some
          basic instructions to spot patterns in this section. The
          excerpt of the implementation of the <literal>cmp</literal>
          function can be found below.
        </para>
        <programlisting>
_camlCompare_mono__cmp_1008:
        .cfi_startproc
.L101:
        cmpq    %rbx, %rax
        jle     .L100
        ret
        .align  2
.L100:
        movq    %rbx, %rax
        ret
        .cfi_endproc
</programlisting>
        <para>
          The <literal>_camlCompare_mono__cmp_1008</literal> is an
          assembly label that has been computed from the module name
          (<literal>Compare_mono</literal>) and the function name
          (<literal>cmp_1008</literal>). The numeric suffix for the
          function name comes straight from the lambda form (which you
          can inspect using <literal>-dlambda</literal>, but in this
          case isn't necessary).
        </para>
        <para>
          The arguments to <literal>cmp</literal> are passed in the
          <literal>%rbx</literal> and <literal>%rax</literal> registers,
          and compared using the <literal>jle</literal> &quot;jump if
          less than or equal&quot; instruction. This requires both the
          arguments to be immediate integers to work. Now let's see what
          happens if our OCaml code omits the type annotations and is a
          polymorphic comparison instead.
        </para>
        <programlisting language="ocaml">
(* back-end/compare_poly.ml  *)
let cmp a b =
  if a &gt; b then a else b
</programlisting>
        <para>
          Compiling this code with <literal>-S</literal> results in a
          significantly more complex assembly output for the same
          function.
        </para>
        <programlisting>
_camlCompare_poly__cmp_1008:
        .cfi_startproc
        subq    $24, %rsp
        .cfi_adjust_cfa_offset  24
.L101:
        movq    %rax, 8(%rsp)
        movq    %rbx, 0(%rsp)
        movq    %rax, %rdi
        movq    %rbx, %rsi
        leaq    _caml_greaterthan(%rip), %rax
        call    _caml_c_call
.L102:
        leaq    _caml_young_ptr(%rip), %r11
        movq    (%r11), %r15
        cmpq    $1, %rax
        je      .L100
        movq    8(%rsp), %rax
        addq    $24, %rsp
        .cfi_adjust_cfa_offset  -24
        ret
        .cfi_adjust_cfa_offset  24
        .align  2
.L100:
        movq    0(%rsp), %rax
        addq    $24, %rsp
        .cfi_adjust_cfa_offset  -24
        ret
        .cfi_adjust_cfa_offset  24
        .cfi_endproc
</programlisting>
        <para>
          The <literal>.cfi</literal> directives are assembler hints
          that contain Call Frame Information that lets the GNU debugger
          provide more sensible backtraces, and have no effect on
          runtime performance. Notice that the rest of the
          implementation is no longer a simple register comparison.
          Instead, the arguments are pushed on the stack (the
          <literal>%rsp</literal> register) and a C function call is
          invoked by placing a pointer to
          <literal>caml_greaterthan</literal> in <literal>%rax</literal>
          and jumping to <literal>caml_c_call</literal>.
        </para>
        <para>
          OCaml on x86_64 architectures caches the location of the minor
          heap in the <literal>%r15</literal> register since it's so
          frequently referenced in OCaml functions. The minor heap
          pointer can also be changed by the C code that's being called
          (e.g. when it allocates OCaml values), and so
          <literal>%r15</literal> is restored after returning from the
          <literal>caml_greaterthan</literal> call. Finally the return
          value of the comparison is popped from the stack and returned.
        </para>
      </sect3>
      <sect3 id="benchmarking-polymorphic-comparison">
        <title>Benchmarking polymorphic comparison</title>
        <para>
          You don't have to fully understand the intricacies of assembly
          language to see that this polymorphic comparison is much
          heavier than the simple monomorphic integer comparison from
          earlier. Let's confirm this hypothesis again by writing a
          quick <literal>Core_bench</literal> test with both functions.
        </para>
        <programlisting language="ocaml">
(* back-end-bench/bench_poly_and_mono.ml  *)
open Core.Std
open Core_bench.Std

let polymorphic_compare () =
  let cmp a b = if a &gt; b then a else b in
  for i = 0 to 1000 do
    ignore(cmp 0 i)
  done

let monomorphic_compare () =
  let cmp (a:int) (b:int) =
    if a &gt; b then a else b in
  for i = 0 to 1000 do
    ignore(cmp 0 i)
  done

let tests =
  [ &quot;Polymorphic comparison&quot;, polymorphic_compare;
    &quot;Monomorphic comparison&quot;, monomorphic_compare ]

let () =
  List.map tests ~f:(fun (name,test) -&gt; Bench.Test.create ~name test)
  |&gt; Bench.make_command
  |&gt; Command.run
</programlisting>
        <para>
          Running this shows quite a significant runtime difference
          between the two.
        </para>
        <programlisting>
# running back-end-bench/run_bench_poly_and_mono.out.sh
$ corebuild -pkg core_bench bench_poly_and_mono.native
$ ./bench_poly_and_mono.native -ascii
Estimated testing time 20s (change using -quota SECS).
                                                 
  Name                     Time (ns)   % of max  
 ------------------------ ----------- ---------- 
  Polymorphic comparison      13_919     100.00  
  Monomorphic comparison         815       5.86  
                                                 
</programlisting>
        <para>
          We see that the polymorphic comparison is close to 20 times
          slower! These results shouldn't be taken too seriously as this
          is a very narrow test, which like all such microbenchmarks
          aren't representative of more complex codebases. However, if
          you're building numerical code that runs many iterations in a
          tight inner loop, it's worth manually peering at the produced
          assembly code to see if you can hand-optimize it.
        </para>
      </sect3>
    </sect2>
    <sect2 id="debugging-native-code-binaries">
      <title>Debugging native code binaries</title>
      <para>
        The native code compiler builds executables that can be debugged
        using conventional system debuggers such as GNU
        <literal>gdb</literal>. You need to compile your libraries with
        the <literal>-g</literal> option to add the debug information to
        the output, just as you need to with C compilers.
      </para>
      <para>
        Extra debugging information is inserted into the output assembly
        when the library is compiled in debug mode. These include the
        CFI stubs you will have noticed in the profiling output earlier
        (<literal>.cfi_start_proc</literal> and
        <literal>.cfi_end_proc</literal> to delimit an OCaml function
        call, for example).
      </para>
      <sect3 id="understanding-name-mangling">
        <title>Understanding name mangling</title>
        <para>
          So how do you refer to OCaml functions in an interactive
          debugger like <literal>gdb</literal>? The first thing you need
          to know is how function names compile down to C symbols; a
          procedure generally called <emphasis>name mangling</emphasis>.
        </para>
        <para>
          Each OCaml source file is compiled into a native object file
          that must export a unique set of symbols to comply with the C
          binary interface. This means that any OCaml values that may be
          used by another compilation unit need to be mapped into a
          symbol name. This mapping has to account for OCaml language
          features such as nested modules, anonymous functions and
          variable names that shadow each other.
        </para>
        <para>
          The conversion follows some straightforward rules for named
          variables and functions:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              The symbol is prefixed by <literal>caml</literal> and the
              local module name, with dots replaced by underscores.
            </para>
          </listitem>
          <listitem>
            <para>
              This is followed by a double <literal>__</literal> suffix
              and the variable name.
            </para>
          </listitem>
          <listitem>
            <para>
              The variable name is also suffixed by a
              <literal>_</literal> and a number. This is the result of
              the lambda compilation that replaces each variable name
              with a unique value within the module. You can determine
              this number by examining the <literal>-dlambda</literal>
              output from <command>ocamlopt</command>.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Anonymous functions are hard to predict without inspecting
          intermediate compiler output. If you need to debug them it's
          usually easier to modify the source code to let-bind the
          anonymous function to a variable name.
        </para>
      </sect3>
      <sect3 id="interactive-breakpoints-with-the-gnu-debugger">
        <title>Interactive breakpoints with the GNU debugger</title>
        <para>
          Let's see name mangling in action with some interactive
          debugging in the GNU <literal>gdb</literal> debugger.
        </para>
        <caution>
        <title>
        Beware <literal>gdb</literal> on MacOS X
        </title>
        <para>
          The examples here assume that you are running
          <literal>gdb</literal> on either Linux or FreeBSD. MacOS X
          does have <literal>gdb</literal> installed, but it's a rather
          quirky experience that doesn't reliably interpret the
          debugging information contained in the native binaries. This
          can result in function names showing up as raw symbols such as
          <literal>.L101</literal> instead of their more human-readable
          form.
        </para>
        <para>
          For OCaml 4.1, we'd recommend you do native code debugging on
          an alternate platform such as Linux, or manually look at the
          assembly code output to map the symbol names onto their
          precise OCaml functions.
        </para>
        </caution>
        <para>
          Let's write a mutually recursive function that selects
          alternating values from a list. This isn't tail recursive and
          so our stack size will grow as we single-step through the
          execution.
        </para>
        <programlisting language="ocaml">
(* back-end/alternate_list.ml  *)
open Core.Std

let rec take =
  function
  |[] -&gt; []
  |hd::tl -&gt; hd :: (skip tl)
and skip =
  function
  |[] -&gt; []
  |_::tl -&gt; take tl

let () =
  take [1;2;3;4;5;6;7;8;9]
  |&gt; List.map ~f:string_of_int
  |&gt; String.concat ~sep:&quot;,&quot;
  |&gt; print_endline
</programlisting>
        <para>
          Compile and run this with debugging symbols. You should see
          the following output:
        </para>
        <programlisting language="ocaml">
(* back-end-bench/run_alternate_list.out  *)
$ corebuild -tag debug alternate_list.native
$ ./alternate_list.native -ascii
1,3,5,7,9
</programlisting>
        <para>
          Now we can run this interactively within
          <literal>gdb</literal>.
        </para>
        <programlisting>
# running back-end/gdb_alternate0.out.sh
$ gdb ./alternate_list.native
GNU gdb (GDB) 7.4.1-debian
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /home/avsm/alternate_list.native...done.
(gdb)
</programlisting>
        <para>
          The <literal>gdb</literal> prompt lets you enter debug
          directives. Let's set the program to break just before the
          first call to <literal>take</literal>.
        </para>
        <programlisting>
# running back-end/gdb_alternate1.out.sh
(gdb) break camlAlternate_list__take_69242 
Breakpoint 1 at 0x5658d0: file alternate_list.ml, line 5.
</programlisting>
        <para>
          We used the C symbol name by following the name mangling rules
          defined earlier. A convenient way to figure out the full name
          is by tab-completion. Just type in a portion of the name and
          press the <literal>&lt;tab&gt;</literal> key to see a list of
          possible completions.
        </para>
        <para>
          Once you've set the breakpoint, start the program executing.
        </para>
        <programlisting>
# running back-end/gdb_alternate2.out.sh
(gdb) run
Starting program: /home/avsm/alternate_list.native
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5
4         function
</programlisting>
        <para>
          The binary has run until the first take invocation and
          stopped, waiting for further instructions. GDB has lots of
          features, so let's continue the program and check the
          stacktrace after a couple of recursions.
        </para>
        <programlisting>
# running back-end/gdb_alternate3.out.sh
(gdb) cont
Continuing.

Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5
4         function
(gdb) cont
Continuing.

Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5
4         function
(gdb) bt
#0  camlAlternate_list__take_69242 () at alternate_list.ml:4
#1  0x00000000005658e7 in camlAlternate_list__take_69242 () at alternate_list.ml:6
#2  0x00000000005658e7 in camlAlternate_list__take_69242 () at alternate_list.ml:6
#3  0x00000000005659f7 in camlAlternate_list__entry () at alternate_list.ml:14
#4  0x0000000000560029 in caml_program ()
#5  0x000000000080984a in caml_start_program ()
#6  0x00000000008099a0 in ?? ()
#7  0x0000000000000000 in ?? ()
(gdb) clear camlAlternate_list__take_69242
Deleted breakpoint 1 
(gdb) cont
Continuing.
1,3,5,7,9
[Inferior 1 (process 3546) exited normally]
</programlisting>
        <para>
          The <literal>cont</literal> command resumes execution after a
          breakpoint has paused it, <literal>bt</literal> displays a
          stack backtrace, and <literal>clear</literal> deletes the
          breakpoint so that the application can execute until
          completion. GDB has a host of other features we won't cover
          here, but you can view more guidelines via Mark Shinwell's
          talk on
          <ulink url="http://www.youtube.com/watch?v=NF2WpWnB-nk&lt;">&quot;Real-world
          debugging in OCaml&quot;</ulink>.
        </para>
        <para>
          One very useful feature of OCaml native code is that C and
          OCaml both share the same stack. This means that GDB
          backtraces can give you a combined view of what's going on in
          your program <emphasis>and</emphasis> runtime library. This
          includes any calls to C libraries or even callbacks into OCaml
          from the C layer if you're in an embedded environment.
        </para>
      </sect3>
    </sect2>
    <sect2 id="profiling-native-code">
      <title>Profiling native code</title>
      <para>
        The recording and analysis of where your application spends its
        execution time is known as <emphasis>performance
        profiling</emphasis>. OCaml native code binaries can be profiled
        just like any other C binary, by using the name mangling
        described earlier to map between OCaml variable names and the
        profiler output.
      </para>
      <para>
        Most profiling tools benefit from having some instrumentation
        included in the binary. OCaml supports two such tools:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            GNU Gprof to measure execution time and call graphs.
          </para>
        </listitem>
        <listitem>
          <para>
            The <ulink url="https://perf.wiki.kernel.org/">Perf</ulink>
            profiling framework in modern versions of Linux.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Note that many other tools that operate on native binaries such
        as Valgrind will work just fine with OCaml as long as the
        program is linked with the <literal>-g</literal> flag to embed
        debugging symbols.
      </para>
      <sect3 id="gprof">
        <title>Gprof</title>
        <para>
          Gprof produces an execution profile of an OCaml program by
          recording a call graph of which functions call each other, and
          recording the time these calls take during the program
          execution.
        </para>
        <para>
          Getting precise information out of Gprof requires passing the
          <literal>-p</literal> flag to the native code compiler when
          compiling <emphasis>and</emphasis> linking the binary. This
          generates extra code that records profile information to a
          file called <literal>gmon.out</literal> when the program is
          executed. This profile information can then be examined using
          Gprof.
        </para>
      </sect3>
      <sect3 id="perf">
        <title>Perf</title>
        <para>
          Perf is a more modern alternative to Gprof that doesn't
          require you to instrument the binary. Instead, it uses
          hardware counters and debug information within the binary to
          record information accurately.
        </para>
        <para>
          Run Perf on a compiled binary to record information first.
          We'll use our write barrier benchmark from earlier which
          measures memory allocation versus in-place modification.
        </para>
        <programlisting>
# running back-end/perf_record.out.sh
$ perf record -g ./barrier_bench.native
Estimated testing time 20s (change using -quota SECS).
┌───────────┬───────────┬─────────────────────┬────────────┐
│ Name      │ Time (ns) │           Time 95ci │ Percentage │
├───────────┼───────────┼─────────────────────┼────────────┤
│ mutable   │ 7_306_219 │ 7_250_234-7_372_469 │      96.83 │
│ immutable │ 7_545_126 │ 7_537_837-7_551_193 │     100.00 │
└───────────┴───────────┴─────────────────────┴────────────┘
[ perf record: Woken up 11 times to write data ]
[ perf record: Captured and wrote 2.722 MB perf.data (~118926 samples) ]
perf record -g ./barrier.native
Estimated testing time 20s (change using -quota SECS).
┌───────────┬───────────┬─────────────────────┬────────────┐
│ Name      │ Time (ns) │           Time 95ci │ Percentage │
├───────────┼───────────┼─────────────────────┼────────────┤
│ mutable   │ 7_306_219 │ 7_250_234-7_372_469 │      96.83 │
│ immutable │ 7_545_126 │ 7_537_837-7_551_193 │     100.00 │
└───────────┴───────────┴─────────────────────┴────────────┘
[ perf record: Woken up 11 times to write data ]
[ perf record: Captured and wrote 2.722 MB perf.data (~118926 samples) ]
</programlisting>
        <para>
          When this completes, you can interactively explore the
          results.
        </para>
        <programlisting>
# running back-end/perf_report.out.sh
$ perf report -g
+  48.86%  barrier.native  barrier.native     [.] camlBarrier__test_immutable_69282
+  30.22%  barrier.native  barrier.native     [.] camlBarrier__test_mutable_69279
+  20.22%  barrier.native  barrier.native     [.] caml_modify
</programlisting>
        <para>
          This trace broadly reflects the results of the benchmark
          itself. The mutable benchmark consists of the combination of
          the call to <literal>test_mutable</literal> and the
          <literal>caml_modify</literal> write barrier function in the
          runtime. This adds up to slightly over half the execution time
          of the application.
        </para>
        <para>
          Perf has a growing collection of other commands that let you
          archive these runs and compare them against each other. You
          can read more on the
          <ulink url="http://perf.wiki.kernel.org">homepage</ulink>.
        </para>
        <sidebar>
        <title>
        Using the frame-pointer to get more accurate traces
        </title>
        <para>
          Although Perf doesn't require adding in explicit probes to the
          binary, it does need to understand how to unwind function
          calls so that the kernel can accurately record the function
          backtrace for every event.
        </para>
        <para>
          OCaml stack frames are too complex for Perf to understand
          directly, and so it needs the compiler to fall back to using
          the same conventions as C for function calls. On 64-bit Intel
          systems, this means that a special register known as the
          <emphasis>frame pointer</emphasis> is used to record function
          call history.
        </para>
        <para>
          Using the frame pointer in this fashion means a slowdown
          (typically around 3-5%) since it's no longer available for
          general-purpose use. OCaml 4.1 thus makes the frame pointer an
          optional feature that can be used to improve the resolution of
          Perf traces.
        </para>
        <para>
          OPAM provides a compiler switch that compiles OCaml with the
          frame pointer activated.
        </para>
        <programlisting>
# running back-end/opam_switch.out.sh
$ opam switch 4.01.0dev+fp
</programlisting>
        <para>
          Using the frame pointer changes the OCaml calling convention,
          but OPAM takes care of recompiling all your libraries with the
          new interface. You can read more about this on the OCamlPro
          <ulink url="http://www.ocamlpro.com/blog/2012/08/08/profile-native-code.html">blog</ulink>.
        </para>
        </sidebar>
      </sect3>
    </sect2>
    <sect2 id="embedding-native-code-in-c">
      <title>Embedding native code in C</title>
      <para>
        The native code compiler normally links a complete executable,
        but can also output a standalone native object file just as the
        bytecode compiler can. This object file has no further
        dependencies on OCaml except for the runtime library.
      </para>
      <para>
        The native code runtime is a different library from the bytecode
        one and is installed as <literal>libasmrun.a</literal> in the
        OCaml standard library directory.
      </para>
      <para>
        Try this custom linking by using the same source files from the
        bytecode embedding example earlier in this chapter.
      </para>
      <programlisting>
# running back-end-embed/build_embed_native.out.sh
$ ocamlopt -output-obj -o embed_native.o embed_me1.ml embed_me2.ml
$ gcc -Wall -I `ocamlc -where` -o final.native embed_native.o main.c -L `ocamlc -where` -lasmrun -ltermcap -lm -ldl
$ ./final.native
Before calling OCaml
hello embedded world 1
hello embedded world 2
After calling OCaml
</programlisting>
      <para>
        The <literal>embed_native.o</literal> is a standalone object
        file that has no further references to OCaml code beyond the
        runtime library, just as with the bytecode runtime. Do remember
        that the link order of the libraries is significant on modern
        GNU toolchains (especially as used in Ubuntu 11.10 upwards) that
        resolve symbols from left-to-right in a single pass.
      </para>
      <tip>
      <title>
      Activating the debug runtime
      </title>
      <para>
        Despite your best efforts, it is easy to introduce a bug into
        some components such as C bindings that causes heap invariants
        to be violated. OCaml includes a <literal>libasmrund.a</literal>
        variant of the runtime library that is compiled with extra
        debugging checks that perform extra memory integrity checks
        during every garbage collection cycle. Running these extra
        checks will abort the program nearer the point of corruption and
        help isolate the bug in the C code.
      </para>
      <para>
        To use the debug library, just link your program with the
        <literal>-runtime-variant d</literal> flag.
      </para>
      <programlisting>
# running back-end-embed/run_debug_hello.out.sh
$ ocamlopt -runtime-variant d -verbose -o hello.native hello.ml
$ ./hello.native
### OCaml runtime: debug mode ###
Initial minor heap size: 2048k bytes
Initial major heap size: 992k bytes
Initial space overhead: 80%
Initial max overhead: 500%
Initial heap increment: 992k bytes
Initial allocation policy: 0
Hello OCaml World!
</programlisting>
      <para>
        If you get an error that <literal>libasmrund.a</literal> is not
        found, then this is probably because you're using OCaml 4.00 and
        not 4.01. It's only installed by default in the very latest
        version, which you should be using via the
        <literal>4.01.0dev+trunk</literal> OPAM switch.
      </para>
      </tip>
    </sect2>
  </sect1>
  <sect1 id="summarizing-the-file-extensions">
    <title>Summarizing the file extensions</title>
    <para>
      We've seen how the compiler uses intermediate files to store
      various stages of the compilation toolchain. Here's a cheat sheet
      of all them in one place.
    </para>
    <para>
      Here are the intermediate files generated by
      <command>ocamlc</command>:
    </para>
    <informaltable>
      <tgroup cols="2">
        <colspec align="left"/>
        <colspec align="left"/>
        <thead>
          <row>
            <entry>
              Extension
            </entry>
            <entry>
              Purpose
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              .ml
            </entry>
            <entry>
              Source files for compilation unit module implementations.
            </entry>
          </row>
          <row>
            <entry>
              .mli
            </entry>
            <entry>
              Source files for compilation unit module interfaces. If
              missing, generated from the <literal>.ml</literal> file.
            </entry>
          </row>
          <row>
            <entry>
              .cmi
            </entry>
            <entry>
              Compiled module interface from a corresponding
              <literal>.mli</literal> source file.
            </entry>
          </row>
          <row>
            <entry>
              .cmo
            </entry>
            <entry>
              Compiled bytecode object file of the module
              implementation.
            </entry>
          </row>
          <row>
            <entry>
              .cma
            </entry>
            <entry>
              Library of bytecode object files packed into a single
              file.
            </entry>
          </row>
          <row>
            <entry>
              .o
            </entry>
            <entry>
              C source files are compiled into native object files by
              the system <literal>cc</literal>.
            </entry>
          </row>
          <row>
            <entry>
              .cmt
            </entry>
            <entry>
              Typed abstract syntax tree for module implementations.
            </entry>
          </row>
          <row>
            <entry>
              .cmti
            </entry>
            <entry>
              Typed abstract syntax tree for module interfaces.
            </entry>
          </row>
          <row>
            <entry>
              .annot
            </entry>
            <entry>
              Old-style annotation file for displaying typed, superseded
              by <literal>cmt</literal> files.
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      The native code compiler generates some additional files.
    </para>
    <informaltable>
      <tgroup cols="2">
        <colspec align="left"/>
        <colspec align="left"/>
        <thead>
          <row>
            <entry>
              Extension
            </entry>
            <entry>
              Purpose
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              .o
            </entry>
            <entry>
              Compiled native object file of the module implementation.
            </entry>
          </row>
          <row>
            <entry>
              .cmx
            </entry>
            <entry>
              Contains extra information for linking and cross-module
              optimization of the object file.
            </entry>
          </row>
          <row>
            <entry>
              .cmxa and .a
            </entry>
            <entry>
              Library of <literal>cmx</literal> and <literal>o</literal>
              units, stored in the <literal>cmxa</literal> and
              <literal>a</literal> files respectively. These files are
              always needed together.
            </entry>
          </row>
          <row>
            <entry>
              .S <emphasis>or</emphasis> .s
            </entry>
            <entry>
              Assembly language output if <literal>-S</literal> is
              specified.
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </sect1>
</chapter></part><appendix id="installation">
  <title>Installation</title>
  <para>
    The easiest way to use OCaml is via the binary packages available
    for many operating systems. For day-to-day code development however,
    it's much easier to use a source-code manager that lets you modify
    individual libraries and automatically recompile all the
    dependencies.
  </para>
  <para>
    An important difference between OCaml and scripting languages such
    as Python or Ruby is the static type safety that means that you
    can't just mix-and-match compiled libraries. Interfaces are checked
    when libraries are compiled, so when an interface is changed, all
    the dependent libraries must also be recompiled. Source-based
    package managers automate this process for you and make development
    life much easier.
  </para>
  <para>
    To work through Real World OCaml, you'll need three major components
    installed:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        The OCaml compiler itself.
      </para>
    </listitem>
    <listitem>
      <para>
        The OPAM source package manager, through which we'll install
        several extra libraries.
      </para>
    </listitem>
    <listitem>
      <para>
        The <literal>utop</literal> interactive toplevel, a modern
        interactive toplevel with command history and tab completion.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    Let's get started with how to install OCaml on various operating
    systems, and we'll get OPAM and <literal>utop</literal> running
    after that.
  </para>
  <sect1 id="getting-ocaml">
    <title>Getting OCaml</title>
    <para>
      The OCaml compiler is available as a binary distribution on many
      operating systems. This is the simplest and preferred installation
      route, but we'll also describe how to do a manual installation as
      a last resort.
    </para>
    <sect2 id="mac-os-x">
      <title>Mac OS X</title>
      <para>
        The
        <ulink url="http://github.com/mxcl/homebrew">Homebrew</ulink>
        package manager has an OCaml installer, which is usually updated
        pretty quickly to the latest stable release. Make sure that you
        have the latest XCode (and Command Line Tools for XCode)
        installed from the App Store before starting the OCaml
        installation.
      </para>
      <programlisting>
$ brew update
$ brew install ocaml
$ brew install pcre
</programlisting>
      <para>
        The Perl-compatible Regular Expression library (PCRE) is used by
        the Core suite. It's not strictly needed to use OCaml, but is a
        commonly used library that we're installing now to save time
        later.
      </para>
      <para>
        Another popular package manager on Mac OS X is
        <ulink url="http://macports.org">MacPorts</ulink>, which also
        has an OCaml port. As with Homebrew, make sure you have XCode
        installed and have followed the rest of the MacPorts
        installation instructions, and then type in:
      </para>
      <programlisting>
$ sudo port install ocaml
$ sudo port install ocaml-pcre
</programlisting>
    </sect2>
    <sect2 id="debian-linux">
      <title>Debian Linux</title>
      <para>
        On Debian Linux, you should install OCaml via binary packages.
        You'll need at least OCaml version 3.12.1 to bootstrap OPAM,
        which means using Debian Wheezy or greater. Don't worry about
        getting the absolute latest version of the compiler, as you just
        need one new enough to compile the OPAM package manager, after
        which you'll use OPAM to manage your compiler installation.
      </para>
      <programlisting>
$ sudo apt-get install ocaml ocaml-native-compilers camlp4-extra
$ sudo apt-get install git libpcre3-dev curl build-essential m4
</programlisting>
      <para>
        Notice that we've installed a few more packages than just the
        OCaml compiler here. The second command line installs enough
        system packages to let you build your own OCaml packages. You
        may find that some OCaml libraries require more system libraries
        (for example, <literal>libssl-dev</literal>), but we'll
        highlight these in the book when we introduce the library.
      </para>
    </sect2>
    <sect2 id="fedora-and-red-hat">
      <title>Fedora and Red Hat</title>
      <para>
        OCaml has been included in the basic distribution since Fedora
        8. To install the latest compiler, just run:
      </para>
      <programlisting>
# yum install ocaml
# yum install ocaml-camlp4-devel
# yum install pcre-devel
</programlisting>
      <para>
        The PCRE package is used by Core and is just included here for
        convenience later.
      </para>
    </sect2>
    <sect2 id="arch-linux">
      <title>Arch Linux</title>
      <para>
        Arch Linux provides OCaml 4.00.1 (or later) in the standard
        repositories, so the easiest method of installation is using
        <literal>pacman</literal>:
      </para>
      <programlisting>
$ pacman -Sy ocaml
</programlisting>
    </sect2>
    <sect2 id="windows">
      <title>Windows</title>
      <para>
        Windows is not currently supported by the examples in Real World
        OCaml, although it is being worked on. Until that's ready, we
        recommend using a virtual machine running Debian Linux on your
        local machine.
      </para>
    </sect2>
    <sect2 id="building-from-source">
      <title>Building from source</title>
      <para>
        To install OCaml from source code, first make sure that you have
        a C compilation environment (usually either
        <literal>gcc</literal> or <literal>llvm</literal> installed).
      </para>
      <programlisting>
$ curl -OL https://github.com/ocaml/ocaml/archive/4.01.tar.gz
$ tar -zxvf 4.01.tar.gz
$ cd ocaml-4.01
$ ./configure
$ make world world.opt
$ sudo make install
</programlisting>
      <para>
        The final step requires administrator privilege to install in
        your system directory. You can also install it in your home
        directory by passing the <literal>prefix</literal> option to the
        configuration script:
      </para>
      <programlisting>
$ ./configure -prefix $HOME/my-ocaml
</programlisting>
      <para>
        Once the installation is completed into this custom location,
        you will need to add <literal>$HOME/my-ocaml/bin</literal> to
        your <literal>PATH</literal>, normally by editing the
        <literal>~/.bash_profile</literal> file. You shouldn't really to
        do this unless you have special reasons, so try to install
        binary packages before trying a source installation.
      </para>
      <note>
      <title>
      Note to reviewers
      </title>
      <para>
        We instruct you to install the unreleased 4.01 branch version of
        OCaml in these instructions, as we take advantage of some recent
        additions to the language that simplify explanations in the
        book. The 4.01 release will happen before the book is released,
        but you may run into &quot;bleeding edge&quot; bugs with the
        release. Leave a comment here if you do and we'll address them.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="getting-opam">
    <title>Getting OPAM</title>
    <para>
      OPAM manages multiple simultaneous OCaml compiler and library
      installations, tracks library versions across upgrades, and
      recompiles dependencies automatically if they get out of date.
      It's used throughout Real World OCaml as the mechanism to retrieve
      and use third-party libraries.
    </para>
    <para>
      Before installing OPAM, make sure that you have the OCaml compiler
      installed as described above. Once installed, the entire OPAM
      database is held in your home directory (normally
      <literal>$HOME/.opam</literal>). If something goes wrong, just
      delete this <literal>.opam</literal> directory and start over from
      a clean slate. If you're using a beta version of OPAM, please
      upgrade it to at least version 1.0.0 or greater before proceeding.
    </para>
    <sect2 id="mac-os-x-1">
      <title>Mac OS X</title>
      <para>
        Source installation of OPAM will take a minute or so on a modern
        machine. There is a Homebrew package for the latest OPAM:
      </para>
      <programlisting>
$ brew update
$ brew install opam
</programlisting>
      <para>
        And on MacPorts, install it like this:
      </para>
      <programlisting>
$ sudo port install opam
</programlisting>
    </sect2>
    <sect2 id="debian-linux-1">
      <title>Debian Linux</title>
      <para>
        OPAM has recently been packaged for Debian and will soon be part
        of the unstable distribution. If you're on an earlier stable
        distribution such as <literal>wheezy</literal>, you can either
        compile from source, or cherry-pick just the OPAM binary package
        from <literal>unstable</literal> by:
      </para>
      <programlisting>
# apt-get update
# apt-get -t unstable install opam
</programlisting>
      <note>
      <title>
      Note to reviewers
      </title>
      <para>
        The binary packages for OPAM are not yet available as of the 5th
        August 2013, but the package is in the <literal>NEW</literal>
        queue. It should be available by the the time the book is
        released, and these instructions will be updated accordingly.
      </para>
      </note>
    </sect2>
    <sect2 id="ubuntu-raring">
      <title>Ubuntu Raring</title>
      <para>
        OPAM is available as a Personal Package Archive on Ubuntu Raring
        for both i386 and x86_64. To install it, just run:
      </para>
      <programlisting>
$ add-apt-repository ppa:avsm/ppa
$ apt-get update
$ apt-get install ocaml opam
</programlisting>
    </sect2>
    <sect2 id="fedora-and-red-hat-1">
      <title>Fedora and Red Hat</title>
      <para>
        There is currently no RPM available for Fedora or Red Hat, so
        please install OPAM via the source code instructions for the
        moment.
      </para>
    </sect2>
    <sect2 id="arch-linux-1">
      <title>Arch Linux</title>
      <para>
        OPAM is available in the Arch User Repository (AUR) in two
        packages. You'll need both <literal>ocaml</literal> and the
        <literal>base-devel</literal> packages installed first:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>opam</literal> contains the most recent stable
            release, and is the recommended package.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>opam-git</literal> builds the package from the
            latest upstream source, and should only be used if you are
            looking for a specific bleeding-edge feature.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Run these commands to install the stable OPAM package:
      </para>
      <programlisting>
$ sudo pacman -Sy base-devel
$ wget https://aur.archlinux.org/packages/op/opam/opam.tar.gz
$ tar -xvf opam.tar.gz &amp;&amp; cd opam
$ makepkg
$ sudo pacman -U opam-_version_.pkg.tar.gz
</programlisting>
    </sect2>
    <sect2 id="source-installation">
      <title>Source Installation</title>
      <para>
        If the binary packages aren't available for your system, you'll
        need to install the latest OPAM release from source. You can
        follow the online
        <ulink url="http://opam.ocamlpro.com/doc/Quick_Install.html">quick
        install guide</ulink> or read the summary below.
      </para>
      <para>
        The distribution only requires the OCaml compiler to be
        installed, so this should be straightforward. Download the
        latest version from the
        <ulink url="https://github.com/OCamlPro/opam/tags">homepage</ulink>.
      </para>
      <programlisting>
$ curl -OL https://github.com/OCamlPro/opam/archive/latest.tar.gz
$ tar -zxvf latest.tar.gz
$ cd opam-latest
$ ./configure &amp;&amp; make
$ sudo make install
</programlisting>
      <note>
      <title>
      Note to reviewers
      </title>
      <para>
        The OPAM instructions will be simplified when integrated
        upstream into Debian and Fedora, which is ongoing. Until then,
        we're leaving source-code installation instructions here. Please
        leave a comment with any amended instructions you encounter.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="configuring-opam">
    <title>Configuring OPAM</title>
    <para>
      The entire OPAM package database is held in the
      <literal>.opam</literal> directory in your home directory,
      including compiler installations. On Linux and Mac OS X, this will
      be the <literal>~/.opam</literal> directory. You shouldn't switch
      to an admin user to install packages as nothing will be installed
      outside of this directory. If you run into problems, just delete
      the whole <literal>~/.opam</literal> directory and follow the
      installations instructions from the <literal>opam init</literal>
      stage again.
    </para>
    <para>
      Let's begin by initialising the OPAM package database. This will
      require an active Internet connection, and ask you a few
      interactive questions at the end. It's safe to answer yes to these
      unless you want to manually control the configuration steps
      yourself as an advanced user.
    </para>
    <programlisting>
$ opam init
&lt;...&gt;
=-=-=-= Configuring OPAM =-=-=-=
Do you want to update your configuration to use OPAM ? [Y/n] y
[1/4] Do you want to update your shell configuration file ? [default: ~/.profile] y
[2/4] Do you want to update your ~/.ocamlinit ? [Y/n] y
[3/4] Do you want to install the auto-complete scripts ? [Y/n] y
[4/4] Do you want to install the `opam-switch-eval` script ? [Y/n] y
User configuration:
~/.ocamlinit is already up-to-date.
~/.profile is already up-to-date.
Gloabal configuration:
Updating &lt;root&gt;/opam-init/init.sh
auto-completion : [true]
opam-switch-eval: [true]
Updating &lt;root&gt;/opam-init/init.zsh
auto-completion : [true]
opam-switch-eval: [true]
Updating &lt;root&gt;/opam-init/init.csh
auto-completion : [true]
opam-switch-eval: [true]
</programlisting>
    <para>
      You only need to run this command once, and it will create the
      <literal>~/.opam</literal> directory and sync with the latest
      package list from the online OPAM database.
    </para>
    <para>
      When the <literal>init</literal> command finishes, you'll see some
      instructions about environment variables. OPAM never installs
      files into your system directories (which would require
      administrator privileges). Instead, it puts them into your home
      directory by default, and can output a set of shell commands which
      configures your shell with the right <literal>PATH</literal>
      variables so that packages will just work.
    </para>
    <para>
      If you choose not to follow the OPAM instructions to add itself to
      your shell profile, you can still configure it on-the-fly in your
      current shell with just one command.
    </para>
    <programlisting>
$ eval `opam config env`
</programlisting>
    <para>
      This evaluates the results of running
      <literal>opam config env</literal> in your current shell and sets
      the variables so that subsequent commands will use them. This
      <emphasis>only</emphasis> works with your current shell and it can
      be only be automated for future shells by adding the line to your
      login scripts. On Mac OS X or Debian, this is usually the
      <literal>~/.bash_profile</literal> file if you're using the
      default shell. If you've switched to another shell, it might be
      <literal>~/.zshrc</literal> instead. OPAM isn't unusual in this
      approach; the SSH <literal>ssh-agent</literal> also works
      similarly, so if you're having any problems just hunt around in
      your configuration scripts to see how that's being invoked.
    </para>
    <para>
      If you answered <literal>yes</literal> to the auto-complete
      scripts question during <literal>opam init</literal>, this should
      have all been set up for you. You can verify this worked by
      listing the available packages:
    </para>
    <programlisting>
$ opam list
</programlisting>
    <note>
    <title>
    Note to reviewers
    </title>
    <para>
      OPAM 1.0.0 places the login commands into your
      <literal>~/.profile</literal> directory, which isn't always
      executed if your shell is <literal>bash</literal>. This has been
      fixed in subsequent versions, but for now you'll need to manually
      copy the contents of <literal>~/.profile</literal> over to
      <literal>~/.bash_profile</literal> via:
    </para>
    <programlisting>
$ cat ~/.profile &gt;&gt; ~/.bash_profile
</programlisting>
    </note>
    <para>
      The most important package we need to install is Core, which is
      the replacement standard library that all of the examples in this
      book use. Before doing this, let's make sure you have exactly the
      right compiler version you need. We've made some minor
      modifications to the way the OCaml compiler displays type
      signatures, and the next command will install a patched
      <literal>4.01.0</literal> compiler with this functionality
      enabled.
    </para>
    <programlisting>
$ opam switch 4.01.0dev+trunk
$ eval `opam config env`
</programlisting>
    <para>
      This step will take around ten or fifteen minutes on a modern
      machine, and will download and install the OCaml compiler within
      the <literal>~/.opam</literal> directory). OPAM supports multiple
      compiler installations, and you'll find this very useful if you
      ever decide to hack on the internals of the compiler or want to
      experiment with the latest release without sacrificing your
      current installation. You only need to install this compiler once,
      and future updates will be much faster as they only recompile
      libraries within the compiler installation.
    </para>
    <para>
      The new compiler will be installed into
      <literal>~/.opam/4.01.0dev+trunk</literal> and any libraries you
      install for it will be tracked separately from your system
      installation. You can have any number of compilers installed
      simultaneously, but only one can be active at any time. Browse
      through the available compilers by running
      <literal>opam switch list</literal>.
    </para>
    <para>
      Finally, we're ready to install the Core libraries. Run this:
    </para>
    <programlisting>
$ opam install core core_extended core_bench async
</programlisting>
    <para>
      This will take about five or ten minutes to build, and will
      install a series of packages. OPAM figures out the dependencies
      you need automatically, but the three packages that really matter
      are:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>core</literal> is the main, well-supported Core
          distribution from Jane Street.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>core_bench</literal> is a benchmarking library that
          makes it easy to test the performance profile of functions via
          a command-line interface.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>core_extended</literal> contains a number of
          experimental, but useful, extension libraries that are under
          review for inclusion in Core. We use some of these in places,
          but much less than Core itself.
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>async</literal> is the network programming library
          that we use in Part II to communicate with other hosts. You
          can skip this for the initial installation until you get to
          Part II, if you prefer.
        </para>
      </listitem>
    </itemizedlist>
  </sect1>
  <sect1 id="editing-environment">
    <title>Editing Environment</title>
    <para>
      There's one last tool you need before getting started on the
      examples. The default <literal>ocaml</literal> command gives us an
      interactive command-line to experiment with code without compiling
      it. However, it's quite a spartan experience and so we use a more
      modern alternative.
    </para>
    <programlisting>
$ opam install utop
</programlisting>
    <para>
      The <literal>utop</literal> package is an interactive command-line
      interface to OCaml that has tab-completion, persistent history and
      integration with Emacs so that you can run it within your editing
      environment.
    </para>
    <para>
      Remember from earlier that OPAM never installs files directly into
      your system directories, and this applies to
      <literal>utop</literal> too. You'll find the binary in
      <literal>~/.opam/4.01.0dev+trunk/bin</literal>. However, typing in
      <literal>utop</literal> from your shell should just work, due to
      the <literal>opam config env</literal> step that configures your
      shell. Don't forget to automate this as described earlier as it
      makes life much easier when developing OCaml code!
    </para>
    <sect2 id="command-line">
      <title>Command Line</title>
      <para>
        The <literal>utop</literal> tool provides a convenient
        interactive toplevel, with full command history, command macros
        and module name completion. When you first run
        <literal>utop</literal>, you'll find yourself at an interactive
        prompt with a bar at the bottom of the screen. The bottom bar
        dynamically updates as you write text, and contains the possible
        names of modules or variables that are valid at that point in
        the phrase you are entering. You can press the
        <literal>&lt;tab&gt;</literal> key to complete the phrase with
        the first choice.
      </para>
      <para>
        The <literal>~/.ocamlinit</literal> file in your home directory
        initialises <literal>utop</literal> with common libraries and
        syntax extensions so you don't need to type them in every time.
        Now that you have Core installed, you should update it to load
        it every time you start <literal>utop</literal>, by adding this
        to it:
      </para>
      <programlisting language="ocaml">
#use &quot;topfind&quot;
#thread
#camlp4o
#require &quot;core.top&quot;
#require &quot;core.syntax&quot;
</programlisting>
      <para>
        If you only use Core libraries (and this will be the case for
        beginners who are working their way through Real World OCaml as
        their first taste of the language), then you can also open the
        Core module by default. Just append this line to the
        <literal>.ocamlinit</literal> file.
      </para>
      <programlisting language="ocaml">
open Core.Std
</programlisting>
      <para>
        When you run <literal>utop</literal> with these initialization
        rules, it should start up with Core opened and ready to use. If
        you don't open <literal>Core.Std</literal> by default, then you
        must remember to open it before running any of the interactive
        examples in the book.
      </para>
    </sect2>
    <sect2 id="editors">
      <title>Editors</title>
      <note>
      <title>
      Note to reviewers
      </title>
      <para>
        The instructions for editor setup are still being compiled. If
        you have a relevant tip or HOWTO, then we'd
        <emphasis>really</emphasis> appreciate you leaving a note here
        with a pointer or direct instructions.
      </para>
      </note>
      <sect3 id="emacs">
        <title>Emacs</title>
        <para>
          TODO: Emacs users have tuareg and
          <ulink url="http://www.typerex.org/">Typerex</ulink>.
        </para>
        <para>
          To use <literal>utop</literal> directly in Emacs, add the
          following line to your <literal>~/.emacs</literal> file:
        </para>
        <programlisting language="scheme">
(autoload 'utop &quot;utop&quot; &quot;Toplevel for OCaml&quot; t)
</programlisting>
        <para>
          You also need to make the <literal>utop.el</literal> file
          available to your Emacs installation. The OPAM version of
          <literal>utop</literal> installs it into the
          <literal>~/.opam</literal> hierarchy, for example in
          <literal>~/.opam/system/share/emacs/site-lisp/utop.el</literal>.
          You may need to replace <literal>system</literal> with your
          current compiler switch, such as
          <literal>4.01.0dev+trunk</literal>.
        </para>
        <para>
          Once this successfully loads in Emacs, you can run utop by
          executing the command <literal>utop</literal> in Emacs. There
          are more details instructions at the
          <ulink url="https://github.com/diml/utop#integration-with-emacs">utop
          homepage</ulink>.
        </para>
      </sect3>
      <sect3 id="vim">
        <title>Vim</title>
        <para>
          TODO: Vim users can use the built-in style, and
          <ulink url="http://github.com/avsm/ocaml-annot">ocaml-annot</ulink>
          may also be useful.
        </para>
      </sect3>
      <sect3 id="eclipse">
        <title>Eclipse</title>
        <para>
          Eclipse is a popular IDE usually used for Java development.
          The OCaml Development Tools (ODT) project provides equivalent
          IDE features for editing and compiling OCaml code, such as
          automatic compilation and name completion.
        </para>
        <para>
          ODT is distributed as a set of plugins for the Eclipse IDE
          environment from the
          <ulink url="http://ocamldt.free.fr">homepage</ulink>. You just
          have to copy these plugins into your Eclipse distribution in
          order to access the new OCaml facilities.
        </para>
      </sect3>
    </sect2>
  </sect1>
</appendix></book>
