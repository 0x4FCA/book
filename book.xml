<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.5//EN' 'http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd'><book>
  <!-- Reference new files using XIncludes (not entities): http://www.sagehill.net/docbookxsl/ModularDoc.html#UsingXinclude -->
  <!-- Each file should have a DOCTYPE at the top of it so you can validate it alone (just like this but with a chapter/preface instead of book-->
  <!-- Remember, using XIncludes means that you'll have to add a flag (typically 'xinclude' with one or two dashes) when using XML processors/parsers -->
  <!-- Validate with xmllint as follows (Basic setup same as libxslt: http://www.sagehill.net/docbookxsl/InstallingAProcessor.html)-->
  <!-- (please collapse dashes in the line beloew) -->

<title>Real World OCaml</title>
<xi:include href='bookinfo.xml' xmlns:xi='http://www.w3.org/2001/XInclude'/>
<xi:include href='ch00.xml' xmlns:xi='http://www.w3.org/2001/XInclude'/>
<chapter id="prologue">
  <title>Prologue</title>
  <para>
    <emphasis>(yminsky: this is something of a placeholder. We need a
    real introduction that should talk, amongst other things, about what
    kinds of applications OCaml is good for and why one should want to
    learn it. Also, some coverage of who uses OCaml successfully
    now.)</emphasis>
  </para>
  <sect1 id="why-ocaml">
    <title>Why OCaml?</title>
    <para>
      Programming languages matter.
    </para>
    <para>
      The programming languages that you use affect your productivity.
      They affect how reliable your software is, how efficient it is,
      how easy it is to read, to refactor, and to extend. And the
      programming languages you know and use can deeply affect how you
      think about programming and software design.
    </para>
    <para>
      But not all ideas about how to design a programming language are
      created equal. Over the last 40 years, a few key language features
      have emerged that together form a kind of sweet-spot in language
      design. These features include:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Garbage collection
        </para>
      </listitem>
      <listitem>
        <para>
          First-class and higher-order functions
        </para>
      </listitem>
      <listitem>
        <para>
          Static type-checking
        </para>
      </listitem>
      <listitem>
        <para>
          Parametric polymorphism
        </para>
      </listitem>
      <listitem>
        <para>
          Support for programming with immutable values
        </para>
      </listitem>
      <listitem>
        <para>
          Algebraic datatypes and pattern-matching
        </para>
      </listitem>
      <listitem>
        <para>
          Type inference
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Some of these features you already know and love, and some are
      probably new to you. But as we hope to demonstrate over the course
      of this book, it turns out that there is something transformative
      about having them all together and able to interact with each
      other in a single language.
    </para>
    <para>
      Despite their importance, these ideas have made only limited
      inroads into mainstream languages. And when they do arrive there,
      like higher-order functions in C# or parametric polymorphism in
      Java, it's typically in a limited and awkward form. The only
      languages that support these ideas well are statically-typed
      functional programming languages like OCaml, F#, Haskell, Scala
      and Standard-ML.
    </para>
    <para>
      Among this worthy set of languages, OCaml stands apart because it
      manages to provide a great deal of power while remaining highly
      pragmatic, highly performant, and comparatively simple to use and
      understand. It is this that makes OCaml a great choice for
      programmers who want to step up to a better programming language,
      and at the same time want to get practical work done.
    </para>
  </sect1>
  <sect1 id="why-core">
    <title>Why Core?</title>
    <para>
      A language on its own isn't enough. You also need a rich set of
      libraries to base your applications on. A common source of
      frustration for those learning OCaml is that the standard library
      that ships with the OCaml compiler is not ideal. While it's well
      implemented, it covers only a small subset of the functionality
      you expect from a standard library, and the interfaces are
      idiosyncratic and inconsistent.
    </para>
    <para>
      But all is not lost! There is an effective alternative to the
      OCaml standard library called Core. Jane Street, a company that
      has been using OCaml for nearly a decade, developed Core for its
      own internal use, but it was designed from the start with an eye
      towards being a general-purpose standard library. Core is also
      distributed with syntax-extensions which provide essential new
      functionality to OCaml; and there are additional libraries, like
      Core_extended and Async, that provide even more useful
      functionality.
    </para>
    <para>
      We believe that Core makes OCaml a better tool, and that's why
      we'll present OCaml and Core together.
    </para>
  </sect1>
  <sect1 id="about-the-authors">
    <title>About the Authors</title>
    <sect2 id="jason-hickey">
      <title>Jason Hickey</title>
      <para>
        Jason Hickey is a Software Engineer at Google Inc. in Mountain
        View, California. He is part of the team that designs and
        develops the global computing infrastructure used to support
        Google services, including the software systems for managing and
        scheduling massively distributed computing resources.
      </para>
      <para>
        Prior to joining Google, Jason was an Assistant Professor of
        Computer Science at Caltech, where his research was in reliable
        and fault-tolerant computing systems, including programming
        language design, formal methods, compilers, and new models of
        distributed computation. He obtained his PhD in Computer Science
        from Cornell University, where he studied programming languages.
        He is the author of the MetaPRL system, a logical framework for
        design and analysis of large software systems; OMake, an
        advanced build system for large software projects. He is the
        author of the textbook, <emphasis>An Introduction to Objective
        Caml</emphasis> (unpublished).
      </para>
    </sect2>
    <sect2 id="anil-madhavapeddy">
      <title>Anil Madhavapeddy</title>
      <para>
        Anil Madhavapeddy is a Senior Research Fellow at the University
        of Cambridge, based in the Systems Research Group. He was on the
        original team that developed the Xen hypervisor, and helped
        develop an industry-leading cloud management toolstack written
        entirely in OCaml. This XenServer product has been deployed on
        hundreds of thousands of physical hosts, and drives critical
        infrastructure for many Fortune 500 companies.
      </para>
      <para>
        Prior to obtaining his PhD in 2006 from the University of
        Cambridge, Anil had a diverse background in industry at Network
        Appliance, NASA and Internet Vision. In addition to professional
        and academic activities, he is an active member of the
        open-source development community with the OpenBSD operating
        system, is co-chair of the Commercial Uses of Functional
        Programming workshop, and serves on the boards of startup
        companies such as Ashima Arts where OCaml is extensively used.
      </para>
    </sect2>
    <sect2 id="yaron-minsky">
      <title>Yaron Minsky</title>
      <para>
        Yaron Minsky heads the Technology group at Jane Street, a
        proprietary trading firm that is the largest industrial user of
        OCaml. He was responsible for introducing OCaml to the company
        and for managing the company's transition to using OCaml for all
        of its core infrastructure. Today, billions of dollars worth of
        securities transactions flow each day through those systems.
      </para>
      <para>
        Yaron obtained his PhD in Computer Science from Cornell
        University, where he studied distributed systems. Yaron has
        lectured, blogged and written about OCaml for years, with
        articles published in Communications of the ACM and the Journal
        of Functional Programming. He chairs the steering committee of
        the Commercial Users of Functional Programming, and is a member
        of the steering committee for the International Conference on
        Functional Programming.
      </para>
    </sect2>
  </sect1>
</chapter>
<chapter id="a-guided-tour">
  <title>A Guided Tour</title>
  <para>
    This chapter is going to give an overview of OCaml by walking
    through a series of small examples that cover most of the major
    features. This should give a sense of what OCaml can do, without
    going into too much detail about any particular topic.
  </para>
  <para>
    We'll present this guided tour using the OCaml toplevel, an
    interactive shell that lets you type in expressions and evaluate
    them interactively. When you get to the point of running real
    programs, you'll want to leave the toplevel behind, but it's a great
    tool for getting to know the language.
  </para>
  <para>
    You should have a working toplevel as you go through this chapter,
    so you can try out the examples as you go. There is a
    zero-configuration browser-based toplevel that you can use for this,
    which you can find here:
  </para>
  <programlisting>
 http://realworldocaml.org/core-top
</programlisting>
  <para>
    Or you can install OCaml and Core on your computer directly.
    Instructions for this are found in Appendix {???}.
  </para>
  <sect1 id="ocaml-as-a-calculator">
    <title>OCaml as a calculator</title>
    <para>
      Let's spin up the toplevel and open the
      <literal>Core.Std</literal> module, which gives us access to
      Core's libraries, and then try out a few simple numerical
      calculations.
    </para>
    <programlisting language="ocaml">
$ rlwrap ocaml
        Objective Caml version 3.12.1

# open Core.Std;;
# 3 + 4;;
- : int = 7
# 8 / 3;;
- : int = 2
# 3.5 +. 6.;;
- : float = 9.5
# sqrt 9.;;
- : float = 3.
</programlisting>
    <para>
      This looks a lot what you'd expect from any language, but there
      are a few differences that jump right out at you.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          We needed to type <literal>;;</literal> in order to tell the
          toplevel that it should evaluate an expression. This is a
          pecularity of the toplevel that is not required in compiled
          code.
        </para>
      </listitem>
      <listitem>
        <para>
          After evaluating an expression, the toplevel spits out both
          the type of the result and the result itself.
        </para>
      </listitem>
      <listitem>
        <para>
          Function application in OCaml is syntactically unusual, in
          that function arguments are written out separated by spaces,
          rather than being demarcated by parens and commas.
        </para>
      </listitem>
      <listitem>
        <para>
          OCaml carefully distinguishes between
          <literal>float</literal>, the type for floating point numbers
          and <literal>int</literal>. The types have different literals
          (<literal>6.</literal> instead of <literal>6</literal>) and
          different infix operators (<literal>+.</literal> instead of
          <literal>+</literal>), and OCaml doesn't do any automated
          casting between the types. This can be a bit of a nuisance,
          but it has its benefits, since it prevents some classes of
          bugs that arise from confusion between the semantics of
          <literal>int</literal> and <literal>float</literal>.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We can also create variables to name the value of a given
      expression, using the <literal>let</literal> syntax.
    </para>
    <programlisting language="ocaml">
# let x = 3 + 4;;
val x : int = 7
# let y = x + x;;
val y : int = 14
</programlisting>
    <para>
      After a new variable is created, the toplevel tells us the name of
      the variable, in addition to its type and value.
    </para>
  </sect1>
  <sect1 id="functions-and-type-inference">
    <title>Functions and Type Inference</title>
    <para>
      The <literal>let</literal> syntax can also be used for creating
      functions:
    </para>
    <programlisting language="ocaml">
# let square x = x * x ;;
val square : int -&gt; int = &lt;fun&gt;
# square (square 2);;
- : int = 16
</programlisting>
    <para>
      Now that we're creating more interesting values, the types have
      gotten more interesting too. <literal>int -&gt; int</literal> is a
      function type, in this case indicating a function that takes an
      <literal>int</literal> and returns an <literal>int</literal>. We
      can also write functions that take multiple arguments:
    </para>
    <programlisting language="ocaml">
# let abs_diff x y =
    abs (x - y) ;;
val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      and even functions that take other functions as arguments:
    </para>
    <programlisting language="ocaml">
# let abs_change f x =
    abs_diff (f x) x ;;
val abs_change : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;
# abs_change square 10;;
- : int = 90
</programlisting>
    <para>
      This notation for multi-argument functions may be a little
      surprising at first, but we'll explain where it comes from when we
      get to function currying in Chapter {{{VARIABLES}}}. For the
      moment, think of the arrows as separating different arguments of
      the function, with the type after the final arrow being the return
      value of the function. Thus,
    </para>
    <programlisting language="ocaml">
int -&gt; int -&gt; int
</programlisting>
    <para>
      describes a function that takes two <literal>int</literal>
      arguments and returns an <literal>int</literal>, while
    </para>
    <programlisting language="ocaml">
(int -&gt; int) -&gt; int -&gt; int
</programlisting>
    <para>
      describes a function of two arguments where the first argument is
      itself a function.
    </para>
    <para>
      As the types we encounter get more complicated, you might ask
      yourself how OCaml is able to determine these types, given that we
      didn't write down any explicit type information. It turns out that
      OCaml is able to determine the type of a new expression using a
      technique called <emphasis>type-inference</emphasis>, by which it
      infers the type of a new expression based on what it already knows
      about the types of other related variables. For example, in
      <literal>abs_change</literal> above, the fact that
      <literal>abs_diff</literal> is already known to take two integer
      arguments lets the compiler infer that <literal>x</literal> is an
      <literal>int</literal> and that <literal>f</literal> returns an
      <literal>int</literal>.
    </para>
    <para>
      Sometimes, there isn't enough information to fully determine the
      concrete type of a given value. Consider this function.
    </para>
    <programlisting language="ocaml">
# let first_if_true test x y =
    if (test x) then x else y;;
</programlisting>
    <para>
      <literal>first_if_true</literal> takes as its arguments a function
      <literal>test</literal>, and two values, <literal>x</literal> and
      <literal>y</literal>, where <literal>x</literal> is to be returned
      if <literal>(test x)</literal> evaluates to
      <literal>true</literal>, and <literal>y</literal> otherwise. So
      what's the type of <literal>first_if_true</literal>? There are no
      obvious clues such as arithmetic operators to tell you what the
      type of <literal>x</literal> and <literal>y</literal> are. Indeed,
      it seems like one could use this <literal>first_if_true</literal>
      on values of any type. Indeed, if we look at the type returned by
      the toplevel:
    </para>
    <programlisting language="ocaml">
val first_if_true : ('a -&gt; bool) -&gt; 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      we see that rather than choose a single concrete type, OCaml has
      introduced a <emphasis>type variable</emphasis>
      <literal>'a</literal> to express that the type is generic. In
      particular, the type of the <literal>test</literal> argument is
      <literal>('a -&gt; bool)</literal>, which means that test is a
      one-argument function whose return value is
      <literal>bool</literal>, and whose argument could be of any type
      <literal>'a</literal>. But, whatever type <literal>'a</literal>
      is, it has to be the same as the type of the other two arguments,
      <literal>x</literal> and <literal>y</literal>.
    </para>
    <para>
      This genericity means that we can write:
    </para>
    <programlisting language="ocaml">
# let long_string s = String.length s &gt; 6;;
val long_string : string -&gt; bool = &lt;fun&gt;
# first_if_true long_string &quot;short&quot; &quot;loooooong&quot;;;
- : string = &quot;loooooong&quot;
</programlisting>
    <para>
      And we can also write:
    </para>
    <programlisting language="ocaml">
# let big_number x = x &gt; 3;;
val big_number : int -&gt; bool = &lt;fun&gt;
# first_if_true big_number 4 3;;
- : int = 4
</programlisting>
    <para>
      But we can't mix and match two different concrete types for
      <literal>'a</literal> in the same use of
      <literal>first_if_true</literal>:
    </para>
    <programlisting language="ocaml">
# first_if_true big_number &quot;short&quot; &quot;loooooong&quot;;;
Characters 25-30:
  first_if_true big_number &quot;short&quot; &quot;loooooong&quot;;;
                           ^^^^^^^
Error: This expression has type string but
    an expression was expected of type int
</programlisting>
    <para>
      While the <literal>'a</literal> in the type of
      <literal>first_if_true</literal> can be instantiated as any
      concrete type, it has to be the same concrete type in all of the
      different places it appears. This kind of genericity is called
      <emphasis>parametric polymorphism</emphasis>, and is very similar
      to generics in C# and Java.
    </para>
    <sidebar><title>
    Type errors vs exceptions
    </title>
    <para>
      There's a big difference in OCaml (and really in any compiled
      language) between errors that are caught at compile time and those
      that are caught at run-time. It's better to catch errors as early
      as possible in the development process, and compilation time is
      best of all.
    </para>
    <para>
      Working in the top-level somewhat obscures the difference between
      run-time and compile time errors, but that difference is still
      there. Generally, type errors, like this one:
    </para>
    <programlisting>
# 3 + &quot;potato&quot;;;
Characters 4-12:
  3 + &quot;potato&quot;;;
      ^^^^^^^^
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
    <para>
      are compile-time errors, whereas an error that can't be caught by
      the type system, like division by zero, leads to a runtime
      exception.
    </para>
    <programlisting>
# 3 / 0;;
Exception: Division_by_zero.
</programlisting>
    <para>
      One important distinction is that type errors will stop you
      whether or not the offending code is ever actually executed. Thus,
      you get an error from typing in this code:
    </para>
    <programlisting>
# if 3 &lt; 4 then 0 else 3 + &quot;potato&quot;;;
Characters 25-33:
  if 3 &lt; 4 then 0 else 3 + &quot;potato&quot;;;
                           ^^^^^^^^
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
    <para>
      but this code works fine.
    </para>
    <programlisting language="ocaml">
# if 3 &lt; 4 then 0 else 3 / 0;;
- : int = 0
</programlisting>
    </sidebar>
  </sect1>
  <sect1 id="tuples-lists-options-and-pattern-matching">
    <title>Tuples, Lists, Options and Pattern-matching</title>
    <sect2 id="tuples">
      <title>Tuples</title>
      <para>
        So far we've encountered a handful of basic types like
        <literal>int</literal>, <literal>float</literal> and
        <literal>string</literal> as well as function types like
        <literal>string -&gt; int</literal>. But we haven't yet talked
        about any data structures. We'll start by looking at a
        particularly simple data structure, the tuple. You can create a
        tuple by joining values together with a comma:
      </para>
      <programlisting language="ocaml">
# let tup = (3,&quot;three&quot;);;
val tup : int * string = (3, &quot;three&quot;)
</programlisting>
      <para>
        The type <literal>int * string</literal> corresponds to the set
        of pairs of <literal>int</literal>s and
        <literal>string</literal>s. For the mathematically inclined, the
        <literal>*</literal> character is used because the space of all
        2-tuples of type <literal>t * s</literal> corresponds to the
        Cartesian product of <literal>t</literal> and
        <literal>s</literal>.
      </para>
      <para>
        You can extract the components of a tuple using OCaml's
        pattern-matching syntax. For example:
      </para>
      <programlisting>
# let (x,y) = tup;;
val x : int = 3
val y : string = &quot;three&quot;
</programlisting>
      <para>
        Here, the <literal>(x,y)</literal> on the right-hand side of the
        <literal>let</literal> is the pattern. This pattern lets us mint
        the new variables <literal>x</literal> and <literal>y</literal>,
        each bound to different components of the value being matched.
        Note that the same syntax is used both for constructing and for
        pattern-matching on tuples.
      </para>
      <para>
        Here's an example of how you might use pattern matching in
        practice: a function for computing the distance between two
        points on the plane, where each point is represented as a pair
        of <literal>float</literal>s.
      </para>
      <programlisting language="ocaml">
# let distance p1 p2 =
    let (x1,y1) = p1 in
    let (x2,y2) = p2 in
    sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2)
;;
val distance : float * float -&gt; float * float -&gt; float = &lt;fun&gt;
</programlisting>
      <para>
        We can make this code more concise by doing the pattern matching
        on the arguments to the function directly.
      </para>
      <programlisting language="ocaml">
# let distance (x1,y1) (x2,y2) =
    sqrt ((x1 -. x2) ** 2. +. sqr (y1 -. y2) ** 2.)
;;
</programlisting>
      <para>
        This is just a first taste of pattern matching. We'll see that
        pattern matching shows up in many contexts in OCaml, and turns
        out to be a surprisingly powerful and pervasive tool.
      </para>
    </sect2>
    <sect2 id="lists">
      <title>Lists</title>
      <para>
        Where tuples let you combine a fixed number of items,
        potentially of different types, lists let you hold any number of
        items of the same type. For example:
      </para>
      <programlisting language="ocaml">
# let languages = [&quot;OCaml&quot;;&quot;Perl&quot;;&quot;C&quot;];;
val languages : string list = [&quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
      <para>
        Note that you can't mix elements of different types on the same
        list, as we did with tuples.
      </para>
      <programlisting language="ocaml">
# let numbers = [3;&quot;four&quot;;5];;
Characters 17-23:
  let numbers = [3;&quot;four&quot;;5];;
                   ^^^^^^
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
      <para>
        In addition to constructing lists using brackets, we can use the
        operator <literal>::</literal> for adding elements to the front
        of a list.
      </para>
      <programlisting>
# &quot;French&quot; :: &quot;Spanish&quot; :: languages;;
- : string list = [&quot;French&quot;; &quot;Spanish&quot;; &quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
      <para>
        Here, we're creating a new extended list, not changing the list
        we started with, as we can see.
      </para>
      <programlisting>
# languages;;
- : string list = [&quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
      <para>
        The bracket notation for lists is really just syntactic sugar
        for <literal>::</literal>. Thus, the following declarations are
        all equivalent. Note that <literal>[]</literal> is used to
        represent the empty list.
      </para>
      <programlisting language="ocaml">
# [1; 2; 3];;
- : int list = [1; 2; 3]
# 1 :: (2 :: (3 :: []));;
- : int list = [1; 2; 3]
# 1 :: 2 :: 3 :: [];;
- : int list = [1; 2; 3]
</programlisting>
      <para>
        Thus, <literal>::</literal> and <literal>[]</literal>, which are
        examples of what are called
        <emphasis>type-constructors</emphasis>, are the basic
        building-blocks for lists.
      </para>
      <sect3 id="basic-list-patterns">
        <title>Basic list patterns</title>
        <para>
          The elements of a list can be accessed through
          pattern-matching. List patterns are fundamentally based on the
          two list constructors, <literal>[]</literal> and
          <literal>::</literal>. Here's a simple example.
        </para>
        <programlisting language="ocaml">
# let (my_favorite :: the_rest) = languages ;;
val my_favorite : string = &quot;OCaml&quot;
val the_rest : string list = [&quot;Perl&quot;; &quot;C&quot;]
</programlisting>
        <para>
          By pattern matching using <literal>::</literal>, we've broken
          off the first element of <literal>languages</literal> from the
          rest of the list. If you know Lisp or Scheme, what we've done
          is the equivalent of using <literal>car</literal> and
          <literal>cdr</literal> to break down a list.
        </para>
        <para>
          If you tried the above example in the toplevel, you probably
          noticed that I omitted a warning generated by the compiler.
          Here's the full output:
        </para>
        <programlisting>
# let (my_favorite :: the_rest) = languages ;;
Characters 5-28:
  let (my_favorite :: the_rest) = languages ;;
       ^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val my_favorite : string = &quot;OCaml&quot;
val the_rest : string list = [&quot;Perl&quot;; &quot;C&quot;]
</programlisting>
        <para>
          The warning comes because the compiler can't be certain that
          the pattern match won't lead to a runtime error, and the
          warnings gives an example of the problem, the empty list,
          <literal>[]</literal>. Indeed, if we try to use such a
          pattern-match on the empty list:
        </para>
        <programlisting language="ocaml">
# let (my_favorite :: the_rest) = [];;
Characters 5-28:
  let (my_favorite :: the_rest) = [];;
       ^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
Exception: (Match_failure &quot;&quot; 1 5).
</programlisting>
        <para>
          we get a runtime error in addition to the compilation warning.
        </para>
        <para>
          You can avoid these warnings, and more importantly make sure
          that your code actually handles all of the possible cases, by
          using a <literal>match</literal> statement. Here's an example:
        </para>
        <programlisting language="ocaml">
# let my_favorite_language languages =
    match languages with
    | first :: the_rest -&gt; first
    | [] -&gt; &quot;OCaml&quot; (* A good default! *)
 ;;
val my_favorite_language : string list -&gt; string = &lt;fun&gt;
# my_favorite_language [&quot;English&quot;;&quot;Spanish&quot;;&quot;French&quot;];;
- : string = &quot;English&quot;
# my_favorite_language [];;
- : string = &quot;OCaml&quot;
</programlisting>
      </sect3>
      <sect3 id="recursive-list-functions">
        <title>Recursive list functions</title>
        <para>
          If we combine pattern matching with a recursive function call,
          we can do things like define a function for summing the
          elements of a list.
        </para>
        <programlisting language="ocaml">
# let rec sum l =
    match l with
    | [] -&gt; 0
    | hd :: tl -&gt; hd + sum tl
  ;;
val sum : int list -&gt; int
# sum [1;2;3;4;5];;
- : int = 15
</programlisting>
        <para>
          We had to add the <literal>rec</literal> keyword in the
          definition of <literal>sum</literal> to allow
          <literal>sum</literal> to refer to itself. We can introduce
          more complicated list patterns as well. Here's a function for
          destuttering a list, <emphasis>i.e.</emphasis>, for removing
          sequential duplicates.
        </para>
        <programlisting language="ocaml">
# let rec destutter list =
    match list with
    | [] -&gt; []
    | hd1 :: (hd2 :: tl) -&gt;
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl)
</programlisting>
        <para>
          Actually, the code above has a problem. If you type it into
          the top-level, you'll see this error:
        </para>
        <programlisting>
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::[]
</programlisting>
        <para>
          This is warning you that we've missed something, in particular
          that our code doesn't handle one-element lists. That's easy
          enough to fix by adding another case to the match:
        </para>
        <programlisting language="ocaml">
# let rec destutter list =
    match list with
    | [] -&gt; []
    | [hd] -&gt; [hd]
    | hd1 :: (hd2 :: tl) -&gt;
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl)
val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
# destutter [&quot;hey&quot;;&quot;hey&quot;;&quot;hey&quot;;&quot;man!&quot;];;
- : string list = [&quot;hey&quot;; &quot;man!&quot;]
</programlisting>
        <para>
          Note that in the above, we used another variant of the list
          pattern, <literal>[hd]</literal>, to match a list with a
          single element. We can do this to match a list with any fixed
          number of elements, <emphasis>e.g.</emphasis>,
          <literal>[x;y;z]</literal> will match any list with exactly
          three elements, and will bind those elements to the variables
          <literal>x</literal>, <literal>y</literal> and
          <literal>z</literal>.
        </para>
      </sect3>
      <sect3 id="the-list-module">
        <title>The <literal>List</literal> module</title>
        <para>
          So far, we've built up all of our list functions using pattern
          matching and recursion. But in practice, this isn't usually
          necessary. OCaml libraries are organized into
          <emphasis>modules</emphasis>, and there is a module in Core
          called <literal>List</literal> which contains many useful
          functions for dealing with lists. For example:
        </para>
        <programlisting language="ocaml">
# List.map ~f:String.length languages;;
- : int list = [5; 4; 1]
</programlisting>
        <para>
          Here, we use the dot-notation to reference elements of the
          <literal>List</literal> and <literal>String</literal> module.
          <literal>List.map</literal> in particular is a function that
          takes a list and a function for transforming elements of that
          list, and returns to us a new list with the transformed
          elements.
        </para>
        <para>
          There's another new piece of syntax to learn here: labeled
          arguments. <literal>String.length</literal> is passed with the
          label, <literal>~f</literal>. Labeled arguments are arguments
          that are specified by name rather than position, which means
          they can be passed in any order. Thus, we could have written
          <literal>List.map languages ~f:String.length</literal> instead
          of <literal>List.map ~f:String.length languages</literal>.
          We'll see why labels are important in Chapter {{{Functions}}}.
        </para>
      </sect3>
    </sect2>
    <sect2 id="options">
      <title>Options</title>
      <para>
        Another common data structure in OCaml is the
        <literal>option</literal>. An <literal>option</literal> is used
        to express that a value that might or might not be present. For
        example,
      </para>
      <programlisting language="ocaml">
# let divide x y =
    if y = 0 then None else Some (x/y)
val divide : int -&gt; int -&gt; int option = &lt;fun&gt;
</programlisting>
      <para>
        <literal>Some</literal> and <literal>None</literal> are type
        constructors, like <literal>::</literal> and
        <literal>[]</literal> for lists, which let you build optional
        values. You can think of an <literal>option</literal> as a
        specialized list that can only have zero or one element.
      </para>
      <para>
        To get a value out of an option, we use pattern matching, as we
        did with tuples and lists. Consider the following simple
        function for printing a log entry given an optional time and a
        message. If no time is provided (<emphasis>i.e.</emphasis>, if
        the time is <literal>None</literal>), the current time is
        computed and used in its place.
      </para>
      <programlisting language="ocaml">
# let print_log_entry maybe_time message =
    let time =
      match maybe_time with
      | Some x -&gt; x
      | None -&gt; Time.now ()
    in
    printf &quot;%s: %s\n&quot; (Time.to_string time) message
val print_log_entry : Time.t option -&gt; string -&gt; unit
</programlisting>
      <para>
        Here, we again use a match statement for handling the two
        possible states of an option. It's worth noting that we don't
        necessarily need to use an explicit <literal>match</literal>
        statement in this case. We can instead use some built in
        functions from the <literal>Option</literal> module, which, like
        the <literal>List</literal> module for lists, is a place where
        you can find a large collection of useful functions for working
        with options.
      </para>
      <para>
        In this case, we can rewrite <literal>print_log_entry</literal>
        using <literal>Option.value</literal>, which either returns the
        content of an option if the option is <literal>Some</literal>,
        or a default value if the option is <literal>None</literal>.
      </para>
      <programlisting language="ocaml">
# let print_log_entry maybe_time message =
    let time = Option.value ~default:(Time.now ()) maybe_time in
    printf &quot;%s: %s\n&quot; (Time.to_string time) message
</programlisting>
      <para>
        Options are important because they are the standard way in OCaml
        to encode a value that might not be there. Values in OCaml are
        non-nullable, so if you have a function that takes an argument
        of type <literal>string</literal>, then the compiler guarantees
        that, if the code compiles successfully, then at run-time, that
        function will only be called with awell-defined value of type
        <literal>string</literal>. This is different from most other
        languages, including Java and C#, where objects are by default
        nullable, and whose type systems do little to defend from
        null-pointer exceptions at runtime.
      </para>
    </sect2>
  </sect1>
  <sect1 id="records-and-variants">
    <title>Records and Variants</title>
    <para>
      So far, we've only looked at data structures that were pre-defined
      in the language, like lists and tuples. But OCaml also allows us
      to define new datatypes. Here's a toy example of a datatype
      representing a point in 2-dimensional space:
    </para>
    <programlisting language="ocaml">
# type point2d = { x : float; y : float };;
type point2d = { x : float; y : float; }
</programlisting>
    <para>
      <literal>point2d</literal> is a <emphasis>record</emphasis> type,
      which you can think of as a tuple where the individual fields are
      named, rather than being defined positionally. Record types are
      easy enough to construct:
    </para>
    <programlisting language="ocaml">
# let p = { x = 3.; y = -4. };;
val p : point2d = {x = 3.; y = -4.}
</programlisting>
    <para>
      And we can get access to the contents of these types using pattern
      matching:
    </para>
    <programlisting language="ocaml">
# let magnitude { x = x; y = y } = sqrt (x ** 2. +. y ** 2.);;
val magnitude : point2d -&gt; float = &lt;fun&gt;
</programlisting>
    <para>
      In the case where we want to name the value in a record field
      after the name of that field, we can write the pattern match even
      more tersely. Instead of writing <literal>{ x = x }</literal> to
      name a variable <literal>x</literal> for the value of field
      <literal>x</literal>, we can write <literal>{ x }</literal>. Using
      this, we can rewrite the magnitude function as follows.
    </para>
    <programlisting language="ocaml">
# let magnitude { x; y } = sqrt (x ** 2. +. y ** 2.);;
</programlisting>
    <para>
      We can also use dot-notation for accessing record fields:
    </para>
    <programlisting language="ocaml">
# let distance v1 v2 =
     magnitude { x = v1.x -. v2.x; y = v1.y -. v2.y };;
val distance : point2d -&gt; point2d -&gt; float = &lt;fun&gt;
</programlisting>
    <para>
      And we can of course include our newly defined types as components
      in larger types, as in the following types, each of which
      representing a different geometric object.
    </para>
    <programlisting language="ocaml">
# type circle = { center: point2d; radius: float } ;;
# type rect = { lower_left: point2d; width: float; height: float } ;;
# type segment = { endpoint1: point2d; endpoint2: point2d } ;;
</programlisting>
    <para>
      Now, imagine that you want to combine multiple of these objects
      together, say as a description of a multi-object scene. You need
      some unified way of representing these objects together in a
      single type. One way of doing this is using a
      <emphasis>variant</emphasis> type:
    </para>
    <programlisting language="ocaml">
# type shape = | Circle of circle
               | Rect of rect
               | Segment of segment;;
</programlisting>
    <para>
      The <literal>|</literal> character separates the different cases
      of the variant (the first <literal>|</literal> is optional), and
      each case has a tag (like <literal>Circle</literal>,
      <literal>Rect</literal> and <literal>Segment</literal>) to
      distinguish that case from the others. Here's how we might write a
      function for testing whether a point is in the interior of one of
      a <literal>shape list</literal>.
    </para>
    <programlisting language="ocaml">
# let is_inside_shape point shape =
     match shape with
     | Circle { center; radius } -&gt;
       distance center point &lt; radius
     | Rect { lower_left; width; height } -&gt;
       point.x &gt; lower_left.x &amp;&amp; point.x &lt; lower_left.x +. width
       &amp;&amp; point.y &gt; lower_left.y &amp;&amp; point.y &lt; lower_left.y +. height
     | Segment _ -&gt; false
     ;;
val is_inside_shape : point2d -&gt; shape -&gt; bool = &lt;fun&gt;
# let is_inside_shapes point shapes =
     let point_is_inside_shape shape =
       is_inside_shape point shape
     in
     List.for_all shapes ~f:point_is_inside_shape
val is_inside_shapes : point2d -&gt; shape list -&gt; bool = &lt;fun&gt;
</programlisting>
    <para>
      You might at this point notice that the use of
      <literal>match</literal> here is reminiscent of how we used
      <literal>match</literal> with <literal>option</literal> and
      <literal>list</literal>. This is no accident:
      <literal>option</literal> and <literal>list</literal> are really
      just examples of variant types that happen to be important enough
      to be defined in the standard library (and in the case of lists,
      to have some special syntax).
    </para>
  </sect1>
  <sect1 id="mutation">
    <title>Mutation</title>
    <para>
      All of our examples so far have been examples of mutation-free, or
      <emphasis>pure</emphasis> code. This is typical of code in
      functional languages, which tend to have a focus on so-called
      <emphasis>pure</emphasis> code. That said, OCaml has good support
      for mutation, including standard mutable data structures like
      arrays and hashtables. For example:
    </para>
    <programlisting>
# let numbers = [| 1;2;3;4 |];;
val numbers : int array = [|1; 2; 3; 4|]
# numbers.(2) &lt;- 4;;
- : unit = ()
# numbers;;
- : int array = [|1; 2; 4; 4|]
</programlisting>
    <para>
      In the above, the <literal>ar.(i)</literal> syntax is used for
      referencing the element of an array, and the
      <literal>&lt;-</literal> syntax is used for setting a mutable
      value.
    </para>
    <para>
      Variable bindings in OCaml are always immutable, but
      datastructures like arrays can be mutable. In addition, record
      fields, which are immutable by default can be declared as mutable.
      Here's a small example of a datastructure for mutable storing a
      running sum. Here, we've declared all the record fields as
      mutable. Here
    </para>
    <programlisting language="ocaml">
# type running_sum = { mutable sum: float;
                       mutable sum_sq: float; (* sum of squares, for stdev *)
                       mutable samples: float; }
  let empty () = { sum = 0.; sum_sq = 0.; samples = 0. }
  let mean rsum = rsum.sum /. rsum.samples
  let stdev rsum =
     let square x = x *. x in
     sqrt (rsum.sum_sq /. rsum.samples -. square (rsum.sum /. rsum.samples))
  let update rsum x =
     rsum.sum &lt;- rsum.sum +. x;
     rsum.sum_sq &lt;- rsum.sum_sq +. x *. x;
     rsum.samples &lt;- rsum.samples +. 1.
  ;;
# let rsum = empty ();;
val rsum : running_sum = {sum = 0.; sum_sq = 0.; samples = 0}
# List.iter [1.;3.;2.;-7.;4.;5.] ~f:(fun x -&gt; update rsum x);;
- : unit = ()
# mean rsum;;
- : float = 1.33333333333333326
# stdev rsum;;
- : float = 1.61015297179882655
</programlisting>
    <para>
      We can declare a single mutable value by using a
      <literal>ref</literal>, which is a record type with a single
      mutable field that is defined in the standard library.
    </para>
    <programlisting>
# let x = { contents = 0 };;
val x : int ref = {contents = 0}
# x.contents &lt;- x.contents + 1;;
- : unit = ()
# x;;
- : int ref = {contents = 1}
</programlisting>
    <para>
      There are a handful of useful functions and operators defined for
      refs to make them more convenient to work with.
    </para>
    <programlisting language="ocaml">
# let x = ref 0 ;; (* create a ref, i.e., { contents = 0 } *)
val x : int ref = {contents = 0}
# !x ;;            (* get the contents of a ref, i.e., x.contents *)
- : int = 0
# x := !x + 1 ;;   (* assignment, i.e., x.contents &lt;- ... *)
- : unit = ()
# incr x ;;        (* increment, i.e., x := !x + 1 *)
- : unit = ()
# !x ;;
- : int = 2
</programlisting>
  </sect1>
  <sect1 id="io">
    <title>I/O</title>
    <para>
    </para>
  </sect1>
</chapter>
<chapter id="variables-and-functions">
  <title>Variables and Functions</title>
  <para>
    Variables are a fundamental concept in programming, one that comes
    up in all but the simplest of examples. Indeed, we encountered
    OCaml's variables multiple times in chapter {{TOUR}}. But while
    variables are no doubt a familiar topic, variables in OCaml are
    different in subtle but important ways from what you find in most
    other languages. Accordingly we're going to spend a some time diving
    into the details of how variables work in OCaml.
  </para>
  <para>
    At its simplest, a variable is an identifier whose meaning is bound
    to a particular value. In OCaml these bindings are usually
    introduced using the <literal>let</literal> keyword, which at the
    top-level of a module has the following syntax.
  </para>
  <programlisting>
let &lt;identifier&gt; = &lt;expr&gt;
</programlisting>
  <para>
    Every variable binding has a <emphasis>scope</emphasis>, which is
    the portion of the code that considers the given variable binding
    during its evaluation. The scope of a top-level let binding is
    everything that follows it in that module (or, the remainder of the
    session if you're using the top-level.)
  </para>
  <para>
    Here's a simple example.
  </para>
  <programlisting>
# let x = 3;;
val x : int = 3
# let y = 4;;
val y : int = 4
# let z = x + y;;
val z : int = 7
</programlisting>
  <para>
    <literal>let</literal> can also be used to create a variable binding
    whose scope is limited to a particular, bounded expression, using
    the following syntax.
  </para>
  <programlisting>
let &lt;identifier&gt; = &lt;expr1&gt; in &lt;expr2&gt;
</programlisting>
  <para>
    This first evaluates <literal>&lt;expr1&gt;</literal>, and then
    evaluates <literal>&lt;expr2&gt;</literal>, with
    <literal>&lt;identifier&gt;</literal> bound to whatever value was
    produced by the evaluation of <literal>&lt;expr1&gt;</literal>. For
    example, <literal>let x = 3 + 1 in x * 2</literal> evaluates to
    <literal>8</literal>.
  </para>
  <para>
    In this form, multiple let bindings can be nested, like this:
  </para>
  <programlisting>
# let x = 3 in
  let y = 4 in
  x + y
;;
- : int = 7
</programlisting>
  <para>
    Note that nested bindings can <emphasis>shadow</emphasis>, or hide,
    previous bindings. Thus, we can write
  </para>
  <programlisting language="ocaml">
# let x = 1 in
  let x = x + x in
  let x = Int.to_string (x + x) in
  x ^ x;;
- : string = &quot;44&quot;
</programlisting>
  <para>
    It's important not to confuse shadowing of variables with
    assignment, <emphasis>i.e.</emphasis>, mutation. Consider the
    following function.
  </para>
  <programlisting>
# let x = 3 in
  let add_to_x y = x + y in
  let x = 4 in
  add_to_x 0
;;
- : int = 3
</programlisting>
  <para>
    If the second let binding of x were in fact an assignment, then you
    would expect <literal>add_to_x 0</literal> to return
    <literal>4</literal>. Instead, it returns <literal>3</literal>,
    because the <literal>x</literal> that <literal>add_to_x</literal>
    refers to is still there, unchanged, even after the new binding of
    <literal>x</literal> to <literal>4</literal> is created.
  </para>
  <para>
    Here's another demonstration of how let bindings differ from
    assignment. In the following example, the second binding of
    <literal>x</literal> is only visible within the scope of a fixed
    sub-expression, in particular, the sub-expression that makes up the
    right-hand side of the definition of <literal>y</literal>. When the
    definition of <literal>y</literal> is complete, we see that the
    inner definition disappears, and the original definition of
    <literal>x</literal> shows up again, unaffected.
  </para>
  <programlisting language="ocaml">
# let x = 3 in
  let y =
    let x = 2 in
    x + x
  in
  x + y
- : int = 7
</programlisting>
  <para>
    In OCaml, let bindings are always immutable. As we'll see in chapter
    {{MUTABILITY}}, there are mutable values in OCaml, but no mutable
    variables.
  </para>
  <sect1 id="pattern-matching-and-let">
    <title>Pattern matching and <literal>let</literal></title>
    <para>
      Another useful feature of let bindings is that they support the
      use of patterns on the left-hand side of the bind. Consider the
      following code, which uses <literal>List.unzip</literal>, a
      function for converting a list of pairs to a pair of lists.
    </para>
    <programlisting>
# let (ints,strings) = List.unzip [(1,&quot;one&quot;); (2,&quot;two&quot;); (3,&quot;three&quot;)]
val ints : int Core.Std.List.t = [1; 2; 3]
val strings : string Core.Std.List.t = [&quot;one&quot;; &quot;two&quot;; &quot;three&quot;]
</programlisting>
    <para>
      This actually binds two variables, one for each element of the
      pair. Using a pattern in a let-binding makes the most sense for a
      pattern that is <emphasis>irrefutable</emphasis>, i.e., where any
      value of the type in question is guaranteed to match the pattern.
      Tuple and record patterns are irrefutable, but list patterns are
      not. Here's an example of a list pattern match that generates a
      warning because not all cases are covered.
    </para>
    <programlisting>
# let (hd::tl) = [1;2;3];;
Characters 4-12:
  let (hd::tl) = [1;2;3];;
      ^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
</programlisting>
    <para>
      As a general matter, inexhaustive matches like the one above
      should be avoided.
    </para>
  </sect1>
  <sect1 id="letand-bindings">
    <title><literal>let</literal>/<literal>and</literal>
    bindings</title>
    <para>
      Another form of let binding that comes up on occasion is where you
      bind multiple arguments in a single declaration. For example, we
      can write:
    </para>
    <programlisting>
# let x = 100 and y = 3.5;;
val x : int = 100
val y : float = 3.5
</programlisting>
    <para>
      This can be useful when you want to create a number of new let
      bindings at once, without having each definition affect the next.
      So, if we wanted to create new bindings that swapped the values of
      <literal>x</literal> and <literal>y</literal>, we could write:
    </para>
    <programlisting>
# let x = y and y = x ;;
val x : float = 3.5
val y : int = 100
</programlisting>
    <para>
      This use-case doesn't come up that often. Most of the time that
      <literal>and</literal> comes into play, it's used to define
      multiple mutually recursive values, which we'll learn about later
      in the chapter.
    </para>
    <para>
      Note that when doing a
      <literal>let</literal>/<literal>and</literal> style declaration,
      the order of execution of the right-hand side of the binds is
      undefined.
    </para>
  </sect1>
  <sect1 id="functions">
    <title>Functions</title>
    <para>
      OCaml function declarations come in multiple styles. The most
      basic form is to create an <emphasis>anonymous</emphasis> function
      using the <literal>fun</literal> keyword:
    </para>
    <programlisting>
# (fun x -&gt; x + 1);;
- : int -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      The above expression creates a one-argument function, which can
      straightforwardly be applied to an argument:
    </para>
    <programlisting>
# (fun x -&gt; x + 1) 7;;
- : int = 8
</programlisting>
    <para>
      Anonymous functions are quite convenient, particularly in a
      higher-order context, <emphasis>e.g.</emphasis>, when constructing
      a function to be passed as an argument to another function.
    </para>
    <para>
      We can create a named function using a let binding.
    </para>
    <programlisting>
# let plusone = (fun x -&gt; x + 1);;
val plusone : int -&gt; int = &lt;fun&gt;
# plusone 3;;
- : int = 4
</programlisting>
    <para>
      The declaration of <literal>plusone</literal> above is equivalent
      to the following form, which we already saw in chapter {{TOUR}}:
    </para>
    <programlisting>
# let plusone x = x + 1;;
</programlisting>
    <para>
      This is the most common and convenient way to declare a function,
      but syntatic niceties aside, the two forms are entirely
      equivalent.
    </para>
    <sidebar>
    <title>
    <literal>let</literal> and <literal>fun</literal>
    </title>
    <para>
      Functions and let bindings have a lot to do with each other. In
      some sense, you can think of the argument of a function as a
      variable being bound to its argument. Indeed, the following two
      expressions are nearly equivalent:
    </para>
    <programlisting>
# (fun x -&gt; x + 1) 7;;
- : int = 8
# let x = 7 in x + 1;;
- : int = 8
</programlisting>
    <para>
      This connection is important, and will come up more when
      programming in a monadic style, as we'll see in chapter {{ASYNC}}.
    </para>
    </sidebar>
    <sect2 id="multi-argument-functions">
      <title>Multi-argument functions</title>
      <para>
        OCaml of course also supports multi-argument functions. Here's
        an example that came up in chapter {{TOUR}}.
      </para>
      <programlisting>
# let abs_diff x y = abs (x - y);;
val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;
# abs_diff 3 4;;
- : int = 1
</programlisting>
      <para>
        You may find the type signature of <literal>abs_diff</literal> a
        bit obscure at first. To understand what's going on, let's
        rewrite <literal>abs_diff</literal> in an equivalent form, using
        the <literal>fun</literal> keyword:
      </para>
      <programlisting>
# let abs_diff =
    (fun x -&gt; (fun y -&gt; abs (x - y)));;
val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This rewrite makes it explicit that <literal>abs_diff</literal>
        is actually a function of one argument that returns another
        function of one argument, which itself returns the absolute
        difference between the argument given to the first function and
        the argument given to the second. In other words,
        <literal>abs_diff</literal> is a nested, or
        <emphasis>curried</emphasis> function. (Currying is named after
        Haskell Curry, a famous logician who had a significant impact on
        the design and theory of programming languages.)
      </para>
      <para>
        The key to interpreting the type signature of a curried function
        is the observation that <literal>-&gt;</literal> is
        right-associative. The type signature of
        <literal>abs_diff</literal> can therefore be parenthesized as
        follows to make the currying more obvious without changing the
        meaning of the signature.
      </para>
      <programlisting>
val abs_diff : int -&gt; (int -&gt; int)
</programlisting>
      <para>
        Currying is more than just a theoretical curiosity. Here's an
        example of how you can make use of currying.
      </para>
      <programlisting>
# let dist_from_3 = abs_diff 3;;
val dist_from_3 : int -&gt; int = &lt;fun&gt;
# dist_from_3 8;;
- : int = 5
# dist_from_3 (-1);;
- : int = 4
</programlisting>
      <para>
        The practice of applying some of the arguments of a curried
        function to get a new function is called <emphasis>partial
        application</emphasis>, and it is a convenient way to mint new,
        specialized functions from more general ones.
      </para>
      <para>
        Note that the <literal>fun</literal> keyword supports its own
        syntactic sugar for currying, so we could also have written
        <literal>abs_diff</literal> as follows.
      </para>
      <programlisting>
# let abs_diff = (fun x y -&gt; abs (x - y));;
</programlisting>
      <para>
        You might worry that curried functions are terribly expensive,
        but this is not an issue. In OCaml, there is no penalty for
        calling a curried function with all of its arguments. (Partial
        application, unsurprisingly, does have a small cost.)
      </para>
      <para>
        Currying is the standard way in OCaml of writing a
        multi-argument function, but it's not the only way. It's also
        possible to use the different arms of a tuple as different
        arguments. So, we could write:
      </para>
      <programlisting>
# let abs_diff (x,y) = abs (x - y)
val abs_diff : int * int -&gt; int = &lt;fun&gt;
# abs_diff (3,4);;
- : int = 1
</programlisting>
      <para>
        OCaml handles this calling convention efficiently as well. In
        particular it does not generally have to allocate a tuple just
        for the purpose of sending arguments to a tuple-style function.
      </para>
      <para>
        There are small tradeoffs between these two styles, but most of
        the time, once should stick to currying, since it's the default
        style in the OCaml world.
      </para>
    </sect2>
    <sect2 id="recursive-functions">
      <title>Recursive functions</title>
      <para>
        In order to define a recursive function, you need to mark the
        let binding as recursive with the <literal>rec</literal>
        keyword, as shown in this example:
      </para>
      <programlisting>
# let rec find_first_stutter = function
     | [] | [_] -&gt;
       (* only zero or one elements, so no repeats *)
       None
     | x :: y :: tl -&gt;
       if x = y then Some x else find_first_stutter (y::tl)
val find_first_stutter : 'a list -&gt; 'a option = &lt;fun&gt;
</programlisting>
      <para>
        We can also define multiple mutually recursive values by using
        <literal>let rec</literal> and <literal>and</literal> together,
        as in this (gratuitiously inefficient) example.
      </para>
      <programlisting>
# let rec is_even x =
    x = 0 || is_odd (x - 1)
  and is_odd x =
    is_even (x - 1)
val is_even : int -&gt; bool = &lt;fun&gt;
val is_odd : int -&gt; bool = &lt;fun&gt;
</programlisting>
      <para>
        Note that in the above example, we take advantage of the fact
        that the right hand side of the <literal>||</literal> is only
        evaluated if the left hand side evaluates to false.
      </para>
    </sect2>
    <sect2 id="prefix-and-infix-operators">
      <title>Prefix and Infix operators</title>
      <para>
        So far, we've seen examples of functions used in both prefix and
        infix style:
      </para>
      <programlisting>
# Int.max 3 4;;  (* prefix *)
- : int = 4
# 3 + 4;;        (* infix  *)
- : int = 7
</programlisting>
      <para>
        In OCaml, functions can only be used infix if the name of the
        function is chosen from one of a specialized set of identifiers
        called <emphasis>operators</emphasis>. An operator is any
        identifier that is a sequence of characters from the following
        set
      </para>
      <programlisting>
! $ % &amp; * + - . / : &lt; = &gt; ? @ ^ | ~
</programlisting>
      <para>
        or is one of a handful of pre-determined strings, including
        things like <literal>mod</literal>, the modulus operator, and
        <literal>lsl</literal>, for &quot;logical shift right&quot;,
        which is a bit-shifting operation.
      </para>
      <para>
        We can define (or redefine) the meaning of an operator as
        follows:
      </para>
      <programlisting>
# let (+!) (x1,y1) (x2,y2) = (x1 + x2, y1 + y2)
val ( +! ) : int * int -&gt; int * int -&gt; int *int = &lt;fun&gt;
# (3,2) +! (-2,4);;
- : int * int = (1,6)
</programlisting>
      <para>
        Note that operators can be used in prefix style as well, if they
        are put in parens:
      </para>
      <programlisting>
# (+!) (3,2) (-2,4);;
- : int = (1,6)
</programlisting>
      <para>
        The details of how the operator works are determined by the
        first character of the operator. This table describes how, and
        lists the operators from highest to lowest precedence.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec colwidth="26*" align="left" />
          <colspec colwidth="59*" align="left" />
          <thead>
            <row>
              <entry>
                First character
              </entry>
              <entry>
                Usage
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <literal>!</literal> <literal>?</literal>
                <literal>~</literal>
              </entry>
              <entry>
                Prefix and unary
              </entry>
            </row>
            <row>
              <entry>
                <literal>**</literal>
              </entry>
              <entry>
                Infix, right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>+</literal> <literal>-</literal>
              </entry>
              <entry>
                Infix, left associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>@</literal> <literal>^</literal>
              </entry>
              <entry>
                Infix, right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>=</literal> <literal>&lt;</literal>
                <literal>&gt;</literal> <literal>|</literal>
                <literal>&amp;</literal> <literal>$</literal>
              </entry>
              <entry>
                Infix, left associative
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>
    <sect2 id="declaring-functions-with-function">
      <title>Declaring functions with
      <literal>function</literal></title>
      <para>
        Another way to define a function is using the
        <literal>function</literal> keyword. Instead of having syntactic
        support for declaring curried functions,
        <literal>function</literal> has built-in pattern matching.
        Here's an example:
      </para>
      <programlisting>
# let some_or_zero = function
     | Some x -&gt; x
     | None -&gt; 0
  ;;
val some_or_zero : int option -&gt; int = &lt;fun&gt;
# List.map ~f:some_or_zero [Some 3; None; Some 4];;
- : int list = [3; 0; 4]
</programlisting>
      <para>
        We can also combine the different styles of function declaration
        together, as in the following example where we declare a two
        argument function with a pattern-match on the second argument.
      </para>
      <programlisting>
# let some_or_default default = function
     | Some x -&gt; x
     | None -&gt; default
  ;;
# List.map ~f:(some_or_default 100) [Some 3; None; Some 4];;
- : int Core.Std.List.t = [3; 100; 4]
</programlisting>
    </sect2>
    <sect2 id="labeled-arguments">
      <title>Labeled Arguments</title>
      <para>
        Up until now, the different arguments to a function have been
        specified positionally, <emphasis>i.e.</emphasis>, by the order
        in which the arguments are passed to the function. OCaml also
        supports labeled arguments, which let you identify a function
        argument by name. Functions with labeled arguments can be
        declared by putting a tilde in front of the variable name in the
        definition of the function:
      </para>
      <programlisting>
# let f ~foo:a ~bar:b = a + b
val f : foo:int -&gt; bar:int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        And the function can be called using the same convention:
      </para>
      <programlisting>
# f ~foo:3 ~bar:10;;
- : int = 13
</programlisting>
      <para>
        In addition, OCaml supports <emphasis>label punning</emphasis>,
        meaning that you get to drop the text after the
        <literal>:</literal> if the name of the label and the name of
        the variable being used are the same. Label punning works in
        both function declaration and function invocation, as shown in
        these examples:
      </para>
      <programlisting>
# let f ~foo ~bar = foo + bar
val f : foo:int -&gt; bar:int -&gt; int = &lt;fun&gt;
# let foo = 3;;
# let bar = 4;;
# f ~foo ~bar;;
- : int = 7
</programlisting>
      <para>
        Labeled arguments are useful in a few different cases:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            When defining a function with lots of arguments. When you
            have enough arguments, names are easier to remember than
            positions.
          </para>
        </listitem>
        <listitem>
          <para>
            For functions that have multiple arguments that might get
            confused with each other, particularly if they're of the
            same type. For example, consider this signature for a
            function for extracting a substring of another string.
          </para>
          <programlisting language="ocaml">
val substring: string -&gt; int -&gt; int -&gt; string
</programlisting>
          <para>
            where the two ints are the starting position and length of
            the substring to extract. Labeled arguments can make this
            signature clearer:
          </para>
          <programlisting language="ocaml">
val substring: string -&gt; pos:int -&gt; len:int -&gt; string
</programlisting>
          <para>
            This improves the readability of both the signature and of
            client code that makes use of <literal>substring</literal>,
            and makes it harder to accidentally swap the position and
            the length.
          </para>
        </listitem>
        <listitem>
          <para>
            Labeled arguments give you a way to assign a clear name and
            meaning to an argument whose type is otherwise less than
            informative. For example, consider a function for creating a
            hashtable where the first argument is the initial size of
            the table, and the second argument is a flag which, when
            true, indicates that the hashtable will adjust its size down
            when its size is small. The following signature is less than
            informative.
          </para>
          <programlisting language="ocaml">
val create_hashtable : int -&gt; bool -&gt; ('a,'b) Hashtable.t
</programlisting>
          <para>
            but with labeled arguments, we can make the intent much
            clearer:
          </para>
          <programlisting language="ocaml">
val create_hashtable : init_size:int -&gt; allow_shrinking:bool -&gt; ('a,'b) Hashtable.t
</programlisting>
        </listitem>
        <listitem>
          <para>
            Labeled arguments can be used to make a function signature
            more flexible. For example, labeled arguments make it
            possible for the caller to decide which argument of a
            function to partially apply, whereas in ordinary curried
            functions, you can only partially apply the arguments in
            order from first to last. Labeled arguments also make it
            possible to place the arguments to a function in different
            orders, which is useful for functions like
            <literal>List.map</literal> where you often want to
            partially apply <literal>List.map</literal> with just the
            function, and at the same time mapping over a large function
            is easier to read if the function is the last argument.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        One surprising gotcha about labeled arguments is that while
        order doesn't matter when calling a function with labeled
        arguments, it does matter in a higher-order context,
        <emphasis>i.e.</emphasis>, when passing a labeled argument to
        another function. This is shown by the following example.
      </para>
      <programlisting>
# let apply_to_tuple f (first,second) = f ~first ~second;;
val apply_to_tuple : (first:'a -&gt; second:'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c = &lt;fun&gt;
# let divide ~second ~first = first / second;;
val divide : second:int -&gt; first:int -&gt; int = &lt;fun&gt;
# apply_to_tuple divide 3 4;;
Characters 15-21:
  apply_to_tuple divide 3 4;;
                 ^^^^^^
Error: This expression has type second:int -&gt; first:int -&gt; int
       but an expression was expected of type
         first:'a -&gt; second:'b -&gt; 'c -&gt; 'd
</programlisting>
    </sect2>
    <sect2 id="optional-arguments">
      <title>Optional arguments</title>
      <para>
        An optional argument is like a labeled argument that the caller
        can choose whether or not to provide. A function with an
        optional argument must define a default for when the argument is
        absent. Consider the following example of a string concatenation
        function with an optionally specified separator. Note that the
        <literal>?</literal> in front of an argument is used to make the
        separator optional.
      </para>
      <programlisting>
# let concat ?sep x y =
     let sep = match sep with None -&gt; &quot;&quot; | Some x -&gt; x in
     x ^ sep ^ y
  ;;
val concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
# concat &quot;foo&quot; &quot;bar&quot;;; (* without the optional argument *)
- : string = &quot;foobar&quot;
# concat ~sep:&quot;:&quot; &quot;foo&quot; &quot;bar&quot;;; (* with the optional argument *)
- : string = &quot;foo:bar&quot;
</programlisting>
      <para>
        Optional arguments can be passed in using the same syntax as
        labeled arguments. Also, similarly to labeled arguments,
        optional arguments can be passed in in any order.
      </para>
      <sidebar>
      <title>
      How are optional arguments inferred?
      </title>
      <para>
        One tricky aspect of labeled and optional arguments is the way
        in which those arguments are inferred. Consider the following
        example:
      </para>
      <programlisting language="ocaml">
# let foo g x y = g ~x ~y ;;
val foo : (x:'a -&gt; y:'b -&gt; 'c) -&gt; 'a -&gt; 'b -&gt; 'c = &lt;fun&gt;
</programlisting>
      <para>
        In principle, it seems like the type first argument of
        <literal>foo</literal> could have had a different order for the
        arguments (<emphasis>e.g.</emphasis>
        <literal>y:'b -&gt; x:'a -&gt; 'c</literal>) or could have
        optional instead of labeled arguments
        (<emphasis>e.g.</emphasis>,
        <literal>?y:'a -&gt; x:'b -&gt; 'c</literal>). OCaml
        disambiguates between these cases by picking labeled arguments
        when it can, and by choosing the order based on the order that
        is actually used. If you try to use two different orders in the
        same context, you'll get a compilation errro:
      </para>
      <programlisting language="ocaml">
# let foo g x y = g ~x ~y + g ~y ~x ;;
Characters 26-27:
  let foo g x y = g ~x ~y + g ~y ~x ;;
                            ^
Error: This function is applied to arguments
in an order different from other calls.
This is only allowed when the real type is known.
</programlisting>
      <para>
        If, however, we put in an explicit type constraint, then we can
        specify any compatible type.
      </para>
      <programlisting language="ocaml">
# let foo g x y = (g : ?y:'a -&gt; x:'b -&gt; int) ~x ~y + g ~y ~x;;
val foo : (?y:'a -&gt; x:'b -&gt; int) -&gt; 'b -&gt; 'a -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        Type constraints are discussed in more detail in chapter
        {{???}}.
      </para>
      </sidebar>
      <para>
        The behavior of substituting in a default value is so common
        that it has its own syntax. Thus, we could rewrite the
        <literal>concat</literal> function as follows:
      </para>
      <programlisting>
# let concat ?(sep=&quot;&quot;) x y = x ^ sep ^ y ;;
</programlisting>
      <sect3 id="explicit-passing-of-an-optional-argument">
        <title>Explicit passing of an optional argument</title>
        <para>
          Sometimes you want to explicitly invoke an optional argument
          with a concrete option, where <literal>None</literal>
          indicates that the argument won't be passed in, and
          <literal>Some</literal> indicates it will. You can do that as
          follows:
        </para>
        <programlisting>
# concat ?sep:None &quot;foo&quot; &quot;bar&quot;;;
- : string = &quot;foobar&quot;
</programlisting>
        <para>
          This is particularly useful when you want to pass through an
          optional argument from one function to another, leaving the
          choice of default to the second function. For example:
        </para>
        <programlisting>
# let uppercase_concat ?sep a b = concat ?sep (String.uppercase a) b ;;
val uppercase_concat : ?sep:string -&gt; string -&gt; string -&gt; string =
  &lt;fun&gt;
# uppercase_concat &quot;foo&quot; &quot;bar&quot;;;
- : string = &quot;FOObar&quot;
</programlisting>
      </sect3>
      <sect3 id="erasure-of-optional-arguments">
        <title>Erasure of optional arguments</title>
        <para>
          One subtle aspect of optional arguments is the question of
          OCaml decides to <emphasis>erase</emphasis> an optional
          argument, <emphasis>i.e.</emphasis>, to give up waiting for an
          optional argument, and substitute in the default value? Note
          that, for ordinary labeled arguments, if you pass in all of
          the non-labeled arguments, you're left with a partially
          applied function that is still waiting for its labeled
          arguments. <emphasis>e.g.</emphasis>,
        </para>
        <programlisting>
# let concat ~sep x y = x ^ sep ^ y ;;
val concat : sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
# concat &quot;a&quot; &quot;b&quot;;;
- : sep:string -&gt; string = &lt;fun&gt;
</programlisting>
        <para>
          So when should an optional argument be erased?
        </para>
        <para>
          OCaml's rule is: an optional argument is erased as soon as the
          first positional argument defined <emphasis>after</emphasis>
          the optional argument is passed in. Thus, the following
          partial application of concat causes the optional argument to
          disappear:
        </para>
        <programlisting>
# let prepend_foo = concat &quot;foo&quot;;;
val prepend_foo : string -&gt; string = &lt;fun&gt;
# prepend_foo &quot;bar&quot;;;
- : string = &quot;foobar&quot;
# prepend_foo &quot;bar&quot; ~sep:&quot;:&quot;;;
Characters 0-11:
  prepend_foo &quot;bar&quot; ~sep:&quot;:&quot;;;
  ^^^^^^^^^^^
Error: This function is applied to too many arguments;
maybe you forgot a `;'
</programlisting>
        <para>
          But if we had instead defined <literal>concat</literal> with
          the optional argument in the second position:
        </para>
        <programlisting>
# let concat x ?(sep=&quot;&quot;) y = x ^ sep ^ y ;;
val concat : string -&gt; ?sep:string -&gt; string -&gt; string = &lt;fun&gt;
</programlisting>
        <para>
          then application of the first argument would not cause the
          optional argument to be erased.
        </para>
        <programlisting>
# let prepend_foo = concat &quot;foo&quot;;;
val prepend_foo : ?sep:string -&gt; string -&gt; string = &lt;fun&gt;
# prepend_foo &quot;bar&quot;;;;
- : string = &quot;foobar&quot;
# prepend_foo ~sep:&quot;=&quot; &quot;bar&quot;;;;
- : string = &quot;foo=bar&quot;
</programlisting>
        <para>
          One oddity is that, if all arguments to a function are
          presented at once, then erasure of optional arguments isn't
          applied until all of the arguments are passed in. Thus, this
          works:
        </para>
        <programlisting>
# concat &quot;a&quot; &quot;b&quot; ~sep:&quot;=&quot;;;
- : string = &quot;a=b&quot;
</programlisting>
        <para>
          but a well-placed pair of parenthesis fails.
        </para>
        <programlisting>
# (concat &quot;a&quot; &quot;b&quot;) ~sep:&quot;=&quot;;;
Characters 0-16:
  (concat &quot;a&quot; &quot;b&quot;) ~sep:&quot;=&quot;;;
  ^^^^^^^^^^^^^^^^
Error: This expression is not a function; it cannot be applied
</programlisting>
        <para>
          The failure is a result of the fact that the expression
          <literal>(concat &quot;a&quot; &quot;b&quot;)</literal> has
          erased <literal>concat</literal>'s optional argument.
        </para>
        <para>
          It's possible to define a function in such a way that the
          optional argument can never be erased, by having no positional
          arguments defined after the optional one. This leads to a
          compiler warning:
        </para>
        <programlisting>
# let concat x y ?(sep=&quot;&quot;) = x ^ sep ^ y ;;
Characters 15-38:
  let concat x y ?(sep=&quot;&quot;) = x ^ sep ^ y ;;
                 ^^^^^^^^^^^^^^^^^^^^^^^
Warning 16: this optional argument cannot be erased.
val concat : string -&gt; string -&gt; ?sep:string -&gt; string = &lt;fun&gt;
</programlisting>
      </sect3>
      <sect3 id="when-to-use-optional-arguments">
        <title>When to use optional arguments</title>
        <para>
          Optional arguments are very useful, but they're also easy to
          abuse. The key advantage of optional arguments is that they
          let you write functions with complex options that users can
          ignore most of the time, only needing to think about them when
          they specifically want to invoke those options.
        </para>
        <para>
          The downside is that it's easy for the caller of a function to
          not be aware that there is a choice to be made, and as a
          result end up making the wrong choice by not doing anything.
          Optional arguments really only make sense when the extra
          concision of omitting the argument overwhelms the
          corresponding loss of explicitness.
        </para>
        <para>
          This means that rarely used functions should not have optional
          arguments. A good rule of thumb for optional arguments is that
          you should never use an optional argument for internal
          functions of a module, only for functions that are exposed to
          users of a module.
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="example-pretty-printing-a-table">
    <title>Example: pretty-printing a table</title>
    <para>
      One common programming task is displaying tabular data. In this
      example, will go over the design of a simple library to do just
      that.
    </para>
    <para>
      We'll start with the interface. The code will go in a new module
      called <literal>Text_table</literal> whose <literal>.mli</literal>
      contains just the following function:
    </para>
    <programlisting language="ocaml">
(* [render headers rows] returns a string containing a formatted
   text table, using unix-style newlines as separators *)
val render
   :  string list         (* header *)
   -&gt; string list list    (* data *)
   -&gt; string
</programlisting>
    <para>
      If you invoke <literal>render</literal> as follows:
    </para>
    <programlisting language="ocaml">
let () =
  print_string (Text_table.render
     [&quot;language&quot;;&quot;architect&quot;;&quot;first release&quot;]
     [ [&quot;Lisp&quot; ;&quot;John McCarthy&quot; ;&quot;1958&quot;] ;
       [&quot;C&quot;    ;&quot;Dennis Ritchie&quot;;&quot;1969&quot;] ;
       [&quot;ML&quot;   ;&quot;Robin Milner&quot;  ;&quot;1973&quot;] ;
       [&quot;OCaml&quot;;&quot;Xavier Leroy&quot;  ;&quot;1996&quot;] ;
     ])
</programlisting>
    <para>
      you'll get the following output:
    </para>
    <programlisting>
| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |
</programlisting>
    <para>
      Now that we know what <literal>render</literal> is supposed to do,
      let's dive into the implementation.
    </para>
    <sect2 id="computing-the-widths">
      <title>Computing the widths</title>
      <para>
        To render the rows of the table, we'll first need the width of
        the widest entry in each column. The following function does
        just that.
      </para>
      <programlisting language="ocaml">
let max_widths header rows =
  let to_lengths l = List.map ~f:String.length l in
  List.fold rows
    ~init:(to_lengths header)
    ~f:(fun acc row -&gt;
      List.map2_exn ~f:Int.max acc (to_lengths row))
</programlisting>
      <para>
        In the above we define a helper function,
        <literal>to_lengths</literal> which uses
        <literal>List.map</literal> and <literal>String.length</literal>
        to convert a list of strings to a list of string lengths. Then,
        starting with the lengths of the headers, we use
        <literal>List.fold</literal> to join in the lengths of the
        elements of each row by <literal>max</literal>'ing them together
        elementwise.
      </para>
      <para>
        Note that this code will throw an exception if any of the rows
        has a different number of entries than the header. In
        particular, <literal>List.map2_exn</literal> throws an exception
        when its arguments have mismatched lengths.
      </para>
    </sect2>
    <sect2 id="rendering-the-rows">
      <title>Rendering the rows</title>
      <para>
        Now we need to write the code to render a single row. There are
        really two different kinds of rows that need to be rendered; an
        ordinary row:
      </para>
      <programlisting>
| Lisp     | John McCarthy  | 1962          |
</programlisting>
      <para>
        and a separator row:
      </para>
      <programlisting>
|----------+----------------+---------------|
</programlisting>
      <para>
        Let's start with the separator row, which we can generate as
        follows:
      </para>
      <programlisting language="ocaml">
let render_separator widths =
  let pieces = List.map widths
    ~f:(fun w -&gt; String.make (w + 2) '-')
  in
  &quot;|&quot; ^ String.concat ~sep:&quot;+&quot; pieces ^ &quot;|&quot;
</programlisting>
      <para>
        We need the extra two-characters for each entry to account for
        the one character of padding on each side of a string in the
        table.
      </para>
      <sidebar>
      <title>
      Performance of <literal>String.concat</literal> and
      <literal>^</literal>
      </title>
      <para>
        In the above, we're using two different ways of concatenating
        strings, <literal>String.concat</literal>, which operates on
        lists of strings, and <literal>^</literal>, which is a pairwise
        operator. You should avoid <literal>^</literal> for joining long
        numbers of strings, since, it allocates a new string every time
        it runs. Thus, the following code:
      </para>
      <programlisting language="ocaml">
let s = &quot;.&quot; ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;
</programlisting>
      <para>
        will allocate a string of length 2, 3, 4, 5, 6 and 7, whereas
        this code:
      </para>
      <programlisting language="ocaml">
let s = String.concat [&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;]
</programlisting>
      <para>
        allocates one string of size 7, as well as a list of length 7.
        At these small sizes, the differences don't amount to much, but
        for assembling of large strings, it can be a serious performance
        issue.
      </para>
      </sidebar>
      <para>
        We can write a very similar piece of code for rendering the data
        in an ordinary row.
      </para>
      <programlisting language="ocaml">
let pad s length =
  if String.length s &gt;= length then s
  else s ^ String.make (length - String.length s) ' '

let render_row row widths =
  let pieces = List.map2 row widths
    ~f:(fun s width -&gt; &quot; &quot; ^ pad s width ^ &quot; &quot;)
  in
  &quot;|&quot; ^ String.concat ~sep:&quot;|&quot; pieces ^ &quot;|&quot;
</programlisting>
      <para>
        You might note that <literal>render_row</literal> and
        <literal>render_separator</literal> share a bit of structure. We
        can improve the code a bit by factoring that repeated structure
        out:
      </para>
      <programlisting language="ocaml">
let decorate_row ~sep row = &quot;|&quot; ^ String.concat ~sep row ^ &quot;|&quot;

let render_row widths row =
  decorate_row ~sep:&quot;|&quot;
    (List.map2_exn row widths ~f:(fun s w -&gt; &quot; &quot; ^ pad s w ^ &quot; &quot;))

let render_separator widths =
  decorate_row ~sep:&quot;+&quot;
    (List.map widths ~f:(fun width -&gt; String.make (width + 2) '-'))
</programlisting>
    </sect2>
    <sect2 id="bringing-it-all-together">
      <title>Bringing it all together</title>
      <para>
        And now we can write the function for rendering a full table.
      </para>
      <programlisting language="ocaml">
let render header rows =
  let widths = max_widths header rows in
  String.concat ~sep:&quot;\n&quot;
    (render_row widths header
     :: render_separator widths
     :: List.map rows ~f:(fun row -&gt; render_row widths row)
    )
</programlisting>
      <para>
        Now, let's think about how you might actually use this interface
        in practice. Usually, when you have data to render in a table,
        that data comes in the form of a list of objects of some sort,
        where you need to extract data from each record for each of the
        columns. So, imagine that you start off with a record type for
        representing information about a given programming language:
      </para>
      <programlisting language="ocaml">
type style =
    Object_oriented | Functional | Imperative | Logic

type prog_lang = { name: string;
                   architect: string;
                   year_released: int;
                   style: style list;
                 }
</programlisting>
      <para>
        If we then wanted to render a table from a list of languages, we
        might write something like this:
      </para>
      <programlisting language="ocaml">
let print_langs langs =
   let headers = [&quot;name&quot;;&quot;architect&quot;;&quot;year released&quot;] in
   let to_row lang =
     [lang.name; lang.architect; Int.to_string lang.year_released ]
   in
   print_string (Text_table.render headers (List.map ~f:to_row langs))
</programlisting>
      <para>
        This is OK, but as you consider more complicated tables with
        more columns, it becomes easier to make the mistake of having a
        mismatch in between <literal>headers</literal> and
        <literal>to_row</literal>. Also, adding, removing and reordering
        columns becomes awkward, because changes need to be made in two
        places.
      </para>
      <para>
        We can improve the table API by adding a type which is a
        first-class representative for a column. We'd add the following
        to the interface of <literal>Text_table</literal>:
      </para>
      <programlisting language="ocaml">
(** An ['a column] is a specification of a column for rending a table
    of values of type ['a] *)
type 'a column

(** [column header to_entry] returns a new column given a header and a
    function for extracting the text entry from the data associated
    with a row *)
val column : string -&gt; ('a -&gt; string) -&gt; 'a column

(** [column_render columns rows] Renders a table with the specified
    columns and rows *)
val column_render :
  'a column list -&gt; 'a list -&gt; string
</programlisting>
      <para>
        Thus, the <literal>column</literal> functions creates a
        <literal>column</literal> from a header string and a function
        for extracting the text for that column associated with a given
        row. Implementing this interface is quite simple:
      </para>
      <programlisting language="ocaml">
type 'a column = string * ('a -&gt; string)
let column header to_string = (header,to_string)

let column_render columns rows =
  let header = List.map columns ~f:fst in
  let rows = List.map rows ~f:(fun row -&gt;
    List.map columns ~f:(fun (_,to_string) -&gt; to_string row))
  in
  render header rows
</programlisting>
      <para>
        And we can rewrite <literal>print_langs</literal> to use this
        new interface as follows.
      </para>
      <programlisting language="ocaml">
let columns =
  [ Text_table.column &quot;Name&quot;      (fun x -&gt; x.name);
    Text_table.column &quot;Architect&quot; (fun x -&gt; x.architect);
    Text_table.column &quot;Year Released&quot;
       (fun x -&gt; Int.to_string x.year_released);
  ]

let print_langs langs =
  print_string (Text_table.column_render columns langs)
</programlisting>
      <para>
        The code is a bit longer, but it's also less error prone. In
        particular, several errors that might be made by the user are
        now ruled out by the type system. For example, it's no longer
        possible for the length of the header and the lengths of the
        rows to be mismatched.
      </para>
      <para>
        The simple column-based interface described here is also a good
        starting for building a richer API. You could for example build
        specialized colums with different formatting and alignment
        rules, which is easier to do with this interface than with the
        original one based on passing in lists-of-lists.
      </para>
    </sect2>
  </sect1>
</chapter>
<chapter id="lists-options-and-pattern-matching">
  <title>Lists, Options and Pattern Matching</title>
  <para>
  </para>
</chapter>
<chapter id="error-handling">
  <title>Error Handling</title>
  <para>
    Nobody likes dealing with errors. It's tedious, it's easy to get
    wrong, and it's usually just not as fun as planning out how your
    program is going to succeed. But error handling is important, and
    however much you don't like thinking about it, having your software
    fail due to poor error handling code is worse.
  </para>
  <para>
    Thankfully, OCaml has powerful tools for handling errors reliably
    and with a minimum of pain. In this chapter we'll discuss some of
    the different approaches in OCaml to handling errors, and give some
    advice on how to design interfaces that help rather than hinder
    error handling.
  </para>
  <para>
    We'll start by describing the two basic approaches for reporting
    errors in OCaml: error-aware return types and exceptions.
  </para>
  <sect1 id="error-aware-return-types">
    <title>Error-aware return types</title>
    <para>
      The best way in OCaml to signal an error is to include that error
      in your return value. Consider the type of the
      <literal>find</literal> function in the list module.
    </para>
    <programlisting>
# List.find;;
- : 'a list -&gt; f:('a -&gt; bool) -&gt; 'a option
</programlisting>
    <para>
      The option in the return type indicates that the function may not
      succeed in finding a suitable element, as you can see below.
    </para>
    <programlisting>
# List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 2) ;;
- : int option = Some 2
# List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 10) ;;
- : int option = None
</programlisting>
    <para>
      Having errors be explicit in the return values of your functions
      tells the caller that there is an error that needs to be handled.
      The caller can then handle the error explicitly, either recovering
      from the error or propagating it onward.
    </para>
    <para>
      The function <literal>compute_bounds</literal> below is an example
      of how you can handle errors in this style. The function takes a
      list and a comparison function, and returns upper and lower bounds
      for the list by finding the smallest and largest element on the
      list. <literal>List.hd</literal> and <literal>List.last</literal>,
      which return <literal>None</literal> when they encounter an empty
      list, are used to extract the largest and smallest element of the
      list.
    </para>
    <programlisting language="ocaml">
# let compute_bounds ~cmp list =
    let sorted = List.sort ~cmp list in
    let smallest = List.hd sorted in
    let largest = List.last sorted in
    match smallest, largest with
    | None,_ | _, None -&gt; None
    | Some x, Some y -&gt; Some (x,y)
  ;;
val compute_bounds :
  cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option = &lt;fun&gt;
</programlisting>
    <para>
      The match statement is used to handle the error cases, propagating
      an error in <literal>hd</literal> or <literal>last</literal> into
      the return value of <literal>compute_bounds</literal>. On the
      other hand, in <literal>find_mismatches</literal> below, errors
      encountered during the computation do not propagate to the return
      value of the function. <literal>find_mismatches</literal> takes
      two hashtables as its arugments and tries to find keys that are
      stored in both. As such, a failure to find a key in one of the
      tables isn't really an error.
    </para>
    <programlisting language="ocaml">
# let find_mismatches table1 table2 =
     Hashtbl.fold table1 ~init:[] ~f:(fun ~key ~data errors -&gt;
        match Hashtbl.find table2 key with
        | Some data' when data' &lt;&gt; data -&gt; key :: errors
        | _ -&gt; errors
     )
 ;;
val find_mismatches :
  ('a, 'b) Hashtbl.t -&gt; ('a, 'b) Hashtbl.t -&gt; 'a list = &lt;fun&gt;
</programlisting>
    <para>
      The use of options to encode errors underlines the fact that it's
      not clear whether a particular outcome, like not finding something
      on a list, is really an error, or just another valid outcome of
      your function. This turns out to be very context-dependent, and
      error-aware return types give you a uniform way of handling the
      result that works well for both situations.
    </para>
    <sect2 id="encoding-errors-with-result">
      <title>Encoding errors with <literal>Result</literal></title>
      <para>
        Options aren't always a sufficiently expressive way to report
        errors. Specifically, when you encode an error as
        <literal>None</literal>, there's nowhere to say anything about
        the nature of the error.
      </para>
      <para>
        <literal>Result.t</literal> is meant to address this deficiency.
        Here's the definition:
      </para>
      <programlisting language="ocaml">
module Result : sig
   type ('a,'b) t = | Ok of 'a
                    | Error of 'b
end
</programlisting>
      <para>
        A <literal>Result.t</literal> is essentially an option augmented
        with the ability to store other information in the error case.
        Like <literal>Some</literal> and <literal>None</literal> for
        options, the constructors <literal>Ok</literal> and
        <literal>Error</literal> are promoted to the top-level by
        <literal>Core.Std</literal>. As such, we can write:
      </para>
      <programlisting>
# [ Ok 3; Error &quot;abject failure&quot;; Ok 4 ];;
[Ok 3; Error &quot;abject failure&quot;; Ok 4]
- : (int, string) Result.t list =
[Ok 3; Error &quot;abject failure&quot;; Ok 4]
</programlisting>
      <para>
        without first opening the <literal>Result</literal> module.
      </para>
    </sect2>
    <sect2 id="error-and-or_error">
      <title><literal>Error</literal> and
      <literal>Or_error</literal></title>
      <para>
        <literal>Result.t</literal> gives you complete freedom to choose
        the type of value you use to represent errors, but it's often
        useful to standardize on an error type. Among other things, this
        makes it easier to write utility functions to automate common
        error handling patterns.
      </para>
      <para>
        But which type to choose? Is it better to represent errors as
        strings? Or S-expressions? Or something else entirely?
      </para>
      <para>
        Core's answer to this question is the <literal>Error.t</literal>
        type, which tries to forge a good compromise between efficiency,
        convenience and control over the presentation of errors.
      </para>
      <para>
        It might not be obvious at first why efficiency is an issue at
        all. But generating error messages is an expensive business. An
        ASCII representation of a type can be quite time-consuming to
        construct, particularly if it includes expensive-to-convert
        numerical datatypes.
      </para>
      <para>
        <literal>Error</literal> gets around this issue through
        laziness. In particular, an <literal>Error.t</literal> allows
        you to put off generation of the actual error string until you
        actually need, which means a lot of the time you never have to
        construct it at all. You can of course construct an error
        directly from a string:
      </para>
      <programlisting>
# Error.of_string &quot;something went wrong&quot;;;
- : Core.Std.Error.t = &quot;something went wrong&quot;
</programlisting>
      <para>
        A more interesting construction message from a performance point
        of view is to construct an <literal>Error.t</literal> from a
        thunk:
      </para>
      <programlisting>
# Error.of_thunk (fun () -&gt;
    sprintf &quot;something went wrong: %f&quot; 32.3343);;
  - : Core.Std.Error.t = &quot;something went wrong: 32.334300&quot;
</programlisting>
      <para>
        In this case, we can benefit from the laziness of
        <literal>Error</literal>, since the thunk won't be called until
        the <literal>Error.t</literal> is converted to a string.
      </para>
      <para>
        We can also create an <literal>Error.t</literal> based on an
        s-expression converter. This is probably the most common idiom
        in Core.
      </para>
      <programlisting>
# Error.create &quot;Something failed a long time ago&quot; Time.epoch Time.sexp_of_t;;
- : Core.Std.Error.t =
&quot;Something failed a long time ago: (1969-12-31 19:00:00.000000)&quot;
</programlisting>
      <para>
        Here, the value <literal>Time.epoch</literal> is included in the
        error, but <literal>Time.sexp_of_t</literal>, which is used for
        converting the time to an s-expression, isn't run until the
        error is converted to a string. Using the Sexplib
        syntax-extension, which is discussed in more detail in chapter
        {{SYNTAX}}, we can inline create an s-expression converter for a
        collection of types, thus allowing us to register multiple
        pieces of data in an <literal>Error.t</literal>.
      </para>
      <programlisting>
# Error.create &quot;Something went terribly wrong&quot;
    (3.5, [&quot;a&quot;;&quot;b&quot;;&quot;c&quot;],6034)
    &lt;:sexp_of&lt;float * string list * int&gt;&gt; ;;
- : Core.Std.Error.t = &quot;Something went terribly wrong: (3.5(a b c)6034)&quot;
</programlisting>
      <para>
        Here, the declaration
        <literal>&lt;:sexp_of&lt;float * string list * int&gt;&gt;</literal>
        asks Sexplib to generate the sexp-converter for the tuple.
      </para>
      <para>
        Error also has operations for transforming errors. For example,
        it's often useful to augment an error with some extra
        information about the context of the error, or to combine
        multipler errors together. <literal>Error.of_list</literal> and
        <literal>Error.tag</literal> fill these roles.
      </para>
      <para>
        The type <literal>'a Or_error.t</literal> is just a shorthand
        for <literal>('a,Error.t) Result.t</literal>, and it is, after
        <literal>option</literal>, the most common way of returning
        errors in Core.
      </para>
    </sect2>
    <sect2 id="bind-and-other-error-handling-idioms">
      <title><literal>bind</literal> and other error-handling
      idioms</title>
      <para>
        As you write more error handling code, you'll discover that
        certain patterns start to emerge. A number of these common
        patterns been codified in the interfaces of modules like
        <literal>Option</literal> and <literal>Result</literal>. One
        particularly useful one is built around the function
        <literal>bind</literal>, which is both an ordinary function and
        an infix operator <literal>&gt;&gt;=</literal>, both with the
        same type signature:
      </para>
      <programlisting language="ocaml">
val (&gt;&gt;=) : 'a option -&gt; ('a -&gt; 'b option) -&gt; 'b option
</programlisting>
      <para>
        <literal>bind</literal> is a way of sequencing together
        error-producing functions so that that the first one to produce
        an error terminates the computation. In particular,
        <literal>None &gt;&gt;= f</literal> returns
        <literal>None</literal> without calling <literal>f</literal>,
        and <literal>Some x &gt;&gt;= f</literal> returns
        <literal>f x</literal>. We can use a nested sequence of these
        binds to express a multi-stage computation that can fail at any
        stage. Here's a rewrite <literal>compute_bounds</literal> in
        this style.
      </para>
      <programlisting>
# let compute_bounds ~cmp list =
    let open Option.Monad_infix in
    let sorted = List.sort ~cmp list in
    List.hd sorted &gt;&gt;= (fun first -&gt;
      List.last sorted &gt;&gt;= (fun last -&gt;
        Some (first,last)))
</programlisting>
      <para>
        Note that we locally open the
        <literal>Option.Monad_infix</literal> module to get access to
        the infix operator <literal>&gt;&gt;=</literal>. The module is
        called <literal>Monad_infix</literal> because the bind operator
        is part of a sub-interface called <literal>Monad</literal>,
        which we'll talk about more in chapter {{{ASYNC}}}.
      </para>
      <para>
        This is a bit easier to read if we write it with fewer parens
        and less indentation, as follows.
      </para>
      <programlisting>
# let compute_bounds ~cmp list =
    let open Option.Monad_infix in
    let sorted = List.sort ~cmp list in
    List.hd sorted   &gt;&gt;= fun first -&gt;
    List.last sorted &gt;&gt;= fun last  -&gt;
    Some (first,last)
</programlisting>
      <para>
        There are other usuful idioms encoded in the functions in
        <literal>Option</literal>. Another example is
        <literal>Option.both</literal>, which takes two optional values
        and produces a new optional pair that is <literal>None</literal>
        if either of its arguments are <literal>None</literal>. Using
        <literal>Option.both</literal>, we can make
        <literal>compute_bounds</literal> even shorter.
      </para>
      <programlisting>
# let compute_bounds ~cmp list =
    let sorted = List.sort ~cmp list in
    Option.both (List.hd sorted) (List.last sorted)
</programlisting>
      <para>
        These error-handling functions are valuable because they let you
        express your error handling both explicitly and concisely. We've
        only discussed these functions in the context of the
        <literal>Option</literal> module, but similar functionality is
        available in both <literal>Result</literal> and
        <literal>Or_error</literal>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="exceptions">
    <title>Exceptions</title>
    <para>
      Exceptions in OCaml are not that different from exceptions in many
      other languages, like Java, C# and Python. In all these cases,
      exceptions are a way to terminate a computation and report an
      error, while providing a mechanism to catch and handle (and
      possibly recover from) exceptions that are triggered by
      sub-computations.
    </para>
    <para>
      We'll see an exception triggered in OCaml if, for example, we try
      to divide an integer by zero:
    </para>
    <programlisting>
# 3 / 0;;
Exception: Division_by_zero.
</programlisting>
    <para>
      And an exception can terminate a computation even if it happens
      nested a few levels deep in a computation.
    </para>
    <programlisting>
# List.map ~f:(fun x -&gt; 100 / x) [1;3;0;4];;
Exception: Division_by_zero.
</programlisting>
    <para>
      In addition to built-in exceptions like
      <literal>Divide_by_zero</literal>, OCaml lets you define your own.
    </para>
    <programlisting>
# exception Key_not_found of string;;
exception Key_not_found of string
# Key_not_found &quot;a&quot;;;
- : exn = Key_not_found(&quot;a&quot;)
</programlisting>
    <para>
      Here's an example of a function for looking up a key in an
      <emphasis>association list</emphasis>, <emphasis>i.e.</emphasis> a
      list of key/value pairs which uses this newly-defined exception:
    </para>
    <programlisting>
# let rec find_exn alist key = match alist with
    | [] -&gt; raise (Key_not_found key)
    | (key',data) :: tl -&gt; if key = key' then data else find_exn tl key
  ;;
val find_exn : (string * 'a) list -&gt; string -&gt; 'a = &lt;fun&gt;
# let alist = [(&quot;a&quot;,1); (&quot;b&quot;,2)];;
val alist : (string * int) list = [(&quot;a&quot;, 1); (&quot;b&quot;, 2)]
# find_exn alist &quot;a&quot;;;
- : int = 1
# find_exn alist &quot;c&quot;;;
Exception: Key_not_found(&quot;c&quot;).
</programlisting>
    <para>
      Note that we named the function <literal>find_exn</literal> to
      warn the user that the function routinely throws exceptions, a
      convention that is used heavily in Core.
    </para>
    <para>
      In the above example, <literal>raise</literal> throws the
      exception, thus terminating the computation. The type of raise is
      a bit surprising when you first see it:
    </para>
    <programlisting>
# raise;;
- : exn -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      Having the return type be an otherwise unused type variable
      <literal>'a</literal> suggests that <literal>raise</literal> could
      return a value of any type. That seems impossible, and it is.
      <literal>raise</literal> has this type because it never returns at
      all. This behavior isn't restricted to functions like
      <literal>raise</literal> that terminate by throwing exceptions.
      Here's another example of a function that doesn't return a value.
    </para>
    <programlisting>
# let rec forever () = forever ();;
val forever : unit -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      <literal>forever</literal> doesn't return a value for a different
      reason: it is an infinite loop.
    </para>
    <para>
      This all matters because it means that the return type of
      <literal>raise</literal> can be whatever it needs to be to fit in
      to the context it is called in. Thus, the type system will let us
      throw an exception anywhere in a program.
    </para>
    <sidebar>
    <title>
    Declaring exceptions with <literal>with sexp</literal>
    </title>
    <para>
      OCaml can't always generate a useful textual representation of
      your exception, for example:
    </para>
    <programlisting>
# exception Wrong_date of Date.t;;
exception Wrong_date of Date.t
# Wrong_date (Date.of_string &quot;2011-02-23&quot;);;
- : exn = Wrong_date(_)
</programlisting>
    <para>
      But if you declare the exception using
      <literal>with sexp</literal> (and the constituent types have sexp
      converters), we'll get something with more information.
    </para>
    <programlisting>
# exception Wrong_date of Date.t with sexp;;
exception Wrong_date of Core.Std.Date.t
# Wrong_date (Date.of_string &quot;2011-02-23&quot;);;
- : exn = (.Wrong_date 2011-02-23)
</programlisting>
    <para>
      The period in front of <literal>Wrong_date</literal> is there
      because the representation generated by
      <literal>with sexp</literal> includes the full module path of the
      module where the exception in question is defined. This is quite
      useful in tracking down which precise exception is being reported.
      In this case, since we've declared the exception at the toplevel,
      that module path is trivial.
    </para>
    </sidebar>
    <sect2 id="exception-handlers">
      <title>Exception handlers</title>
      <para>
        So far, we've only seen exceptions fully terminate the execution
        of a computation. But often, we want a program to be able to
        respond to and recover from an exception. This is achieved
        through the use of <emphasis>exception handlers</emphasis>.
      </para>
      <para>
        In OCaml, an exception handler is declared using a
        <literal>try</literal>/<literal>with</literal> statement. Here's
        the basic syntax.
      </para>
      <programlisting>
try &lt;expr&gt; with
| &lt;pat1&gt; -&gt; &lt;expr1&gt;
| &lt;pat2&gt; -&gt; &lt;expr2&gt;
...
</programlisting>
      <para>
        A <literal>try</literal>/<literal>with</literal> clause would
        first evaluate <literal>&lt;expr&gt;</literal>, and if that
        evaluation completes without returning an exception, then the
        value of the overall expression is the value of
        <literal>&lt;expr&gt;</literal>.
      </para>
      <para>
        But if evaluating <literal>&lt;expr&gt;</literal> leads to an
        exception being thrown, then the exception will be fed to the
        pattern match statements following the <literal>with</literal>.
        If the exception matches a pattern, then the expression on the
        right hand side of that pattern will be evaluated. Otherwise,
        the original exception continues up the call stack, to be
        handled by the next outer exception handler, or terminate the
        program if there is none.
      </para>
    </sect2>
    <sect2 id="cleaning-up-in-the-presence-of-exceptions">
      <title>Cleaning up in the presence of exceptions</title>
      <para>
        One headache with exceptions is that they can terminate your
        execution at unexpected places, leaving your program in an
        awkward state. Consider the following code snippet:
      </para>
      <programlisting language="ocaml">
let load_config filename =
  let inc = In_channel.create filename in
  let config = Config.t_of_sexp (Sexp.input_sexp inc) in
  In_channel.close inc;
  config
</programlisting>
      <para>
        The problem with this code is that the function that loads the
        s-expression and parses it into a <literal>Config.t</literal>
        might thrown an exception if the config file in question is
        malformed. Unfortunately, that means that the
        <literal>In_channel.t</literal> that was opened will never be
        closed, leading to a file-descriptor leak.
      </para>
      <para>
        We can fix this using Core's <literal>protect</literal>
        function. The basic purpose of <literal>protect</literal> is to
        ensure that the <literal>finally</literal> thunk will be called
        when <literal>f</literal> exits, whether it exited normally or
        with an exception. Here's how it could be used to fix
        <literal>load_config</literal>.
      </para>
      <programlisting language="ocaml">
let load_config filename =
  let inc = In_channel.create filename in
  protect ~f:(fun () -&gt; Config.t_of_sexp (Sexp.input_sexp inc)
    ~finally:(fun () -&gt; In_channel.close inc)
</programlisting>
    </sect2>
    <sect2 id="catching-specific-exceptions">
      <title>Catching specific exceptions</title>
      <para>
        OCaml's exception-handling system allows you to tune your
        error-recovery logic to the particular error that was thrown.
        For example, <literal>List.find_exn</literal> always throws
        <literal>Not_found</literal>. You can take advantage of this in
        your code, for example, let's define a function called
        <literal>lookup_weight</literal>, with the following signature:
      </para>
      <programlisting language="ocaml">
(** [lookup_weight ~compute_weight alist key] Looks up a
    floating-point weight by applying [compute_weight] to the data
    associated with [key] by [alist].  If [key] is not found, then
    return 0.
*)
val lookup_weight :
  compute_weight:('data -&gt; float) -&gt; ('key * 'data) list -&gt; 'key -&gt; float
</programlisting>
      <para>
        We can implement such a function using exceptions as follows:
      </para>
      <programlisting>
# let lookup_weight ~compute_weight alist key =
    try
      let data = List.Assoc.find_exn alist key in
      compute_weight data
    with
      Not_found -&gt; 0. ;;
val lookup_weight :
  compute_weight:('a -&gt; float) -&gt; ('b * 'a) list -&gt; 'b -&gt; float =
  &lt;fun&gt;
</programlisting>
      <para>
        This implementation is more problematic than it looks. In
        particular, what happens if <literal>compute_weight</literal>
        itself throws an exception? Ideally,
        <literal>lookup_weight</literal> should propagate that exception
        on, but if the exception happens to be
        <literal>Not_found</literal>, then that's not what will happen:
      </para>
      <programlisting>
# lookup_weight ~compute_weight:(fun _ -&gt; raise Not_found)
    [&quot;a&quot;,3; &quot;b&quot;,4] &quot;a&quot; ;;
- : float = 0.
</programlisting>
      <para>
        This kind of problem is hard to detect in advance, because the
        type system doesn't tell us what kinds of exceptions a given
        function might throw. Because of this kind of confusion, it's
        usually better to avoid catching specific exceptions. In this
        case, we can improve the code by catching the exception in a
        narrower scope.
      </para>
      <programlisting language="ocaml">
# let lookup_weight ~compute_weight alist key =
    match
      try Some (List.Assoc.find_exn alist key) with
      | Not_found -&gt; None
    with
    | None -&gt; 0.
    | Some data -&gt; compute_weight data ;;
</programlisting>
      <para>
        At which point, it makes sense to simply use the non-exception
        throwing function, <literal>List.Assoc.find</literal>, instead.
      </para>
    </sect2>
    <sect2 id="backtraces">
      <title>Backtraces</title>
      <para>
        A big part of the point of exceptions is to give useful
        debugging information. But at first glance, OCaml's exceptions
        can be less than informative. Consider the following simple
        program.
      </para>
      <programlisting language="ocaml">
(* exn.ml *)

open Core.Std
exception Empty_list

let list_max = function
  | [] -&gt; raise Empty_list
  | hd :: tl -&gt; List.fold tl ~init:hd ~f:(Int.max)

let () =
  printf &quot;%d\n&quot; (list_max [1;2;3]);
  printf &quot;%d\n&quot; (list_max [])
</programlisting>
      <para>
        If we build and run this program, we'll get a pretty
        uninformative error:
      </para>
      <programlisting>
$ ./exn
3
Fatal error: exception Exn.Empty_list
</programlisting>
      <para>
        The example in qeustion is short enough that it's quite easy to
        see where the error came from. But in a complex program, simply
        knowing which exception was thrown is usually not enough
        information to figure out what went wrong.
      </para>
      <para>
        We can get more information from OCaml if we turn on stack
        traces. This can be done by setting the
        <literal>OCAMLRUNPARAM</literal> environment variable, as shown:
      </para>
      <programlisting>
exn $ export OCAMLRUNPARAM=b
exn $ ./exn
3
Fatal error: exception Exn.Empty_list
Raised at file &quot;exn.ml&quot;, line 7, characters 16-26
Called from file &quot;exn.ml&quot;, line 12, characters 17-28
</programlisting>
      <para>
        Backtraces can also be obtained at runtime. In particular,
        <literal>Exn.backtrace</literal> will return the backtrace fo
        the most recently thrown exception.
      </para>
    </sect2>
    <sect2 id="exceptions-for-control-flow">
      <title>Exceptions for control flow</title>
      <para>
      </para>
    </sect2>
    <sect2 id="from-exceptions-to-error-aware-types-and-back-again">
      <title>From exceptions to error-aware types and back again</title>
      <para>
        Both exceptions and error-aware types are necessary parts of
        programming in OCaml. As such, you often need to move between
        these two worlds. Happily, Core comes with some useful helper
        functions to help you do just that. For example, given a piece
        of code that can throw an exception, you can capture that
        exception into an option as follows:
      </para>
      <programlisting>
# let find alist key =
    Option.try_with (fun () -&gt; find_exn alist key) ;;
val find : (string * 'a) list -&gt; string -&gt; 'a option = &lt;fun&gt;
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;c&quot;;;
- : int Core.Std.Option.t = None
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;b&quot;;;
- : int Core.Std.Option.t = Some 2
</programlisting>
      <para>
        And <literal>Result</literal> and <literal>Or_error</literal>
        have similar <literal>try_with</literal> functions. So, we could
        write:
      </para>
      <programlisting>
# let find alist key =
    Result.try_with (fun () -&gt; find_exn alist key) ;;
val find : (string * 'a) list -&gt; string -&gt; ('a, exn) Result.t = &lt;fun&gt;
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;c&quot;;;
- : (int, exn) Result.t = Result.Error Key_not_found(&quot;c&quot;)
</programlisting>
      <para>
        And then we can re-raise that exception:
      </para>
      <programlisting>
# Result.ok_exn (find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;b&quot;);;
- : int = 2
# Result.ok_exn (find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;c&quot;);;
Exception: Key_not_found(&quot;c&quot;).
</programlisting>
    </sect2>
  </sect1>
</chapter>
<chapter id="files-modules-and-programs">
  <title>Files, Modules and Programs</title>
  <para>
    We've so far experienced OCaml only through the toplevel. As you
    move from exercises to real-world programs, you'll need to leave the
    toplevel behind and start building programs from files. Files are
    more than just a convenient way to store and manage your code; in
    OCaml, they also act as abstraction boundaries that divide your
    program into conceptual components.
  </para>
  <para>
    In this chapter, we'll show you how to build an OCaml program from a
    collection of files, as well as the basics of working with modules
    and module signatures.
  </para>
  <sect1 id="single-file-programs">
    <title>Single File Programs</title>
    <para>
      We'll start with an example: a utility that reads lines from
      <literal>stdin</literal>, computing a frequency count of the lines
      that have been read in. At the end, the 10 lines with the highest
      frequency counts are written out. Here's a simple implementation,
      which we'll save as the file <literal>freq.ml</literal>. Note that
      we're using several functions from the
      <literal>List.Assoc</literal> module, which provides utility
      functions for interacting with association lists,
      <emphasis>i.e.</emphasis>, lists of key/value pairs.
    </para>
    <programlisting language="ocaml">
(* file.ml: basic implementation *)

open Core.Std

(* build_counts recursively builds up a mapping from lines to
   number of occurences of that line. *)
let rec build_counts counts =
  match In_channel.input_line stdin with
  | None -&gt; counts (* EOF, so return the counts accummulated so far *)
  | Some line -&gt;
    (* get the number of times this line has been seen before,
       inferring 0 if the line doesn't show up in [counts] *)
    let count =
      match List.Assoc.find counts line with
      | None -&gt; 0
      | Some x -&gt; x
    in
    (* increment the count for line by 1, and recurse *)
    build_counts (List.Assoc.add counts line (count + 1))

let () =
  (* Compute the line counts *)
  let counts = build_counts [] in
  (* Sort the line counts in descending order of frequency *)
  let sorted_counts = List.sort ~cmp:(fun (_,x) (_,y) -&gt; descending x y) counts  in
  (* Print out the 10 highest frequency entries *)
  List.iter (List.take 10 sorted_counts) ~f:(fun (line,count) -&gt;
    printf &quot;%3d: %s\n&quot; count line)
</programlisting>
    <sidebar><title>
    Where is the main function?
    </title>
    <para>
      Unlike C, programs in OCaml do not have a unique
      <literal>main</literal> function. When an OCaml program is
      evaluated, all the statements in the implementation files are
      evaluated in order. These implementation files can contain
      arbitrary expressions, not just function definitions. In this
      example, the role of the <literal>main</literal> function is
      played by the expression
      <literal>let () = process_lines []</literal>, which kicks off the
      actions of the program. But really the entire file is evaluated at
      startup, and so in some sense the full codebase is one big
      <literal>main</literal> function.
    </para>
    </sidebar>
    <para>
      If we weren't using Core or any other external libraries, we could
      build the executable like this:
    </para>
    <programlisting>
ocamlc freq.ml -o freq
</programlisting>
    <para>
      But in this case, this command will fail with the error
      <literal>Unbound module Core</literal>. We need a somewhat more
      complex invocation to get Core linked in:
    </para>
    <programlisting>
ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq
</programlisting>
    <para>
      Here we're using <literal>ocamlfind</literal>, a tool which itself
      invokes other parts of the ocaml toolchain (in this case,
      <literal>ocamlc</literal>) with the appropriate flags to link in
      particular libraries and packages. Here,
      <literal>-package core</literal> is asking
      <literal>ocamlfind</literal> to link in the Core library,
      <literal>-linkpkg</literal> is required to do the final linking in
      of packages for building a runnable executable, and
      <literal>-thread</literal> turns on threading support, which is
      required for Core.
    </para>
    <para>
      While this works well enough for a one-file project, more
      complicated builds will require a tool to orchestrate the build.
      One great tool for this task is <literal>ocamlbuild</literal>,
      which is shipped with the OCaml compiler. We'll talk more about
      <literal>ocamlbuild</literal> in chapter {{{OCAMLBUILD}}}, but for
      now, we'll just walk through the steps required for this simple
      application. First, create a <literal>_tags</literal> file,
      containing the following lines.
    </para>
    <programlisting>
true:package(core)
true:thread,annot,debugging
</programlisting>
    <para>
      The purpose of the <literal>_tags</literal> file is to specify
      which compilation options are required for which files. In this
      case, we're telling <literal>ocamlbuild</literal> to link in the
      <literal>core</literal> package and to turn on threading, output
      of annotation files, and debugging support for all files (the
      pattern <literal>true</literal> matches every file in the
      project.)
    </para>
    <para>
      We then create a build script <literal>build.sh</literal> that
      invokes <literal>ocamlbuild</literal>:
    </para>
    <programlisting>
#!/usr/bin/env bash

TARGET=freq
ocamlbuild -use-ocamlfind $TARGET.byte &amp;&amp; cp $TARGET.byte $TARGET
</programlisting>
    <para>
      If you invoke <literal>build.sh</literal>, you'll get a bytecode
      executable. If we'd used a target of
      <literal>unique.native</literal> in <literal>build.sh</literal>,
      we would have gotten native-code instead.
    </para>
    <para>
      Whichever way you build the application, you can now run it from
      the command-line. The following line extracts strings from the
      <literal>ocamlopt</literal> executable, and then reports the most
      frequently occurring ones.
    </para>
    <programlisting>
$ strings `which ocamlopt` | ./freq
 13: movq
 10: cmpq
  8: &quot;, &amp;
  7: .globl
  6: addq
  6: leaq
  5: &quot;, $
  5: .long
  5: .quad
  4: &quot;, '
</programlisting>
    <sidebar><title>
    Byte-code vs native-code
    </title>
    <para>
      OCaml ships with two compilers---the <literal>ocamlc</literal>
      byte-code compiler, and the <literal>ocamlopt</literal>
      native-code compiler. Programs compiled with
      <literal>ocamlc</literal> are interpreted by a virtual machine,
      while programs compiled with <literal>ocamlopt</literal> are
      compiled to native machine code to be run on a specific operating
      system and processor architecture.
    </para>
    <para>
      Aside from performance, executables generated by thet two
      compilers have nearly identical behavior. There are a few things
      to be aware of. First, the byte-code compiler can be used on more
      architectures, and has some better tool support; in particular,
      the OCaml debugger only works with byte-code. Also, the byte-code
      compiler compiles faster than the native code compiler.
    </para>
    <para>
      As a general matter, production executables should usually be
      built using the native-code compiler, but it sometimes makes sense
      to use bytecode for development builds. And, of course, bytecode
      makese sense when targetting a platform not supported by the
      native code compiler.
    </para>
    </sidebar>

  </sect1>
  <sect1 id="multi-file-programs-and-modules">
    <title>Multi-file programs and modules</title>
    <para>
      Source files in OCaml are tied into the module system, with each
      file compiling down into a module whose name is derived from the
      name of the file. We've encountered modules before, for example,
      when we used functions like <literal>find</literal> and
      <literal>add</literal> from the <literal>List.Assoc</literal>
      module. At it's simplest, you can think of a module as a
      collection of definitions that are stored within a namespace.
    </para>
    <para>
      Let's consider how we can use modules to refactor the
      implementation of <literal>freq.ml</literal>. Remember that the
      variable <literal>counts</literal> contains an association list
      representing the counts of the lines seen so far. But updating an
      association list takes time linear in the length of the list,
      meaning that the time complexity of processing a file is quadratic
      in the number of distinct lines in the file.
    </para>
    <para>
      We can fix this problem by replacing association lists with a more
      efficient datastructure. To do that, we'll first factor out the
      key functionality into a separate module with an explicit
      interface. We can consider alternative (and more efficient)
      implementations once we have a clear interface to program against.
    </para>
    <para>
      We'll start by creating a file, <literal>counter.ml</literal>,
      that contains the logic for maintaining the association list used
      to describe the counts. The key function, called
      <literal>touch</literal>, updates the association list with the
      information that a given line should be added to the frequency
      counts.
    </para>
    <programlisting language="ocaml">
(* counter.ml: first version *)

open Core.Std

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)
</programlisting>
    <para>
      We can now rewrite <literal>freq.ml</literal> to use
      <literal>Counter</literal>. Note that the resulting code can still
      be built with <literal>build.sh</literal>, since
      <literal>ocambuild</literal> will discover dependencies and
      realize that <literal>counter.ml</literal> needs to be compiled.
    </para>
    <programlisting language="ocaml">
(* freq.ml: using Counter *)

open Core.Std

let rec build_counts counts =
  match In_channel.input_line stdin with
  | None -&gt; counts
  | Some line -&gt; build_counts (Counter.touch counts line)

let () =
  let counts = build_counts [] in
  let sorted_counts = List.sort counts
    ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  in
  List.iter (List.take sorted_counts 10)
    ~f:(fun (line,count) -&gt; printf &quot;%3d: %s\n&quot; count line)
</programlisting>
    <sect2 id="signatures-and-abstract-types">
      <title>Signatures and Abstract Types</title>
      <para>
        While we've pushed some of the logic to the
        <literal>Counter</literal> module, the code in
        <literal>freq.ml</literal> can still depend on the details of
        the implementation of <literal>Counter</literal>. Indeed, if you
        look at the invocation of <literal>build_counts</literal>:
      </para>
      <programlisting language="ocaml">
  let counts = build_counts [] in
</programlisting>
      <para>
        you'll see that it depends on the fact that the empty set of
        frequency counts is represented as an empty list. We'd like to
        prevent this kind of dependency, so that we can change the
        implementation of <literal>Counter</literal> without needing to
        change client code like that in <literal>freq.ml</literal>.
      </para>
      <para>
        The first step towards hiding the implementation details of
        <literal>Counter</literal> is to create an interface file,
        <literal>counter.mli</literal>, which controls how
        <literal>counter</literal> is accessed. Let's start by writing
        down a simple descriptive interface, <emphasis>i.e.</emphasis>,
        an interface that describes what's currently available in
        <literal>Counter</literal> without hiding anything. We'll use
        <literal>val</literal> declarations in the
        <literal>mli</literal>, which have the following syntax
      </para>
      <programlisting>
val &lt;identifier&gt; : &lt;type&gt;
</programlisting>
      <para>
        and are used to expose the existence of a given value in the
        module. Here's an interface that describes the current contents
        of <literal>Counter</literal>. We can save this as
        <literal>counter.mli</literal> and compile, and the program will
        build as before.
      </para>
      <programlisting language="ocaml">
(* counter.mli: descriptive interface *)

val touch : (string * int) list -&gt; string -&gt; (string * int) list
</programlisting>
      <para>
        To actually hide the fact that frequency counts are represented
        as association lists, we need to make the type of frequency
        counts <emphasis>abstract</emphasis>. A type is abstract if its
        name is exposed in the interface, but its definition is not.
        Here's an abstract interface for <literal>Counter</literal>:
      </para>
      <programlisting language="ocaml">
(* counter.mli: abstract interface *)

open Core.Std

type t

val empty : t
val to_list : t -&gt; (string * int) list
val touch : t -&gt; string -&gt; t
</programlisting>
      <para>
        Note that we needed to add <literal>empty</literal> and
        <literal>to_list</literal> to <literal>Counter</literal>, since
        otherwise, there would be no way to create a
        <literal>Counter.t</literal> or get data out of one.
      </para>
      <para>
        Here's a rewrite of <literal>counter.ml</literal> to match this
        signature.
      </para>
      <programlisting language="ocaml">
(* counter.ml: implementation matching abstract interface *)

open Core.Std

type t = (string * int) list

let empty = []

let to_list x = x

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)
</programlisting>
      <para>
        If we now try to compile <literal>freq.ml</literal>, we'll get
        the following error:
      </para>
      <programlisting>
File &quot;freq.ml&quot;, line 11, characters 20-22:
Error: This expression has type 'a list
       but an expression was expected of type Counter.t
</programlisting>
      <para>
        This is because <literal>freq.ml</literal> depends on the fact
        that frequency counts are represented as association lists, a
        fact that we've just hidden. We just need to fix the code to use
        <literal>Counter.empty</literal> instead of
        <literal>[]</literal> and <literal>Counter.to_list</literal> to
        get the association list out at the end for processing and
        printing.
      </para>
      <para>
        Now we can turn to optimizing the implementation of
        <literal>Counter</literal>. Here's an alternate and far more
        efficient implementation, based on the <literal>Map</literal>
        datastructure in Core.
      </para>
      <programlisting language="ocaml">
(* counter.ml: efficient version *)

open Core.Std

type t = (string,int) Map.t

let empty = Map.empty

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t s (count + 1)

let to_list t = Map.to_alist t
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="more-on-modules-and-signatures">
    <title>More on modules and signatures</title>
    <sect2 id="concrete-types-in-signatures">
      <title>Concrete types in signatures</title>
      <para>
        In our frequency-count example, the module
        <literal>Counter</literal> had an abstract type
        <literal>Counter.t</literal> for representing a collection of
        frequency counts. Sometimes, you'll want to make a type in your
        interface <emphasis>concrete</emphasis>, by including the type
        definition in the interface.
      </para>
      <para>
        For example, imagine we wanted to add a function to
        <literal>Counter</literal> for returning the line with the
        median frequency count. If the number of lines is even, then
        there is no precise median, so the function would return the two
        lines before and after the median instead. We'll use a custom
        type to represent the fact that there are two possible possible
        return values. Here's a possible implementation.
      </para>
      <programlisting language="ocaml">
type median = | Median of string
              | Before_and_after of string * string

let median t =
  let sorted_strings = List.sort (Map.to_alist t)
      ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  in
  let len = List.length sorted_strings in
  if len = 0 then failwith &quot;median: empty frequency count&quot;;
  let nth n = List.nth_exn sorted_strings n in
  if len mod 2 = 1
  then Median (nth (len/2))
  else Before_and_after (nth (len/2) (len/2 + 1))
</programlisting>
      <para>
        Now, to expose this usefully in the interface, we need to expose
        both the function and the type <literal>median</literal> with
        its definition. We'd do that by adding these lines to the
        <literal>counter.mli</literal>:
      </para>
      <programlisting language="ocaml">
type median = | Median of string
              | Before_and_after of string * string

val get_median : t -&gt; median
</programlisting>
      <para>
        The decision of whether a given type should be abstract or
        concrete is an important one. Abstract types give you more
        control over how values are created and accessed, and makes it
        easier to enforce invariants beyond the what's enforced by the
        type itself; concrete types let you expose more detail and
        structure to client code in a lightweight way. The right choice
        depends very much on the context.
      </para>
    </sect2>
    <sect2 id="the-include-directive">
      <title>The <literal>include</literal> directive</title>
      <para>
        OCaml provides a number of tools for manipulating modules. One
        particularly useful one is the <literal>include</literal>
        directive, which is used to include the contents of one module
        into another.
      </para>
      <para>
        One natural application of <literal>include</literal> is to
        create one module which is an extension of another one. For
        example, imagine you wanted to build an extended version of the
        <literal>List</literal> module, where you've added some
        functionality not present in the module as distributed in Core.
        We can do this easily using <literal>include</literal>:
      </para>
      <programlisting language="ocaml">
(* ext_list.ml: an extended list module *)

open Core.Std

(* The new function we're going to add *)
let rec intersperse list el =
  match list with
  | [] | [ _ ]   -&gt; list
  | x :: y :: tl -&gt; x :: el :: intersperse (y::tl) el

(* The remainder of the list module *)
include List
</programlisting>
      <para>
        Now, what about the interface of this new module? It turns out
        that include works on the signature language as well, so we can
        pull essentially the same trick to write an
        <literal>mli</literal> for this new module. The only trick is
        that we need to get our hands on the signature for the list
        module, which can be done using
        <literal>module type of</literal>.
      </para>
      <programlisting language="ocaml">
(* ext_list.mli: an extended list module *)

open Core.Std

(* Include the interface of the list module from Core *)
include (module type of List)

(* Signature of function we're adding *)
val intersperse : 'a list -&gt; 'a -&gt; 'a list
</programlisting>
      <para>
        And we can now use <literal>Ext_list</literal> as a replacement
        for <literal>List</literal>. If we want to use
        <literal>Ext_list</literal> in preference to
        <literal>List</literal> in our project, we can create a file of
        common definitions:
      </para>
      <programlisting language="ocaml">
(* common.ml *)

module List = Ext_list
</programlisting>
      <para>
        And if we then put <literal>open Common</literal> after
        <literal>open Core.Std</literal> at the top of each file in our
        project, then references to <literal>List</literal> will
        automatically go to <literal>Ext_list</literal> instead.
      </para>
    </sect2>
    <sect2 id="modules-within-a-file">
      <title>Modules within a file</title>
      <para>
        Up until now, we've only considered modules that correspond to
        files, like <literal>counter.ml</literal>. But modules (and
        module signatures) can be nested inside other modules. As a
        simple example, consider a program that needs to deal with some
        class of identifier like a username. Rather than just keeping
        usernames as strings, you might want to mint an abstract type,
        so that the type-system will help you to not confuse usernames
        with other string data that is floating around your program.
      </para>
      <para>
        Here's how you might create such a type, within a module:
      </para>
      <programlisting language="ocaml">
open Core.Std

module Username : sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end = struct
  type t = string
  let of_string x = x
  let to_string x = x
end
</programlisting>
      <para>
        The basic structure of a module declaration like this is:
      </para>
      <programlisting language="ocaml">
module &lt;name&gt; : &lt;signature&gt; = &lt;implementation&gt;
</programlisting>
      <para>
        We could have written this slightly differently, by giving the
        signature its own top-level <literal>module type</literal>
        declaration, making it possible to in a lightweight way create
        multiple distinct types with the same underlying implementation.
      </para>
      <programlisting language="ocaml">
module type ID = sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end

module String_id = struct
  type t = string
  let of_string x = x
  let to_string x = x
end

module Username : ID = String_id
module Hostname : ID = String_id

(* Now the following buggy code won't compile *)
type session_info = { user: Username.t;
                      host: Hostname.t;
                      when_started: Time.t;
                    }

let sessions_have_same_user s1 s2 =
  s1.user = s1.host
</programlisting>
    </sect2>
    <sect2 id="opening-modules">
      <title>Opening modules</title>
      <para>
        One useful primitive in OCaml's module language is the
        <literal>open</literal> directive. We've seen that already in
        the <literal>open Core.Std</literal> that has been at the top of
        our source files.
      </para>
      <para>
        The basic purpose of <literal>open</literal> is to extend the
        namespaces that OCaml searches when trying to resolve an
        identifier. Roughly, if you open a module <literal>M</literal>,
        then every subsequent time you look for an identifier
        <literal>foo</literal>, the module system will look in
        <literal>M</literal> for a value named <literal>foo</literal>.
        This is true for all kinds of identifiers, including types, type
        constructors, values and modules.
      </para>
      <para>
        <literal>open</literal> is essential when dealing with something
        like a standard library, but it's generally good style to keep
        opening of modules to a minimum. Opening a module is basically a
        tradeoff between terseness and explicitness - the more modules
        you open, the harder it is to look at an identifier and figure
        out where it's defined.
      </para>
      <para>
        Here's some general advice on how to deal with opens.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Opening modules at the top-level of a module should be done
            quite sparingly, and generally only with modules that have
            been specifically designed to be opened, like
            <literal>Core.Std</literal> or
            <literal>Option.Monad_infix</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            One alternative to local opens that makes your code terser
            without giving up on explicitness is to locally rebind the
            name of a module. So, instead of writing:
          </para>
          <programlisting language="ocaml">
let print_median m =
   match m with
   | Counter.Median string -&gt; printf &quot;True median:\n   %s\n&quot;
   | Counter.Before_and_after of before * after -&gt;
     printf &quot;Before and after median:\n   %s\n   %s\n&quot; before after
</programlisting>
          <para>
            you could write
          </para>
          <programlisting language="ocaml">
let print_median m =
   let module C = Counter in
   match m with
   | C.Median string -&gt; printf &quot;True median:\n   %s\n&quot;
   | C.Before_and_after of before * after -&gt;
     printf &quot;Before and after median:\n   %s\n   %s\n&quot; before after
</programlisting>
          <para>
            Because the module name <literal>C</literal> only exists for
            a short scope, it's easy to read and remember what
            <literal>C</literal> stands for. Rebinding modules to very
            short names at the top-level of your module is usually a
            mistake.
          </para>
        </listitem>
        <listitem>
          <para>
            If you do need to do an open, it's better to do a
            <emphasis>local open</emphasis>. There are two syntaxes for
            local opens. For example, you can write:
          </para>
          <programlisting language="ocaml">
let average x y =
  let open Int64 in
  x + y / of_int 2
</programlisting>
          <para>
            In the above, <literal>of_int</literal> and the infix
            operators are the ones from <literal>Int64</literal> module.
          </para>
          <para>
            There's another even more lightweight syntax for local
            opens, which is particularly useful for small expressions:
          </para>
          <programlisting language="ocaml">
let average x y =
  Int64.(x + y / of_int 2)
</programlisting>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2 id="common-errors-with-modules">
      <title>Common errors with modules</title>
      <para>
        When OCaml compiles a program with an <literal>ml</literal> and
        an <literal>mli</literal>, it will complain if it detects a
        mismatch between the two. Here are some of the common errors
        you'll run into.
      </para>
      <sect3 id="type-mismatches">
        <title>Type mismatches</title>
        <para>
          The simplest kind of error is where the type specified in the
          signature does not match up with the type in the
          implementation of the module. As an example, if we replace the
          <literal>val</literal> declaration in
          <literal>counter.mli</literal> by swapping the types of the
          first two arguments:
        </para>
        <programlisting language="ocaml">
val touch : string -&gt; t -&gt; t
</programlisting>
        <para>
          and then try to compile <literal>Counter</literal> (by writing
          <literal>ocamlbuild -use-ocamlfind counter.cmo</literal>),
          we'll ge the following error:
        </para>
        <programlisting>
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       Values do not match:
         val touch :
           ('a, int) Core.Std.Map.t -&gt; 'a -&gt; ('a, int) Core.Std.Map.t
       is not included in
         val touch : string -&gt; t -&gt; t
</programlisting>
        <para>
          This error message is a bit intimidating at first, and it
          takes a bit of thought to see where the first type, which is
          the type of [touch] in the implementation, doesn't match the
          second one, which is the type of [touch] in the interface. You
          need to recognize that [t] is in fact a [Core.Std.Map.t], and
          the problem is that in the first type, the first argument is a
          map while the second is the key to that map, but the order is
          swapped in the second type.
        </para>
      </sect3>
      <sect3 id="missing-definitions">
        <title>Missing definitions</title>
        <para>
          We might decide that we want a new function in
          <literal>Counter</literal> for pulling out the frequency count
          of a given string. We can update the <literal>mli</literal> by
          adding the following line.
        </para>
        <programlisting language="ocaml">
val count : t -&gt; string -&gt; int
</programlisting>
        <para>
          Now, if we try to compile without actully adding the
          implementation, we'll get this error:
        </para>
        <programlisting>
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       The field `count' is required but not provided
</programlisting>
        <para>
          A missing type definition will lead to a similar error.
        </para>
      </sect3>
      <sect3 id="type-definition-mismatches">
        <title>Type definition mismatches</title>
        <para>
          Type definitions that show up in an <literal>mli</literal>
          need to match up with corresponding definitions in the
          <literal>ml</literal>. Consider again the example of the type
          <literal>median</literal>. The order of the declaration of
          variants matters to the OCaml compiler so, if the definition
          of <literal>median</literal> in the implementation lists those
          options in a different order:
        </para>
        <programlisting language="ocaml">
type median = | Before_and_after of line * line
              | Median of line
</programlisting>
        <para>
          that will lead to a compilation error:
        </para>
        <programlisting>
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       Type declarations do not match:
         type median = Before_and_after of string * string | Median of string
       is not included in
         type median = Median of string | Before_and_after of string * string
       Their first fields have different names, Before_and_after and Median.
</programlisting>
        <para>
          Order is similarly important in other parts of the signature,
          including the order in which record fields are declared and
          the order of arguments (including labelled and optional
          arguments) to a function.
        </para>
      </sect3>
      <sect3 id="cyclic-dependencies">
        <title>Cyclic dependencies</title>
        <para>
          In most cases, OCaml doesn't allow circular dependencies,
          <emphasis>i.e.</emphasis>, a collection of definitions that
          all refer to each other. If you want to create such
          definitions, you typically have to mark them specially. For
          example, when defining a set of mutually recursive values, you
          need to define them using <literal>let rec</literal> rather
          than ordinary <literal>let</literal>.
        </para>
        <para>
          The same is true at the module level. By default, circular
          dependencies between modules is not allowed, and indeed,
          circular dependencies among files is never allowed.
        </para>
        <para>
          The simplest case of this is that a module can not directly
          refer to itself (although definitions within a module can
          refer to each other in the ordinary way). So, if we tried to
          add a reference to <literal>Counter</literal> from within
          <literal>counter.ml</literal>:
        </para>
        <programlisting language="ocaml">
let singleton l = Counter.touch Counter.empty
</programlisting>
        <para>
          then when we try to build, we'll get this error:
        </para>
        <programlisting>
File &quot;counter.ml&quot;, line 17, characters 18-31:
Error: Unbound module Counter
Command exited with code 2.
</programlisting>
        <para>
          The problem manifests in a different way if we create circular
          references between files. We could create such a situation by
          adding a reference to Freq from <literal>counter.ml</literal>,
          <emphasis>e.g.</emphasis>, by adding the following line:
        </para>
        <programlisting language="ocaml">
let build_counts = Freq.build_counts
</programlisting>
        <para>
          In this case, <literal>ocamlbuild</literal> will notice the
          error and complain:
        </para>
        <programlisting>
Circular dependencies: &quot;freq.cmo&quot; already seen in
  [ &quot;counter.cmo&quot;; &quot;freq.cmo&quot; ]
</programlisting>
      </sect3>
    </sect2>
  </sect1>
</chapter>
<chapter id="functors-and-first-class-modules">
  <title>Functors and First-class modules</title>
  <para>
    Up until now, modules have played a limited role, used as the way
    for organizing the system into different components with
    well-defined interfaces. This is of course important, but it is only
    part of what modules can do. OCaml's module system is part of a
    powerful toolset for organizing and putting together complex
    functionality.
  </para>
  <sect1 id="functors">
    <title>Functors</title>
    <para>
      A functor in OCaml is essentially a function from modules to
      modules. Let's walk through a small, complete example of how to
      use functors. In this case, we're going to show how you can use a
      functor build up a larger module interface from a few key
      components. First, let's start with the interface, in particular,
      an interface for something that supports the comparison operator.
    </para>
    <programlisting language="ocaml">
module type Comparable = sig
  type t
  val compare : t -&gt; t -&gt; int
  val (=)  : t -&gt; t -&gt; bool
  val (&lt;&gt;) : t -&gt; t -&gt; bool
  val (&gt;)  : t -&gt; t -&gt; bool
  val (&lt;)  : t -&gt; t -&gt; bool
  val (&gt;=) : t -&gt; t -&gt; bool
  val (&lt;=) : t -&gt; t -&gt; bool
  val min  : t -&gt; t -&gt; t
  val max  : t -&gt; t -&gt; t
end
</programlisting>
    <para>
      This is in fact a subset of the <literal>Comparable</literal>
      interface in Core.
    </para>
    <para>
      Now, suppose we want to implement multiple modules that support
      this interface. Implementing all of these individual functions for
      each module is going to be a lot of painful boilerplate, since
      it's essentially the same logic that ties it all together.
    </para>
    <para>
      By using a functor, however, we can derive an implementation that
      satisfies this interface provided with just the
      <literal>compare</literal> function. In particular, we'll require
      as input a module that satisfies this signature:
    </para>
    <programlisting language="ocaml">
module type Comparable_input = sig
  type t
  val compare : t -&gt; t -&gt; int
end
</programlisting>
    <para>
      and we'll create a new module that satisfies the
      <literal>Comparable</literal> signature. Here's a functor which
      does just that.
    </para>
    <programlisting language="ocaml">
module Make(M:Comparable_input) : Comparable with type t = M.t = struct
  type t = M.t
  let compare = M.compare
  let (=) x y = compare x y = 0
  let (&lt;&gt;) x y = compare x y &lt;&gt; 0
  let (&gt;) x y = compare x y &gt; 0
  let (&lt;) x y = compare x y &lt; 0
  let (&gt;=) x y = compare x y &gt;= 0
  let (&lt;=) x y = compare x y &lt;= 0
  let min x y = if x &lt; y then x else y
  let max x y = if x &gt; y then x else y
end
</programlisting>
  </sect1>
</chapter>
<chapter id="syntax-extensions">
  <title>Syntax Extensions</title>
  <para>
    <emphasis>(yminsky: still very very rough)</emphasis>
  </para>
  <para>
    This chapter convers several extensions to OCaml's syntax that are
    distributed with Core. Before diving into the details of the syntax
    extensions, let's take a small detour that will explain the
    motivation behind creating them in the first place.
  </para>
  <sect1 id="serialization-with-s-expressions">
    <title>Serialization with s-expressions</title>
    <para>
      Serialization, <emphasis>i.e.</emphasis> reading and writing
      program data to a sequence of bytes, is an important and common
      programming task. To this end, Core comes with good support for
      <emphasis>s-expressions</emphasis>, which are a convenient
      general-purpose serialization format. The type of an s-expression
      is as follows:
    </para>
    <programlisting language="ocaml">
module Sexp : sig
  type t = Atom of string | List of t list
end
</programlisting>
    <para>
      An s-expression is in essence a nested parenthetical list whose
      atomic values are strings. The <literal>Sexp</literal> module
      comes with functionality for parsing and printing s-expressions.
    </para>
    <programlisting>
# let sexp =
    let a x = Sexp.Atom x and l x = Sexp.List x in
    l [a &quot;this&quot;;l [a &quot;is&quot;; a &quot;an&quot;]; l [a &quot;s&quot;; a &quot;expression&quot;]];;
val sexp : Sexp.t = (this (is an) (s expression))
</programlisting>
    <para>
      In addition, most of the base types in Core support conversion to
      and from s-expressions. For example, we can write:
    </para>
    <programlisting>
# Int.sexp_of_t 3;;
- : Sexp.t = 3
# List.sexp_of_t;;
- : ('a -&gt; Sexp.t) -&gt; 'a List.t -&gt; Sexp.t = &lt;fun&gt;
# List.sexp_of_t Int.sexp_of_t [1;2;3];;
- : Sexp.t = (1 2 3)
</programlisting>
    <para>
      Notice that <literal>List.sexp_of_t</literal> is polymorphic, and
      takes as its first argument another conversion function to handle
      the elements of the list to be converted. Core uses this scheme
      more generally for defining sexp-converters for polymorphic types.
    </para>
    <para>
      But what if you want a function to convert some brand new type to
      an s-expression? You can of course write it yourself:
    </para>
    <programlisting>
# type t = { foo: int; bar: float };;
# let sexp_of_t t =
    let a x = Sexp.Atom x and l x = Sexp.List x in
    l [ l [a &quot;foo&quot;; Int.sexp_of_t t.foo  ];
        l [a &quot;bar&quot;; Float.sexp_of_t t.bar]; ]
  ;;
val sexp_of_t : t -&gt; Core.Std.Sexp.t = &lt;fun&gt;
# sexp_of_t { foo = 3; bar = -5.5 };;
- : Core.Std.Sexp.t = ((foo 3) (bar -5.5))
</programlisting>
    <para>
      This is somewhat tiresome to write, and it gets more so when you
      consider the parser, <emphasis>i.e.</emphasis>,
      <literal>t_of_sexp</literal>, which is considerably more complex.
      Writing this kind of parsing and printing code by hand is
      mechanical and error prone, not to mention a drag.
    </para>
    <para>
      Given how mechanical the code is, you could imagine writing a
      program that inspected the type definition and auto-generated the
      conversion code for you. That is precisely where syntax extensions
      come in. Using Sexplib and adding <literal>with sexp</literal> as
      an annotation to our type definition, we get the functions we want
      for free.
    </para>
    <programlisting>
# type t = { foo: int; bar: float } with sexp;;
type t = { foo : int; bar : float; }
val t_of_sexp__ : Sexplib.Sexp.t -&gt; t = &lt;fun&gt;
val t_of_sexp : Sexplib.Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexplib.Sexp.t = &lt;fun&gt;
# t_of_sexp (Sexp.of_string &quot;((bar 35) (foo 3))&quot;);;
- : t = {foo = 3; bar = 35.}
</programlisting>
    <para>
      (You can ignore <literal>t_of_sexp__</literal>, which is a helper
      function that is needed in very rare cases.)
    </para>
    <para>
      The syntax-extensions in Core that we're going to discuss all have
      this same basic structure: they auto-generate code based on type
      definitions, implementing functionality that you could in theory
      have implemented by hand, but with far less programmer effort.
    </para>
    <para>
      There are several syntax extensions distributed with Core,
      including:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis role="strong">Sexplib</emphasis>: provides
          serialization for s-expressions.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Bin_prot</emphasis>: provides
          serialization to an efficient binary format.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Fieldslib</emphasis>: generates
          first-class values that represent fields of a record, as well
          as accessor functions and setters for mutable record fields.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Variantslib</emphasis>: like Fieldslib
          for variants, producing first-class variants and other helper
          functions for interacting with variant types.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Pa_compare</emphasis>: generates
          efficient, type-specialized comparison functions.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Pa_typehash</emphasis>: generates a
          hash value for a type definition, <emphasis>i.e.</emphasis>,
          an integer that is highly unlikely to be the same for two
          distinct types.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We'll discuss each of these syntax extensions in detail, starting
      with Sexplib.
    </para>
  </sect1>
  <sect1 id="sexplib">
    <title>Sexplib</title>
    <sect2 id="formatting-of-s-expressions">
      <title>Formatting of s-expressions</title>
      <para>
        Sexplib's format for s-expressions is pretty straightforward: an
        s-expression is written down as a nested parenthetical
        expression, with whitespace-separated strings as the atoms.
        Quotes are used for atoms that contain parenthesis or spaces
        themselves, backslash is the escape character, and semicolons
        are used to introduce comments. Thus, if you create the
        following file:
      </para>
      <programlisting>
;; foo.scm

((foo 3.3) ;; Shall I compare thee  to a summer's dream?
 (bar &quot;this is () an \&quot; atom&quot;))
</programlisting>
      <para>
        we can load it up and print it back out again:
      </para>
      <programlisting>
# Sexp.load_sexp &quot;foo.scm&quot;;;
- : Sexp.t = ((foo 3.3) (bar &quot;this is () an \&quot; atom&quot;))
</programlisting>
      <para>
        Note that the comments were dropped from the file upon reading.
        This is expected, since there's no place in the
        <literal>Sexp.t</literal> type to store comments.
      </para>
      <para>
        If we introduce an error into our s-expression, by, say,
        deleting the open-paren in front of <literal>bar</literal>,
        we'll get a parse error:
      </para>
      <programlisting>
# Exn.handle_uncaught ~exit:false (fun () -&gt;
    ignore (Sexp.load_sexp &quot;foo.scm&quot;));;
  Uncaught exception:

  (Sexplib.Sexp.Parse_error
   ((location parse) (err_msg &quot;unexpected character: ')'&quot;) (text_line 4)
    (text_char 29) (global_offset 94) (buf_pos 94)))
</programlisting>
      <para>
        (In the above, we use <literal>Exn.handle_uncaught</literal> to
        make sure that the exception gets printed out in full detail.)
      </para>
    </sect2>
    <sect2 id="sexp-converters">
      <title>Sexp converters</title>
      <para>
        The most important functionality provided by Sexplib is the
        auto-generation of converters for new types. We've seen a bit of
        how this works already, but let's walk through a complete
        example. Here's the source for the beginning of a library for
        representing integer intervals.
      </para>
      <programlisting language="ocaml">
(* file: int_interval.ml *)
(* Module for representing closed integer intervals *)

open Core.Std

(* Invariant: For any Range (x,y), y &gt; x *)
type t = | Range of int * int
         | Empty
with sexp

let is_empty = function Empty -&gt; true | Range _ -&gt; false
let create x y = if x &gt; y then Empty else Range (x,y)
let contains i x = match i with
   | Empty -&gt; false
   | Range (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high
</programlisting>
      <para>
        We can now use this module as follows:
      </para>
      <programlisting language="ocaml">
(* file: test_interval.ml *)

open Core.Std

let intervals =
  let module I = Int_interval in
  [ I.create 3 4;
    I.create 5 4; (* should be empty *)
    I.create 2 3;
    I.create 1 6;
  ]

let () =
  intervals
  |! List.sexp_of_t Int_interval.sexp_of_t
  |! Sexp.to_string_hum
  |! print_endline
</programlisting>
      <para>
        But we're still missing something: we haven't created an
        <literal>mli</literal> for <literal>Int_interval</literal> yet.
        Note that we need to explicitly export the s-expression
        converters that were created within the ml. If we don't:
      </para>
      <programlisting language="ocaml">
(* file: int_interval.mli *)
(* Module for representing closed integer intervals *)

type t

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool
</programlisting>
      <para>
        then we'll get the following error:
      </para>
      <programlisting>
File &quot;test_interval.ml&quot;, line 15, characters 20-42:
Error: Unbound value Int_interval.sexp_of_t
Command exited with code 2.
</programlisting>
      <para>
        We could export the types by hand:
      </para>
      <programlisting language="ocaml">
type t
val sexp_of_t : Sexp.t -&gt; t
val t_of_sexp : t -&gt; Sexp.t
</programlisting>
      <para>
        But Sexplib has a shorthand for this as well, so that we can
        instead write simply:
      </para>
      <programlisting language="ocaml">
type t with sexp
</programlisting>
      <para>
        at which point <literal>test_interval.ml</literal> will compile
        again, and if we run it, we'll get the following output:
      </para>
      <programlisting>
$ ./test_interval.native
((Range 3 4) Empty (Range 2 3) (Range 1 6))
</programlisting>
      <sidebar> <title>
      Preserving invariants
      </title>
      <para>
        One easy mistake to make when dealing with sexp converters is to
        ignore the fact that those converters can violate the invariants
        of your code. For example, the <literal>Int_interval</literal>
        module depends for the correctness of the
        <literal>is_empty</literal> check on the fact that for any value
        <literal>Range (x,y)</literal>, <literal>y</literal> is greater
        than or equal to <literal>x</literal>. The
        <literal>create</literal> function preserves this invariant, but
        the <literal>t_of_sexp</literal> function does not.
      </para>
      <para>
        We can fix this problem by writing a custom sexp-converter, in
        this case, using the sexp-converter that we already have:
      </para>
      <programlisting language="ocaml">
type t = | Range of int * int
         | Empty
with sexp

let create x y = if x &gt; y then Empty else Range (x,y)

let t_of_sexp sexp =
  let t = t_of_sexp sexp in
  begin match t with
  | Range (x,y) when y &lt; x -&gt;
    of_sexp_error &quot;Upper and lower bound of Range swapped&quot; sexp
  | Empty | Range _ -&gt; ()
  end;
  t
</programlisting>
      <para>
        We call the function <literal>of_sexp_error</literal> to raise
        an exception because that improves the error reporting that
        Sexplib can provide when a conversion fails.
      </para>
      </sidebar>
    </sect2>
    <sect2 id="getting-good-error-messages">
      <title>Getting good error messages</title>
      <para>
        There are two steps to deserializing a type from an
        s-expression: first, converting the bytes in a file to an
        s-expression, and the second, converting that s-expression into
        the type in question. One problem with this is that it can be
        hard to localize errors to the right place using this scheme.
        Consider the following example:
      </para>
      <programlisting language="ocaml">
(* file: read_foo.ml *)

open Core.Std

type t = { a: string; b: int; c: float option } with sexp

let run () =
  let t =
    Sexp.load_sexp &quot;foo.scm&quot;
    |! t_of_sexp
  in
  printf &quot;b is: %d\n%!&quot; t.b

let () =
  Exn.handle_uncaught ~exit:true run
</programlisting>
      <para>
        If you were to run this on a malformatted file, say, this one:
      </para>
      <programlisting>
;; foo.scm
((a not-an-integer)
 (b not-an-integer)
 (c ()))
</programlisting>
      <para>
        you'll get the following error:
      </para>
      <programlisting>
read_foo $ ./read_foo.native
Uncaught exception:

  (Sexplib.Conv.Of_sexp_error
   (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;) not-an-integer)
</programlisting>
      <para>
        If all you have is the error message and the string, it's not
        terribly informative. In particular, you know that the parsing
        errored out on the atom &quot;not-an-integer&quot;, but you
        don't know which one! In a large file, this kind of bad error
        message can be pure misery.
      </para>
      <para>
        But there's hope! If we make s amll change to the
        <literal>run</literal> function as follows:
      </para>
      <programlisting language="ocaml">
let run () =
  let t = Sexp.load_sexp_conv_exn &quot;foo.scm&quot; t_of_sexp in
  printf &quot;b is: %d\n%!&quot; t.b
</programlisting>
      <para>
        and run it again, we'll get the following much more helpful
        error message:
      </para>
      <programlisting language="ocaml">
read_foo $ ./read_foo.native
Uncaught exception:

  (Sexplib.Conv.Of_sexp_error
   (Sexplib.Sexp.Annotated.Conv_exn foo.scm:3:4
    (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;))
   not-an-integer)
</programlisting>
      <para>
        In the above error, &quot;foo.scm:3:4&quot; tells us that the
        error occurred on &quot;foo.scm&quot;, line 3, character 4,
        which is a much better start for figuring out what has gone
        wrong.
      </para>
    </sect2>
    <sect2 id="sexp-conversion-directives">
      <title>Sexp-conversion directives</title>
      <para>
        Sexplib supports a collection of directives for modifying the
        default behavior of the autogenerated sexp-converters. These
        directives allow you to customize the way in which types are
        represented as s-expressions without having to write a custom
        parser. We describe these directives below.
      </para>
      <sect3 id="sexp-opaque">
        <title><literal>sexp-opaque</literal></title>
        <para>
          The most commonly used directive is
          <literal>sexp_opaque</literal>, whose purpose is to mark a
          given component of a type as being unconvertable. Anything
          marked with <literal>sexp_opaque</literal> will be presented
          as the atom <literal>&lt;opaque&gt;</literal> by the to-sexp
          converter, and will trigger an exception from the from-sexp
          converter. Note that the type of a component marked as opaque
          doesn't need to have a sexp-converter defined. Here, if we
          define a type without a sexp-converter, and then try to use it
          another type with a sexp-converter, we'll error out:
        </para>
        <programlisting>
# type no_converter = int * int;;
type no_converter = int * int
# type t = { a: no_converter; b: string } with sexp;;
Characters 14-26:
  type t = { a: no_converter; b: string } with sexp;;
                ^^^^^^^^^^^^
Error: Unbound value no_converter_of_sexp
</programlisting>
        <para>
          But with <literal>sexp_opaque</literal>, we won't:
        </para>
        <programlisting>
# type t = { a: no_converter sexp_opaque; b: string } with sexp;;
type t = { a : no_converter Core.Std.sexp_opaque; b : string; }
val t_of_sexp__ : Sexplib.Sexp.t -&gt; t = &lt;fun&gt;
val t_of_sexp : Sexplib.Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexplib.Sexp.t = &lt;fun&gt;
</programlisting>
        <para>
          And if we now convert a value of this type to an s-expression,
          we'll see the contents of field <literal>a</literal> marked as
          opaque:
        </para>
        <programlisting>
# sexp_of_t { a = (3,4); b = &quot;foo&quot; };;
- : Sexp.t = ((a &lt;opaque&gt;) (b foo))
</programlisting>
      </sect3>
      <sect3 id="sexp_option">
        <title><literal>sexp_option</literal></title>
        <para>
          Another common directive is <literal>sexp_opaque</literal>,
          which is used to make an optional field in a record. Ordinary
          optional values are represented either as
          <literal>()</literal> for <literal>None</literal>, or as
          <literal>(x)</literal> for <literal>Some x</literal>. If you
          put an option in a record field, then the record field will
          always be required, and its value will be presented in the way
          an ordinary optional value would. For example:
        </para>
        <programlisting>
# type t = { a: int option; b: string } with sexp;;
# sexp_of_t { a = None; b = &quot;hello&quot; };;
- : Sexp.t = ((a ()) (b hello))
# sexp_of_t { a = Some 3; b = &quot;hello&quot; };;
- : Sexp.t = ((a (3)) (b hello))
</programlisting>
        <para>
          But what if we want a field to be optional,
          <emphasis>i.e.</emphasis>, we want to allow it to be omitted
          from the record entirely? In that case, we can mark it with
          <literal>sexp_option</literal>:
        </para>
        <programlisting language="ocaml">
# type t = { a: int sexp_option; b: string } with sexp;;
# sexp_of_t { a = Some 3; b = &quot;hello&quot; };;
- : Sexp.t = ((a 3) (b hello))
# sexp_of_t { a = None; b = &quot;hello&quot; };;
- : Sexp.t = ((b hello))
</programlisting>
      </sect3>
      <sect3 id="sexp_list">
        <title><literal>sexp_list</literal></title>
        <para>
          One problem with the autogenerated sexp-converters is that
          they can have more parens than one would ideally like.
          Consider, for example, the following variant type:
        </para>
        <programlisting>
# type compatible_versions = | Specific of string list
                             | All
  with sexp;;
# sexp_of_compatible_versions (Specific [&quot;3.12.0&quot;; &quot;3.12.1&quot;; &quot;3.13.0&quot;]);;
- : Sexp.t = (Specific (3.12.0 3.12.1 3.13.0))
</programlisting>
        <para>
          You might prefer to make the syntax a bit less
          parenthesis-laden by dropping the parens around the list.
          <literal>sexp_list</literal> gives us this alternate syntax:
        </para>
        <programlisting>
# type compatible_versions = | Specific of string sexp_list
                             | All
  with sexp;;
# sexp_of_compatible_versions (Specific [&quot;3.12.0&quot;; &quot;3.12.1&quot;; &quot;3.13.0&quot;]);;
- : Sexp.t = (Specific 3.12.0 3.12.1 3.13.0)
</programlisting>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="bin_prot">
    <title>Bin_prot</title>
    <para>
      S-expressions are a good serialization format when you need
      something machine-parseable as well as human readable and
      editable. But Sexplib's s-expressions are not particularly
      performant. There are a number of reasons for this. For one thing,
      s-expression serialization goes through an intermediate type,
      <literal>Sexp.t</literal>, which must be allocated and is then
      typically thrown away, putting non-trivial pressure on the GC. In
      addition, parsing and printing to strings in an ASCII format can
      be expensive for types like <literal>int</literal>s,
      <literal>float</literal>s and <literal>Time.t</literal>s where
      some real computation needs to be done to produce or parse the
      ASCII representation.
    </para>
    <para>
      Bin_prot is a library designed to address these issues by
      providing fast serialization in a compact binary format. Kicking
      off the syntax extension is done by putting
      <literal>with bin_io</literal>. (This looks a bit unsightly in the
      top-level because of all the definitions that are generated. We'll
      elide those definitions here, but you can see it for yourself in
      the toplevel.)
    </para>
    <para>
      Here's a small complete example of a program that can read and
      write values using bin-io. Here, the serialization is of types
      that might be used as part of a message-queue, where each message
      has a topic, some content, and a source, which is in turn a
      hostname and a port.
    </para>
    <programlisting language="ocaml">
(* file: message_example.ml *)

open Core.Std

(* The type of a message *)
module Message = struct
  module Source = struct
    type t = { hostname: string;
               port: int;
             }
    with bin_io
  end

  type t = { topic: string;
             content: string;
             source: Source.t;
           }
  with bin_io
end

(* Create the 1st-class module providing the binability of messages *)
let binable = (module Message : Binable.S with type t = Message.t)

(* Saves a message to an output channel.  The message is serialized to
   a bigstring before being written out to the channel.  Also, a
   binary encoding of an integer is written out to tell the reader how
   long of a message to expect.  *)
let save_message outc msg =
  let s = Binable.to_bigstring binable msg in
  let len = Bigstring.length s in
  Out_channel.output_binary_int outc len;
  Bigstring.really_output outc s

(* Loading the message is done by first reading in the length, and by
   then reading in the appropriate number of bytes into a Bigstring
   created for that purpose. *)
let load_message inc =
  match In_channel.input_binary_int inc with
  | None -&gt; failwith &quot;Couldn't load message: length missing from header&quot;
  | Some len -&gt;
    let buf = Bigstring.create len in
    Bigstring.really_input ~pos:0 ~len inc buf;
    Binable.of_bigstring binable buf

(* To generate some example messages *)
let example content =
  let source =
    { Message.Source.
      hostname = &quot;ocaml.org&quot;; port = 2322 }
  in
  { Message.
    topic = &quot;rwo-example&quot;; content; source; }

(* write out three messages... *)
let write_messages () =
  let outc = Out_channel.create &quot;tmp.bin&quot; in
  List.iter ~f:(save_message outc) [
    example &quot;a wonderful&quot;;
    example &quot;trio&quot;;
    example &quot;of messages&quot;;
  ];
  Out_channel.close outc

(* ... and read them back in *)
let read_messages () =
  let inc = In_channel.create &quot;tmp.bin&quot; in
  for i = 1 to 3 do
    let msg = load_message inc in
    printf &quot;msg %d: %s\n&quot; i msg.Message.content
  done

let () =
  write_messages (); read_messages ()
</programlisting>
  </sect1>
  <sect1 id="fieldslib">
    <title>Fieldslib</title>
    <para>
      One common idiom when using records is to provide field accessor
      functions for a particular record.
    </para>
    <programlisting>
type t = { topic: string;
           content: string;
           source: Source.t;
         }

let topic   t = t.topic
let content t = t.content
let source  t = t.source
</programlisting>
    <para>
      Similarly, sometimes you simultaneously want an accessor to a
      field of a record and a textual representation of the name of that
      field. This might come up if you were validating a field and
      needed the string representation to generate an error message, or
      if you wanted to scaffold a form in a GUI automatically based on
      the fields of a record. Fieldslib provides a module
      <literal>Field</literal> for this purpose. Here's some code for
      creating <literal>Field.t</literal>'s for all the fields of our
      type <literal>t</literal>.
    </para>
    <programlisting language="ocaml">
# module Fields = struct
    let topic =
      { Field.
        name   = &quot;topic&quot;;
        setter = None;
        getter = (fun t -&gt; t.topic);
        fset   = (fun t topic -&gt; { t with topic });
      }
    let content =
      { Field.
        name   = &quot;content&quot;;
        setter = None;
        getter = (fun t -&gt; t.content);
        fset   = (fun t content -&gt; { t with content });
      }
    let source =
      { Field.
        name   = &quot;source&quot;;
        setter = None;
        getter = (fun t -&gt; t.source);
        fset   = (fun t source -&gt; { t with source });
      }
  end ;;
module Fields :
  sig
    val topic : (t, string list) Core.Std.Field.t
    val content : (t, string) Core.Std.Field.t
    val source : (t, Source.t) Core.Std.Field.t
  end
</programlisting>
  </sect1>
</chapter>
<chapter id="object-oriented-programming">
  <title>Object Oriented Programming</title>
  <para>
    <emphasis>(yminsky: If we don't feel like these are
    &quot;great&quot; tools, maybe we shouldn't say it!)</emphasis>
  </para>
  <para>
    <emphasis>(yminsky: I wonder if it's worth emphasizing what makes
    objects unique early on. I think of them as no better of an
    encapsulation tool than closures. What makes them unique in my mind
    is that they are some combination of lighter weight and more dynamic
    than the alternatives (modules, records of closures,
    etc.))</emphasis>
  </para>
  <para>
    <emphasis>(yminsky: I'm not sure where we should say it, but OCaml's
    object system is strikingly different from those that most people
    are used to. It would be nice if we could call those differences out
    clearly somewhere. The main difference I see is the fact that
    subtyping and inheritance are not tied together, and that subtyping
    is structural.)</emphasis>
  </para>
  <para>
    We've already seen several tools that OCaml provides for organizing
    programs, particularly first-class modules. In addition, OCaml also
    supports object-oriented programming. There are objects, classes,
    and their associated types. Objects are good for encapsulation and
    abstraction, and classes are good for code re-use.
  </para>
  <sect1 id="when-to-use-objects">
    <title>When to use objects</title>
    <para>
      You might wonder when to use objects. First-class modules are more
      expressive (a module can include types, classes and objects
      cannot), and modules, functors, and algebraic data types offer a
      wide range of ways to express program structure. In fact, many
      seasoned OCaml programmers rarely use classes and objects, if at
      all.
    </para>
    <para>
      What exactly is object-oriented programming? Mitchell [6] points
      out four fundamental properties.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis>Abstraction</emphasis>: the details of the
          implementation are hidden in the object; the interface is just
          the set of publically-accessible methods.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Subtyping</emphasis>: if an object
          <literal>a</literal> has all the functionality of an object
          <literal>b</literal>, then we may use <literal>a</literal> in
          any context where <literal>b</literal> is expected.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Dynamic lookup</emphasis>: when a message is sent to
          an object, the method to be executed is determined by the
          implementation of the object, not by some static property of
          the program. In other words, different objects may react to
          the same message in different ways.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Inheritance</emphasis>: the definition of one kind
          of object can be re-used to produce a new kind of object.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Modules already provide these features in some form, but the main
      focus of classes is on code re-use through inheritance and late
      binding of methods. This is a critical property of classes: the
      methods that implement an object are determined when the object is
      instantiated, a form of <emphasis>dynamic</emphasis> binding. In
      the meantime, while classes are being defined, it is possible (and
      necessary) to refer to methods without knowing statically how they
      will be implemented.
    </para>
    <para>
      In contrast, modules use static (lexical) scoping. If you want to
      parameterize your module code so that some part of it can be
      implemented later, you would write a function/functor. This is
      more explicit, but often more verbose than overriding a method in
      a class.
    </para>
    <para>
      In general, a rule of thumb might be: use classes and objects in
      situations where dynamic binding is a big win, for example if you
      have many similar variations in the implementation of a concept.
      Real world examples are fairly rare, but one good example is
      Xavier Leroy's
      <ulink url="http://gallium.inria.fr/~xleroy/software.html#cryptokit">Cryptokit</ulink>,
      which provides a variety of cryptographic primitives that can be
      combined in building-block style.
    </para>
  </sect1>
  <sect1 id="ocaml-objects">
    <title>OCaml objects</title>
    <para>
      If you already know about object oriented programming in a
      language like Java or C++, the OCaml object system may come as a
      surprise. Foremost is the complete separation of subtyping and
      inheritance in OCaml. In a language like Java, a class name is
      also used as the type of objects created by instantiating it, and
      the subtyping rule corresponds to inheritance. For example. if we
      implement a class <literal>Stack</literal> in Java by inheriting
      from a class <literal>Deque</literal>, we would be allowed to pass
      a stack anywhere a deque is expected (this is a silly example of
      course, practitioners will point out that we shouldn't do it).
    </para>
    <para>
      OCaml is entirely different. Classes are used to construct objects
      and support inheritance, including non-subtyping inheritance.
      Classes are not types. Instead, objects have <emphasis>object
      types</emphasis>, and if you want to use objects, you aren't
      required to use classes at all. Here is an example of a simple
      object.
    </para>
    <programlisting language="ocaml">
# let p =
  object
    val mutable x = 0
    method get = x
    method set i = x &lt;- i
  end;;
val p : &lt; get : int; set : int -&gt; unit &gt; = &lt;obj&gt;
</programlisting>
    <para>
      The object has an integer value <literal>x</literal>, a method
      <literal>get</literal> that returns x, and a method
      <literal>set</literal> that updates the value of x.
    </para>
    <para>
      The object type is enclosed in angle brackets
      <literal>&lt; ... &gt;</literal>, containing just the types of the
      methods. Fields, like x, are not part of the public interface of
      an object. All interaction with an object is through its methods.
      The syntax for a method invocation (also called &quot;sending a
      message&quot; to the object) uses the <literal>#</literal>
      character.
    </para>
    <programlisting language="ocaml">
# p#get;
- : int = 0
# p#set 17;;
- : unit = ()
# p#get;;
- : int = 17
</programlisting>
    <para>
      Objects can also be constructed by functions. If we want to
      specify the initial value of the object, we can define a function
      that takes the initial value and produces an object.
    </para>
    <programlisting language="ocaml">
# let make i =
  object
    val mutable x = i
    method get = x
    method set y = x &lt;- y
  end;;
val make : 'a -&gt; &lt; get : 'a; set : 'a -&gt; unit &gt; = &lt;fun&gt;
# let p = make 5;;
val p : &lt; get : int; set : int -&gt; unit &gt; = &lt;obj&gt;
# p#get;;
- : int = 5
</programlisting>
    <para>
      Note that the types of the function <literal>make</literal> and
      the returned object now use the polymorphic type
      <literal>'a</literal>. When make is invoked on a concrete value
      <literal>5</literal>, we get the same object type as before, with
      type <literal>int</literal> for the value.
    </para>
  </sect1>
  <sect1 id="object-polymorphism">
    <title>Object Polymorphism</title>
    <para>
      <emphasis>(yminsky: Maybe this is a good time to talk about the
      nature of object subtyping?)</emphasis>
    </para>
    <para>
      Functions can also take object arguments. Let's construct a new
      object <literal>average</literal> that's the average of any two
      objects with a <literal>get</literal> method.
    </para>
    <programlisting language="ocaml">
# let average p1 p2 =
  object
    method get = (p1#get + p2#get) / 2
  end;;
val average : &lt; get : int; .. &gt; -&gt; &lt; get : int; .. &gt; -&gt; &lt; get : int &gt; = &lt;fun&gt;
# let p1 = make 5;;
# let p2 = make 15;;
# let a = average p1 p2;;
# a#get;;
- : int = 10
# p2#set 25;;
# a#get;;
- : int = 15
</programlisting>
    <para>
      Note that the type for <literal>average</literal> uses the object
      type <literal>&lt; get : int; .. &gt;</literal>. The
      <literal>..</literal> are ellipsis, standing for any other
      methods. The type <literal>&lt; get : int; .. &gt;</literal>
      specifies an object that must have at least a
      <literal>get</literal> method, and possibly some others as well.
      If we try using the exact type
      <literal>&lt; get : int &gt;</literal> for an object with more
      methods, type inference will fail.
    </para>
    <programlisting language="ocaml">
# let (p : &lt; get : int &gt;) = make 5;;
Error: This expression has type &lt; get : int; set : int -&gt; unit &gt;
       but an expression was expected of type &lt; get : int &gt;
       The second object type has no method set
</programlisting>
    <sidebar>
    <title>
    Elisions are polymorphic
    </title>
    <para>
      The <literal>..</literal> in an object type is an elision,
      standing for &quot;possibly more methods.&quot; It may not be
      apparent from the syntax, but an elided object type is actually
      polymorphic. If we try to write a type definition, we get an
      obscure error.
    </para>
    <programlisting language="ocaml">
# type point = &lt; get:int; .. &gt;;;
Error: A type variable is unbound in this type declaration.
In type &lt; get : int; .. &gt; as 'a the variable 'a is unbound
</programlisting>
    <para>
      A <literal>..</literal> in an object type is called a
      <emphasis>row variable</emphasis> and this typing scheme is called
      <emphasis>row polymorphism</emphasis>. Even though
      <literal>..</literal> doesn't look like a type variable, it
      actually is. The error message suggests a solution, which is to
      add the <literal>as 'a</literal> type constraint.
    </para>
    <programlisting language="ocaml">
# type 'a point = &lt; get:int; .. &gt; as 'a;;
type 'a point = 'a constraint 'a = &lt; get : int; .. &gt;
</programlisting>
    <para>
      In other words, the type <literal>'a point</literal> is equal to
      <literal>'a</literal>, where
      <literal>'a = &lt; get : int; .. &gt;</literal>. That may seem
      like an odd way to say it, and in fact, this type definition is
      not really an abbreviation because <literal>'a</literal> refers to
      the entire type.
    </para>
    </sidebar>
    <para>
      An object of type <literal>&lt; get:int; .. &gt;</literal> can be
      any object with a method <literal>get:int</literal>, it doesn't
      matter how it is implemented. So far, we've constructed two
      objects with that type; the function <literal>make</literal>
      constructed one, and so did <literal>average</literal>. When the
      method <literal>#get</literal> is invoked, the actual method that
      is run is determined by the object.
    </para>
    <programlisting language="ocaml">
# let print_point p = Printf.printf &quot;Point: %d\n&quot; p#get;;
val print_point : &lt; get : int; .. &gt; -&gt; unit = &lt;fun&gt;
# print_point (make 5);;
Point: 5
# print_point (average (make 5) (make 15));;
Point: 10
</programlisting>
  </sect1>
  <sect1 id="classes">
    <title>Classes</title>
    <para>
      Programming with objects directly is great for encapsulation, but
      one of the main goals of object-oriented programming is code
      re-use through inheritance. For inheritance, we need to introduce
      <emphasis>classes</emphasis>. In object-oriented programming, a
      class is a &quot;recipe&quot; for creating objects. The recipe can
      be changed by adding new methods and fields, or it can be changed
      by modifying existing methods.
    </para>
    <para>
      In OCaml, class definitions must be defined as top-level
      statements in a module. A class is not an object, and a class
      definition is not an expression. The syntax for a class definition
      uses the keyword <literal>class</literal>.
    </para>
    <programlisting language="ocaml">
# class point =
  object
    val mutable x = 0
    method get = x
    method set y = x &lt;- y
  end;;
class point :
  object
    val mutable x : int
    method get : int
    method set : int -&gt; unit
  end
</programlisting>
    <para>
      The type <literal>class point : ... end</literal> is a
      <emphasis>class type</emphasis>. This particular type specifies
      that the <literal>point</literal> class defines a mutable field
      <literal>x</literal>, a method <literal>get</literal> that returns
      an <literal>int</literal>, and a method <literal>set</literal>
      with type <literal>int -&gt; unit</literal>.
    </para>
    <para>
      To produce an object, classes are instantiated with the keyword
      <literal>new</literal>.
    </para>
    <programlisting language="ocaml">
# let p = new point;;
val p : point = &lt;obj&gt;
# p#get;;
- : int = 0
# p#set 5;;
- : unit = ()
# p#get;;
- : int = 5
</programlisting>
    <para>
      <emphasis>(yminsky: You say that inheritance uses an existing
      class to define a new one, but the example below looks like using
      an existing class to define a new module. Is that what's going on?
      Or is a new class being created implicitly? If the latter, it
      might be better to be more explicit in this example and name the
      new class.)</emphasis>
    </para>
    <para>
      Inheritance uses an existing class to define a new one. For
      example, the following class definition supports an addition
      method <literal>moveby</literal> that moves the point by a
      relative amount. This also makes use of the
      <literal>(self : 'self)</literal> binding after the
      <literal>object</literal> keyword. The variable
      <literal>self</literal> stands for the current object, allowing
      self-invocation, and the type variable <literal>'self</literal>
      stands for the type of the current object (which in general is a
      subtype of <literal>movable_point</literal>).
    </para>
    <programlisting language="ocaml">
# class movable_point =
  object (self : 'self)
    inherit point
    method moveby dx = self#set (self#get + dx)
  end;;
</programlisting>
  </sect1>
  <sect1 id="class-parameters-and-polymorphism">
    <title>Class parameters and polymorphism</title>
    <para>
      A class definition serves as the <emphasis>constructor</emphasis>
      for the class. In general, a class definition may have parameters
      that must be provided as arguments when the object is created with
      <literal>new</literal>.
    </para>
    <para>
      Let's build an example of an imperative singly-linked list using
      object-oriented techniques. First, we'll want to define a class
      for a single element of the list. We'll call it a
      <literal>node</literal>, and it will hold a value of type
      <literal>'a</literal>. When defining the class, the type
      parameters are placed in square brackets before the class name in
      the class definition. We also need a parameter
      <literal>x</literal> for the initial value.
    </para>
    <programlisting language="ocaml">
class ['a] node x =
object
  val mutable value : 'a = x
  val mutable next_node : 'a node option = None

  method get = value
  method set x = value &lt;- x

  method next = next_node
  method set_next node = next_node &lt;- node
end;;
</programlisting>
    <para>
      The <literal>value</literal> is the value stored in the node, and
      it can be retrieved and changed with the <literal>get</literal>
      and <literal>set</literal> methods. The
      <literal>next_node</literal> field is the link to the next element
      in the stack. Note that the type parameter <literal>['a]</literal>
      in the definition uses square brackets, but other uses of the type
      can omit them (or use parentheses if there is more than one type
      parameter).
    </para>
    <para>
      The type annotations on the <literal>val</literal> declarations
      are used to constrain type inference. If we omit these
      annotations, the type inferred for the class will be &quot;too
      polymorphic,&quot; <literal>x</literal> could have some type
      <literal>'b</literal> and <literal>next_node</literal> some type
      <literal>'c option</literal>.
    </para>
    <programlisting language="ocaml">
  class ['a] node x =
  object
    val mutable value = x
    val mutable next_node = None

    method get = value
    method set x = value &lt;- x

    method next = next_node
    method set_next node = next_node &lt;- node
  end;;
Error: Some type variables are unbound in this type:
         class ['a] node :
           'b -&gt;
           object
             val mutable next_node : 'c option
             val mutable value : 'b
             method get : 'b
             method next : 'c option
             method set : 'b -&gt; unit
             method set_next : 'c option -&gt; unit
           end
       The method get has type 'b where 'b is unbound
</programlisting>
    <para>
      In general, we need to provide enough constraints so that the
      compiler will infer the correct type. We can add type constraints
      to the parameters, to the fields, and to the methods. It is a
      matter of preference how many constraints to add. You can add type
      constraints in all three places, but the extra text may not help
      clarity. A convenient middle ground is to annotate the fields
      and/or class parameters, and add constraints to methods only if
      necessary.
    </para>
    <para>
      Next, we can define the list itself. We'll keep a field
      <literal>head</literal> the refers to the first element in the
      list, and <literal>last</literal> refers to the final element in
      the list. The method <literal>insert</literal> adds an element to
      the end of the list.
    </para>
    <programlisting language="ocaml">
class ['a] slist =
object
   val mutable first : ('a) node option = None
   val mutable last : ('a) node option = None

   method is_empty = first = None

   method insert x =
      let new_node = Some (new node x) in
      match last with
         Some last_node -&gt;
            last_node#set_next new_node;
            last &lt;- new_node
       | None -&gt;
            first &lt;- new_node;
            last &lt;- new_node
end;;
</programlisting>
  </sect1>
  <sect1 id="object-types">
    <title>Object types</title>
    <para>
      This definition of the class <literal>slist</literal> is not
      complete, we can construct lists, but we also need to add the
      ability to traverse the elements in the list. One common style for
      doing this is to define a class for an <literal>iterator</literal>
      object. An iterator provides a generic mechanism to inspect and
      traverse the elements of a collection. This pattern isn't
      restricted to lists, it can be used for many different kinds of
      collections.
    </para>
    <para>
      There are two common styles for defining abstract interfaces like
      this. In Java, an iterator would normally be specified with an
      interface, which specifies a set of method types. In languages
      without interfaces, like C++, the specification would normally use
      <emphasis>abstract</emphasis> classes to specify the methods
      without implementing them (C++ uses the &quot;= 0&quot; definition
      to mean &quot;not implemented&quot;).
    </para>
    <programlisting>
// Java-style iterator, specified as an interface.
interface &lt;T&gt; iterator {
  T Get();
  boolean HasValue();
  void Next();
};

// Abstract class definition in C++.
template&lt;typename T&gt;
class Iterator {
 public:
  virtual ~Iterator() {}
  virtual T get() const = 0;
  virtual bool has_value() const = 0;
  virtual void next() = 0;
};
</programlisting>
    <para>
      OCaml support both styles. In fact, OCaml is more flexible than
      these approaches because an object type can be implemented by any
      object with the appropriate methods, it does not have to be
      specified by the object's class <emphasis>a priori</emphasis>.
      We'll leave abstract classes for later. Let's demonstrate the
      technique using object types.
    </para>
    <para>
      First, we'll define an object type <literal>iterator</literal>
      that specifies the methods in an iterator.
    </para>
    <programlisting language="ocaml">
type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;;;`
</programlisting>
    <para>
      Next, we'll define an actual iterator for the class
      <literal>slist</literal>. We can represent the position in the
      list with a field <literal>current</literal>, following links as
      we traverse the list.
    </para>
    <programlisting language="ocaml">
class ['a] slist_iterator cur =
object
  val mutable current : 'a node option = cur

  method has_value = current &lt;&gt; None

  method get =
     match current with
        Some node -&gt; node#get
      | None -&gt; raise (Invalid_argument &quot;no value&quot;)

  method next =
     match current with
        Some node -&gt; current &lt;- node#next
      | None -&gt; raise (Invalid_argument &quot;no value&quot;)
end;;
</programlisting>
    <para>
      Finally, we add a method <literal>iterator</literal> to the slist
      class to produce an iterator. To do so, we construct an
      <literal>slist_iterator</literal> that refers to the first node in
      the list, but we want to return a value with the object type
      <literal>iterator</literal>. This requires an explicit coercion
      using the <literal>:&gt;</literal> operator.
    </para>
    <programlisting language="ocaml">
class ['a] slist = object
...
   method iterator = (new slist_iterator first :&gt; 'a iterator)
end

# let l = new slist;;
# l.insert 5;;
# l.insert 4;;
# let it = l#iterator;;
# it#get;;
- : int = 5
# it#next;;
- : unit = ()
# it#get;;
- : int = 4
# it#next;;
- : unit = ()
# it#has_value;;
- : bool = false
</programlisting>
    <para>
      We may also wish to define functional-style methods,
      <literal>iter f</literal> takes a function <literal>f</literal>
      and applies it to each of the elements of the list.
    </para>
    <programlisting language="ocaml">
method iter f =
  let it = self#iterator in
  while it#has_value do
    f it#get
    it#next
  end
</programlisting>
    <para>
      What about functional operations similar to
      <literal>List.map</literal> or <literal>List.fold</literal>? In
      general, these methods take a function that produces a value of
      some other type than the elements of the set. For example, the
      function <literal>List.fold</literal> has type
      <literal>'a list -&gt; ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</literal>,
      where <literal>'b</literal> is an arbitrary type. To replicate
      this in the <literal>slist</literal> class, we need a method type
      <literal>('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</literal>, where
      the method type is polymorphic over <literal>'b</literal>.
    </para>
    <para>
      The solution is to use a type quantifier, as shown in the
      following example. The method type must be specified directly
      after the method name, which means that method parameters must be
      expressed using a <literal>fun</literal> or
      <literal>function</literal> expression.
    </para>
    <programlisting language="ocaml">
method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b =
   (fun f x -&gt;
         let y = ref x in
         let it = self#iterator in
         while it#has_value do
            y := f !y it#get;
            it#next
         done;
         !y)
</programlisting>
  </sect1>
  <sect1 id="immutable-objects">
    <title>Immutable objects</title>
    <para>
      Many people consider object-oriented programming to be
      intrinsically imperative, where an object is like a state machine.
      Sending a message to an object causes it to change state,
      possibily sending messages to other objects.
    </para>
    <para>
      Indeed, in many programs, this makes sense, but it is by no means
      required. Let's define an object-oriented version of lists similar
      to the imperative list above. We'll implement it with a regular
      list type <literal>'a list</literal>, and insertion will be to the
      beginning of the list instead of to the end.
    </para>
    <programlisting language="ocaml">
class ['a] flist =
object (self : 'self)
   val elements : 'a list = []

   method is_empty = elements = []

   method insert x : 'self = {&lt; elements = x :: elements &gt;}

   method iterator =
      (new flist_iterator elements :&gt; 'a iterator)

   method iter (f : 'a -&gt; unit) = List.iter f elements

   method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b =
      (fun f x -&gt; List.fold_left f x elements)
end;;
</programlisting>
    <para>
      A key part of the implementation is the definition of the method
      <literal>insert</literal>. The expression
      <literal>{&lt; ... &gt;}</literal> produces a copy of the current
      object, with the same type, and the specified fields updated. In
      other words, the <literal>new_fst new_x</literal> method produces
      a copy of the object, with <literal>x</literal> replaced by
      <literal>new_x</literal>. The original object is not modified, and
      the value of <literal>y</literal> is also unaffected.
    </para>
    <para>
      There are some restriction on the use of the expression
      <literal>{&lt; ... &gt;}</literal>. It can be used only within a
      method body, and only the values of fields may be updated. Method
      implementations are fixed at the time the object is created, they
      cannot be changed dynamically.
    </para>
    <para>
      We use the same object type <literal>iterator</literal> for
      iterators, but implement it differently.
    </para>
    <programlisting language="ocaml">
class ['a] flist_iterator l =
object
   val mutable elements : 'a list = l

   method has_value = l &lt;&gt; []

   method get =
      match l with
         h :: _ -&gt; h
       | [] -&gt; raise (Invalid_argument &quot;list is empty&quot;)

   method next =
      match l with
         _ :: l -&gt; elements &lt;- l
       | [] -&gt; raise (Invalid_argument &quot;list is empty&quot;)
end;;
</programlisting>
  </sect1>
  <sect1 id="class-types">
    <title>Class types</title>
    <para>
      Once we have defined the list implementation, the next step is to
      wrap it in a module or <literal>.ml</literal> file and give it a
      type so that it can be used in the rest of our code. What is the
      type?
    </para>
    <para>
      Before we begin, let's wrap up the implementation in an explicit
      module (we'll use explicit modules for illustration, but the
      process is similar when we want to define a
      <literal>.mli</literal> file). In keeping with the usual style for
      modules, we define a type <literal>'a t</literal> to represent the
      type of list values.
    </para>
    <programlisting language="ocaml">
module SList = struct
   type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;
   type 'a t = &lt; is_empty : bool; insert : 'a -&gt; unit; iterator : 'a iterator &gt;

   class ['a] node x = object ... end
   class ['a] slist_iterator cur = object ... end
   class ['a] slist = object ... end

   let make () = new slist
end;;
</programlisting>
    <para>
      We have multiple choices in definining the module type, depending
      on how much of the implementation we want to expose. At one
      extreme, a maximally-abstract signature would completely hide the
      class definitions.
    </para>
    <programlisting language="ocaml">
module AbstractSList : sig
   type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;
   type 'a t = &lt; is_empty : bool; insert : 'a -&gt; unit; iterator : 'a iterator &gt;

   val make : unit -&gt; 'a t
end = SList
</programlisting>
    <para>
      The abstract signature is simple because we ignore the classes.
      But what if we want to include them in the signature, so that
      other modules can inherit from the class definitions? For this, we
      need to specify types for the classes, called <emphasis>class
      types</emphasis>. Class types do not appear in mainstream
      object-oriented programming languages, so you may not be familiar
      with them, but the concept is pretty simple. A class type
      specifies the type of each of the visible parts of the class,
      including both fields and methods. Just like for module types, you
      don't have to give a type for everything; anything you omit will
      be hidden.
    </para>
    <programlisting language="ocaml">
module VisibleSList : sig
  type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;
  type 'a t = &lt; is_empty : bool; insert : 'a -&gt; unit; iterator : 'a iterator &gt;

  class ['a] node : 'a -&gt;
  object
     method get : 'a
     method set : 'a -&gt; unit
     method next : 'a node option
     method set_next : 'a node option -&gt; unit
  end

  class ['a] slist_iterator : 'a node option -&gt;
  object
     method has_value : bool
     method get : 'a
     method next : unit
  end

  class ['a] slist :
  object
    val mutable first : 'a node option
    val mutable last : 'a node option
    method is_empty : bool
    method insert : 'a -&gt; unit
    method iterator : 'a iterator
  end

  val make : unit -&gt; 'a slist
end = SList
</programlisting>
    <para>
      In this signature, we've chosen to make nearly everything visible.
      The class type for <literal>slist</literal> specifies the types of
      the fields <literal>first</literal> and <literal>last</literal>,
      as well ad the types of each of the methods. We've also included a
      class type for <literal>slist_iterator</literal>, which is of
      somewhat more questionable value, since the type doesn't appear in
      the type for <literal>slist</literal> at all.
    </para>
    <para>
      One more thing, in this example the function
      <literal>make</literal> has type
      <literal>unit -&gt; 'a slist</literal>. But wait, we've stressed
      <emphasis>classes are not types</emphasis>, so what's up with
      that? In fact, what we've said is entirely true, classes and class
      names <emphasis>are not</emphasis> types. However, class names can
      be used to stand for types. When the compiler sees a class name in
      type position, it automatically constructs an object type from it
      by erasing all the fields and keeping only the method types. In
      this case, the type expression <literal>'a slist</literal> is
      exactly equivalent to <literal>'a t</literal>.
    </para>
  </sect1>
  <sect1 id="subtyping">
    <title>Subtyping</title>
    <para>
      Subtyping is a central concept in object-oriented programming. It
      governs when an object with one type <emphasis>A</emphasis> can be
      used in an expression that expects an object of another type
      <emphasis>B</emphasis>. When this is true, we say that
      <emphasis>A</emphasis> is a <emphasis>subtype</emphasis> of
      <emphasis>B</emphasis>. Actually, more concretely, subtyping
      determines when the coercion operator <literal>e :&gt; t</literal>
      can be applied. This coercion works only if the expression
      <literal>e</literal> has some type <literal>s</literal> and
      <literal>s</literal> is a subtype of <literal>t</literal>.
    </para>
    <para>
      To explore this, let's define some simple classes for geometric
      shapes. The generic type <literal>shape</literal> has a method to
      compute the area, and a <literal>square</literal> is a specific
      kind of shape.
    </para>
    <programlisting language="ocaml">
type shape = &lt; area : float &gt;;;

class square w =
object (self : 'self)
  method area = self#width *. self#width
  method width = w
end;;
</programlisting>
    <para>
      A <literal>square</literal> has a method <literal>area</literal>
      just like a <literal>shape</literal>, and an additional method
      <literal>width</literal>. Still, we expect a
      <literal>square</literal> to be a <literal>shape</literal>, and it
      is. The coercion <literal>:&gt;</literal> must be explicit.
    </para>
    <programlisting language="ocaml">
# let new_square x : shape = new square x;;
Characters 27-39:
  let new_square x : shape = new square x;;
                             ^^^^^^^^^^^^
Error: This expression has type square but an expression was expected of type shape
The second object type has no method width
# let new_square x : shape = (new square x :&gt; shape);;
val new_square : float -&gt; shape = &lt;fun&gt;
</programlisting>
    <para>
      What are the rules for subtyping? In general, object subtyping has
      two general forms, called <emphasis>width</emphasis> and
      <emphasis>depth</emphasis> subtyping. Width subtyping means that
      an object type <emphasis>A</emphasis> is a a subtype of
      <emphasis>B</emphasis>, if <emphasis>A</emphasis> has all of the
      methods of <emphasis>B</emphasis>, and possibly more. A
      <literal>square</literal> is a subtype of <literal>shape</literal>
      because it implements all of the methods of
      <literal>shape</literal> (the <literal>area</literal> method).
    </para>
    <para>
      The subtyping rules are purely technical, they have no relation to
      object semantics. We can define a class
      <literal>rectangle</literal> that has all of the methods of a
      <literal>square</literal>, so it is a subtype of square and can be
      used wherever a <literal>square</literal> is expected.
    </para>
    <programlisting language="ocaml">
# class rectangle h w =
  object (self : 'self)
     inherit square w
     method area = self#width *. self#height
     method height = h
  end;;
# let square_rectangle h w : square = (new rectangle h w :&gt; square);;
val square_rectangle : float -&gt; float -&gt; square = &lt;fun&gt;
</programlisting>
    <para>
      This may seem absurd, but this concept is expressible in all
      object-oriented languages. The contradiction is semantic -- we
      know that in the real world, not all rectangles are squares; but
      in the programming world, rectangles have all of the features of
      squares (according to our definition), so they can be used just
      like squares. Suffice it to say that it is usually better to avoid
      such apparent contradictions.
    </para>
    <para>
      Next, let's take a seemingly tiny step forward, and start building
      collections of shapes. It is easy enough to define a
      <literal>slist</literal> of squares.
    </para>
    <programlisting language="ocaml">
# let squares =
     let l = SList.make () in
     l#insert (new square 1.0);
     l#insert (new square 2.0);
     l;;
val squares : square slist = &lt;obj&gt;
</programlisting>
    <para>
      We can also define a function to calculate the total area of a
      list of shapes. There is no reason to restrict this to squares, it
      should work for any list of shapes with type
      <literal>shape slist</literal>. The problem is that doing so
      raises some serious typing questions -- can a
      <literal>square slist</literal> be passed to a function that
      expects a <literal>shape slist</literal>? If we try it, the
      compiler produces a verbose error message.
    </para>
    <programlisting language="ocaml">
# let total_area (l : shape slist) : float =
     let total = ref 0.0 in
     let it = l#iterator in
     while it#has_value do
        total := !total +. it#get#area;
        it#next
     done;
     !total;;
val total_area : shape slist -&gt; float = &lt;fun&gt;
# total_area squares;;
Characters 11-18:
  total_area squares;;
             ^^^^^^^
Error: This expression has type
         square slist =
           &lt; insert : square -&gt; unit; is_empty : bool;
             iterator : square iterator &gt;
       but an expression was expected of type
         shape slist =
           &lt; insert : shape -&gt; unit; is_empty : bool;
             iterator : shape iterator &gt;
       Type square = &lt; area : float; width : float &gt;
       is not compatible with type shape = &lt; area : float &gt; 
       The second object type has no method width
</programlisting>
    <para>
      It might seem tempting to give up at this point, especially
      because the subtyping is not even true -- the type
      <literal>square slist</literal> is not a subtype of
      <literal>shape slist</literal>. The problem is with the
      <literal>insert</literal> method. For
      <literal>shape slist</literal>, the <literal>insert</literal>
      method takes an arbitrary <literal>shape</literal> and inserts it
      into the list. So if we could coerce a
      <literal>square slist</literal> to a
      <literal>shape slist</literal>, then it would be possible to
      insert an arbitrary shape into the list, which would be an error.
    </para>
    <sect2 id="using-more-precise-types-to-address-subtyping-problems">
      <title>Using more precise types to address subtyping
      problems</title>
      <para>
        Still, the <literal>total_area</literal> function should be
        fine, in principle. It doesn't call <literal>insert</literal>,
        so it isn't making that error. To make it work, we need to use a
        more precise type that indicates we are not going to be mutating
        the list. We define a type
        <literal>readonly_shape_slist</literal> and confirm that we can
        coerce the list of squares.
      </para>
      <programlisting language="ocaml">
# type readonly_shape_slist = &lt; iterator : shape iterator &gt;;;
type readonly_shape_slist = &lt; iterator : shape iterator &gt;
# (squares :&gt; readonly_shape_slist);;
- : readonly_shape_slist = &lt;obj&gt;
# let total_area (l : readonly_shape_slist) : float = ...;;
val total_area : readonly_shape_slist -&gt; float = &lt;fun&gt;
#   total_area (squares :&gt; readonly_shape_slist);;
- : float = 5.
</programlisting>
      <para>
        Why does this work, why is a <literal>square slist</literal> a
        subtype of <literal>readonly_shape_slist</literal>. The
        reasoning is in two steps. First, the easy part is width
        subtyping: we can drop the other methods to see that
        <literal>square slist</literal> is a subtype of
        <literal>&lt; iterator : square iterator &gt;</literal>. The
        next step is to use <emphasis>depth</emphasis> subtyping, which,
        in its general form, says that an object type
        <literal>&lt; m : t1 &gt;</literal> is a subtype of a type
        <literal>&lt; m : t2&gt;</literal> iff <literal>t1</literal> is
        a subtype of <literal>t2</literal>. In other words, instead of
        reasoning about the number of methods in a type (the width), the
        number of methods is fixed, and we look within the method types
        themselves (the &quot;depth&quot;).
      </para>
      <para>
        In this particular case, depth subtyping on the
        <literal>iterator</literal> method requires that
        <literal>square iterator</literal> be a subtype of
        <literal>shape iterator</literal>. Expanding the type definition
        for the type <literal>iterator</literal>, we again invoke depth
        subtyping, and we need to show that the type
        <literal>&lt; get : square &gt;</literal> is a subtype of
        <literal>&lt;get : shape &gt;</literal>, which follows because
        <literal>square</literal> is a subtype of
        <literal>shape</literal>.
      </para>
      <para>
        This reasoning may seem fairly long and complicated, but it
        should be pointed out that this typing
        <emphasis>works</emphasis>, and in the end the type annotations
        are fairly minor. In most typed object-oriented languages, the
        coercion would simply not be possible. For example, in C++, a
        STL type <literal>slist&lt;T&gt;</literal> is invariant in
        <literal>T</literal>, it is simply not possible to use
        <literal>slist&lt;square&gt;</literal> where
        <literal>slist&lt;shape&gt;</literal> is expected (at least
        safely). The situation is similar in Java, although Java
        supports has an escape hatch that allows the program to fall
        back to dynamic typing. The situation in OCaml is much better;
        it works, it is statically checked, and the annotations are
        pretty simple.
      </para>
    </sect2>
    <sect2 id="using-elided-types-to-address-subtyping-problems">
      <title>Using elided types to address subtyping problems</title>
      <para>
        Before we move to the next topic, there is one more thing to
        address. The typing we gave above, using
        <literal>readonly_shape_slist</literal>, requires that the
        caller perform an explicit coercion before calling the
        <literal>total_area</literal> function. We would like to give a
        better type that avoids the coercion.
      </para>
      <para>
        A solution is to use an elided type. Instead of
        <literal>shape</literal>, we can use the elided type
        <literal>&lt; area : float; .. &gt;</literal>. In fact, once we
        do this, it also becomes possible to use the
        <literal>slist</literal> type.
      </para>
      <programlisting language="ocaml">
# let total_area (l : &lt; area : float; .. &gt; slist) : float = ...;;
val total_area : &lt; area : float; .. &gt; slist -&gt; float = &lt;fun&gt;
# total_area squares;;
- : float = 5.
</programlisting>
      <para>
        This works, and it removes the need for explicit coercions. This
        type is still fairly simple, but it does have the drawback that
        the programmer needs to remember that the types
        <literal>&lt; area : float; ..&gt;</literal> and
        <literal>shape</literal> are related.
      </para>
      <para>
        OCaml supports an abbreviation in this case, but it works only
        for classes, not object types. The type expression
        <literal># classname</literal> is an abbreviation for an elided
        type containing all of the methods in the named class, and more.
        Since <literal>shape</literal> is an object type, we can't write
        <literal>#shape</literal>. However, if a class definition is
        available, this abbreviation can be useful. The following
        definition is exactly equivalent to the preceeding.
      </para>
      <programlisting language="ocaml">
# class cshape = object method area = 0.0 end;;
class cshape : object method area : float end
# let total_area (l : #cshape list) : float = ...;;
val total_area : #cshape slist -&gt; float = &lt;fun&gt;
# total_area squares;;
- : float = 5.
</programlisting>
    </sect2>
    <sect2 id="narrowing">
      <title>Narrowing</title>
      <para>
        Narrowing, also called <emphasis>down casting</emphasis>, is the
        ability to coerce an object to one of its subtypes. For example,
        if we have a list of shapes <literal>shape slist</literal>, we
        might know (for some reason) what the actual type of each shape
        is. Perhaps we know that all objects in the list have type
        <literal>square</literal>. In this case,
        <emphasis>narrowing</emphasis> would allow the re-casting of the
        object from type <literal>shape</literal> to type
        <literal>square</literal>. Many languages support narrowing
        through dynamic type checking. For example, in Java, a coercion
        <literal>(Square) x</literal> is allowed if the value
        <literal>x</literal> has type <literal>Square</literal> or one
        of its subtypes; otherwise the coercion throws an exception.
      </para>
      <para>
        Narrowing is <emphasis>not permitted</emphasis> in OCaml.
        Period.
      </para>
      <para>
        Why? There are two reasonable explanations, one based on a
        design principle, and another technical (the technical reason is
        simple: it is hard to implement).
      </para>
      <para>
        The design argument is this: narrowing violates abstraction. In
        fact, with a structural typing system like in OCaml, narrowing
        would essentially provide the ability to enumerate the methods
        in an object. To check whether an object <literal>obj</literal>
        has some method <literal>foo : int</literal>, one would attempt
        a coercion <literal>(obj :&gt; &lt; foo : int &gt;)</literal>.
      </para>
      <para>
        More commonly, narrowing leads to poor object-oriented style.
        Consider the following Java code, which returns the name of a
        shape object.
      </para>
      <programlisting>
String GetShapeName(Shape s) {
  if (s instanceof Square) {
    return &quot;Square&quot;;
  } else if (s instanceof Circle) {
    return &quot;Circle&quot;;
  } else {
    return &quot;Other&quot;;
  }
}
</programlisting>
      <para>
        Most programmers would consider this code to be
        &quot;wrong.&quot; Instead of performing a case analysis on the
        type of object, it would be better to define a method to return
        the name of the shape. Instead of calling
        <literal>GetShapeName(s)</literal>, we should call
        <literal>s.Name()</literal> instead.
      </para>
      <para>
        However, the situation is not always so obvious. The following
        code checks whether an array of shapes looks like a
        &quot;barbell,&quot; composed to two <literal>Circle</literal>
        objects separated by a <literal>Line</literal>, where the
        circles have the same radius.
      </para>
      <programlisting>
boolean IsBarBell(Shape[] s) {
  return s.length == 3 &amp;&amp; (s[0] instanceof Circle) &amp;&amp;
    (s[1] instanceof Line) &amp;&amp; (s[2] instanceof Circle) &amp;&amp;
    ((Circle) s[0]).radius() == ((Circle) s[2]).radius();
}
</programlisting>
      <para>
        In this case, it is much less clear how to augment the
        <literal>Shape</literal> class to support this kind of pattern
        analysis. It is also not obvious that object-oriented
        programming is well-suited for this situation. Pattern matching
        seems like a better fit.
      </para>
      <programlisting language="ocaml">
let is_bar_bell = function
 | [Circle r1; Line _; Circle r2] when r1 == r2 -&gt; true
 | _ -&gt; false;;
</programlisting>
      <para>
        Regardless, there is a solution if you find yourself in this
        situation, which is to augment the classes with variants. You
        can define a method <literal>variant</literal> that injects the
        actual object into a variant type.
      </para>
      <programlisting language="ocaml">
type shape = &lt; variant : repr; area : float&gt;
and circle = &lt; variant : repr; area : float; radius : float &gt;
and line = &lt; variant : repr; area : float; length : float &gt;
and repr =
 | Circle of circle
 | Line of line;;

let is_bar_bell = function
 | [s1; s2; s3] -&gt;
   (match s1#variant, s2#variant, s3#variant with
     | Circle c1, Line _, Circle c2 when c1#radius == c2#radius -&gt; true
     | _ -&gt; false)
 | _ -&gt; false;;
</programlisting>
      <para>
        This pattern works, but it has drawbacks. In particular, the
        recursive type definition should make it clear that this pattern
        is essentially equivalent to using variants, and that objects do
        not provide much value here.
      </para>
    </sect2>
    <sect2 id="binary-methods">
      <title>Binary methods</title>
      <para>
        A <emphasis>binary method</emphasis> is a method that takes an
        object of <literal>self</literal> type. One common example is
        defining a method for equality.
      </para>
      <programlisting language="ocaml">
# class square w =
  object (self : 'self) 
    method width = w
    method area = self#width * self#width
    method equals (other : 'self) = other#width = self#width
  end;;
class square : int -&gt;
  object ('a)
    method area : int
    method equals : 'a -&gt; bool
    method width : int
  end
# class rectangle w h =
  object (self : 'self)
    method width = w
    method height = h
    method area = self#width * self#height
    method equals (other : 'self) = other#width = self#width &amp;&amp; other#height = self#height
  end;;
...
# (new square 5)#equals (new square 5);;
- : bool = true
# (new rectangle 5 6)#equals (new rectangle 5 7);;
- : bool = false
</programlisting>
      <para>
        This works, but there is a problem lurking here. The method
        <literal>equals</literal> takes an object of the exact type
        <literal>square</literal> or <literal>rectangle</literal>.
        Because of this, we can't define a common base class
        <literal>shape</literal> that also includes an equality method.
      </para>
      <programlisting language="ocaml">
# type shape = &lt; equals : shape -&gt; bool; area : int &gt;;;
# let sq = new square 5;;
# (sq :&gt; shape);;
Characters 0-13:
  (sq :&gt; shape);;
  ^^^^^^^^^^^^^
Error: Type square = &lt; area : int; equals : square -&gt; bool; width : int &gt;
       is not a subtype of shape = &lt; area : int; equals : shape -&gt; bool &gt; 
Type shape = &lt; area : int; equals : shape -&gt; bool &gt; is not a subtype of
  square = &lt; area : int; equals : square -&gt; bool; width : int &gt; 
</programlisting>
      <para>
        The problem is that a <literal>square</literal> expects to be
        compared with a <literal>square</literal>, not an arbitrary
        shape; similarly for <literal>rectangle</literal>.
      </para>
      <para>
        This problem is fundamental. Many languages solve it either with
        narrowing (with dynamic type checking), or by method
        overloading. Since OCaml has neither of these, what can we do?
      </para>
      <para>
        One proposal we could consider is, since the problematic method
        is equality, why not just drop it from the base type
        <literal>shape</literal> and use polymorphic equality instead?
        Unfortunately, the builtin equality has very poor behavior when
        applied to objects.
      </para>
      <programlisting language="ocaml">
# (object method area = 5 end) = (object method area = 5 end);;
- : bool = false
</programlisting>
      <para>
        The problem here is that the builtin polymorphic equality
        compares the method implementations, not their return values.
        The method implementations (the function values that implement
        the methods) are different, so the equality comparison is false.
        There are other reasons not to use the builtin polymorphic
        equality, but these false negatives are a showstopper.
      </para>
      <para>
        If we want to define equality for shapes in general, the
        remaining solution is to use the same approach as we described
        for narrowing. That is, introduce a
        <emphasis>representation</emphasis> type implemented using
        variants, and implement the comparison based on the
        representation type.
      </para>
      <programlisting language="ocaml">
type shape_repr =
 | Square of int
 | Circle of int
 | Rectangle of int * int;;

type shape = &lt; repr : shape_repr; equals : shape -&gt; bool; area : int &gt;;;

class square w =
object (self : 'self)
  method width = w
  method area = self#width * self#width
  method repr = Square self#width
  method equals (other : shape) = self#repr = other#repr
end;;
</programlisting>
      <para>
        The binary method <literal>equals</literal> is now implemented
        in terms of the concrete type <literal>shape_repr</literal>. In
        fact, the objects are now isomorphic to the
        <literal>shape_repr</literal> type. When using this pattern, you
        will not be able to hide the <literal>repr</literal> method, but
        you can hide the type definition using the module system.
      </para>
      <programlisting language="ocaml">
module Shapes : sig
  type shape_repr
  type shape = &lt; repr : shape_repr; equals : shape -&gt; bool; area -&gt; int &gt;

  class square : int -&gt;
    object
      method width : int
      method area : int
      method repr : shape_repr
      method equals : shape -&gt; bool
    end
end = struct
  type shape_repr = Square of int | Circle of int | Rectangle of int * int
  ...
end;;
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="private-methods">
    <title>Private methods</title>
    <para>
      Methods can be declared <emphasis>private</emphasis>, which means
      that they may be called by subclasses, but they are not visible
      otherwise (similar to a <emphasis>protected</emphasis> method in
      C++).
    </para>
    <para>
      To illustrate, let's build a class <literal>vector</literal> that
      contains an array of integers, resizing the storage array on
      demand. The field <literal>values</literal> contains the actual
      values, and the <literal>get</literal>, <literal>set</literal>,
      and <literal>length</literal> methods implement the array access.
      For clarity, the resizing operation is implemented as a private
      method <literal>ensure_capacity</literal> that resizes the array
      if necessary.
    </para>
    <programlisting language="ocaml">
# class vector =
  object (self : 'self)
     val mutable values : int array = [||]

     method get i = values.(i)
     method set i x =
        self#ensure_capacity i;
        values.(i) &lt;- x
     method length = Array.length values

     method private ensure_capacity i =
        if self#length &lt;= i then
           let new_values = Array.create (i + 1) 0 in
           Array.blit values 0 new_values 0 (Array.length values);
           values &lt;- new_values
  end;;
# let v = new vector;;
# v#set 5 2;;
# v#get 5;;
- 2 : int
# v#ensure_capacity 10;;
Characters 0-1:
  v#ensure_capacity 10;;
  ^
Error: This expression has type vector
       It has no method ensure_capacity
</programlisting>
    <para>
      To be precise, the method <literal>ensure_capacity</literal> is
      part of the class type, but it is not part of the object type.
      This means the object <literal>v</literal> has no method
      <literal>ensure_capacity</literal>. However, it is available to
      subclasses. We can extend the class, for example, to include a
      method <literal>swap</literal> that swaps two elements.
    </para>
    <programlisting language="ocaml">
# class swappable_vector =
  object (self : 'self)
     inherit vector

     method swap i j =
        self#ensure_capacity (max i j);
        let tmp = values.(i) in
        values.(i) &lt;- values.(j);
        values.(j) &lt;- tmp
  end;;
</programlisting>
    <para>
      Yet another reason for private methods is to factor the
      implementation and support recursion. Moving along with this
      example, let's build a binary heap, which is a binary tree in heap
      order: where the label of parent elements is smaller than the
      labels of its children. One efficient implementation is to use an
      array to represent the values, where the root is at index 0, and
      the children of a parent node at index <literal>i</literal> are at
      indexes <literal>2 * i</literal> and <literal>2 * i + 1</literal>.
      To insert a node into the tree, we add it as a leaf, and then
      recursively move it up the tree until we restore heap order.
    </para>
    <programlisting language="ocaml">
class binary_heap =
object (self : 'self)
   val values = new swappable_vector

   method min =
      if values#length = 0 then
         raise (Invalid_argument &quot;heap is empty&quot;);
      values#get 0

   method add x =
      let pos = values#length in
      values#set pos x;
      self#move_up pos

   method private move_up i =
      if i &gt; 0 then
         let parent = (i - 1) / 2 in
            if values#get i &lt; values#get parent then begin
               values#swap i parent;
               self#move_up parent
            end
end;;
</programlisting>
    <para>
      The method <literal>move_up</literal> implements the process of
      restoring heap order as a recursive method (though it would be
      straightforward avoid the recursion and use iteration here).
    </para>
    <para>
      The key property of private methods is that they are visible to
      subclasses, but not anywhere else. If you want the stronger
      guarantee that a method is <emphasis>really</emphasis> private,
      not even accessible in subclasses, you can use an explicit typing
      that omits the method. In the following code, the
      <literal>move_up</literal> method is explicitly omitted from the
      object type, and it can't be invoked in subclasses.
    </para>
    <programlisting language="ocaml">
# class binary_heap :
  object
    method min : int
    method add : int -&gt; unit
  end =
  object (self : 'self) {
    ...
    method private move_up i = ...
  end;;
</programlisting>
  </sect1>
  <sect1 id="virtual-classes-and-methods">
    <title>Virtual classes and methods</title>
    <para>
      A <emphasis>virtual</emphasis> class is a class where some methods
      or fields are declared, but not implemented. This should not be
      confused with the word &quot;virtual&quot; as it is used in C++.
      In C++, a &quot;virtual&quot; method uses dynamic dispatch,
      regular non-virtual methods use static dispatched. In OCaml,
      <emphasis>all</emphasis> methods use dynamic dispatch, but the
      keyword <emphasis>virtual</emphasis> means the method or field is
      not implemented.
    </para>
    <para>
      In the previous section, we defined a class
      <literal>swappable_vector</literal> that inherits from
      <literal>array_vector</literal> and adds a <literal>swap</literal>
      method. In fact, the <literal>swap</literal> method could be
      defined for any object with <literal>get</literal> and
      <literal>set</literal> methods; it doesn't have to be the specific
      class <literal>array_vector</literal>.
    </para>
    <para>
      One way to do this is to declare the
      <literal>swappable_vector</literal> abstractly, declaring the
      methods <literal>get</literal> and <literal>set</literal>, but
      leaving the implementation for later. However, the
      <literal>swap</literal> method can be defined immediately.
    </para>
    <programlisting language="ocaml">
class virtual abstract_swappable_vector =
object (self : 'self)
   method virtual get : int -&gt; int
   method virtual set : int -&gt; int -&gt; unit
   method swap i j =
      let tmp = self#get i in
      self#set i (self#get j);
      self#set j tmp
end;;
</programlisting>
    <para>
      At some future time, we may settle on a concrete implementation
      for the vector. We can inherit from the
      <literal>abstract_swappable_bvector</literal> to get the
      <literal>swap</literal> method &quot;for free.&quot; Here's one
      implementation using arrays.
    </para>
    <programlisting language="ocaml">
class array_vector =
object (self : 'self)
   inherit abstract_swappable_vector

   val mutable values = [||]
   method get i = values.(i)
   method set i x =
      self#ensure_capacity i;
      values.(i) &lt;- x
   method length = Array.length values

   method private ensure_capacity i =
      if self#length &lt;= i then
         let new_values = Array.create (i + 1) 0 in
            Array.blit values 0 new_values 0 (Array.length values);
            values &lt;- new_values
end
</programlisting>
    <para>
      Here's a different implementation using
      <literal>HashTbl</literal>.
    </para>
    <programlisting language="ocaml">
class hash_vector =
object (self : 'self)
   inherit abstract_swappable_vector

   val table = Hashtbl.create 19

   method get i =
      try Hashtbl.find table i with
         Not_found -&gt; 0

   method set = Hashtbl.add table
end;;
</programlisting>
    <para>
      One way to view a <literal>virtual</literal> class is that it is
      like a functor, where the &quot;inputs&quot; are the declared, but
      not defined, virtual methods and fields. The functor application
      is implemented through inheritance, when virtual methods are given
      concrete implementations.
    </para>
    <para>
      We've been mentioning that fields can be virtual too. Here is
      another implementation of the swapper, this time with direct
      access to the array of values.
    </para>
    <programlisting language="ocaml">
class virtual abstract_swappable_array_vector =
object (self : 'self)
   val mutable virtual values : int array
   method private virtual ensure_capacity : int -&gt; unit

   method swap i j =
      self#ensure_capacity (max i j);
      let tmp = values.(i) in
      values.(i) &lt;- values.(j);
      values.(j) &lt;- tmp
end;;
</programlisting>
    <para>
      This level of dependency on the implementation details is
      possible, but it is hard to justify the use of a virtual class --
      why not just define the <literal>swap</literal> method as part of
      the concrete class? Virtual classes are better suited for
      situations where there are multiple (useful) implementations of
      the virtual parts. In most cases, this will be public virtual
      methods.
    </para>
  </sect1>
  <sect1 id="multiple-inheritance">
    <title>Multiple inheritance</title>
    <para>
      When a class inherits from more than one superclass, it is using
      <emphasis>multiple inheritance</emphasis>. Multiple inheritance
      extends the variety of ways in which classes can be combined, and
      it can be quite useful, particularly with virtual classes.
      However, it can be tricky to use, particularly when the
      inheritance hierarchy is a graph rather than a tree, so it should
      be used with care.
    </para>
    <sect2 id="how-names-are-resolved">
      <title>How names are resolved</title>
      <para>
        The main &quot;trickiness&quot; of multiple inheritance is due
        to naming -- what happens when a method or field with some name
        is defined in more than one class?
      </para>
      <para>
        If there is one thing to remember about inheritance in OCaml, it
        is this: inheritance is like textual inclusion. If there is more
        than one definition for a name, the last definition wins. Let's
        look at some artificial, but illustrative, examples.
      </para>
      <para>
        First, let's consider what happens when we define a method more
        than once. In the following example, the method
        <literal>get</literal> is defined twice; the second definition
        &quot;wins,&quot; meaning that it overrides the first one.
      </para>
      <programlisting language="ocaml">
# class m1 =
object (self : 'self)
   method get = 1
   method f = self#get
   method get = 2
end;;
class m1 : object method f : int method get : int end
# (new m1)#f;;
- : int = 2
</programlisting>
      <para>
        Fields have similar behavior, though the compiler produces a
        warning message about the override.
      </para>
      <programlisting language="ocaml">
# class m2 =
# class m2 =
  object (self : 'self)
     val x = 1
     method f = x
     val x = 2
  end;;
Characters 69-74:
     val x = 2
         ^^^^^
Warning 13: the instance variable x is overridden.
The behaviour changed in ocaml 3.10 (previous behaviour was hiding.)
class m2 : object val x : int method f : int end
# (new m2)#f;;
- : int = 2
</programlisting>
      <para>
        Of course, it is unlikely that you will define two methods or
        two fields of the same name in the same class. However, the
        rules for inheritance follow the same pattern: the last
        definition wins. In the following definition, the
        <literal>inherit</literal> declaration comes last, so the method
        definition <literal>method get = 2</literal> overrides the
        previous definition, always returning 2.
      </para>
      <programlisting language="ocaml">
# class m4 = object method get = 2 end;;
# class m5 =
  object
    val mutable x = 1
    method get = x
    method set x' = x &lt;- x'
    inherit m4
  end;;
class m5 : object val mutable x : int method get : int method set : int -&gt; unit end
# let x = new m5;;
val x : m5 = &lt;obj&gt;
# x#set 5;;
- : unit = ()
# x#get;;
- : int = 2
</programlisting>
      <para>
        To reiterate, to understand what inheritance means, replace each
        <literal>inherit</literal> directive with its definition, and
        take the last definition of each method or field. This holds
        even for private methods. However, it does
        <emphasis>not</emphasis> hold for private methods that are
        &quot;really&quot; private, meaning that they have been hidden
        by a type constraint. In the following definitions, there are
        three definitions of the private method <literal>g</literal>.
        However, the definition of <literal>g</literal> in
        <literal>m8</literal> is not overridden, because it is not part
        of the class type for <literal>m8</literal>.
      </para>
      <programlisting language="ocaml">
# class m6 =
  object (self : 'self)
     method f1 = self#g
     method private g = 1
  end;;
class m6 : object method f1 : int method private g : int end
# class m7 =
  object (self : 'self)
     method f2 = self#g
     method private g = 2
  end;;
class m7 : object method f2 : int method private g : int end
# class m8 : object method f3 : int end =
  object (self : 'self)
     method f3 = self#g
     method private g = 3
  end;;
class m8 : object method f3 : int end
# class m9 =
  object (self : 'self)
     inherit m6
     inherit m7
     inherit m8
  end;;
# class m9 :
  object
    method f1 : int
    method f2 : int
    method f3 : int
    method private g : int
  end
# let x = new m9;;
val x : m9 = &lt;obj&gt;
# x#f1;;
- : int = 2
# x#f3;;
- : int = 3
</programlisting>
    </sect2>
    <sect2 id="mixins">
      <title>Mixins</title>
      <para>
        When should you use multiple inheritance? If you ask multiple
        people, you're likely to get multiple (perhaps heated) answers.
        Some will argue that multiple inheritance is overly complicated;
        others will argue that inheritance is problematic in general,
        and one should use object composition instead. But regardless of
        who you talk to, you will rarely hear that multiple inheritance
        is great and you should use it widely.
      </para>
      <para>
        In any case, if you're programming with objects, there's one
        general pattern for multiple inheritance that is both useful and
        reasonably simple, the <emphasis>mixin</emphasis> pattern.
        Generically, a <emphasis>mixin</emphasis> is just a virtual
        class that implements a feature based on another one. If you
        have a class that implements methods <emphasis>A</emphasis>, and
        you have a mixin <emphasis>M</emphasis> that provides methods
        <emphasis>B</emphasis> from <emphasis>A</emphasis>, then you can
        inherit from <emphasis>M</emphasis> -- &quot;mixing&quot; it in
        -- to get features <emphasis>B</emphasis>.
      </para>
      <para>
        That's too abstract, so let's give an example based on
        collections. In Section XXX:Objecttypes, we introduced the
        <emphasis>iterator</emphasis> pattern, where an
        <emphasis>iterator</emphasis> object is used to enumerate the
        elements of a collection. Lots of containers can have iterators,
        singly-linked lists, dictionaries, vectors, etc.
      </para>
      <programlisting language="ocaml">
type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;;;
class ['a] slist : object ... method iterator : 'a iterator end;;
class ['a] vector : object ... method iterator : 'a iterator end;;
class ['a] deque : object ... method iterator : 'a iterator end;;
class ['a, 'b] map : object ... method iterator : 'b iterator end;;
...
</programlisting>
      <para>
        The collections are different is some ways, but they share a
        common pattern for iteration that we can re-use. For a simple
        example, let's define a mixin that implements an arithmetic sum
        for a collection of integers.
      </para>
      <programlisting language="ocaml">
# class virtual int_sum_mixin =
  object (self : 'self)
     method virtual iterator : int iterator
     method sum =
        let it = self#iterator in
        let total = ref 0 in
        while it#has_value do
           total := !total + it#get;
           it#next
        done;
        !total
  end;;
# class int_slist =
  object
     inherit [int] slist
     inherit int_sum_mixin
  end;;
# let l = new int_slist;;
val l : int_slist = &lt;obj&gt;
# l#insert 5;;
# l#insert 12;;
# l#sum;;
- : int = 17
# class int_deque =
  object
     inherit [int] deque
     inherit int_sum_mixin
  end;;
</programlisting>
      <para>
        In this particular case, the mixin works only for a collection
        of integers, so we can't add the mixin to the polymorphic class
        definition <literal>['a] slist</literal> itself. However, the
        result of using the mixin is that the integer collection has a
        method <literal>sum</literal>, and it is done with very little
        of the fuss we would need if we used object composition instead.
      </para>
      <para>
        The mixin pattern isn't limited to non-polymorphic classes, of
        course. We can use it to implement generic features as well. The
        following mixin defines functional-style iteration in terms of
        the imperative iterator pattern.
      </para>
      <programlisting language="ocaml">
class virtual ['a] fold_mixin =
object (self : 'self)
   method virtual iterator : 'a iterator
   method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b =
      (fun f x -&gt;
            let y = ref x in
            let it = self#iterator in
            while it#has_value do
               y := f !y it#get;
               it#next
            done;
            !y)
end;;

class ['a] slist_with_fold =
object
   inherit ['a] slist
   inherit ['a] fold_mixin
end;;
</programlisting>
      <tip>
      <para>
        This is a tip in Docbook. Lorem ipsum dolor sit amet,
        consectetuer adipiscing elit, sed diam nonummy nibh euismod
        tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi
        enim ad minim veniam, quis nostrud exerci tation ullamcorper
        suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis
        autem vel eum iriure dolor in hendrerit in vulputate velit esse
        molestie consequat, vel illum dolore eu feugiat nulla facilisis
        at vero eros et accumsan et iusto odio dignissim qui blandit
        praesent luptatum zzril delenit augue duis dolore te feugait
        nulla facilisi. Nam liber tempor cum soluta nobis eleifend
        option congue nihil imperdiet doming id quod mazim placerat
        facer possim assum. Typi non habent claritatem insitam; est usus
        legentis in iis qui facit eorum claritatem. Investigationes
        demonstraverunt lectores legere me lius quod ii legunt saepius.
        Claritas est etiam processus dynamicus, qui sequitur mutationem
        consuetudium lectorum. Mirum est notare quam littera gothica,
        quam nunc putamus parum claram, anteposuerit litterarum formas
        humanitatis per seacula quarta decima et quinta decima. Eodem
        modo typi, qui nunc nobis videntur parum clari, fiant sollemnes
        in futurum.
      </para>
      </tip>

      <note>
      <title>
      This is a note title
      </title>
      <para>
        This is a tip in Docbook. Lorem ipsum dolor sit amet,
        consectetuer adipiscing elit, sed diam nonummy nibh euismod
        tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi
        enim ad minim veniam, quis nostrud exerci tation ullamcorper
        suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis
        autem vel eum iriure dolor in hendrerit in vulputate velit esse
        molestie consequat, vel illum dolore eu feugiat nulla facilisis
        at vero eros et accumsan et iusto odio dignissim qui blandit
        praesent luptatum zzril delenit augue duis dolore te feugait
        nulla facilisi. Nam liber tempor cum soluta nobis eleifend
        option congue nihil imperdiet doming id quod mazim placerat
        facer possim assum. Typi non habent claritatem insitam; est usus
        legentis in iis qui facit eorum claritatem. Investigationes
        demonstraverunt lectores legere me lius quod ii legunt saepius.
        Claritas est etiam processus dynamicus, qui sequitur mutationem
        consuetudium lectorum. Mirum est notare quam littera gothica,
        quam nunc putamus parum claram, anteposuerit litterarum formas
        humanitatis per seacula quarta decima et quinta decima. Eodem
        modo typi, qui nunc nobis videntur parum clari, fiant sollemnes
        in futurum.
      </para>
      </note>

    </sect2>
  </sect1>
</chapter>
</book>
