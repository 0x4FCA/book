<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.5//EN' 'http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd'><book>
  <!-- Reference new files using XIncludes (not entities): http://www.sagehill.net/docbookxsl/ModularDoc.html#UsingXinclude -->
  <!-- Each file should have a DOCTYPE at the top of it so you can validate it alone (just like this but with a chapter/preface instead of book-->
  <!-- Remember, using XIncludes means that you'll have to add a flag (typically 'xinclude' with one or two dashes) when using XML processors/parsers -->
  <!-- Validate with xmllint as follows (Basic setup same as libxslt: http://www.sagehill.net/docbookxsl/InstallingAProcessor.html)-->
  <!-- (please collapse dashes in the line beloew) -->

<title>Real World OCaml</title>
<xi:include href='bookinfo.xml' xmlns:xi='http://www.w3.org/2001/XInclude'/>
<xi:include href='ch00.xml' xmlns:xi='http://www.w3.org/2001/XInclude'/>
<chapter id="prologue">
  <title>Prologue</title>
  <para>
    <emphasis>(yminsky: this is something of a placeholder. We need a
    real introduction that should talk, amongst other things, about what
    kinds of applications OCaml is good for and why one should want to
    learn it. Also, some coverage of who uses OCaml successfully
    now.)</emphasis>
  </para>
  <sect1 id="why-ocaml">
    <title>Why OCaml?</title>
    <para>
      Programming languages matter.
    </para>
    <para>
      The programming languages that you use affect your productivity.
      They affect how reliable your software is, how efficient it is,
      how easy it is to read, to refactor, and to extend. And the
      programming languages you know and use can deeply affect how you
      think about programming and software design.
    </para>
    <para>
      But not all ideas about how to design a programming language are
      created equal. Over the last 40 years, a few key language features
      have emerged that together form a kind of sweet-spot in language
      design. These features include:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Garbage collection
        </para>
      </listitem>
      <listitem>
        <para>
          First-class and higher-order functions
        </para>
      </listitem>
      <listitem>
        <para>
          Static type-checking
        </para>
      </listitem>
      <listitem>
        <para>
          Parametric polymorphism
        </para>
      </listitem>
      <listitem>
        <para>
          Support for programming with immutable values
        </para>
      </listitem>
      <listitem>
        <para>
          Algebraic datatypes and pattern-matching
        </para>
      </listitem>
      <listitem>
        <para>
          Type inference
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Some of these features you already know and love, and some are
      probably new to you. But as we hope to demonstrate over the course
      of this book, it turns out that there is something transformative
      about having them all together and able to interact with each
      other in a single language.
    </para>
    <para>
      Despite their importance, these ideas have made only limited
      inroads into mainstream languages. And when they do arrive there,
      like higher-order functions in C# or parametric polymorphism in
      Java, it's typically in a limited and awkward form. The only
      languages that support these ideas well are statically-typed
      functional programming languages like OCaml, F#, Haskell, Scala
      and Standard-ML.
    </para>
    <para>
      Among this worthy set of languages, OCaml stands apart because it
      manages to provide a great deal of power while remaining highly
      pragmatic, highly performant, and comparatively simple to use and
      understand. It is this that makes OCaml a great choice for
      programmers who want to step up to a better programming language,
      and at the same time want to get practical work done.
    </para>
  </sect1>
  <sect1 id="why-core">
    <title>Why Core?</title>
    <para>
      A language on its own isn't enough. You also need a rich set of
      libraries to base your applications on. A common source of
      frustration for those learning OCaml is that the standard library
      that ships with the OCaml compiler is not ideal. While it's well
      implemented, it covers only a small subset of the functionality
      you expect from a standard library, and the interfaces are
      idiosyncratic and inconsistent.
    </para>
    <para>
      But all is not lost! There is an effective alternative to the
      OCaml standard library called Core. Jane Street, a company that
      has been using OCaml for nearly a decade, developed Core for its
      own internal use, but it was designed from the start with an eye
      towards being a general-purpose standard library. Core is also
      distributed with syntax-extensions which provide essential new
      functionality to OCaml; and there are additional libraries, like
      Core_extended and Async, that provide even more useful
      functionality.
    </para>
    <para>
      We believe that Core makes OCaml a better tool, and that's why
      we'll present OCaml and Core together.
    </para>
  </sect1>
  <sect1 id="about-the-authors">
    <title>About the Authors</title>
    <sect2 id="jason-hickey">
      <title>Jason Hickey</title>
      <para>
        Jason Hickey is a Software Engineer at Google Inc. in Mountain
        View, California. He is part of the team that designs and
        develops the global computing infrastructure used to support
        Google services, including the software systems for managing and
        scheduling massively distributed computing resources.
      </para>
      <para>
        Prior to joining Google, Jason was an Assistant Professor of
        Computer Science at Caltech, where his research was in reliable
        and fault-tolerant computing systems, including programming
        language design, formal methods, compilers, and new models of
        distributed computation. He obtained his PhD in Computer Science
        from Cornell University, where he studied programming languages.
        He is the author of the MetaPRL system, a logical framework for
        design and analysis of large software systems; OMake, an
        advanced build system for large software projects. He is the
        author of the textbook, <emphasis>An Introduction to Objective
        Caml</emphasis> (unpublished).
      </para>
    </sect2>
    <sect2 id="anil-madhavapeddy">
      <title>Anil Madhavapeddy</title>
      <para>
        Anil Madhavapeddy is a Senior Research Fellow at the University
        of Cambridge, based in the Systems Research Group. He was on the
        original team that developed the Xen hypervisor, and helped
        develop an industry-leading cloud management toolstack written
        entirely in OCaml. This XenServer product has been deployed on
        hundreds of thousands of physical hosts, and drives critical
        infrastructure for many Fortune 500 companies.
      </para>
      <para>
        Prior to obtaining his PhD in 2006 from the University of
        Cambridge, Anil had a diverse background in industry at Network
        Appliance, NASA and Internet Vision. In addition to professional
        and academic activities, he is an active member of the
        open-source development community with the OpenBSD operating
        system, is co-chair of the Commercial Uses of Functional
        Programming workshop, and serves on the boards of startup
        companies such as Ashima Arts where OCaml is extensively used.
      </para>
    </sect2>
    <sect2 id="yaron-minsky">
      <title>Yaron Minsky</title>
      <para>
        Yaron Minsky heads the Technology group at Jane Street, a
        proprietary trading firm that is the largest industrial user of
        OCaml. He was responsible for introducing OCaml to the company
        and for managing the company's transition to using OCaml for all
        of its core infrastructure. Today, billions of dollars worth of
        securities transactions flow each day through those systems.
      </para>
      <para>
        Yaron obtained his PhD in Computer Science from Cornell
        University, where he studied distributed systems. Yaron has
        lectured, blogged and written about OCaml for years, with
        articles published in Communications of the ACM and the Journal
        of Functional Programming. He chairs the steering committee of
        the Commercial Users of Functional Programming, and is a member
        of the steering committee for the International Conference on
        Functional Programming.
      </para>
    </sect2>
  </sect1>
</chapter>
<chapter id="a-guided-tour">
  <title>A Guided Tour</title>
  <para>
    This chapter gives an overview of OCaml by walking through a series
    of small examples that cover most of the major features of the
    language. This should give a sense of what OCaml can do, without
    getting too deep in any one topic.
  </para>
  <para>
    We'll present this guided tour using the <literal>utop</literal>
    OCaml toplevel, an interactive shell that lets you type in
    expressions and evaluate them interactively. When you get to the
    point of running real programs, you'll want to leave the toplevel
    behind, but it's a great tool for getting to know the language.
  </para>
  <para>
    You should have a working toplevel as you go through this chapter,
    so you can try out the examples as you go. There is a
    zero-configuration browser-based toplevel that you can use for this,
    which you can find here:
  </para>
  <programlisting>
 http://realworldocaml.org/TODO
</programlisting>
  <note>
  <title>
  Getting the interactive top-level
  </title>
  <para>
    Before proceeding, make sure you have the Core library installed.
    You can do this easily via the OPAM package manager, which is
    explained in <link linkend="installation">Chapter X</link>. In a
    nutshell, you need to:
  </para>
  <programlisting>
$ opam init
$ opam switch 4.00.1+short-types
$ opam install utop async core_extended
$ eval `opam config -env`
$ utop
</programlisting>
  <para>
    You can exit utop by pressing <literal>control-D</literal> and
    return.
  </para>
  </note>
  <sect1 id="ocaml-as-a-calculator">
    <title>OCaml as a calculator</title>
    <para>
      Let's spin up the toplevel and open the
      <literal>Core.Std</literal> module to get access to Core's
      libraries. Don't forget to open <literal>Core.Std</literal>, since
      without it, many of the examples below will fail.
    </para>
    <programlisting>
$ utop
# open Core.Std;;
</programlisting>
    <para>
      Now that we have Core open, let's try a few simple numerical
      calculations.
    </para>
    <programlisting>
# 3 + 4;;
- : int = 7
# 8 / 3;;
- : int = 2
# 3.5 +. 6.;;
- : float = 9.5
# sqrt 9.;;
- : float = 3.
</programlisting>
    <para>
      By and large, this is pretty similar to what you'd find in any
      programming language, but there are a few things that jump right
      out at you.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          We needed to type <literal>;;</literal> in order to tell the
          toplevel that it should evaluate an expression. This is a
          peculiarity of the toplevel that is not required in
          stand-alone programs.
        </para>
      </listitem>
      <listitem>
        <para>
          After evaluating an expression, the toplevel spits out both
          the type of the result and the result itself.
        </para>
      </listitem>
      <listitem>
        <para>
          Function arguments are separated by spaces, instead of by
          parenthesis and commas, which is more like the UNIX shell than
          C or Java.
        </para>
      </listitem>
      <listitem>
        <para>
          OCaml carefully distinguishes between
          <literal>float</literal>, the type for floating point numbers
          and <literal>int</literal>. The types have different literals
          (<literal>6.</literal> instead of <literal>6</literal>) and
          different infix operators (<literal>+.</literal> instead of
          <literal>+</literal>), and OCaml doesn't do any automated
          casting between the types. This can be a bit of a nuisance,
          but it has its benefits, since it prevents some kinds of bugs
          that arise in other languages due to unexpected differences
          between the behavior of <literal>int</literal> and
          <literal>float</literal>.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We can also create variables to name the value of a given
      expression, using the <literal>let</literal> syntax.
    </para>
    <programlisting>
# let x = 3 + 4;;
val x : int = 7
# let y = x + x;;
val y : int = 14
</programlisting>
    <para>
      After a new variable is created, the toplevel tells us the name of
      the variable, in addition to its type and value.
    </para>
  </sect1>
  <sect1 id="functions-and-type-inference">
    <title>Functions and Type Inference</title>
    <para>
      The <literal>let</literal> syntax can also be used for creating
      functions:
    </para>
    <programlisting>
# let square x = x * x ;;
val square : int -&gt; int = &lt;fun&gt;
# square (square 2);;
- : int = 16
</programlisting>
    <para>
      When using <literal>let</literal> to define a function, the first
      identifier after the <literal>let</literal> is the function name,
      and each subsequent identifier is a different argument to the
      function. Thus, <literal>square</literal> is a function with a
      single argument.
    </para>
    <para>
      Now that we're creating more interesting values like functions,
      the types have gotten more interesting too.
      <literal>int -&gt; int</literal> is a function type, in this case
      indicating a function that takes an <literal>int</literal> and
      returns an <literal>int</literal>. We can also write functions
      that take multiple arguments.
    </para>
    <programlisting>
# let ratio x y =
     Float.of_int x /. Float.of_int y
  ;;
val ratio : int -&gt; int -&gt; float = &lt;fun&gt;
# ratio 4 7;;
- : float = 0.571428571428571397
</programlisting>
    <para>
      The notation for the type-signature of a multi-argument functions
      may be a little surprising at first, but we'll explain where it
      comes from when we get to function currying in
      <link linkend="variables-and-functions">Chapter 3</link>. For the
      moment, think of the arrows as separating different arguments of
      the function, with the type after the final arrow being the return
      value of the function. Thus,
    </para>
    <programlisting language="ocaml">
int -&gt; int -&gt; float
</programlisting>
    <para>
      describes a function that takes two <literal>int</literal>
      arguments and returns a <literal>float</literal>.
    </para>
    <para>
      We can even write functions that take other functions as
      arguments. Here's an example of a function that takes three
      arguments: a test function and two integer arguments. The function
      returns the sum of the integers that pass the test.
    </para>
    <programlisting>
# let sum_if_true test x y =
     if test x then x else 0
     + if test y then y else 0
  ;;
val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      If we look at the inferred type signature in detail, we see that
      the first argument is a function that takes an int and returns a
      boolean, and that the remaining two arguments are integers. Here's
      an example of this function in action.
    </para>
    <programlisting>
# let even x = x mod 2 = 0 ;;
val even : int -&gt; bool = &lt;fun&gt;
# sum_if_true even 3 4;;
- : int = 4
# sum_if_true even 2 4;;
- : int = 6
</programlisting>
    <sect2 id="type-inference">
      <title>Type inference</title>
      <para>
        As the types we encounter get more complicated, you might ask
        yourself how OCaml is able to figure them out, given that we
        didn't write down any explicit type information.
      </para>
      <para>
        OCaml determines the type of an expression using a technique
        called <emphasis>type-inference</emphasis>, by which it infers
        the type of a given expression based on what it already knows
        about the types of other related variables, and on constraints
        on the types that arise from the structure of the code.
      </para>
      <para>
        As an example, let's walk through the process of inferring the
        type of <literal>sum_if_true</literal>.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            OCaml requires that both arms of an <literal>if</literal>
            statement return the same type, so the expression
            <literal>if test x then x else 0</literal> requires that
            <literal>x</literal> must be the same type as
            <literal>0</literal>, which is <literal>int</literal>. By
            the same logic we can conclude that <literal>y</literal> has
            type <literal>int</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>test</literal> is passed <literal>x</literal> as an
            argument. Since <literal>x</literal> has type
            <literal>int</literal>, the input type of
            <literal>test</literal> must be <literal>int</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>test x</literal> is used as the condition in an
            <literal>if</literal> statement, so the return type of
            <literal>test</literal> must be <literal>bool</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            The fact that <literal>+</literal> returns an int implies
            that the return value of <literal>sum_if_true</literal> must
            be int.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Together, that nails down the the types of all the variables,
        which determines the overall type of
        <literal>sum_if_true</literal>.
      </para>
      <para>
        Over time, you'll build a rough intuition for how the OCaml
        inference engine works, which makes it easier to reason through
        your programs. One way of making it easier to understand the
        types is to add explicit type annotations. These annotations
        never change the behavior of an OCaml program, but they can
        serve as useful documentation, as well as catch unintended type
        changes. Here's an annotated version of
        <literal>sum_if_true</literal>:
      </para>
      <programlisting>
# let sum_if_true (test : int -&gt; bool) (x:int) (y:int) : int =
     if test x then x else 0
     + if test y then y else 0
  ;;
val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        In the above, we've marked every argument to the function with
        its type, with the final annotation indicating the type of the
        return value. Such type annotations can actually go around any
        value in an OCaml program, and can be useful for figuring out
        why a given program is failing to compile.
      </para>
    </sect2>
    <sect2 id="inferring-generic-types">
      <title>Inferring generic types</title>
      <para>
        Sometimes, there isn't enough information to fully determine the
        concrete type of a given value. Consider this function.
      </para>
      <programlisting>
# let first_if_true test x y =
    if test x then x else y
  ;;
</programlisting>
      <para>
        <literal>first_if_true</literal> takes as its arguments a
        function <literal>test</literal>, and two values,
        <literal>x</literal> and <literal>y</literal>, where
        <literal>x</literal> is to be returned if
        <literal>test x</literal> evaluates to <literal>true</literal>,
        and <literal>y</literal> otherwise. So what's the type of
        <literal>first_if_true</literal>? There are no obvious clues
        such as arithmetic operators or literals to tell you what the
        type of <literal>x</literal> and <literal>y</literal> are. That
        makes it seem like one could use this
        <literal>first_if_true</literal> on values of any type. Indeed,
        if we look at the type returned by the toplevel:
      </para>
      <programlisting>
val first_if_true : ('a -&gt; bool) -&gt; 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
</programlisting>
      <para>
        we see that rather than choose a single concrete type, OCaml has
        introduced a <emphasis>type variable</emphasis>
        <literal>'a</literal> to express that the type is generic. In
        particular, the type of the <literal>test</literal> argument is
        <literal>('a -&gt; bool)</literal>, which means that test is a
        one-argument function whose return value is
        <literal>bool</literal>, and whose argument could be of any type
        <literal>'a</literal>. But, whatever type <literal>'a</literal>
        is, it has to be the same as the type of the other two
        arguments, <literal>x</literal> and <literal>y</literal>.
      </para>
      <para>
        This genericity means that we can write:
      </para>
      <programlisting>
# let long_string s = String.length s &gt; 6;;
val long_string : string -&gt; bool = &lt;fun&gt;
# first_if_true long_string &quot;short&quot; &quot;loooooong&quot;;;
- : string = &quot;loooooong&quot;
</programlisting>
      <para>
        And we can also write:
      </para>
      <programlisting>
# let big_number x = x &gt; 3;;
val big_number : int -&gt; bool = &lt;fun&gt;
# first_if_true big_number 4 3;;
- : int = 4
</programlisting>
      <para>
        Both <literal>long_string</literal> and
        <literal>big_number</literal> are functions, and each is passed
        to <literal>first_if_true</literal> with two other arguments of
        the appropriate type (strings in the first example, and integers
        in the second). But we can't mix and match two different
        concrete types for <literal>'a</literal> in the same use of
        <literal>first_if_true</literal>.
      </para>
      <programlisting>
# first_if_true big_number &quot;short&quot; &quot;loooooong&quot;;;
Characters 25-30:
  first_if_true big_number &quot;short&quot; &quot;loooooong&quot;;;
                           ^^^^^^^
Error: This expression has type string but
    an expression was expected of type int
</programlisting>
      <para>
        In this example, <literal>big_number</literal> requires that
        <literal>'a</literal> be of type <literal>int</literal>, whereas
        <literal>&quot;short&quot;</literal> and
        <literal>&quot;loooooong&quot;</literal> require that
        <literal>'a</literal> be of type <literal>string</literal>, and
        they can't all be right at the same time. This kind of
        genericity is called <emphasis>parametric
        polymorphism</emphasis>, and is very similar to generics in C#
        and Java.
      </para>
      <sidebar><title>
      Type errors vs exceptions
      </title>
      <para>
        There's a big difference in OCaml (and really in any compiled
        language) between errors that are caught at compile time and
        those that are caught at run-time. It's better to catch errors
        as early as possible in the development process, and compilation
        time is best of all.
      </para>
      <para>
        Working in the top-level somewhat obscures the difference
        between run-time and compile time errors, but that difference is
        still there. Generally, type errors, like this one:
      </para>
      <programlisting>
# 3 + &quot;potato&quot;;;
Characters 4-12:
  3 + &quot;potato&quot;;;
      ^^^^^^^^
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
      <para>
        are compile-time errors, whereas an error that can't be caught
        by the type system, like division by zero, leads to a runtime
        exception.
      </para>
      <programlisting>
# 3 / 0;;
Exception: Division_by_zero.
</programlisting>
      <para>
        One important distinction is that type errors will stop you
        whether or not the offending code is ever actually executed.
        Thus, you get an error from typing in this code:
      </para>
      <programlisting>
# if 3 &lt; 4 then 0 else 3 + &quot;potato&quot;;;
Characters 25-33:
  if 3 &lt; 4 then 0 else 3 + &quot;potato&quot;;;
                           ^^^^^^^^
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
      <para>
        but this code works fine, even though it contains an branch that
        would throw an exception if it were ever reached.
      </para>
      <programlisting>
# if 3 &lt; 4 then 0 else 3 / 0;;
- : int = 0
</programlisting>
      </sidebar>
    </sect2>
  </sect1>
  <sect1 id="tuples-lists-options-and-pattern-matching">
    <title>Tuples, Lists, Options and Pattern-matching</title>
    <sect2 id="tuples">
      <title>Tuples</title>
      <para>
        So far we've encountered a handful of basic types like
        <literal>int</literal>, <literal>float</literal> and
        <literal>string</literal> as well as function types like
        <literal>string -&gt; int</literal>. But we haven't yet talked
        about any data structures. We'll start by looking at a
        particularly simple data structure, the tuple. You can create a
        tuple by joining values together with a comma:
      </para>
      <programlisting>
# let tup = (3,&quot;three&quot;);;
val tup : int * string = (3, &quot;three&quot;)
</programlisting>
      <para>
        For the mathematically inclined, the <literal>*</literal>
        character is used because the set of all pairs of type
        <literal>t * s</literal> corresponds to the Cartesian product of
        the set of elements of type <literal>t</literal> and the set of
        elements of type <literal>s</literal>.
      </para>
      <para>
        You can extract the components of a tuple using OCaml's
        pattern-matching syntax. For example:
      </para>
      <programlisting>
# let (x,y) = tup;;
val x : int = 3
val y : string = &quot;three&quot;
</programlisting>
      <para>
        Here, the <literal>(x,y)</literal> on the left-hand side of the
        <literal>let</literal> is the pattern. This pattern lets us mint
        the new variables <literal>x</literal> and <literal>y</literal>,
        each bound to different components of the value being matched.
        Note that the same syntax is used both for constructing and for
        pattern-matching on tuples.
      </para>
      <para>
        Pattern matching can also show up in function arguments. Here's
        a function for computing the distance between two points on the
        plane, where each point is represented as a pair of
        <literal>float</literal>s. The pattern matching syntax lets us
        get at the values we need with a minimum of fuss.
      </para>
      <programlisting>
# let distance (x1,y1) (x2,y2) =
    sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
;;
</programlisting>
      <para>
        This is just a first taste of pattern matching. Pattern matching
        is a pervasive tool in OCaml, and as you'll see, it has
        surprising power.
      </para>
    </sect2>
    <sect2 id="lists">
      <title>Lists</title>
      <para>
        Where tuples let you combine a fixed number of items,
        potentially of different types, lists let you hold any number of
        items of the same type. For example:
      </para>
      <programlisting>
# let languages = [&quot;OCaml&quot;;&quot;Perl&quot;;&quot;C&quot;];;
val languages : string list = [&quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
      <para>
        Note that you can't mix elements of different types on the same
        list, as we did with tuples.
      </para>
      <programlisting>
# let numbers = [3;&quot;four&quot;;5];;
Characters 17-23:
  let numbers = [3;&quot;four&quot;;5];;
                   ^^^^^^
Error: This expression has type string but an expression was expected of type
         int
</programlisting>
      <sect3 id="the-list-module">
        <title>The <literal>List</literal> module</title>
        <para>
          OCaml comes with a <literal>List</literal> module that has a
          rich collection of functions for working with lists. We can
          access values from within a module by using dot-notation.
          Here, for example, is how we compute the length of a list.
        </para>
        <programlisting>
# List.length languages;;
- : int = 3
</programlisting>
        <para>
          Here's something a little more complicated. We can compute the
          list of the lengths of each language as follows.
        </para>
        <programlisting>
# List.map languages ~f:String.length;;
- : int list = [5; 4; 1]
</programlisting>
        <para>
          <literal>List.map</literal> takes two arguments: a list, and a
          function for transforming the elements of that list. Note that
          <literal>List.map</literal> creates a new list and does not
          modify the original.
        </para>
        <para>
          In this example, the function <literal>String.length</literal>
          is passed using under the <emphasis>labeled
          argument</emphasis> <literal>~f</literal>. Labels allow you to
          specify function arguments by name rather than by position. As
          you can see below, we can change the order of labeled
          arguments without changing the function's behavior.
        </para>
        <programlisting>
# List.map ~f:String.length languages;;
- : int list = [5; 4; 1]
</programlisting>
        <para>
          We'll learn more about labeled arguments and why they're
          important in Chapter {{{variables-and-functions}}}.
        </para>
      </sect3>
      <sect3 id="constructing-lists-with">
        <title>Constructing lists with <literal>::</literal></title>
        <para>
          In addition to constructing lists using brackets, we can use
          the operator <literal>::</literal> for adding elements to the
          front of a list.
        </para>
        <programlisting>
# &quot;French&quot; :: &quot;Spanish&quot; :: languages;;
- : string list = [&quot;French&quot;; &quot;Spanish&quot;; &quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
        <para>
          Here, we're creating a new extended list, not changing the
          list we started with, as you can see below.
        </para>
        <programlisting>
# languages;;
- : string list = [&quot;OCaml&quot;; &quot;Perl&quot;; &quot;C&quot;]
</programlisting>
        <para>
          The bracket notation for lists is really just syntactic sugar
          for <literal>::</literal>. Thus, the following declarations
          are all equivalent. Note that <literal>[]</literal> is used to
          represent the empty list.
        </para>
        <programlisting>
# [1; 2; 3];;
- : int list = [1; 2; 3]
# 1 :: (2 :: (3 :: []));;
- : int list = [1; 2; 3]
# 1 :: 2 :: 3 :: [];;
- : int list = [1; 2; 3]
</programlisting>
      </sect3>
      <sect3 id="list-patterns-using-match">
        <title>List patterns using <literal>match</literal></title>
        <para>
          The elements of a list can be accessed through
          pattern-matching. List patterns are based on the two list
          constructors, <literal>[]</literal> and <literal>::</literal>.
          Here's a simple example.
        </para>
        <programlisting>
# let my_favorite_language (my_favorite :: the_rest) =
     my_favorite
  ;;
</programlisting>
        <para>
          By pattern matching using <literal>::</literal>, we've broken
          off the first element of <literal>languages</literal> from the
          rest of the list. If you know Lisp or Scheme, what we've done
          is the equivalent of using <literal>car</literal> to grab the
          first element of a list.
        </para>
        <para>
          If you try the above example in the toplevel, however, you'll
          see that it spits out an error:
        </para>
        <programlisting>
    Characters 25-69:
  .........................(my_favorite :: the_rest) =
       my_favorite
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val my_favorite_language : 'a list -&gt; 'a = &lt;fun&gt;
</programlisting>
        <para>
          The warning comes because the compiler can't be certain that
          the pattern match won't lead to a runtime error. Indeed, the
          warning gives an example of a pattern that won't match, the
          empty list, <literal>[]</literal>. We can see this in action
          below.
        </para>
        <programlisting>
# my_favorite_language [&quot;English&quot;;&quot;Spanish&quot;;&quot;French&quot;];;
- : string = &quot;English&quot;
# my_favorite_language [];;
Exception: Match_failure (&quot;//toplevel//&quot;, 11, 10).
</programlisting>
        <para>
          You can avoid these warnings, and more importantly make sure
          that your code actually handles all of the possible cases, by
          using a <literal>match</literal> statement instead.
        </para>
        <para>
          A <literal>match</literal> statement is a kind of juiced-up
          version of the switch statement found in <literal>C</literal>
          and <literal>Java</literal>. It essentially lets you list a
          sequence of patterns (separated by <literal>|</literal>
          characters --- the one before the first case is optional), and
          the compiler then dispatches to the code following the first
          matched pattern. And, as we've already seen, we can name new
          variables in our patterns that correspond to sub-structures of
          the value being matched.
        </para>
        <para>
          Here's a new version of
          <literal>my_favorite_language</literal> that uses
          <literal>match</literal>, and doesn't trigger a compiler
          warning.
        </para>
        <programlisting>
# let my_favorite_language languages =
    match languages with
    | first :: the_rest -&gt; first
    | [] -&gt; &quot;OCaml&quot; (* A good default! *)
 ;;
val my_favorite_language : string list -&gt; string = &lt;fun&gt;
# my_favorite_language [&quot;English&quot;;&quot;Spanish&quot;;&quot;French&quot;];;
- : string = &quot;English&quot;
# my_favorite_language [];;
- : string = &quot;OCaml&quot;
</programlisting>
        <para>
          Note that we included a comment in the above code. OCaml
          comments are bounded by <literal>(*</literal> and
          <literal>*)</literal>, and can be nested arbitrarily and cover
          multiple lines.
        </para>
        <para>
          The first pattern, <literal>first :: the_rest</literal>,
          covers the case where <literal>languages</literal> has at
          least one element, since every list except for the empty list
          can be written down with one or more <literal>::</literal>'s.
          The second pattern, <literal>[]</literal>, matches only the
          empty list. These cases are exhaustive (every list is either
          empty, or has at least one element), and the compiler can
          detect that exhaustiveness, which is why it doesn't spit out a
          warning.
        </para>
      </sect3>
      <sect3 id="recursive-list-functions">
        <title>Recursive list functions</title>
        <para>
          Recursive functions, or, functions that call themselves, are
          an important technique in OCaml and in any functional
          language. The typical approach to designing a recursive
          function is to separate the logic into a set of <emphasis>base
          cases</emphasis>, that can be solved directly, and a set of
          <emphasis>inductive cases</emphasis>, where the function
          breaks the problem down into smaller pieces and then calls
          itself to solve those smaller problems.
        </para>
        <para>
          When writing recursive list functions, this separation between
          the base cases and the inductive cases is often done using
          pattern matching. Here's a simple example of a function that
          sums the elements of a list.
        </para>
        <programlisting>
# let rec sum l =
    match l with
    | [] -&gt; 0
    | hd :: tl -&gt; hd + sum tl
  ;;
val sum : int list -&gt; int
# sum [1;2;3;4;5];;
- : int = 15
</programlisting>
        <para>
          Note that we had to use the <literal>rec</literal> keyword to
          allow <literal>sum</literal> to refer to itself. And, as you
          might imagine, the base case and inductive case are different
          arms of the match. In particular, the base case is that of the
          empty list, and the inductive case is that of a list of zero
          or more elements.
        </para>
        <para>
          We can introduce more complicated list patterns as well.
          Here's a function for destuttering a list,
          <emphasis>i.e.</emphasis>, for removing sequential duplicates.
        </para>
        <programlisting>
# let rec destutter list =
    match list with
    | [] -&gt; []
    | hd1 :: hd2 :: tl -&gt;
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl)
  ;;
</programlisting>
        <para>
          Again, the first arm of the match is the base case, and the
          second is the inductive. Unfortunately, this code has a
          problem. If you type it into the top-level, you'll see this
          error:
        </para>
        <programlisting>
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::[]
</programlisting>
        <para>
          This indicates that we're missing a case, in particular we
          don't handle one-element lists. That's easy enough to fix by
          adding another case to the match:
        </para>
        <programlisting>
# let rec destutter list =
    match list with
    | [] -&gt; []
    | [hd] -&gt; [hd]
    | hd1 :: (hd2 :: tl) -&gt;
      if hd1 = hd2 then destutter (hd2 :: tl)
      else hd1 :: destutter (hd2 :: tl)
  ;;
val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
# destutter [&quot;hey&quot;;&quot;hey&quot;;&quot;hey&quot;;&quot;man!&quot;];;
- : string list = [&quot;hey&quot;; &quot;man!&quot;]
</programlisting>
        <para>
          Note that this code used another variant of the list pattern,
          <literal>[hd]</literal>, to match a list with a single
          element. We can do this to match a list with any fixed number
          of elements, <emphasis>e.g.</emphasis>,
          <literal>[x;y;z]</literal> will match any list with exactly
          three elements, and will bind those elements to the variables
          <literal>x</literal>, <literal>y</literal> and
          <literal>z</literal>.
        </para>
        <para>
          In the last few examples, our list processing code involved a
          lot of recursive functions. In practice, this isn't usually
          necessary. Most of the time, you'll find yourself happy to use
          the iteration functions found in the <literal>List</literal>
          module. But it's good to know how to use recursion when you
          need to do something new that's not already supported.
        </para>
      </sect3>
    </sect2>
    <sect2 id="options">
      <title>Options</title>
      <para>
        Another common data structure in OCaml is the option. An option
        is used to express that a value might or might not be present.
        For example,
      </para>
      <programlisting>
# let divide x y =
    if y = 0 then None else Some (x/y) ;;
val divide : int -&gt; int -&gt; int option = &lt;fun&gt;
</programlisting>
      <para>
        <literal>Some</literal> and <literal>None</literal> are
        constructors, like <literal>::</literal> and
        <literal>[]</literal> for lists, which let you build optional
        values. You can think of an option as a specialized list that
        can only have zero or one element.
      </para>
      <para>
        To get a value out of an option, we use pattern matching, as we
        did with tuples and lists. Consider the following simple
        function for printing a log entry given an optional time and a
        message. If no time is provided (<emphasis>i.e.</emphasis>, if
        the time is <literal>None</literal>), the current time is
        computed and used in its place.
      </para>
      <programlisting>
# let print_log_entry maybe_time message =
    let time =
      match maybe_time with
      | Some x -&gt; x
      | None -&gt; Time.now ()
    in
    printf &quot;%s: %s\n&quot; (Time.to_string time) message ;;
val print_log_entry : Time.t option -&gt; string -&gt; unit
</programlisting>
      <para>
        Here, we again use a <literal>match</literal> statement for
        handling the two possible states of an option. It's worth noting
        that we don't necessarily need to use an explicit
        <literal>match</literal> statement in this case. We can instead
        use some built in functions from the <literal>Option</literal>
        module, which, like the <literal>List</literal> module for
        lists, is a place where you can find a large collection of
        useful functions for working with options.
      </para>
      <para>
        In this case, we can rewrite <literal>print_log_entry</literal>
        using <literal>Option.value</literal>, which returns the content
        of an option if the option is <literal>Some</literal>, or a
        default value if the option is <literal>None</literal>.
      </para>
      <programlisting>
# let print_log_entry maybe_time message =
    let time = Option.value ~default:(Time.now ()) maybe_time in
    printf &quot;%s: %s\n&quot; (Time.to_string time) message ;;
</programlisting>
      <para>
        Options are important because they are the standard way in OCaml
        to encode a value that might not be there. This is different
        from most other languages, including Java and C#, where most if
        not all datatypes are <emphasis>nullable</emphasis>, meaning
        that, whatever their type is, any given value also contains the
        possibility of being a null value. In such languages, null is
        lurking everywhere.
      </para>
      <para>
        In OCaml, however, nulls are explicit. A value of type
        <literal>string * string</literal> always actually contains two
        two well-defined values of type <literal>string</literal>. If
        you want to allow, say, the first of those, to possibly be
        absent, then you need to change the type to something like
        <literal>string option * string</literal>. As we'll see, this
        explicitness allows the compiler to provide a great deal of help
        in making sure you're correctly handing the possibility of
        missing data.
      </para>
    </sect2>
  </sect1>
  <sect1 id="records-and-variants">
    <title>Records and Variants</title>
    <para>
      So far, we've looked only at data structures that were predefined
      in the language, like lists and tuples. But OCaml also allows us
      to define new datatypes. Here's a toy example of a datatype
      representing a point in 2-dimensional space:
    </para>
    <programlisting>
# type point2d = { x : float; y : float };;
type point2d = { x : float; y : float; }
</programlisting>
    <para>
      <literal>point2d</literal> is a <emphasis>record</emphasis> type,
      which you can think of as a tuple where the individual fields are
      named, rather than being defined positionally. Record types are
      easy enough to construct:
    </para>
    <programlisting>
# let p = { x = 3.; y = -4. };;
val p : point2d = {x = 3.; y = -4.}
</programlisting>
    <para>
      And we can get access to the contents of these types using pattern
      matching:
    </para>
    <programlisting>
# let magnitude { x = x_pos; y = y_pos } = sqrt (x_pos ** 2. +. y_pos ** 2.);;
val magnitude : point2d -&gt; float = &lt;fun&gt;
</programlisting>
    <para>
      We can write the pattern match even more tersely, using what's
      called <emphasis>field punning</emphasis>. In particular, when the
      name of the field and the name of the variable coincide, we don't
      have to write them both down. Thus, the magnitude function can be
      rewritten as follows.
    </para>
    <programlisting>
# let magnitude { x; y } = sqrt (x ** 2. +. y ** 2.);;
</programlisting>
    <para>
      We can also use dot-notation for accessing record fields:
    </para>
    <programlisting>
# let distance v1 v2 =
     magnitude { x = v1.x -. v2.x; y = v1.y -. v2.y };;
val distance : point2d -&gt; point2d -&gt; float = &lt;fun&gt;
</programlisting>
    <para>
      And we can of course include our newly defined types as components
      in larger types, as in the following types, each of which is a
      description of a different geometric object.
    </para>
    <programlisting>
# type circle_desc  = { center: point2d; radius: float } ;;
# type rect_desc    = { lower_left: point2d; width: float; height: float } ;;
# type segment_desc = { endpoint1: point2d; endpoint2: point2d } ;;
</programlisting>
    <para>
      Now, imagine that you want to combine multiple objects of these
      types together as a description of a multi-object scene. You need
      some unified way of representing these objects together in a
      single type. One way of doing this is using a
      <emphasis>variant</emphasis> type:
    </para>
    <programlisting>
# type scene_element =
    | Circle  of circle_desc
    | Rect    of rect_desc
    | Segment of segment_desc
  ;;
</programlisting>
    <para>
      The <literal>|</literal> character separates the different cases
      of the variant (the first <literal>|</literal> is optional), and
      each case has a tag, like <literal>Circle</literal>,
      <literal>Rect</literal> and <literal>Scene</literal>, to
      distinguish that case from the others. Here's how we might write a
      function for testing whether a point is in the interior of some
      element of a list of <literal>scene_element</literal>s.
    </para>
    <programlisting>
# let is_inside_scene_element point scene_element =
     match scene_element with
     | Circle { center; radius } -&gt;
       distance center point &lt; radius
     | Rect { lower_left; width; height } -&gt;
       point.x &gt; lower_left.x &amp;&amp; point.x &lt; lower_left.x +. width
       &amp;&amp; point.y &gt; lower_left.y &amp;&amp; point.y &lt; lower_left.y +. height
     | Segment { endpoint1; endpoint2 } -&gt; false
     ;;
val is_inside_scene_element : point2d -&gt; scene_element -&gt; bool = &lt;fun&gt;
# let is_inside_scene point scene =
     let point_is_inside_scene_element scene_element =
       is_inside_scene_element point scene_element
     in
     List.for_all scene ~f:point_is_inside_scene_element;;
val is_inside_shapes : point2d -&gt; scene_element list -&gt; bool = &lt;fun&gt;
</programlisting>
    <para>
      You might at this point notice that the use of
      <literal>match</literal> here is reminiscent of how we used
      <literal>match</literal> with <literal>option</literal> and
      <literal>list</literal>. This is no accident:
      <literal>option</literal> and <literal>list</literal> are really
      just examples of variant types that happen to be important enough
      to be defined in the standard library (and in the case of lists,
      to have some special syntax).
    </para>
  </sect1>
  <sect1 id="imperative-programming">
    <title>Imperative programming</title>
    <para>
      So far, we've only written so-called <emphasis>pure</emphasis> or
      <emphasis>functional</emphasis> code, meaning that we didn't write
      any code that modified a variable or value after its creation.
      This is a quite different style from
      <emphasis>imperative</emphasis> programming, where computations
      are structured as sequences of instructions that operate by
      modifying state as they go.
    </para>
    <para>
      Functional code is the default in OCaml, with variable bindings
      and most datastructures being immutable. But OCaml also has
      excellent support for imperative programming, including mutable
      data structures like arrays and hashtables and control-flow
      constructs like for and while loops.
    </para>
    <sect2 id="arrays">
      <title>Arrays</title>
      <para>
        Perhaps the simplest mutable datastructure in OCaml is the
        array. Arrays in OCaml are very similar to arrays in other
        languages like C: they are fixed width, indexing starts at 0,
        and accessing or modifying an array element is a constant-time
        operation. Arrays are more compact in terms of memory
        utilization than most other data structures in OCaml, including
        lists. OCaml uses three words per element of a list, but only
        one per element of an array.
      </para>
      <para>
        Here's an example.
      </para>
      <programlisting>
# let numbers = [| 1;2;3;4 |];;
val numbers : int array = [|1; 2; 3; 4|]
# numbers.(2) &lt;- 4;;
- : unit = ()
# numbers;;
- : int array = [|1; 2; 4; 4|]
</programlisting>
      <para>
        the <literal>.(i)</literal> syntax is used to refer to an
        element of an array, and the <literal>&lt;-</literal> syntax is
        for modification. Because the elements of the array are counted
        starting at zero, element <literal>.(2)</literal> is the third
        element.
      </para>
    </sect2>
    <sect2 id="mutable-record-fields">
      <title>Mutable record fields</title>
      <para>
        The array is an important mutable datastructure, but it's not
        the only one. Records, which are immutable by default, can be
        declared with specific fields as being mutable. Here's a small
        example of a datastructure for storing a running statistical
        summary of a collection of numbers. Here's the basic data
        structure:
      </para>
      <programlisting>
# type running_sum =
   { mutable sum: float;
     mutable sum_sq: float; (* sum of squares *)
     mutable samples: int;
   }
  ;;
</programlisting>
      <para>
        The fields in <literal>running_sum</literal> are designed to be
        easy to extend incrementally, and sufficient to compute means
        and standard deviations, as shown below.
      </para>
      <programlisting>
# let mean rsum = rsum.sum /. float rsum.samples
  let stdev rsum =
     sqrt (rsum.sum_sq /. float rsum.samples
           -. (rsum.sum /. float rsum.samples) ** 2.) ;;
val mean : running_sum -&gt; float = &lt;fun&gt;
val stdev : running_sum -&gt; float = &lt;fun&gt;
</programlisting>
      <para>
        We also need functions to create and update
        <literal>running_sum</literal>s:
      </para>
      <programlisting>
# let create () = { sum = 0.; sum_sq = 0.; samples = 0 }
  let update rsum x =
     rsum.samples &lt;- rsum.samples + 1;
     rsum.sum     &lt;- rsum.sum     +. x;
     rsum.sum_sq  &lt;- rsum.sum_sq  +. x *. x
  ;;
val create : unit -&gt; running_sum = &lt;fun&gt;
val update : running_sum -&gt; float -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        <literal>create</literal> returns a
        <literal>running_sum</literal> corresponding to the empty set,
        and <literal>update rsum x</literal> changes
        <literal>rsum</literal> to reflect the addition of
        <literal>x</literal> to its set of samples, by updating the
        number of samples, the sum, and the sum of squares.
      </para>
      <para>
        Note the use in the above code of single semi-colons to sequence
        operations. When we were working purely functionally, this
        wasn't necessary, but you start needing it when your code is
        acting by side-effect.
      </para>
      <para>
        A new and somewhat odd type has cropped up in this example:
        <literal>unit</literal>. What makes <literal>unit</literal>
        different is that there is only one value of type
        <literal>unit</literal>, which is written <literal>()</literal>.
        Because <literal>unit</literal> has only one inhabitant, a value
        of type <literal>unit</literal> can't convey any information.
      </para>
      <para>
        If it doesn't convey any information, then what is
        <literal>unit</literal> good for? Most of the time,
        <literal>unit</literal> acts as a placeholder. Thus, we use
        <literal>unit</literal> for the return value of a function like
        <literal>update</literal> that operates by side effect rather
        than by returning a value, and for the argument to a function
        like <literal>create</literal> that doesn't require any
        information to be passed into it in order to run.
      </para>
      <para>
        Here's an example of <literal>create</literal> and
        <literal>update</literal> in action.
      </para>
      <programlisting>
# let rsum = create ();;
val rsum : running_sum = {sum = 0.; sum_sq = 0.; samples = 0}
# List.iter [1.;3.;2.;-7.;4.;5.] ~f:(fun x -&gt; update rsum x);;
- : unit = ()
# mean rsum;;
- : float = 1.33333333333333326
# stdev rsum;;
- : float = 3.94405318873307698
</programlisting>
    </sect2>
    <sect2 id="refs">
      <title>Refs</title>
      <para>
        We can declare a single mutable value by using a
        <literal>ref</literal>, which is a record type with a single
        mutable field that is defined in the standard library.
      </para>
      <programlisting>
# let x = { contents = 0 };;
val x : int ref = {contents = 0}
# x.contents &lt;- x.contents + 1;;
- : unit = ()
# x;;
- : int ref = {contents = 1}
</programlisting>
      <para>
        There are a handful of useful functions and operators defined
        for refs to make them more convenient to work with.
      </para>
      <programlisting>
# let x = ref 0 ;; (* create a ref, i.e., { contents = 0 } *)
val x : int ref = {contents = 0}
# !x ;;            (* get the contents of a ref, i.e., x.contents *)
- : int = 0
# x := !x + 1 ;;   (* assignment, i.e., x.contents &lt;- ... *)
- : unit = ()
# incr x ;;        (* increment, i.e., x := !x + 1 *)
- : unit = ()
# !x ;;
- : int = 2
</programlisting>
      <para>
        A ref is really just an example of a mutable record, but in
        practice, it's the standard way of dealing with a single mutable
        value in a computation.
      </para>
    </sect2>
    <sect2 id="for-and-while-loops">
      <title>For and while loops</title>
      <para>
        Along with mutable data structures, OCaml gives you constructs
        like <literal>while</literal> and <literal>for</literal> loops
        for interacting with them. Here, for example, is a piece of
        imperative code for permuting an array. Here, we use the
        <literal>Random</literal> module as our source of randomness.
        (<literal>Random</literal> starts out with a deterministic seed,
        but you can call <literal>Random.self_init</literal> to get a
        new random seed chosen.)
      </para>
      <programlisting>
# let permute ar =
    for i = 0 to Array.length ar - 2 do
       (* pick a j that is after i and before the end of the list *)
       let j = i + 1 + Random.int (Array.length ar - i - 1) in
       (* Swap i and j *)
       let tmp = ar.(i) in
       ar.(i) &lt;- ar.(j);
       ar.(j) &lt;- tmp
    done
  ;;
val permute : 'a array -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        Note that the semi-colon after the first array assignment
        doesn't terminate the scope of the let-binding, so the variable
        <literal>j</literal> remains in scope until the end of the body
        of the for loop.
      </para>
      <para>
        Here's an example run of this code.
      </para>
      <programlisting>
# let ar = Array.init 20 ~f:(fun i -&gt; i);;
val ar : int array =
  [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19|]
# permute ar;;
- : unit = ()
# ar;;
- : int array =
[|14; 13; 1; 3; 2; 19; 17; 18; 9; 16; 15; 7; 12; 11; 4; 10; 0; 5; 6; 8|]
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="a-complete-program">
    <title>A complete program</title>
    <para>
      So far, we've played with the basic features of the language using
      the toplevel. Now we'll create a simple, complete stand-along
      program that does something useful: sum up a list of numbers read
      in from the UNIX standard input.
    </para>
    <para>
      Here's the code, which you can save in a file called
      <literal>sum.ml</literal>.
    </para>
    <programlisting language="ocaml">
(* file: sum.ml *)

open Core.Std

let rec read_and_accumulate accum =
  let line = In_channel.input_line stdin in
  match line with
  | None -&gt; accum
  | Some x -&gt; read_and_accumulate (accum +. Float.of_string x)

let () =
  printf &quot;Total: %F\n&quot; (read_and_accumulate 0.)
</programlisting>
    <para>
      This is our first use of OCaml's input and output routines. The
      function <literal>read_and_accumulate</literal> uses
      <literal>In_channel.input_line</literal> to read in lines one by
      one from the standard input, adding each number to its accumulated
      sum as it goes. Note that <literal>input_line</literal> returns an
      optional value, with <literal>None</literal> indicating the end of
      the input. Note that <literal>read_and_accumulate</literal> is a
      recursive function, invoking itself to read the next line, until
      the last line is reached.
    </para>
    <para>
      After <literal>read_and_accumulate</literal> returns, the total
      needs to be printed. This is done using the
      <literal>printf</literal> command, which provides support for
      type-safe format strings, similar to what you'll find in a variety
      of languages. The format string is parsed by the compiler and used
      to determine the number and type of the remaining arguments that
      are required for <literal>printf</literal>. In this case, there is
      a single formatting directive, <literal>%F</literal>, so
      <literal>printf</literal> expects one additional argument of type
      <literal>float</literal>.
    </para>
    <sect2 id="compiling-and-running">
      <title>Compiling and running</title>
      <para>
        We can use <literal>ocamlbuild</literal> to compile the program.
        We'll need to create a file, in the same directory as
        <literal>sum.ml</literal>, called <literal>_tags</literal>. We
        can put the following in <literal>_tags</literal> to indicate
        that we're building against Core, and that threads should be
        enabled, which is a required by Core.
      </para>
      <programlisting>
true:package(core),thread
</programlisting>
      <para>
        With our <literal>_tags</literal> file in place, we can build
        our executable by issuing this command.
      </para>
      <programlisting>
ocamlbuild -use-ocamlfind sum.native
</programlisting>
      <para>
        The <literal>.native</literal> suffix indicates that we're
        building a native-code executable, which we'll discuss more in
        Chapter {{{files-modules-and-programs}}}. Once the build
        completes, we can use the resulting program like any
        command-line utility. In this example, we can just type in a
        sequence of numbers, one per line, hitting control-d to exit
        when the input is complete.
      </para>
      <programlisting>
max $ ./sum.native
1
2
3
94.5
Total: 100.5
</programlisting>
      <para>
        More work is needed to make a really usable command-line
        programming, including a proper command-line parsing interface
        and better error handling.
      </para>
    </sect2>
  </sect1>
  <sect1 id="where-to-go-from-here">
    <title>Where to go from here</title>
    <para>
      That's it for our guided tour! There are plenty of features left
      to touch upon and lots of details to explain, but the hope is that
      this has given you enough of a feel for the language that you have
      a sense as to what to expect, and will be comfortable reading
      examples in the rest of the book.
    </para>
  </sect1>
</chapter>
<chapter id="variables-and-functions">
  <title>Variables and Functions</title>
  <para>
    Variables and functions are fundamental ideas that show up in
    virtually all programming languages. But OCaml has a different take
    on these basic concepts, and so we'll spend some time digging into
    the details of OCaml's variables and functions differ from what you
    may have seen elsewhere.
  </para>
  <sect1 id="variables">
    <title>Variables</title>
    <para>
      At its simplest, a variable is an identifier whose meaning is
      bound to a particular value. In OCaml these bindings are often
      introduced using the <literal>let</literal> keyword. When typed in
      at the prompt of the interpreter, a let binding has the following
      syntax.
    </para>
    <programlisting>
let &lt;identifier&gt; = &lt;expr&gt;
</programlisting>
    <para>
      As we'll see when we get to the module system in Chapter
      {{{files-modules-and-programs}}}, this same syntax is used for
      top-level definitions in a module.
    </para>
    <para>
      Every variable binding has a <emphasis>scope</emphasis>, which is
      the portion of the code that can refer to that binding. The scope
      of a top-level let binding is everything that follows it in the
      top-level session (or in the remainder of the module).
    </para>
    <para>
      Here's a simple example.
    </para>
    <programlisting>
# let x = 3;;
val x : int = 3
# let y = 4;;
val y : int = 4
# let z = x + y;;
val z : int = 7
</programlisting>
    <para>
      <literal>let</literal> can also be used to create a variable
      binding whose scope is limited to a particular expression, using
      the following syntax.
    </para>
    <programlisting>
let &lt;identifier&gt; = &lt;expr1&gt; in &lt;expr2&gt;
</programlisting>
    <para>
      This first evaluates <emphasis><literal>expr1</literal></emphasis>
      and then evaluates <emphasis><literal>expr2</literal></emphasis>
      with <emphasis><literal>identifier</literal></emphasis> bound to
      whatever value was produced by the evaluation of
      <emphasis><literal>expr1</literal></emphasis>. Here's how it looks
      in practice.
    </para>
    <programlisting>
# let languages = &quot;OCaml,Perl,C++,C&quot;;;
val languages : string = &quot;OCaml,Perl,C++,C&quot;
# let dashed_languages =
    let language_list = String.split languages ~on:',' in
    String.concat ~sep:&quot;-&quot; language_list
  ;;
val dashed_languages : string = &quot;OCaml-Perl-C++-C&quot;
</programlisting>
    <para>
      Note that the scope of <literal>language_list</literal> is just
      the expression
      <literal>String.concat ~sep:&quot;-&quot; language_list</literal>,
      and is not available at the top-level, as we can see if we try to
      access it now.
    </para>
    <programlisting>
# language_list;;
Characters 0-13:
  language_list;;
  ^^^^^^^^^^^^^
Error: Unbound value language_list
</programlisting>
    <para>
      A let binding in an inner scope can <emphasis>shadow</emphasis>,
      or hide, the definition from an outer scope. So, for example, we
      could have written the <literal>dashed_languages</literal> example
      as follows:
    </para>
    <programlisting>
# let languages = &quot;OCaml,Perl,C++,C&quot;;;
val languages : string = &quot;OCaml,Perl,C++,C&quot;
# let dashed_languages =
     let languages = String.split languages ~on:',' in
     String.concat ~sep:&quot;-&quot; languages
  ;;
val dashed_languages : Core.Std.String.t = &quot;OCaml-Perl-C++-C&quot;
</programlisting>
    <para>
      This time, in the inner scope we called the list of strings
      <literal>languages</literal> instead of
      <literal>language_list</literal>, thus hiding the original
      definition of <literal>languages</literal>. But once the
      definition of <literal>dashed_languages</literal> is complete, the
      inner scope has closed and the original definition of languages
      reappears.
    </para>
    <programlisting>
# languages;;
- : string = &quot;OCaml,Perl,C++,C&quot;
</programlisting>
    <para>
      One common idiom is to use a series of nested
      <literal>let</literal>/<literal>in</literal> expressions to build
      up the components of a larger computation. Thus, we might write:
    </para>
    <programlisting>
# let area_of_ring inner_radius outer_radius =
     let pi = acos (-1.) in
     let area_of_circle r = pi *. r *. r in
     area_of_circle outer_radius -. area_of_circle inner_radius
  ;;
# area_of_ring 1. 3.;;
- : float = 25.1327412287183449
</programlisting>
    <para>
      It's important not to confuse this sequence of let bindings with
      the modification of a mutable variable. How would
      <literal>area_of_ring</literal> be different, for example, if we
      had instead written this purposefully confusing bit of code:
    </para>
    <programlisting>
# let area_of_ring inner_radius outer_radius =
     let pi = acos (-1.) in
     let area_of_circle r = pi *. r *. r in
     let pi = 0. in
     area_of_circle outer_radius -. area_of_circle inner_radius
  ;;
</programlisting>
    <para>
      Here, we redefined <literal>pi</literal> to be zero after the
      definition of <literal>area_of_circle</literal>. You might think
      that this would mean that the result of the computation would now
      be zero, but you'd be wrong. In fact, the behavior of the function
      is unchanged. That's because the original definition of
      <literal>pi</literal> wasn't changed, it was just shadowed, so
      that any subsequent reference to <literal>pi</literal> would see
      the new definition of <literal>pi</literal> as zero. But there is
      no later use of <literal>pi</literal>, so the binding doesn't make
      a difference. Indeed, if you type the example I gave above into
      the toplevel, OCaml will warn you that the definition is unused.
    </para>
    <programlisting>
Characters 126-128:
    let pi = 0. in
        ^^
Warning 26: unused variable pi.
</programlisting>
    <para>
      In OCaml, let bindings are immutable. As we'll see in chapter
      {{{imperative-programming}}}, there are mutable values in OCaml,
      but no mutable variables.
    </para>
    <sect2 id="pattern-matching-and-let">
      <title>Pattern matching and <literal>let</literal></title>
      <para>
        Another useful feature of let bindings is that they support the
        use of patterns on the left-hand side of the bind. Consider the
        following code, which uses <literal>List.unzip</literal>, a
        function for converting a list of pairs into a pair of lists.
      </para>
      <programlisting>
# let (ints,strings) = List.unzip [(1,&quot;one&quot;); (2,&quot;two&quot;); (3,&quot;three&quot;)]
val ints : int list = [1; 2; 3]
val strings : string list = [&quot;one&quot;; &quot;two&quot;; &quot;three&quot;]
</programlisting>
      <para>
        This actually binds two variables, one for each element of the
        pair. Using a pattern in a let-binding makes the most sense for
        a pattern that is <emphasis>irrefutable</emphasis>,
        <emphasis>i.e.</emphasis>, where any value of the type in
        question is guaranteed to match the pattern. Tuple and record
        patterns are irrefutable, but list patterns are not. Consider
        the following code that implements a function for up-casing the
        first element of a comma-separate list.
      </para>
      <programlisting>
# let upcase_first_entry line =
     let (key :: values) = String.split ~on:',' line in
     String.concat ~sep:&quot;,&quot; (String.uppercase key :: values)
  ;;
      Characters 40-53:
       let (key :: values) = String.split ~on:',' line in
            ^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val upcase_first_entry : string -&gt; string = &lt;fun&gt;
</programlisting>
      <para>
        This case can't really come up in practice, because
        <literal>String.split</literal> always returns a list with at
        least one element. But the compiler doesn't know this, and so it
        emits the warning. It's generally better to use a match
        statement to handle such cases explicitly:
      </para>
      <programlisting>
# let upcase_first_entry line =
     match String.split ~on:',' line with
     | [] -&gt; assert false (* String.split returns at least one element *)
     | first :: rest -&gt; String.concat ~sep:&quot;,&quot; (String.uppercase first :: rest)
  ;;
val upcase_first_entry : string -&gt; string = &lt;fun&gt;
</programlisting>
    </sect2>
    <sect2 id="letand-bindings">
      <title><literal>let</literal>/<literal>and</literal>
      bindings</title>
      <para>
        Another variant on the let binding is the use of
        <literal>and</literal> to join multiple variable definitions
        into a single declaration. For example, we can write:
      </para>
      <programlisting>
# let x = 100 and y = 3.5;;
val x : int = 100
val y : float = 3.5
</programlisting>
      <para>
        This can be useful when you want to create a number of new let
        bindings at once, without having each definition affect the
        next. So, if we wanted to create new bindings that swapped the
        values of <literal>x</literal> and <literal>y</literal>, we
        could write:
      </para>
      <programlisting>
# let x = y and y = x ;;
val x : float = 3.5
val y : int = 100
</programlisting>
      <para>
        This use-case doesn't come up that often. Most of the time that
        <literal>and</literal> comes into play, it's used to define
        multiple mutually recursive values, which we'll learn about
        later in the chapter.
      </para>
      <para>
        Note that when doing a
        <literal>let</literal>/<literal>and</literal> style declaration,
        the order of execution of the right-hand side of the binds is
        undefined by the language definition, so one should not write
        code that relies on it.
      </para>
    </sect2>
  </sect1>
  <sect1 id="functions">
    <title>Functions</title>
    <para>
      OCaml being a functional language, it's no surprise that functions
      are an important and pervasive element of programming in OCaml.
      Indeed, we've seen functions pop up already in many of the
      examples we've looked at thus far. But while we've introduced the
      basics of functions, we're now going to cover them in more depth,
      starting from the foundations.
    </para>
    <sect2 id="anonymous-functions">
      <title>Anonymous Functions</title>
      <para>
        We'll start by looking at the most basic form of OCaml function,
        the <emphasis>anonymous</emphasis> function. Anonymous functions
        are declared using the <literal>fun</literal> keyword, as
        follows.
      </para>
      <programlisting>
# (fun x -&gt; x + 1);;
- : int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        Anonymous functions aren't named, but they can be used for many
        different purposes nonetheless. You can, for example, apply an
        anonymous function to an argument:
      </para>
      <programlisting>
# (fun x -&gt; x + 1) 7;;
- : int = 8
</programlisting>
      <para>
        Or pass it to another function.
      </para>
      <programlisting>
# List.map ~f:(fun x -&gt; x + 1) [1;2;3];;
- : int list = [2; 3; 4]
</programlisting>
      <para>
        Or even stuff then into a datastructure.
      </para>
      <programlisting>
# let increments = [ (fun x -&gt; x + 1); (fun x -&gt; x + 2) ] ;;
val increments : (int -&gt; int) list = [&lt;fun&gt;; &lt;fun&gt;]
# List.map ~f:(fun f -&gt; f 5) increments;;
- : int list = [6; 7]
</programlisting>
      <para>
        It's worth stopping for a moment to puzzle this example out,
        since this kind of higher-order use of functions can be a bit
        obscure at first. The first thing to understand is the function
        <literal>(fun f -&gt; f 5)</literal>, which takes a function as
        its argument and applies that function to the number
        <literal>5</literal>. The invocation of
        <literal>List.map</literal> applies
        <literal>(fun f -&gt; f 5)</literal> to the elements of the
        <literal>increments</literal> list (which are themselves
        functions) and returns the list containing the results of these
        function applications.
      </para>
      <para>
        The key thing to understand is that functions are ordinary
        values in OCaml, and you can do everything with them that you'd
        do with an ordinary value, including passing them to and
        returning them from other functions and storing them in
        datastructures. We even name functions in the same way that we
        name other values, by using a let binding.
      </para>
      <programlisting>
# let plusone = (fun x -&gt; x + 1);;
val plusone : int -&gt; int = &lt;fun&gt;
# plusone 3;;
- : int = 4
</programlisting>
      <para>
        Defining named functions is so common that there is some built
        in syntactic sugar for it. Thus, we can write:
      </para>
      <programlisting>
# let plusone x = x + 1;;
val plusone : int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This is the most common and convenient way to declare a
        function, but syntactic niceties aside, the two styles of
        function definition are entirely equivalent.
      </para>
      <sidebar>
      <title>
      <literal>let</literal> and <literal>fun</literal>
      </title>
      <para>
        Functions and let bindings have a lot to do with each other. In
        some sense, you can think of the argument of a function as a
        variable being bound to its argument. Indeed, the following two
        expressions are nearly equivalent:
      </para>
      <programlisting>
# (fun x -&gt; x + 1) 7;;
- : int = 8
# let x = 7 in x + 1;;
- : int = 8
</programlisting>
      <para>
        This connection is important, and will come up more when
        programming in a monadic style, as we'll see in chapter
        {{ASYNC}}.
      </para>
      </sidebar>
    </sect2>
    <sect2 id="multi-argument-functions">
      <title>Multi-argument functions</title>
      <para>
        OCaml of course also supports multi-argument functions. Here's
        an example that came up in chapter {{TOUR}}.
      </para>
      <programlisting>
# let abs_diff x y = abs (x - y);;
val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;
# abs_diff 3 4;;
- : int = 1
</programlisting>
      <para>
        You may find the type signature of <literal>abs_diff</literal>
        with all of its arrows a little hard to parse. To understand
        what's going on, let's rewrite <literal>abs_diff</literal> in an
        equivalent form, using the <literal>fun</literal> keyword:
      </para>
      <programlisting>
# let abs_diff =
    (fun x -&gt; (fun y -&gt; abs (x - y)));;
val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        This rewrite makes it explicit that <literal>abs_diff</literal>
        is actually a function of one argument that returns another
        function of one argument, which itself returns the final
        computation. Because the functions are nested, the inner
        expression <literal>abs (x - y)</literal> has access to both
        <literal>x</literal>, which was captured by the first function
        application, and <literal>y</literal>, which was captured by the
        second one.
      </para>
      <para>
        This style of function is called a <emphasis>curried</emphasis>
        function. (Currying is named after Haskell Curry, a famous
        logician who had a significant impact on the design and theory
        of programming languages.) The key to interpreting the type
        signature of a curried function is the observation that
        <literal>-&gt;</literal> is right-associative. The type
        signature of <literal>abs_diff</literal> can therefore be
        parenthesized as follows. This doesn't change the meaning of the
        signature, but it makes it easier to see how the currying fits
        in.
      </para>
      <programlisting>
val abs_diff : int -&gt; (int -&gt; int)
</programlisting>
      <para>
        Currying is more than just a theoretical curiosity. You can make
        use of currying to specialize a function by feeding in some of
        the arguments. Here's an example where we create a specialized
        version of <literal>abs_diff</literal> that measures the
        distance of a given number from <literal>3</literal>.
      </para>
      <programlisting>
# let dist_from_3 = abs_diff 3;;
val dist_from_3 : int -&gt; int = &lt;fun&gt;
# dist_from_3 8;;
- : int = 5
# dist_from_3 (-1);;
- : int = 4
</programlisting>
      <para>
        The practice of applying some of the arguments of a curried
        function to get a new function is called <emphasis>partial
        application</emphasis>.
      </para>
      <para>
        Note that the <literal>fun</literal> keyword supports its own
        syntactic sugar for currying, so we could also have written
        <literal>abs_diff</literal> as follows.
      </para>
      <programlisting>
# let abs_diff = (fun x y -&gt; abs (x - y));;
</programlisting>
      <para>
        You might worry that curried functions are terribly expensive,
        but this is not the case. In OCaml, there is no penalty for
        calling a curried function with all of its arguments. (Partial
        application, unsurprisingly, does have a small extra cost.)
      </para>
      <para>
        Currying is not the only way of writing a multi-argument
        function in OCaml. It's also possible to use the different arms
        of a tuple as different arguments. So, we could write:
      </para>
      <programlisting>
# let abs_diff (x,y) = abs (x - y)
val abs_diff : int * int -&gt; int = &lt;fun&gt;
# abs_diff (3,4);;
- : int = 1
</programlisting>
      <para>
        OCaml handles this calling convention efficiently as well. In
        particular it does not generally have to allocate a tuple just
        for the purpose of sending arguments to a tuple-style function.
      </para>
      <para>
        There are small tradeoffs between these two approaches, but most
        of the time, one should stick to currying, since it's the
        default style in the OCaml world.
      </para>
    </sect2>
    <sect2 id="recursive-functions">
      <title>Recursive functions</title>
      <para>
        In order to define a recursive function, you need to mark the
        let binding as recursive with the <literal>rec</literal>
        keyword, as shown in this example:
      </para>
      <programlisting>
# let rec find_first_stutter = function
     | [] | [_] -&gt;
       (* only zero or one elements, so no repeats *)
       None
     | x :: y :: tl -&gt;
       if x = y then Some x else find_first_stutter (y::tl)
val find_first_stutter : 'a list -&gt; 'a option = &lt;fun&gt;
</programlisting>
      <para>
        We can also define multiple mutually recursive values by using
        <literal>let rec</literal> and <literal>and</literal> together,
        as in this (gratuitously inefficient) example.
      </para>
      <programlisting>
# let rec is_even x =
    if x = 0 then true else is_odd (x - 1)
  and is_odd x =
    if x = 0 then false else is_even (x - 1)
 ;;
val is_even : int -&gt; bool = &lt;fun&gt;
val is_odd : int -&gt; bool = &lt;fun&gt;
# List.map ~f:is_even [0;1;2;3;4;5];;
- : bool Core.Std.List.t = [true; false; true; false; true; false]
# List.map ~f:is_odd [0;1;2;3;4;5];;
- : bool Core.Std.List.t = [false; true; false; true; false; true]
</programlisting>
      <para>
        Note that in the above example, we take advantage of the fact
        that the right hand side of <literal>||</literal> is evaluated
        lazily, only being executed if the left hand side evaluates to
        false.
      </para>
    </sect2>
    <sect2 id="prefix-and-infix-operators">
      <title>Prefix and Infix operators</title>
      <para>
        So far, we've seen examples of functions used in both prefix and
        infix style:
      </para>
      <programlisting>
# Int.max 3 4;;  (* prefix *)
- : int = 4
# 3 + 4;;        (* infix  *)
- : int = 7
</programlisting>
      <para>
        You might not have thought of the second example as an ordinary
        function, but it very much is. Infix operators like
        <literal>+</literal> really only differ syntactically from other
        functions. In fact, if we put parenthesis around an infix
        operator, you can use it as an ordinary prefix function.
      </para>
      <programlisting>
# (+) 3 4;;
- : int = 7
# List.map ~f:((+) 3) [4;5;6];;
- : int list = [7; 8; 9]
</programlisting>
      <para>
        In the second expression above, we've partially applied
        <literal>(+)</literal> to gain a function that increments its
        single argument by <literal>3</literal>, and then applied that
        to all the elements of a list.
      </para>
      <para>
        A function is treated syntactically as an operator if the name
        of that function is chosen from one of a specialized set of
        identifiers. This set includes any identifier that is a sequence
        of characters from the following set
      </para>
      <programlisting>
! $ % &amp; * + - . / : &lt; = &gt; ? @ ^ | ~
</programlisting>
      <para>
        or is one of a handful of pre-determined strings, including
        <literal>mod</literal>, the modulus operator, and
        <literal>lsl</literal>, for &quot;logical shift left&quot;, a
        bit-shifting operation.
      </para>
      <para>
        We can define (or redefine) the meaning of an operator as
        follows. Here's an example of a simple vector-addition operator
        on int pairs.
      </para>
      <programlisting>
# let (+!) (x1,y1) (x2,y2) = (x1 + x2, y1 + y2)
val ( +! ) : int * int -&gt; int * int -&gt; int *int = &lt;fun&gt;
# (3,2) +! (-2,4);;
- : int * int = (1,6)
</programlisting>
      <para>
        The syntactic role of an operator work is determined by its
        first character. This table describes how, and lists the
        operators from highest to lowest precedence.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec colwidth="26*" align="left" />
          <colspec colwidth="59*" align="left" />
          <thead>
            <row>
              <entry>
                First character
              </entry>
              <entry>
                Usage
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <literal>!</literal> <literal>?</literal>
                <literal>~</literal>
              </entry>
              <entry>
                Prefix and unary
              </entry>
            </row>
            <row>
              <entry>
                <literal>**</literal>
              </entry>
              <entry>
                Infix, right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>+</literal> <literal>-</literal>
              </entry>
              <entry>
                Infix, left associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>@</literal> <literal>^</literal>
              </entry>
              <entry>
                Infix, right associative
              </entry>
            </row>
            <row>
              <entry>
                <literal>=</literal> <literal>&lt;</literal>
                <literal>&gt;</literal> <literal>|</literal>
                <literal>&amp;</literal> <literal>$</literal>
              </entry>
              <entry>
                Infix, left associative
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        Here's an example of a very useful operator that's defined in
        Core, following these rules. Here's the definition:
      </para>
      <programlisting>
# let (|!) x f = f x ;;
val ( |! ) : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &lt;fun&gt;
</programlisting>
      <para>
        It's not quite obvious at first what the purpose of this
        operator is: it just takes some value and a function, and
        applies the function to the value. But its utility is clearer
        when you see it in action. It works as a kind of sequencing
        operator, similar in spirit to using pipe in the UNIX shell.
        Consider, for example, the following code for printing out the
        unique elements of your <literal>PATH</literal>.
      </para>
      <programlisting>
# Sys.getenv_exn &quot;PATH&quot;
  |! String.split ~on:':'
  |! List.dedup ~compare:String.compare
  |! List.iter ~f:print_endline
  ;;
/bin
/opt/local/bin
/usr/bin
/usr/local/bin
- : unit = ()
</programlisting>
      <para>
        An important part of what's happening here is partial
        application. Normally, <literal>List.iter</literal> takes two
        arguments: a function to be called on each element of the list,
        and the list to iterate over. We can call
        <literal>List.iter</literal> with all it's arguments:
      </para>
      <programlisting>
# List.iter ~f:print_endline [&quot;Two&quot;; &quot;lines&quot;];;
Two
lines
- : unit = ()
</programlisting>
      <para>
        Or, we can pass it just the function argument, leaving us with a
        function for printing out a list of strings.
      </para>
      <programlisting>
# List.iter ~f:print_endline;;
- : string list -&gt; unit = &lt;fun&gt;
</programlisting>
      <para>
        It is this later form that we're using in the
        <literal>|!</literal> pipeline above.
      </para>
      <para>
        Note that <literal>|!</literal> only works in the intended way
        because it is left-associative. Indeed, let's see what happens
        if we try using a right associative operator, like (^!).
      </para>
      <programlisting>
# let (^!) = (|!);;
val ( ^! ) : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &lt;fun&gt;
# Sys.getenv_exn &quot;PATH&quot;
  ^! String.split ~on:':'
  ^! List.dedup ~compare:String.compare
  ^! List.iter ~f:print_endline
  ;;
        Characters 93-119:
    ^! List.iter ~f:print_endline
       ^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: This expression has type string list -&gt; unit
       but an expression was expected of type
         (string list -&gt; string list) -&gt; 'a
</programlisting>
      <para>
        The above type error is a little bewildering at first glance.
        What's going on is that, because <literal>^!</literal> is right
        associative, the operator is trying to feed the value
        <literal>List.dedup ~compare:String.compare</literal> to the
        function <literal>List.iter ~f:print_endline</literal>. But
        <literal>List.iter ~f:print_endline</literal> expects a list of
        strings as its input, not a function.
      </para>
      <para>
        The type error aside, this example highlights the importance of
        choosing the operator you use with care, particularly with
        respect to associativity.
      </para>
    </sect2>
    <sect2 id="declaring-functions-with-function">
      <title>Declaring functions with
      <literal>function</literal></title>
      <para>
        Another way to define a function is using the
        <literal>function</literal> keyword. Instead of having syntactic
        support for declaring curried functions,
        <literal>function</literal> has built-in pattern matching.
        Here's an example:
      </para>
      <programlisting>
# let some_or_zero = function
     | Some x -&gt; x
     | None -&gt; 0
  ;;
val some_or_zero : int option -&gt; int = &lt;fun&gt;
# List.map ~f:some_or_zero [Some 3; None; Some 4];;
- : int list = [3; 0; 4]
</programlisting>
      <para>
        This is equivalent to combining a <literal>fun</literal> with
        <literal>match</literal>, as follows:
      </para>
      <programlisting>
# let some_or_zero num_opt =
    match num_opt with
    | Some x -&gt; x
    | None -&gt; 0
  ;;
val some_or_zero : int option -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        We can also combine the different styles of function declaration
        together, as in the following example where we declare a two
        argument function with a pattern-match on the second argument.
      </para>
      <programlisting>
# let some_or_default default = function
     | Some x -&gt; x
     | None -&gt; default
  ;;
# List.map ~f:(some_or_default 100) [Some 3; None; Some 4];;
- : int Core.Std.List.t = [3; 100; 4]
</programlisting>
      <para>
        Also, note the use of partial application to generate the
        function passed to <literal>List.map</literal>
      </para>
    </sect2>
    <sect2 id="labeled-arguments">
      <title>Labeled Arguments</title>
      <para>
        Up until now, we've written functions where the arguments are
        specified positionally, <emphasis>i.e.</emphasis>, by the order
        in which the arguments are passed to the function. OCaml also
        supports labeled arguments, which let you identify a function
        argument by name. Labeled arguments are declared by putting a
        tilde in front of the label.
      </para>
      <programlisting>
# let f ~foo:a ~bar:b = a + b;;
val f : foo:int -&gt; bar:int -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        We can then provide a labeled argument using a similar
        convention. As you can see, the arguments can be provided in any
        order.
      </para>
      <programlisting>
# f ~foo:3 ~bar:10;;
- : int = 13
# f ~bar:10 ~foo:3;;
- : int = 13
</programlisting>
      <para>
        OCaml also supports <emphasis>label punning</emphasis>, meaning
        that you get to drop the text after the <literal>:</literal> if
        the name of the label and the name of the variable being used
        are the same. Label punning works in both function declaration
        and function invocation, as shown in these examples:
      </para>
      <programlisting>
# let foo = 3;;
# let bar = 4;;
# f ~foo ~bar;;
- : int = 7
</programlisting>
      <para>
        Labeled arguments are useful in a few different cases:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            When defining a function with lots of arguments. Beyond a
            certain number, arguments are easier to remember by name
            than by position.
          </para>
        </listitem>
        <listitem>
          <para>
            When defining functions that have multiple arguments that
            might get confused with each other. This is most at issue
            when the arguments are of the same type. For example,
            consider this signature for a function for extracting a
            substring of another string.
          </para>
          <programlisting language="ocaml">
val substring: string -&gt; int -&gt; int -&gt; string
</programlisting>
          <para>
            where the two ints are the starting position and length of
            the substring to extract. Labeled arguments can make this
            signature clearer:
          </para>
          <programlisting language="ocaml">
val substring: string -&gt; pos:int -&gt; len:int -&gt; string
</programlisting>
          <para>
            This improves the readability of both the signature and of
            client code that makes use of <literal>substring</literal>,
            and makes it harder to accidentally swap the position and
            the length.
          </para>
        </listitem>
        <listitem>
          <para>
            When the meaning of a particular argument is unclear from
            the type alone. For example, consider a function for
            creating a hashtable where the first argument is the initial
            size of the table, and the second argument is a flag which,
            when true, indicates that the hashtable will reduce its size
            when the hashtable contains few elements. The following
            signature doesn't give you much of a hint as to the meaning
            of the arguments.
          </para>
          <programlisting language="ocaml">
val create_hashtable : int -&gt; bool -&gt; ('a,'b) Hashtable.t
</programlisting>
          <para>
            but with labeled arguments, we can make the intent much
            clearer.
          </para>
          <programlisting language="ocaml">
val create_hashtable : init_size:int -&gt; allow_shrinking:bool -&gt; ('a,'b) Hashtable.t
</programlisting>
        </listitem>
        <listitem>
          <para>
            When you want flexibility on the order in which arguments
            are passed. Consider a function like
            <literal>List.iter</literal>, that takes two arguments: a
            function, and a list of elements to call that function on. A
            common pattern is to partially apply
            <literal>List.iter</literal> by giving it just the function,
            as in the following example from earlier in the chapter.
            This requires putting the function argument first.
          </para>
          <programlisting>
# Sys.getenv_exn &quot;PATH&quot;
  |! String.split ~on:':'
  |! List.dedup ~compare:String.compare
  |! List.iter ~f:print_endline
  ;;
</programlisting>
          <para>
            In other cases, you want to put the function argument
            second. One common reason is readability. In particular, a
            function that spans multiple lines is easiest to read when
            it's the last argument provided.
          </para>
        </listitem>
      </itemizedlist>
      <sect3 id="higher-order-functions-and-labels">
        <title>Higher-order functions and labels</title>
        <para>
          One surprising gotcha with labeled arguments is that while
          order doesn't matter when calling a function with labeled
          arguments, it does matter in a higher-order context,
          <emphasis>e.g.</emphasis>, when passing a function with
          labeled arguments to another function. Here's an example.
        </para>
        <programlisting>
# let apply_to_tuple f (first,second) = f ~first ~second;;
val apply_to_tuple : (first:'a -&gt; second:'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c = &lt;fun&gt;
</programlisting>
        <para>
          Here, the definition of <literal>apply_to_tuple</literal> sets
          up the expectation that its first argument is a function with
          two labeled arguments, <literal>first</literal> and
          <literal>second</literal>, listed in that order. We could have
          defined <literal>apply_to_tuple</literal> differently to
          change the order in which the labeled arguments were listed.
        </para>
        <programlisting>
# let apply_to_tuple f (first,second) = f ~second ~first;;
val apply_to_tuple : (second:'a -&gt; first:'b -&gt; 'c) -&gt; 'b * 'a -&gt; 'c = &lt;fun&gt;
</programlisting>
        <para>
          It turns out this order of listing matters. In particular, if
          we define a function that has a different order
        </para>
        <programlisting>
# let divide ~first ~second = first / second;;
val divide : first:int -&gt; second:int -&gt; int = &lt;fun&gt;
</programlisting>
        <para>
          we'll find that it can't be passed in to
          <literal>apply_to_tuple</literal>.
        </para>
        <programlisting>
# apply_to_tuple divide (3,4);;
Characters 15-21:
  apply_to_tuple divide (3,4);;
                 ^^^^^^
Error: This expression has type first:int -&gt; second:int -&gt; int
       but an expression was expected of type second:'a -&gt; first:'b -&gt; 'c
</programlisting>
        <para>
          But, if we go back to the original definition of
          <literal>apply_to_tuple</literal>, things will work smoothly.
        </para>
        <programlisting>
# let apply_to_tuple f (first,second) = f ~first ~second;;
val apply_to_tuple : (first:'a -&gt; second:'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c = &lt;fun&gt;
# apply_to_tuple divide (3,4);;
- : int = 0
</programlisting>
        <para>
          So, even though the order of labeled arguments usually doesn't
          matter, it will sometimes bite you in higher-ordered contexts,
          where you're doing things like passing functions as arguments
          to other functions.
        </para>
      </sect3>
    </sect2>
    <sect2 id="optional-arguments">
      <title>Optional arguments</title>
      <para>
        An optional argument is like a labeled argument that the caller
        can choose whether or not to provide. Optional arguments are
        passed in using the same syntax as labeled arguments, and,
        similarly to labeled arguments, optional arguments can be
        provided in any order.
      </para>
      <para>
        Here's an example of a string concatenation function with an
        optional separator.
      </para>
      <programlisting>
# let concat ?sep x y =
     let sep = match sep with None -&gt; &quot;&quot; | Some x -&gt; x in
     x ^ sep ^ y
  ;;
val concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
# concat &quot;foo&quot; &quot;bar&quot;;;             (* without the optional argument *)
- : string = &quot;foobar&quot;
# concat ~sep:&quot;:&quot; &quot;foo&quot; &quot;bar&quot;;;    (* with the optional argument    *)
- : string = &quot;foo:bar&quot;
</programlisting>
      <para>
        Here, <literal>?</literal> is used to mark
        <literal>sep</literal> as optional. And while the caller can
        pass a value of type <literal>string</literal> for
        <literal>sep</literal>, internally to the function,
        <literal>sep</literal> is seen as a
        <literal>string option</literal>, with <literal>None</literal>
        appearing when <literal>sep</literal> is not provided by the
        caller.
      </para>
      <para>
        In the above example, we had a bit of code to substitute in the
        empty string when no argument was provided. This is a common
        enough pattern that there's an explicit syntax for providing a
        default value, which allows us to write
        <literal>concat</literal> even more concisely.
      </para>
      <programlisting>
# let concat ?(sep=&quot;&quot;) x y = x ^ sep ^ y ;;
val concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
</programlisting>
      <para>
        Optional arguments are very useful, but they're also easy to
        abuse. The key advantage of optional arguments is that they let
        you write functions with multiple arguments that users can
        ignore most of the time, only worrying about them when they
        specifically want to invoke those options.
      </para>
      <para>
        The downside is that the caller may be unaware that there is a
        choice to be made, and so may unknowingly (and wrongly) pick
        that default behavior. Optional arguments really only make sense
        when the extra concision of omitting the argument overwhelms the
        corresponding loss of explicitness.
      </para>
      <para>
        This means that rarely used functions should not have optional
        arguments. A good rule of thumb for optional arguments is that
        you should never use an optional argument for internal functions
        of a module, only for functions that are exposed as part of the
        module's interface.
      </para>
      <sect3 id="explicit-passing-of-an-optional-argument">
        <title>Explicit passing of an optional argument</title>
        <para>
          Under the covers, a function with an optional argument
          receives <literal>None</literal> when the caller doesn't
          provide the argument, and <literal>Some</literal> when it
          does. But the <literal>Some</literal> and
          <literal>None</literal> are normally not explicitly passed in
          by the caller.
        </para>
        <para>
          But sometimes, passing in <literal>Some</literal> or
          <literal>None</literal> explicitly is exactly what you want.
          OCaml lets you do this by using <literal>?</literal> instead
          of <literal>~</literal> to mark the argument. Thus, the
          following two lines are equivalent ways of specifying the
          <literal>sep</literal> argument to concat.
        </para>
        <programlisting>
# concat ~sep:&quot;:&quot; &quot;foo&quot; &quot;bar&quot;;; (* provide the optional argument *)
- : string = &quot;foo:bar&quot;
# concat ?sep:(Some &quot;:&quot;) &quot;foo&quot; &quot;bar&quot;;; (* pass an explicit [Some] *)
- : string = &quot;foo:bar&quot;
</programlisting>
        <para>
          And the following two lines are equivalent ways of calling
          <literal>concat</literal> without specifying
          <literal>sep</literal>.
        </para>
        <programlisting>
# concat &quot;foo&quot; &quot;bar&quot;;; (* don't provide the optional argument *)
- : string = &quot;foobar&quot;
# concat ?sep:None &quot;foo&quot; &quot;bar&quot;;; (* explicitly pass `None` *)
- : string = &quot;foobar&quot;
</programlisting>
        <para>
          One use-case for this is when you want to define a wrapper
          function that mimics the optional arguments of the function
          it's wrapping. For example, imagine we wanted to create a
          function called <literal>uppercase_concat</literal>, which is
          the same as <literal>concat</literal> except that it converts
          the first string that it's passed to uppercase. We could write
          the function as follows.
        </para>
        <programlisting>
# let uppercase_concat ?(sep=&quot;&quot;) a b = concat ~sep (String.uppercase a) b ;;
val uppercase_concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
# uppercase_concat &quot;foo&quot; &quot;bar&quot;;;
- : string = &quot;FOObar&quot;
# uppercase_concat &quot;foo&quot; &quot;bar&quot; ~sep:&quot;:&quot;;;
- : string = &quot;FOO:bar&quot;
</programlisting>
        <para>
          In the way we've written it, we've been forced to separately
          make the decision as to what the default separator is. Thus,
          if we later change <literal>concat</literal>'s default
          behavior, we'll need to remember to change
          <literal>uppercase_concat</literal> to match it.
        </para>
        <para>
          Instead, we can have <literal>uppercase_concat</literal>
          simply pass through the optional argument to
          <literal>concat</literal> using the <literal>?</literal>
          syntax.
        </para>
        <programlisting>
# let uppercase_concat ?sep a b = concat ?sep (String.uppercase a) b ;;
val uppercase_concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;
</programlisting>
        <para>
          Now, if someone calls <literal>uppercase_concat</literal>
          without an argument, an explicit <literal>None</literal> will
          be passed to <literal>concat</literal>, leaving
          <literal>concat</literal> to decide what the default behavior
          should be.
        </para>
      </sect3>
      <sect3 id="inference-of-labeled-and-optional-arguments">
        <title>Inference of labeled and optional arguments</title>
        <para>
          <emphasis>(yminsky: This is too abstract of an
          example.)</emphasis>
        </para>
        <para>
          One subtle aspect of labeled and optional arguments is how
          they are inferred by the type system. Consider the following
          example:
        </para>
        <programlisting language="ocaml">
# let foo g x y = g ~x ~y ;;
val foo : (x:'a -&gt; y:'b -&gt; 'c) -&gt; 'a -&gt; 'b -&gt; 'c = &lt;fun&gt;
</programlisting>
        <para>
          In principle, it seems like the inferred type of
          <literal>g</literal> could have its labeled arguments listed
          in a different order, such as:
        </para>
        <programlisting language="ocaml">
val foo : (y:'b -&gt; x:'a -&gt; 'c) -&gt; 'a -&gt; 'b -&gt; 'c = &lt;fun&gt;
</programlisting>
        <para>
          And it would be perfectly consistent for <literal>g</literal>
          to take an optional argument instead of a labeled one, which
          could lead to this type signature for <literal>foo</literal>:
        </para>
        <programlisting language="ocaml">
val foo : (?x:'a -&gt; y:'b -&gt; 'c) -&gt; 'a -&gt; 'b -&gt; 'c = &lt;fun&gt;
</programlisting>
        <para>
          Since there are multiple plausible types to choose from, OCaml
          needs some heuristic for choosing between them. The heuristic
          the compiler uses is to prefer labels to options, and to
          choose the order of arguments that shows up in the source
          code.
        </para>
        <para>
          Note that these heuristics might at different points in the
          source suggest different types. For example, here's a function
          whose argument <literal>g</literal> is a function that is used
          once with argument <literal>~x</literal> followed by
          <literal>~y</literal>, and once with argument
          <literal>~y</literal> followed by <literal>~x</literal>. The
          result of this is a compilation error.
        </para>
        <programlisting language="ocaml">
# let bar g x y = g ~x ~y + g ~y ~x ;;
Characters 26-27:
  let bar g x y = g ~x ~y + g ~y ~x ;;
                            ^
Error: This function is applied to arguments
in an order different from other calls.
This is only allowed when the real type is known.
</programlisting>
        <para>
          Note that if we provide an explicit type constraint for
          <literal>g</literal>, that constraint decides the question of
          what <literal>g</literal>'s type is, and the error disappears.
        </para>
        <programlisting language="ocaml">
# let foo (g : ?y:'a -&gt; x:'b -&gt; int) x y =
    g ~x ~y + g ~y ~x ;;
val foo : (?y:'a -&gt; x:'b -&gt; int) -&gt; 'b -&gt; 'a -&gt; int = &lt;fun&gt;
</programlisting>
        <para>
          Here, our type annotation,
          <literal>?y:'a -&gt; x:'b -&gt; int</literal>, indicates that
          <literal>foo</literal> has an optional argument
          <literal>y</literal> followed by a labeled argument
          <literal>x</literal>, where <literal>y</literal> and
          <literal>x</literal> are potentially polymorphic, hence the
          type variables <literal>'a</literal> and
          <literal>'b</literal>. This annotation nails down the order of
          the arguments of <literal>g</literal>, and thus allows the
          compiler to successfully infer a type for
          <literal>foo</literal>, despite the fact that it uses
          <literal>g</literal> in ways that suggest two different
          argument orders.
        </para>
      </sect3>
      <sect3 id="optional-arguments-and-partial-application">
        <title>Optional arguments and partial application</title>
        <para>
          Optional arguments can be tricky to think about in the
          presence of partial application. We can of course partially
          apply the optional argument itself:
        </para>
        <programlisting>
# let colon_concat = concat ~sep:&quot;:&quot;;;
val colon_concat : string -&gt; string -&gt; string = &lt;fun&gt;
# colon_concat &quot;a&quot; &quot;b&quot;;;
- : string = &quot;a:b&quot;
</programlisting>
        <para>
          But what happens if we partially apply just the first
          argument?
        </para>
        <programlisting>
# let prepend_pound = concat &quot;# &quot;;;
val prepend_pound : string -&gt; string = &lt;fun&gt;
# prepend_pound &quot;a BASH comment&quot;;;
- : string = &quot;# a BASH comment&quot;
</programlisting>
        <para>
          Note that the optional argument <literal>?sep</literal> has
          now disappeared, or <emphasis>erased</emphasis>. So when does
          OCaml decide to erase an optional argument?
        </para>
        <para>
          The rule is: an optional argument is erased as soon as the
          first positional argument defined <emphasis>after</emphasis>
          the optional argument is passed in. That explains the behavior
          of <literal>prepend_pound</literal> above. But if we had
          instead defined <literal>concat</literal> with the optional
          argument in the second position:
        </para>
        <programlisting>
# let concat x ?(sep=&quot;&quot;) y = x ^ sep ^ y ;;
val concat : string -&gt; ?sep:string -&gt; string -&gt; string = &lt;fun&gt;
</programlisting>
        <para>
          then application of the first argument would not cause the
          optional argument to be erased.
        </para>
        <programlisting>
# let prepend_pound = concat &quot;# &quot;;;
val prepend_pound : ?sep:string -&gt; string -&gt; string = &lt;fun&gt;
# prepend_pound &quot;a BASH comment&quot;;;
- : string = &quot;# a BASH comment&quot;
# prepend_pound &quot;a BASH comment&quot; ~sep:&quot;--- &quot;;;
- : string = &quot;# --- a BASH comment&quot;
</programlisting>
        <para>
          However, if all arguments to a function are presented at once,
          then erasure of optional arguments isn't applied until all of
          the arguments are passed in. This preserves our ability to
          pass in optional arguments anywhere on the argument list.
          Thus, we can write:
        </para>
        <programlisting>
# concat &quot;a&quot; &quot;b&quot; ~sep:&quot;=&quot;;;
- : string = &quot;a=b&quot;
</programlisting>
        <para>
          An optional argument that doesn't have any following
          positional arguments can't be erased at all, which leads to a
          compiler warning.
        </para>
        <programlisting>
# let concat x y ?(sep=&quot;&quot;) = x ^ sep ^ y ;;
Characters 15-38:
  let concat x y ?(sep=&quot;&quot;) = x ^ sep ^ y ;;
                 ^^^^^^^^^^^^^^^^^^^^^^^
Warning 16: this optional argument cannot be erased.
val concat : string -&gt; string -&gt; ?sep:string -&gt; string = &lt;fun&gt;
</programlisting>
        <para>
          And indeed, when we provide the two positions arguments, the
          <literal>sep</literal> argument is not erased, instead
          returning a function that expects the <literal>sep</literal>
          argument to be provided.
        </para>
        <programlisting>
# concat &quot;a&quot; &quot;b&quot;;;
- : ?sep:string -&gt; string = &lt;fun&gt;
</programlisting>
      </sect3>
    </sect2>
  </sect1>
</chapter>
<chapter id="lists-options-and-patterns">
  <title>Lists, Options and Patterns</title>
  <para>
    <emphasis>(Note, this chapter is incomplete. jyh is working on
    it.)</emphasis>
  </para>
  <sect1 id="lists-1">
    <title>Lists</title>
    <para>
      As with any programming language, we need a way to represent
      <emphasis>data</emphasis>, things like numbers, words, images,
      etc., and we need a way to define <emphasis>aggregates</emphasis>
      that bring together related values that represent some concept.
    </para>
    <para>
      Lists are one of the most common ways to aggregate data in OCaml;
      they are simple, and they are extensively supported by the
      standard library.
    </para>
    <sect2 id="example-pretty-printing-a-table">
      <title>Example: pretty-printing a table</title>
      <para>
        One common programming task is displaying tabular data. In this
        example, we will go over the design of a simple library to do
        just that.
      </para>
      <para>
        We'll start with the interface. The code will go in a new module
        called <literal>Text_table</literal> whose
        <literal>.mli</literal> contains just the following function:
      </para>
      <programlisting language="ocaml">
(* [render headers rows] returns a string containing a formatted
   text table, using Unix-style newlines as separators *)
val render
   :  string list         (* header *)
   -&gt; string list list    (* data *)
   -&gt; string
</programlisting>
      <para>
        If you invoke <literal>render</literal> as follows:
      </para>
      <programlisting language="ocaml">
let () =
  print_string (Text_table.render
     [&quot;language&quot;;&quot;architect&quot;;&quot;first release&quot;]
     [ [&quot;Lisp&quot; ;&quot;John McCarthy&quot; ;&quot;1958&quot;] ;
       [&quot;C&quot;    ;&quot;Dennis Ritchie&quot;;&quot;1969&quot;] ;
       [&quot;ML&quot;   ;&quot;Robin Milner&quot;  ;&quot;1973&quot;] ;
       [&quot;OCaml&quot;;&quot;Xavier Leroy&quot;  ;&quot;1996&quot;] ;
     ])
</programlisting>
      <para>
        you'll get the following output:
      </para>
      <programlisting>
| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |
</programlisting>
      <para>
        Now that we know what <literal>render</literal> is supposed to
        do, let's dive into the implementation.
      </para>
      <sect3 id="computing-the-widths">
        <title>Computing the widths</title>
        <para>
          To render the rows of the table, we'll first need the width of
          the widest entry in each column. The following function does
          just that.
        </para>
        <programlisting language="ocaml">
let max_widths header rows =
  let to_lengths l = List.map ~f:String.length l in
  List.fold rows
    ~init:(to_lengths header)
    ~f:(fun acc row -&gt;
      List.map2_exn ~f:Int.max acc (to_lengths row))
</programlisting>
        <para>
          In the above we define a helper function,
          <literal>to_lengths</literal> which uses
          <literal>List.map</literal> and
          <literal>String.length</literal> to convert a list of strings
          to a list of string lengths. Then, starting with the lengths
          of the headers, we use <literal>List.fold</literal> to join in
          the lengths of the elements of each row by
          <literal>max</literal>'ing them together element-wise.
        </para>
        <para>
          Note that this code will throw an exception if any of the rows
          has a different number of entries than the header. In
          particular, <literal>List.map2_exn</literal> throws an
          exception when its arguments have mismatched lengths.
        </para>
      </sect3>
      <sect3 id="rendering-the-rows">
        <title>Rendering the rows</title>
        <para>
          Now we need to write the code to render a single row. There
          are really two different kinds of rows that need to be
          rendered; an ordinary row:
        </para>
        <programlisting>
| Lisp     | John McCarthy  | 1962          |
</programlisting>
        <para>
          and a separator row:
        </para>
        <programlisting>
|----------+----------------+---------------|
</programlisting>
        <para>
          Let's start with the separator row, which we can generate as
          follows:
        </para>
        <programlisting language="ocaml">
let render_separator widths =
  let pieces = List.map widths
    ~f:(fun w -&gt; String.make (w + 2) '-')
  in
  &quot;|&quot; ^ String.concat ~sep:&quot;+&quot; pieces ^ &quot;|&quot;
</programlisting>
        <para>
          We need the extra two-characters for each entry to account for
          the one character of padding on each side of a string in the
          table.
        </para>
        <sidebar>
        <title>
        Performance of <literal>String.concat</literal> and
        <literal>^</literal>
        </title>
        <para>
          In the above, we're using two different ways of concatenating
          strings, <literal>String.concat</literal>, which operates on
          lists of strings, and <literal>^</literal>, which is a
          pairwise operator. You should avoid <literal>^</literal> for
          joining long numbers of strings, since, it allocates a new
          string every time it runs. Thus, the following code:
        </para>
        <programlisting language="ocaml">
let s = &quot;.&quot; ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;
</programlisting>
        <para>
          will allocate a string of length 2, 3, 4, 5, 6 and 7, whereas
          this code:
        </para>
        <programlisting language="ocaml">
let s = String.concat [&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;]
</programlisting>
        <para>
          allocates one string of size 7, as well as a list of length 7.
          At these small sizes, the differences don't amount to much,
          but for assembling of large strings, it can be a serious
          performance issue.
        </para>
        </sidebar>
        <para>
          We can write a very similar piece of code for rendering the
          data in an ordinary row.
        </para>
        <programlisting language="ocaml">
let pad s length =
  if String.length s &gt;= length then s
  else s ^ String.make (length - String.length s) ' '

let render_row row widths =
  let pieces = List.map2 row widths
    ~f:(fun s width -&gt; &quot; &quot; ^ pad s width ^ &quot; &quot;)
  in
  &quot;|&quot; ^ String.concat ~sep:&quot;|&quot; pieces ^ &quot;|&quot;
</programlisting>
        <para>
          You might note that <literal>render_row</literal> and
          <literal>render_separator</literal> share a bit of structure.
          We can improve the code a bit by factoring that repeated
          structure out:
        </para>
        <programlisting language="ocaml">
let decorate_row ~sep row = &quot;|&quot; ^ String.concat ~sep row ^ &quot;|&quot;

let render_row widths row =
  decorate_row ~sep:&quot;|&quot;
    (List.map2_exn row widths ~f:(fun s w -&gt; &quot; &quot; ^ pad s w ^ &quot; &quot;))

let render_separator widths =
  decorate_row ~sep:&quot;+&quot;
    (List.map widths ~f:(fun width -&gt; String.make (width + 2) '-'))
</programlisting>
        <para>
          And now we can write the function for rendering a full table.
        </para>
        <programlisting language="ocaml">
let render header rows =
  let widths = max_widths header rows in
  String.concat ~sep:&quot;\n&quot;
    (render_row widths header
     :: render_separator widths
     :: List.map rows ~f:(fun row -&gt; render_row widths row)
    )
</programlisting>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="list-basics">
    <title>List basics</title>
    <para>
      In the example, we see calls to <literal>List</literal> functions
      in the standard library, in particular
      <literal>List.map</literal>. How does this all work? To
      understand, we need to consider first how lists are
      <emphasis>represented</emphasis> internally, which follows from
      the type definition and the way lists are constructed. Let's look
      at the constructors first.
    </para>
    <para>
      We have seen how square brackets can be used to construct a list
      of values, but there are really just two ways to construct a list
      value.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          [] is the <emphasis>empty</emphasis> list.
        </para>
      </listitem>
      <listitem>
        <para>
          If <literal>x</literal> is a value and <literal>l</literal> is
          a list, then the expression <literal>x :: l</literal>
          constructs a new list where the first element is
          <literal>x</literal>, and the rest is <literal>l</literal>.
          The value corresponding to <literal>x :: l</literal> is
          commonly called a <emphasis>cons</emphasis>-cell (the term
          comes from Lisp, where <emphasis>cons</emphasis> is short for
          &quot;constructor&quot;).
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The bracket syntax <literal>[5; 3; 7]</literal> is syntactic sugar
      for a list with 3 cons-cells,
      <literal>5 :: 3 :: 7 :: []</literal>. Each cell has two parts: 1)
      a value, and 2) a pointer to the rest of the list. The final
      pointer refers to the special value <literal>[]</literal>
      representing the empty list.
    </para>
    <figure>
      <title>List</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="figures/04-list-01.svg" />
        </imageobject>
        <textobject><phrase>List</phrase></textobject>
      </mediaobject>
    </figure>
  </sect1>
  <sect1 id="pattern-matching">
    <title>Pattern matching</title>
    <para>
      Constructing a list is really only half the story -- it would be
      pretty useless to construct lists unless we can also pull them
      apart. We need <emphasis>destructors</emphasis>, and for this we
      use <emphasis>pattern matching</emphasis>, like we saw in the
      previous chapter.
    </para>
    <para>
      For a list, there are two possible shapes: the empty list
      <literal>[]</literal> or a cons-cell <literal>h :: t</literal>. We
      can use a <literal>match</literal> expression to perform the
      pattern matching. In the case of a cons-cell, the variables
      <literal>h</literal> and <literal>t</literal> in the pattern are
      bound to the corresponding values in the list when the match is
      performed.
    </para>
    <para>
      For example, suppose we want to define a function to add 1 to each
      element of a list. We have to consider both cases, 1) where the
      list is empty, or 2) where it is a cons-cell.
    </para>
    <programlisting>
# let rec add1 l =
    match l with
     | [] -&gt; []
     | h :: t -&gt; (h + 1) :: (add1 t);;
val add1 : int list -&gt; int list = &lt;fun&gt;
# add1 [5; 3; 7];;
- : int list = [6; 4; 8]
</programlisting>
    <para>
      The functions in the standard library can implemented in similar
      ways. A straightforward, but inefficient, version of the
      <literal>List.map</literal> function is as follows.
    </para>
    <programlisting language="ocaml">
# let rec map l ~f =
    match l with
     | [] -&gt; []
     | h :: t -&gt; f h :: map ~f t;;
val map : 'a list -&gt; f:('a -&gt; 'b) -&gt; 'b list = &lt;fun&gt;
# map ~f:string_of_int [5; 3; 7];;
- : string list = [&quot;5&quot;; &quot;3&quot;; &quot;7&quot;]
</programlisting>
  </sect1>
  <sect1 id="list-performance">
    <title>List performance</title>
    <para>
      Lists are ubiquitous in OCaml programs. They are easy to use and
      reasonably efficient for small lists, but large lists can have
      significant performance problems. The issue is that lists are
      formed from separately allocated cons-cells. This has space
      overhead because each value in the list is paired with a pointer
      to the rest of the list. The separate allocation also reduces
      locality, so it can result in poor cache behavior.
    </para>
    <para>
      Perhaps more important than those concerns is that naive list
      traversal takes time linear in the length of the list. For
      example, the following <literal>length</literal> function takes
      linear time to count the number of elements in the list.
    </para>
    <programlisting language="ocaml">
let rec length = function [] -&gt; 0 | _ :: t -&gt; (length t) + 1;;
</programlisting>
    <para>
      In fact, this implementation of the function
      <literal>length</literal> is worse than that, because the function
      is recursive. In this implementation of the function, the
      recursive call to <literal>length t</literal> is active at the
      same time as the outer call, with the result that the runtime
      needs to allocate stack frames for each recursive call, so this
      function also takes linear space. For large lists, this is not
      only inefficient, it can also result in stack overflow.
    </para>
    <sect2 id="tail-recursion">
      <title>Tail-recursion</title>
      <para>
        We can't do anything about <literal>length</literal> taking
        linear time -- singly-linked lists of this kind don't have an
        efficient <literal>length</literal> operation. However, we can
        address the space problem using <emphasis>tail
        recursion</emphasis>.
      </para>
      <para>
        Tail recursion occurs whenever the result of the recursive call
        is returned immediately by the calling function. In this case,
        the compiler optimizes the call by skipping the allocation of a
        new stack frame, instead branching directly to the called
        procedure.
      </para>
      <para>
        In the definition of <literal>length</literal> above, the
        expression containing the recursive call
        <literal>(length t) + 1</literal> is <emphasis>not</emphasis>
        tail recursive because 1 is added to the result. However, it is
        easy to transform the function so that it is properly tail
        recursive.
      </para>
      <programlisting language="ocaml">
let length l =
  let rec tail_recursive_length len = function
    | [] -&gt; len
    | _ :: t -&gt; tail_recursive_length (len + 1) t
  in tail_recursive_length 0 l;;
</programlisting>
      <para>
        To preserve the type of the <literal>length</literal> function,
        we hide the tail-recursive implementation by nesting it. The
        tail-recursive implementation performs the addition
        <emphasis>before</emphasis> the recursive call, instead of
        afterwards. Since the result of the recursive call is returned
        without modification, the compiler branches directly to the
        called procedure rather than allocating a new stack frame.
      </para>
      <para>
        In other cases, it can be more problematic to use
        tail-recursion. For example, consider the non tail-recursive
        implemenation of <literal>map</literal> function, listed above.
        The code is simple, but not efficient.
      </para>
      <programlisting language="ocaml">
let rec map f = function
 | [] -&gt; []
 | h :: t -&gt; f h :: map f t;;
</programlisting>
      <para>
        If we use the same trick as we used for the
        <literal>length</literal> method, we need to accumulate the
        result <emphasis>before</emphasis> the recursive call, but this
        collects the result in reverse order. One way to address it is
        to construct the reserved result, then explicitly correct it
        before returning.
      </para>
      <programlisting language="ocaml">
let rev l =
  let rec tail_recursive_rev result = function
   | [] -&gt; result
   | h :: t -&gt; tail_recursive_rev (h :: result) t
  in tail_recursive_rev [] l;;

let rev_map l ~f =
  let rec rmap accu = function
   | [] -&gt; accu
   | h :: t -&gt; rmap (f h :: accu) l
  in rmap [] l;;

let map l ~f = rev (rev_map l ~f);;
</programlisting>
      <para>
        The functions <literal>tail_recursive_rev</literal> and
        <literal>rev_map</literal> are both tail-recursive, which means
        that the function <literal>map</literal> is tail-recursive also.
        The cost of doing so is that we construct an intermediate
        reversed list that is immediately discarded. One way to think of
        it is that instead of allocating a linear number of stack
        frames, we allocate a linear number of cons-cells.
      </para>
      <para>
        Allocation of short-lived data in OCaml is quite cheap, so the
        intermediate list is not very expensive. The performance of the
        two implementations is not significantly different, with one
        exception: the tail-recursive implementation will not cause a
        stack overflow for large lists, while the simple
        non-tail-recursive implementation will have problems with large
        lists.
      </para>
    </sect2>
    <sect2 id="hybrid-recursion">
      <title>Hybrid recursion</title>
      <para>
        In general, the choice of whether to use regular recursion vs.
        tail recursion is not immediately obvious. Regular recursion is
        often better for small lists (and other data structures), but it
        is better to use tail recursion for very large lists --
        especially because stack sizes limit the number of recursive
        calls.
      </para>
      <para>
        Core takes a hybrid approach that can be illustrated with the
        implementation of the function <literal>Core_list.map</literal>.
      </para>
      <programlisting language="ocaml">
let map_slow l ~f = rev (rev_map l ~f);;

let rec count_map ~f l ctr =
  match l with
  | [] -&gt; []
  | [x1] -&gt; let f1 = f x1 in [f1]
  | [x1; x2] -&gt; let f1 = f x1 in let f2 = f x2 in [f1; f2]
  | [x1; x2; x3] -&gt;
    let f1 = f x1 in
    let f2 = f x2 in
    let f3 = f x3 in
    [f1; f2; f3]
  | [x1; x2; x3; x4] -&gt;
    let f1 = f x1 in
    let f2 = f x2 in
    let f3 = f x3 in
    let f4 = f x4 in
    [f1; f2; f3; f4]
  | x1 :: x2 :: x3 :: x4 :: x5 :: tl -&gt;
    let f1 = f x1 in 
    let f2 = f x2 in
    let f3 = f x3 in
    let f4 = f x4 in
    let f5 = f x5 in
    f1 :: f2 :: f3 :: f4 :: f5 ::
      (if ctr &gt; 1000 then map_slow ~f tl else count_map ~f tl (ctr + 1));;

let map l ~f = count_map ~f l 0;;
</programlisting>
      <para>
        For performance, there are separate patterns for small lists
        with up to 4 elements, then a recursive case for lists with five
        or more elements. The <literal>ctr</literal> value limits the
        recursion -- regular recursion is used for up to 1000 recursive
        calls (which includes lists with up to 4000 elements), then the
        tail-recursive function <literal>map_slow</literal> is used for
        any remainder.
      </para>
      <para>
        As an aside, you might wonder why this implementation uses
        explicit let-definitions for the result values
        <literal>f1</literal>, <literal>f2</literal>, etc. The reason is
        to force the order of evaluation, so that the the function
        <literal>f</literal> is always applied to the list values
        left-to-right (starting with the first element in the list). In
        an expression like <literal>[f x1; f x2; f x3]</literal> the
        order of evaluation is not specified by the language, any of the
        subexpressions might be evaluated first (though we would often
        expect evaluation order to be either left-to-right or
        right-to-left). For functions that perform I/O, or have other
        side-effects, left-to-right evaluation order is important (and
        required).
      </para>
    </sect2>
  </sect1>
  <sect1 id="heterogenous-values">
    <title>Heterogenous values</title>
    <para>
      Lists are fairly general, but there are several reasons why you
      might not want to use them.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Large lists often have poor performance.
        </para>
      </listitem>
      <listitem>
        <para>
          The list length is variable, not fixed.
        </para>
      </listitem>
      <listitem>
        <para>
          The data in a list must have the same type.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      In the tabulaton example that we used to start this chapter, the
      <literal>List</literal> is not a good choice for each entry in the
      table. Now, let's think about how you might actually use this
      interface in practice. Usually, when you have data to render in a
      table, the data entries are described more precisely by a record.
      So, imagine that you start off with a record type for representing
      information about a given programming language:
    </para>
    <programlisting language="ocaml">
type style =
    Object_oriented | Functional | Imperative | Logic

type prog_lang = { name: string;
                   architect: string;
                   year_released: int;
                   style: style list;
                 }
</programlisting>
    <para>
      If we then wanted to render a table from a list of languages, we
      might write something like this:
    </para>
    <programlisting language="ocaml">
let print_langs langs =
   let headers = [&quot;name&quot;;&quot;architect&quot;;&quot;year released&quot;] in
   let to_row lang =
     [lang.name; lang.architect; Int.to_string lang.year_released ]
   in
   print_string (Text_table.render headers (List.map ~f:to_row langs))
</programlisting>
    <para>
      This is OK, but as you consider more complicated tables with more
      columns, it becomes easier to make the mistake of having a
      mismatch in between <literal>headers</literal> and
      <literal>to_row</literal>. Also, adding, removing and reordering
      columns becomes awkward, because changes need to be made in two
      places.
    </para>
    <para>
      We can improve the table API by adding a type that is a
      first-class representative for a column. We'd add the following to
      the interface of <literal>Text_table</literal>:
    </para>
    <programlisting language="ocaml">
(** An ['a column] is a specification of a column for rending a table
    of values of type ['a] *)
type 'a column

(** [column header to_entry] returns a new column given a header and a
    function for extracting the text entry from the data associated
    with a row *)
val column : string -&gt; ('a -&gt; string) -&gt; 'a column

(** [column_render columns rows] Renders a table with the specified
    columns and rows *)
val column_render :
  'a column list -&gt; 'a list -&gt; string
</programlisting>
    <para>
      Thus, the <literal>column</literal> functions creates a
      <literal>column</literal> from a header string and a function for
      extracting the text for that column associated with a given row.
      Implementing this interface is quite simple:
    </para>
    <programlisting language="ocaml">
type 'a column = string * ('a -&gt; string)
let column header to_string = (header,to_string)

let column_render columns rows =
  let header = List.map columns ~f:fst in
  let rows = List.map rows ~f:(fun row -&gt;
    List.map columns ~f:(fun (_,to_string) -&gt; to_string row))
  in
  render header rows
</programlisting>
    <para>
      And we can rewrite <literal>print_langs</literal> to use this new
      interface as follows.
    </para>
    <programlisting language="ocaml">
let columns =
  [ Text_table.column &quot;Name&quot;      (fun x -&gt; x.name);
    Text_table.column &quot;Architect&quot; (fun x -&gt; x.architect);
    Text_table.column &quot;Year Released&quot;
       (fun x -&gt; Int.to_string x.year_released);
  ]

let print_langs langs =
  print_string (Text_table.column_render columns langs)
</programlisting>
    <para>
      The code is a bit longer, but it's also less error prone. In
      particular, several errors that might be made by the user are now
      ruled out by the type system. For example, it's no longer possible
      for the length of the header and the lengths of the rows to be
      mismatched.
    </para>
    <para>
      The simple column-based interface described here is also a good
      starting for building a richer API. You could for example build
      specialized columns with different formatting and alignment rules,
      which is easier to do with this interface than with the original
      one based on passing in lists-of-lists.
    </para>
  </sect1>
  <sect1 id="options-1">
    <title>Options</title>
    <para>
      OCaml has no &quot;NULL&quot; or &quot;nil&quot; values.
      Programmers coming from other languages are often surprised and
      annoyed by this -- it seems really convenient to have a special
      <literal>NULL</literal> value that represents concepts like
      &quot;end of list&quot; or &quot;leaf node in a tree.&quot; The
      possible benefit is that <emphasis>every</emphasis> pointer type
      has a extra NULL value; the problem is that using the NULL value
      as if it were a real value has weak or undefined semantics.
    </para>
    <para>
      How do we get similar semantics in OCaml? The ubiquitous technique
      is to use the <literal>option</literal> type, which has the
      following definition.
    </para>
    <programlisting language="ocaml">
type 'a option = None | Some of 'a;;
</programlisting>
    <para>
      That is, a value of type <literal>'a option</literal> is either
      <literal>None</literal>, which means &quot;no value;&quot; or it
      is <literal>Some v</literal>, which represents a value
      <literal>v</literal>. There is nothing special about the
      <literal>option</literal> type -- it is a variant type just like
      any other. What it means is that checking for
      <literal>None</literal> is <emphasis>explicit</emphasis>, it is
      not possible to use <literal>None</literal> in a place where
      <literal>Some x</literal> is expected.
    </para>
    <para>
      In the most direct form, we can use an <literal>option</literal>
      wherever some value is &quot;optional,&quot; with the usual
      meaning. For example, if the architect of a programming language
      is not always known, we could use a special string like
      <literal>&quot;unknown&quot;</literal> to represent the
      architect's name, but we might accidentally confuse it with the
      name of a person. The more explicit alternative is to use an
      option.
    </para>
    <programlisting language="ocaml">
type prog_lang = { name: string;
                   architect: string option;
                   year_released: int;
                   style: style list;
                 }

let x86 = { name = &quot;x86 assembly&quot;;
            architect = None;
            year_released = 1980;
            style = Imperative
          };;
</programlisting>
    <para>
      We can also represent a data structure with NULL-pointers using
      the <literal>option</literal> type. For example, let's build an
      imperative singly-linked list, where new values are added to the
      <emphasis>end</emphasis> of the list. In a standard imperative
      language (like in the C++ Standard Template Library), NULL is used
      to represent &quot;end of list.&quot; We'll use the
      <literal>option</literal> type instead.
    </para>
    <programlisting language="ocaml">
type 'a slist = { mutable head : 'a elem option; mutable tail : 'a elem option }
and 'a elem = { value : 'a; mutable next : 'a elem option };;

let new_slist () = { head = None; tail = None };;

let push_back l x =
  let elem = { value = x; next = None } in
  match l.tail with
   | None -&gt; l.head &lt;- Some elem; l.tail &lt;- Some elem
   | Some last -&gt; last.next &lt;- Some elem;;
</programlisting>
    <para>
      Similarly, if we're defining a type of binary trees, one choice is
      to use <literal>option</literal> for the child node references. In
      a binary search tree, each node in the tree is labeled with a
      value and it has up to two children. The nodes in the tree follow
      <emphasis>prefix</emphasis> order, meaning that the label of the
      left child is smaller than the label of its parent, and the label
      of the right child is larger than the label of the parent.
    </para>
    <programlisting language="ocaml">
type 'a node = { label : 'a; left : 'a binary_tree; right : 'a binary_tree }
and 'a binary_tree = 'a node option;;

let new_binary_tree () : 'a binary_tree = None;;

let rec insert x = function
 | Some { label = label; left = left; right = right } as tree -&gt;
   if x &lt; label then
     Some { label = label; left = insert x left; right = right }
   else if x &gt; label then
     Some { label = label; left = left; right = insert x right }
   else 
     tree
 | None -&gt; Some { label = x; left = None; right = None };;
</programlisting>
    <para>
      This representation is perfectly adequate, but many OCaml
      programmers would prefer a representation where the
      <literal>option</literal> is &quot;hoisted&quot; to the
      <literal>node</literal> type, meaning that we have two kinds of
      nodes. In this case, the code is somewhat more succinct. In the
      end, of course, the two versions are isomorphic.
    </para>
    <programlisting language="ocaml">
type 'a binary_tree =
 | Leaf
 | Interior of 'a * 'a binary_tree * 'a binary_tree;;

let new_binary_tree () : 'a binary_tree = Leaf;;

let rec insert x = function
 | Interior (label, left, right) as tree -&gt;
   if x &lt; label then Interior (label, insert x left, right)
   else if x &gt; label then Interior (label, left, insert x right)
   else tree
 | Leaf -&gt; Interior (x, Leaf, Leaf);;
</programlisting>
  </sect1>
</chapter>
<chapter id="records">
  <title>Records</title>
  <para>
    One of OCaml's best features is its concise and expressive system
    for declaring new datatypes. Two key elements of that system are
    <emphasis>records</emphasis> and <emphasis>variants</emphasis>, both
    of which we discussed briefly in chapter {{{GUIDEDTOUR}}}. In this
    chapter we'll cover records in more depth, covering more of the
    details of how they work, as well as advice on how to use them
    effectively in your software designs.
  </para>
  <para>
    A record represents a collection of values stored together as one,
    where each component is identified by a different field name. The
    basic syntax for a record type declaration is as follows.
  </para>
  <programlisting>
type &lt;record-name&gt; =
  { &lt;field-name&gt; : &lt;type-name&gt; ;
    &lt;field-name&gt; : &lt;type-name&gt; ;
    ...
  }
</programlisting>
  <para>
    Here's a simple example, a <literal>host_info</literal> record that
    summarizes information about a given computer.
  </para>
  <programlisting>
# type host_info =
    { hostname   : string;
      os_name    : string;
      os_release : string;
      cpu_arch   : string;
    };;
</programlisting>
  <para>
    We can construct a <literal>host_info</literal> just as easily. The
    following code uses the <literal>Shell</literal> module from
    <literal>Core_extended</literal> to dispatch commands to the shell
    to extract the information we need about the computer we're running
    on.
  </para>
  <programlisting>
# open Core_extended.Std;;
# let my_host = { hostname   = Shell.sh_one &quot;hostname&quot;;
                  os_name    = Shell.sh_one &quot;uname -s&quot;;
                  os_release = Shell.sh_one &quot;uname -r&quot;;
                  cpu_arch   = Shell.sh_one &quot;uname -p&quot;;
                };;
val my_host : host_info =
  {hostname = &quot;Yarons-MacBook-Air.local&quot;; os_name = &quot;Darwin&quot;;
   os_release = &quot;11.4.0&quot;; cpu_arch = &quot;i386&quot;}
</programlisting>
  <para>
    You might wonder how the compiler inferred that
    <literal>my_host</literal> is of type <literal>host_info</literal>.
    The hook that the compiler uses in this case to figure out the type
    is the record field names. It turns out that, within a given scope,
    each record field name is associated with a unique record type.
    Later in the chapter, we'll talk about what to do when you want to
    have the same record fields in multiple records.
  </para>
  <para>
    Once we have a record value in hand, we can extract elements from
    the record field using dot-notation.
  </para>
  <programlisting>
# my_host.cpu_arch;;
- : string = &quot;i386&quot;
</programlisting>
  <sect1 id="patterns-and-exhaustiveness">
    <title>Patterns and exhaustiveness</title>
    <para>
      Another way of getting information out of a record is by using a
      pattern match, as in the definition of
      <literal>host_info_to_string</literal> below.
    </para>
    <programlisting>
# let host_info_to_string { hostname = h; os_name = os;
                            os_release = r; cpu_arch = c } =
       sprintf &quot;%s (%s %s / %s)&quot; h os r c;;
    val host_info_to_string : host_info -&gt; string = &lt;fun&gt;
# host_info_to_string my_host;;
- : string = &quot;Yarons-MacBook-Air.local (Darwin 11.4.0 / i386)&quot;
</programlisting>
    <para>
      Note that the pattern that we used had only a single case, rather
      than using several cases separated by <literal>|</literal>s. We
      only needed a single pattern because record patterns are
      <emphasis>irrefutable</emphasis>, meaning that, because the layout
      of a record is always the same, a record pattern match will never
      fail at runtime. In general, types with a fixed structure, like
      records and tuples, have irrefutable patterns, whereas types with
      variable structure, like lists and variants, do not.
    </para>
    <para>
      Another important characteristic of record patterns is that they
      don't need to be complete; a pattern can mention only a subset of
      the fields in the record. This can be convenient, but it's can
      also be error prone. In particular, this means that when new
      fields are added to the record, code that should be updated to
      react to the presence of those new fields will not be flagged by
      the compiler.
    </para>
    <para>
      As an example, imagine that we wanted to add a new field to our
      <literal>host_info</literal> record called
      <literal>os_version</literal>, as shown below.
    </para>
    <programlisting>
# type host_info =
    { hostname   : string;
      os_name    : string;
      os_release : string;
      cpu_arch   : string;
      os_version : string;
    };;
</programlisting>
    <para>
      The code for <literal>host_info_to_string</literal> would continue
      to compile without change. In this particular case, it's pretty
      clear that you might want to update
      <literal>host_info_to_string</literal> in order to take into
      account the new field, and it would be nice if the type system
      would give you a warning about the change.
    </para>
    <para>
      Happily, OCaml does offer an optional warning for missing fields
      in a record pattern. With that warning turned on (which you can do
      in the toplevel by typing
      <literal>#warnings &quot;+9&quot;</literal>), the compiler will
      warn about the missing field.
    </para>
    <programlisting>
# warnings &quot;+9&quot;;;
# let host_info_to_string { hostname = h; os_name = os;
                            os_release = r; cpu_arch = c } =
       sprintf &quot;%s (%s %s / %s)&quot; h os r c;;
    Characters 24-112:
  ........................{ hostname = h; os_name = os;
                              os_release = r; cpu_arch = c }..
Warning 9: the following labels are not bound in this record pattern:
os_version
Either bind these labels explicitly or add '; _' to the pattern.
val host_info_to_string : host_info -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      We can disable the warning for a given pattern by explicitly
      acknowledging that we are ignoring extra fields. This is done by
      adding an underscore to the pattern, as shown below.
    </para>
    <programlisting>
# let host_info_to_string { hostname = h; os_name = os;
                            os_release = r; cpu_arch = c; _ } =
       sprintf &quot;%s (%s %s / %s)&quot; h os r c;;
    val host_info_to_string : host_info -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      Generally, the right default is to turn the warning for incomplete
      record matches on, and to explicitly disable it with an
      <literal>_</literal> where necessary.
    </para>
  </sect1>
  <sect1 id="field-punning">
    <title>Field punning</title>
    <para>
      When the name of a variable coincides with the name of a record
      field, OCaml provides some handy syntactic shortcuts. For example,
      the pattern in the following function binds all of the fields in
      question to variables of the same name. This is called
      <emphasis>field punning</emphasis>.
    </para>
    <programlisting>
# let host_info_to_string { hostname; os_name; os_release; cpu_arch } =
     sprintf &quot;%s (%s %s / %s)&quot; hostname os_name os_release cpu_arch;;
  val host_info_to_string : host_info -&gt; string = &lt;fun&gt;
</programlisting>
    <para>
      Field punning can also be used to construct a record. Consider the
      following code for generating a <literal>host_info</literal>
      record.
    </para>
    <programlisting>
# let my_host =
    let hostname   = Shell.sh_one &quot;hostname&quot; in
    let os_name    = Shell.sh_one &quot;uname -s&quot; in
    let os_release = Shell.sh_one &quot;uname -r&quot; in
    let cpu_arch   = Shell.sh_one &quot;uname -p&quot; in
    { hostname; os_name; os_release; cpu_arch };;
val my_host : host_info =
  {hostname = &quot;Yarons-MacBook-Air.local&quot;; os_name = &quot;Darwin&quot;;
   os_release = &quot;11.4.0&quot;; cpu_arch = &quot;i386&quot;}
</programlisting>
    <para>
      In the above code, we defined variables corresponding to the
      record fields first, and then the record declaration itself simply
      listed the fields that needed to be included.
    </para>
    <para>
      You can take advantage of both field punning and label punning
      when writing a function for constructing a record from labeled
      arguments, as shown below.
    </para>
    <programlisting>
# let create_host_info ~hostname ~os_name ~os_release ~cpu_arch =
    let hostname = String.lowercase hostname in
    { hostname; os_name; os_release; cpu_arch };;
</programlisting>
    <para>
      This is considerably more concise than what you would get without
      punning at all.
    </para>
    <programlisting>
let create_host_info ~hostname:hostname ~os_name:os_name
   ~os_release:os_release ~cpu_arch:cpu_arch =
    let hostname = String.lowercase hostname in
    { hostname = hostname ; os_name = os_name;
      os_release = os_release; cpu_arch = cpu_arch };;
</programlisting>
    <para>
      Together, labeled arguments, field names, and field and label
      punning, encourage a style where you propagate the same names
      throughout your code-base. This is generally good practice, since
      it encourages consistent naming, which makes it easier for new
      people to navigate your source.
    </para>
  </sect1>
  <sect1 id="reusing-field-names">
    <title>Reusing field names</title>
    <para>
      Defining records with the same field names can be problematic.
      Let's consider a simple example: building types to represent the
      protocol used for a logging server. The following types represent
      messages a server might receive from a client.
    </para>
    <para>
      Below, the <literal>log_entry</literal> message is used to deliver
      a log entry to the server for processing. The
      <literal>logon</literal> message is sent when a client initiates a
      connection, and includes the identity of the user connecting and
      credentials used for authentication. Finally, the
      <literal>heartbeat</literal> message is periodically sent by the
      client to demonstrate to the server that the client is alive and
      connected. All of these messages include a session id and the time
      the message was generated.
    </para>
    <programlisting language="ocaml">
# type log_entry =
    { session_id: string;
      time: Time.t;
      important: bool;
      message: string;
    }
  type heartbeat =
    { session_id: string;
      time: Time.t;
      status_message: string;
    }
  type logon =
    { session_id: string;
      time: Time.t;
      user: string;
      credentials: string;
    }
;;
</programlisting>
    <para>
      The fact that we reused field names will cause trouble when we try
      to construct a message.
    </para>
    <programlisting>
# let create_log_entry ~session_id ~important message =
     { time = Time.now (); session_id; important; message }
  ;;
    Characters 75-129:
       { time = Time.now (); session_id; important; message }
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: The record field label important belongs to the type log_entry
       but is mixed here with labels of type logon
</programlisting>
    <para>
      The problem is that the declaration of <literal>logon</literal>
      (and <literal>heartbeat</literal>) shadowed some of the fields of
      <literal>log_entry</literal>. As a result, the fields
      <literal>time</literal> and <literal>session_id</literal> are
      assumed to be fields of <literal>logon</literal>, and
      <literal>important</literal> and <literal>message</literal>, which
      were not shadowed, are assumed to be fields of
      <literal>log_entry</literal>. The compiler therefore complains
      that we're trying to construct a record with fields from two
      different record types.
    </para>
    <para>
      There are two common solutions to this problem. The first is to
      add a prefix to each field name to make it unique, as shown below.
    </para>
    <programlisting>
# type log_entry =
    { log_entry_session_id: string;
      log_entry_time: Time.t;
      log_entry_important: bool;
      log_entry_message: string;
    }
  type heartbeat =
    { heartbeat_session_id: string;
      heartbeat_time: Time.t;
      heartbeat_status_message: string;
    }
  type logon =
    { logon_session_id: string;
      logon_time: Time.t;
      logon_user: string;
      logon_credentials: string;
    }
;;
</programlisting>
    <para>
      This eliminates the collisions and is simple enough to do. But it
      leaves you with awkwardly named record fields, and adds needless
      repetition and verbosity to your code.
    </para>
    <para>
      Another approach is to mint a module for each type. This is
      actually a broadly useful idiom, providing for each type a
      namespace within which to put related values. Using this style we
      would write:
    </para>
    <programlisting>
# module Log_entry = struct
    type t =
      { session_id: string;
        time: Time.t;
        important: bool;
        message: string;
      }
  end
  module Heartbeat = struct
    type t =
      { session_id: string;
        time: Time.t;
        status_message: string;
      }
  end
  module Logon = struct
    type t =
      { session_id: string;
        time: Time.t;
        user: string;
        credentials: string;
      }
  end;;
</programlisting>
    <para>
      Now, our heartbeat-creation function can be rendered as follows.
    </para>
    <programlisting>
# let create_log_entry ~session_id ~important message =
     { Log_entry.time = Time.now (); Log_entry.session_id;
       Log_entry.important; Log_entry.message }
  ;;
val create_log_entry :
  session_id:string -&gt; important:bool -&gt; string -&gt; Log_entry.t = &lt;fun&gt;
</programlisting>
    <para>
      The module name <literal>Log_entry</literal> is required to
      qualify the fields, because this function is outside of the
      <literal>Log_entry</literal> module where the record was defined.
      OCaml only requires the module qualification for one record field,
      however, so we can write this more concisely.
    </para>
    <programlisting>
# let create_log_entry ~session_id ~important message =
     { Log_entry. time = Time.now (); session_id; important; message }
  ;;
val create_log_entry :
  session_id:string -&gt; important:bool -&gt; string -&gt; Log_entry.t = &lt;fun&gt;
</programlisting>
    <para>
      For functions defined within the module where a given record is
      defined, the module qualification goes away entirely. And indeed,
      for things like constructors, defining it within the module is
      often the best solution.
    </para>
  </sect1>
  <sect1 id="functional-updates">
    <title>Functional updates</title>
    <para>
      Fairly often, you will find yourself wanting to create a new
      record that differs from an existing record in only a subset of
      the fields. For example, imagine our logging server had a record
      type for representing the state of a given client, including when
      the last heartbeat was received from that client. The following
      defines a type for representing this information, as well as a
      function for updating the client information when a new heartbeat
      arrives.
    </para>
    <programlisting>
# type client_info =
   { addr: Unix.Inet_addr.t;
     port: int;
     user: string;
     credentials: string;
     last_heartbeat_time: Time.t;
   };;
# let register_heartbeat t hb =
      { addr = t.addr;
        port = t.port;
        user = t.user;
        credentials = t.credentials;
        last_heartbeat_time = hb.Heartbeat.time;
      };;
val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; client_info = &lt;fun&gt;
</programlisting>
    <para>
      This is fairly verbose, given that there's only one field that we
      actually want to change, and all the others are just being copied
      over from <literal>t</literal>. We can use OCaml's
      <emphasis>functional update</emphasis> syntax to do this more
      tersely. The syntax of a functional update is as follows.
    </para>
    <programlisting>
{ &lt;record-value&gt; with &lt;field&gt; = &lt;value&gt;;
                      &lt;field&gt; = &lt;value&gt;;
                      ...
}
</programlisting>
    <para>
      The purpose of the functional update is to create a new record
      based on an existing one, with a set of field changes layered on
      top.
    </para>
    <para>
      Given this, we can rewrite <literal>register_heartbeat</literal>
      more concisely.
    </para>
    <programlisting>
# let register_heartbeat t hb =
    { t with last_heartbeat_time = hb.Heartbeat.time };;
</programlisting>
    <para>
      Functional updates make your code independent of the identity of
      the fields in the record that are not changing. This is often what
      you want, but it has downsides as well. In particular, if you
      change the definition of your record to have more fields, the type
      system will not prompt you to reconsider whether your update code
      should affect those fields. Consider what happens if we decided to
      add a field for the status message received on the last heartbeat.
    </para>
    <programlisting>
# type client_info =
   { addr: Unix.Inet_addr.t;
     port: int;
     user: string;
     credentials: string;
     last_heartbeat_time: Time.t;
     last_heartbeat_status: string;
   };;
</programlisting>
    <para>
      The original implementation of
      <literal>register_heartbeat</literal> would now be invalid, and
      thus the compiler would warn us to think about how to handle this
      new field. But the version using a functional update continues to
      compile as is, even though it incorrectly ignores the new field.
      The correct thing to do would be to update the code as follows.
    </para>
    <programlisting>
# let register_heartbeat t hb =
    { t with last_heartbeat_time   = hb.Heartbeat.time;
             last_heartbeat_status = hb.Heartbeat.status_message;
    };;
</programlisting>
  </sect1>
  <sect1 id="mutable-fields">
    <title>Mutable fields</title>
    <para>
      Like most OCaml values, records are immutable by default. You can,
      however, declare individual record fields as mutable. For example,
      we could take the <literal>client_info</literal> type and make the
      fields that may need to change over time mutable, as follows.
    </para>
    <programlisting>
# type client_info =
   { addr: Unix.Inet_addr.t;
     port: int;
     user: string;
     credentials: string;
     mutable last_heartbeat_time: Time.t;
     mutable last_heartbeat_status: string;
   };;
</programlisting>
    <para>
      We then use the <literal>&lt;-</literal> operator for actually
      changing the state. The side-effecting version of
      <literal>register_heartbeat</literal> would be written as follows.
    </para>
    <programlisting>
# let register_heartbeat t hb =
    t.last_heartbeat_time   &lt;- hb.Heartbeat.time;
    t.last_heartbeat_status &lt;- hb.Heartbeat.status_message
  ;;
val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; unit = &lt;fun&gt;
</programlisting>
    <para>
      Note that <literal>&lt;-</literal> is not needed for
      initialization, because all fields of a record, including mutable
      ones, must be specified when the record is created.
    </para>
    <para>
      OCaml's policy of immutable-by-default is a good one, but
      imperative programming does have its place. We'll discuss more
      about how (and when) to use OCaml's imperative features in Chapter
      {{{imperative-programming}}}.
    </para>
  </sect1>
  <sect1 id="first-class-fields">
    <title>First-class fields</title>
    <para>
      Consider the following function for extracting the usernames from
      a list of <literal>Logon</literal> messages.
    </para>
    <programlisting>
# let get_users logons =
     List.dedup (List.map logons ~f:(fun x -&gt; x.Logon.user));;
  val get_hostnames : Logon.t list -&gt; string list = &lt;fun&gt;
</programlisting>
    <para>
      Here, we wrote a small function
      <literal>(fun x -&gt; x.Logon.user)</literal> to access the
      <literal>user</literal> field. This kind of accessor function is a
      common enough pattern that that it would be convenient to generate
      them automatically. The <literal>fieldslib</literal> syntax
      extension that ships with <literal>Core</literal> does just that.
    </para>
    <para>
      <literal>fieldslib</literal> is invoked by putting the
      <literal>with fields</literal> annotation at the end of the
      declaration of a record type. So, for example, we could have
      defined <literal>Logon</literal> as follows.
    </para>
    <programlisting>
# module Logon = struct
    type t =
      { session_id: string;
        time: Time.t;
        user: string;
        credentials: string;
      }
    with fields
  end;;
</programlisting>
    <para>
      Given that definition, we can use the function
      <literal>Logon.user</literal> to extract the user field from a
      logon message.
    </para>
    <programlisting>
# let get_users logons = List.dedup (List.map logons ~f:Logon.user);;
val get_users : Logon.t list -&gt; string list = &lt;fun&gt;
</programlisting>
    <para>
      In addition to generating field accessor functions,
      <literal>fieldslib</literal> also creates a sub-module called
      <literal>Fields</literal> that contains a first class
      representative of each field, in the form of a value of type
      <literal>Field.t</literal>. A <literal>Field.t</literal> bundles
      up the following functionality of a record filed:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          The name of the field as a string
        </para>
      </listitem>
      <listitem>
        <para>
          The ability to extract the field
        </para>
      </listitem>
      <listitem>
        <para>
          The ability to do a functional update of that field
        </para>
      </listitem>
      <listitem>
        <para>
          The (optional) ability to set the record field, which is
          present only if the field is mutable.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We can use these first class fields to do things like write a
      generic function for displaying a record field. The function
      <literal>show_field</literal> takes three arguments: the
      <literal>Field.t</literal>, a function for converting the contents
      of the field in question to a string, and the record type.
    </para>
    <programlisting>
# let show_field field to_string record =
     sprintf &quot;%s: %s&quot; (Field.name field) (Field.get field record |! to_string);;
val show_field : ('a, 'b) Field.t -&gt; ('b -&gt; string) -&gt; 'a -&gt; string =
  &lt;fun&gt;
</programlisting>
    <para>
      Here's an example of <literal>show_field</literal> in action.
    </para>
    <programlisting>
# let logon = { Logon.
                session_id = &quot;26685&quot;;
                time = Time.now ();
                user = &quot;yminsky&quot;;
                credentials = &quot;Xy2d9W&quot;; }
  ;;
# show_field Logon.Fields.user Fn.id logon;;
- : string = &quot;user: yminsky&quot;
# show_field Logon.Fields.time Time.to_string logon;;
- : string = &quot;time: 2012-06-26 18:44:13.807826&quot;
</programlisting>
    <para>
      <literal>fieldslib</literal> also provides higher-level operators,
      like <literal>Fields.fold</literal> and
      <literal>Fields.iter</literal>, which let you iterate over all the
      fields of a record. The following function uses
      <literal>Logon.Fields.iter</literal> and
      <literal>show_field</literal> to print out all the fields of a
      <literal>Logon</literal> record.
    </para>
    <programlisting>
# let print_logon logon =
    let print to_string field =
      printf &quot;%s\n&quot; (show_field field to_string logon)
    in
    Logon.Fields.iter
      ~session_id:(print Fn.id)
      ~time:(print Time.to_string)
      ~user:(print Fn.id)
      ~credentials:(print Fn.id)
  ;;
val print_logon : Logon.t -&gt; unit = &lt;fun&gt;
# print_logon logon;;
session_id: 26685
time: 2012-06-26 18:44:13.807826
user: yminsky
credentials: Xy2d9W
- : unit = ()
</programlisting>
    <para>
      The advantage of using field iterators is that when the definition
      of <literal>Logon</literal> changes, <literal>iter</literal> will
      change along with it, prompting you to handle whatever new cases
      arise.
    </para>
    <para>
      Field iterators are useful for a variety of tasks, from building
      validation functions to scaffolding the definition of a web-form
      based on a record type, all with a guarantee that you've
      exhaustively considered all elements of the field.
    </para>
  </sect1>
</chapter>
<chapter id="variants">
  <title>Variants</title>
  <para>
    Variant types are used to represent multiple different
    possibilities, where each possibility is identified by a different
    <emphasis>constructor</emphasis>. The syntax of a variant type
    declaration is as follows.
  </para>
  <programlisting>
type &lt;variant-name&gt; =
  | &lt;Constructor1&gt; [of &lt;arg1&gt; * .. * &lt;argn&gt;]?
  | &lt;Constructor2&gt; [of &lt;arg1&gt; * .. * &lt;argn&gt;]?
  ...
</programlisting>
  <para>
    The basic purpose of variants is to effectively represent data that
    may have multiple different cases. We can give a better sense of the
    utility of variants by walking through a concrete example, which
    we'll do by thinking about how to represent terminal colors.
  </para>
  <sect1 id="example-terminal-colors">
    <title>Example: terminal colors</title>
    <para>
      Almost all terminals support a set of 8 basic colors, which we can
      represent with the following variant type.
    </para>
    <programlisting>
# type basic_color =
    Black | Red | Green | Yellow | Blue | Magenta | Cyan | White;;
</programlisting>
    <para>
      This is a particularly simple form of variant, in that the
      constructors don't have arguments. Such variants are very similar
      to the enumerations found in many languages, including C and Java.
    </para>
    <para>
      We can construct instances of <literal>basic_color</literal> by
      simply writing out the constructors in question.
    </para>
    <programlisting>
# [Black;Blue;Red];;
- : basic_color list = [Black; Blue; Red]
</programlisting>
    <para>
      Pattern matching can be used to process a variant. The following
      function uses pattern matching to convert
      <literal>basic_color</literal> to a corresponding integer for use
      in creating color-setting escape codes.
    </para>
    <programlisting>
# let basic_color_to_int = function
  | Black -&gt; 0 | Red     -&gt; 1 | Green -&gt; 2 | Yellow -&gt; 3
  | Blue  -&gt; 4 | Magenta -&gt; 5 | Cyan  -&gt; 6 | White  -&gt; 7 ;;
val basic_color_to_int : basic_color -&gt; int = &lt;fun&gt;
</programlisting>
    <para>
      Note that the exhaustiveness checking on pattern matches means
      that the compiler will warn us if we miss a color.
    </para>
    <para>
      Using this function, we can generate the escape codes to change
      the color of a given string.
    </para>
    <programlisting>
# let color_by_number number text =
    sprintf &quot;\027[38;5;%dm%s\027[0m&quot; number text;;
  val color_by_number : int -&gt; string -&gt; string = &lt;fun&gt;
# let s = color_by_number (basic_color_to_int Blue) &quot;Hello Blue World!&quot;;;
val s : string = &quot;\027[38;5;4mHello Blue World!\027[0m&quot;
# printf &quot;%s\n&quot; s;;
Hello Blue World!
- : unit = ()
</programlisting>
    <para>
      On most terminals, that last line is printed in blue.
    </para>
    <sect2 id="full-terminal-colors">
      <title>Full terminal colors</title>
      <para>
        The simple enumeration of <literal>basic_color</literal> isn't
        enough to fully describe the set of colors that a modern
        terminal can display. Many terminals, including the venerable
        <literal>xterm</literal>, support 256 different colors, broken
        up into the following groups.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            The 8 basic colors, in regular and bold versions.
          </para>
        </listitem>
        <listitem>
          <para>
            A 6 × 6 × 6 RGB color cube
          </para>
        </listitem>
        <listitem>
          <para>
            A 24-level grayscale ramp
          </para>
        </listitem>
      </itemizedlist>
      <para>
        We can represent this more complicated color-space as a variant,
        but this time, the different constructors will have arguments,
        to describe the data available in each case.
      </para>
      <programlisting>
# type weight = Regular | Bold
  type color =
  | Basic of basic_color * weight (* basic colors, regular and bold *)
  | RGB   of int * int * int       (* 6x6x6 color cube *)
  | Gray  of int                   (* 24 grayscale levels *)
;;
</programlisting>
      <para>
        In order to compute the color code for a
        <literal>color</literal>, we use pattern matching to break down
        the <literal>color</literal> variant into the appropriate cases.
      </para>
      <programlisting>
# let color_to_int = function
    | Basic (basic_color,weight) -&gt;
      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in
      base + basic_color_to_int basic_color
    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | Gray i -&gt; 232 + i ;;
val color_to_int : color -&gt; int = &lt;fun&gt;
</programlisting>
      <sidebar><title>
      Catch-all cases and refactoring
      </title>
      <para>
        OCaml's type system can act as a form of refactoring tool, where
        the compiler warns you of places where your code needs to be
        adapted to changes made elsewhere. This is particularly valuable
        when working with variant types.
      </para>
      <para>
        Consider what would happen if we were to change the definition
        of <literal>color</literal> to the following.
      </para>
      <programlisting>
# type color =
  | Basic of basic_color     (* basic colors *)
  | Bold  of basic_color     (* bold basic colors *)
  | RGB   of int * int * int (* 6x6x6 color cube *)
  | Gray  of int             (* 24 grayscale levels *)
;;
</programlisting>
      <para>
        We've essentially broken out the <literal>Basic</literal> case
        into two cases, <literal>Basic</literal> and
        <literal>Bold</literal>, and <literal>Basic</literal> has
        changed from having two arguments to one.
        <literal>color_to_int</literal> as we wrote it still expects the
        old structure of the variant, and if we try to compile that same
        code again, the compiler will notice the discrepancy.
      </para>
      <programlisting>
# let color_to_int = function
    | Basic (basic_color,weight) -&gt;
      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in
      base + basic_color_to_int basic_color
    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | Gray i -&gt; 232 + i ;;
Characters 40-60:
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type basic_color
</programlisting>
      <para>
        Here, the compiler is complaining that the
        <literal>Basic</literal> constructor is assumed to have the
        wrong number of arguments. If we fix that, however, the compiler
        flag will flag a second problem, which is that we haven't
        handled the new <literal>Bold</literal> constructor.
      </para>
      <programlisting>
# let color_to_int = function
    | Basic basic_color -&gt; basic_color_to_int basic_color
    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | Gray i -&gt; 232 + i ;;
Characters 19-154:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Bold _
val color_to_int : color -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        Fixing this now leads us to the correct implementation.
      </para>
      <programlisting>
# let color_to_int = function
    | Basic basic_color -&gt; basic_color_to_int basic_color
    | Bold  basic_color -&gt; 8 + basic_color_to_int basic_color
    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | Gray i -&gt; 232 + i ;;
val color_to_int : color -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        As you can see, the type system identified for us the places in
        our code that needed to be fixed. This refactoring isn't
        entirely free, however. To really take advantage of it, you need
        to write your code in a way that maximizes the compiler's
        chances of helping you find your bugs. One important rule is to
        avoid catch-all cases in pattern matches.
      </para>
      <para>
        Here's an example of how a catch-all case plays in. Imagine we
        wanted a version of <literal>color_to_int</literal> that works
        on older terminals by rendering the first 16 colors (the 8
        <literal>basic_color</literal>s in regular and bold) in the
        normal way, but rendering everything else as white. We might
        have written the function as follows.
      </para>
      <programlisting>
# let oldschool_color_to_int = function
    | Basic (basic_color,weight) -&gt;
      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in
      base + basic_color_to_int basic_color
    | _ -&gt; basic_color_to_int White;;
val oldschool_color_to_int : color -&gt; int = &lt;fun&gt;
</programlisting>
      <para>
        But because the catch-all case encompasses all possibilities,
        the type system will no longer warn us that we have missed the
        new <literal>Bold</literal> case when we change the type to
        include it. We can get this check back by being more explicit
        about what we're ignoring. We haven't changed the behavior of
        the code, but we have improved our robustness to change.
      </para>
      </sidebar>
      <para>
        Using the above function, we can print text using the full set
        of available colors.
      </para>
      <programlisting>
# let color_print color s =
     printf &quot;%s\n&quot; (color_by_number (color_to_int color) s);;
val color_print : color -&gt; string -&gt; unit = &lt;fun&gt;
# color_print (Basic (Red,Bold)) &quot;A bold red!&quot;;;
A bold red!
- : unit = ()
# color_print (Gray 4) &quot;A muted gray...&quot;;;
A muted gray...
- : unit = ()
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="combining-records-and-variants">
    <title>Combining records and variants</title>
    <para>
      Records and variants are most effective when used in concert.
      Consider again the type <literal>Log_entry.t</literal> from
      section [[REUSING FIELD NAMES]]:
    </para>
    <programlisting language="ocaml">
module Log_entry = struct
  type t =
    { session_id: string;
      time: Time.t;
      important: bool;
      message: string;
    }
end
</programlisting>
    <para>
      This record type combines multiple pieces of data into one value.
      In particular, a single <literal>Log_entry.t</literal> has a
      <literal>session_id</literal> <emphasis>and</emphasis> a
      <literal>time</literal> <emphasis>and</emphasis> an
      <literal>important</literal> flag <emphasis>and</emphasis> a
      <literal>message</literal>. More generally, you can think of
      record types as acting as conjunctions. Variants, on the other
      hand, are disjunctions, letting you represent multiple
      possibilities, as in the following example.
    </para>
    <programlisting language="ocaml">
type client_message = | Logon of Logon.t
                      | Heartbeat of Heartbeat.t
                      | Log_entry of Log_entry.t
</programlisting>
    <para>
      A <literal>client_message</literal> is a <literal>Logon</literal>
      <emphasis>or</emphasis> a <literal>Heartbeat</literal>
      <emphasis>or</emphasis> a <literal>Log_entry</literal>. If we want
      to write code that processes messages generically, rather than
      code specialized to a fixed message type, we need something like
      <literal>client_message</literal> to act as one overarching type
      for the different possible messages.
    </para>
    <para>
      You can increase the precision of your types by using variants to
      represent structural differences between types, and records to
      represent structure that is shared. As an example, consider the
      following function that takes a list of
      <literal>client_message</literal>s and returns all messages
      generated by a given user. The code in question is implemented by
      folding over the list of messages, where the accumulator is a pair
      of:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          the set of session identifiers for the user that have been
          seen thus far.
        </para>
      </listitem>
      <listitem>
        <para>
          the set of messages so far that are associated with the user.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Here's the concrete code.
    </para>
    <programlisting language="ocaml">
let messages_for_user user messages =
  let (user_messages,_) =
    List.fold messages ~init:([],String.Set.empty)
      ~f:(fun ((messages,user_sessions) as acc) message -&gt;
        match message with
        | Logon m -&gt;
          if m.Logon.user = user then
            (message::messages, Set.add user_sessions m.Logon.session_id)
          else acc
        | Heartbeat _ | Log_entry _ -&gt;
          let session_id = match message with
            | Logon     m -&gt; m.Logon.session_id
            | Heartbeat m -&gt; m.Heartbeat.session_id
            | Log_entry m -&gt; m.Log_entry.session_id
          in
          if Set.mem user_sessions session_id then
            (message::messages,user_sessions)
          else acc
      )
  in
  List.rev user_messages
</programlisting>
    <para>
      There's one awkward bit about the code above, which is the
      calculation of the session ids. In particular, we have the
      following repetitive snippet of code:
    </para>
    <programlisting language="ocaml">
  let session_id = match message with
    | Logon     m -&gt; m.Logon.session_id
    | Heartbeat m -&gt; m.Heartbeat.session_id
    | Log_entry m -&gt; m.Log_entry.session_id
  in
</programlisting>
    <para>
      This code effectively computes the session id for each underlying
      message type. The repetition in this case isn't that bad, but
      would become problematic in larger and more complicated examples.
    </para>
    <para>
      We can improve the code by refactoring our types to explicitly
      separate which parts are shared and which are common. The first
      step is to cut down the definitions of the per-message records to
      just contain the unique components of each message.
    </para>
    <programlisting language="ocaml">
module Log_entry = struct
  type t = { important: bool;
             message: string;
           }
end

module Heartbeat = struct
  type t = { status_message: string; }
end

module Logon = struct
  type t = { user: string;
             credentials: string;
           }
end
</programlisting>
    <para>
      We can then define a variant type that covers the different
      possible unique components.
    </para>
    <programlisting language="ocaml">
type details =
| Logon of Logon.t
| Heartbeat of Heartbeat.t
| Log_entry of Log_entry.t
</programlisting>
    <para>
      Separately, we need a record that contains the fields that are
      common across all messages.
    </para>
    <programlisting language="ocaml">
module Common = struct
  type t = { session_id: string;
             time: Time.t;
           }
end
</programlisting>
    <para>
      A full message can then represented as a pair of a
      <literal>Common.t</literal> and a <literal>details</literal>.
      Using this, we can rewrite our example above as follows:
    </para>
    <programlisting language="ocaml">
let messages_for_user user messages =
  let (user_messages,_) =
    List.fold messages ~init:([],String.Set.empty)
      ~f:(fun ((messages,user_sessions) as acc) ((common,details) as message) -&gt;
        let session_id = common.Common.session_id in
        match details with
        | Logon m -&gt;
          if m.Logon.user = user then
            (message::messages, Set.add user_sessions session_id)
          else acc
        | Heartbeat _ | Log_entry _ -&gt;
          if Set.mem user_sessions session_id then
            (message::messages,user_sessions)
          else acc
      )
  in
  List.rev user_messages
</programlisting>
    <para>
      Note that the more complex match statement for computing the
      session id has been replaced with the simple expression
      <literal>common.Common.session_id</literal>.
    </para>
    <para>
      This basic design is good in another way: it allows us to
      essentially downcast to the specific message type once we know
      what it is, and then dispatch code to handle just that message
      type. In particular, while we use the type
      <literal>Common.t * details</literal> to represent an arbitrary
      message, we can use <literal>Common.t * Logon.t</literal> to
      represent a logon message. Thus, if we had functions for handling
      individual message types, we could write a dispatch function as
      follows.
    </para>
    <programlisting language="ocaml">
let handle_message server_state (common,details) =
  match details with
  | Log_entry m -&gt; handle_log_entry server_state (common,m)
  | Logon     m -&gt; handle_logon     server_state (common,m)
  | Heartbeat m -&gt; handle_heartbeat server_state (common,m)
</programlisting>
    <para>
      And it's explicit at the type level that
      <literal>handle_log_entry</literal> sees only
      <literal>Log_entry</literal> messages,
      <literal>handle_logon</literal> sees only <literal>Logon</literal>
      messages, etc.
    </para>
  </sect1>
  <sect1 id="variants-and-recursive-data-structures">
    <title>Variants and recursive data structures</title>
    <para>
      Another common application of variants is to represent tree-like
      recursive data-structures. Let's see how this works by working
      through a simple example: designing a Boolean expression
      evaluator.
    </para>
    <para>
      Such a language can be useful anywhere you need to specify
      filters, which are used in everything from packet analyzers to
      mail clients. Below, we define a variant called
      <literal>blang</literal> (short for &quot;binary language&quot;)
      with one constructor for each kind of expression we want to
      support.
    </para>
    <programlisting>
# type 'a blang =
  | Base  of 'a
  | Const of bool
  | And   of 'a blang list
  | Or    of 'a blang list
  | Not   of 'a blang
  ;;
</programlisting>
    <para>
      Note that the definition of the type <literal>blang</literal> is
      recursive, meaning that a <literal>blang</literal> may contain
      other <literal>blang</literal>s.
    </para>
    <para>
      The only mysterious bit about <literal>blang</literal> is the role
      of <literal>Base</literal>. The <literal>Base</literal>
      constructor is to let the language include a set of base
      predicates. These base predicates tie the expressions in question
      to whatever our application is. Thus, if you were writing a filter
      language for an email processor, your base predicates might
      specify the tests you would run against an email. Here's a simple
      example of how you might define a base predicate type.
    </para>
    <programlisting>
# type mail_field = To | From | CC | Date | Subject
  type mail_predicate = { field: mail_field;
                          contains: string }
  ;;
</programlisting>
    <para>
      And now, we can construct a simple expression that uses
      <literal>mail_predicate</literal> for its base predicate.
    </para>
    <programlisting>
# And [ Or [ Base { field = To; contains = &quot;doligez&quot; } ;
             Base { field = CC; contains = &quot;doligez&quot; } ];
        Base { field = Subject; contains = &quot;runtime&quot; } ];;
    - : mail_predicate blang =
And
 [Or
   [Base {field = To; contains = &quot;doligez&quot;};
    Base {field = CC; contains = &quot;doligez&quot;}];
  Base {field = Subject; contains = &quot;runtime&quot;}]
</programlisting>
    <para>
      Being able to construct such expressions is all well and good, but
      to do any real work, we need some way to evaluate an expression.
      Here's a piece of code to do just that.
    </para>
    <programlisting>
# let rec eval blang base_eval =
    let eval' blang = eval blang base_eval in
    match blang with
    | Base  base   -&gt; base_eval base
    | Const bool   -&gt; bool
    | And   blangs -&gt; List.for_all blangs ~f:eval'
    | Or    blangs -&gt; List.exists  blangs ~f:eval'
    | Not   blang  -&gt; not (eval' blang)
  ;;
val eval : 'a blang  -&gt; ('a -&gt; bool) -&gt; bool = &lt;fun&gt;
</programlisting>
    <para>
      The structure of the code is pretty straightforward --- we're just
      walking over the structure of the data, doing the appropriate
      thing at each state, which sometimes requires a recursive call and
      sometimes doesn't. We did define a helper function,
      <literal>eval'</literal>, which is just <literal>eval</literal>
      specialized to use <literal>base_eval</literal>, and is there to
      remove some boilerplate from the recursive calls to
      <literal>eval</literal>.
    </para>
    <para>
      We can also write code to transform an expression, for example, by
      simplifying it. Here's a function to does just that.
    </para>
    <programlisting>
# let rec simplify = function
    | Base _ | Const _ as x -&gt; x
    | And blangs -&gt;
      let blangs = List.map ~f:simplify blangs in
      if List.exists blangs ~f:(function Const false -&gt; true | _ -&gt; false)
      then Const false
      else And blangs
    | Or blangs -&gt;
      let blangs = List.map ~f:simplify blangs in
      if List.exists blangs ~f:(function Const true -&gt; true | _ -&gt; false)
      then Const true else Or blangs
    | Not blang -&gt;
      match simplify blang with
      | Const bool -&gt; Const (not bool)
      | blang -&gt; Not blang
  ;;
val simplify : 'a blang -&gt; 'a blang = &lt;fun&gt;
</programlisting>
    <para>
      One thing to notice about the above code is that it uses a
      catch-all case in the very last line within the
      <literal>Not</literal> case. It's generally better to be explicit
      about the cases you're ignoring. Indeed, if we change this snippet
      of code to be more explicit:
    </para>
    <programlisting language="ocaml">
    | Not blang -&gt;
      match simplify blang with
      | Const bool -&gt; Const (not bool)
      | (And _ | Or _ | Base _ | Not _) -&gt; Not blang
</programlisting>
    <para>
      we can immediately notice that we've missed an important
      simplification. Really, we should have simplified double negation.
    </para>
    <programlisting language="ocaml">
    | Not blang -&gt;
      match simplify blang with
      | Const b -&gt; Const (not b)
      | Not blang -&gt; blang
      | (And _ | Or _ | Base _ ) -&gt; Not blang
</programlisting>
    <para>
      This example is more than a toy. There's a module very much in
      this spirit already exists as part of Core, and gets a lot of
      practical use in a variety of applications. More generally, using
      variants to build recursive data-structures is a common technique,
      and shows up everywhere from designing little languages to
      building efficient data-structures like red-black trees.
    </para>
  </sect1>
  <sect1 id="polymorphic-variants">
    <title>Polymorphic variants</title>
    <para>
      In addition to the ordinary variants we've seen so far, OCaml also
      supports so-called <emphasis>polymorphic variants</emphasis>. As
      we'll see, polymorphic variants are more flexible and
      syntactically more lightweight than ordinary variants, but that
      extra power comes at a cost, as we'll see.
    </para>
    <para>
      Syntactically, polymorphic variants are distinguished from
      ordinary variants by the leading backtick. Pleasantly enough, you
      can create a polymorphic variant without first writing an explicit
      type declaration.
    </para>
    <programlisting>
# let three = `Int 3;;
val three : [&gt; `Int of int ] = `Int 3
# let four = `Float 4.;;
val four : [&gt; `Float of float ] = `Float 4.
# let nan = `Not_a_number;;
val nan : [&gt; `Not_a_number ] = `Not_a_number
# [three; four; nan];;
- : [&gt; `Float of float | `Int of int | `Not_a_number ] list =
[`Int 3; `Float 4.; `Not_a_number]
</programlisting>
    <para>
      Variant types are inferred automatically from their use, and when
      we combine variants whose types contemplate different tags, the
      compiler infers a new type that knows about both all those tags.
    </para>
    <para>
      The type system will complain, however, if it sees incompatible
      uses of the same tag:
    </para>
    <programlisting>
# let five = `Int &quot;five&quot;;;
val five : [&gt; `Int of string ] = `Int &quot;five&quot;
# [three; four; five];;
Characters 14-18:
  [three; four; five];;
                ^^^^
Error: This expression has type [&gt; `Int of string ]
       but an expression was expected of type
         [&gt; `Float of float | `Int of int ]
       Types for tag `Int are incompatible
</programlisting>
    <para>
      The <literal>&gt;</literal> at the beginning of the variant types
      above is critical, because it marks the types as being open to
      combination with other variant types. We can read the type
      <literal>[&gt; `Int of string | `Float of float]</literal> as
      describing a variant whose tags include
      <literal>`Int of string</literal> and
      <literal>`Float of float</literal>, but may include more tags as
      well. You can roughly translate <literal>&gt;</literal> to
      &quot;these tags or more&quot;.
    </para>
    <para>
      OCaml will in some cases infer a variant type with
      <literal>&lt;</literal>, to indicate &quot;these tags or
      less&quot;, as in the following example.
    </para>
    <programlisting>
# let is_positive = function
     | `Int   x -&gt; x &gt; 0
     | `Float x -&gt; x &gt; 0.
  ;;
val is_positive : [&lt; `Float of float | `Int of int ] -&gt; bool = &lt;fun&gt;
</programlisting>
    <para>
      The <literal>&lt;</literal> is there because
      <literal>is_positive</literal> has no way of dealing with values
      that have tags other than <literal>`Float of float</literal> or
      <literal>`Int of int</literal>.
    </para>
    <para>
      We can think of these <literal>&lt;</literal> and
      <literal>&gt;</literal> markers as indications of upper and lower
      bounds. If the same type is both an upper and a lower bound, we
      end up with an <emphasis>exact</emphasis> polymorphic variant
      type, which has neither marker. For example:
    </para>
    <programlisting>
# let exact = List.filter ~f:is_positive [three;four];;
val exact : [ `Float of float | `Int of int ] list
   = [`Int 3; `Float 4.]
</programlisting>
    <sidebar><title>
    Polymorphic variants and casts
    </title>
    <para>
      Most of the time, the inference system is able to infer
      polymorphic variant types that work without any extra help from
      the user. In some cases, however, OCaml can't figure out how to
      make the types work on its own, and requires some extra
      annotations.
    </para>
    <programlisting>
</programlisting>
    </sidebar>
    <para>
      Perhaps surprisingly, we can also create polymorphic variant types
      that have different lower and upper bounds.
    </para>
    <programlisting>
let is_positive = function
     | `Int   x -&gt; Ok (x &gt; 0)
     | `Float x -&gt; Ok (x &gt; 0.)
     | `Not_a_number -&gt; Error &quot;not a number&quot;;;
val is_positive :
  [&lt; `Float of float | `Int of int | `Not_a_number ] -&gt;
  (bool, string) Result.t = &lt;fun&gt;
# List.filter [three; four] ~f:(fun x -&gt;
     match is_positive x with Error _ -&gt; false | Ok b -&gt; b);;
  - : [&lt; `Float of float | `Int of int | `Not_a_number &gt; `Float `Int ]
    List.t
= [`Int 3; `Float 4.]
</programlisting>
    <para>
      Here, the inferred type states that the tags can be no more than
      <literal>`Float</literal>, <literal>`Int</literal> and
      <literal>`Not_a_number</literal>, and must contain at least
      <literal>`Float</literal> and <literal>`Int</literal>. As you can
      already start to see, polymorphic variants can lead to fairly
      complex inferred types.
    </para>
    <sect2 id="example-terminal-colors-redux">
      <title>Example: Terminal colors redux</title>
      <para>
        To see how to use polymorphic variants in practice, let's go
        back to the terminal color example that we discussed earlier.
        Imagine that we have a new terminal type that adds yet more
        colors, say, by adding an alpha channel so you can specify
        translucent colors. We could model this extended set of colors
        as follows, using an ordinary variant.
      </para>
      <programlisting>
# type extended_color =
  | Basic of basic_color * weight  (* basic colors, regular and bold *)
  | RGB   of int * int * int       (* 6x6x6 color space *)
  | Gray  of int                   (* 24 grayscale levels *)
  | RGBA  of int * int * int * int (* 6x6x6x6 color space *)
  ;;
</programlisting>
      <para>
        We want to write a function
        <literal>extended_color_to_int</literal>, that works like
        <literal>color_to_int</literal> for all of the old kinds of
        colors, with new logic only for handling colors that include an
        alpha channel. We might think we could write the function to do
        this as follows.
      </para>
      <programlisting>
# let extended_color_to_int = function
    | RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
    | (Basic _ | RGB _ | Gray _) as color -&gt; color_to_int color
  ;;
</programlisting>
      <para>
        This looks reasonable enough, but it leads to the following type
        error.
      </para>
      <programlisting>
Characters 93-98:
    | (Basic _ | RGB _ | Gray _) as color -&gt; color_to_int color
                                                          ^^^^^
Error: This expression has type extended_color
       but an expression was expected of type color
</programlisting>
      <para>
        The problem is that <literal>extended_color</literal> and
        <literal>color</literal> are in the compiler's view distinct and
        unrelated types. The compiler doesn't, for example, recognize
        any equality between the <literal>Basic</literal> constructor in
        the two types.
      </para>
      <para>
        What we essentially want to do is to share constructors between
        two different types, and polymorphic variants let us do this.
        First, let's rewrite <literal>basic_color_to_int</literal> and
        <literal>color_to_int</literal> using polymorphic variants. The
        translation here is entirely straightforward.
      </para>
      <programlisting>
# let basic_color_to_int = function
    | `Black -&gt; 0 | `Red     -&gt; 1 | `Green -&gt; 2 | `Yellow -&gt; 3
    | `Blue  -&gt; 4 | `Magenta -&gt; 5 | `Cyan  -&gt; 6 | `White  -&gt; 7

  let color_to_int = function
    | `Basic (basic_color,weight) -&gt;
      let base = match weight with `Bold -&gt; 8 | `Regular -&gt; 0 in
      base + basic_color_to_int basic_color
    | `RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
    | `Gray i -&gt; 232 + i
 ;;
val basic_color_to_int :
  [&lt; `Black | `Blue | `Cyan | `Green | `Magenta | `Red | `White | `Yellow ] -&gt;
  int = &lt;fun&gt;
val color_to_int :
  [&lt; `Basic of
       [&lt; `Black | `Blue | `Cyan | `Green | `Magenta | `Red
        | `White | `Yellow ] *
       [&lt; `Bold | `Regular ]
   | `Gray of int
   | `RGB of int * int * int ] -&gt;
  int = &lt;fun&gt;
</programlisting>
      <para>
        Now we can try writing <literal>extended_color_to_int</literal>.
        The key issue with this code is that
        <literal>extended_color_to_int</literal> needs to invoke
        <literal>color_to_int</literal> with a narrower type,
        <emphasis>i.e.</emphasis>, one that includes fewer tags. Written
        properly, this narrowing can be done via a pattern match. In
        particular, in the following code, the type of the variable
        <literal>color</literal> includes only the tags
        <literal>`Basic</literal>, <literal>`RGB</literal> and
        <literal>`Gray</literal>, and not <literal>`RGBA</literal>.
      </para>
      <programlisting>
# let extended_color_to_int = function
    | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
    | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color
  ;;
val extended_color_to_int :
  [&lt; `Basic of
       [&lt; `Black | `Blue | `Cyan | `Green | `Magenta | `Red
        | `White | `Yellow ] *
       [&lt; `Bold | `Regular ]
   | `Gray of int
   | `RGB of int * int * int
   | `RGBA of int * int * int * int ] -&gt;
  int = &lt;fun&gt;
</programlisting>
      <para>
        The above code is more delicately balanced than one might
        imagine. In particular, if we use a catch-all case instead of an
        explicit enumeration of the cases, the type is no longer
        narrowed, and so compilation fails.
      </para>
      <programlisting>
# let extended_color_to_int = function
    | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
    | color -&gt; color_to_int color
  ;;
      Characters 125-130:
      | color -&gt; color_to_int color
                              ^^^^^
Error: This expression has type [&gt; `RGBA of int * int * int * int ]
       but an expression was expected of type
         [&lt; `Basic of
              [&lt; `Black | `Blue | `Cyan | `Green | `Magenta | `Red
               | `White | `Yellow ] *
              [&lt; `Bold | `Regular ]
          | `Gray of int
          | `RGB of int * int * int ]
       The second variant type does not allow tag(s) `RGBA
</programlisting>
      <sidebar><title>
      Polymorphic variants and catch-all cases
      </title>
      <para>
        As we saw with the definition of <literal>is_positive</literal>,
        a match statement can lead to the inference of an upper bound on
        a variant type, limiting the possible tags to those that can be
        handled by the match. If we add a catch-all case to our match
        statement, we end up with a function with a lower bound.
      </para>
      <programlisting>
# let is_positive_permissive = function
     | `Int   x -&gt; Ok (x &gt; 0)
     | `Float x -&gt; Ok (x &gt; 0.)
     | _ -&gt; Error &quot;Unknown number type&quot;
  ;;
val is_positive_permissive :
  [&gt; `Float of float | `Int of int ] -&gt; (bool, string) Core.Std._result =
  &lt;fun&gt;
# is_positive_permissive (`Int 0);;
- : (bool, string) Result.t = Ok false
# is_positive_permissive (`Ratio (3,4));;
- : (bool, string) Result.t = Error &quot;Unknown number type&quot;
</programlisting>
      <para>
        Catch-all cases are error-prone even with ordinary variants, but
        they are especially so with polymorphic variants. That's because
        you have no way of bounding what tags your function might have
        to deal with. Such code is particularly vulnerable to typos. For
        instance, if code that uses
        <literal>is_positive_permissive</literal> passes in
        <literal>Float</literal> misspelled as <literal>Floot</literal>,
        the erroneous code will compile without complaint.
      </para>
      <programlisting>
# is_positive_permissive (`Floot 3.5);;
- : (bool, string) Result.t = Error &quot;Unknown number type&quot;
</programlisting>
      <para>
        With ordinary variants, such a typo would have been caught as an
        unknown constructor. As a general matter, one should be wary
        about mixing catch-all cases and polymorphic variants.
      </para>
      </sidebar>
      <para>
        The code here is fragile in a different way, in that it's too
        vulnerable to typos. Let's consider how we might write this code
        as a proper library, including a proper <literal>mli</literal>.
        The interface might look something like this:
      </para>
      <programlisting language="ocaml">
(* file: terminal_color.mli *)

open Core.Std

type basic_color =
  [ `Black   | `Blue | `Cyan  | `Green
  | `Magenta | `Red  | `White | `Yellow ]

type color =
  [ `Basic of basic_color * [ `Bold | `Regular ]
  | `Gray of int
  | `RGB  of int * int * int ]

type extended_color =
  [ color
  | `RGBA of int * int * int * int ]

val color_to_int          : color -&gt; int
val extended_color_to_int : extended_color -&gt; int
</programlisting>
      <para>
        Here, <literal>extended_color</literal> is defined as an
        explicit extension of <literal>color</literal>. Also, notice
        that we defined all of these types as exact variants. Now here's
        what the implementation might look like.
      </para>
      <programlisting language="ocaml">
open Core.Std

type basic_color =
  [ `Black   | `Blue | `Cyan  | `Green
  | `Magenta | `Red  | `White | `Yellow ]

type color =
  [ `Basic of basic_color * [ `Bold | `Regular ]
  | `Gray of int
  | `RGB  of int * int * int ]

type extended_color =
  [ color
  | `RGBA of int * int * int * int ]

let basic_color_to_int = function
  | `Black -&gt; 0 | `Red     -&gt; 1 | `Green -&gt; 2 | `Yellow -&gt; 3
  | `Blue  -&gt; 4 | `Magenta -&gt; 5 | `Cyan  -&gt; 6 | `White  -&gt; 7

let color_to_int = function
  | `Basic (basic_color,weight) -&gt;
    let base = match weight with `Bold -&gt; 8 | `Regular -&gt; 0 in
    base + basic_color_to_int basic_color
  | `RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
  | `Gray i -&gt; 232 + i

let extended_color_to_int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | `Grey x -&gt; 2000 + x
  | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color
</programlisting>
      <para>
        In this case, a change was made to
        <literal>extended_color_to_int</literal>, to add special-case
        handling for the color gray, rather than using
        <literal>color_to_int</literal>. Unfortunately,
        <literal>Gray</literal> was misspelled as
        <literal>Grey</literal>, and the compiler didn't complain. It
        just inferred a bigger type for
        <literal>extended_color_to_int</literal>, which happens to be
        compatible with the <literal>mli</literal>, and so it compiles
        without incident.
      </para>
      <para>
        If we add an explicit type annotation to the code itself (rather
        than just in the mli), then the compiler has enough information
        to warn us.
      </para>
      <programlisting language="ocaml">
let extended_color_to_int : extended_color -&gt; int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | `Grey x -&gt; 2000 + x
  | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color
</programlisting>
      <para>
        In particular, the compiler will complain that the
        <literal>`Grey</literal> case as unused.
      </para>
      <programlisting language="ocaml">
File &quot;terminal_color.ml&quot;, line 29, characters 4-11:
Warning 11: this match case is unused.
</programlisting>
      <para>
        Once we have type definitions at our disposal, we can revisit
        the question of how we write the pattern-match that narrows the
        type. In particular, we can explicitly use the type name as part
        of the pattern match, by prefixing it with a
        <literal>#</literal>.
      </para>
      <programlisting language="ocaml">
let extended_color_to_int : extended_color -&gt; int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | #color as color -&gt; color_to_int color
</programlisting>
      <para>
        This is useful when you want to narrow down to a type whose
        definition is long, and you don't want the verbosity of writing
        the tags down explicitly in the match.
      </para>
    </sect2>
    <sect2 id="when-to-use-polymorphic-variants">
      <title>When to use polymorphic variants</title>
      <para>
        At first glance, polymorphic variants look like a strict
        improvement over ordinary variants. You can do everything that
        ordinary variants can do, plus it's more flexible and more
        concise. What's not to like?
      </para>
      <para>
        In reality, regular variants are the more pragmatic choice most
        of the time. That's because the flexibility of polymorphic
        variants comes at a price. Here are some of the downsides.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis>Efficiency:</emphasis> This isn't a huge effect,
            but polymorphic variants are somewhat heavier than regular
            variants, and OCaml can't generate code for matching on
            polymorphic variants that is quite as efficient as what is
            generated for regular variants.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>Error-finding:</emphasis> Polymorphic variants are
            type-safe, but the typing discipline that they impose is, by
            dint of its flexibility, less likely to catch bugs in your
            program.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>Complexity:</emphasis> As we've seen, the typing
            rules for polymorphic variants are a lot more complicated
            than they are for regular variants. This means that heavy
            use of polymorphic variants can leave you scratching your
            head trying to figure out why a given piece of code did or
            didn't compile. It can also lead to absurdly long and hard
            to decode error messages.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        All that said, polymorphic variants are still a useful and
        powerful feature, but it's worth understanding their
        limitations, and how to use them sensibly and modestly.
      </para>
      <para>
        Probably the safest and most common use-case for polymorphic
        variants is for cases where ordinary variants would be
        sufficient, but are syntactically too heavyweight. For example,
        you often want to create a variant type for encoding the inputs
        or outputs to a function, where it's not worth declaring a
        separate type for it. Polymorphic variants are very useful here,
        and as long as there are type annotations that constrain these
        to have explicit, exact types, this tends to work well.
      </para>
      <para>
        Variants are most problematic exactly where you take full
        advantage of their power; in particular, when you take advantage
        of the ability of polymorphic variant types to overlap in the
        tags they support. This ties into OCaml's support for subtyping.
        As we'll discuss further when we cover objects in Chapter
        {{{OBJECTS}}}, subtyping brings in a lot of complexity, and most
        of the time, that's complexity you want to avoid.
      </para>
    </sect2>
  </sect1>
</chapter>
<chapter id="error-handling">
  <title>Error Handling</title>
  <para>
    Nobody likes dealing with errors. It's tedious, it's easy to get
    wrong, and it's usually just not as fun as planning out how your
    program is going to succeed. But error handling is important, and
    however much you don't like thinking about it, having your software
    fail due to poor error handling code is worse.
  </para>
  <para>
    Thankfully, OCaml has powerful tools for handling errors reliably
    and with a minimum of pain. In this chapter we'll discuss some of
    the different approaches in OCaml to handling errors, and give some
    advice on how to design interfaces that help rather than hinder
    error handling.
  </para>
  <para>
    We'll start by describing the two basic approaches for reporting
    errors in OCaml: error-aware return types and exceptions.
  </para>
  <sect1 id="error-aware-return-types">
    <title>Error-aware return types</title>
    <para>
      The best way in OCaml to signal an error is to include that error
      in your return value. Consider the type of the
      <literal>find</literal> function in the list module.
    </para>
    <programlisting>
# List.find;;
- : 'a list -&gt; f:('a -&gt; bool) -&gt; 'a option
</programlisting>
    <para>
      The option in the return type indicates that the function may not
      succeed in finding a suitable element, as you can see below.
    </para>
    <programlisting>
# List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 2) ;;
- : int option = Some 2
# List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 10) ;;
- : int option = None
</programlisting>
    <para>
      Having errors be explicit in the return values of your functions
      tells the caller that there is an error that needs to be handled.
      The caller can then handle the error explicitly, either recovering
      from the error or propagating it onward.
    </para>
    <para>
      The function <literal>compute_bounds</literal> below is an example
      of how you can handle errors in this style. The function takes a
      list and a comparison function, and returns upper and lower bounds
      for the list by finding the smallest and largest element on the
      list. <literal>List.hd</literal> and <literal>List.last</literal>,
      which return <literal>None</literal> when they encounter an empty
      list, are used to extract the largest and smallest element of the
      list.
    </para>
    <programlisting language="ocaml">
# let compute_bounds ~cmp list =
    let sorted = List.sort ~cmp list in
    let smallest = List.hd sorted in
    let largest = List.last sorted in
    match smallest, largest with
    | None,_ | _, None -&gt; None
    | Some x, Some y -&gt; Some (x,y)
  ;;
val compute_bounds :
  cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option = &lt;fun&gt;
</programlisting>
    <para>
      The match statement is used to handle the error cases, propagating
      an error in <literal>hd</literal> or <literal>last</literal> into
      the return value of <literal>compute_bounds</literal>. On the
      other hand, in <literal>find_mismatches</literal> below, errors
      encountered during the computation do not propagate to the return
      value of the function. <literal>find_mismatches</literal> takes
      two hashtables as its arguments and tries to find keys that are
      stored in both. As such, a failure to find a key in one of the
      tables isn't really an error.
    </para>
    <programlisting language="ocaml">
# let find_mismatches table1 table2 =
     Hashtbl.fold table1 ~init:[] ~f:(fun ~key ~data errors -&gt;
        match Hashtbl.find table2 key with
        | Some data' when data' &lt;&gt; data -&gt; key :: errors
        | _ -&gt; errors
     )
 ;;
val find_mismatches :
  ('a, 'b) Hashtbl.t -&gt; ('a, 'b) Hashtbl.t -&gt; 'a list = &lt;fun&gt;
</programlisting>
    <para>
      The use of options to encode errors underlines the fact that it's
      not clear whether a particular outcome, like not finding something
      on a list, is really an error, or just another valid outcome of
      your function. This turns out to be very context-dependent, and
      error-aware return types give you a uniform way of handling the
      result that works well for both situations.
    </para>
    <sect2 id="encoding-errors-with-result">
      <title>Encoding errors with <literal>Result</literal></title>
      <para>
        Options aren't always a sufficiently expressive way to report
        errors. Specifically, when you encode an error as
        <literal>None</literal>, there's nowhere to say anything about
        the nature of the error.
      </para>
      <para>
        <literal>Result.t</literal> is meant to address this deficiency.
        Here's the definition:
      </para>
      <programlisting language="ocaml">
module Result : sig
   type ('a,'b) t = | Ok of 'a
                    | Error of 'b
end
</programlisting>
      <para>
        A <literal>Result.t</literal> is essentially an option augmented
        with the ability to store other information in the error case.
        Like <literal>Some</literal> and <literal>None</literal> for
        options, the constructors <literal>Ok</literal> and
        <literal>Error</literal> are promoted to the top-level by
        <literal>Core.Std</literal>. As such, we can write:
      </para>
      <programlisting>
# [ Ok 3; Error &quot;abject failure&quot;; Ok 4 ];;
[Ok 3; Error &quot;abject failure&quot;; Ok 4]
- : (int, string) Result.t list =
[Ok 3; Error &quot;abject failure&quot;; Ok 4]
</programlisting>
      <para>
        without first opening the <literal>Result</literal> module.
      </para>
    </sect2>
    <sect2 id="error-and-or_error">
      <title><literal>Error</literal> and
      <literal>Or_error</literal></title>
      <para>
        <literal>Result.t</literal> gives you complete freedom to choose
        the type of value you use to represent errors, but it's often
        useful to standardize on an error type. Among other things, this
        makes it easier to write utility functions to automate common
        error handling patterns.
      </para>
      <para>
        But which type to choose? Is it better to represent errors as
        strings? Or S-expressions? Or something else entirely?
      </para>
      <para>
        Core's answer to this question is the <literal>Error.t</literal>
        type, which tries to forge a good compromise between efficiency,
        convenience and control over the presentation of errors.
      </para>
      <para>
        It might not be obvious at first why efficiency is an issue at
        all. But generating error messages is an expensive business. An
        ASCII representation of a type can be quite time-consuming to
        construct, particularly if it includes expensive-to-convert
        numerical datatypes.
      </para>
      <para>
        <literal>Error</literal> gets around this issue through
        laziness. In particular, an <literal>Error.t</literal> allows
        you to put off generation of the actual error string until you
        actually need, which means a lot of the time you never have to
        construct it at all. You can of course construct an error
        directly from a string:
      </para>
      <programlisting>
# Error.of_string &quot;something went wrong&quot;;;
- : Core.Std.Error.t = &quot;something went wrong&quot;
</programlisting>
      <para>
        A more interesting construction message from a performance point
        of view is to construct an <literal>Error.t</literal> from a
        thunk:
      </para>
      <programlisting>
# Error.of_thunk (fun () -&gt;
    sprintf &quot;something went wrong: %f&quot; 32.3343);;
  - : Core.Std.Error.t = &quot;something went wrong: 32.334300&quot;
</programlisting>
      <para>
        In this case, we can benefit from the laziness of
        <literal>Error</literal>, since the thunk won't be called until
        the <literal>Error.t</literal> is converted to a string.
      </para>
      <para>
        We can also create an <literal>Error.t</literal> based on an
        s-expression converter. This is probably the most common idiom
        in Core.
      </para>
      <programlisting>
# Error.create &quot;Something failed a long time ago&quot; Time.epoch Time.sexp_of_t;;
- : Core.Std.Error.t =
&quot;Something failed a long time ago: (1969-12-31 19:00:00.000000)&quot;
</programlisting>
      <para>
        Here, the value <literal>Time.epoch</literal> is included in the
        error, but <literal>Time.sexp_of_t</literal>, which is used for
        converting the time to an s-expression, isn't run until the
        error is converted to a string. Using the Sexplib
        syntax-extension, which is discussed in more detail in chapter
        {{SYNTAX}}, we can inline create an s-expression converter for a
        collection of types, thus allowing us to register multiple
        pieces of data in an <literal>Error.t</literal>.
      </para>
      <programlisting>
# Error.create &quot;Something went terribly wrong&quot;
    (3.5, [&quot;a&quot;;&quot;b&quot;;&quot;c&quot;],6034)
    &lt;:sexp_of&lt;float * string list * int&gt;&gt; ;;
- : Core.Std.Error.t = &quot;Something went terribly wrong: (3.5(a b c)6034)&quot;
</programlisting>
      <para>
        Here, the declaration
        <literal>&lt;:sexp_of&lt;float * string list * int&gt;&gt;</literal>
        asks Sexplib to generate the sexp-converter for the tuple.
      </para>
      <para>
        Error also has operations for transforming errors. For example,
        it's often useful to augment an error with some extra
        information about the context of the error, or to combine
        multiplier errors together. <literal>Error.of_list</literal> and
        <literal>Error.tag</literal> fill these roles.
      </para>
      <para>
        The type <literal>'a Or_error.t</literal> is just a shorthand
        for <literal>('a,Error.t) Result.t</literal>, and it is, after
        <literal>option</literal>, the most common way of returning
        errors in Core.
      </para>
    </sect2>
    <sect2 id="bind-and-other-error-handling-idioms">
      <title><literal>bind</literal> and other error-handling
      idioms</title>
      <para>
        As you write more error handling code, you'll discover that
        certain patterns start to emerge. A number of these common
        patterns been codified in the interfaces of modules like
        <literal>Option</literal> and <literal>Result</literal>. One
        particularly useful one is built around the function
        <literal>bind</literal>, which is both an ordinary function and
        an infix operator <literal>&gt;&gt;=</literal>, both with the
        same type signature:
      </para>
      <programlisting language="ocaml">
val (&gt;&gt;=) : 'a option -&gt; ('a -&gt; 'b option) -&gt; 'b option
</programlisting>
      <para>
        <literal>bind</literal> is a way of sequencing together
        error-producing functions so that that the first one to produce
        an error terminates the computation. In particular,
        <literal>None &gt;&gt;= f</literal> returns
        <literal>None</literal> without calling <literal>f</literal>,
        and <literal>Some x &gt;&gt;= f</literal> returns
        <literal>f x</literal>. We can use a nested sequence of these
        binds to express a multi-stage computation that can fail at any
        stage. Here's a rewrite <literal>compute_bounds</literal> in
        this style.
      </para>
      <programlisting>
# let compute_bounds ~cmp list =
    let open Option.Monad_infix in
    let sorted = List.sort ~cmp list in
    List.hd sorted &gt;&gt;= (fun first -&gt;
      List.last sorted &gt;&gt;= (fun last -&gt;
        Some (first,last)))
</programlisting>
      <para>
        Note that we locally open the
        <literal>Option.Monad_infix</literal> module to get access to
        the infix operator <literal>&gt;&gt;=</literal>. The module is
        called <literal>Monad_infix</literal> because the bind operator
        is part of a sub-interface called <literal>Monad</literal>,
        which we'll talk about more in chapter {{{ASYNC}}}.
      </para>
      <para>
        This is a bit easier to read if we write it with fewer
        parentheses and less indentation, as follows.
      </para>
      <programlisting>
# let compute_bounds ~cmp list =
    let open Option.Monad_infix in
    let sorted = List.sort ~cmp list in
    List.hd sorted   &gt;&gt;= fun first -&gt;
    List.last sorted &gt;&gt;= fun last  -&gt;
    Some (first,last)
</programlisting>
      <para>
        There are other useful idioms encoded in the functions in
        <literal>Option</literal>. Another example is
        <literal>Option.both</literal>, which takes two optional values
        and produces a new optional pair that is <literal>None</literal>
        if either of its arguments are <literal>None</literal>. Using
        <literal>Option.both</literal>, we can make
        <literal>compute_bounds</literal> even shorter.
      </para>
      <programlisting>
# let compute_bounds ~cmp list =
    let sorted = List.sort ~cmp list in
    Option.both (List.hd sorted) (List.last sorted)
</programlisting>
      <para>
        These error-handling functions are valuable because they let you
        express your error handling both explicitly and concisely. We've
        only discussed these functions in the context of the
        <literal>Option</literal> module, but similar functionality is
        available in both <literal>Result</literal> and
        <literal>Or_error</literal>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="exceptions">
    <title>Exceptions</title>
    <para>
      Exceptions in OCaml are not that different from exceptions in many
      other languages, like Java, C# and Python. In all these cases,
      exceptions are a way to terminate a computation and report an
      error, while providing a mechanism to catch and handle (and
      possibly recover from) exceptions that are triggered by
      sub-computations.
    </para>
    <para>
      We'll see an exception triggered in OCaml if, for example, we try
      to divide an integer by zero:
    </para>
    <programlisting>
# 3 / 0;;
Exception: Division_by_zero.
</programlisting>
    <para>
      And an exception can terminate a computation even if it happens
      nested a few levels deep in a computation.
    </para>
    <programlisting>
# List.map ~f:(fun x -&gt; 100 / x) [1;3;0;4];;
Exception: Division_by_zero.
</programlisting>
    <para>
      In addition to built-in exceptions like
      <literal>Divide_by_zero</literal>, OCaml lets you define your own.
    </para>
    <programlisting>
# exception Key_not_found of string;;
exception Key_not_found of string
# Key_not_found &quot;a&quot;;;
- : exn = Key_not_found(&quot;a&quot;)
</programlisting>
    <para>
      Here's an example of a function for looking up a key in an
      <emphasis>association list</emphasis>, <emphasis>i.e.</emphasis> a
      list of key/value pairs which uses this newly-defined exception:
    </para>
    <programlisting>
# let rec find_exn alist key = match alist with
    | [] -&gt; raise (Key_not_found key)
    | (key',data) :: tl -&gt; if key = key' then data else find_exn tl key
  ;;
val find_exn : (string * 'a) list -&gt; string -&gt; 'a = &lt;fun&gt;
# let alist = [(&quot;a&quot;,1); (&quot;b&quot;,2)];;
val alist : (string * int) list = [(&quot;a&quot;, 1); (&quot;b&quot;, 2)]
# find_exn alist &quot;a&quot;;;
- : int = 1
# find_exn alist &quot;c&quot;;;
Exception: Key_not_found(&quot;c&quot;).
</programlisting>
    <para>
      Note that we named the function <literal>find_exn</literal> to
      warn the user that the function routinely throws exceptions, a
      convention that is used heavily in Core.
    </para>
    <para>
      In the above example, <literal>raise</literal> throws the
      exception, thus terminating the computation. The type of raise is
      a bit surprising when you first see it:
    </para>
    <programlisting>
# raise;;
- : exn -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      Having the return type be an otherwise unused type variable
      <literal>'a</literal> suggests that <literal>raise</literal> could
      return a value of any type. That seems impossible, and it is.
      <literal>raise</literal> has this type because it never returns at
      all. This behavior isn't restricted to functions like
      <literal>raise</literal> that terminate by throwing exceptions.
      Here's another example of a function that doesn't return a value.
    </para>
    <programlisting>
# let rec forever () = forever ();;
val forever : unit -&gt; 'a = &lt;fun&gt;
</programlisting>
    <para>
      <literal>forever</literal> doesn't return a value for a different
      reason: it is an infinite loop.
    </para>
    <para>
      This all matters because it means that the return type of
      <literal>raise</literal> can be whatever it needs to be to fit in
      to the context it is called in. Thus, the type system will let us
      throw an exception anywhere in a program.
    </para>
    <sidebar>
    <title>
    Declaring exceptions with <literal>with sexp</literal>
    </title>
    <para>
      OCaml can't always generate a useful textual representation of
      your exception, for example:
    </para>
    <programlisting>
# exception Wrong_date of Date.t;;
exception Wrong_date of Date.t
# Wrong_date (Date.of_string &quot;2011-02-23&quot;);;
- : exn = Wrong_date(_)
</programlisting>
    <para>
      But if you declare the exception using
      <literal>with sexp</literal> (and the constituent types have sexp
      converters), we'll get something with more information.
    </para>
    <programlisting>
# exception Wrong_date of Date.t with sexp;;
exception Wrong_date of Core.Std.Date.t
# Wrong_date (Date.of_string &quot;2011-02-23&quot;);;
- : exn = (.Wrong_date 2011-02-23)
</programlisting>
    <para>
      The period in front of <literal>Wrong_date</literal> is there
      because the representation generated by
      <literal>with sexp</literal> includes the full module path of the
      module where the exception in question is defined. This is quite
      useful in tracking down which precise exception is being reported.
      In this case, since we've declared the exception at the toplevel,
      that module path is trivial.
    </para>
    </sidebar>
    <sect2 id="exception-handlers">
      <title>Exception handlers</title>
      <para>
        So far, we've only seen exceptions fully terminate the execution
        of a computation. But often, we want a program to be able to
        respond to and recover from an exception. This is achieved
        through the use of <emphasis>exception handlers</emphasis>.
      </para>
      <para>
        In OCaml, an exception handler is declared using a
        <literal>try</literal>/<literal>with</literal> statement. Here's
        the basic syntax.
      </para>
      <programlisting>
try &lt;expr&gt; with
| &lt;pat1&gt; -&gt; &lt;expr1&gt;
| &lt;pat2&gt; -&gt; &lt;expr2&gt;
...
</programlisting>
      <para>
        A <literal>try</literal>/<literal>with</literal> clause would
        first evaluate <literal>&lt;expr&gt;</literal>, and if that
        evaluation completes without returning an exception, then the
        value of the overall expression is the value of
        <literal>&lt;expr&gt;</literal>.
      </para>
      <para>
        But if evaluating <literal>&lt;expr&gt;</literal> leads to an
        exception being thrown, then the exception will be fed to the
        pattern match statements following the <literal>with</literal>.
        If the exception matches a pattern, then the expression on the
        right hand side of that pattern will be evaluated. Otherwise,
        the original exception continues up the call stack, to be
        handled by the next outer exception handler, or terminate the
        program if there is none.
      </para>
    </sect2>
    <sect2 id="cleaning-up-in-the-presence-of-exceptions">
      <title>Cleaning up in the presence of exceptions</title>
      <para>
        One headache with exceptions is that they can terminate your
        execution at unexpected places, leaving your program in an
        awkward state. Consider the following code snippet:
      </para>
      <programlisting language="ocaml">
let load_config filename =
  let inc = In_channel.create filename in
  let config = Config.t_of_sexp (Sexp.input_sexp inc) in
  In_channel.close inc;
  config
</programlisting>
      <para>
        The problem with this code is that the function that loads the
        s-expression and parses it into a <literal>Config.t</literal>
        might throw an exception if the config file in question is
        malformed. Unfortunately, that means that the
        <literal>In_channel.t</literal> that was opened will never be
        closed, leading to a file-descriptor leak.
      </para>
      <para>
        We can fix this using Core's <literal>protect</literal>
        function. The basic purpose of <literal>protect</literal> is to
        ensure that the <literal>finally</literal> thunk will be called
        when <literal>f</literal> exits, whether it exited normally or
        with an exception. Here's how it could be used to fix
        <literal>load_config</literal>.
      </para>
      <programlisting language="ocaml">
let load_config filename =
  let inc = In_channel.create filename in
  protect ~f:(fun () -&gt; Config.t_of_sexp (Sexp.input_sexp inc)
    ~finally:(fun () -&gt; In_channel.close inc)
</programlisting>
    </sect2>
    <sect2 id="catching-specific-exceptions">
      <title>Catching specific exceptions</title>
      <para>
        OCaml's exception-handling system allows you to tune your
        error-recovery logic to the particular error that was thrown.
        For example, <literal>List.find_exn</literal> always throws
        <literal>Not_found</literal>. You can take advantage of this in
        your code, for example, let's define a function called
        <literal>lookup_weight</literal>, with the following signature:
      </para>
      <programlisting language="ocaml">
(** [lookup_weight ~compute_weight alist key] Looks up a
    floating-point weight by applying [compute_weight] to the data
    associated with [key] by [alist].  If [key] is not found, then
    return 0.
*)
val lookup_weight :
  compute_weight:('data -&gt; float) -&gt; ('key * 'data) list -&gt; 'key -&gt; float
</programlisting>
      <para>
        We can implement such a function using exceptions as follows:
      </para>
      <programlisting>
# let lookup_weight ~compute_weight alist key =
    try
      let data = List.Assoc.find_exn alist key in
      compute_weight data
    with
      Not_found -&gt; 0. ;;
val lookup_weight :
  compute_weight:('a -&gt; float) -&gt; ('b * 'a) list -&gt; 'b -&gt; float =
  &lt;fun&gt;
</programlisting>
      <para>
        This implementation is more problematic than it looks. In
        particular, what happens if <literal>compute_weight</literal>
        itself throws an exception? Ideally,
        <literal>lookup_weight</literal> should propagate that exception
        on, but if the exception happens to be
        <literal>Not_found</literal>, then that's not what will happen:
      </para>
      <programlisting>
# lookup_weight ~compute_weight:(fun _ -&gt; raise Not_found)
    [&quot;a&quot;,3; &quot;b&quot;,4] &quot;a&quot; ;;
- : float = 0.
</programlisting>
      <para>
        This kind of problem is hard to detect in advance, because the
        type system doesn't tell us what kinds of exceptions a given
        function might throw. Because of this kind of confusion, it's
        usually better to avoid catching specific exceptions. In this
        case, we can improve the code by catching the exception in a
        narrower scope.
      </para>
      <programlisting language="ocaml">
# let lookup_weight ~compute_weight alist key =
    match
      try Some (List.Assoc.find_exn alist key) with
      | Not_found -&gt; None
    with
    | None -&gt; 0.
    | Some data -&gt; compute_weight data ;;
</programlisting>
      <para>
        At which point, it makes sense to simply use the non-exception
        throwing function, <literal>List.Assoc.find</literal>, instead.
      </para>
    </sect2>
    <sect2 id="backtraces">
      <title>Backtraces</title>
      <para>
        A big part of the point of exceptions is to give useful
        debugging information. But at first glance, OCaml's exceptions
        can be less than informative. Consider the following simple
        program.
      </para>
      <programlisting language="ocaml">
(* exn.ml *)

open Core.Std
exception Empty_list

let list_max = function
  | [] -&gt; raise Empty_list
  | hd :: tl -&gt; List.fold tl ~init:hd ~f:(Int.max)

let () =
  printf &quot;%d\n&quot; (list_max [1;2;3]);
  printf &quot;%d\n&quot; (list_max [])
</programlisting>
      <para>
        If we build and run this program, we'll get a pretty
        uninformative error:
      </para>
      <programlisting>
$ ./exn
3
Fatal error: exception Exn.Empty_list
</programlisting>
      <para>
        The example in question is short enough that it's quite easy to
        see where the error came from. But in a complex program, simply
        knowing which exception was thrown is usually not enough
        information to figure out what went wrong.
      </para>
      <para>
        We can get more information from OCaml if we turn on stack
        traces. This can be done by setting the
        <literal>OCAMLRUNPARAM</literal> environment variable, as shown:
      </para>
      <programlisting>
exn $ export OCAMLRUNPARAM=b
exn $ ./exn
3
Fatal error: exception Exn.Empty_list
Raised at file &quot;exn.ml&quot;, line 7, characters 16-26
Called from file &quot;exn.ml&quot;, line 12, characters 17-28
</programlisting>
      <para>
        Backtraces can also be obtained at runtime. In particular,
        <literal>Exn.backtrace</literal> will return the backtrace of
        the most recently thrown exception.
      </para>
    </sect2>
    <sect2 id="exceptions-for-control-flow">
      <title>Exceptions for control flow</title>
      <para>
      </para>
    </sect2>
    <sect2 id="from-exceptions-to-error-aware-types-and-back-again">
      <title>From exceptions to error-aware types and back again</title>
      <para>
        Both exceptions and error-aware types are necessary parts of
        programming in OCaml. As such, you often need to move between
        these two worlds. Happily, Core comes with some useful helper
        functions to help you do just that. For example, given a piece
        of code that can throw an exception, you can capture that
        exception into an option as follows:
      </para>
      <programlisting>
# let find alist key =
    Option.try_with (fun () -&gt; find_exn alist key) ;;
val find : (string * 'a) list -&gt; string -&gt; 'a option = &lt;fun&gt;
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;c&quot;;;
- : int Core.Std.Option.t = None
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;b&quot;;;
- : int Core.Std.Option.t = Some 2
</programlisting>
      <para>
        And <literal>Result</literal> and <literal>Or_error</literal>
        have similar <literal>try_with</literal> functions. So, we could
        write:
      </para>
      <programlisting>
# let find alist key =
    Result.try_with (fun () -&gt; find_exn alist key) ;;
val find : (string * 'a) list -&gt; string -&gt; ('a, exn) Result.t = &lt;fun&gt;
# find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;c&quot;;;
- : (int, exn) Result.t = Result.Error Key_not_found(&quot;c&quot;)
</programlisting>
      <para>
        And then we can re-raise that exception:
      </para>
      <programlisting>
# Result.ok_exn (find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;b&quot;);;
- : int = 2
# Result.ok_exn (find [&quot;a&quot;,1; &quot;b&quot;,2] &quot;c&quot;);;
Exception: Key_not_found(&quot;c&quot;).
</programlisting>
    </sect2>
  </sect1>
</chapter>
<chapter id="imperative-programming-1">
  <title>Imperative Programming</title>
  <para>
  </para>
</chapter>
<chapter id="files-modules-and-programs">
  <title>Files, Modules and Programs</title>
  <para>
    We've so far experienced OCaml largely through the toplevel. As you
    move from exercises to real-world programs, you'll need to leave the
    toplevel behind and start building programs from files. Files are
    more than just a convenient way to store and manage your code; in
    OCaml, they also act as boundaries that divide your program into
    conceptual units.
  </para>
  <para>
    In this chapter, we'll show you how to build an OCaml program from a
    collection of files, as well as the basics of working with modules
    and module signatures.
  </para>
  <sect1 id="single-file-programs">
    <title>Single File Programs</title>
    <para>
      We'll start with an example: a utility that reads lines from
      <literal>stdin</literal>, computing a frequency count of the lines
      that have been read in. At the end, the 10 lines with the highest
      frequency counts are written out. Here's a simple implementation,
      which we'll save as the file <literal>freq.ml</literal>. Note that
      we're using several functions from the
      <literal>List.Assoc</literal> module, which provides utility
      functions for interacting with association lists,
      <emphasis>i.e.</emphasis>, lists of key/value pairs.
    </para>
    <programlisting language="ocaml">
(* freq.ml: basic implementation *)

open Core.Std

(* build_counts recursively builds up a mapping from lines to
   number of occurrences of that line. *)
let rec build_counts counts =
  match In_channel.input_line stdin with
  | None -&gt; counts (* EOF, so return the counts accumulated so far *)
  | Some line -&gt;
    (* get the number of times this line has been seen before,
       inferring 0 if the line doesn't show up in [counts] *)
    let count =
      match List.Assoc.find counts line with
      | None -&gt; 0
      | Some x -&gt; x
    in
    (* increment the count for line by 1, and recurse *)
    build_counts (List.Assoc.add counts line (count + 1))

let () =
  (* Compute the line counts *)
  let counts = build_counts [] in
  (* Sort the line counts in descending order of frequency *)
  let sorted_counts = List.sort ~cmp:(fun (_,x) (_,y) -&gt; descending x y) counts  in
  (* Print out the 10 highest frequency entries *)
  List.iter (List.take 10 sorted_counts) ~f:(fun (line,count) -&gt;
    printf &quot;%3d: %s\n&quot; count line)
</programlisting>
    <sidebar><title>
    Where is the main function?
    </title>
    <para>
      Unlike C, programs in OCaml do not have a unique
      <literal>main</literal> function. When an OCaml program is
      evaluated, all the statements in the implementation files are
      evaluated in order. These implementation files can contain
      arbitrary expressions, not just function definitions. In this
      example, the declaration starting with <literal>let () =</literal>
      plays the role of the <literal>main</literal> declaration, kicking
      off the processing. But really the entire file is evaluated at
      startup, and so in some sense the full codebase is one big
      <literal>main</literal> function.
    </para>
    </sidebar>
    <para>
      If we weren't using Core or any other external libraries, we could
      build the executable like this:
    </para>
    <programlisting>
ocamlc freq.ml -o freq
</programlisting>
    <para>
      But in this case, this command will fail with the error
      <literal>Unbound module Core</literal>. We need a somewhat more
      complex invocation to get Core linked in:
    </para>
    <programlisting>
ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq
</programlisting>
    <para>
      Here we're using <literal>ocamlfind</literal>, a tool which itself
      invokes other parts of the ocaml toolchain (in this case,
      <literal>ocamlc</literal>) with the appropriate flags to link in
      particular libraries and packages. Here,
      <literal>-package core</literal> is asking
      <literal>ocamlfind</literal> to link in the Core library,
      <literal>-linkpkg</literal> is required to do the final linking in
      of packages for building a runnable executable, and
      <literal>-thread</literal> turns on threading support, which is
      required for Core.
    </para>
    <para>
      While this works well enough for a one-file project, more
      complicated builds will require a tool to orchestrate the build.
      One great tool for this task is <literal>ocamlbuild</literal>,
      which is shipped with the OCaml compiler. We'll talk more about
      <literal>ocamlbuild</literal> in chapter {{{OCAMLBUILD}}}, but for
      now, we'll just walk through the steps required for this simple
      application. First, create a <literal>_tags</literal> file,
      containing the following lines.
    </para>
    <programlisting>
true:package(core),thread,annot,debugging
</programlisting>
    <para>
      The purpose of the <literal>_tags</literal> file is to specify
      which compilation options are required for which files. In this
      case, we're telling <literal>ocamlbuild</literal> to link in the
      <literal>core</literal> package and to turn on threading, output
      of annotation files, and debugging support for all files (the
      condition <literal>true</literal> causes the options to be applied
      to every file in the project.)
    </para>
    <para>
      We can then invoke <literal>ocamlbuild</literal> to build the
      executable in question.
    </para>
    <programlisting>
$ ocamlbuild -use-ocamlfind freq.byte
</programlisting>
    <para>
      If we'd invoked <literal>ocamlbuild</literal> with a target of
      <literal>freq.native</literal> instead of
      <literal>freq.byte</literal>, we would have gotten native-code
      instead.
    </para>
    <para>
      We can now run the our program from the command-line. The
      following line extracts strings from the
      <literal>ocamlopt</literal> executable, and then reports the most
      frequently occurring ones.
    </para>
    <programlisting>
$ strings `which ocamlopt` | ./freq.byte
 13: movq
 10: cmpq
  8: &quot;, &amp;
  7: .globl
  6: addq
  6: leaq
  5: &quot;, $
  5: .long
  5: .quad
  4: &quot;, '
</programlisting>
    <sidebar><title>
    Byte-code vs native-code
    </title>
    <para>
      OCaml ships with two compilers---the <literal>ocamlc</literal>
      byte-code compiler, and the <literal>ocamlopt</literal>
      native-code compiler. Programs compiled with
      <literal>ocamlc</literal> are interpreted by a virtual machine,
      while programs compiled with <literal>ocamlopt</literal> are
      compiled to native machine code to be run on a specific operating
      system and processor architecture.
    </para>
    <para>
      Aside from performance, executables generated by the two compilers
      have nearly identical behavior. There are a few things to be aware
      of. First, the byte-code compiler can be used on more
      architectures, and has some better tool support; in particular,
      the OCaml debugger only works with byte-code. Also, the byte-code
      compiler compiles faster than the native code compiler. Also, in
      order to run a bytecode executable you typically need to have
      OCaml installed on the system in question. That's not strictly
      required, though, since you can a byte-code executable with an
      embedded runtime, using the <literal>-custom</literal> compiler
      flag.
    </para>
    <para>
      As a general matter, production executables should usually be
      built using the native-code compiler, but it sometimes makes sense
      to use bytecode for development builds. And, of course, bytecode
      makes sense when targeting a platform not supported by the native
      code compiler.
    </para>
    </sidebar>

  </sect1>
  <sect1 id="multi-file-programs-and-modules">
    <title>Multi-file programs and modules</title>
    <para>
      Source files in OCaml are tied into the module system, with each
      file compiling down into a module whose name is derived from the
      name of the file. We've encountered modules before, for example,
      when we used functions like <literal>find</literal> and
      <literal>add</literal> from the <literal>List.Assoc</literal>
      module. At it's simplest, you can think of a module as a
      collection of definitions that are stored within a namespace.
    </para>
    <para>
      Let's consider how we can use modules to refactor the
      implementation of <literal>freq.ml</literal>. Remember that the
      variable <literal>counts</literal> contains an association list
      representing the counts of the lines seen so far. But updating an
      association list takes time linear in the length of the list,
      meaning that the time complexity of processing a file is quadratic
      in the number of distinct lines in the file.
    </para>
    <para>
      We can fix this problem by replacing association lists with a more
      efficient datastructure. To do that, we'll first factor out the
      key functionality into a separate module with an explicit
      interface. We can consider alternative (and more efficient)
      implementations once we have a clear interface to program against.
    </para>
    <para>
      We'll start by creating a file, <literal>counter.ml</literal>,
      that contains the logic for maintaining the association list used
      to describe the counts. The key function, called
      <literal>touch</literal>, updates the association list with the
      information that a given line should be added to the frequency
      counts.
    </para>
    <programlisting language="ocaml">
(* counter.ml: first version *)

open Core.Std

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)
</programlisting>
    <para>
      We can now rewrite <literal>freq.ml</literal> to use
      <literal>Counter</literal>. Note that the resulting code can still
      be built with <literal>build.sh</literal>, since
      <literal>ocamlbuild</literal> will discover dependencies and
      realize that <literal>counter.ml</literal> needs to be compiled.
    </para>
    <programlisting language="ocaml">
(* freq.ml: using Counter *)

open Core.Std

let rec build_counts counts =
  match In_channel.input_line stdin with
  | None -&gt; counts
  | Some line -&gt; build_counts (Counter.touch counts line)

let () =
  let counts = build_counts [] in
  let sorted_counts = List.sort counts
    ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  in
  List.iter (List.take sorted_counts 10)
    ~f:(fun (line,count) -&gt; printf &quot;%3d: %s\n&quot; count line)
</programlisting>
    <sect2 id="signatures-and-abstract-types">
      <title>Signatures and Abstract Types</title>
      <para>
        While we've pushed some of the logic to the
        <literal>Counter</literal> module, the code in
        <literal>freq.ml</literal> can still depend on the details of
        the implementation of <literal>Counter</literal>. Indeed, if you
        look at the invocation of <literal>build_counts</literal>:
      </para>
      <programlisting language="ocaml">
  let counts = build_counts [] in
</programlisting>
      <para>
        you'll see that it depends on the fact that the empty set of
        frequency counts is represented as an empty list. We'd like to
        prevent this kind of dependency, so that we can change the
        implementation of <literal>Counter</literal> without needing to
        change client code like that in <literal>freq.ml</literal>.
      </para>
      <para>
        The first step towards hiding the implementation details of
        <literal>Counter</literal> is to create an interface file,
        <literal>counter.mli</literal>, which controls how
        <literal>counter</literal> is accessed. Let's start by writing
        down a simple descriptive interface, <emphasis>i.e.</emphasis>,
        an interface that describes what's currently available in
        <literal>Counter</literal> without hiding anything. We'll use
        <literal>val</literal> declarations in the
        <literal>mli</literal>, which have the following syntax
      </para>
      <programlisting>
val &lt;identifier&gt; : &lt;type&gt;
</programlisting>
      <para>
        and are used to expose the existence of a given value in the
        module. Here's an interface that describes the current contents
        of <literal>Counter</literal>. We can save this as
        <literal>counter.mli</literal> and compile, and the program will
        build as before.
      </para>
      <programlisting language="ocaml">
(* counter.mli: descriptive interface *)

val touch : (string * int) list -&gt; string -&gt; (string * int) list
</programlisting>
      <para>
        To actually hide the fact that frequency counts are represented
        as association lists, we need to make the type of frequency
        counts <emphasis>abstract</emphasis>. A type is abstract if its
        name is exposed in the interface, but its definition is not.
        Here's an abstract interface for <literal>Counter</literal>:
      </para>
      <programlisting language="ocaml">
(* counter.mli: abstract interface *)

open Core.Std

type t

val empty : t
val to_list : t -&gt; (string * int) list
val touch : t -&gt; string -&gt; t
</programlisting>
      <para>
        Note that we needed to add <literal>empty</literal> and
        <literal>to_list</literal> to <literal>Counter</literal>, since
        otherwise, there would be no way to create a
        <literal>Counter.t</literal> or get data out of one.
      </para>
      <para>
        Here's a rewrite of <literal>counter.ml</literal> to match this
        signature.
      </para>
      <programlisting language="ocaml">
(* counter.ml: implementation matching abstract interface *)

open Core.Std

type t = (string * int) list

let empty = []

let to_list x = x

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)
</programlisting>
      <para>
        If we now try to compile <literal>freq.ml</literal>, we'll get
        the following error:
      </para>
      <programlisting>
File &quot;freq.ml&quot;, line 11, characters 20-22:
Error: This expression has type 'a list
       but an expression was expected of type Counter.t
</programlisting>
      <para>
        This is because <literal>freq.ml</literal> depends on the fact
        that frequency counts are represented as association lists, a
        fact that we've just hidden. We just need to fix the code to use
        <literal>Counter.empty</literal> instead of
        <literal>[]</literal> and <literal>Counter.to_list</literal> to
        get the association list out at the end for processing and
        printing.
      </para>
      <para>
        Now we can turn to optimizing the implementation of
        <literal>Counter</literal>. Here's an alternate and far more
        efficient implementation, based on the <literal>Map</literal>
        datastructure in Core.
      </para>
      <programlisting language="ocaml">
(* counter.ml: efficient version *)

open Core.Std

type t = string Int.Map.t

let empty = Map.empty

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t s (count + 1)

let to_list t = Map.to_alist t
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="more-on-modules-and-signatures">
    <title>More on modules and signatures</title>
    <sect2 id="concrete-types-in-signatures">
      <title>Concrete types in signatures</title>
      <para>
        In our frequency-count example, the module
        <literal>Counter</literal> had an abstract type
        <literal>Counter.t</literal> for representing a collection of
        frequency counts. Sometimes, you'll want to make a type in your
        interface <emphasis>concrete</emphasis>, by including the type
        definition in the interface.
      </para>
      <para>
        For example, imagine we wanted to add a function to
        <literal>Counter</literal> for returning the line with the
        median frequency count. If the number of lines is even, then
        there is no precise median, so the function would return the two
        lines before and after the median instead. We'll use a custom
        type to represent the fact that there are two possible return
        values. Here's a possible implementation.
      </para>
      <programlisting language="ocaml">
type median = | Median of string
              | Before_and_after of string * string

let median t =
  let sorted_strings = List.sort (Map.to_alist t)
      ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  in
  let len = List.length sorted_strings in
  if len = 0 then failwith &quot;median: empty frequency count&quot;;
  let nth n = fst (List.nth_exn sorted_strings n) in
  if len mod 2 = 1
  then Median (nth (len/2))
  else Before_and_after (nth (len/2), nth (len/2 + 1));;
</programlisting>
      <para>
        Now, to expose this usefully in the interface, we need to expose
        both the function and the type <literal>median</literal> with
        its definition. We'd do that by adding these lines to the
        <literal>counter.mli</literal>:
      </para>
      <programlisting language="ocaml">
type median = | Median of string
              | Before_and_after of string * string

val get_median : t -&gt; median
</programlisting>
      <para>
        The decision of whether a given type should be abstract or
        concrete is an important one. Abstract types give you more
        control over how values are created and accessed, and makes it
        easier to enforce invariants beyond the what's enforced by the
        type itself; concrete types let you expose more detail and
        structure to client code in a lightweight way. The right choice
        depends very much on the context.
      </para>
    </sect2>
    <sect2 id="the-include-directive">
      <title>The <literal>include</literal> directive</title>
      <para>
        OCaml provides a number of tools for manipulating modules. One
        particularly useful one is the <literal>include</literal>
        directive, which is used to include the contents of one module
        into another.
      </para>
      <para>
        One natural application of <literal>include</literal> is to
        create one module which is an extension of another one. For
        example, imagine you wanted to build an extended version of the
        <literal>List</literal> module, where you've added some
        functionality not present in the module as distributed in Core.
        We can do this easily using <literal>include</literal>:
      </para>
      <programlisting language="ocaml">
(* ext_list.ml: an extended list module *)

open Core.Std

(* The new function we're going to add *)
let rec intersperse list el =
  match list with
  | [] | [ _ ]   -&gt; list
  | x :: y :: tl -&gt; x :: el :: intersperse (y::tl) el

(* The remainder of the list module *)
include List
</programlisting>
      <para>
        Now, what about the interface of this new module? It turns out
        that include works on the signature language as well, so we can
        pull essentially the same trick to write an
        <literal>mli</literal> for this new module. The only trick is
        that we need to get our hands on the signature for the list
        module, which can be done using
        <literal>module type of</literal>.
      </para>
      <programlisting language="ocaml">
(* ext_list.mli: an extended list module *)

open Core.Std

(* Include the interface of the list module from Core *)
include (module type of List)

(* Signature of function we're adding *)
val intersperse : 'a list -&gt; 'a -&gt; 'a list
</programlisting>
      <para>
        And we can now use <literal>Ext_list</literal> as a replacement
        for <literal>List</literal>. If we want to use
        <literal>Ext_list</literal> in preference to
        <literal>List</literal> in our project, we can create a file of
        common definitions:
      </para>
      <programlisting language="ocaml">
(* common.ml *)

module List = Ext_list
</programlisting>
      <para>
        And if we then put <literal>open Common</literal> after
        <literal>open Core.Std</literal> at the top of each file in our
        project, then references to <literal>List</literal> will
        automatically go to <literal>Ext_list</literal> instead.
      </para>
    </sect2>
    <sect2 id="modules-within-a-file">
      <title>Modules within a file</title>
      <para>
        Up until now, we've only considered modules that correspond to
        files, like <literal>counter.ml</literal>. But modules (and
        module signatures) can be nested inside other modules. As a
        simple example, consider a program that needs to deal with some
        class of identifier like a username. Rather than just keeping
        usernames as strings, you might want to mint an abstract type,
        so that the type-system will help you to not confuse usernames
        with other string data that is floating around your program.
      </para>
      <para>
        Here's how you might create such a type, within a module:
      </para>
      <programlisting language="ocaml">
open Core.Std

module Username : sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end = struct
  type t = string
  let of_string x = x
  let to_string x = x
end
</programlisting>
      <para>
        The basic structure of a module declaration like this is:
      </para>
      <programlisting language="ocaml">
module &lt;name&gt; : &lt;signature&gt; = &lt;implementation&gt;
</programlisting>
      <para>
        We could have written this slightly differently, by giving the
        signature its own top-level <literal>module type</literal>
        declaration, making it possible to in a lightweight way create
        multiple distinct types with the same underlying implementation.
      </para>
      <programlisting language="ocaml">
module type ID = sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end

module String_id = struct
  type t = string
  let of_string x = x
  let to_string x = x
end

module Username : ID = String_id
module Hostname : ID = String_id

(* Now the following buggy code won't compile *)
type session_info = { user: Username.t;
                      host: Hostname.t;
                      when_started: Time.t;
                    }

let sessions_have_same_user s1 s2 =
  s1.user = s2.user
</programlisting>
      <para>
        We can also combine this with the use of the include directive
        to add some extra functionality to such a module. Thus, we could
        have rewritten the definition of <literal>Hostname</literal>
        above as follows to add a function
        <literal>Hostname.mine</literal> that returns the hostname of
        the present machine.
      </para>
      <programlisting language="ocaml">
module Hostname : sig
  include ID
  val mine : unit -&gt; t
end = struct
  include String_id
  let mine = Unix.gethostname
end  
</programlisting>
    </sect2>
    <sect2 id="opening-modules">
      <title>Opening modules</title>
      <para>
        One useful primitive in OCaml's module language is the
        <literal>open</literal> directive. We've seen that already in
        the <literal>open Core.Std</literal> that has been at the top of
        our source files.
      </para>
      <para>
        The basic purpose of <literal>open</literal> is to extend the
        namespaces that OCaml searches when trying to resolve an
        identifier. Roughly, if you open a module <literal>M</literal>,
        then every subsequent time you look for an identifier
        <literal>foo</literal>, the module system will look in
        <literal>M</literal> for a value named <literal>foo</literal>.
        This is true for all kinds of identifiers, including types, type
        constructors, values and modules.
      </para>
      <para>
        <literal>open</literal> is essential when dealing with something
        like a standard library, but it's generally good style to keep
        opening of modules to a minimum. Opening a module is basically a
        tradeoff between terseness and explicitness - the more modules
        you open, the harder it is to look at an identifier and figure
        out where it's defined.
      </para>
      <para>
        Here's some general advice on how to deal with opens.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Opening modules at the top-level of a module should be done
            quite sparingly, and generally only with modules that have
            been specifically designed to be opened, like
            <literal>Core.Std</literal> or
            <literal>Option.Monad_infix</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            One alternative to local opens that makes your code terser
            without giving up on explicitness is to locally rebind the
            name of a module. So, instead of writing:
          </para>
          <programlisting language="ocaml">
let print_median m =
   match m with
   | Counter.Median string -&gt; printf &quot;True median:\n   %s\n&quot;
   | Counter.Before_and_after of before * after -&gt;
     printf &quot;Before and after median:\n   %s\n   %s\n&quot; before after
</programlisting>
          <para>
            you could write
          </para>
          <programlisting language="ocaml">
let print_median m =
   let module C = Counter in
   match m with
   | C.Median string -&gt; printf &quot;True median:\n   %s\n&quot;
   | C.Before_and_after of before * after -&gt;
     printf &quot;Before and after median:\n   %s\n   %s\n&quot; before after
</programlisting>
          <para>
            Because the module name <literal>C</literal> only exists for
            a short scope, it's easy to read and remember what
            <literal>C</literal> stands for. Rebinding modules to very
            short names at the top-level of your module is usually a
            mistake.
          </para>
        </listitem>
        <listitem>
          <para>
            If you do need to do an open, it's better to do a
            <emphasis>local open</emphasis>. There are two syntaxes for
            local opens. For example, you can write:
          </para>
          <programlisting language="ocaml">
let average x y =
  let open Int64 in
  x + y / of_int 2
</programlisting>
          <para>
            In the above, <literal>of_int</literal> and the infix
            operators are the ones from <literal>Int64</literal> module.
          </para>
          <para>
            There's another even more lightweight syntax for local
            opens, which is particularly useful for small expressions:
          </para>
          <programlisting language="ocaml">
let average x y =
  Int64.(x + y / of_int 2)
</programlisting>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2 id="common-errors-with-modules">
      <title>Common errors with modules</title>
      <para>
        When OCaml compiles a program with an <literal>ml</literal> and
        an <literal>mli</literal>, it will complain if it detects a
        mismatch between the two. Here are some of the common errors
        you'll run into.
      </para>
      <sect3 id="type-mismatches">
        <title>Type mismatches</title>
        <para>
          The simplest kind of error is where the type specified in the
          signature does not match up with the type in the
          implementation of the module. As an example, if we replace the
          <literal>val</literal> declaration in
          <literal>counter.mli</literal> by swapping the types of the
          first two arguments:
        </para>
        <programlisting language="ocaml">
val touch : string -&gt; t -&gt; t
</programlisting>
        <para>
          and then try to compile <literal>Counter</literal> (by writing
          <literal>ocamlbuild -use-ocamlfind counter.cmo</literal>),
          we'll get the following error:
        </para>
        <programlisting>
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       Values do not match:
         val touch :
           ('a, int) Core.Std.Map.t -&gt; 'a -&gt; ('a, int) Core.Std.Map.t
       is not included in
         val touch : string -&gt; t -&gt; t
</programlisting>
        <para>
          This error message is a bit intimidating at first, and it
          takes a bit of thought to see where the first type, which is
          the type of [touch] in the implementation, doesn't match the
          second one, which is the type of [touch] in the interface. You
          need to recognize that [t] is in fact a [Core.Std.Map.t], and
          the problem is that in the first type, the first argument is a
          map while the second is the key to that map, but the order is
          swapped in the second type.
        </para>
      </sect3>
      <sect3 id="missing-definitions">
        <title>Missing definitions</title>
        <para>
          We might decide that we want a new function in
          <literal>Counter</literal> for pulling out the frequency count
          of a given string. We can update the <literal>mli</literal> by
          adding the following line.
        </para>
        <programlisting language="ocaml">
val count : t -&gt; string -&gt; int
</programlisting>
        <para>
          Now, if we try to compile without actually adding the
          implementation, we'll get this error:
        </para>
        <programlisting>
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       The field `count' is required but not provided
</programlisting>
        <para>
          A missing type definition will lead to a similar error.
        </para>
      </sect3>
      <sect3 id="type-definition-mismatches">
        <title>Type definition mismatches</title>
        <para>
          Type definitions that show up in an <literal>mli</literal>
          need to match up with corresponding definitions in the
          <literal>ml</literal>. Consider again the example of the type
          <literal>median</literal>. The order of the declaration of
          variants matters to the OCaml compiler so, if the definition
          of <literal>median</literal> in the implementation lists those
          options in a different order:
        </para>
        <programlisting language="ocaml">
type median = | Before_and_after of line * line
              | Median of line
</programlisting>
        <para>
          that will lead to a compilation error:
        </para>
        <programlisting>
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       Type declarations do not match:
         type median = Before_and_after of string * string | Median of string
       is not included in
         type median = Median of string | Before_and_after of string * string
       Their first fields have different names, Before_and_after and Median.
</programlisting>
        <para>
          Order is similarly important in other parts of the signature,
          including the order in which record fields are declared and
          the order of arguments (including labeled and optional
          arguments) to a function.
        </para>
      </sect3>
      <sect3 id="cyclic-dependencies">
        <title>Cyclic dependencies</title>
        <para>
          In most cases, OCaml doesn't allow circular dependencies,
          <emphasis>i.e.</emphasis>, a collection of definitions that
          all refer to each other. If you want to create such
          definitions, you typically have to mark them specially. For
          example, when defining a set of mutually recursive values, you
          need to define them using <literal>let rec</literal> rather
          than ordinary <literal>let</literal>.
        </para>
        <para>
          The same is true at the module level. By default, circular
          dependencies between modules is not allowed, and indeed,
          circular dependencies among files is never allowed.
        </para>
        <para>
          The simplest case of this is that a module can not directly
          refer to itself (although definitions within a module can
          refer to each other in the ordinary way). So, if we tried to
          add a reference to <literal>Counter</literal> from within
          <literal>counter.ml</literal>:
        </para>
        <programlisting language="ocaml">
let singleton l = Counter.touch Counter.empty
</programlisting>
        <para>
          then when we try to build, we'll get this error:
        </para>
        <programlisting>
File &quot;counter.ml&quot;, line 17, characters 18-31:
Error: Unbound module Counter
Command exited with code 2.
</programlisting>
        <para>
          The problem manifests in a different way if we create circular
          references between files. We could create such a situation by
          adding a reference to Freq from <literal>counter.ml</literal>,
          <emphasis>e.g.</emphasis>, by adding the following line:
        </para>
        <programlisting language="ocaml">
let build_counts = Freq.build_counts
</programlisting>
        <para>
          In this case, <literal>ocamlbuild</literal> will notice the
          error and complain:
        </para>
        <programlisting>
Circular dependencies: &quot;freq.cmo&quot; already seen in
  [ &quot;counter.cmo&quot;; &quot;freq.cmo&quot; ]
</programlisting>
      </sect3>
    </sect2>
  </sect1>
</chapter>
<chapter id="functors-and-first-class-modules">
  <title>Functors and First-Class Modules</title>
  <para>
    Up until now, we've seen modules play a limited role, serving as a
    mechanism for organizing code into units with specified interfaces.
    But OCaml's module system plays a bigger role in the language,
    acting as a powerful toolset for structuring large-scale systems.
    This chapter will introduce you to functors and first class modules,
    which greatly increase the power of the module system.
  </para>
  <sect1 id="functors">
    <title>Functors</title>
    <para>
      Functors are, roughly speaking, functions from modules to modules,
      and they can be used to solve a variety of code-structuring
      problems, including:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis>Dependency injection</emphasis>, or making the
          implementations of some components of a system swappable. This
          is particularly useful when you want to mock up parts of your
          system for testing and simulation purposes.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Auto-extension of modules</emphasis>. Sometimes,
          there is some functionality that you want to build in a
          standard way for different types, in each case based on a some
          piece of type-specific logic. For example, you might want to
          add a slew of comparison operators derived from a base
          comparison function. To do this by hand would require a lot of
          repetitive code for each type, but functors let you write this
          logic just once and apply it to many different types.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Instantiating modules with state</emphasis>. Modules
          can contain mutable state, and that means that you'll
          occasionally want to have multiple instantiations of a
          particular module, each with its own separate and independent
          mutable state. Functors let you automate the construction of
          such modules.
        </para>
      </listitem>
    </itemizedlist>
    <sect2 id="a-trivial-example">
      <title>A trivial example</title>
      <para>
        We'll start by considering the simplest possible example: a
        functor for incrementing an integer.
      </para>
      <para>
        More precisely, we'll create a functor that takes a module
        containing a single integer variable <literal>x</literal>, and
        returns a new module with <literal>x</literal> incremented by
        one. The first step is to define a module type which will
        describe the input and output of the functor.
      </para>
      <programlisting>
# module type X_int = sig val x : int end;;
module type X_int = sig val x : int end
</programlisting>
      <para>
        Now, we can use that module type to write the increment functor.
      </para>
      <programlisting>
# module Increment (M:X_int) : X_int = struct
    let x = M.x + 1
  end;;
module Increment : functor (M : X_int) -&gt; X_int
</programlisting>
      <para>
        One thing that immediately jumps out about functors is that
        they're considerably more heavyweight syntactically than
        ordinary functions. For one thing, functors require explicit
        type annotations, which ordinary functions do not. Here, we've
        specified the module type for both the input and output of the
        functor. Technically, only the type on the input is mandatory,
        although in practice, one often specifies both.
      </para>
      <para>
        The following shows what happens when we omit the module type
        for the output of the functor.
      </para>
      <programlisting>
# module Increment (M:X_int) = struct
    let x = M.x + 1
  end;;
module Increment : functor (M : X_int) -&gt; sig val x : int end
</programlisting>
      <para>
        We can see that the inferred module type of the output is now
        written out explicitly, rather than being a reference to the
        named signature <literal>X_int</literal>.
      </para>
      <para>
        Here's what <literal>Increment</literal> looks like in action.
      </para>
      <programlisting>
# module Three = struct let x = 3 end;;
  module Three : sig val x : int end
# module Four = Increment(Three);;
module Four : sig val x : int end
# Four.x - Three.x;;
- : int = 1
</programlisting>
      <para>
        In this case, we applied <literal>Increment</literal> to a
        module whose signature is exactly equal to
        <literal>X_int</literal>. But we can apply
        <literal>Increment</literal> to any module that satisfies
        <literal>X_int</literal>. So, for example,
        <literal>Increment</literal> can take as its input a module that
        has more fields than are contemplated in
        <literal>X_int</literal>, as shown below.
      </para>
      <programlisting>
# module Three_and_more = struct
    let x = 3
    let y = &quot;three&quot;
  end;;
module Three_and_more : sig val x : int val x_string : string end
# module Four = Increment(Three_and_more);;
module Four : sig val x : int end
</programlisting>
    </sect2>
    <sect2 id="a-bigger-example-computing-with-intervals">
      <title>A bigger example: computing with intervals</title>
      <para>
        We'll now look at a more complex example, which will give us an
        opportunity to learn more about how functors work. In
        particular, we'll walk through the design of a library for
        computing with intervals. This library will be functorized over
        the type of the endpoints of the intervals and the ordering of
        those endpoints.
      </para>
      <para>
        First we'll define a module type that captures the information
        we'll need about the endpoint type. This interface, which we'll
        call <literal>Comparable</literal>, contains just two things: a
        comparison function, and the type of the values to be compared.
      </para>
      <programlisting>
# module type Comparable = sig
    type t
    val compare : t -&gt; t -&gt; int
  end ;;
</programlisting>
      <para>
        The comparison function follows the standard OCaml idiom for
        such functions, returning <literal>0</literal> if the two
        elements are equal, a positive number if the first element is
        larger than the second, and a negative number if the first
        element is smaller than the second. Thus, we could rewrite the
        standard comparison functions on top of
        <literal>compare</literal> as shown below.
      </para>
      <programlisting language="ocaml">
compare x y &lt; 0     (* x &lt; y *)
compare x y = 0     (* x = y *)
compare x y &gt; 0     (* x &gt; y *)
</programlisting>
      <para>
        Now that we have the <literal>Comparable</literal> interface, we
        can write the implementation of our interval module. In this
        module, we'll represent an interval with a variant type, which
        is either <literal>Empty</literal> or
        <literal>Interval (x,y)</literal>, where <literal>x</literal>
        and <literal>y</literal> are the bounds of the interval.
      </para>
      <programlisting>
# module Make_interval(Endpoint : Comparable) = struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    let create low high =
      if Endpoint.compare low high &gt; 0 then Empty
      else Interval (low,high)

    let is_empty = function
      | Empty -&gt; true
      | Interval _ -&gt; false

    let contains t x =
      match t with
      | Empty -&gt; false
      | Interval (l,h) -&gt;
        Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

    let intersect t1 t2 =
      let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
      let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
      match t1,t2 with
      | Empty, _ | _, Empty -&gt; Empty
      | Interval (l1,h1), Interval (l2,h2) -&gt;
        create (max l1 l2) (min h1 h2)

  end ;;
module Make_interval :
  functor (Endpoint : Comparable) -&gt;
    sig
      type t = Interval of Endpoint.t * Endpoint.t | Empty
      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
      val contains : t -&gt; Endpoint.t -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end
</programlisting>
      <para>
        We can instantiate the functor by applying it to a module with
        the right signature. In the following, we provide the functor
        input as an anonymous module.
      </para>
      <programlisting language="ocaml">
# module Int_interval =
    Make_interval(struct
      type t = int
      let compare = Int.compare
    end);;
module Int_interval :
  sig
    type t = Interval of int * int | Empty
    val create : int -&gt; int -&gt; t
    val contains : t -&gt; int -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
      <para>
        If we choose our interfaces to be aligned with the standards of
        our libraries, then we often don't have to construct a custom
        module for a given functor. In this case, for example, we can
        directly use the <literal>Int</literal> or
        <literal>String</literal> modules provided by Core.
      </para>
      <programlisting>
# module Int_interval = Make_interval(Int) ;;
# module String_interval = Make_interval(String) ;;
</programlisting>
      <para>
        This works because many modules in Core, including
        <literal>Int</literal> and <literal>String</literal>, satisfy an
        extended version of the <literal>Comparable</literal> signature
        described above. As a general matter, having standardized
        signatures is a good practice, both because a more uniform
        codebase is easier to navigate, and because it makes functors
        easier to use.
      </para>
      <para>
        Now we can use the newly defined <literal>Int_interval</literal>
        module like any ordinary module.
      </para>
      <programlisting>
# let i1 = Int_interval.create 3 8;;
val i1 : Int_interval.t = Int_interval.Interval (3, 8)
# let i2 = Int_interval.create 4 10;;
val i2 : Int_interval.t = Int_interval.Interval (4, 10)
# Int_interval.intersect i1 i2;;
- : Int_interval.t = Int_interval.Interval (4, 8)
</programlisting>
      <para>
        This design gives us the freedom to use any comparison function
        we want for comparing the endpoints. We could, for example,
        create a type of int interval with the order of the comparison
        reversed, as follows:
      </para>
      <programlisting>
# module Rev_int_interval =
    Make_interval(struct
      type t = int
      let compare x y = Int.compare y x
    end);;
</programlisting>
      <para>
        The behavior of <literal>Rev_int_interval</literal> is of course
        different from <literal>Int_interval</literal>, as we can see
        below.
      </para>
      <programlisting>
# let interval = Int_interval.create 4 3;;
val interval : Int_interval.t = Int_interval.Empty
# let rev_interval = Rev_int_interval.create 4 3;;
val rev_interval : Rev_int_interval.t = Rev_int_interval.Interval (4, 3)
</programlisting>
      <para>
        Importantly, <literal>Rev_int_interval.t</literal> is a
        different type than <literal>Int_interval.t</literal>, even
        though its physical representation is the same. Indeed, the type
        system will prevent us from confusing them.
      </para>
      <programlisting>
# Int_interval.contains rev_interval 3;;
Characters 22-34:
  Int_interval.contains rev_interval 3;;
                        ^^^^^^^^^^^^
Error: This expression has type Rev_int_interval.t
       but an expression was expected of type
         Int_interval.t = Make_interval(Int).t
</programlisting>
      <para>
        This is important, because confusing the two kinds of intervals
        would be a semantic error, and it's an easy one to make. The
        ability of functors to mint new types is a useful trick that
        comes up a lot.
      </para>
      <sect3 id="making-the-functor-abstract">
        <title>Making the functor abstract</title>
        <para>
          There's a problem with <literal>Make_interval</literal>. The
          code we wrote depends on the invariant that the upper bound of
          an interval is greater than its lower bound, but that
          invariant can be violated. The invariant is enforced by the
          create function, but because <literal>Interval.t</literal> is
          not abstract, we can bypass the <literal>create</literal>
          function.
        </para>
        <programlisting>
# Int_interval.create 4 3;; (* going through create *)
- : Int_interval.t = Int_interval.Empty
# Int_interval.Interval (4,3);; (* bypassing create *)
- : Int_interval.t = Int_interval.Interval (4, 3)
</programlisting>
        <para>
          To make <literal>Int_interval.t</literal> abstract, we need to
          apply an interface to the output of the
          <literal>Make_interval</literal>. Here's an explicit interface
          that we can use for that purpose.
        </para>
        <programlisting>
# module type Interval_intf = sig
   type t
   type endpoint
   val create : endpoint -&gt; endpoint -&gt; t
   val is_empty : t -&gt; bool
   val contains : t -&gt; endpoint -&gt; bool
   val intersect : t -&gt; t -&gt; t
  end;;
</programlisting>
        <para>
          This interface includes the type <literal>endpoint</literal>
          to represent the type of the endpoints of the interval. Given
          this interface, we can redo our definition of
          <literal>Make_interval</literal>, as follows. Notice that we
          added the type <literal>endpoint</literal> to the
          implementation of the module to make the implementation match
          <literal>Interval_intf</literal>.
        </para>
        <programlisting>
# module Make_interval(Endpoint : Comparable) : Interval_intf = struct

    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ....

  end ;;
module Make_interval : functor (Endpoint : Comparable) -&gt; Interval_intf
</programlisting>
      </sect3>
      <sect3 id="sharing-constraints">
        <title>Sharing constraints</title>
        <para>
          The resulting module is abstract, but unfortunately, it's too
          abstract. In particular, we haven't exposed the type
          <literal>endpoint</literal>, which means that we can't even
          construct an interval anymore.
        </para>
        <programlisting>
# module Int_interval = Make_interval(Int);;
module Int_interval : Interval_intf
# Int_interval.create 3 4;;
Characters 20-21:
  Int_interval.create 3 4;;
                      ^
Error: This expression has type int but an expression was expected of type
         Int_interval.endpoint
</programlisting>
        <para>
          To fix this, we need to expose the fact that
          <literal>endpoint</literal> is equal to
          <literal>Int.t</literal> (or more generally,
          <literal>Endpoint.t</literal>, where
          <literal>Endpoint</literal> is the argument to the functor).
          One way of doing this is through a <emphasis>sharing
          constraint</emphasis>, which allows you to tell the compiler
          to expose the fact that a given type is equal to some other
          type. The syntax for a sharing constraint on a module type is
          as follows.
        </para>
        <programlisting language="ocaml">
S with type t = s
</programlisting>
        <para>
          where <literal>S</literal> is a module type,
          <literal>t</literal> is a type inside of <literal>S</literal>,
          and <literal>s</literal> is a different type. The result of
          this expression is a new signature that's been modified so
          that it exposes the fact that <literal>t</literal> is equal to
          <literal>s</literal>. We can use a sharing constraint to
          create a specialized version of
          <literal>Interval_intf</literal> for integer intervals.
        </para>
        <programlisting>
# module type Int_interval_intf = Interval_intf with type endpoint = int;;
module type Int_interval_intf =
  sig
    type t
    type endpoint = int
    val create : endpoint -&gt; endpoint -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; endpoint -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
        <para>
          And we can also use it in the context of a functor, where the
          right-hand side of the sharing constraint is an element of the
          functor argument. Thus, we expose an equality between a type
          in the output of the functor (in this case, the type
          <literal>endpoint</literal>) and a type in its input
          (<literal>Endpoint.t</literal>).
        </para>
        <programlisting>
# module Make_interval(Endpoint : Comparable)
      : Interval_intf with type endpoint = Endpoint.t = struct

    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;
module Make_interval :
  functor (Endpoint : Comparable) -&gt;
    sig
      type t
      type endpoint = Endpoint.t
      val create : endpoint -&gt; endpoint -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; endpoint -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end
</programlisting>
        <para>
          So now, the interface is as it was, except that
          <literal>endpoint</literal> is now known to be equal to
          <literal>Endpoint.t</literal>. As a result of that type
          equality, we can now do things like construct intervals again.
        </para>
        <programlisting>
# let i = Int_interval.create 3 4;;
val i : Int_interval.t = &lt;abstr&gt;
# Int_interval.contains i 5;;
- : bool = false
</programlisting>
      </sect3>
      <sect3 id="destructive-substitution">
        <title>Destructive substitution</title>
        <para>
          Sharing constraints basically do the job, but the approach we
          used has some downsides. In particular, we've now been stuck
          with the useless type declaration of
          <literal>endpoint</literal> that clutters up both the
          interface and the implementation. A better solution would be
          to modify the <literal>Interval_intf</literal> signature by
          replacing <literal>endpoint</literal> with
          <literal>Endpoint.t</literal> everywhere it shows up, making
          <literal>endpoint</literal> unnecessary. We can do just this
          using what's called <emphasis>destructive
          substitution</emphasis>. Here's the basic syntax.
        </para>
        <programlisting language="ocaml">
S with type t := s
</programlisting>
        <para>
          where <literal>S</literal> is a signature,
          <literal>t</literal> is a type inside of <literal>S</literal>,
          and <literal>s</literal> is a different type. The following
          shows how we could use this with
          <literal>Make_interval</literal>.
        </para>
        <para>
          Here's an example of what we get if we use destructive
          substitution to specialize the
          <literal>Interval_intf</literal> interface to integer
          intervals.
        </para>
        <programlisting>
# module type Int_interval_intf = Interval_intf with type endpoint := int;;
module type Int_interval_intf =
  sig
    type t
    val create : int -&gt; int -&gt; t
    val is_empty : t -&gt; bool
    val contains : t -&gt; int -&gt; bool
    val intersect : t -&gt; t -&gt; t
  end
</programlisting>
        <para>
          There's now no mention of n <literal>endpoint</literal>, all
          occurrences of that type having been replaced by
          <literal>int</literal>. As with sharing constraints, we can
          also use this in the context of a functor.
        </para>
        <programlisting>
# module Make_interval(Endpoint : Comparable)
    : Interval_intf with type endpoint := Endpoint.t =
  struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ....

  end ;;
module Make_interval :
  functor (Endpoint : Comparable) -&gt;
    sig
      type t
      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; Endpoint.t -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end
</programlisting>
        <para>
          The interface is precisely what we want, and we didn't need to
          define the <literal>endpoint</literal> type alias in the body
          of the module. If we instantiate this module, we'll see that
          it works properly: we can construct new intervals, but
          <literal>t</literal> is abstract, and so we can't directly
          access the constructors and violate the invariants of the data
          structure.
        </para>
        <programlisting>
# module Int_interval = Make_interval(Int);;
# Int_interval.create 3 4;;
- : Int_interval.t = &lt;abstr&gt;
# Int_interval.Interval (4,3);;
Characters 0-27:
  Int_interval.Interval (4,3);;
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: Unbound constructor Int_interval.Interval
</programlisting>
      </sect3>
      <sect3 id="using-multiple-interfaces">
        <title>Using multiple interfaces</title>
        <para>
          Another feature that we might want for our interval module is
          the ability to serialize the type, in particular, by
          converting to s-expressions. If we simply invoke the
          <literal>sexplib</literal> macros by adding
          <literal>with sexp</literal> to the definition of
          <literal>t</literal>, though, we'll get an error:
        </para>
        <programlisting>
# module Make_interval(Endpoint : Comparable)
    : Interval_intf with type endpoint := Endpoint.t = struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty
    with sexp

    ....

  end ;;
Characters 120-123:
        type t = | Interval of Endpoint.t * Endpoint.t
                               ^^^^^^^^^^
Error: Unbound value Endpoint.t_of_sexp
</programlisting>
        <para>
          The problem is that <literal>with sexp</literal> adds code for
          defining the s-expression converters, and that code assumes
          that <literal>Endpoint</literal> has the appropriate
          sexp-conversion functions for <literal>Endpoint.t</literal>.
          But all we know about <literal>Endpoint</literal> is that it
          satisfies the <literal>Comparable</literal> interface, which
          doesn't say anything about s-expressions.
        </para>
        <para>
          Happily, Core comes with a built in interface for just this
          purpose called <literal>Sexpable</literal>, which is defined
          as follows:
        </para>
        <programlisting language="ocaml">
module type Sexpable = sig
  type t = int
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
end
</programlisting>
        <para>
          We can modify <literal>Make_interval</literal> to use the
          <literal>Sexpable</literal> interface, for both its input and
          its output. Note the use of destructive substitution to
          combine multiple signatures together. This is important
          because it stops the <literal>type t</literal>'s from the
          different signatures from interfering with each other.
        </para>
        <para>
          Also note that we have been careful to override the
          sexp-converter here to ensure that the datastructures
          invariants are still maintained when reading in from an
          s-expression.
        </para>
        <programlisting>
# module type Interval_intf_with_sexp = sig
   type t
   include Interval_intf with type t := t
   include Sexpable      with type t := t
  end;;
# module Make_interval(Endpoint : sig
    type t
    include Comparable with type t := t
    include Sexpable   with type t := t
  end) : Interval_intf_with_sexp with type endpoint := Endpoint.t =
  struct

      type t = | Interval of Endpoint.t * Endpoint.t
               | Empty
      with sexp

      let create low high =
         ...

      (* put a wrapper round the auto-generated sexp_of_t to enforce
         the invariants of the datastructure *)
      let t_of_sexp sexp =
        match t_of_sexp sexp with
        | Empty -&gt; Empty
        | Interval (x,y) -&gt; create x y

      ....

     end ;;
module Make_interval :
  functor
    (Endpoint : sig
           type t
           val compare : t -&gt; t -&gt; int
           val sexp_of_t : t -&gt; Sexplib.Sexp.t
           val t_of_sexp : Sexplib.Sexp.t -&gt; t
         end) -&gt;
    sig
      type t
      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; Endpoint.t -&gt; bool
      val intersect : t -&gt; t -&gt; t
      val sexp_of_t : t -&gt; Sexplib.Sexp.t
      val t_of_sexp : Sexplib.Sexp.t -&gt; t
    end
</programlisting>
        <para>
          And now, we can use that sexp-converter in the ordinary way:
        </para>
        <programlisting>
# module Int = Make_interval(Int) ;;
# Int_interval.sexp_of_t (Int_interval.create 3 4);;
- : Sexplib.Sexp.t = (Interval 3 4)
# Int_interval.sexp_of_t (Int_interval.create 4 3);;
- : Sexplib.Sexp.t = Empty
</programlisting>
      </sect3>
    </sect2>
    <sect2 id="extending-modules">
      <title>Extending modules</title>
      <para>
        One common use of functors is to generate type-specific
        functionality for a given module in a standardized way. We'll
        think about this in the context of an example of creating a
        simple data structure.
      </para>
      <para>
        The following is a minimal interface for a functional queue. A
        functional queue is simply a functional version of a FIFO
        (first-in, first-out) queue. Being functional, operations on the
        queue return new queues, rather than modifying the queues that
        were passed in.
      </para>
      <programlisting language="ocaml">
(* file: fqueue.mli *)

type 'a t
val empty : 'a t
val enqueue : 'a t -&gt; 'a -&gt; 'a t
(** [dequeue q] returns None if the [q] is empty *)
val dequeue : 'a t -&gt; ('a * 'a t) option
val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc
</programlisting>
      <para>
        A standard trick for implementing functional queues efficiently
        is to maintain both an input and an output list, where the input
        list is ordered to make <literal>enqueue</literal> fast, and the
        output list is ordered to make <literal>dequeue</literal> fast.
        When the output list is empty, the input list is reversed and
        becomes the new output list. Thinking through why this is
        efficient is a worthwhile exercise, but we won't dwell on that
        here.
      </para>
      <para>
        Here's a concrete implementation.
      </para>
      <programlisting language="ocaml">
(* file: fqueue.ml *)

type 'a t = 'a list * 'a list

let empty = ([],[])

let enqueue (l1,l2) x = (x :: l1,l2)

let dequeue (in_list,out_list) =
  match out_list with
  | hd :: tl -&gt; Some (hd, (in_list,tl))
  | [] -&gt;
    match List.rev in_list with
    | [] -&gt; None
    | hd::tl -&gt; Some (hd, ([], tl))

let fold (in_list,out_list) ~init ~f =
  List.fold ~init:(List.fold ~init ~f out_list) ~f
     (List.rev in_list)
</programlisting>
      <para>
        The code above works fine, but the interface it implements is
        unfortunately quite skeletal; there are lots of useful helper
        functions that one might want that aren't there. And
        implementing those helper functions can be something of a dull
        affair, since you need to implement essentially the same helper
        functions for multiple different data structures in essentially
        the same way.
      </para>
      <para>
        As it happens, many of these helper functions can be derived
        mechanically from just the fold function we already implemented.
        Rather than write all of these helper functions by hand for
        every new container type, we can instead use a functor to write
        the code for these once and for all, basing them off of the
        <literal>fold</literal> function.
      </para>
      <para>
        Let's create a new module, <literal>Foldable</literal>, that
        contains support for this. The first thing we'll need is a
        signature to describe a container that supports fold.
      </para>
      <programlisting language="ocaml">
(* file: foldable.ml *)

module type S = sig
  type 'a t
  val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc
end
</programlisting>
      <para>
        We'll also need a signature for the helper functions we're going
        to generate. This just represents some of the helper functions
        we can derive from fold, but it's enough to give you a flavor of
        what you can do.
      </para>
      <programlisting language="ocaml">
module type Extension = sig
  type 'a t
  val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
  val length  : 'a t -&gt; int
  val count   : 'a t -&gt; f:('a -&gt; bool) -&gt; int
  val for_all : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
  val exists  : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
end
</programlisting>
      <para>
        Finally, we can define the functor itself.
      </para>
      <programlisting language="ocaml">
module Extend(Container : S)
  : Extension with type 'a t := 'a C.t =
struct
  open Container

  let iter   t ~f = fold t ~init:() ~f:(fun () a -&gt; f a)
  let length t    = fold t ~init:0  ~f:(fun acc _ -&gt; acc + 1)
  let count  t ~f = fold t ~init:0  ~f:(fun count x -&gt; count + if f x then 1 else 0)

  exception Short_circuit

  let for_all c ~f =
    try iter c ~f:(fun x -&gt; if not (f x) then raise Short_circuit); true
    with Short_circuit -&gt; false

  let exists c ~f =
    try iter c ~f:(fun x -&gt; if f x then raise Short_circuit); false
    with Short_circuit -&gt; true
end
</programlisting>
      <para>
        Now we can apply this to <literal>Fqueue</literal>. First, we
        can extend the interface:
      </para>
      <programlisting language="ocaml">
(* file: fqueue.mli, 2nd version *)

type 'a t
val empty : 'a t
val enqueue : 'a t -&gt; 'a -&gt; 'a t
val dequeue : 'a t -&gt; ('a * 'a t) option
val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc

include Foldable.Extension with type 'a t := 'a t
</programlisting>
      <para>
        In order to apply the functor, we'll put the definition of
        <literal>Fqueue</literal> in a sub-module called
        <literal>T</literal>, and then call
        <literal>Foldable.Extend</literal> on <literal>T</literal>.
        Here's how that code would look.
      </para>
      <programlisting language="ocaml">
module T = struct
  type 'a t = 'a list * 'a list

  ....

  let fold (in_list,out_list) ~init ~f =
    List.fold ~init:(List.fold ~init ~f out_list)
      ~f (List.rev in_list)

end
include T
include Foldable.Extend(T)
</programlisting>
      <para>
        This pattern comes up quite a bit in Core. It's used to
        implement various standard bits of functionality, including:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Comparison-based datastructures like maps and sets, based on
            the <literal>Comparable</literal> interface.
          </para>
        </listitem>
        <listitem>
          <para>
            Hash-based datastructures like hash sets and hash heaps.
          </para>
        </listitem>
        <listitem>
          <para>
            Support for so-called monadic libraries, like the ones
            discussed in {{{ERROR HANDLING}}} and {{{CONCURRENCY}}}.
            Here, the functor is used to provide a collection of
            standard helper functions based on the core
            <literal>bind</literal> and <literal>return</literal>
            operators.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
  <sect1 id="first-class-modules">
    <title>First class modules</title>
    <para>
      _(jyh: I'm going to start some new text on FCM. We might want
      another chapter, but let's see how it goes. I've kept Ron's
      original text below.)
    </para>
    <para>
      OCaml provides several mechanisms for organizing your programs,
      including modules and functors, files and compilation units, and
      classes and objects. Files and compilation units
      (<literal>.ml</literal> and <literal>.mli</literal> files) are
      really just a simplified module system. Classes and objects are a
      different form of organization altogether (as we'll see in
      [[[Chapter 13]]]). Yet, in each of these cases, there is a clear
      separation between types and values -- values cannot contain
      types, and types cannot contain values. And since modules can
      contain types, modules can't be values.
    </para>
    <para>
      <emphasis>(yminsky: Instead of saying that ml and mli files are a
      simplified module system, maybe say that they &quot;provide a
      simple way of creating modules and interfaces&quot;, or some such?
      It's not like there's a simplified module system floating
      around)</emphasis>
    </para>
    <para>
      <emphasis>(yminsky: consider dropping &quot;Yet&quot; in the
      above.)</emphasis>
    </para>
    <para>
      Next, we'll relax this restriction with <emphasis>first-class
      modules</emphasis>. &quot;First-class&quot; means that modules can
      be passed around as ordinary values that can be created from and
      converted back to regular modules. This is a relatively recent
      addition to the OCaml language, and while it might seem trivial to
      say, it has profound consequences on the language. First-class
      modules are strictly more expressive than any other organization
      mechanism, including classes and objects. Once you use first-class
      modules, you'll never want to go back.
    </para>
    <para>
      <emphasis>(yminsky: I wouldn't say they're strictly more
      expressive. For example, they don't give you a way of expressing
      sub typing relationships effectively, which objects
      do.)</emphasis>
    </para>
    <para>
      This is not say that first-class modules should be used
      indiscriminately. When you pass modules as values, the reason is
      to support dynamic behavior, and this can have a negative impact
      on understandability. As we proceed, we'll compare first-class
      modules to other techniques, and suggest alternatives when it
      seems appropriate.
    </para>
    <para>
      _(jyh: Original text You can think of OCaml as being broken up
      into two sub-language: a core language that is concerned with
      values and types, and a module language that is concerned with
      modules and module signatures. These sub-languages are stratified,
      in that modules can contain types and values, but ordinary values
      can't contain modules or module types. That means you can't do
      things like define a variable whose definition is a module, or a
      function that takes a module as an argument.
    </para>
    <para>
      OCaml provides a way around this stratification in the form of
      <emphasis>first-class modules</emphasis>. First-class modules are
      ordinary values that can be created from and converted back to
      regular modules. As we'll see, letting modules into the core
      language makes it possible to use more flexible and dynamic
      module-oriented designs.)_
    </para>
    <sect2 id="another-trivial-example">
      <title>Another trivial example</title>
      <para>
        Much as we did with functors, we'll start out with an utterly
        trivial example, to allow us to show the basic mechanics of
        first class modules with a minimum of fuss.
      </para>
      <para>
        A first-class module is created by packaging up a module with a
        signature that it satisfies. The following defines a simple
        signature and a module that matches it.
      </para>
      <programlisting>
# module type X_int = sig val x : int end;;
module type X_int = sig val x : int end
# module Three : X_int = struct let x = 3 end;;
module Three : X_int
# Three.x;;
- : int = 3
</programlisting>
      <para>
        We can then create a first-class module using the
        <literal>module</literal> keyword.
      </para>
      <programlisting>
# let three = (module Three : X_int);;
val three : (module X_int) = &lt;module&gt;
</programlisting>
      <para>
        Note that the type of the first-class module,
        <literal>(module X_int)</literal>, is based on the name of the
        signature that we used in constructing it.
      </para>
      <para>
        To get at the contents of <literal>three</literal>, we need to
        unpack it into a module again, which we can do using the
        <literal>val</literal> keyword.
      </para>
      <programlisting>
# module New_three = (val three : X_int) ;;
module New_three : X_int
# New_three.x;;
- : int = 3
</programlisting>
      <para>
        Using these conversions as building blocks, we can create tools
        for working with first-class modules in a natural way. The
        following shows the definition of two function,
        <literal>to_int</literal>, which converts a
        <literal>(module X_int)</literal> into an
        <literal>int</literal>. And <literal>plus</literal>, which adds
        two <literal>(module X_int)</literal>s.
      </para>
      <programlisting>
# let to_int m =
    let module M = (val m : X_int) in
    M.x
  ;;
val to_int : (module X_int) -&gt; int = &lt;fun&gt;
# let plus m1 m2 =
    (module struct
       let x = to_int m1 + to_int m2
     end : X_int)
  ;;
val plus : (module X_int) -&gt; (module X_int) -&gt; (module X_int) = &lt;fun&gt;
</programlisting>
      <para>
        With these functions in hand, we can start operating on our
        <literal>(module X_int)</literal>'s in a more natural style,
        taking full advantage of the concision and simplicity of the
        core language.
      </para>
      <programlisting>
# let six = plus three three;;
val six : (module X_int) = &lt;module&gt;
# to_int (List.fold ~init:six ~f:plus [three;three]);;
- : int = 12
</programlisting>
      <para>
        Of course, all we've really done with this example is come up
        with a more cumbersome way of working with integers. Let's see
        what happens when with work with more complex abstract types.
      </para>
    </sect2>
    <sect2 id="standard-vs.-first-class-modules">
      <title>Standard vs. first-class modules</title>
      <para>
        <emphasis>(yminsky: I'm not in solve with the example. It feels
        in some sense too artificial, and that aside, when you get to
        the end of the example, you haven't really gotten any juice of
        first-class modules)</emphasis>
      </para>
      <para>
        <emphasis>(yminsky: using &quot;standard&quot; in quotes seems a
        little awkward. Maybe just drop the quotes, and talk about
        standard or ordinary modules directly?)</emphasis>
      </para>
      <para>
        Let's compare the style of &quot;standard&quot; modules to
        first-class modules, using a simple library of abstract
        geometric shapes. In a &quot;standard&quot; module definition,
        we would define the shapes using abstract data types, where
        there is a type <literal>t</literal> that defines the actual
        representation, and the module would include functions that
        operate on the values of type <literal>t</literal>. In the
        following code, the module type <literal>Shape</literal> defines
        the type of generic shape, and the modules
        <literal>Rectangle</literal> and <literal>Line</literal>
        implement some concrete shapes.
      </para>
      <programlisting>
module type Shape = sig
  type t
  val area : t -&gt; int
  val position : t -&gt; int * int
end

module Rectangle = struct
   type t = { width : int; height : int; x : int; y : int }
   let make ~x ~y ~width ~height =
      { width = width; height = height; x = x; y = y }
   let area { width = width; height = height } = width * height
   let position { x = x; y = y } = (x, y)
end

module Line = struct
   type t = { dx : int; dy : int; x : int; y : int }
   let make ~x ~y ~dx ~dy = { dx = dx; dy = dy; x = x; y = y }
   let area _ = 0
   let position { x = x; y = y } = (x, y)
end
</programlisting>
      <para>
        Next, if we want to define a generic shape that is either a
        rectangle or a line, we would probably use a variant type. The
        following module <literal>Shapes</literal> is entirely
        boilerplate. We define the variant type, then functions to
        perform a dynamic dispatch based on the type of object.
      </para>
      <programlisting language="ocaml">
module Shapes = struct
   type t = [ `Rect of Rectangle.t | `Line of Line.t ]
   let make_rectangle = Rectangle.make
   let make_line = Line.make
   let area = function
      `Rect r -&gt; Rectangle.area r
    | `Line l -&gt; Line.area l
   let position = function
      `Rect r -&gt; Rectangle.position r
    | `Line l -&gt; Line.position l
end;;
</programlisting>
      <para>
        In fact, confronted with this boilerplate, we would probably
        choose not use modules at all, but simply define a single module
        with a variant type and the code for all of the shapes. This
        isn't to say that separate code for separate shapes is bad, it
        just means that the language doesn't support it well (at least
        with standard modules).
      </para>
      <para>
        With first-class modules, the situation changes, but we have to
        dispense with the representation type altogether. For immutable
        shapes, the implementation is now trivial.
      </para>
      <programlisting>
# module type Shape = sig
    val area : int
    val position : int * int
  end;;
module type Shape = sig val area : int val position : int * int end
# let make_rectangle ~x ~y ~width ~height =
   let module Rectangle = struct
      let area = width * height
      let position = (x, y)
   end in
   (module Rectangle : Shape);;
val make_rectangle :
  x:int -&gt; y:int -&gt; width:int -&gt; height:int -&gt; (module Shape) = &lt;fun&gt;
# let make_line ~x ~y ~dx ~dy =
   let module Line = struct
      let area = 0
      let position = (x, y)
   end in
   (module Line : Shape);;
val make_line : x:int -&gt; y:int -&gt; dx:'a -&gt; dy:'b -&gt; (module Shape) = &lt;fun&gt;
</programlisting>
      <para>
        For mutable shapes, it isn't much different, but we have to
        include the state as values in the module implementations. For
        this, we'll define a representation type <literal>t</literal> in
        the module implementation, and for rectangles, a value
        <literal>rect</literal> of that type. The code for lines is
        similar.
      </para>
      <programlisting>
# module type Shape = sig
     val area : unit -&gt; int
     val position : unit -&gt; int * int
     val moveby : dx:int -&gt; dy:int -&gt; unit
     val enlargeby : size:int -&gt; unit
  end;;
module type Shape = ...
# let make_rectangle ~x ~y ~width ~height =
    let module Rectangle = struct
      type t = { mutable x : int; mutable y : int;
                 mutable width : int; mutable height : int }
      let rect = { x = x; y = y; width = width; height = height }
      let area () = rect.width * rect.height
      let position () = (rect.x, rect.y)
      let moveby ~dx ~dy =
         rect.x &lt;- rect.x + dx;
         rect.y &lt;- rect.y + dy
      let enlargeby ~size =
         rect.width &lt;- rect.width * size;
         rect.height &lt;- rect.height * size
    end in
    (module Rectangle : Shape);;
val make_rectangle :
  x:int -&gt; y:int -&gt; width:int -&gt; height:int -&gt; (module Shape) = &lt;fun&gt;
</programlisting>
    </sect2>
    <sect2 id="a-more-complete-example----containers">
      <title>A more complete example -- containers</title>
      <para>
        So far, we haven't done anything that really needs modules. The
        type <literal>Shape</literal> could just as well be specified as
        a record type
        <literal>type shape = { area : int; position : int * int; ... }</literal>.
      </para>
      <para>
        To explore the topic more fully, let's implement a system of
        dynamic containers. OCaml already provides a set of standard
        containers like <literal>List</literal>, <literal>Set</literal>,
        <literal>Hashtbl</literal>, etc., but these types have to be
        selected statically. If a function expects a value of type
        <literal>Set.Make(ElementType).t</literal>, then you have to
        pass it a set of exactly that type. What we would like is a kind
        of container where the container implementation is chosen by the
        caller. We define an abstract <emphasis>interface</emphasis>, as
        a module type, then define one or more concrete module
        implementations.
      </para>
      <para>
        Let's start by defining an abstract container interface. It
        contains some elements of type <literal>elt</literal>, and
        functions to examine and iterate through the contents. For
        convenience, we also define a normal type
        <literal>'a container</literal> to represent containers with
        elements of type <literal>'a</literal>.
      </para>
      <programlisting language="ocaml">
module type Container = sig
   type elt
   val empty : unit -&gt; bool
   val iter : (elt -&gt; unit) -&gt; unit
   val fold : ('a -&gt; elt -&gt; 'a) -&gt; 'a -&gt; 'a
end;;

type 'a container = (module Container with type elt = 'a)
</programlisting>
      <sect3 id="imperative-containers">
        <title>Imperative containers</title>
        <para>
          For imperative containers, will also want functions to mutate
          the contents by adding or removing elements. For example, a
          stack can be implemented as a module <literal>Stack</literal>
          that includes all the functions in the generic
          <literal>Container</literal> module, as well as functions to
          push and pop elements.
        </para>
        <programlisting language="ocaml">
module type Stack = sig
   include Container
   val push : elt -&gt; unit
   val pop : unit -&gt; elt
end;;

type 'a stack = (module Stack with type elt = 'a)
</programlisting>
        <para>
          Now that the types are defined, the next step is to define a
          concrete container implementation. For this simple example,
          we'll use a list to represent a stack. The function
          <literal>make_list_stack</literal> constructs module
          implementation using a <literal>let module</literal>
          construction, then returns the result.
        </para>
        <programlisting>
# let make_list_stack (type element) () : element stack =
    let module ListStack = struct
      type elt = element
      let contents = ref []
      let empty () = !contents = []
      let iter f = List.iter f !contents
      let fold f x = List.fold_left f x !contents
      let push x = contents := x :: !contents
      let pop () =
         match !contents with
            x :: rest -&gt; contents := rest; x
          | [] -&gt; raise (Invalid_argument &quot;stack is empty&quot;)
    end in
    (module ListStack : Stack with type elt = element);;
val make_list_stack : unit -&gt; 'a stack = &lt;fun&gt;
</programlisting>
        <para>
          Note the use of the explicit type parameter
          <literal>element</literal>. This is required because the use
          of a type variable in the module definition (like
          <literal>type elt = 'a</literal>) would be rejected by the
          compiler. The construction and use of the stack is
          straightforward.
        </para>
        <programlisting>
# let demo (s : int stack) =
    let module S = (val s) in
    S.push 5;
    S.push 17;
    S.iter (fun i -&gt; Printf.printf &quot;Element: %d\n&quot; i);;
val demo : int stack -&gt; unit = &lt;fun&gt;
# demo (make_list_stack ());;
Element: 17
Element: 5
- : unit = ()
</programlisting>
        <para>
          The <literal>demo</literal> function is entirely oblivious to
          the implementation of the stack. Instead of passing a module
          implementation based on lists, we could pass a different
          implementation based on arrays.
        </para>
        <para>
          We could go on to define other containers, sets, dictionaries,
          queues, etc. but the implementations would be similar to what
          we have seen. Instead, let's look at functional data
          structures, which require a little more work to express.
        </para>
      </sect3>
      <sect3 id="pure-functional-containers">
        <title>Pure functional containers</title>
        <para>
          Imperative data structures have simpler types that functional
          ones because the return type of imperative functions is just
          <literal>unit</literal>. When we look at pure functional data
          structures, we immediately run into a problem with type
          recursion.
        </para>
        <programlisting>
# module type Container = sig
    type elt
    val empty : bool
    val iter : (elt -&gt; unit) -&gt; unit
    val fold : ('a -&gt; elt -&gt; 'a) -&gt; 'a -&gt; 'a
    val add : elt -&gt; (module Container)
  end;;
Characters 160-178:
     val add : elt -&gt; (module Container)
                      ^^^^^^^^^^^^^^^^^^
Error: Unbound module type Container
</programlisting>
        <para>
          The problem here is that module type definitions are not
          recursive -- we can't use the type being defined in its own
          definition.
        </para>
        <para>
          Recursive modules provide a solution, but it requires a
          &quot;trick&quot;, where we define a module that is equal to
          itself. This module contains only type definitions, and the
          only purpose of the outer recursive module is to allow the
          recursion in the definition. While we're at it, let's include
          a <literal>map</literal> function with the usual semantics.
        </para>
        <programlisting>
module rec Container : sig
   module type T = sig
      type elt
      val empty : bool
      val iter : (elt -&gt; unit) -&gt; unit
      val fold : ('a -&gt; elt -&gt; 'a) -&gt; 'a -&gt; 'a
      val map : (elt -&gt; 'a) -&gt; 'a Container.t
      val add : elt -&gt; elt Container.t
   end
   type 'a t = (module Container.T with type elt = 'a)
end = Container;;
</programlisting>
        <para>
          There are several ways to write this model, but this
          definition is convenient because it defines both a module type
          <literal>Container.T</literal> and a value type
          <literal>'a Container.t</literal>. The outer recursive module
          <literal>Container</literal> allows the module type
          <literal>T</literal> to refer to the value type
          <literal>t</literal> and <emphasis>vice versa</emphasis>. Note
          that the module <literal>Container</literal> is defined as
          itself (as <literal>Container</literal>).
        </para>
        <para>
          With this first technicality out of the way, the next one is
          how to construct values of type
          <literal>Container.t</literal>. In the imperative version of
          the stack, we used a function
          <literal>make_list_stack</literal>. We want to do the same
          here, but the function definition must be both recursive and
          polymorphic.
        </para>
        <programlisting>
# let make_stack () =
    let rec make : 'a. 'a list -&gt; 'a Container.t = fun
      (type element) (contents : element list) -&gt;
      let module NewList = struct
         type elt = element
         let empty = contents = []
         let iter f = List.iter f contents
         let fold f x = List.fold_left f x contents
         let map f = make (List.map f contents)
         let add x = make (x :: contents)
      end in
      (module NewList : Container.T with type elt = element)
   in
   make [];;
val make_stack : unit -&gt; 'a Container.t = &lt;fun&gt;
</programlisting>
        <para>
          The recursion here is particularly important. The functions
          <literal>map</literal> and <literal>add</literal> return new
          collections, so they call the function <literal>make</literal>
          recursively. The explicit polymorphic type
          <literal>make : 'a. 'a list -&gt; 'a Container.t</literal>
          means that the function <literal>make</literal> is properly
          polymorphic, so that the <literal>map</literal> function is
          polymorphic.
        </para>
        <para>
          Now that the construction is done, the usage is similar to the
          imperative case, except that now the data structure is
          functional.
        </para>
        <programlisting>
# let demo (s : int Container.t) =
    let module S = (val s) in
    let module S = (val (S.add 5)) in
    let module S = (val (S.add 17)) in
    S.iter (fun i -&gt; Printf.printf &quot;Int Element: %d\n&quot; i);
    let s = S.map (fun i -&gt; float_of_int i +. 0.1) in
    let module S = (val s) in
    S.iter (fun x -&gt; Printf.printf &quot;Float Element: %f\n&quot; x);
    s;;
val demo : int Container.t -&gt; float Container.t = &lt;fun&gt;
# demo (make_stack ());;
Int Element: 17
Int Element: 5
Float Element: 17.100000
Float Element: 5.100000
- : unit = ()
</programlisting>
        <para>
          The syntactic load here is pretty high, requiring a
          <literal>let module</literal> expression to name every
          intermediate value. First-class modules are fairly new to the
          language, and this is likely to change, but in the meantime
          the syntactic load can be pretty daunting.
        </para>
        <para>
          Let's look a some other more typical examples, where dynamic
          module selection is more localized.
        </para>
        <para>
          _(jyh: This is a rough draft, I'm not sure about the ordering
          and the topics, yet. Switching back to Ron's text now.)
        </para>
      </sect3>
    </sect2>
    <sect2 id="dynamically-choosing-a-module">
      <title>Dynamically choosing a module</title>
      <para>
        Perhaps the simplest thing you can do with first-class modules
        that you can't do without them is to pick the implementation of
        a module at runtime.
      </para>
      <para>
        Consider an application that does I/O multiplexing using a
        system call like <literal>select</literal> to determine which
        file descriptors are ready to use. There are in fact multiple
        APIs you might want to use, including <literal>select</literal>
        itself, <literal>epoll</literal>, and <literal>libev</literal>,
        where different multiplexers make somewhat different performance
        and portability trade-offs. You could support all of these in
        one application by defining a single module, let's call it
        <literal>Mutliplexer</literal>, whose implementation is chosen
        at run-time based on an environment variable.
      </para>
      <para>
        To do this, you'd first need an interface <literal>S</literal>
        that all of the different multiplexer implementations would need
        to match, and then an implementation of each multiplexer.
      </para>
      <programlisting language="ocaml">
(* file: multiplexer.ml *)

(* An interface the OS-specific functionality *)
module type S = sig ... end

(* The implementations of each individual multiplexer *)
module Select : S = struct ... end  
module Epoll  : S = struct ... end
module Libev  : S = struct ... end
</programlisting>
      <para>
        We can choose the first-class module that we want based on
        looking up an environment variable.
      </para>
      <programlisting language="ocaml">
let multiplexer =
  match Sys.getenv &quot;MULTIPLEXER&quot; with
  | None
  | Some &quot;select&quot; -&gt; (module Select : S)
  | Some &quot;epoll&quot;  -&gt; (module Epoll : S)
  | Some &quot;libev&quot;  -&gt; (module Libev : S)
  | Some other -&gt; failwithf &quot;Unknown multiplexer: %s&quot; other ()
</programlisting>
      <para>
        Finally, we can convert the resulting first-class module back to
        an ordinary module, and then include that so it becomes part of
        the body of our module.
      </para>
      <programlisting language="ocaml">
(* The final, dynamically chosen, implementation *)
include (val multiplexer : S)
</programlisting>
    </sect2>
    <sect2 id="example-a-service-bundle">
      <title>Example: A service bundle</title>
      <para>
        This section describes the design of a library for bundling
        together multiple services, where a service is a piece of code
        that exports a query interface. A service bundle combines
        together multiple individual services under a single query
        interface that works by dispatching incoming queries to the
        appropriate underlying service.
      </para>
      <para>
        The following is a first attempt at an interface for our
        <literal>Service</literal> module, which contains both a module
        type <literal>S</literal>, which is the interface that a service
        should meet, as well as a <literal>Bundle</literal> module which
        is for combining multiple services.
      </para>
      <programlisting language="ocaml">
(* file: service.mli *)

open Core.Std

(** The module type for a service. *)
module type S = sig
  type t
  val name           : string
  val create         : unit -&gt; t
  val handle_request : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t
end

(** Bundles multiple services together *)
module Bundle : sig
  type t
  val create : (module S) list -&gt; t
  val handle_request : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t
  val service_names  : t -&gt; string list
end
</programlisting>
      <para>
        Here, a service has a state, represented by the type
        <literal>t</literal>, a name by which the service can be
        referenced, a function <literal>create</literal> for
        instantiating a service, and a function by which a service can
        actually handle a request. Here, requests and responses are
        delivered as s-expressions. At the <literal>Bundle</literal>
        level, the s-expression of a request is expected to be formatted
        as follows:
      </para>
      <programlisting>
(&lt;service-name&gt; &lt;body&gt;)
</programlisting>
      <para>
        where <literal>&lt;service_name&gt;</literal> is the service
        that should handle the request, and
        <literal>&lt;body&gt;</literal> is the body of the request.
      </para>
      <para>
        Now let's look at how to implement <literal>Service</literal>.
        The core datastructure of <literal>Bundle</literal> is a
        hashtable of request handlers, one per service. Each request
        handler is a function of type
        <literal>(Sexp.t -&gt; Sexp.t Or_error.t)</literal>. These
        request handlers really stand in for the underlying service,
        with the particular state of the service in question being
        hidden inside of the request handler.
      </para>
      <para>
        The first part of <literal>service.ml</literal> is just the
        preliminaries: the definition of the module type
        <literal>S</literal>, and the definition of the type
        <literal>Bundle.t</literal>.
      </para>
      <programlisting language="ocaml">
(* file: service.ml *)

open Core.Std

module type S = sig
  type t
  val name           : string
  val create         : unit -&gt; t
  val handle_request : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t
end

module Bundle = struct
  type t = { handlers: (Sexp.t -&gt; Sexp.t Or_error.t) String.Table.t; }
</programlisting>
      <para>
        The next thing we need is a function for creating a
        <literal>Bundle.t</literal>. This <literal>create</literal>
        function builds a table to hold the request handlers, and then
        iterates through the services, unpacking each module,
        constructing the request handler, and then putting that request
        handler in the table.
      </para>
      <programlisting>
  (** Creates a handler given a list of services *)
  let create services =
    let handlers = String.Table.create () in
    List.iter services ~f:(fun service_m -&gt;
      let module Service = (val service_m : S) in
      let service = Service.create () in
      if Hashtbl.mem handlers Service.name then
        failwith (&quot;Attempt to register duplicate handler for &quot;^Service.name);
      Hashtbl.replace handlers ~key:Service.name
        ~data:(fun sexp -&gt; Service.handle_request service sexp)
    );
    {handlers}
</programlisting>
      <para>
        Note that the <literal>Service.t</literal> that is created is
        referenced by the corresponding request handler, so that it is
        effectively hidden behind the function in the
        <literal>handlers</literal> table.
      </para>
      <para>
        Now we can write the function for the bundle to handle requests.
        The handler will examine the s-expression to determine the body
        of the query and the name of the service to dispatch to. It then
        looks up the handler calls it to generate the response.
      </para>
      <programlisting language="ocaml">
  let handle_request t sexp =
    match sexp with
    | Sexp.List [Sexp.Atom name;query] -&gt;
      begin match Hashtbl.find t.handlers name with
      | None -&gt; Or_error.error_string (&quot;Unknown service: &quot;^name)
      | Some handler -&gt;
        try handler query
        with exn -&gt; Error (Error.of_exn exn)
      end
    | _ -&gt; Or_error.error_string &quot;Malformed query&quot;
</programlisting>
      <para>
        Last of all, we define a function for looking up the names of
        the available services.
      </para>
      <programlisting language="ocaml">
  let service_names t = Hashtbl.keys t.handlers

end
</programlisting>
      <para>
        To see this system in action, we need to define some services,
        create the corresponding bundle, and then hook that bundle up to
        some kind of client. For simplicity, we'll build a simple
        command-line interface. There are two functions below:
        <literal>handle_one</literal>, which handles a single
        interaction; and <literal>handle_loop</literal>, which creates
        the bundle and then runs <literal>handle_one</literal> in a
        loop.
      </para>
      <programlisting language="ocaml">
(* file: service_client.ml *)

open Core.Std

(** Handles a single request coming from stdin *)
let handle_one bundle =
  printf &quot;&gt;&gt;&gt; %!&quot;; (* prompt *)
  match In_channel.input_line stdin with
  | None -&gt; `Stop (* terminate on end-of-stream, so Ctrl-D will exit *)
  | Some line -&gt;
    let line = String.strip line in (* drop leading and trailing whitespace *)
    if line = &quot;&quot; then `Continue
    else match Or_error.try_with (fun () -&gt; Sexp.of_string line) with
    | Error err -&gt;
      eprintf &quot;Couldn't parse query: %s\n%!&quot; (Error.to_string_hum err);
      `Continue
    | Ok query_sexp -&gt;
      let resp = Service.Bundle.handle_request bundle query_sexp in
      Sexp.output_hum stdout (&lt;:sexp_of&lt;Sexp.t Or_error.t&gt;&gt; resp);
      Out_channel.newline stdout;
      `Continue

let handle_loop services =
  let bundle = Service.Bundle.create services in
  let rec loop () =
    match handle_one bundle with
    | `Stop -&gt; ()
    | `Continue -&gt; loop ()
  in
  loop ()
</programlisting>
      <para>
        Now we'll create a couple of toy services. One service is a
        counter that can be updated by query; and the other service
        lists a directory. The last line then kicks off the shell with
        the services we've defined.
      </para>
      <programlisting language="ocaml">
module Counter : Service.S = struct
  type t = int ref

  let name = &quot;update-counter&quot;
  let create () = ref 0

  let handle_request t sexp =
    match Or_error.try_with (fun () -&gt; int_of_sexp sexp) with
    | Error _ as err -&gt; err
    | Ok x -&gt;
      t := !t + x;
      Ok (sexp_of_int !t)
end

module List_dir : Service.S = struct
  type t = unit

  let name = &quot;ls&quot;
  let create () = ()

  let handle_request () sexp =
    match Or_error.try_with (fun () -&gt; string_of_sexp sexp) with
    | Error _ as err -&gt; err
    | Ok dir -&gt; Ok (Array.sexp_of_t String.sexp_of_t (Sys.readdir dir))
end

let () =
  handle_loop [(module List_dir : Service.S); (module Counter : Service.S)]
</programlisting>
      <para>
        And now we can go ahead and start up the client.
      </para>
      <programlisting>
$ ./service_client.byte
&gt;&gt;&gt; (update-counter 1)
(Ok 1)
&gt;&gt;&gt; (update-counter 10)
(Ok 11)
&gt;&gt;&gt; (ls .)
(Ok
 (_build _tags service.ml service.mli service.mli~ service.ml~
  service_client.byte service_client.ml service_client.ml~))
&gt;&gt;&gt;
</programlisting>
      <para>
        Now, let's consider what happens to the design when we want to
        make the interface of a service a bit more realistic. In
        particular, right now services are created without any
        configuration. Let's add a config type to each service, and
        change the interface of <literal>Bundle</literal> so that
        services can be registered along with their configs. At the same
        time, we'll change the <literal>Bundle</literal> API to allow
        services to be changed dynamically, rather than just added at
        creation time.
      </para>
    </sect2>
  </sect1>
</chapter>
<chapter id="input-and-output">
  <title>Input and Output</title>
  <para>
  </para>
</chapter>
<chapter id="serialization-with-json-xml-and-s-expressions">
  <title>Serialization with JSON, XML and S-Expressions</title>
  <para>
    Data serialization, <emphasis>i.e.</emphasis> reading and writing
    program data to a sequence of bytes, is an important and common
    programming task. Sometimes you need to match someone else's data
    format (such as XML), and other times you just want to quickly dump
    some values to disk and read them back later. To this end, OCaml
    comes with several techniques for data serialization depending on
    what your problem is.
  </para>
  <para>
    We'll start off by looking at JSON and XML first, as they are very
    common third-party data formats. After that, we'll introduce some
    syntax extensions in Core that make it really easy to manipulate
    s-expressions and safe binary serialisers directly from OCaml types.
  </para>
  <sect1 id="json">
    <title>JSON</title>
    <para>
      JSON is a lightweight data-interchange format often used in web
      services and browsers. It is described in
      <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</ulink>,
      and is designed to be easy to parse and generate. You'll run into
      JSON very often when working with modern APIs, and so we'll cover
      several different ways to manipulate it in this chapter. Along the
      way we'll introduce several new libraries and syntax extensions
      which make the job easier.
    </para>
    <para>
      JSON consists of just two basic structures: an unordered
      collection of key/value pairs, and an ordered list of values.
      Values can be strings, booleans, floats, integers or null. Let's
      see what an example JSON record for a book description looks like:
    </para>
    <programlisting language="json">
{
  &quot;title&quot;: &quot;Real World OCaml&quot;,
  &quot;tags&quot; : [ &quot;functional programming&quot;, &quot;ocaml&quot;, &quot;algorithms&quot; ],
  &quot;pages&quot;: 450,
  &quot;authors&quot;: [
    { &quot;name&quot;: &quot;Jason Hickey&quot;, &quot;affiliation&quot;: &quot;Google&quot; },
    { &quot;name&quot;: &quot;Anil Madhavapeddy&quot;, &quot;affiliation&quot;: &quot;Cambridge&quot;},
    { &quot;name&quot;: &quot;Yaron Minsky&quot;, &quot;affiliation&quot;: &quot;Jane Street&quot;}
  ],
  &quot;is_online&quot;: true
}
</programlisting>
    <para>
      JSON values usually start with an object at the top level that
      contains a set of key/value pairs. The keys must be strings, but
      values can be any JSON type. In the example above,
      <literal>tags</literal> is a string list, while the
      <literal>authors</literal> field contains a list of records.
      Unlike OCaml lists, JSON lists can contain completely different
      JSON types within them.
    </para>
    <para>
      This free-form nature of JSON types is both a blessing and a
      curse. It's very easy to generate JSON values, but code parsing
      them also has to cope with handling subtle variations in how
      values are represented. For example, what if the
      <literal>pages</literal> value above is actually represented as a
      string value of <literal>&quot;450&quot;</literal> instead of an
      integer?
    </para>
    <para>
      Our first task is to parse the JSON into a more structured OCaml
      type so that we can use static typing more effectively. When
      manipulating JSON in Python or Ruby, you might write unit tests to
      check that you have handled unusual inputs. The OCaml model
      prefers compile-time static checking as well as unit tests. For
      example, using pattern matching can warn you if you've not checked
      that a value can be <literal>Null</literal> as well as contain an
      actual value.
    </para>
    <para>
      There are several JSON parsers available for OCaml, and we've
      picked
      <ulink url="http://mjambon.com/yojson.html"><literal>Yojson</literal></ulink>
      for the remainder of this chapter. You can
      <literal>opam install yojson</literal> to get it via the OPAM
      package manager.
    </para>
    <sect2 id="parsing-standard-json-with-yojson">
      <title>Parsing standard JSON with Yojson</title>
      <para>
        The JSON specification has very few data types, and Yojson
        implements these in the <literal>Yojson.Basic</literal> module.
        The <literal>json</literal> type shown below is sufficient to
        express any valid JSON structure. Note that some of the types
        are recursive, so that fields can contain references to more
        JSON fields, and that it also specifically includes a
        <literal>Null</literal> variant for empty fields.
      </para>
      <programlisting language="ocaml">
type json = [
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Int of int
  | `List of json list
  | `Null
  | `String of string ] 
</programlisting>
      <para>
        Let's parse the earlier JSON string example into this type now.
        The first stop is the <literal>Yojson.Basic</literal>
        documentation, where we find these helpful functions:
      </para>
      <programlisting language="ocaml">
val from_string : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; json
(* Read a JSON value from a string.
  [buf] : use this buffer at will during parsing instead of creating a new one.
  [fname] : data file name to be used in error messages. It does not have to be a real file.
  [lnum] : number of the first line of input. Default is 1.

val from_channel : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; in_channel -&gt; json
(* Read a JSON value from a channel. See [from_string] for the meaning of the 
   optional arguments. *)

val from_file : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; json
(* Read a JSON value from a file. See [from_string] for the meaning of the optional
   arguments. *)
</programlisting>
      <para>
        When first reading these interfaces, you can generally ignore
        the optional arguments (with the question marks in the type), as
        they will be filled in with sensible values. The simpler
        signature for these values with the optional elements removed
        makes their purpose quite clear:
      </para>
      <programlisting language="ocaml">
val from_string : string -&gt; json
val from_file : string -&gt; json
val from_channel : in_channel -&gt; json
</programlisting>
      <para>
        The <literal>in_channel</literal> constructor is from the
        original OCaml standard library, and its use is considered
        deprecated when using the Core standard library. This leaves us
        with two ways of parsing the JSON: either from a string buffer,
        or from a file on a filesystem. The next example shows both in
        action, assuming the JSON record is stored in a file called
        <emphasis>book.json</emphasis>:
      </para>
      <programlisting language="ocaml">
open Core.Std

let _ =
  (* Read JSON file into an OCaml string *)
  let buf = In_channel.read_all &quot;book.json&quot; in

  (* Use the string JSON constructor *)
  let json1 = Yojson.Basic.from_string buf in

  (* Use the file JSON constructor *)
  let json2 = Yojson.Basic.from_file &quot;book.json&quot; in

  (* Test that the two values are the same *)
  print_endline (if json1 = json2 then &quot;OK&quot; else &quot;FAIL&quot;)
  print_endline (if phys_equal json1 json2 then &quot;FAIL&quot; else &quot;OK&quot;)
</programlisting>
      <para>
        <literal>from_file</literal> is a convenience function in Yojson
        that accepts an input filename and takes care of opening and
        closing it for you. It's far more common to use
        <literal>from_string</literal> to construct a JSON value an
        OCaml <literal>string</literal> buffers. These strings can come
        from a network connection (we'll see more of this in in the
        {{{ASYNC}}} chapter) or even a database. Finally, the example
        checks that the two input mechanisms actually resulted in the
        same OCaml data structure.
      </para>
      <sidebar>
      <title>
      The difference between <literal>=</literal> and
      <literal>==</literal>, and <literal>phys_equal</literal> in Core
      </title>
      <para>
        If you come from a C/C++ background, you will probably
        reflexively use <literal>==</literal> to test two values for
        equality. In OCaml, <literal>==</literal> tests for
        <emphasis>physical</emphasis> equality, and <literal>=</literal>
        tests for <emphasis>structural</emphasis> equality.
      </para>
      <para>
        The <literal>==</literal> physical equality test will match if
        two data structures have precisely the same pointer in memory.
        Two data structures that have identical contents, but are
        constructed separately, will not match using this operator. In
        the JSON example, the <literal>json1</literal> and
        <literal>json2</literal> values are not identical and so would
        fail the physical equality test.
      </para>
      <para>
        The <literal>=</literal> structural equality operator
        recursively inspects each field in the two values and tests them
        individually for equality. In the JSON parsing example, every
        field will be traversed and checked, and they will check out as
        equal. Crucially, if your data structure is cyclical (that is, a
        value recursively points back to another field within the same
        structure), the <literal>=</literal> operator will never
        terminate, and your program will hang! In this situation, you
        must use the physical equality operator, or write a custom
        comparison function that breaks the recursion.
      </para>
      <para>
        It's quite easy to mix up the use of <literal>=</literal> and
        <literal>==</literal>, so Core disables the
        <literal>==</literal> operator and provides
        <literal>phys_equal</literal> instead. You'll see a type error
        if you use <literal>==</literal> anywhere:
      </para>
      <programlisting>
# 1 == 2;;
Error: This expression has type int but an expression was expected of type
         [ `Consider_using_phys_equal ]
# phys_equal 1 2;;
- : bool = false
</programlisting>
      <para>
        If you feel like hanging your OCaml interpreter, you can verify
        what happens with recursive values for yourself:
      </para>
      <programlisting>
# type t1 = { foo1:int; bar1:t2 } and t2 = { foo2:int; bar2:t1 } ;;
type t1 = { foo1 : int; bar1 : t2; }
and t2 = { foo2 : int; bar2 : t1; }
# let rec v1 = { foo1=1; bar1=v2 } and v2 = { foo2=2; bar2=v1 };; 
&lt;lots of text&gt;
# v1 == v1;;
- : bool = true
# phys_equal v1 v1;;
- : bool = true
# v1 = v1 ;;
&lt;press ^Z and kill the process now&gt;
</programlisting>
      </sidebar>
      <sect3 id="selecting-values-from-json-structures">
        <title>Selecting values from JSON structures</title>
        <para>
          Now that we've figured out how to parse the example JSON, lets
          see how we can manipulate it from OCaml code with a more
          complete example.
        </para>
        <programlisting language="ocaml">
open Core.Std
open Async.Std
open Printf

let _ =
  (* Read the JSON file *)
  let json = Yojson.Basic.from_file &quot;book.json&quot; in

  (* Locally open the JSON manipulation functions *)
  let open Yojson.Basic.Util in
  let title = json |! member &quot;title&quot; |! to_string in
  let tags = json |! member &quot;tags&quot; |! to_list |! filter_string in
  let pages = json |! member &quot;pages&quot; |! to_int in
  let is_online = json |! member &quot;is_online&quot; |! to_bool_option in
  let is_translated = json |! member &quot;is_translated&quot; |! to_bool_option in
  let authors = json |! member &quot;authors&quot; |! to_list in
  let names = List.map authors ~f:(fun json -&gt; member &quot;name&quot; json |! to_string) in

  (* Print the results of the parsing *)
  printf &quot;Title: %s (%d)\n&quot; title pages;
  printf &quot;Authors: %s\n&quot; (String.concat ~sep:&quot;, &quot; names);
  printf &quot;Tags: %s\n&quot; (String.concat ~sep:&quot;, &quot; tags);
  let string_of_bool_option =
    function
    | None -&gt; &quot;&lt;none&gt;&quot;
    | Some true -&gt; &quot;yes&quot;
    | Some false -&gt; &quot;no&quot; in
  printf &quot;Online: %s\n&quot; (string_of_bool_option is_online);
  printf &quot;Translated: %s\n&quot; (string_of_bool_option is_translated)
</programlisting>
        <para>
          This introduces the <literal>Yojson.Basic.Util</literal>
          module, which contains <emphasis>combinator</emphasis>
          functions for JSON manipulation. Combinators are a style of
          function that can be chained together using the
          <literal>|!</literal> pipe operator to select and convert
          values out of the JSON structure. Let's examine some of them
          in more detail:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              For the <literal>title</literal> string, the
              <literal>member</literal> combinator extracts the key from
              the array, and casts it to an OCaml string. An exception
              is raised if the JSON value is not a string.
            </para>
          </listitem>
          <listitem>
            <para>
              The <literal>tags</literal> field is similar to
              <literal>title</literal>, but are passed through the
              <literal>to_list</literal> combinator since they are a
              JSON list. The <literal>filter_string</literal> combinator
              folds all of the strings in the JSON list into an OCaml
              list (any non-strings also in there are simply ignored).
            </para>
          </listitem>
          <listitem>
            <para>
              The <literal>is_online</literal> and
              <literal>is_translated</literal> fields are optional in
              our JSON schema, and no error is raised if they are not
              present in the JSON array. The resulting OCaml type is a
              <literal>string option</literal> to reflect this. In our
              example, only <literal>is_online</literal> is present and
              <literal>is_translated</literal> will be
              <literal>None</literal>.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          In the last part of the example, we simply print the parsed
          fields since they are just normal OCaml values. This technique
          of using chained parsing functions is very powerful in
          combination with the OCaml type system. Many errors that don't
          make sense at runtime (for example, mixing up lists and
          objects) will be caught statically via a type error.
        </para>
      </sect3>
    </sect2>
    <sect2 id="constructing-json-values">
      <title>Constructing JSON values</title>
      <para>
        To build and print JSON values, you can just construct values of
        type <literal>json</literal> and call the
        <literal>to_string</literal> function. There are also
        pretty-printing functions that lay out the output in a more
        human-readable style:
      </para>
      <programlisting>
# let x = `Assoc [ (&quot;key&quot;, `String &quot;value&quot;) ] ;;
val x : [&gt; `Assoc of (string * [&gt; `String of string ]) list ] =
  `Assoc [(&quot;key&quot;, `String &quot;value&quot;)]
# Yojson.Basic.pretty_to_string x ;;
- : string = &quot;{ \&quot;key\&quot;: \&quot;value\&quot; }&quot;
# Yojson.Basic.pretty_to_channel stdout x ;;
{ &quot;key&quot;: &quot;value&quot; }
- : unit = ()
</programlisting>
      <para>
        In the example above, although the value that
        <literal>x</literal> has is compatible with the type
        <literal>json</literal>, it's not explicitly defined as such.
        The type inference engine will figure out a type that is based
        on how the value <literal>x</literal> is used, and in this case
        only the <literal>Assoc</literal> and <literal>String</literal>
        variants are present. One difficulty you will encounter is that
        type errors involving polymorphic variants can be quite verbose
        if you make a mistake in your code. For example, suppose you
        build an <literal>Assoc</literal> and include a single value
        instead of a list of keys:
      </para>
      <programlisting>
# let x = `Assoc (&quot;key&quot;, `String &quot;value&quot;);;
val x : [&gt; `Assoc of string * [&gt; `String of string ] ] =
  `Assoc (&quot;key&quot;, `String &quot;value&quot;)
# Yojson.Basic.pretty_to_string x;;
Error: This expression has type
         [&gt; `Assoc of string * [&gt; `String of string ] ]
       but an expression was expected of type Yojson.Basic.json
       Types for tag `Assoc are incompatible
</programlisting>
      <para>
        The type error above isn't <emphasis>wrong</emphasis> as such,
        but can be inconvenient to wade through for larger values. An
        easy way to narrow down this sort of type error is to add
        explicit type annotations as a compiler hint about your
        intentions:
      </para>
      <programlisting>
# let (x:Yojson.Basic.json) = `Assoc (&quot;key&quot;, `String &quot;value&quot;);;
Error: This expression has type 'a * 'b
       but an expression was expected of type
         (string * Yojson.Basic.json) list
</programlisting>
      <para>
        In this case, we've marked the <literal>x</literal> as being of
        type <literal>Yojson.Basic.json</literal>, and the compiler
        immediately spots that the argument to the
        <literal>Assoc</literal> variant has the incorrect type. This
        illustrates the strengths and drawbacks of using polymorphic
        variants: they make it possible to easily subtype across module
        boundaries (the <literal>Basic</literal> and
        <literal>Safe</literal> in Yojson's case), but the error
        messages can be more confusing. However, a bit of careful manual
        type annotation is all it takes to make tracking down such
        issues much easier.
      </para>
      <para>
        <emphasis>avsm</emphasis>: segway into memory representation of
        polyvariants here?
      </para>
      <sect3 id="using-non-standard-json-extensions">
        <title>Using non-standard JSON extensions</title>
        <para>
          The standard JSON types are <emphasis>really</emphasis> basic,
          and OCaml types are far more expressive. Yojson supports an
          extended JSON format for those times when you're not
          interoperating with external systems and just want a
          convenient human-readable local format. The
          <literal>Yojson.Safe.json</literal> type is a superset of the
          <literal>Basic</literal> polymorphic variant, and looks like
          this:
        </para>
        <programlisting language="ocaml">
type json = [ 
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Floatlit of string
  | `Int of int
  | `Intlit of string
  | `List of json list
  | `Null
  | `String of string
  | `Stringlit of string
  | `Tuple of json list
  | `Variant of string * json option ] 
</programlisting>
        <para>
          You should immediately be able to spot a benefit of using
          polymorphic variants here. A standard JSON type such as a
          <literal>String</literal> will type-check against both the
          <literal>Basic</literal> module and also the non-standard
          <literal>Safe</literal> module. However, if you use extension
          values such as <literal>Tuple</literal> with the
          <literal>Basic</literal> module, they will not be a valid
          sub-type and the compiler will complain.
        </para>
        <para>
          The extensions includes with Yojson include:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              The <literal>lit</literal> suffix denotes that the value
              is stored as a JSON string. For example, a
              <literal>Floatlit</literal> will be stored as
              <literal>&quot;1.234&quot;</literal> instead of
              <literal>1.234</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              The <literal>Tuple</literal> type is stored as
              <literal>(&quot;abc&quot;, 123)</literal> instead of a
              list.
            </para>
          </listitem>
          <listitem>
            <para>
              The <literal>Variant</literal> type encodes OCaml variants
              more explicitly, as
              <literal>&lt;&quot;Foo&quot;&gt;</literal> or
              <literal>&lt;&quot;Bar&quot;:123&gt;</literal> for a
              variant with parameters.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          The only purpose of these extensions is to make the data
          representation more expressive without having to refer to the
          original OCaml types. You can always cast a
          <literal>Safe.json</literal> to a
          <literal>Basic.json</literal> type by using the
          <literal>to_basic</literal> function as follows:
        </para>
        <programlisting language="ocaml">
val to_basic : json -&gt; Yojson.Basic.json
(** Tuples are converted to JSON arrays, Variants are converted to JSON strings
or arrays of a string (constructor) and a json value (argument). Long integers
are converted to JSON strings.  Examples: 

`Tuple [ `Int 1; `Float 2.3 ]   -&gt;    `List [ `Int 1; `Float 2.3 ]
`Variant (&quot;A&quot;, None)            -&gt;    `String &quot;A&quot;
`Variant (&quot;B&quot;, Some x)          -&gt;    `List [ `String &quot;B&quot;, x ]
`Intlit &quot;12345678901234567890&quot;  -&gt;    `String &quot;12345678901234567890&quot;
 *)
</programlisting>
      </sect3>
    </sect2>
    <sect2 id="automatically-mapping-json-to-ocaml-types">
      <title>Automatically mapping JSON to OCaml types</title>
      <para>
        The combinators described earlier make it fairly easy to extract
        fields from JSON records, but the process is still pretty
        manual. We'll talk about how to do larger-scale JSON parsing
        now, using a domain-specific language known as
        <ulink url="http://oss.wink.com/atdgen/">ATD</ulink>.
      </para>
      <para>
        The idea behind ATD is to specify the format of the JSON in a
        separate file, and then run a compiler
        (<literal>atdgen</literal>) that outputs OCaml code to construct
        and parse JSON values. This means that you don't need to write
        any OCaml parsing code at all, as it will all be auto-generated
        for you.
      </para>
      <para>
        Let's go straight into looking at an example of how this works,
        by using a small portion of the Github API. Github is a popular
        code hosting and sharing website that provides a JSON-based web
        <ulink url="http://developer.github.com">API</ulink>. The ATD
        code fragment below describes the Github authorization API. It
        is based on a pseudo-standard web protocol known as OAuth, and
        is used to authorized users to access Github services.
      </para>
      <programlisting language="ocaml">
type scope = [
    User &lt;json name=&quot;user&quot;&gt;
  | Public_repo &lt;json name=&quot;public_repo&quot;&gt;
  | Repo &lt;json name=&quot;repo&quot;&gt;
  | Repo_status &lt;json name=&quot;repo_status&quot;&gt;
  | Delete_repo &lt;json name=&quot;delete_repo&quot;&gt;
  | Gist &lt;json name=&quot;gist&quot;&gt;
]

type app = {
  name: string;
  url: string;
}  &lt;ocaml field_prefix=&quot;app_&quot;&gt;

type authorization_request = {
  scopes: scope list;
  note: string;
} &lt;ocaml field_prefix=&quot;auth_req_&quot;&gt;

type authorization_response = {
  scopes: scope list;
  token: string;
  app: app;
  url: string;
  id: int;
  ?note: string option;
  ?note_url: string option;
}
</programlisting>
      <para>
        ATD is (deliberately) similar to OCaml type definitions, with
        some important differences. Each field can include extra
        annotations to customise the parsing code for a particular
        backend. For example, the Github <literal>scope</literal> field
        above is defined as a variant type, but with the actual JSON
        values being defined explicitly (as lower-case versions).
      </para>
      <para>
        The ATD spec can be compiled to a number of OCaml targets. Let's
        run the compiler twice, to generate some OCaml type definitions,
        and a JSON serialiser.
      </para>
      <programlisting language="Bash">
$ atdgen -t github.atd
$ atdgen -j github.atd
</programlisting>
      <para>
        This will generate some new files in your current directory.
        <literal>Github_t.ml</literal> and
        <literal>Github_t.mli</literal> will contain an OCaml module
        with types defines that correspond to the ATD file. It looks
        like this:
      </para>
      <programlisting language="ocaml">
type scope = [
  | `User | `Public_repo | `Repo | `Repo_status 
  | `Delete_repo | `Gist
]

type app = { 
  app_name (*atd name *): string; 
  app_url (*atd url *): string 
}

type authorization_request = {
  auth_req_scopes (*atd scopes *): scope list;
  auth_req_note (*atd note *): string
}

type authorization_response = {
  scopes: scope list;
  token: string;
  app: app;
  url: string;
  id: int;
  note: string option;
  note_url: string option
}
</programlisting>
      <para>
        There is an obvious correspondence to the ATD definition. Note
        in particular that field names in separate OCaml records cannot
        shadow each other, and so we specifically prefix every field
        with a prefix to distinguish it from other records. For example,
        <literal>&lt;ocaml field_prefix=&quot;auth_req_&quot;&gt;</literal>
        in the ATD spec prefixes every field name in the generated
        <literal>authorization_request</literal> record with
        <literal>auth_req</literal>.
      </para>
      <para>
        The <literal>Github_t</literal> module only contains the type
        definitions, while <literal>Github_j</literal> has a concrete
        serialization module to and from JSON. You can read the
        <literal>github_j.mli</literal> to see the full interface, but
        the important functions for most uses are the conversion
        functions to and from a string. For our example above, this
        looks like:
      </para>
      <programlisting language="ocaml">
val string_of_authorization_response :
  ?len:int -&gt; authorization_response -&gt; string
  (** Serialize a value of type {!authorization_response}
      into a JSON string.
      @param len specifies the initial length 
                 of the buffer used internally.
                 Default: 1024. *)

val authorization_response_of_string :
  string -&gt; authorization_response
</programlisting>
      <para>
        This is pretty convenient! We've written a single ATD file, and
        all the OCaml boilerplate to convert between JSON and a strongly
        typed record has been generated for us. You can control various
        aspects of the serializer by passing flags to
        <literal>atdgen</literal>. The important ones for JSON are:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>-j-std</literal>: work in standard JSON mode, and
            never print non-standard JSON extensions.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>-j-custom-fields FUNCTION</literal>: call a custom
            function for every unknown field encountered, instead of
            raising a parsing exception.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>-j-defaults</literal>: force the output a JSON
            value even if the specification defines it as the default
            value for that field.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The full ATD specification is quite sophisticated (and well
        documented online at its homepage). The ATD compiler can also
        target formats other than JSON, and also outputs code for other
        languages such as Java if you need more interoperability. There
        are also several similar projects you can investigate which
        automate the code generation process:
        <ulink url="http://piqi.org">Piqi</ulink> uses the Google
        protobuf format, and
        <ulink url="http://thrift.apache.org">Thrift</ulink> supports a
        huge variety of other programming languages.
      </para>
      <para>
        We'll also return to the Github example here later in the book
        when discussing the Async networking library, and you can find
        the full ATD specification for Github in the
        <ulink url="http://github.com/avsm/ocaml-github"><literal>ocaml-github</literal></ulink>
        repository.
      </para>
    </sect2>
  </sect1>
  <sect1 id="xml">
    <title>XML</title>
    <para>
      XML is a markup language designed to store tree-structured data in
      a format that is (somewhat) human- and machine-readable. Like
      JSON, it is a textual format commonly used in web technologies,
      with a complete
      <ulink url="http://www.w3.org/TR/REC-xml/">specification</ulink>
      available online. A complete description is beyond the scope of
      this book, but we'll explain how to manipulate it now.
    </para>
    <note>
    <title>
    Obtaining and installing XMLM
    </title>
    <para>
      The remainder of this section uses the freely available XMLM
      library. It's easiest to obtain it via OPAM
      (<literal>opam install xmlm</literal>), and the source code and
      documentation are also available
      <ulink url="http://erratique.ch/software/xmlm/doc/Xmlm">online</ulink>.
    </para>
    </note>
    <para>
      Since XML is such a common web format, we've taken our example
      document from the
      <ulink url="http://duckduckgo.com">DuckDuckGo</ulink> search
      engine. This is a smaller search engine than the usual suspects,
      but has the advantage of a freely available API that doesn't
      require you to register before using it. We'll talk more about how
      to use the API later in the {{{ASYNC}}} chapter, but for now
      here's what a shortened XML search response from DuckDuckGo looks
      like:
    </para>
    <programlisting language="ocaml">
&lt;DuckDuckGoResponse version=&quot;1.0&quot;&gt;
&lt;Heading&gt;DuckDuckGo&lt;/Heading&gt;
&lt;AbstractText&gt;DuckDuckGo is an Internet search engine.&lt;/AbstractText&gt;
&lt;AbstractURL&gt;https://en.wikipedia.org/wiki/DuckDuckGo&lt;/AbstractURL&gt;
&lt;AbstractSource&gt;Wikipedia&lt;/AbstractSource&gt;
&lt;Results&gt;
&lt;Result&gt;
  &lt;Text&gt;Official site&lt;/Text&gt;
  &lt;FirstURL&gt;https://duckduckgo.com/&lt;/FirstURL&gt;
  &lt;/Result&gt;
&lt;/Results&gt;
&lt;RelatedTopics&gt;
 &lt;RelatedTopic&gt;
   &lt;Text&gt;Companies based in Pennsylvania&lt;/Text&gt;
   &lt;FirstURL&gt; 
     http://duckduckgo.com/c/Companies_based_in_Pennsylvania
   &lt;/FirstURL&gt;
 &lt;/RelatedTopic&gt;
 &lt;RelatedTopic&gt;
   &lt;Text&gt;Internet search engines&lt;/Text&gt;
   &lt;FirstURL&gt;
     http://duckduckgo.com/c/Internet_search_engines
   &lt;/FirstURL&gt;
 &lt;/RelatedTopic&gt;
&lt;/RelatedTopics&gt;
&lt;/DuckDuckGoResponse&gt;
</programlisting>
    <para>
      The XML document is structured as a series of
      <literal>&lt;tags&gt;</literal> that are closed by an end
      <literal>&lt;/tag&gt;</literal>. The opening tags have an optional
      set of key/value attributes and usually contain text data or
      further tags within them. If the XML document is large, we don't
      want to read the whole thing into memory before processing it.
      Luckily we don't have to, as there are two parsing strategies for
      XML: a low-level <emphasis>streaming</emphasis> API that parses a
      document incrementally, and a simpler but more inefficient tree
      API. We'll start with the streaming API first, as the tree API is
      built on top of it.
    </para>
    <sect2 id="stream-parsing-xml">
      <title>Stream parsing XML</title>
      <para>
        The XMLM documentation is a good place to read about the overall
        layout of the library. It tells us that:
      </para>
      <blockquote>
        <para>
          A well-formed sequence of <literal>signal</literal>s
          represents an XML document tree traversal in depth-first
          order. Input pulls a well-formed sequence of
          <literal>signal</literal>s from a data source and output
          pushes a well-formed sequence of <literal>signal</literal>s to
          a data destination. Functions are provided to easily transform
          sequences of <literal>signal</literal>s to/from arborescent
          data structures.
        </para>
      </blockquote>
      <para>
        The type of a <literal>signal</literal> reveals the basic
        structure of the streaming API in XMLM:
      </para>
      <programlisting language="ocaml">
type signal = [
  | `Data of string
  | `Dtd of dtd
  | `El_end 
  | `El_start of tag 
]
</programlisting>
      <para>
        XMLM outputs an ordered sequence of these signals to your code
        as it parses the document. The structure of XML documents is
        defined via a optional &quot;Document Type Description&quot;
        (DTD). Some XML parsers can validate a document against a DTD,
        but XMLM is a simpler <emphasis>non-validating</emphasis> parser
        that reads the DTD if present but disregards its contents. The
        first <literal>signal</literal> when inputting an XML document
        is always a <literal>Dtd</literal>. The
        <literal>El_start</literal> and <literal>El_end</literal>
        indicate the opening and closing of tags, and
        <literal>Data</literal> is the free-form information contained
        between tags.
      </para>
      <para>
        Let's try our hand at handling signals by writing the XML
        identity function that parses some XML and outputs it again.
        Since this uses the XMLM streaming API, there is minimal
        buffering required.
      </para>
      <programlisting language="ocaml">
let xml_id i o =
  let rec pull i o depth =
    Xmlm.output o (Xmlm.peek i);
    match Xmlm.input i with
    | `El_start _ -&gt; pull i o (depth + 1)
    | `El_end -&gt; if depth &gt; 1 then pull i o (depth - 1)
    | `Data _ -&gt; pull i o depth
    | `Dtd _ -&gt; assert false
  in
  Xmlm.output o (Xmlm.input i); (* `Dtd *)
  pull i o 0;
  if not (Xmlm.eoi i) then invalid_arg &quot;document not well-formed&quot;

let _ =
  let i = Xmlm.make_input (`Channel (open_in &quot;ddg.xml&quot;)) in
  let o = Xmlm.make_output (`Channel stdout) in
  xml_id i o
</programlisting>
      <para>
        Let's start at the bottom, where we open up input and output
        channels to pass to <literal>Xmlm</literal> parser. The
        <literal>input</literal> and <literal>output</literal>
        constructor functions use a polymorphic variant to define the
        mechanism that the library should use to read the document.
        <literal>Channel</literal> is the simplest, but there are
        several others available.
      </para>
      <programlisting language="ocaml">
type source = [
  | `Channel of in_channel
  | `Fun of unit -&gt; int
  | `String of int * string 
] 
</programlisting>
      <para>
        The <literal>Fun</literal> channel returns one character at a
        time as an integer, and <literal>String</literal> starts parsing
        an OCaml string from the given integer offset. Both of these are
        will normally be used in preference to
        <literal>Channel</literal>, which uses an interface that is
        deprecated in Core.
      </para>
      <para>
        The <literal>xml_id</literal> function begins by reading one
        signal, which will always be a <literal>Dtd</literal>. The
        recursive <literal>pull</literal> function is then invoked to
        iterate over the remaining signals. This uses
        <literal>Xmlm.peek</literal> to inspect the current input signal
        and immediately output it. The rest of the function is not
        strictly necessary, but it tracks that all of the tags that have
        been started via the <literal>El_start</literal> signal are also
        closed by a corresponding <literal>El_end</literal> signal. Once
        the <literal>pull</literal> function has finished due to the
        opening tag being closed, the <literal>Xmlm.eoi</literal>
        function verifies that the &quot;end of input&quot; has been
        reached.
      </para>
    </sect2>
    <sect2 id="tree-parsing-xml">
      <title>Tree parsing XML</title>
      <para>
        The signals provide a very iterative style of parsing XML, as
        your program has to deal with signals arriving serially. It's
        sometimes more convenient to deal with small XML documents
        directly in-memory as an OCaml data structure. It's easy to
        convert a signal stream into a tree, as follows:
      </para>
      <programlisting language="ocaml">
type tree = 
  | Element of Xmlm.tag * tree list
  | Data of string

let in_tree i = 
  let el tag children = Element (tag, children) in
  let data d = Data d in
  Xmlm.input_doc_tree ~el ~data i

let out_tree o t = 
  let frag = function
  | Element (tag, childs) -&gt; `El (tag, childs) 
  | Data d -&gt; `Data d 
  in
  Xmlm.output_doc_tree frag o t
</programlisting>
      <para>
        The type <literal>tree</literal> can be pattern-matched and
        traversed like a normal OCaml data structure. Let's see how this
        works by extracting out all the &quot;Related Topics&quot; in
        the example document. First, we'll need a few helper combinator
        functions to filter through tags and trees, with the following
        signature:
      </para>
      <programlisting language="ocaml">
(* Extract a textual name from an XML tag.
   Discards the namespace information. *)
val name : Xmlm.tag -&gt; string

(* Filter out the contents of a tag [n] from a tagset,
   and return the concatenated contents of all of them *)
val filter_tag : string -&gt; tree list -&gt; tree list

(* Given a list of [trees], concatenate all of the data contents               
   into a string, and discard any sub-tags within it *)
val concat_data : tree list -&gt; string
</programlisting>
      <para>
        The implementation of these functions traverses the
        <literal>tree</literal> type that we defined earlier.
      </para>
      <programlisting language="ocaml">
let name ((_,n),_) = n

let filter_tag n =
  List.fold_left ~init:[] ~f:(fun acc -&gt;
    function
    |Element (tag, ts) when name tag = n -&gt; ts @ acc
    |_ -&gt; acc
  )

let concat_data =
  List.fold_left ~init:&quot;&quot; ~f:(fun acc -&gt;
    function
    |Data s -&gt; acc ^ s
    |_ -&gt; acc                           
  )
</programlisting>
      <para>
        (<emphasis>avsm</emphasis>: have we explained
        <literal>fold_left</literal> before this section or does it need
        a full intro?)
      </para>
      <para>
        Notice the use of a <emphasis>guard pattern</emphasis> in the
        <literal>filter_tag</literal> pattern match. This looks for an
        <literal>Element</literal> tag that matches the name parameter,
        and concatenates the results with the accumulator list.
      </para>
      <para>
        Once we have these helper functions, the selection of all the
        <literal>&lt;Text&gt;</literal> tags is easy:
      </para>
      <programlisting language="ocaml">
let topics trees =
  filter_tag &quot;DuckDuckGoResponse&quot; trees |!
  filter_tag &quot;RelatedTopics&quot; |!
  filter_tag &quot;RelatedTopic&quot; |!
  filter_tag &quot;Text&quot; |!
  List.iter ~f:(fun x -&gt; concat_data [x] |! print_endline)

let _ =
  let i = Xmlm.make_input (`Channel (open_in &quot;ddg.xml&quot;)) in
  let (_,it) = in_tree i in
  topics [it]
</programlisting>
      <para>
        The <literal>filter_tag</literal> combinator accepts a
        <literal>tree list</literal> parameter and outputs a
        <literal>tree list</literal>. This lets us easily chain together
        the results of one filter to another, and hence select
        hierarchical XML tags very easily. When we get to the
        <literal>&lt;Text&gt;</literal> tag, we iterate over all the
        results and print each one individually.
      </para>
    </sect2>
    <sect2 id="using-the-cow-syntax-extension">
      <title>Using the COW syntax extension</title>
      <para>
        TODO: Explain how the p4 XML extension works. This is a good
        excuse.
      </para>
    </sect2>
    <sect2 id="working-with-xhtml">
      <title>Working with XHTML</title>
      <para>
        TODO
      </para>
    </sect2>
  </sect1>
  <sect1 id="serialization-with-s-expressions">
    <title>Serialization with s-expressions</title>
    <para>
      So far, we've talked about interoperating with formats that are
      usually defined by third-parties. It's also very common to just
      exchange and persist OCaml values safely, so we'll discuss how to
      do this now.
    </para>
    <para>
      S-expressions are nested paranthetical strings whose atomic values
      are strings.
    </para>
    <programlisting language="ocaml">
module Sexp : sig
  type t = Atom of string | List of t list
end
</programlisting>
    <para>
      An s-expression is in essence a nested parenthetical list whose
      atomic values are strings. The <literal>Sexp</literal> module
      comes with functionality for parsing and printing s-expressions.
    </para>
    <programlisting>
# let sexp =
    let a x = Sexp.Atom x and l x = Sexp.List x in
    l [a &quot;this&quot;;l [a &quot;is&quot;; a &quot;an&quot;]; l [a &quot;s&quot;; a &quot;expression&quot;]];;
val sexp : Sexp.t = (this (is an) (s expression))
</programlisting>
    <para>
      In addition, most of the base types in Core support conversion to
      and from s-expressions. For example, we can write:
    </para>
    <programlisting>
# Int.sexp_of_t 3;;
- : Sexp.t = 3
# List.sexp_of_t;;
- : ('a -&gt; Sexp.t) -&gt; 'a List.t -&gt; Sexp.t = &lt;fun&gt;
# List.sexp_of_t Int.sexp_of_t [1;2;3];;
- : Sexp.t = (1 2 3)
</programlisting>
    <para>
      Notice that <literal>List.sexp_of_t</literal> is polymorphic, and
      takes as its first argument another conversion function to handle
      the elements of the list to be converted. Core uses this scheme
      more generally for defining sexp-converters for polymorphic types.
    </para>
    <para>
      But what if you want a function to convert some brand new type to
      an s-expression? You can of course write it yourself:
    </para>
    <programlisting>
# type t = { foo: int; bar: float };;
# let sexp_of_t t =
    let a x = Sexp.Atom x and l x = Sexp.List x in
    l [ l [a &quot;foo&quot;; Int.sexp_of_t t.foo  ];
        l [a &quot;bar&quot;; Float.sexp_of_t t.bar]; ]
  ;;
val sexp_of_t : t -&gt; Core.Std.Sexp.t = &lt;fun&gt;
# sexp_of_t { foo = 3; bar = -5.5 };;
- : Core.Std.Sexp.t = ((foo 3) (bar -5.5))
</programlisting>
    <para>
      This is somewhat tiresome to write, and it gets more so when you
      consider the parser, <emphasis>i.e.</emphasis>,
      <literal>t_of_sexp</literal>, which is considerably more complex.
      Writing this kind of parsing and printing code by hand is
      mechanical and error prone, not to mention a drag.
    </para>
    <para>
      Given how mechanical the code is, you could imagine writing a
      program that inspected the type definition and auto-generated the
      conversion code for you. That is precisely where syntax extensions
      come in. Using Sexplib and adding <literal>with sexp</literal> as
      an annotation to our type definition, we get the functions we want
      for free.
    </para>
    <programlisting>
# type t = { foo: int; bar: float } with sexp;;
type t = { foo : int; bar : float; }
val t_of_sexp__ : Sexplib.Sexp.t -&gt; t = &lt;fun&gt;
val t_of_sexp : Sexplib.Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexplib.Sexp.t = &lt;fun&gt;
# t_of_sexp (Sexp.of_string &quot;((bar 35) (foo 3))&quot;);;
- : t = {foo = 3; bar = 35.}
</programlisting>
    <para>
      (You can ignore <literal>t_of_sexp__</literal>, which is a helper
      function that is needed in very rare cases.)
    </para>
    <para>
      The syntax-extensions in Core that we're going to discuss all have
      this same basic structure: they auto-generate code based on type
      definitions, implementing functionality that you could in theory
      have implemented by hand, but with far less programmer effort.
    </para>
    <para>
      There are several syntax extensions distributed with Core,
      including:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis role="strong">Sexplib</emphasis>: provides
          serialization for s-expressions.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Bin_prot</emphasis>: provides
          serialization to an efficient binary format.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Fieldslib</emphasis>: generates
          first-class values that represent fields of a record, as well
          as accessor functions and setters for mutable record fields.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Variantslib</emphasis>: like Fieldslib
          for variants, producing first-class variants and other helper
          functions for interacting with variant types.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Pa_compare</emphasis>: generates
          efficient, type-specialized comparison functions.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">Pa_typehash</emphasis>: generates a
          hash value for a type definition, <emphasis>i.e.</emphasis>,
          an integer that is highly unlikely to be the same for two
          distinct types.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We'll discuss each of these syntax extensions in detail, starting
      with Sexplib.
    </para>
  </sect1>
  <sect1 id="sexplib">
    <title>Sexplib</title>
    <sect2 id="formatting-of-s-expressions">
      <title>Formatting of s-expressions</title>
      <para>
        Sexplib's format for s-expressions is pretty straightforward: an
        s-expression is written down as a nested parenthetical
        expression, with whitespace-separated strings as the atoms.
        Quotes are used for atoms that contain parenthesis or spaces
        themselves, backslash is the escape character, and semicolons
        are used to introduce comments. Thus, if you create the
        following file:
      </para>
      <programlisting>
;; foo.scm

((foo 3.3) ;; Shall I compare thee  to a summer's dream?
 (bar &quot;this is () an \&quot; atom&quot;))
</programlisting>
      <para>
        we can load it up and print it back out again:
      </para>
      <programlisting>
# Sexp.load_sexp &quot;foo.scm&quot;;;
- : Sexp.t = ((foo 3.3) (bar &quot;this is () an \&quot; atom&quot;))
</programlisting>
      <para>
        Note that the comments were dropped from the file upon reading.
        This is expected, since there's no place in the
        <literal>Sexp.t</literal> type to store comments.
      </para>
      <para>
        If we introduce an error into our s-expression, by, say,
        deleting the open-paren in front of <literal>bar</literal>,
        we'll get a parse error:
      </para>
      <programlisting>
# Exn.handle_uncaught ~exit:false (fun () -&gt;
    ignore (Sexp.load_sexp &quot;foo.scm&quot;));;
  Uncaught exception:

  (Sexplib.Sexp.Parse_error
   ((location parse) (err_msg &quot;unexpected character: ')'&quot;) (text_line 4)
    (text_char 29) (global_offset 94) (buf_pos 94)))
</programlisting>
      <para>
        (In the above, we use <literal>Exn.handle_uncaught</literal> to
        make sure that the exception gets printed out in full detail.)
      </para>
    </sect2>
    <sect2 id="sexp-converters">
      <title>Sexp converters</title>
      <para>
        The most important functionality provided by Sexplib is the
        auto-generation of converters for new types. We've seen a bit of
        how this works already, but let's walk through a complete
        example. Here's the source for the beginning of a library for
        representing integer intervals.
      </para>
      <programlisting language="ocaml">
(* file: int_interval.ml *)
(* Module for representing closed integer intervals *)

open Core.Std

(* Invariant: For any Range (x,y), y &gt; x *)
type t = | Range of int * int
         | Empty
with sexp

let is_empty = function Empty -&gt; true | Range _ -&gt; false
let create x y = if x &gt; y then Empty else Range (x,y)
let contains i x = match i with
   | Empty -&gt; false
   | Range (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high
</programlisting>
      <para>
        We can now use this module as follows:
      </para>
      <programlisting language="ocaml">
(* file: test_interval.ml *)

open Core.Std

let intervals =
  let module I = Int_interval in
  [ I.create 3 4;
    I.create 5 4; (* should be empty *)
    I.create 2 3;
    I.create 1 6;
  ]

let () =
  intervals
  |! List.sexp_of_t Int_interval.sexp_of_t
  |! Sexp.to_string_hum
  |! print_endline
</programlisting>
      <para>
        But we're still missing something: we haven't created an
        <literal>mli</literal> for <literal>Int_interval</literal> yet.
        Note that we need to explicitly export the s-expression
        converters that were created within the ml. If we don't:
      </para>
      <programlisting language="ocaml">
(* file: int_interval.mli *)
(* Module for representing closed integer intervals *)

type t

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool
</programlisting>
      <para>
        then we'll get the following error:
      </para>
      <programlisting>
File &quot;test_interval.ml&quot;, line 15, characters 20-42:
Error: Unbound value Int_interval.sexp_of_t
Command exited with code 2.
</programlisting>
      <para>
        We could export the types by hand:
      </para>
      <programlisting language="ocaml">
type t
val sexp_of_t : Sexp.t -&gt; t
val t_of_sexp : t -&gt; Sexp.t
</programlisting>
      <para>
        But Sexplib has a shorthand for this as well, so that we can
        instead write simply:
      </para>
      <programlisting language="ocaml">
type t with sexp
</programlisting>
      <para>
        at which point <literal>test_interval.ml</literal> will compile
        again, and if we run it, we'll get the following output:
      </para>
      <programlisting>
$ ./test_interval.native
((Range 3 4) Empty (Range 2 3) (Range 1 6))
</programlisting>
      <sidebar> <title>
      Preserving invariants
      </title>
      <para>
        One easy mistake to make when dealing with sexp converters is to
        ignore the fact that those converters can violate the invariants
        of your code. For example, the <literal>Int_interval</literal>
        module depends for the correctness of the
        <literal>is_empty</literal> check on the fact that for any value
        <literal>Range (x,y)</literal>, <literal>y</literal> is greater
        than or equal to <literal>x</literal>. The
        <literal>create</literal> function preserves this invariant, but
        the <literal>t_of_sexp</literal> function does not.
      </para>
      <para>
        We can fix this problem by writing a custom sexp-converter, in
        this case, using the sexp-converter that we already have:
      </para>
      <programlisting language="ocaml">
type t = | Range of int * int
         | Empty
with sexp

let create x y = if x &gt; y then Empty else Range (x,y)

let t_of_sexp sexp =
  let t = t_of_sexp sexp in
  begin match t with
  | Range (x,y) when y &lt; x -&gt;
    of_sexp_error &quot;Upper and lower bound of Range swapped&quot; sexp
  | Empty | Range _ -&gt; ()
  end;
  t
</programlisting>
      <para>
        We call the function <literal>of_sexp_error</literal> to raise
        an exception because that improves the error reporting that
        Sexplib can provide when a conversion fails.
      </para>
      </sidebar>
    </sect2>
    <sect2 id="getting-good-error-messages">
      <title>Getting good error messages</title>
      <para>
        There are two steps to deserializing a type from an
        s-expression: first, converting the bytes in a file to an
        s-expression, and the second, converting that s-expression into
        the type in question. One problem with this is that it can be
        hard to localize errors to the right place using this scheme.
        Consider the following example:
      </para>
      <programlisting language="ocaml">
(* file: read_foo.ml *)

open Core.Std

type t = { a: string; b: int; c: float option } with sexp

let run () =
  let t =
    Sexp.load_sexp &quot;foo.scm&quot;
    |! t_of_sexp
  in
  printf &quot;b is: %d\n%!&quot; t.b

let () =
  Exn.handle_uncaught ~exit:true run
</programlisting>
      <para>
        If you were to run this on a malformatted file, say, this one:
      </para>
      <programlisting>
;; foo.scm
((a not-an-integer)
 (b not-an-integer)
 (c ()))
</programlisting>
      <para>
        you'll get the following error:
      </para>
      <programlisting>
read_foo $ ./read_foo.native
Uncaught exception:

  (Sexplib.Conv.Of_sexp_error
   (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;) not-an-integer)
</programlisting>
      <para>
        If all you have is the error message and the string, it's not
        terribly informative. In particular, you know that the parsing
        error-ed out on the atom &quot;not-an-integer&quot;, but you
        don't know which one! In a large file, this kind of bad error
        message can be pure misery.
      </para>
      <para>
        But there's hope! If we make small change to the
        <literal>run</literal> function as follows:
      </para>
      <programlisting language="ocaml">
let run () =
  let t = Sexp.load_sexp_conv_exn &quot;foo.scm&quot; t_of_sexp in
  printf &quot;b is: %d\n%!&quot; t.b
</programlisting>
      <para>
        and run it again, we'll get the following much more helpful
        error message:
      </para>
      <programlisting language="ocaml">
read_foo $ ./read_foo.native
Uncaught exception:

  (Sexplib.Conv.Of_sexp_error
   (Sexplib.Sexp.Annotated.Conv_exn foo.scm:3:4
    (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;))
   not-an-integer)
</programlisting>
      <para>
        In the above error, &quot;foo.scm:3:4&quot; tells us that the
        error occurred on &quot;foo.scm&quot;, line 3, character 4,
        which is a much better start for figuring out what has gone
        wrong.
      </para>
    </sect2>
    <sect2 id="sexp-conversion-directives">
      <title>Sexp-conversion directives</title>
      <para>
        Sexplib supports a collection of directives for modifying the
        default behavior of the auto-generated sexp-converters. These
        directives allow you to customize the way in which types are
        represented as s-expressions without having to write a custom
        parser. We describe these directives below.
      </para>
      <sect3 id="sexp-opaque">
        <title><literal>sexp-opaque</literal></title>
        <para>
          The most commonly used directive is
          <literal>sexp_opaque</literal>, whose purpose is to mark a
          given component of a type as being unconvertible. Anything
          marked with <literal>sexp_opaque</literal> will be presented
          as the atom <literal>&lt;opaque&gt;</literal> by the to-sexp
          converter, and will trigger an exception from the from-sexp
          converter. Note that the type of a component marked as opaque
          doesn't need to have a sexp-converter defined. Here, if we
          define a type without a sexp-converter, and then try to use it
          another type with a sexp-converter, we'll error out:
        </para>
        <programlisting>
# type no_converter = int * int;;
type no_converter = int * int
# type t = { a: no_converter; b: string } with sexp;;
Characters 14-26:
  type t = { a: no_converter; b: string } with sexp;;
                ^^^^^^^^^^^^
Error: Unbound value no_converter_of_sexp
</programlisting>
        <para>
          But with <literal>sexp_opaque</literal>, we won't:
        </para>
        <programlisting>
# type t = { a: no_converter sexp_opaque; b: string } with sexp;;
type t = { a : no_converter Core.Std.sexp_opaque; b : string; }
val t_of_sexp__ : Sexplib.Sexp.t -&gt; t = &lt;fun&gt;
val t_of_sexp : Sexplib.Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexplib.Sexp.t = &lt;fun&gt;
</programlisting>
        <para>
          And if we now convert a value of this type to an s-expression,
          we'll see the contents of field <literal>a</literal> marked as
          opaque:
        </para>
        <programlisting>
# sexp_of_t { a = (3,4); b = &quot;foo&quot; };;
- : Sexp.t = ((a &lt;opaque&gt;) (b foo))
</programlisting>
      </sect3>
      <sect3 id="sexp_option">
        <title><literal>sexp_option</literal></title>
        <para>
          Another common directive is <literal>sexp_opaque</literal>,
          which is used to make an optional field in a record. Ordinary
          optional values are represented either as
          <literal>()</literal> for <literal>None</literal>, or as
          <literal>(x)</literal> for <literal>Some x</literal>. If you
          put an option in a record field, then the record field will
          always be required, and its value will be presented in the way
          an ordinary optional value would. For example:
        </para>
        <programlisting>
# type t = { a: int option; b: string } with sexp;;
# sexp_of_t { a = None; b = &quot;hello&quot; };;
- : Sexp.t = ((a ()) (b hello))
# sexp_of_t { a = Some 3; b = &quot;hello&quot; };;
- : Sexp.t = ((a (3)) (b hello))
</programlisting>
        <para>
          But what if we want a field to be optional,
          <emphasis>i.e.</emphasis>, we want to allow it to be omitted
          from the record entirely? In that case, we can mark it with
          <literal>sexp_option</literal>:
        </para>
        <programlisting language="ocaml">
# type t = { a: int sexp_option; b: string } with sexp;;
# sexp_of_t { a = Some 3; b = &quot;hello&quot; };;
- : Sexp.t = ((a 3) (b hello))
# sexp_of_t { a = None; b = &quot;hello&quot; };;
- : Sexp.t = ((b hello))
</programlisting>
      </sect3>
      <sect3 id="sexp_list">
        <title><literal>sexp_list</literal></title>
        <para>
          One problem with the auto-generated sexp-converters is that
          they can have more parentheses than one would ideally like.
          Consider, for example, the following variant type:
        </para>
        <programlisting>
# type compatible_versions = | Specific of string list
                             | All
  with sexp;;
# sexp_of_compatible_versions (Specific [&quot;3.12.0&quot;; &quot;3.12.1&quot;; &quot;3.13.0&quot;]);;
- : Sexp.t = (Specific (3.12.0 3.12.1 3.13.0))
</programlisting>
        <para>
          You might prefer to make the syntax a bit less
          parenthesis-laden by dropping the parentheses around the list.
          <literal>sexp_list</literal> gives us this alternate syntax:
        </para>
        <programlisting>
# type compatible_versions = | Specific of string sexp_list
                             | All
  with sexp;;
# sexp_of_compatible_versions (Specific [&quot;3.12.0&quot;; &quot;3.12.1&quot;; &quot;3.13.0&quot;]);;
- : Sexp.t = (Specific 3.12.0 3.12.1 3.13.0)
</programlisting>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="bin_prot">
    <title>Bin_prot</title>
    <para>
      S-expressions are a good serialization format when you need
      something machine-parseable as well as human readable and
      editable. But Sexplib's s-expressions are not particularly
      performant. There are a number of reasons for this. For one thing,
      s-expression serialization goes through an intermediate type,
      <literal>Sexp.t</literal>, which must be allocated and is then
      typically thrown away, putting non-trivial pressure on the GC. In
      addition, parsing and printing to strings in an ASCII format can
      be expensive for types like <literal>int</literal>s,
      <literal>float</literal>s and <literal>Time.t</literal>s where
      some real computation needs to be done to produce or parse the
      ASCII representation.
    </para>
    <para>
      Bin_prot is a library designed to address these issues by
      providing fast serialization in a compact binary format. Kicking
      off the syntax extension is done by putting
      <literal>with bin_io</literal>. (This looks a bit unsightly in the
      top-level because of all the definitions that are generated. We'll
      elide those definitions here, but you can see it for yourself in
      the toplevel.)
    </para>
    <para>
      Here's a small complete example of a program that can read and
      write values using bin-io. Here, the serialization is of types
      that might be used as part of a message-queue, where each message
      has a topic, some content, and a source, which is in turn a
      hostname and a port.
    </para>
    <programlisting language="ocaml">
(* file: message_example.ml *)

open Core.Std

(* The type of a message *)
module Message = struct
  module Source = struct
    type t = { hostname: string;
               port: int;
             }
    with bin_io
  end

  type t = { topic: string;
             content: string;
             source: Source.t;
           }
  with bin_io
end

(* Create the 1st-class module providing the binability of messages *)
let binable = (module Message : Binable.S with type t = Message.t)

(* Saves a message to an output channel.  The message is serialized to
   a bigstring before being written out to the channel.  Also, a
   binary encoding of an integer is written out to tell the reader how
   long of a message to expect.  *)
let save_message outc msg =
  let s = Binable.to_bigstring binable msg in
  let len = Bigstring.length s in
  Out_channel.output_binary_int outc len;
  Bigstring.really_output outc s

(* Loading the message is done by first reading in the length, and by
   then reading in the appropriate number of bytes into a Bigstring
   created for that purpose. *)
let load_message inc =
  match In_channel.input_binary_int inc with
  | None -&gt; failwith &quot;Couldn't load message: length missing from header&quot;
  | Some len -&gt;
    let buf = Bigstring.create len in
    Bigstring.really_input ~pos:0 ~len inc buf;
    Binable.of_bigstring binable buf

(* To generate some example messages *)
let example content =
  let source =
    { Message.Source.
      hostname = &quot;ocaml.org&quot;; port = 2322 }
  in
  { Message.
    topic = &quot;rwo-example&quot;; content; source; }

(* write out three messages... *)
let write_messages () =
  let outc = Out_channel.create &quot;tmp.bin&quot; in
  List.iter ~f:(save_message outc) [
    example &quot;a wonderful&quot;;
    example &quot;trio&quot;;
    example &quot;of messages&quot;;
  ];
  Out_channel.close outc

(* ... and read them back in *)
let read_messages () =
  let inc = In_channel.create &quot;tmp.bin&quot; in
  for i = 1 to 3 do
    let msg = load_message inc in
    printf &quot;msg %d: %s\n&quot; i msg.Message.content
  done

let () =
  write_messages (); read_messages ()
</programlisting>
  </sect1>
  <sect1 id="fieldslib">
    <title>Fieldslib</title>
    <para>
      One common idiom when using records is to provide field accessor
      functions for a particular record.
    </para>
    <programlisting>
type t = { topic: string;
           content: string;
           source: Source.t;
         }

let topic   t = t.topic
let content t = t.content
let source  t = t.source
</programlisting>
    <para>
      Similarly, sometimes you simultaneously want an accessor to a
      field of a record and a textual representation of the name of that
      field. This might come up if you were validating a field and
      needed the string representation to generate an error message, or
      if you wanted to scaffold a form in a GUI automatically based on
      the fields of a record. Fieldslib provides a module
      <literal>Field</literal> for this purpose. Here's some code for
      creating <literal>Field.t</literal>'s for all the fields of our
      type <literal>t</literal>.
    </para>
    <programlisting language="ocaml">
# module Fields = struct
    let topic =
      { Field.
        name   = &quot;topic&quot;;
        setter = None;
        getter = (fun t -&gt; t.topic);
        fset   = (fun t topic -&gt; { t with topic });
      }
    let content =
      { Field.
        name   = &quot;content&quot;;
        setter = None;
        getter = (fun t -&gt; t.content);
        fset   = (fun t content -&gt; { t with content });
      }
    let source =
      { Field.
        name   = &quot;source&quot;;
        setter = None;
        getter = (fun t -&gt; t.source);
        fset   = (fun t source -&gt; { t with source });
      }
  end ;;
module Fields :
  sig
    val topic : (t, string list) Core.Std.Field.t
    val content : (t, string) Core.Std.Field.t
    val source : (t, Source.t) Core.Std.Field.t
  end
</programlisting>
  </sect1>
</chapter>
<chapter id="concurrent-programming-with-async">
  <title>Concurrent Programming with Async</title>
  <para>
    When you start building OCaml code that interfaces with external
    systems, you'll soon need to handle concurrent operations. Consider
    the case of a web server sending a large file to many clients, or a
    GUI waiting for a mouse clicks. These applications often need to
    block while waiting for input for a particular task, and process
    something else during that time. Meanwhile, when new data does
    appear, the blocked task needs to be resumed as quickly as possible.
  </para>
  <para>
    Efficiency really matters here, as busy servers can often handle
    tens of thousands of simultaneous connections. An equally important
    concern is readable source code, where the control flow of the
    program is obvious at a glance.
  </para>
  <para>
    You've probably used preemptive system threads before in some
    programming languages such as Java or C#. In this model, each task
    is usually given an operating system thread of its own. Other
    languages such as Javascript are single-threaded, and applications
    must register function callbacks to be triggered upon external
    events (such as a timeout or browser click).
  </para>
  <para>
    Both of these mechanisms have tradeoffs. Preemptive threads require
    their own memory stacks and can be memory hungry. The operating
    system can also arbitrarily interleave the execution of threads, and
    so they require careful locking around shared data structures.
  </para>
  <para>
    Event-driven systems usually only execute a single task at a time
    and require less locking. However, the program structure can often
    descend into a maze of event callbacks for even a simple operation
    that blocks a few times. Code readability matters, and so we'd like
    to avoid such spaghetti control flow.
  </para>
  <para>
    The <literal>Async</literal> OCaml library offers a hybrid model
    that lets you write event-driven code that can block
    <emphasis>without</emphasis> the complexity of preemptive threading.
    Let's dive straight into an example to see what this looks like, and
    then explain some of the new concepts. We're going to search for
    definitions of English terms using the DuckDuckGo search engine.
  </para>
  <sect1 id="example-searching-definitions-with-duckduckgo">
    <title>Example: searching definitions with DuckDuckGo</title>
    <para>
      DuckDuckGo is a search engine with a freely available search
      interface. A DuckDuckGo search is executed by making an HTTP
      request to <literal>api.duckduckgo.com</literal>. The result comes
      back in either JSON or XML format, depending on what was requested
      in the original query string. Let's write some functions that
      construct the right URI and can parse the resulting JSON.
    </para>
    <para>
      Before we can make the HTTP calls, we need a couple of helper
      functions with the following signature.
    </para>
    <programlisting language="ocaml">
(* Generate a DuckDuckGo API search URI for [query] *)
val make_ddg_uri : query:string -&gt; Uri.t

(* Extract the Definition field from the DuckDuckGo search
   response, or return [None] if it doesn't exist *)
val get_definition_from_json: string -&gt; string option
</programlisting>
    <para>
      This code uses a couple of new libraries we haven't seen before.
      You will need to OPAM install <literal>uri</literal> and
      <literal>yojson</literal> (refer to chapter {{{installation}}} if
      you need help). Let's see how to implement them first.
    </para>
    <sect2 id="uri-handling">
      <title>URI handling</title>
      <para>
        You're hopefully familiar with HTTP URLs, which identify
        endpoints across the World Wide Web. These are actually part of
        a more general family known as Uniform Resource Identifiers
        (URIs). The full URI specification is defined in
        <ulink url="http://tools.ietf.org/html/rfc3986">RFC3986</ulink>
        (and is rather complicated!). Luckily, the
        <literal>ocaml-uri</literal> library provides a strongly-typed
        interface which takes care of much of the hassle.
      </para>
      <programlisting language="ocaml">
(* Generate a DuckDuckGo search URI from a query string *)
let make_ddg_uri =
  let base_uri = &quot;http://api.duckduckgo.com/?format=json&quot; in
  let uri = Uri.of_string base_uri in
  fun ~query -&gt;
    Uri.add_query_param uri (&quot;q&quot;, [query])
</programlisting>
      <para>
        A <literal>Uri.t</literal> is constructed from the
        <literal>Uri.of_string</literal> function, and a query parameter
        <literal>q</literal> is added with the desired search query. The
        library takes care of encoding the URI correctly when outputting
        it in the network protocol.
      </para>
      <para>
        Note that the URI manipulation functions are all
        <emphasis>pure</emphasis> functions which return a new URI
        value, and never modify the input. This makes it easier to pass
        around URI values through your application stack without fear of
        modification.
      </para>
    </sect2>
    <sect2 id="parsing-json-strings">
      <title>Parsing JSON strings</title>
      <para>
        The HTTP response from DuckDuckGo is in JSON, a common (and
        thankfully simple) format that is specified in
        <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</ulink>.
        There are quite a few JSON parsers available for OCaml, and
        we've picked
        <ulink url="http://mjambon.com/yojson.html"><literal>Yojson</literal></ulink>
        for this example.
      </para>
      <para>
        There are a few non-standard extensions to JSON, so Yojson
        exposes them as the <literal>Basic</literal> and
        <literal>Safe</literal> sub-modules. It doesn't really matter
        which one we pick for this simple example, so we'll go with
        <literal>Safe</literal>.
      </para>
      <para>
        The input <literal>string</literal> is parsed using
        <literal>Yojson.Safe.from_string</literal> into an OCaml data
        type. The JSON values are represented using polymorphic
        variants, and can thus be pattern matched more easily once they
        have been parsed by Yojson.
      </para>
      <programlisting language="ocaml">
type json = [
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Int of int
  | `List of json list
  | `Null
  | `String of string
  | `Tuple of json list
]
</programlisting>
      <para>
        We're expecting the DuckDuckGo response to be a record, with an
        optional <literal>Description</literal> field being one of the
        keys in the record. The
        <literal>get_definition_from_json</literal> does a pattern match
        on this, and returns an optional string if a definition is found
        within the result.
      </para>
      <programlisting language="ocaml">
(* Extract the Definition field from the DuckDuckGo search
   response, or return [None] if it doesn't exist *)
let get_definition_from_json (json:string) =
  match Yojson.Safe.from_string json with
  |`Assoc kv_list -&gt;
      let open Option in
      List.Assoc.find kv_list &quot;Definition&quot; &gt;&gt;|
      Yojson.Safe.to_string
  |_ -&gt; None
</programlisting>
      <para>
        Notice that we use options here instead of throwing exceptions
        on an error. When the <literal>Option</literal> module is
        opened, it provides a <literal>map</literal> operator
        (<literal>&gt;&gt;|</literal>) which calls the bound closure if
        the value exists. If no result is found, then the
        <literal>Yojson.Safe.to_string</literal> conversion function is
        simply ignored, and a <literal>None</literal> returned.
      </para>
    </sect2>
    <sect2 id="executing-an-http-client-query">
      <title>Executing an HTTP client query</title>
      <para>
        Now that we've written those utility functions, let's look at
        the Async code that performs the actual search:
      </para>
      <programlisting language="ocaml">
(* Execute the DuckDuckGo search *)
(* TODO: This client API is being simplified in Cohttp *)
let do_ddg_query query =
  Cohttp_async.Client.call `GET (make_ddg_uri ~query)
  &gt;&gt;= function
  | Some (res, Some body) -&gt;
      let buf = Buffer.create 128 in
      Pipe.iter_without_pushback body ~f:(Buffer.add_string buf)
      &gt;&gt;| fun () -&gt;
      get_definition_from_json (Buffer.contents buf) |!
      Option.value ~default:&quot;???&quot;
  | Some (_, None) | None -&gt;
      failwith &quot;no body in response&quot;
</programlisting>
      <para>
        For this code, you'll need to OPAM install the
        <literal>cohttp</literal> library. The
        <literal>Cohttp_async.Client</literal> module executes the HTTP
        call, and returns a status and response body wrapped. This whole
        result is wrapped in a type you haven't seen before:
        <literal>Async.Deferred.t</literal>.
      </para>
      <para>
        The <literal>Deferred.t</literal> represents a
        <emphasis>future</emphasis> value whose result is not available
        yet. You can &quot;wait&quot; for the result by binding a
        callback using the <literal>&gt;&gt;=</literal> operator (which
        is imported when you open <literal>Async.Std</literal>). This is
        the same monad pattern available in other Core libraries such as
        <literal>Option</literal>, but instead of operating on optional
        values, we are now mapping over future values. We'll come back
        to monads later in this chapter. (<emphasis>avsm</emphasis>:
        TODO xref)
      </para>
      <para>
        The <literal>ddg_query</literal> function invokes the HTTP
        client call, and returns a tuple containing the response codes
        and headers, and a <literal>string Pipe.Reader</literal>. Pipes
        in Async are often used to transmit large amounts of data
        between two processes or concurrent threads. The
        <literal>Cohttp</literal> library creates a
        <literal>Pipe.Writer</literal> which it outputs the HTTP body
        into, and provides your application with the
        <literal>Reader</literal> end.
      </para>
      <para>
        In this case, the HTTP body probably isn't very large, so we
        just iterate over the Pipe's contents until we have the full
        HTTP body in a <literal>Buffer.t</literal>. Once the full body
        has been retrieved into our buffer, the next callback passes it
        through the JSON parser and returns a human-readable string of
        the search description that DuckDuckGo gave us.
      </para>
      <programlisting language="ocaml">
(* Run a single search *)
let run_one_search =
  do_ddg_query &quot;Camel&quot; &gt;&gt;| prerr_endline

(* Start the Async scheduler *)
let _ = Scheduler.go ()
</programlisting>
      <para>
        Let's actually use the search function to run a real query now.
        The fragment above spawns a single search, and then fires up the
        Async scheduler. The scheduler is where all the work happens,
        and must be started in every application that uses Async.
        Without it, logging won't be output, nor will blocked functions
        ever wake up. When the scheduler is active, it is waiting for
        incoming I/O events and waking up function callbacks that were
        sleeping on that particular file descriptor or timeout.
      </para>
      <para>
        A single connection isn't that interesting from a concurrency
        perspective. Luckily, Async makes it very easy to run multiple
        parallel searches:
      </para>
      <programlisting language="ocaml">
(* Run many searches in parallel *)
let run_many_searches =
  let searches = [&quot;Duck&quot;; &quot;Sheep&quot;; &quot;Cow&quot;; &quot;Llama&quot;; &quot;Camel&quot;] in
  Deferred.List.map ~how:`Parallel searches ~f:do_ddg_query &gt;&gt;|
  List.iter ~f:print_endline
</programlisting>
      <para>
        The <literal>Deferred.List</literal> module lets you specify
        exactly how to map over a collection of futures. The searches
        will be executed simultaneously, and the map thread will
        complete once all of the sub-threads are complete. If you
        replace the <literal>Parallel</literal> parameter with
        <literal>Serial</literal>, the map will wait for each search to
        fully complete before issuing the next one.
      </para>
      <note>
      <title>
      Terminating Async applications
      </title>
      <para>
        When you run the search example, you'll notice that the
        application doesn't terminate even when all of the searches are
        complete. The Async scheduler doesn't terminate by default, and
        so most applications will listen for a signal to exit or simply
        use <literal>CTRL-C</literal> to interrupt it from a console.
      </para>
      <para>
        Another alternative is to run an Async function in a separate
        system thread. You can do this by wrapping the function in the
        <literal>Async.Thread_safe.block_on_async_exn</literal>. The
        <literal>utop</literal> top-level does this automatically for
        you if you attempt to evaluate an Async function interactively.
      </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="manipulating-async-threads">
    <title>Manipulating Async threads</title>
    <para>
      Now that we've seen the search example above, let's examine how
      Async works in more detail.
    </para>
    <para>
      Async threads are co-operative and never preempt each other, and
      the library internally converts blocking code into a single event
      loop. The threads are normal OCaml heap-allocated values (without
      any runtime magic!) and are therefore very fast to allocate.
      Concurrency is mostly limited only by your available main memory,
      or operating system limits on non-memory resources such as file
      descriptors.
    </para>
    <para>
      Lets begin by constructing a simple thread. Async follows the Core
      convention and provides an <literal>Async.Std</literal> that
      provides threaded variants of many standard library functions. The
      examples throughout this chapter assume that
      <literal>Async.Std</literal> is open in your environment.
    </para>
    <programlisting>
# require &quot;async.unix&quot; ;;
# open Async.Std ;;
# return 5 ;;
- : int Deferred.t = &lt;abstr&gt;
</programlisting>
    <para>
      The basic type of an Async thread is a
      <literal>Deferred.t</literal>, which can be constructed by the
      <literal>return</literal> function. The type parameter (in this
      case <literal>int</literal>) represents the ultimate type of the
      thread once it has completed in the future. This return value
      cannot be used directly while it is wrapped in a
      <literal>Deferred.t</literal> as it may not be available yet.
      Instead, we <literal>bind</literal> a function closure that is
      called once the value is eventually ready.
    </para>
    <programlisting>
# let x = return 5 ;;
val x : int Deferred.t = &lt;abstr&gt;
# let y = Deferred.bind x (fun a -&gt; return (string_of_int a)) ;;
val y : string Deferred.t = &lt;abstr&gt;
</programlisting>
    <para>
      Here, we've bound a function to <literal>x</literal> that will
      convert the <literal>int</literal> to a <literal>string</literal>.
      Notice that while both <literal>x</literal> and
      <literal>y</literal> share a common <literal>Deferred.t</literal>
      type, their type variables differ and so they cannot be
      interchangably used except in polymorphic functions. This is
      useful when refactoring large codebases, as you can tell if any
      function will block simply by the presence of an
      <literal>Deferred.t</literal> in the signature.
    </para>
    <para>
      Let's examine the function signatures of <literal>bind</literal>
      and <literal>return</literal> more closely.
    </para>
    <programlisting>
# return ;;
- : 'a -&gt; 'a Deferred.t = &lt;fun&gt;
# Deferred.bind ;;
- : 'a Deferred.t -&gt; ('a -&gt; 'b Deferred.t) -&gt; 'b Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      <literal>return</literal>, <literal>bind</literal> and the
      <literal>Deferred.t</literal> type all contain polymorphic type
      variables (the <literal>'a</literal>) which represent the type of
      the thread, and are inferred based on how they are used in your
      code. The <literal>'a</literal> type of the argument passed to the
      <literal>bind</literal> callback <emphasis>must</emphasis> be the
      same as the <literal>'a Deferred.t</literal> of the input thread,
      preventing runtime mismatches between thread callbacks. Both
      <literal>bind</literal> and <literal>return</literal> form a
      design pattern in functional programming known as
      <emphasis>monads</emphasis>, and you will run across this
      signature in many applications beyond just threads.
    </para>
    <para>
      _(avsm: do we talk about Monads earlier in the Core chapter? I
      presume we do, since the Option monad is very useful)
    </para>
    <para>
      Binding callbacks is to deferred values is the most common way to
      compose blocking operations, and inline operators are provided to
      make it easier to use. In the fragment below, we see
      <literal>&gt;&gt;=</literal> and <literal>&gt;&gt;|</literal> used
      in similar ways to convert an integer into a string:
    </para>
    <programlisting>
# let x = return 5 ;;
val x : int Deferred.t = &lt;abstr&gt;
# x &gt;&gt;= fun y -&gt; return (string_of_int y) ;;
val - : string Deferred.t = &lt;abstr&gt;
# x &gt;&gt;| string_of_int ;;
val - : string Deferred.t = &lt;abstr&gt;
</programlisting>
    <para>
      The <literal>&gt;&gt;=</literal> operator is exactly the same as
      <literal>bind</literal> and unpacks the integer future into the
      <literal>y</literal> variable. The subsequent closure receives the
      unpacked integer and builds a new string future. It can be a
      little verbose to keep calling <literal>bind</literal> and
      <literal>return</literal>, and so the <literal>&gt;&gt;|</literal>
      operator maps a non-Async function across a future value. In the
      second example, the future value of <literal>x</literal> is mapped
      to <literal>string_of_int</literal> directly, and the result is a
      <literal>string</literal> future.
    </para>
    <para>
      Async threads can be evaluated from the toplevel by wrapping them
      in <literal>Thread_safe.block_on_async_exn</literal>, which spawns
      a system thread that waits until a result is available. The
      <literal>utop</literal> top-level automatically detects
      <literal>Deferred.t</literal> types that are entered interactively
      and wraps them in this function for you automatically.
    </para>
    <programlisting>
# let fn () = return 5 &gt;&gt;| string_of_int ;;
val fn : unit -&gt; string Deferred.t = &lt;abstr&gt;
# Thread_safe.block_on_async_exn fn ;;
- : string = &quot;5&quot;
# fn () ;;
- : string = &quot;5&quot;
</programlisting>
    <para>
      In the second evaluation of <literal>fn</literal>, the top-level
      detected the return type of a future and evaluated the result into
      a concrete string.
    </para>
    <para>
      (<emphasis>avsm</emphasis>: this utop feature not actually
      implemented yet for Async, but works for Lwt)
    </para>
  </sect1>
  <sect1 id="timing-and-thread-composition">
    <title>Timing and Thread Composition</title>
    <para>
      Our examples so far have been with static threads, and now we'll
      look at how to coordinate multiple threads and timeouts. Let's
      write a program that spawns two threads, each of which sleep for
      some random time and return either &quot;Heads&quot; or
      &quot;Tails&quot;, and the quickest thread returns its value.
    </para>
    <programlisting>
# let flip () =
  let span = Time.Span.of_sec 3.0 in
  let span_heads = Time.Span.randomize span ~percent:0.75 in
  let span_tails = Time.Span.randomize span ~percent:0.75 in
  let coin_heads =
    Clock.after span_heads
    &gt;&gt;| fun () -&gt;
    &quot;Heads!&quot;, span_heads, span_tails
  in
  let coin_tails =
    Clock.after span_tails
    &gt;&gt;| fun () -&gt;
    &quot;Tails!&quot;, span_heads, span_tails
  in
  Deferred.any [coin_heads; coin_tails] ;;
val flip : unit -&gt; (string * Time.Span.t * Time.Span.t) Deferred.t = &lt;fun&gt;
</programlisting>
    <para>
      This introduces a couple of new time-related Async functions. The
      <literal>Time</literal> module contains functions to express both
      absolute and relative temporal relationships. In our coin flipping
      example, we create a relative time span of 3 seconds, and then
      permute it randomly twice by 75%. We then create two threads,
      <literal>coin_heads</literal> and <literal>coin_tails</literal>
      which return after their respective intervals. Finally,
      <literal>Deferred.any</literal> waits for the first thread which
      completes and returns its value, ignoring the remaining
      undetermined threads.
    </para>
    <para>
      Both of the threads encode the time intervals in their return
      value so that you can can easily verify the calculations (you
      could also simply print the time spans to the console as they are
      calculated and simplify the return types). You can see this by
      executing the <literal>flip</literal> function at the toplevel a
      few times.
    </para>
    <programlisting>
# Thread_safe.block_on_async_exn flip ;;
# - : string * Time.Span.t * Time.Span.t = (&quot;Heads!&quot;, 2.86113s, 3.64635s) 
# Thread_safe.block_on_async_exn flip ;;
# - : string * Time.Span.t * Time.Span.t = (&quot;Tails!&quot;, 4.44979s, 2.14977s)
</programlisting>
    <para>
      The <literal>Deferred</literal> module has a number of other ways
      to select between multiple threads, such as:
    </para>
    <informaltable>
      <tgroup cols="3">
        <colspec align="left" />
        <colspec align="left" />
        <colspec align="left" />
        <thead>
          <row>
            <entry>
              Function
            </entry>
            <entry>
              # Threads
            </entry>
            <entry>
              Behaviour
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              both
            </entry>
            <entry>
              2
            </entry>
            <entry>
              Combines both threads into a tuple and returns both
              values.
            </entry>
          </row>
          <row>
            <entry>
              any
            </entry>
            <entry>
              list
            </entry>
            <entry>
              Returns the first thread that becomes determined.
            </entry>
          </row>
          <row>
            <entry>
              all
            </entry>
            <entry>
              list
            </entry>
            <entry>
              Waits for all threads to complete and returns their
              values.
            </entry>
          </row>
          <row>
            <entry>
              all_unit
            </entry>
            <entry>
              list
            </entry>
            <entry>
              Waits for all <literal>unit</literal> threads to complete
              and returns <literal>unit</literal>.
            </entry>
          </row>
          <row>
            <entry>
              peek
            </entry>
            <entry>
              1
            </entry>
            <entry>
              Inspects a single thread to see if it is determined yet.
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      Try modifying the <literal>Deferred.any</literal> in the above
      example to use some of the other thread joining functions above,
      such as <literal>Deferred.both</literal>.
    </para>
    <sect2 id="cancellation">
      <title>Cancellation</title>
      <para>
      </para>
    </sect2>
  </sect1>
  <sect1 id="a-simple-tcp-echo-server">
    <title>A simple TCP Echo Server</title>
    <para>
    </para>
  </sect1>
  <sect1 id="onto-an-http-server">
    <title>Onto an HTTP Server</title>
    <para>
    </para>
  </sect1>
  <sect1 id="binding-to-the-github-api">
    <title>Binding to the Github API</title>
    <para>
      Show how we can use a monadic style to bind to the Github API and
      make simple JSON requests/responses.
    </para>
    <sidebar><title>
    A Note on Portability
    </title>
    <para>
      Explain libev and why its needed here.
    </para>
    </sidebar>


  </sect1>
</chapter>
<chapter id="object-oriented-programming">
  <title>Object Oriented Programming</title>
  <para>
    <emphasis>(yminsky: If we don't feel like these are
    &quot;great&quot; tools, maybe we shouldn't say it!)</emphasis>
  </para>
  <para>
    <emphasis>(yminsky: I wonder if it's worth emphasizing what makes
    objects unique early on. I think of them as no better of an
    encapsulation tool than closures. What makes them unique in my mind
    is that they are some combination of lighter weight and more dynamic
    than the alternatives (modules, records of closures,
    etc.))</emphasis>
  </para>
  <para>
    <emphasis>(yminsky: I'm not sure where we should say it, but OCaml's
    object system is strikingly different from those that most people
    are used to. It would be nice if we could call those differences out
    clearly somewhere. The main difference I see is the fact that
    subtyping and inheritance are not tied together, and that subtyping
    is structural.)</emphasis>
  </para>
  <para>
    We've already seen several tools that OCaml provides for organizing
    programs, particularly first-class modules. In addition, OCaml also
    supports object-oriented programming. There are objects, classes,
    and their associated types. Objects are good for encapsulation and
    abstraction, and classes are good for code re-use.
  </para>
  <sect1 id="when-to-use-objects">
    <title>When to use objects</title>
    <para>
      You might wonder when to use objects. First-class modules are more
      expressive (a module can include types, classes and objects
      cannot), and modules, functors, and algebraic data types offer a
      wide range of ways to express program structure. In fact, many
      seasoned OCaml programmers rarely use classes and objects, if at
      all.
    </para>
    <para>
      What exactly is object-oriented programming? Mitchell [6] points
      out four fundamental properties.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis>Abstraction</emphasis>: the details of the
          implementation are hidden in the object; the interface is just
          the set of publically-accessible methods.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Subtyping</emphasis>: if an object
          <literal>a</literal> has all the functionality of an object
          <literal>b</literal>, then we may use <literal>a</literal> in
          any context where <literal>b</literal> is expected.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Dynamic lookup</emphasis>: when a message is sent to
          an object, the method to be executed is determined by the
          implementation of the object, not by some static property of
          the program. In other words, different objects may react to
          the same message in different ways.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Inheritance</emphasis>: the definition of one kind
          of object can be re-used to produce a new kind of object.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Modules already provide these features in some form, but the main
      focus of classes is on code re-use through inheritance and late
      binding of methods. This is a critical property of classes: the
      methods that implement an object are determined when the object is
      instantiated, a form of <emphasis>dynamic</emphasis> binding. In
      the meantime, while classes are being defined, it is possible (and
      necessary) to refer to methods without knowing statically how they
      will be implemented.
    </para>
    <para>
      In contrast, modules use static (lexical) scoping. If you want to
      parameterize your module code so that some part of it can be
      implemented later, you would write a function/functor. This is
      more explicit, but often more verbose than overriding a method in
      a class.
    </para>
    <para>
      In general, a rule of thumb might be: use classes and objects in
      situations where dynamic binding is a big win, for example if you
      have many similar variations in the implementation of a concept.
      Real world examples are fairly rare, but one good example is
      Xavier Leroy's
      <ulink url="http://gallium.inria.fr/~xleroy/software.html#cryptokit">Cryptokit</ulink>,
      which provides a variety of cryptographic primitives that can be
      combined in building-block style.
    </para>
  </sect1>
  <sect1 id="ocaml-objects">
    <title>OCaml objects</title>
    <para>
      If you already know about object oriented programming in a
      language like Java or C++, the OCaml object system may come as a
      surprise. Foremost is the complete separation of subtyping and
      inheritance in OCaml. In a language like Java, a class name is
      also used as the type of objects created by instantiating it, and
      the subtyping rule corresponds to inheritance. For example. if we
      implement a class <literal>Stack</literal> in Java by inheriting
      from a class <literal>Deque</literal>, we would be allowed to pass
      a stack anywhere a deque is expected (this is a silly example of
      course, practitioners will point out that we shouldn't do it).
    </para>
    <para>
      OCaml is entirely different. Classes are used to construct objects
      and support inheritance, including non-subtyping inheritance.
      Classes are not types. Instead, objects have <emphasis>object
      types</emphasis>, and if you want to use objects, you aren't
      required to use classes at all. Here is an example of a simple
      object.
    </para>
    <programlisting language="ocaml">
# let p =
  object
    val mutable x = 0
    method get = x
    method set i = x &lt;- i
  end;;
val p : &lt; get : int; set : int -&gt; unit &gt; = &lt;obj&gt;
</programlisting>
    <para>
      The object has an integer value <literal>x</literal>, a method
      <literal>get</literal> that returns x, and a method
      <literal>set</literal> that updates the value of x.
    </para>
    <para>
      The object type is enclosed in angle brackets
      <literal>&lt; ... &gt;</literal>, containing just the types of the
      methods. Fields, like x, are not part of the public interface of
      an object. All interaction with an object is through its methods.
      The syntax for a method invocation (also called &quot;sending a
      message&quot; to the object) uses the <literal>#</literal>
      character.
    </para>
    <programlisting language="ocaml">
# p#get;
- : int = 0
# p#set 17;;
- : unit = ()
# p#get;;
- : int = 17
</programlisting>
    <para>
      Objects can also be constructed by functions. If we want to
      specify the initial value of the object, we can define a function
      that takes the initial value and produces an object.
    </para>
    <programlisting language="ocaml">
# let make i =
  object
    val mutable x = i
    method get = x
    method set y = x &lt;- y
  end;;
val make : 'a -&gt; &lt; get : 'a; set : 'a -&gt; unit &gt; = &lt;fun&gt;
# let p = make 5;;
val p : &lt; get : int; set : int -&gt; unit &gt; = &lt;obj&gt;
# p#get;;
- : int = 5
</programlisting>
    <para>
      Note that the types of the function <literal>make</literal> and
      the returned object now use the polymorphic type
      <literal>'a</literal>. When make is invoked on a concrete value
      <literal>5</literal>, we get the same object type as before, with
      type <literal>int</literal> for the value.
    </para>
  </sect1>
  <sect1 id="object-polymorphism">
    <title>Object Polymorphism</title>
    <para>
      <emphasis>(yminsky: Maybe this is a good time to talk about the
      nature of object subtyping?)</emphasis>
    </para>
    <para>
      Functions can also take object arguments. Let's construct a new
      object <literal>average</literal> that's the average of any two
      objects with a <literal>get</literal> method.
    </para>
    <programlisting language="ocaml">
# let average p1 p2 =
  object
    method get = (p1#get + p2#get) / 2
  end;;
val average : &lt; get : int; .. &gt; -&gt; &lt; get : int; .. &gt; -&gt; &lt; get : int &gt; = &lt;fun&gt;
# let p1 = make 5;;
# let p2 = make 15;;
# let a = average p1 p2;;
# a#get;;
- : int = 10
# p2#set 25;;
# a#get;;
- : int = 15
</programlisting>
    <para>
      Note that the type for <literal>average</literal> uses the object
      type <literal>&lt; get : int; .. &gt;</literal>. The
      <literal>..</literal> are ellipsis, standing for any other
      methods. The type <literal>&lt; get : int; .. &gt;</literal>
      specifies an object that must have at least a
      <literal>get</literal> method, and possibly some others as well.
      If we try using the exact type
      <literal>&lt; get : int &gt;</literal> for an object with more
      methods, type inference will fail.
    </para>
    <programlisting language="ocaml">
# let (p : &lt; get : int &gt;) = make 5;;
Error: This expression has type &lt; get : int; set : int -&gt; unit &gt;
       but an expression was expected of type &lt; get : int &gt;
       The second object type has no method set
</programlisting>
    <sidebar>
    <title>
    Elisions are polymorphic
    </title>
    <para>
      The <literal>..</literal> in an object type is an elision,
      standing for &quot;possibly more methods.&quot; It may not be
      apparent from the syntax, but an elided object type is actually
      polymorphic. If we try to write a type definition, we get an
      obscure error.
    </para>
    <programlisting language="ocaml">
# type point = &lt; get:int; .. &gt;;;
Error: A type variable is unbound in this type declaration.
In type &lt; get : int; .. &gt; as 'a the variable 'a is unbound
</programlisting>
    <para>
      A <literal>..</literal> in an object type is called a
      <emphasis>row variable</emphasis> and this typing scheme is called
      <emphasis>row polymorphism</emphasis>. Even though
      <literal>..</literal> doesn't look like a type variable, it
      actually is. The error message suggests a solution, which is to
      add the <literal>as 'a</literal> type constraint.
    </para>
    <programlisting language="ocaml">
# type 'a point = &lt; get:int; .. &gt; as 'a;;
type 'a point = 'a constraint 'a = &lt; get : int; .. &gt;
</programlisting>
    <para>
      In other words, the type <literal>'a point</literal> is equal to
      <literal>'a</literal>, where
      <literal>'a = &lt; get : int; .. &gt;</literal>. That may seem
      like an odd way to say it, and in fact, this type definition is
      not really an abbreviation because <literal>'a</literal> refers to
      the entire type.
    </para>
    </sidebar>
    <para>
      An object of type <literal>&lt; get:int; .. &gt;</literal> can be
      any object with a method <literal>get:int</literal>, it doesn't
      matter how it is implemented. So far, we've constructed two
      objects with that type; the function <literal>make</literal>
      constructed one, and so did <literal>average</literal>. When the
      method <literal>#get</literal> is invoked, the actual method that
      is run is determined by the object.
    </para>
    <programlisting language="ocaml">
# let print_point p = Printf.printf &quot;Point: %d\n&quot; p#get;;
val print_point : &lt; get : int; .. &gt; -&gt; unit = &lt;fun&gt;
# print_point (make 5);;
Point: 5
# print_point (average (make 5) (make 15));;
Point: 10
</programlisting>
  </sect1>
  <sect1 id="classes">
    <title>Classes</title>
    <para>
      Programming with objects directly is great for encapsulation, but
      one of the main goals of object-oriented programming is code
      re-use through inheritance. For inheritance, we need to introduce
      <emphasis>classes</emphasis>. In object-oriented programming, a
      class is a &quot;recipe&quot; for creating objects. The recipe can
      be changed by adding new methods and fields, or it can be changed
      by modifying existing methods.
    </para>
    <para>
      In OCaml, class definitions must be defined as top-level
      statements in a module. A class is not an object, and a class
      definition is not an expression. The syntax for a class definition
      uses the keyword <literal>class</literal>.
    </para>
    <programlisting language="ocaml">
# class point =
  object
    val mutable x = 0
    method get = x
    method set y = x &lt;- y
  end;;
class point :
  object
    val mutable x : int
    method get : int
    method set : int -&gt; unit
  end
</programlisting>
    <para>
      The type <literal>class point : ... end</literal> is a
      <emphasis>class type</emphasis>. This particular type specifies
      that the <literal>point</literal> class defines a mutable field
      <literal>x</literal>, a method <literal>get</literal> that returns
      an <literal>int</literal>, and a method <literal>set</literal>
      with type <literal>int -&gt; unit</literal>.
    </para>
    <para>
      To produce an object, classes are instantiated with the keyword
      <literal>new</literal>.
    </para>
    <programlisting language="ocaml">
# let p = new point;;
val p : point = &lt;obj&gt;
# p#get;;
- : int = 0
# p#set 5;;
- : unit = ()
# p#get;;
- : int = 5
</programlisting>
    <para>
      <emphasis>(yminsky: You say that inheritance uses an existing
      class to define a new one, but the example below looks like using
      an existing class to define a new module. Is that what's going on?
      Or is a new class being created implicitly? If the latter, it
      might be better to be more explicit in this example and name the
      new class.)</emphasis>
    </para>
    <para>
      Inheritance uses an existing class to define a new one. For
      example, the following class definition supports an addition
      method <literal>moveby</literal> that moves the point by a
      relative amount. This also makes use of the
      <literal>(self : 'self)</literal> binding after the
      <literal>object</literal> keyword. The variable
      <literal>self</literal> stands for the current object, allowing
      self-invocation, and the type variable <literal>'self</literal>
      stands for the type of the current object (which in general is a
      subtype of <literal>movable_point</literal>).
    </para>
    <programlisting language="ocaml">
# class movable_point =
  object (self : 'self)
    inherit point
    method moveby dx = self#set (self#get + dx)
  end;;
</programlisting>
  </sect1>
  <sect1 id="class-parameters-and-polymorphism">
    <title>Class parameters and polymorphism</title>
    <para>
      A class definition serves as the <emphasis>constructor</emphasis>
      for the class. In general, a class definition may have parameters
      that must be provided as arguments when the object is created with
      <literal>new</literal>.
    </para>
    <para>
      Let's build an example of an imperative singly-linked list using
      object-oriented techniques. First, we'll want to define a class
      for a single element of the list. We'll call it a
      <literal>node</literal>, and it will hold a value of type
      <literal>'a</literal>. When defining the class, the type
      parameters are placed in square brackets before the class name in
      the class definition. We also need a parameter
      <literal>x</literal> for the initial value.
    </para>
    <programlisting language="ocaml">
class ['a] node x =
object
  val mutable value : 'a = x
  val mutable next_node : 'a node option = None

  method get = value
  method set x = value &lt;- x

  method next = next_node
  method set_next node = next_node &lt;- node
end;;
</programlisting>
    <para>
      The <literal>value</literal> is the value stored in the node, and
      it can be retrieved and changed with the <literal>get</literal>
      and <literal>set</literal> methods. The
      <literal>next_node</literal> field is the link to the next element
      in the stack. Note that the type parameter <literal>['a]</literal>
      in the definition uses square brackets, but other uses of the type
      can omit them (or use parentheses if there is more than one type
      parameter).
    </para>
    <para>
      The type annotations on the <literal>val</literal> declarations
      are used to constrain type inference. If we omit these
      annotations, the type inferred for the class will be &quot;too
      polymorphic,&quot; <literal>x</literal> could have some type
      <literal>'b</literal> and <literal>next_node</literal> some type
      <literal>'c option</literal>.
    </para>
    <programlisting language="ocaml">
  class ['a] node x =
  object
    val mutable value = x
    val mutable next_node = None

    method get = value
    method set x = value &lt;- x

    method next = next_node
    method set_next node = next_node &lt;- node
  end;;
Error: Some type variables are unbound in this type:
         class ['a] node :
           'b -&gt;
           object
             val mutable next_node : 'c option
             val mutable value : 'b
             method get : 'b
             method next : 'c option
             method set : 'b -&gt; unit
             method set_next : 'c option -&gt; unit
           end
       The method get has type 'b where 'b is unbound
</programlisting>
    <para>
      In general, we need to provide enough constraints so that the
      compiler will infer the correct type. We can add type constraints
      to the parameters, to the fields, and to the methods. It is a
      matter of preference how many constraints to add. You can add type
      constraints in all three places, but the extra text may not help
      clarity. A convenient middle ground is to annotate the fields
      and/or class parameters, and add constraints to methods only if
      necessary.
    </para>
    <para>
      Next, we can define the list itself. We'll keep a field
      <literal>head</literal> the refers to the first element in the
      list, and <literal>last</literal> refers to the final element in
      the list. The method <literal>insert</literal> adds an element to
      the end of the list.
    </para>
    <programlisting language="ocaml">
class ['a] slist =
object
   val mutable first : ('a) node option = None
   val mutable last : ('a) node option = None

   method is_empty = first = None

   method insert x =
      let new_node = Some (new node x) in
      match last with
         Some last_node -&gt;
            last_node#set_next new_node;
            last &lt;- new_node
       | None -&gt;
            first &lt;- new_node;
            last &lt;- new_node
end;;
</programlisting>
  </sect1>
  <sect1 id="object-types">
    <title>Object types</title>
    <para>
      This definition of the class <literal>slist</literal> is not
      complete, we can construct lists, but we also need to add the
      ability to traverse the elements in the list. One common style for
      doing this is to define a class for an <literal>iterator</literal>
      object. An iterator provides a generic mechanism to inspect and
      traverse the elements of a collection. This pattern isn't
      restricted to lists, it can be used for many different kinds of
      collections.
    </para>
    <para>
      There are two common styles for defining abstract interfaces like
      this. In Java, an iterator would normally be specified with an
      interface, which specifies a set of method types. In languages
      without interfaces, like C++, the specification would normally use
      <emphasis>abstract</emphasis> classes to specify the methods
      without implementing them (C++ uses the &quot;= 0&quot; definition
      to mean &quot;not implemented&quot;).
    </para>
    <programlisting>
// Java-style iterator, specified as an interface.
interface &lt;T&gt; iterator {
  T Get();
  boolean HasValue();
  void Next();
};

// Abstract class definition in C++.
template&lt;typename T&gt;
class Iterator {
 public:
  virtual ~Iterator() {}
  virtual T get() const = 0;
  virtual bool has_value() const = 0;
  virtual void next() = 0;
};
</programlisting>
    <para>
      OCaml support both styles. In fact, OCaml is more flexible than
      these approaches because an object type can be implemented by any
      object with the appropriate methods, it does not have to be
      specified by the object's class <emphasis>a priori</emphasis>.
      We'll leave abstract classes for later. Let's demonstrate the
      technique using object types.
    </para>
    <para>
      First, we'll define an object type <literal>iterator</literal>
      that specifies the methods in an iterator.
    </para>
    <programlisting language="ocaml">
type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;;;`
</programlisting>
    <para>
      Next, we'll define an actual iterator for the class
      <literal>slist</literal>. We can represent the position in the
      list with a field <literal>current</literal>, following links as
      we traverse the list.
    </para>
    <programlisting language="ocaml">
class ['a] slist_iterator cur =
object
  val mutable current : 'a node option = cur

  method has_value = current &lt;&gt; None

  method get =
     match current with
        Some node -&gt; node#get
      | None -&gt; raise (Invalid_argument &quot;no value&quot;)

  method next =
     match current with
        Some node -&gt; current &lt;- node#next
      | None -&gt; raise (Invalid_argument &quot;no value&quot;)
end;;
</programlisting>
    <para>
      Finally, we add a method <literal>iterator</literal> to the slist
      class to produce an iterator. To do so, we construct an
      <literal>slist_iterator</literal> that refers to the first node in
      the list, but we want to return a value with the object type
      <literal>iterator</literal>. This requires an explicit coercion
      using the <literal>:&gt;</literal> operator.
    </para>
    <programlisting language="ocaml">
class ['a] slist = object
...
   method iterator = (new slist_iterator first :&gt; 'a iterator)
end

# let l = new slist;;
# l.insert 5;;
# l.insert 4;;
# let it = l#iterator;;
# it#get;;
- : int = 5
# it#next;;
- : unit = ()
# it#get;;
- : int = 4
# it#next;;
- : unit = ()
# it#has_value;;
- : bool = false
</programlisting>
    <para>
      We may also wish to define functional-style methods,
      <literal>iter f</literal> takes a function <literal>f</literal>
      and applies it to each of the elements of the list.
    </para>
    <programlisting language="ocaml">
method iter f =
  let it = self#iterator in
  while it#has_value do
    f it#get
    it#next
  end
</programlisting>
    <para>
      What about functional operations similar to
      <literal>List.map</literal> or <literal>List.fold</literal>? In
      general, these methods take a function that produces a value of
      some other type than the elements of the set. For example, the
      function <literal>List.fold</literal> has type
      <literal>'a list -&gt; ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</literal>,
      where <literal>'b</literal> is an arbitrary type. To replicate
      this in the <literal>slist</literal> class, we need a method type
      <literal>('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</literal>, where
      the method type is polymorphic over <literal>'b</literal>.
    </para>
    <para>
      The solution is to use a type quantifier, as shown in the
      following example. The method type must be specified directly
      after the method name, which means that method parameters must be
      expressed using a <literal>fun</literal> or
      <literal>function</literal> expression.
    </para>
    <programlisting language="ocaml">
method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b =
   (fun f x -&gt;
         let y = ref x in
         let it = self#iterator in
         while it#has_value do
            y := f !y it#get;
            it#next
         done;
         !y)
</programlisting>
  </sect1>
  <sect1 id="immutable-objects">
    <title>Immutable objects</title>
    <para>
      Many people consider object-oriented programming to be
      intrinsically imperative, where an object is like a state machine.
      Sending a message to an object causes it to change state,
      possibily sending messages to other objects.
    </para>
    <para>
      Indeed, in many programs, this makes sense, but it is by no means
      required. Let's define an object-oriented version of lists similar
      to the imperative list above. We'll implement it with a regular
      list type <literal>'a list</literal>, and insertion will be to the
      beginning of the list instead of to the end.
    </para>
    <programlisting language="ocaml">
class ['a] flist =
object (self : 'self)
   val elements : 'a list = []

   method is_empty = elements = []

   method insert x : 'self = {&lt; elements = x :: elements &gt;}

   method iterator =
      (new flist_iterator elements :&gt; 'a iterator)

   method iter (f : 'a -&gt; unit) = List.iter f elements

   method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b =
      (fun f x -&gt; List.fold_left f x elements)
end;;
</programlisting>
    <para>
      A key part of the implementation is the definition of the method
      <literal>insert</literal>. The expression
      <literal>{&lt; ... &gt;}</literal> produces a copy of the current
      object, with the same type, and the specified fields updated. In
      other words, the <literal>new_fst new_x</literal> method produces
      a copy of the object, with <literal>x</literal> replaced by
      <literal>new_x</literal>. The original object is not modified, and
      the value of <literal>y</literal> is also unaffected.
    </para>
    <para>
      There are some restriction on the use of the expression
      <literal>{&lt; ... &gt;}</literal>. It can be used only within a
      method body, and only the values of fields may be updated. Method
      implementations are fixed at the time the object is created, they
      cannot be changed dynamically.
    </para>
    <para>
      We use the same object type <literal>iterator</literal> for
      iterators, but implement it differently.
    </para>
    <programlisting language="ocaml">
class ['a] flist_iterator l =
object
   val mutable elements : 'a list = l

   method has_value = l &lt;&gt; []

   method get =
      match l with
         h :: _ -&gt; h
       | [] -&gt; raise (Invalid_argument &quot;list is empty&quot;)

   method next =
      match l with
         _ :: l -&gt; elements &lt;- l
       | [] -&gt; raise (Invalid_argument &quot;list is empty&quot;)
end;;
</programlisting>
  </sect1>
  <sect1 id="class-types">
    <title>Class types</title>
    <para>
      Once we have defined the list implementation, the next step is to
      wrap it in a module or <literal>.ml</literal> file and give it a
      type so that it can be used in the rest of our code. What is the
      type?
    </para>
    <para>
      Before we begin, let's wrap up the implementation in an explicit
      module (we'll use explicit modules for illustration, but the
      process is similar when we want to define a
      <literal>.mli</literal> file). In keeping with the usual style for
      modules, we define a type <literal>'a t</literal> to represent the
      type of list values.
    </para>
    <programlisting language="ocaml">
module SList = struct
   type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;
   type 'a t = &lt; is_empty : bool; insert : 'a -&gt; unit; iterator : 'a iterator &gt;

   class ['a] node x = object ... end
   class ['a] slist_iterator cur = object ... end
   class ['a] slist = object ... end

   let make () = new slist
end;;
</programlisting>
    <para>
      We have multiple choices in definining the module type, depending
      on how much of the implementation we want to expose. At one
      extreme, a maximally-abstract signature would completely hide the
      class definitions.
    </para>
    <programlisting language="ocaml">
module AbstractSList : sig
   type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;
   type 'a t = &lt; is_empty : bool; insert : 'a -&gt; unit; iterator : 'a iterator &gt;

   val make : unit -&gt; 'a t
end = SList
</programlisting>
    <para>
      The abstract signature is simple because we ignore the classes.
      But what if we want to include them in the signature, so that
      other modules can inherit from the class definitions? For this, we
      need to specify types for the classes, called <emphasis>class
      types</emphasis>. Class types do not appear in mainstream
      object-oriented programming languages, so you may not be familiar
      with them, but the concept is pretty simple. A class type
      specifies the type of each of the visible parts of the class,
      including both fields and methods. Just like for module types, you
      don't have to give a type for everything; anything you omit will
      be hidden.
    </para>
    <programlisting language="ocaml">
module VisibleSList : sig
  type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;
  type 'a t = &lt; is_empty : bool; insert : 'a -&gt; unit; iterator : 'a iterator &gt;

  class ['a] node : 'a -&gt;
  object
     method get : 'a
     method set : 'a -&gt; unit
     method next : 'a node option
     method set_next : 'a node option -&gt; unit
  end

  class ['a] slist_iterator : 'a node option -&gt;
  object
     method has_value : bool
     method get : 'a
     method next : unit
  end

  class ['a] slist :
  object
    val mutable first : 'a node option
    val mutable last : 'a node option
    method is_empty : bool
    method insert : 'a -&gt; unit
    method iterator : 'a iterator
  end

  val make : unit -&gt; 'a slist
end = SList
</programlisting>
    <para>
      In this signature, we've chosen to make nearly everything visible.
      The class type for <literal>slist</literal> specifies the types of
      the fields <literal>first</literal> and <literal>last</literal>,
      as well ad the types of each of the methods. We've also included a
      class type for <literal>slist_iterator</literal>, which is of
      somewhat more questionable value, since the type doesn't appear in
      the type for <literal>slist</literal> at all.
    </para>
    <para>
      One more thing, in this example the function
      <literal>make</literal> has type
      <literal>unit -&gt; 'a slist</literal>. But wait, we've stressed
      <emphasis>classes are not types</emphasis>, so what's up with
      that? In fact, what we've said is entirely true, classes and class
      names <emphasis>are not</emphasis> types. However, class names can
      be used to stand for types. When the compiler sees a class name in
      type position, it automatically constructs an object type from it
      by erasing all the fields and keeping only the method types. In
      this case, the type expression <literal>'a slist</literal> is
      exactly equivalent to <literal>'a t</literal>.
    </para>
  </sect1>
  <sect1 id="subtyping">
    <title>Subtyping</title>
    <para>
      Subtyping is a central concept in object-oriented programming. It
      governs when an object with one type <emphasis>A</emphasis> can be
      used in an expression that expects an object of another type
      <emphasis>B</emphasis>. When this is true, we say that
      <emphasis>A</emphasis> is a <emphasis>subtype</emphasis> of
      <emphasis>B</emphasis>. Actually, more concretely, subtyping
      determines when the coercion operator <literal>e :&gt; t</literal>
      can be applied. This coercion works only if the expression
      <literal>e</literal> has some type <literal>s</literal> and
      <literal>s</literal> is a subtype of <literal>t</literal>.
    </para>
    <para>
      To explore this, let's define some simple classes for geometric
      shapes. The generic type <literal>shape</literal> has a method to
      compute the area, and a <literal>square</literal> is a specific
      kind of shape.
    </para>
    <programlisting language="ocaml">
type shape = &lt; area : float &gt;;;

class square w =
object (self : 'self)
  method area = self#width *. self#width
  method width = w
end;;
</programlisting>
    <para>
      A <literal>square</literal> has a method <literal>area</literal>
      just like a <literal>shape</literal>, and an additional method
      <literal>width</literal>. Still, we expect a
      <literal>square</literal> to be a <literal>shape</literal>, and it
      is. The coercion <literal>:&gt;</literal> must be explicit.
    </para>
    <programlisting language="ocaml">
# let new_square x : shape = new square x;;
Characters 27-39:
  let new_square x : shape = new square x;;
                             ^^^^^^^^^^^^
Error: This expression has type square but an expression was expected of type shape
The second object type has no method width
# let new_square x : shape = (new square x :&gt; shape);;
val new_square : float -&gt; shape = &lt;fun&gt;
</programlisting>
    <para>
      What are the rules for subtyping? In general, object subtyping has
      two general forms, called <emphasis>width</emphasis> and
      <emphasis>depth</emphasis> subtyping. Width subtyping means that
      an object type <emphasis>A</emphasis> is a a subtype of
      <emphasis>B</emphasis>, if <emphasis>A</emphasis> has all of the
      methods of <emphasis>B</emphasis>, and possibly more. A
      <literal>square</literal> is a subtype of <literal>shape</literal>
      because it implements all of the methods of
      <literal>shape</literal> (the <literal>area</literal> method).
    </para>
    <para>
      The subtyping rules are purely technical, they have no relation to
      object semantics. We can define a class
      <literal>rectangle</literal> that has all of the methods of a
      <literal>square</literal>, so it is a subtype of square and can be
      used wherever a <literal>square</literal> is expected.
    </para>
    <programlisting language="ocaml">
# class rectangle h w =
  object (self : 'self)
     inherit square w
     method area = self#width *. self#height
     method height = h
  end;;
# let square_rectangle h w : square = (new rectangle h w :&gt; square);;
val square_rectangle : float -&gt; float -&gt; square = &lt;fun&gt;
</programlisting>
    <para>
      This may seem absurd, but this concept is expressible in all
      object-oriented languages. The contradiction is semantic -- we
      know that in the real world, not all rectangles are squares; but
      in the programming world, rectangles have all of the features of
      squares (according to our definition), so they can be used just
      like squares. Suffice it to say that it is usually better to avoid
      such apparent contradictions.
    </para>
    <para>
      Next, let's take a seemingly tiny step forward, and start building
      collections of shapes. It is easy enough to define a
      <literal>slist</literal> of squares.
    </para>
    <programlisting language="ocaml">
# let squares =
     let l = SList.make () in
     l#insert (new square 1.0);
     l#insert (new square 2.0);
     l;;
val squares : square slist = &lt;obj&gt;
</programlisting>
    <para>
      We can also define a function to calculate the total area of a
      list of shapes. There is no reason to restrict this to squares, it
      should work for any list of shapes with type
      <literal>shape slist</literal>. The problem is that doing so
      raises some serious typing questions -- can a
      <literal>square slist</literal> be passed to a function that
      expects a <literal>shape slist</literal>? If we try it, the
      compiler produces a verbose error message.
    </para>
    <programlisting language="ocaml">
# let total_area (l : shape slist) : float =
     let total = ref 0.0 in
     let it = l#iterator in
     while it#has_value do
        total := !total +. it#get#area;
        it#next
     done;
     !total;;
val total_area : shape slist -&gt; float = &lt;fun&gt;
# total_area squares;;
Characters 11-18:
  total_area squares;;
             ^^^^^^^
Error: This expression has type
         square slist =
           &lt; insert : square -&gt; unit; is_empty : bool;
             iterator : square iterator &gt;
       but an expression was expected of type
         shape slist =
           &lt; insert : shape -&gt; unit; is_empty : bool;
             iterator : shape iterator &gt;
       Type square = &lt; area : float; width : float &gt;
       is not compatible with type shape = &lt; area : float &gt; 
       The second object type has no method width
</programlisting>
    <para>
      It might seem tempting to give up at this point, especially
      because the subtyping is not even true -- the type
      <literal>square slist</literal> is not a subtype of
      <literal>shape slist</literal>. The problem is with the
      <literal>insert</literal> method. For
      <literal>shape slist</literal>, the <literal>insert</literal>
      method takes an arbitrary <literal>shape</literal> and inserts it
      into the list. So if we could coerce a
      <literal>square slist</literal> to a
      <literal>shape slist</literal>, then it would be possible to
      insert an arbitrary shape into the list, which would be an error.
    </para>
    <sect2 id="using-more-precise-types-to-address-subtyping-problems">
      <title>Using more precise types to address subtyping
      problems</title>
      <para>
        Still, the <literal>total_area</literal> function should be
        fine, in principle. It doesn't call <literal>insert</literal>,
        so it isn't making that error. To make it work, we need to use a
        more precise type that indicates we are not going to be mutating
        the list. We define a type
        <literal>readonly_shape_slist</literal> and confirm that we can
        coerce the list of squares.
      </para>
      <programlisting language="ocaml">
# type readonly_shape_slist = &lt; iterator : shape iterator &gt;;;
type readonly_shape_slist = &lt; iterator : shape iterator &gt;
# (squares :&gt; readonly_shape_slist);;
- : readonly_shape_slist = &lt;obj&gt;
# let total_area (l : readonly_shape_slist) : float = ...;;
val total_area : readonly_shape_slist -&gt; float = &lt;fun&gt;
#   total_area (squares :&gt; readonly_shape_slist);;
- : float = 5.
</programlisting>
      <para>
        Why does this work, why is a <literal>square slist</literal> a
        subtype of <literal>readonly_shape_slist</literal>. The
        reasoning is in two steps. First, the easy part is width
        subtyping: we can drop the other methods to see that
        <literal>square slist</literal> is a subtype of
        <literal>&lt; iterator : square iterator &gt;</literal>. The
        next step is to use <emphasis>depth</emphasis> subtyping, which,
        in its general form, says that an object type
        <literal>&lt; m : t1 &gt;</literal> is a subtype of a type
        <literal>&lt; m : t2&gt;</literal> iff <literal>t1</literal> is
        a subtype of <literal>t2</literal>. In other words, instead of
        reasoning about the number of methods in a type (the width), the
        number of methods is fixed, and we look within the method types
        themselves (the &quot;depth&quot;).
      </para>
      <para>
        In this particular case, depth subtyping on the
        <literal>iterator</literal> method requires that
        <literal>square iterator</literal> be a subtype of
        <literal>shape iterator</literal>. Expanding the type definition
        for the type <literal>iterator</literal>, we again invoke depth
        subtyping, and we need to show that the type
        <literal>&lt; get : square &gt;</literal> is a subtype of
        <literal>&lt;get : shape &gt;</literal>, which follows because
        <literal>square</literal> is a subtype of
        <literal>shape</literal>.
      </para>
      <para>
        This reasoning may seem fairly long and complicated, but it
        should be pointed out that this typing
        <emphasis>works</emphasis>, and in the end the type annotations
        are fairly minor. In most typed object-oriented languages, the
        coercion would simply not be possible. For example, in C++, a
        STL type <literal>slist&lt;T&gt;</literal> is invariant in
        <literal>T</literal>, it is simply not possible to use
        <literal>slist&lt;square&gt;</literal> where
        <literal>slist&lt;shape&gt;</literal> is expected (at least
        safely). The situation is similar in Java, although Java
        supports has an escape hatch that allows the program to fall
        back to dynamic typing. The situation in OCaml is much better;
        it works, it is statically checked, and the annotations are
        pretty simple.
      </para>
    </sect2>
    <sect2 id="using-elided-types-to-address-subtyping-problems">
      <title>Using elided types to address subtyping problems</title>
      <para>
        Before we move to the next topic, there is one more thing to
        address. The typing we gave above, using
        <literal>readonly_shape_slist</literal>, requires that the
        caller perform an explicit coercion before calling the
        <literal>total_area</literal> function. We would like to give a
        better type that avoids the coercion.
      </para>
      <para>
        A solution is to use an elided type. Instead of
        <literal>shape</literal>, we can use the elided type
        <literal>&lt; area : float; .. &gt;</literal>. In fact, once we
        do this, it also becomes possible to use the
        <literal>slist</literal> type.
      </para>
      <programlisting language="ocaml">
# let total_area (l : &lt; area : float; .. &gt; slist) : float = ...;;
val total_area : &lt; area : float; .. &gt; slist -&gt; float = &lt;fun&gt;
# total_area squares;;
- : float = 5.
</programlisting>
      <para>
        This works, and it removes the need for explicit coercions. This
        type is still fairly simple, but it does have the drawback that
        the programmer needs to remember that the types
        <literal>&lt; area : float; ..&gt;</literal> and
        <literal>shape</literal> are related.
      </para>
      <para>
        OCaml supports an abbreviation in this case, but it works only
        for classes, not object types. The type expression
        <literal># classname</literal> is an abbreviation for an elided
        type containing all of the methods in the named class, and more.
        Since <literal>shape</literal> is an object type, we can't write
        <literal>#shape</literal>. However, if a class definition is
        available, this abbreviation can be useful. The following
        definition is exactly equivalent to the preceeding.
      </para>
      <programlisting language="ocaml">
# class cshape = object method area = 0.0 end;;
class cshape : object method area : float end
# let total_area (l : #cshape list) : float = ...;;
val total_area : #cshape slist -&gt; float = &lt;fun&gt;
# total_area squares;;
- : float = 5.
</programlisting>
    </sect2>
    <sect2 id="narrowing">
      <title>Narrowing</title>
      <para>
        Narrowing, also called <emphasis>down casting</emphasis>, is the
        ability to coerce an object to one of its subtypes. For example,
        if we have a list of shapes <literal>shape slist</literal>, we
        might know (for some reason) what the actual type of each shape
        is. Perhaps we know that all objects in the list have type
        <literal>square</literal>. In this case,
        <emphasis>narrowing</emphasis> would allow the re-casting of the
        object from type <literal>shape</literal> to type
        <literal>square</literal>. Many languages support narrowing
        through dynamic type checking. For example, in Java, a coercion
        <literal>(Square) x</literal> is allowed if the value
        <literal>x</literal> has type <literal>Square</literal> or one
        of its subtypes; otherwise the coercion throws an exception.
      </para>
      <para>
        Narrowing is <emphasis>not permitted</emphasis> in OCaml.
        Period.
      </para>
      <para>
        Why? There are two reasonable explanations, one based on a
        design principle, and another technical (the technical reason is
        simple: it is hard to implement).
      </para>
      <para>
        The design argument is this: narrowing violates abstraction. In
        fact, with a structural typing system like in OCaml, narrowing
        would essentially provide the ability to enumerate the methods
        in an object. To check whether an object <literal>obj</literal>
        has some method <literal>foo : int</literal>, one would attempt
        a coercion <literal>(obj :&gt; &lt; foo : int &gt;)</literal>.
      </para>
      <para>
        More commonly, narrowing leads to poor object-oriented style.
        Consider the following Java code, which returns the name of a
        shape object.
      </para>
      <programlisting>
String GetShapeName(Shape s) {
  if (s instanceof Square) {
    return &quot;Square&quot;;
  } else if (s instanceof Circle) {
    return &quot;Circle&quot;;
  } else {
    return &quot;Other&quot;;
  }
}
</programlisting>
      <para>
        Most programmers would consider this code to be
        &quot;wrong.&quot; Instead of performing a case analysis on the
        type of object, it would be better to define a method to return
        the name of the shape. Instead of calling
        <literal>GetShapeName(s)</literal>, we should call
        <literal>s.Name()</literal> instead.
      </para>
      <para>
        However, the situation is not always so obvious. The following
        code checks whether an array of shapes looks like a
        &quot;barbell,&quot; composed to two <literal>Circle</literal>
        objects separated by a <literal>Line</literal>, where the
        circles have the same radius.
      </para>
      <programlisting>
boolean IsBarBell(Shape[] s) {
  return s.length == 3 &amp;&amp; (s[0] instanceof Circle) &amp;&amp;
    (s[1] instanceof Line) &amp;&amp; (s[2] instanceof Circle) &amp;&amp;
    ((Circle) s[0]).radius() == ((Circle) s[2]).radius();
}
</programlisting>
      <para>
        In this case, it is much less clear how to augment the
        <literal>Shape</literal> class to support this kind of pattern
        analysis. It is also not obvious that object-oriented
        programming is well-suited for this situation. Pattern matching
        seems like a better fit.
      </para>
      <programlisting language="ocaml">
let is_bar_bell = function
 | [Circle r1; Line _; Circle r2] when r1 == r2 -&gt; true
 | _ -&gt; false;;
</programlisting>
      <para>
        Regardless, there is a solution if you find yourself in this
        situation, which is to augment the classes with variants. You
        can define a method <literal>variant</literal> that injects the
        actual object into a variant type.
      </para>
      <programlisting language="ocaml">
type shape = &lt; variant : repr; area : float&gt;
and circle = &lt; variant : repr; area : float; radius : float &gt;
and line = &lt; variant : repr; area : float; length : float &gt;
and repr =
 | Circle of circle
 | Line of line;;

let is_bar_bell = function
 | [s1; s2; s3] -&gt;
   (match s1#variant, s2#variant, s3#variant with
     | Circle c1, Line _, Circle c2 when c1#radius == c2#radius -&gt; true
     | _ -&gt; false)
 | _ -&gt; false;;
</programlisting>
      <para>
        This pattern works, but it has drawbacks. In particular, the
        recursive type definition should make it clear that this pattern
        is essentially equivalent to using variants, and that objects do
        not provide much value here.
      </para>
    </sect2>
    <sect2 id="binary-methods">
      <title>Binary methods</title>
      <para>
        A <emphasis>binary method</emphasis> is a method that takes an
        object of <literal>self</literal> type. One common example is
        defining a method for equality.
      </para>
      <programlisting language="ocaml">
# class square w =
  object (self : 'self) 
    method width = w
    method area = self#width * self#width
    method equals (other : 'self) = other#width = self#width
  end;;
class square : int -&gt;
  object ('a)
    method area : int
    method equals : 'a -&gt; bool
    method width : int
  end
# class rectangle w h =
  object (self : 'self)
    method width = w
    method height = h
    method area = self#width * self#height
    method equals (other : 'self) = other#width = self#width &amp;&amp; other#height = self#height
  end;;
...
# (new square 5)#equals (new square 5);;
- : bool = true
# (new rectangle 5 6)#equals (new rectangle 5 7);;
- : bool = false
</programlisting>
      <para>
        This works, but there is a problem lurking here. The method
        <literal>equals</literal> takes an object of the exact type
        <literal>square</literal> or <literal>rectangle</literal>.
        Because of this, we can't define a common base class
        <literal>shape</literal> that also includes an equality method.
      </para>
      <programlisting language="ocaml">
# type shape = &lt; equals : shape -&gt; bool; area : int &gt;;;
# let sq = new square 5;;
# (sq :&gt; shape);;
Characters 0-13:
  (sq :&gt; shape);;
  ^^^^^^^^^^^^^
Error: Type square = &lt; area : int; equals : square -&gt; bool; width : int &gt;
       is not a subtype of shape = &lt; area : int; equals : shape -&gt; bool &gt; 
Type shape = &lt; area : int; equals : shape -&gt; bool &gt; is not a subtype of
  square = &lt; area : int; equals : square -&gt; bool; width : int &gt; 
</programlisting>
      <para>
        The problem is that a <literal>square</literal> expects to be
        compared with a <literal>square</literal>, not an arbitrary
        shape; similarly for <literal>rectangle</literal>.
      </para>
      <para>
        This problem is fundamental. Many languages solve it either with
        narrowing (with dynamic type checking), or by method
        overloading. Since OCaml has neither of these, what can we do?
      </para>
      <para>
        One proposal we could consider is, since the problematic method
        is equality, why not just drop it from the base type
        <literal>shape</literal> and use polymorphic equality instead?
        Unfortunately, the builtin equality has very poor behavior when
        applied to objects.
      </para>
      <programlisting language="ocaml">
# (object method area = 5 end) = (object method area = 5 end);;
- : bool = false
</programlisting>
      <para>
        The problem here is that the builtin polymorphic equality
        compares the method implementations, not their return values.
        The method implementations (the function values that implement
        the methods) are different, so the equality comparison is false.
        There are other reasons not to use the builtin polymorphic
        equality, but these false negatives are a showstopper.
      </para>
      <para>
        If we want to define equality for shapes in general, the
        remaining solution is to use the same approach as we described
        for narrowing. That is, introduce a
        <emphasis>representation</emphasis> type implemented using
        variants, and implement the comparison based on the
        representation type.
      </para>
      <programlisting language="ocaml">
type shape_repr =
 | Square of int
 | Circle of int
 | Rectangle of int * int;;

type shape = &lt; repr : shape_repr; equals : shape -&gt; bool; area : int &gt;;;

class square w =
object (self : 'self)
  method width = w
  method area = self#width * self#width
  method repr = Square self#width
  method equals (other : shape) = self#repr = other#repr
end;;
</programlisting>
      <para>
        The binary method <literal>equals</literal> is now implemented
        in terms of the concrete type <literal>shape_repr</literal>. In
        fact, the objects are now isomorphic to the
        <literal>shape_repr</literal> type. When using this pattern, you
        will not be able to hide the <literal>repr</literal> method, but
        you can hide the type definition using the module system.
      </para>
      <programlisting language="ocaml">
module Shapes : sig
  type shape_repr
  type shape = &lt; repr : shape_repr; equals : shape -&gt; bool; area -&gt; int &gt;

  class square : int -&gt;
    object
      method width : int
      method area : int
      method repr : shape_repr
      method equals : shape -&gt; bool
    end
end = struct
  type shape_repr = Square of int | Circle of int | Rectangle of int * int
  ...
end;;
</programlisting>
    </sect2>
  </sect1>
  <sect1 id="private-methods">
    <title>Private methods</title>
    <para>
      Methods can be declared <emphasis>private</emphasis>, which means
      that they may be called by subclasses, but they are not visible
      otherwise (similar to a <emphasis>protected</emphasis> method in
      C++).
    </para>
    <para>
      To illustrate, let's build a class <literal>vector</literal> that
      contains an array of integers, resizing the storage array on
      demand. The field <literal>values</literal> contains the actual
      values, and the <literal>get</literal>, <literal>set</literal>,
      and <literal>length</literal> methods implement the array access.
      For clarity, the resizing operation is implemented as a private
      method <literal>ensure_capacity</literal> that resizes the array
      if necessary.
    </para>
    <programlisting language="ocaml">
# class vector =
  object (self : 'self)
     val mutable values : int array = [||]

     method get i = values.(i)
     method set i x =
        self#ensure_capacity i;
        values.(i) &lt;- x
     method length = Array.length values

     method private ensure_capacity i =
        if self#length &lt;= i then
           let new_values = Array.create (i + 1) 0 in
           Array.blit values 0 new_values 0 (Array.length values);
           values &lt;- new_values
  end;;
# let v = new vector;;
# v#set 5 2;;
# v#get 5;;
- 2 : int
# v#ensure_capacity 10;;
Characters 0-1:
  v#ensure_capacity 10;;
  ^
Error: This expression has type vector
       It has no method ensure_capacity
</programlisting>
    <para>
      To be precise, the method <literal>ensure_capacity</literal> is
      part of the class type, but it is not part of the object type.
      This means the object <literal>v</literal> has no method
      <literal>ensure_capacity</literal>. However, it is available to
      subclasses. We can extend the class, for example, to include a
      method <literal>swap</literal> that swaps two elements.
    </para>
    <programlisting language="ocaml">
# class swappable_vector =
  object (self : 'self)
     inherit vector

     method swap i j =
        self#ensure_capacity (max i j);
        let tmp = values.(i) in
        values.(i) &lt;- values.(j);
        values.(j) &lt;- tmp
  end;;
</programlisting>
    <para>
      Yet another reason for private methods is to factor the
      implementation and support recursion. Moving along with this
      example, let's build a binary heap, which is a binary tree in heap
      order: where the label of parent elements is smaller than the
      labels of its children. One efficient implementation is to use an
      array to represent the values, where the root is at index 0, and
      the children of a parent node at index <literal>i</literal> are at
      indexes <literal>2 * i</literal> and <literal>2 * i + 1</literal>.
      To insert a node into the tree, we add it as a leaf, and then
      recursively move it up the tree until we restore heap order.
    </para>
    <programlisting language="ocaml">
class binary_heap =
object (self : 'self)
   val values = new swappable_vector

   method min =
      if values#length = 0 then
         raise (Invalid_argument &quot;heap is empty&quot;);
      values#get 0

   method add x =
      let pos = values#length in
      values#set pos x;
      self#move_up pos

   method private move_up i =
      if i &gt; 0 then
         let parent = (i - 1) / 2 in
            if values#get i &lt; values#get parent then begin
               values#swap i parent;
               self#move_up parent
            end
end;;
</programlisting>
    <para>
      The method <literal>move_up</literal> implements the process of
      restoring heap order as a recursive method (though it would be
      straightforward avoid the recursion and use iteration here).
    </para>
    <para>
      The key property of private methods is that they are visible to
      subclasses, but not anywhere else. If you want the stronger
      guarantee that a method is <emphasis>really</emphasis> private,
      not even accessible in subclasses, you can use an explicit typing
      that omits the method. In the following code, the
      <literal>move_up</literal> method is explicitly omitted from the
      object type, and it can't be invoked in subclasses.
    </para>
    <programlisting language="ocaml">
# class binary_heap :
  object
    method min : int
    method add : int -&gt; unit
  end =
  object (self : 'self) {
    ...
    method private move_up i = ...
  end;;
</programlisting>
  </sect1>
  <sect1 id="virtual-classes-and-methods">
    <title>Virtual classes and methods</title>
    <para>
      A <emphasis>virtual</emphasis> class is a class where some methods
      or fields are declared, but not implemented. This should not be
      confused with the word &quot;virtual&quot; as it is used in C++.
      In C++, a &quot;virtual&quot; method uses dynamic dispatch,
      regular non-virtual methods use static dispatched. In OCaml,
      <emphasis>all</emphasis> methods use dynamic dispatch, but the
      keyword <emphasis>virtual</emphasis> means the method or field is
      not implemented.
    </para>
    <para>
      In the previous section, we defined a class
      <literal>swappable_vector</literal> that inherits from
      <literal>array_vector</literal> and adds a <literal>swap</literal>
      method. In fact, the <literal>swap</literal> method could be
      defined for any object with <literal>get</literal> and
      <literal>set</literal> methods; it doesn't have to be the specific
      class <literal>array_vector</literal>.
    </para>
    <para>
      One way to do this is to declare the
      <literal>swappable_vector</literal> abstractly, declaring the
      methods <literal>get</literal> and <literal>set</literal>, but
      leaving the implementation for later. However, the
      <literal>swap</literal> method can be defined immediately.
    </para>
    <programlisting language="ocaml">
class virtual abstract_swappable_vector =
object (self : 'self)
   method virtual get : int -&gt; int
   method virtual set : int -&gt; int -&gt; unit
   method swap i j =
      let tmp = self#get i in
      self#set i (self#get j);
      self#set j tmp
end;;
</programlisting>
    <para>
      At some future time, we may settle on a concrete implementation
      for the vector. We can inherit from the
      <literal>abstract_swappable_bvector</literal> to get the
      <literal>swap</literal> method &quot;for free.&quot; Here's one
      implementation using arrays.
    </para>
    <programlisting language="ocaml">
class array_vector =
object (self : 'self)
   inherit abstract_swappable_vector

   val mutable values = [||]
   method get i = values.(i)
   method set i x =
      self#ensure_capacity i;
      values.(i) &lt;- x
   method length = Array.length values

   method private ensure_capacity i =
      if self#length &lt;= i then
         let new_values = Array.create (i + 1) 0 in
            Array.blit values 0 new_values 0 (Array.length values);
            values &lt;- new_values
end
</programlisting>
    <para>
      Here's a different implementation using
      <literal>HashTbl</literal>.
    </para>
    <programlisting language="ocaml">
class hash_vector =
object (self : 'self)
   inherit abstract_swappable_vector

   val table = Hashtbl.create 19

   method get i =
      try Hashtbl.find table i with
         Not_found -&gt; 0

   method set = Hashtbl.add table
end;;
</programlisting>
    <para>
      One way to view a <literal>virtual</literal> class is that it is
      like a functor, where the &quot;inputs&quot; are the declared, but
      not defined, virtual methods and fields. The functor application
      is implemented through inheritance, when virtual methods are given
      concrete implementations.
    </para>
    <para>
      We've been mentioning that fields can be virtual too. Here is
      another implementation of the swapper, this time with direct
      access to the array of values.
    </para>
    <programlisting language="ocaml">
class virtual abstract_swappable_array_vector =
object (self : 'self)
   val mutable virtual values : int array
   method private virtual ensure_capacity : int -&gt; unit

   method swap i j =
      self#ensure_capacity (max i j);
      let tmp = values.(i) in
      values.(i) &lt;- values.(j);
      values.(j) &lt;- tmp
end;;
</programlisting>
    <para>
      This level of dependency on the implementation details is
      possible, but it is hard to justify the use of a virtual class --
      why not just define the <literal>swap</literal> method as part of
      the concrete class? Virtual classes are better suited for
      situations where there are multiple (useful) implementations of
      the virtual parts. In most cases, this will be public virtual
      methods.
    </para>
  </sect1>
  <sect1 id="multiple-inheritance">
    <title>Multiple inheritance</title>
    <para>
      When a class inherits from more than one superclass, it is using
      <emphasis>multiple inheritance</emphasis>. Multiple inheritance
      extends the variety of ways in which classes can be combined, and
      it can be quite useful, particularly with virtual classes.
      However, it can be tricky to use, particularly when the
      inheritance hierarchy is a graph rather than a tree, so it should
      be used with care.
    </para>
    <sect2 id="how-names-are-resolved">
      <title>How names are resolved</title>
      <para>
        The main &quot;trickiness&quot; of multiple inheritance is due
        to naming -- what happens when a method or field with some name
        is defined in more than one class?
      </para>
      <para>
        If there is one thing to remember about inheritance in OCaml, it
        is this: inheritance is like textual inclusion. If there is more
        than one definition for a name, the last definition wins. Let's
        look at some artificial, but illustrative, examples.
      </para>
      <para>
        First, let's consider what happens when we define a method more
        than once. In the following example, the method
        <literal>get</literal> is defined twice; the second definition
        &quot;wins,&quot; meaning that it overrides the first one.
      </para>
      <programlisting language="ocaml">
# class m1 =
object (self : 'self)
   method get = 1
   method f = self#get
   method get = 2
end;;
class m1 : object method f : int method get : int end
# (new m1)#f;;
- : int = 2
</programlisting>
      <para>
        Fields have similar behavior, though the compiler produces a
        warning message about the override.
      </para>
      <programlisting language="ocaml">
# class m2 =
# class m2 =
  object (self : 'self)
     val x = 1
     method f = x
     val x = 2
  end;;
Characters 69-74:
     val x = 2
         ^^^^^
Warning 13: the instance variable x is overridden.
The behaviour changed in ocaml 3.10 (previous behaviour was hiding.)
class m2 : object val x : int method f : int end
# (new m2)#f;;
- : int = 2
</programlisting>
      <para>
        Of course, it is unlikely that you will define two methods or
        two fields of the same name in the same class. However, the
        rules for inheritance follow the same pattern: the last
        definition wins. In the following definition, the
        <literal>inherit</literal> declaration comes last, so the method
        definition <literal>method get = 2</literal> overrides the
        previous definition, always returning 2.
      </para>
      <programlisting language="ocaml">
# class m4 = object method get = 2 end;;
# class m5 =
  object
    val mutable x = 1
    method get = x
    method set x' = x &lt;- x'
    inherit m4
  end;;
class m5 : object val mutable x : int method get : int method set : int -&gt; unit end
# let x = new m5;;
val x : m5 = &lt;obj&gt;
# x#set 5;;
- : unit = ()
# x#get;;
- : int = 2
</programlisting>
      <para>
        To reiterate, to understand what inheritance means, replace each
        <literal>inherit</literal> directive with its definition, and
        take the last definition of each method or field. This holds
        even for private methods. However, it does
        <emphasis>not</emphasis> hold for private methods that are
        &quot;really&quot; private, meaning that they have been hidden
        by a type constraint. In the following definitions, there are
        three definitions of the private method <literal>g</literal>.
        However, the definition of <literal>g</literal> in
        <literal>m8</literal> is not overridden, because it is not part
        of the class type for <literal>m8</literal>.
      </para>
      <programlisting language="ocaml">
# class m6 =
  object (self : 'self)
     method f1 = self#g
     method private g = 1
  end;;
class m6 : object method f1 : int method private g : int end
# class m7 =
  object (self : 'self)
     method f2 = self#g
     method private g = 2
  end;;
class m7 : object method f2 : int method private g : int end
# class m8 : object method f3 : int end =
  object (self : 'self)
     method f3 = self#g
     method private g = 3
  end;;
class m8 : object method f3 : int end
# class m9 =
  object (self : 'self)
     inherit m6
     inherit m7
     inherit m8
  end;;
# class m9 :
  object
    method f1 : int
    method f2 : int
    method f3 : int
    method private g : int
  end
# let x = new m9;;
val x : m9 = &lt;obj&gt;
# x#f1;;
- : int = 2
# x#f3;;
- : int = 3
</programlisting>
    </sect2>
    <sect2 id="mixins">
      <title>Mixins</title>
      <para>
        When should you use multiple inheritance? If you ask multiple
        people, you're likely to get multiple (perhaps heated) answers.
        Some will argue that multiple inheritance is overly complicated;
        others will argue that inheritance is problematic in general,
        and one should use object composition instead. But regardless of
        who you talk to, you will rarely hear that multiple inheritance
        is great and you should use it widely.
      </para>
      <para>
        In any case, if you're programming with objects, there's one
        general pattern for multiple inheritance that is both useful and
        reasonably simple, the <emphasis>mixin</emphasis> pattern.
        Generically, a <emphasis>mixin</emphasis> is just a virtual
        class that implements a feature based on another one. If you
        have a class that implements methods <emphasis>A</emphasis>, and
        you have a mixin <emphasis>M</emphasis> that provides methods
        <emphasis>B</emphasis> from <emphasis>A</emphasis>, then you can
        inherit from <emphasis>M</emphasis> -- &quot;mixing&quot; it in
        -- to get features <emphasis>B</emphasis>.
      </para>
      <para>
        That's too abstract, so let's give an example based on
        collections. In Section XXX:Objecttypes, we introduced the
        <emphasis>iterator</emphasis> pattern, where an
        <emphasis>iterator</emphasis> object is used to enumerate the
        elements of a collection. Lots of containers can have iterators,
        singly-linked lists, dictionaries, vectors, etc.
      </para>
      <programlisting language="ocaml">
type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;;;
class ['a] slist : object ... method iterator : 'a iterator end;;
class ['a] vector : object ... method iterator : 'a iterator end;;
class ['a] deque : object ... method iterator : 'a iterator end;;
class ['a, 'b] map : object ... method iterator : 'b iterator end;;
...
</programlisting>
      <para>
        The collections are different is some ways, but they share a
        common pattern for iteration that we can re-use. For a simple
        example, let's define a mixin that implements an arithmetic sum
        for a collection of integers.
      </para>
      <programlisting language="ocaml">
# class virtual int_sum_mixin =
  object (self : 'self)
     method virtual iterator : int iterator
     method sum =
        let it = self#iterator in
        let total = ref 0 in
        while it#has_value do
           total := !total + it#get;
           it#next
        done;
        !total
  end;;
# class int_slist =
  object
     inherit [int] slist
     inherit int_sum_mixin
  end;;
# let l = new int_slist;;
val l : int_slist = &lt;obj&gt;
# l#insert 5;;
# l#insert 12;;
# l#sum;;
- : int = 17
# class int_deque =
  object
     inherit [int] deque
     inherit int_sum_mixin
  end;;
</programlisting>
      <para>
        In this particular case, the mixin works only for a collection
        of integers, so we can't add the mixin to the polymorphic class
        definition <literal>['a] slist</literal> itself. However, the
        result of using the mixin is that the integer collection has a
        method <literal>sum</literal>, and it is done with very little
        of the fuss we would need if we used object composition instead.
      </para>
      <para>
        The mixin pattern isn't limited to non-polymorphic classes, of
        course. We can use it to implement generic features as well. The
        following mixin defines functional-style iteration in terms of
        the imperative iterator pattern.
      </para>
      <programlisting language="ocaml">
class virtual ['a] fold_mixin =
object (self : 'self)
   method virtual iterator : 'a iterator
   method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b =
      (fun f x -&gt;
            let y = ref x in
            let it = self#iterator in
            while it#has_value do
               y := f !y it#get;
               it#next
            done;
            !y)
end;;

class ['a] slist_with_fold =
object
   inherit ['a] slist
   inherit ['a] fold_mixin
end;;
</programlisting>
    </sect2>
  </sect1>
</chapter>
<chapter id="understanding-the-runtime-system">
  <title>Understanding the runtime system</title>
  <para>
    Much of the static type information contained within an OCaml
    program is checked and discarded at compilation time, leaving a much
    simpler <emphasis>runtime</emphasis> representation for values.
    Understanding this difference is important for writing efficient
    programs, and also for interfacing with C libraries that work
    directly with the runtime system.
  </para>
  <note>
  <title>
  Why do OCaml types disappear at runtime?
  </title>
  <para>
    The OCaml compiler runs through several phases of during the
    compilation process. After syntax checking, the next stage is
    <emphasis>type checking</emphasis>. In a validly typed program, a
    function cannot be applied with an unexpected type. For example, the
    <literal>print_endline</literal> function must receive a single
    <literal>string</literal> argument, and an <literal>int</literal>
    will result in a type error.
  </para>
  <para>
    Since OCaml verifies these properties at compile time, it doesn't
    need to keep track of as much information at runtime. Thus, later
    stages of the compiler can discard and simplify the type
    declarations to a much more minimal subset that's actually required
    to distinguish polymorphic values at runtime. This is a major
    performance win versus something like a Java or .NET method call,
    where the runtime must look up the concrete instance of the object
    and dispatch the method call. Those languages amortize some of the
    cost via &quot;Just-in-Time&quot; dynamic patching, but OCaml
    prefers runtime simplicity instead.
  </para>
  </note>
  <para>
    Let's start by explaining the memory layout, and then move onto the
    details of how C bindings work.
  </para>
  <sect1 id="the-garbage-collector">
    <title>The garbage collector</title>
    <para>
      A running OCaml program uses blocks of memory (i.e. contiguous
      sequences of words in RAM) to represent many of the values that it
      deals with such as tuples, records, closures or arrays. An OCaml
      program implicitly allocates a block of memory when such a value
      is created.
    </para>
    <programlisting>
# let x = { foo = 13; bar = 14 } ;;
</programlisting>
    <para>
      An expression such as the record above requires a new block of
      memory with two words of available space. One word holds the
      <literal>foo</literal> field and the second word holds the
      <literal>bar</literal> field. The OCaml compiler translates such
      an expression into an explicit allocation for the block from
      OCaml's runtime system: a C library that provides a collection of
      routines that can be called by running OCaml programs. The runtime
      system manages a <emphasis>heap</emphasis>, which a collection of
      memory regions it obtains from the operating system using
      <emphasis>malloc(3)</emphasis>. The OCaml runtime uses these
      memory regions to hold <emphasis>heap blocks</emphasis>, which it
      then fills up in response to allocation requests by the OCaml
      program.
    </para>
    <para>
      When there is'nt enough memory available to satisfy an allocation
      request from the allocated heap blocks, the runtime system invokes
      the <emphasis>garbage collector</emphasis> (or GC). An OCaml
      program does not explicitly free a heap block when it is done with
      it, and the GC must determine which heap blocks are
      &quot;alive&quot; and which heap blocks are
      <emphasis>dead</emphasis>, i.e. no longer in use. Dead blocks are
      collected and their memory made available for re-use by the
      application.
    </para>
    <para>
      The garbage collector does not keep constant track of blocks as
      they are allocated and used. Instead, it regularly scans blocks by
      starting from a set of <emphasis>roots</emphasis>, which are
      values that the application always has access to (such as the
      stack). The GC maintains a directed graph in which heap blocks are
      nodes, and there is an edge from heap block <literal>b1</literal>
      to heap block <literal>b2</literal> if some field of
      <literal>b1</literal> points to <literal>b2</literal>. All blocks
      reachable from the roots by following edges in the graph must be
      retained, and unreachable blocks can be reused.
    </para>
    <para>
      With the typical OCaml programming style, many small blocks are
      frequently allocated, used for a short period of time, and then
      never used again. OCaml takes advantage of this fact to improve
      the performance of allocation and collection by using a
      <emphasis>generational</emphasis> garbage collector. This means
      that it has different memory regions to hold blocks based on how
      long the blocks have been alive. OCaml's heap is split in two;
      there is a small, fixed-size <emphasis>minor heap</emphasis> used
      for initially allocating most blocks, and a large, variable-sized
      <emphasis>major heap</emphasis> for holding blocks that have been
      alive longer or are larger than 4KB. A typical functional
      programming style means that young blocks tend to die young, and
      old blocks tend to stay around for longer than young ones (this is
      referred to as the <emphasis>generational hypothesis</emphasis>).
      To reflect this, OCaml uses different memory layouts and garbage
      collection algorithms for the major and minor heaps.
    </para>
    <sect2 id="the-fast-minor-heap">
      <title>The fast minor heap</title>
      <para>
        The minor heap is one contiguous chunk of memory containing a
        sequence of heap blocks that have been allocated. If there is
        space, allocating a new block is a fast constant-time operation
        in which the pointer to the end of the heap is incremented by
        the desired size. To garbage collect the minor heap, OCaml uses
        <emphasis>copying collection</emphasis> to copy all live blocks
        in the minor heap to the major heap. This only takes work
        proportional to the number of live blocks in the minor heap,
        which is typically small according to the generational
        hypothesis.
      </para>
      <para>
        One complexity of generational collection is that in order to
        know which blocks in the minor heap are live, the collector must
        know which minor-heap blocks are directly pointed to by
        major-heap blocks. To do this, OCaml maintains a set of such
        inter-generational pointers, and, through cooperation with the
        compiler, uses a write barrier to update this set whenever a
        major-heap block is modified to point at a minor-heap block.
      </para>
    </sect2>
    <sect2 id="the-long-lived-major-heap">
      <title>The long-lived major heap</title>
      <para>
        The major heap consists of a number of chunks of memory, each
        containing live blocks interspersed with regions of free memory.
        The runtime system maintains a free list data structure that
        indexes all the free memory, and this list is used to satisfy
        allocation requests. OCaml uses mark and sweep garbage
        collection for the major heap. The <emphasis>mark</emphasis>
        phase to traverses the block graph and marks all live blocks by
        setting a bit in the color tag of the block header.
        (<emphasis>avsm</emphasis>: we only explain the color tag in the
        next section, so rephrase or xref).
      </para>
      <para>
        The <emphasis>sweep</emphasis> phase sequentially scans all heap
        memory and identifies dead blocks that weren't marked earlier.
        The <emphasis>compact</emphasis> phase relocates live blocks to
        eliminate the gaps of free memory between them and ensure memory
        does not fragment.
      </para>
      <para>
        A garbage collection must <emphasis>stop the world</emphasis>
        (that is, halt the application) in order to ensure that blocks
        can be safely moved. The mark and sweep phases run incrementally
        over slices of memory, and are broken up into a number of steps
        that are interspersed with the running OCaml program. Only a
        compaction touches all the memory in one go, and is a relatively
        rare operation.
      </para>
      <para>
        The <literal>Gc</literal> module lets you control all these
        parameters from your application, and we will discuss garbage
        collection tuning in (<emphasis>avsm</emphasis>: crossref).
      </para>
    </sect2>
  </sect1>
  <sect1 id="the-representation-of-values">
    <title>The representation of values</title>
    <para>
      Every OCaml <emphasis>value</emphasis> is a single word that is
      either an integer or a pointer. If the lowest bit of the word is
      non-zero, the value is an unboxed integer. Several OCaml types map
      onto this integer representation, including
      <literal>bool</literal>, <literal>int</literal>, the empty list,
      <literal>unit</literal>, and variants without constructors.
      Integers are the only unboxed runtime values in OCaml, and are the
      cheapest values to allocate.
    </para>
    <para>
      If the lowest bit of the <literal>value</literal> is zero, then
      the value is a pointer. A pointer value is stored unmodified,
      since pointers are guaranteed to be word-aligned and the bottom
      bits are always zero. If the pointer is inside an area managed by
      the OCaml runtime, it is assumed to point to an OCaml
      <emphasis>block</emphasis>. If it points outside the OCaml runtime
      area, it is is treated as an opaque C pointer to some other system
      resource.
    </para>
    <sect2 id="blocks-and-values">
      <title>Blocks and values</title>
      <para>
        An OCaml <emphasis>block</emphasis> is the basic unit of
        allocation on the heap. A block consists of a one-word header
        (either 32- or 64-bits) followed by variable-length data, which
        is either opaque bytes or <emphasis>fields</emphasis>. The
        collector never inspects opaque bytes, but fields are valid
        OCaml values. The runtime always inspects fields, and follows
        them as part of the garbage collection process described
        earlier. Every block header has a multipurpose tag byte that
        defines whether to interprete the subsequent data as opaque or
        OCaml fields.
      </para>
      <para>
        (<emphasis>avsm</emphasis>: pointers to blocks actually point
        4/8 bytes into it, for some efficiency reason that I cannot
        recall right now).
      </para>
      <programlisting>
+------------------------+-------+----------+----------+----------+----
| size of block in words |  col  | tag byte | value[0] | value[1] | ...
+------------------------+-------+----------+----------+----------+----
 &lt;-either 22 or 54 bits-&gt; &lt;2 bit&gt; &lt;--8 bit--&gt;
</programlisting>
      <para>
        The size field records the length of the block in memory words.
        Note that it is limited to 22-bits on 32-bit platforms, which is
        the reason why OCaml strings are limited to 16MB on that
        architecture. If you need bigger strings, either switch to a
        64-bit host, or use the <literal>Bigarray</literal> module
        (<emphasis>avsm</emphasis>: xref). The 2-bit color field is used
        by the garbage collector to keep track of its status, and is not
        exposed directly to OCaml programs.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left" />
          <colspec align="left" />
          <thead>
            <row>
              <entry>
                Tag Color
              </entry>
              <entry>
                Block Status
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                blue
              </entry>
              <entry>
                on the free list and not currently in use
              </entry>
            </row>
            <row>
              <entry>
                white
              </entry>
              <entry>
                not reached yet, but possibly reachable
              </entry>
            </row>
            <row>
              <entry>
                gray
              </entry>
              <entry>
                reachable, but its fields have not been scanned
              </entry>
            </row>
            <row>
              <entry>
                black
              </entry>
              <entry>
                reachable, and its fields have been scanned
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        A block's tag byte is multi-purpose, and indicates whether the
        data array represents opaque bytes or fields. If a block's tag
        is greater than or equal to <literal>No_scan_tag</literal>
        (251), then the block's data are all opaque bytes, and are not
        scanned by the collector. The most common such block is the
        <literal>string</literal> type, which we describe more below.
      </para>
      <para>
        (<emphasis>avsm</emphasis>: too much info here) If the header is
        zero, then the object has been forwarded as part of minor
        collection, and the first field points to the new location.
        Also, if the block is on the
        <literal>oldify_todo_list</literal>, part of the minor gc, then
        the second field points to the next entry on the
        oldify_todo_list.
      </para>
      <para>
        The exact representation of values inside a block depends on
        their OCaml type. They are summarised in the table below, and
        then we'll examine some of them in greater detail.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left" />
          <colspec align="left" />
          <thead>
            <row>
              <entry>
                OCaml Value
              </entry>
              <entry>
                Representation
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                any <literal>int</literal> or <literal>char</literal>
              </entry>
              <entry>
                directly as a value, shifted left by 1 bit, with the
                least significant bit set to 1
              </entry>
            </row>
            <row>
              <entry>
                <literal>unit</literal>, <literal>[]</literal>,
                <literal>false</literal>
              </entry>
              <entry>
                as OCaml <literal>int</literal> 0.
              </entry>
            </row>
            <row>
              <entry>
                <literal>true</literal>
              </entry>
              <entry>
                as OCaml <literal>int</literal> 1.
              </entry>
            </row>
            <row>
              <entry>
                <literal>Foo | Bar</literal>
              </entry>
              <entry>
                as ascending OCaml <literal>int</literal>s, starting
                from 0.
              </entry>
            </row>
            <row>
              <entry>
                <literal>Foo | Bar of int</literal>
              </entry>
              <entry>
                variants with parameters are boxed, while entries with
                no parameters are unboxed (see below).
              </entry>
            </row>
            <row>
              <entry>
                polymorphic variants
              </entry>
              <entry>
                variable space usage depending on the number of
                parameters (see below).
              </entry>
            </row>
            <row>
              <entry>
                floating point number
              </entry>
              <entry>
                as a block with a single field containing the
                double-precision float.
              </entry>
            </row>
            <row>
              <entry>
                string
              </entry>
              <entry>
                word-aligned byte arrays that are also directly
                compatible with C strings.
              </entry>
            </row>
            <row>
              <entry>
                <literal>[1; 2; 3]</literal>
              </entry>
              <entry>
                as <literal>1::2::3::[]</literal> where
                <literal>[]</literal> is an int, and
                <literal>h::t</literal> a block with tag 0 and two
                parameters.
              </entry>
            </row>
            <row>
              <entry>
                tuples, records and arrays
              </entry>
              <entry>
                an array of values. Arrays can be variable size, but
                structs and tuples are fixed size.
              </entry>
            </row>
            <row>
              <entry>
                records or arrays, all float
              </entry>
              <entry>
                special tag for unboxed arrays of floats. Doesn't apply
                to tuples.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>
    <sect2 id="integers-characters-and-other-basic-types">
      <title>Integers, characters and other basic types</title>
      <para>
        Many basic types are stored directly as unboxed values at
        runtime. The native <literal>int</literal> type is the most
        obvious, although it drops a single bit of precision due to the
        tag bit described earlier. Other atomic types such as the
        <literal>unit</literal> and empty list <literal>[]</literal>
        value are stored as constant integers. Boolean values have a
        value of <literal>0</literal> and <literal>1</literal> for
        <literal>true</literal> and <literal>false</literal>
        respectively.
      </para>
      <note>
      <title>
      Why are OCaml integers missing a bit?
      </title>
      <para>
        Since the lowest bit of an OCaml value is reserved, native OCaml
        integers have a maximum allowable length of 31- or 63-bits,
        depending on the host architecture. The rationale for reserving
        the lowest bit is for efficiency. Pointers always point to
        word-aligned addresses, and so their lower bits are normally
        zero. By setting the lower bit to a non-zero value for integers,
        the garbage collector can simply iterate over every header tag
        to distinguish integers from pointers. This reduces the garbage
        collection overhead on the overall program.
      </para>
      </note>
      <para>
        (<emphasis>avsm</emphasis>: explain that integer manipulation is
        almost as fast due to isa quirks)
      </para>
    </sect2>
    <sect2 id="tuples-records-and-arrays">
      <title>Tuples, records and arrays</title>
      <programlisting>
+---------+----------+----------- - - - - 
| header  | value[0] | value[1] | ....
+---------+----------+----------+- - - - -
</programlisting>
      <para>
        Tuples, records and arrays are all represented identically at
        runtime, with a block with tag <literal>0</literal>. Tuples and
        records have constant sizes determined at compile-time, whereas
        arrays can be of variable length. While arrays are restricted to
        containing a single type of element in the OCaml type system,
        this is not required by the memory representation.
      </para>
      <para>
        You can check the difference between a block and a direct
        integer yourself using the <literal>Obj</literal> module, which
        exposes the internal representation of values to OCaml code.
      </para>
      <programlisting>
# Obj.is_block (Obj.repr (1,2,3)) ;;
- : bool = true
# Obj.is_block (Obj.repr 1) ;;
- : bool = false
</programlisting>
      <para>
        The <literal>Obj.repr</literal> function retrieves the runtime
        representation of any OCaml value.
        <literal>Obj.is_block</literal> checks the bottom bit to
        determine if the value is a block header or an unboxed integer.
      </para>
    </sect2>
    <sect2 id="floating-point-numbers-and-arrays">
      <title>Floating point numbers and arrays</title>
      <para>
        Floating point numbers in OCaml are always stored as full
        double-precision values. Individual floating point values are
        stored as a block with a single field that contains the number.
        This block has the <literal>Double_tag</literal> set which
        signals to the collector that the floating point value is not to
        be scanned.
      </para>
      <programlisting>
# Obj.tag (Obj.repr 1.0) = Obj.double_tag ;;
- : int = 253
# Obj.double_tag ;;
- : int = 253
</programlisting>
      <para>
        Since each floating-point value is boxed in a separate memory
        block, it can be inefficient to handle large arrays of floats in
        comparison to unboxed integers. OCaml therefore special-cases
        records or arrays that contain <emphasis>only</emphasis>
        <literal>float</literal> types. These are stored in a block that
        contains the floats packed directly in the data section, with
        the <literal>Double_array_tag</literal> set to signal to the
        collector that the contents are not OCaml values.
      </para>
      <programlisting>
+---------+----------+----------- - - - - 
| header  | float[0] | float[1] | ....
+---------+----------+----------+- - - - -
</programlisting>
      <para>
        You can test this for yourself using the
        <literal>Obj.tag</literal> function to check that the allocated
        block has the expected runtime tag, and
        <literal>Obj.double_field</literal> to retrieve a float from
        within the block.
      </para>
      <programlisting>
# open Obj ;;
# tag (repr [| 1.0; 2.0; 3.0 |]) ;;
- : int = 254
# tag (repr (1.0, 2.0, 3.0) ) ;;
- : int = 0 
# double_field (repr [| 1.1; 2.2; 3.3 |] ) 1 ;;
- : float = 2.2
# Obj.double_field (Obj.repr 1.234) 0;;
- : float = 1.234
</programlisting>
      <para>
        Notice that float tuples are <emphasis>not</emphasis> optimized
        in the same way as float records or arrays, and so they have the
        usual tuple tag value of <literal>0</literal>. Only records and
        arrays can have the array optimization, and only if every single
        field is a float.
      </para>
    </sect2>
    <sect2 id="variants-and-lists">
      <title>Variants and lists</title>
      <para>
        Basic variant types with no extra parameters for any of their
        branches are simply stored as an OCaml integer, starting with
        <literal>0</literal> for the first option and in ascending
        order.
      </para>
      <programlisting>
# open Obj ;;
# type t = Apple | Orange | Pear ;;
type t = Apple | Orange | Pear
# ((magic (repr Apple)) : int) ;;
- : int = 0
# ((magic (repr Pear)) : int) ;;
- : int = 2
# is_block (repr Apple) ;;
- : bool = false
</programlisting>
      <para>
        <literal>Obj.magic</literal> unsafely forces a type cast between
        any two OCaml types; in this example the <literal>int</literal>
        type hint retrieves the runtime integer value. The
        <literal>Obj.is_block</literal> confirms that the value isn't a
        more complex block, but just an OCaml <literal>int</literal>.
      </para>
      <para>
        Variants that have parameters arguments are a little more
        complex. They are stored as blocks, with the value
        <emphasis>tags</emphasis> ascending from 0 (counting from
        leftmost variants with parameters). The parameters are stored as
        words in the block.
      </para>
      <programlisting>
# type t = Apple | Orange of int | Pear of string | Kiwi ;;
type t = Apple | Orange of int | Pear of string | Kiwi
# is_block (repr (Orange 1234)) ;;
- : bool = true
# tag (repr (Orange 1234)) ;; 
- : int = 0
# tag (repr (Pear &quot;xyz&quot;)) ;;
- : int = 1
# (magic (field (repr (Orange 1234)) 0) : int) ;;
- : int = 1234
(magic (field (repr (Pear &quot;xyz&quot;)) 0) : string) ;;
- : string = &quot;xyz&quot;
</programlisting>
      <para>
        In the above example, the <literal>Apple</literal> and
        <literal>Kiwi</literal> values are still stored as normal OCaml
        integers with values <literal>0</literal> and
        <literal>1</literal> respectively. The <literal>Orange</literal>
        and <literal>Pear</literal> values both have parameters, and are
        stored as blocks whose tags ascend from <literal>0</literal>
        (and so <literal>Pear</literal> has a tag of
        <literal>1</literal>, as the use of <literal>Obj.tag</literal>
        verifies). Finally, the parameters are fields which contain
        OCaml values within the block, and <literal>Obj.field</literal>
        can be used to retrieve them.
      </para>
      <para>
        Lists are stored with a representation that is exactly the same
        as if the list was written as a variant type with
        <literal>Head</literal> and <literal>Cons</literal>. The empty
        list <literal>[]</literal> is an integer <literal>0</literal>,
        and subsequent blocks have tag <literal>0</literal> and two
        parameters: a block with the current value, and a pointer to the
        rest of the list.
      </para>
      <warning>
      <title>
      <literal>Obj</literal> module considered harmful
      </title>
      <para>
        The <literal>Obj</literal> module is an undocumented module that
        exposes the internals of the OCaml compiler and runtime. It is
        very useful for examining and understanding how your code will
        behave at runtime, but should <emphasis>never</emphasis> be used
        for production code unless you understand the implications. The
        module bypasses the OCaml type system, making memory corruption
        and segmentation faults possible.
      </para>
      <para>
        Some theorem provers such as Coq do output code which uses
        <literal>Obj</literal> internally, but the external module
        signatures never expose it. Unless you too have a machine proof
        of correctness to accompany your use of <literal>Obj</literal>,
        stay away from it except for debugging!
      </para>
      </warning>
      <para>
        Due to this encoding, there is a limit around 240 variants with
        parameters that applies to each type definition, but the only
        limit on the number of variants without parameters is the size
        of the native integer (either 31- or 63-bits). This limit arises
        because of the size of the tag byte, and that some of the high
        numbered tags are reserved.
      </para>
    </sect2>
    <sect2 id="polymorphic-variants-1">
      <title>Polymorphic variants</title>
      <para>
        Polymorphic variants are more flexible than normal variants when
        writing code, but can be less efficient at runtime. This is
        because there isn't as much static compile-time information
        available to optimise their memory layout. This isn't always the
        case, however. A polymorphic variant without any parameters is
        stored as an unboxed integer and so only takes up one word of
        memory. Unlike normal variants, the integer value is determined
        by apply a hash function to the <emphasis>name</emphasis> of the
        variant. The hash function isn't exposed directly by the
        compiler, but the <literal>type_conv</literal> library from Core
        provides an alternative implementation.
      </para>
      <programlisting>
# #require &quot;type_conv&quot; ;;
# Pa_type_conv.hash_variant &quot;Foo&quot; ;;
- : int = 3505894
# (Obj.magic (Obj.repr `Foo) : int) ;;
- : int = 3505894
</programlisting>
      <para>
        The hash function is designed to give the same results on 32-bit
        and 64-bit architectures, so the memory representation is stable
        across different CPUs and host types.
      </para>
      <para>
        Polymorphic variants use more memory space when parameters are
        included in the datatype constructors. Normal variants use the
        tag byte to encode the variant value, but this byte is
        insufficient to encode the hashed value for polymoprhic
        variants. Therefore, they must allocate a new block (with tag
        <literal>0</literal>) and store the value in there instead. This
        means that polymorphic variants with constructors use one word
        of memory more than normal variant constructors.
      </para>
      <para>
        Another inefficiency is when a polymorphic variant constructor
        has more than one parameter. Normal variants hold parameters as
        a single flat block with multiple fields for each entry, but
        polymorphic variants must adopt a more flexible uniform memory
        representation since they may be re-used in a different context.
        They allocate a tuple block for the parameters that is pointed
        to from the argument field of the variant. Thus, there are three
        additional words for such variants, along with an extra memory
        indirection due to the tuple.
      </para>
    </sect2>
    <sect2 id="string-values">
      <title>String values</title>
      <para>
        Strings are standard OCaml blocks with the header size defining
        the size of the string in machine words. The
        <literal>String_tag</literal> (252) is higher than the
        <literal>No_scan_tag</literal>, indicating that the contents of
        the block are opaque to the collector. The block contents are
        the contents of the string, with padding bytes to align the
        block on a word boundary.
      </para>
      <programlisting>
+---------------+----------------+--------+-----------+
| header        | 'a' 'b' 'c' 'd' 'e' 'f' | '\O' '\1' |
+---------------+----------------+--------+-----------+
                L data                    L padding
</programlisting>
      <para>
        On a 32-bit machine, the padding is calculated based on the
        modulo of the string length and word size to ensure the result
        is word-aligned. A 64-bit machine extends the potential padding
        up to 7 bytes instead of 3.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left" />
          <colspec align="left" />
          <thead>
            <row>
              <entry>
                String length mod 4
              </entry>
              <entry>
                Padding
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                0
              </entry>
              <entry>
                <literal>00 00 00 03</literal>
              </entry>
            </row>
            <row>
              <entry>
                1
              </entry>
              <entry>
                <literal>00 00 02</literal>
              </entry>
            </row>
            <row>
              <entry>
                2
              </entry>
              <entry>
                <literal>00 01</literal>
              </entry>
            </row>
            <row>
              <entry>
                3
              </entry>
              <entry>
                <literal>00</literal>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        This string representation is a clever way to ensure that the
        string contents are always zero-terminated by the padding word,
        and still compute its length efficiently without scanning the
        whole string. The following formula is used:
      </para>
      <programlisting>
number_of_words_in_block * sizeof(word) - last_byte_of_block - 1
</programlisting>
      <para>
        The guaranteed NULL-termination comes in handy when passing a
        string to C, but is not relied upon to compute the length from
        OCaml code. Thus, OCaml strings can contain null bytes at any
        point within the string, but care should be taken that any C
        library functions can also cope with this.
      </para>
    </sect2>
    <sect2 id="custom-heap-blocks">
      <title>Custom heap blocks</title>
      <para>
        OCaml supports <emphasis>custom</emphasis> heap blocks via a
        <literal>Custom_tag</literal> that let the runtime perform
        user-defined operations over OCaml values. A custom block lives
        in the OCaml heap like an ordinary block and can be of whatever
        size the user desires. The <literal>Custom_tag</literal> (255)
        is higher than <literal>No_scan_tag</literal> and so cannot
        contain any OCaml values.
      </para>
      <para>
        The first word of the data within the custom block is a C
        pointer to a <literal>struct</literal> of custom operations. The
        custom block cannot have pointers to OCaml blocks and is opaque
        to the garbage collector.
      </para>
      <programlisting>
struct custom_operations {
  char *identifier;
  void (*finalize)(value v);
  int (*compare)(value v1, value v2);
  intnat (*hash)(value v);
  void (*serialize)(value v,
                    /*out*/ uintnat * wsize_32 /*size in bytes*/,
                    /*out*/ uintnat * wsize_64 /*size in bytes*/);
  uintnat (*deserialize)(void * dst);
  int (*compare_ext)(value v1, value v2);
};
</programlisting>
      <para>
        The custom operations specify how the runtime should perform
        polymorphic comparison, hashing and binary marshalling. They
        also optionally contain a finalizer, which the runtime will call
        just before the block is garbage collected. This finalizer has
        nothing to do with ordinary OCaml finalizers, as created by
        <literal>Gc.finalise</literal>. (<emphasis>avsm</emphasis>: xref
        to GC module explanation)
      </para>
      <para>
        When a custom block is allocated, you can also specify the
        proportion of &quot;extra-heap resources&quot; consumed by the
        block, which will affect the garbage collector's decision as to
        how much work to do in the next major slice.
        (<emphasis>avsm</emphasis>: elaborate on this or move to the C
        interface section)
      </para>
    </sect2>
  </sect1>
  <sect1 id="interfacing-with-c">
    <title>Interfacing with C</title>
    <para>
      Now that you understand the runtime structure of the garbage
      collector, interfacing with C libraries is actually pretty simple.
      OCaml defines an <literal>external</literal> keyword that maps
      OCaml functions to a C symbol. That C function will be passed the
      arguments with the C <literal>value</literal> type which
      corresponds to the memory layout for OCaml values described
      earlier.
    </para>
    <sect2 id="getting-started-with-a-hello-world-c-binding">
      <title>Getting started with a &quot;Hello World&quot; C
      binding</title>
      <para>
        Let's define a simple &quot;Hello World&quot; C binding to see
        how this works. First create a <literal>hello.ml</literal> that
        contains the external declaration:
      </para>
      <programlisting language="ocaml">
external hello_world: unit -&gt; unit = &quot;caml_hello_world&quot;
let _ = hello_world ()
</programlisting>
      <para>
        If you try to compile this module now, you should receive a
        linker error:
      </para>
      <programlisting>
$ ocamlopt -o hello hello.ml
Undefined symbols for architecture x86_64:
  &quot;_caml_hello_world&quot;, referenced from:
      .L100 in hello.o
      _camlHello in hello.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
File &quot;caml_startup&quot;, line 1:
Error: Error during linking
</programlisting>
      <para>
        This is the system linker telling you that there is a missing
        <literal>caml_hello_world</literal> symbol that must be provided
        before a binary can be linked. Now create a file called
        <literal>hello_stubs.c</literal> which contains the C function.
      </para>
      <programlisting language="c">
#include &lt;stdio.h&gt;
#include &lt;caml/mlvalues.h&gt;

CAMLprim value
caml_hello_world(value v_unit)
{
  printf(&quot;Hello OCaml World!\n&quot;);
  return Val_unit;
}
</programlisting>
      <para>
        Now attempt to recompile the <literal>hello</literal> binary
        with the C file also included in the compiler invocation, and it
        should succeed:
      </para>
      <programlisting>
$ ocamlopt -o hello hello.ml hello_stubs.c
$ ./hello
Hello OCaml World!
</programlisting>
      <para>
        The compiler uses the file extensions to determine how to
        compile each file. In the case of the <literal>.c</literal>
        extension, it passes it to the system C compiler and appends an
        include directory containing the OCaml runtime header files that
        define conversion functions to-and-from OCaml values.
      </para>
      <para>
        The <literal>mlvalues.h</literal> header is the basic header
        that all C bindings need. Locate it in your system by using
        <literal>ocamlc -where</literal> to find your system OCaml
        installation. It defines a few important typedefs early on that
        should be familiar after the earlier explanations:
      </para>
      <programlisting language="C">
typedef intnat value;

#define Is_long(x)   (((x) &amp; 1) != 0)
#define Is_block(x)  (((x) &amp; 1) == 0)

#define Val_unit Val_int(0)
</programlisting>
      <para>
        The <literal>value</literal> typedef is a word that can either
        be an integer if <literal>Is_long</literal> is true, or a heap
        block if <literal>Is_block</literal> is true. Our C function
        definition of <literal>caml_hello_world</literal> accepts a
        single parameter, and returns a <literal>value</literal>. In our
        simple example, all the types of parameters and returns are
        <literal>unit</literal>, and so we use the
        <literal>Val_unit</literal> macro to construct the return value.
      </para>
      <para>
        You must be <emphasis>very</emphasis> careful that the value you
        return from the C function corresponds exactly to the memory
        representation of the types you declared earlier in the
        <literal>external</literal> declaration of the ML file, or else
        heap carnage and corruption will ensure.
      </para>
      <tip>
      <title>
      Activating the debug runtime
      </title>
      <para>
        Despite your best efforts, it is easy to introduce a bug into C
        bindings that cause heap invariants to be violated. OCaml
        includes a variant of the runtime library that is compiled with
        debugging symbols, and includes regular memory integrity checks
        upon every garbage collection. Running these often will abort
        the program near the point of corruption and helps track it down
        quickly.
      </para>
      <para>
        To use this, just recompile with
        <literal>-runtime-variant d</literal> set:
      </para>
      <programlisting>
$ ocamlopt -runtime-variant d -verbose -o hello hello.ml hello_stubs.c
$ ./hello 
### OCaml runtime: debug mode ###
Initial minor heap size: 2048k bytes
Initial major heap size: 992k bytes
Initial space overhead: 80%
Initial max overhead: 500%
Initial heap increment: 992k bytes
Initial allocation policy: 0
Hello OCaml World!
</programlisting>
      </tip>

    </sect2>
  </sect1>
</chapter>
<chapter id="managing-external-memory-with-bigarrays">
  <title>Managing external memory with Bigarrays</title>
  <sect1 id="bigarrays-for-external-memory-blocks">
    <title>Bigarrays for external memory blocks</title>
    <para>
      An OCaml bigarray is a useful custom block provided as standard to
      manipulate memory blocks outside the OCaml heap. It has
      <literal>Custom_tag</literal> in the header, and the first word
      points to the <literal>custom_operations</literal> struct for
      bigarrays. Following this is a <literal>caml_ba_array</literal>
      struct.
    </para>
    <programlisting>
struct caml_ba_array {
  void * data;                  /* Pointer to raw data */
  intnat num_dims;              /* Number of dimensions */
  intnat flags;                 /* Kind of element array + memory layout + allocation status */
  struct caml_ba_proxy * proxy; /* The proxy for sub-arrays, or NULL */
  intnat dim[]  /*[num_dims]*/; /* Size in each dimension */
};
</programlisting>
    <para>
      The <literal>data</literal> is usually a pointer to a
      <literal>malloc</literal>'ed chunk of memory, which the custom
      finalizer operation <literal>free</literal>'s when the block is
      free. The <literal>flags</literal> field encodes three values,
      located in the bits as specified by three masks:
    </para>
    <programlisting>
CAML_BA_KIND_MASK = 0xFF     /* Mask for kind in flags field */
CAML_BA_LAYOUT_MASK = 0x100  /* Mask for layout in flags field */
CAML_BA_MANAGED_MASK = 0x600 /* Mask for &quot;managed&quot; bits in flags field */
</programlisting>
    <para>
      The <literal>CAML_BA_KIND_MASK</literal> bits hold a value of the
      <literal>caml_ba_kind</literal> enum that identifies the kind of
      value in the bigarray <literal>data</literal>.
    </para>
    <programlisting>
enum caml_ba_kind {
  CAML_BA_FLOAT32,             /* Single-precision floats */
  CAML_BA_FLOAT64,             /* Double-precision floats */
  CAML_BA_SINT8,               /* Signed 8-bit integers */
  CAML_BA_UINT8,               /* Unsigned 8-bit integers */
  CAML_BA_SINT16,              /* Signed 16-bit integers */
  CAML_BA_UINT16,              /* Unsigned 16-bit integers */
  CAML_BA_INT32,               /* Signed 32-bit integers */
  CAML_BA_INT64,               /* Signed 64-bit integers */
  CAML_BA_CAML_INT,            /* OCaml-style integers (signed 31 or 63 bits) */
  CAML_BA_NATIVE_INT,          /* Platform-native long integers (32 or 64 bits) */
  CAML_BA_COMPLEX32,           /* Single-precision complex */
  CAML_BA_COMPLEX64,           /* Double-precision complex */
}
</programlisting>
    <para>
      The <literal>CAML_BA_LAYOUT_MASK</literal> bit says whether
      multi-dimensional arrays are layed out C or Fortran style.
    </para>
    <programlisting>
enum caml_ba_layout {
  CAML_BA_C_LAYOUT = 0,           /* Row major, indices start at 0 */
  CAML_BA_FORTRAN_LAYOUT = 0x100, /* Column major, indices start at 1 */
};
</programlisting>
    <para>
      The <literal>CAML_BA_MANAGED_MASK</literal> bits hold a value of
      the <literal>caml_ba_managed</literal> enum that identifies
      whether OCaml is responsible for freeing the
      <literal>data</literal> or some other code is.
    </para>
    <programlisting>
enum caml_ba_managed {
  CAML_BA_EXTERNAL = 0,        /* Data is not allocated by OCaml */
  CAML_BA_MANAGED = 0x200,     /* Data is allocated by OCaml */
  CAML_BA_MAPPED_FILE = 0x400, /* Data is a memory mapped file */
};
</programlisting>
  </sect1>
</chapter>
<chapter id="inside-the-runtime">
  <title>Inside the Runtime</title>
  <para>
    (<emphasis>avsm</emphasis>: this chapter is still being chopped and
    changed)
  </para>
  <sect1 id="runtime-memory-management">
    <title>Runtime Memory Management</title>
    <para>
      The OCaml runtime divides the address space into memory pages of
      4KB each (this is configurable by recompiling the runtime). At any
      given time, every page that is in use is used for a single
      purpose: major heap, minor heap, static data or code. The runtime
      guarantees this by always allocating slightly more memory than
      requested so that that it can choose align the memory it will
      actually use at the beginning of a 4KB page.
    </para>
    <para>
      The runtime maintains a <emphasis>page table</emphasis> that
      allows it to determine the status of any virtual memory address in
      the operating system process. The status defines whether that
      address is a page in use by the OCaml runtime, and if so, which of
      the four purposes it is being used for.
    </para>
    <para>
      Since the virtual memory space can be very large and sparsely used
      (especially on a 64-bit CPU), the page table is implemented as a
      hash table in which keys are page-aligned addresses and values are
      a single byte. The hash table is represented as an array of words,
      with each word being a key-value pair. The key-value pair is the
      bitwise <literal>or</literal> of the virtual address of the start
      of the page (which has zeros for its lower 12-bits due to being
      aligned to 4KB), and the lower 8 bits are used for the value. To
      look up an address, one masks out the lower 12-bits of the memory
      address, compute a multiplicative hash to get a table index, and
      then compares against the address (i.e. the key) at that index.
      Linear probing is used to resolve collisions.
    </para>
    <para>
      The byte value stored is a bitwise <literal>or</literal> of the
      following status bits:
    </para>
    <informaltable>
      <tgroup cols="3">
        <colspec align="left" />
        <colspec align="left" />
        <colspec align="left" />
        <thead>
          <row>
            <entry>
              Page table status
            </entry>
            <entry>
              Value
            </entry>
            <entry>
              Meaning
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <literal>In_heap</literal>
            </entry>
            <entry>
              1
            </entry>
            <entry>
              in the major heap
            </entry>
          </row>
          <row>
            <entry>
              <literal>In_young</literal>
            </entry>
            <entry>
              2
            </entry>
            <entry>
              in the minor heap
            </entry>
          </row>
          <row>
            <entry>
              <literal>In_static_data</literal>
            </entry>
            <entry>
              4
            </entry>
            <entry>
              in the statically allocated data segment
            </entry>
          </row>
          <row>
            <entry>
              <literal>In_code_area</literal>
            </entry>
            <entry>
              8
            </entry>
            <entry>
              in the statically allocated code segment
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      The page table starts with a size aiming to be between 25% and 50%
      full of entries, and is automatically doubled in size if it
      becomes half full. It is never shrunk.
    </para>
    <sect2 id="allocating-on-the-minor-heap">
      <title>Allocating on the minor heap</title>
      <para>
        The minor heap is a contiguous chunk of virtual memory. Its size
        is set on program startup and decided by the
        <literal>OCAMLRUNPARAM</literal> environment variable
        (<emphasis>avsm</emphasis>: xref), and then only changed later
        by calls to <literal>Gc.set</literal>. The default size is 256k.
      </para>
      <para>
        The range of memory usable for allocation goes from the
        <literal>caml_young_start</literal> to
        <literal>caml_young_end</literal> C variables managed by the
        runtime.
      </para>
      <programlisting>
                &lt;---- size ----&gt;
 base --- start ---------------- end
          limit      ptr &lt;------
                          blocks
</programlisting>
      <para>
        In a fresh minor heap, the <literal>limit</literal> will equal
        the <literal>start</literal>, and the current
        <literal>ptr</literal> will equal the <literal>end</literal>. As
        blocks are allocated, <literal>caml_young_ptr</literal> will
        decrease until it reaches <literal>caml_young_limit</literal>,
        at which point a minor garbage collection is triggered. To
        allocate a block in the minor heap, we decrement
        <literal>caml_young_ptr</literal> by the size of the block
        (including the header), and then set the the header to a valid
        value. If there isn't enough space left for the block without
        decrementing past the <literal>limit</literal>, a minor
        collection is triggered.
      </para>
      <para>
        To force a minor gc to occur, one can set the
        <literal>caml_young_limit</literal> to equal
        <literal>caml_young_end</literal>, which causes signal handlers
        to be run and to &quot;urge&quot; the runtime
        (<emphasis>avsm</emphasis>: elaborate on this urging business,
        and how to set young from within OCaml via
        <literal>Gc.??</literal>).
      </para>
    </sect2>
    <sect2 id="allocating-on-the-major-heap">
      <title>Allocating on the major heap</title>
      <para>
        The major heap is a singly linked list of contiguous memory
        chunks, sorted in increasing order of virtual address. Each
        chunk is a single memory chunk allocated via
        <emphasis>malloc(3)</emphasis> and consists of a header and a
        data area which contains OCaml blocks. A pointer to a heap chunk
        points to the start of the data area, and access to the header
        is done by a negative offset from this pointer. A chunk header
        has:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            the address of the memory that the chunk is in, as allocated
            by <emphasis>malloc(3)</emphasis>. It is needed when the
            chunk is freed.
          </para>
        </listitem>
        <listitem>
          <para>
            the size in bytes of the data area
          </para>
        </listitem>
        <listitem>
          <para>
            an allocation size in bytes, used during heap compaction to
            merge small blocks to defragment the heap.
          </para>
        </listitem>
        <listitem>
          <para>
            a link to the next heap chunk in the list.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The chunk's data area always starts on a page boundary, and its
        size is a multiple of the page size (4KB). It contains a
        contiguous sequence of heap blocks. These can be as small as one
        or two 4KB pages, but are usually allocated in 1MB chunks (or
        512KB on 32-bit architectures). You can modify these defaults by
        editing <literal>Heap_chunk_def</literal> in
        <literal>byterun/config.h</literal> and recompiling the runtime.
        (<emphasis>avsm</emphasis>: talk about modifying the defaults in
        a separate callout, as there are quite a few variables which can
        be tweaked)
      </para>
      <para>
        Allocating a block on the major heap first checks the free list
        of blocks (see below). If there isn't enough room on the free
        list, the runtime expands the major heap with a fresh block that
        will be large enough. That block is then added to the free list,
        and the free list is checked again (and this time will
        definitely succeed).
      </para>
    </sect2>
    <sect2 id="the-major-heap-free-list">
      <title>The major heap free list</title>
      <para>
        The free space in the major heap's chunks is organized as a
        singly linked list of OCaml blocks, ordered by increasing
        virtual address. The runtime has a pointer to the first block in
        the free list. A free list block is at least two words: a header
        followed by a pointer to the next free-list block. The header
        specifies the length of the block just as with a normal block.
        (<emphasis>avsm</emphasis>: I'm not sure that this is quite
        true. It seems from <literal>freelist.c</literal> that the
        freelist blocks are normal OCaml blocks, with the first data
        entry being the next pointer. when detached, they become normal
        ocaml blocks)
      </para>
      <para>
        As soon as the runtime finds a free block that is larger than
        the request, there are three possibilities:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            If the free block is exactly the right size, it is unlinked
            from the free list and returned as the requested block.
          </para>
        </listitem>
        <listitem>
          <para>
            If the free block is one word too large, it is unlinked from
            the free list, and the first word is given a special header
            recognizable to the collector as an unused word, while the
            rest of the block is returned as the requested block.
          </para>
        </listitem>
        <listitem>
          <para>
            If the free block is two or more words larger than the
            requested block, it remains in the free list, with its
            length shortened, and the end of the free block is returned
            for the requested block. Since the allocated block is
            right-justified within the free block, the linking of the
            free list doesn't need to be changed at all as the block
            that remains in the free list is the original one.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2 id="memory-allocation-strategies">
      <title>Memory allocation strategies</title>
      <para>
        Allocating a new block in the major heap always looks in the
        free list. There are two allocation policies: first fit and next
        fit (the default).
      </para>
      <sect3 id="next-fit-allocation">
        <title>Next-fit allocation</title>
        <para>
          Next-fit allocation keeps a pointer to the block in the free
          list that was most recently used to satisfy a request. When a
          new request comes in, the allocator searches from the next
          block until the end of the free list, and then from the
          beginning of the free list up to that block.
        </para>
      </sect3>
      <sect3 id="first-fit-allocation">
        <title>First-fit allocation</title>
        <para>
          First-fit allocation focusses on reducing memory
          fragmentation, at the expense of slower block allocation. For
          some workloads, the reduction in the frequency in heap
          compaction will outweigh the extra allocation cost.
          (<emphasis>avsm</emphasis>: example?)
        </para>
        <para>
          The runtime maintains an ordered array of freelist chunks,
          called the <literal>flp</literal> array. Imagine a function
          mapping a block's index in the free list to its size. The flp
          array pointers are to the high points of this graph. That is,
          if you walk the free list between <literal>flp[i]</literal>
          and <literal>flp[i+1]</literal>, you will come across blocks
          that have sizes at most the size of <literal>flp[i]</literal>.
          Furthermore this sequence of smaller-than-flp[i] blocks cannot
          be extended, which is equivalent to saying
          <literal>size(flp[i+1]) &gt; size(flp[i])</literal>.
        </para>
        <para>
          When allocating, we first check the flp-array. If
          <literal>flp[i]</literal> is not big enough for our new block,
          then we may as well skip to <literal>flp[i+1]</literal>,
          because everything in the free list before then will also be
          too small.
        </para>
        <para>
          If there's nothing big enough in the <literal>flp</literal>
          array, we extend it by walking the free list starting at the
          <emphasis>last</emphasis> pointer in the
          <literal>flp</literal>-array, say <literal>flp[N]</literal>.
          We extend the <literal>flp</literal> array along the way, so
          that at each block, if this block is bigger than the current
          last thing in <literal>flp</literal> (which is equivalent to
          saying this is the biggest block we've ever seen, since the
          blocks pointed to by the <subscript>flp</subscript> array are
          increasing in size), we add it to the end of
          <subscript>flp</subscript>. We stop this walk when we come
          across a block big enough to house our desired new block.
        </para>
        <para>
          There's also the case when the <literal>flp</literal> array
          has its ceiling size of <literal>FLP_MAX</literal> (default
          100). Then we just start at the end of the
          <literal>flp</literal> array and walk until we find something
          big enough. This is known in the as a slow first-fit search,
          since this linear walk may take a long time.
        </para>
        <para>
          If we did manage to find something suitable in the
          <literal>flp</literal> array, say at index
          <literal>i</literal>, we need to update
          <literal>flp</literal>. This update is rather complex, and the
          reason why first-fit allocation is slower than next-fit. We
          walk through the free list between <literal>flp[i-1]</literal>
          and <literal>flp[i]</literal> and record every high point we
          come across. Say we find <literal>j</literal> such points. We
          move the upper portion of <literal>flp</literal> (from
          <literal>flp[i+1]</literal> to the end) to the right by
          <literal>j</literal> places and insert each new high point
          into the array. There is a further corner case when adding in
          <literal>j</literal> new high points would make
          <literal>flp</literal> bigger than <literal>FLP_MAX</literal>.
        </para>
        <para>
          (<emphasis>avsm</emphasis>: this really needs a diagram)
        </para>
        <note>
        <title>
        Which allocation policy should I use?
        </title>
        <para>
          (<emphasis>avsm</emphasis>: 0 is the next-fit policy, which is
          quite fast but can result in fragmentation. 1 is the first-fit
          policy, which can be slower in some cases but can be better
          for programs with fragmentation problems. )
        </para>
        </note>
      </sect3>
    </sect2>
    <sect2 id="inter-generational-pointers">
      <title>Inter-generational pointers</title>
      <para>
        Most incremental generational garbage collectors have to keep
        careful track of values pointing from old generations to younger
        ones. The OCaml runtime is no exception, and maintains a set of
        addresses in the major heap that may point into the minor heap.
        These addresses are <emphasis>not</emphasis> OCaml pointers, and
        just literal memory addresses. The runtime ensures that it never
        relocates values in the major heap unless this
        &quot;remembered&quot; set is empty. The set is maintained as a
        dynamically resized array of pointers, which is itself
        maintained via a collection of pointers known as the
        <literal>caml_ref_table</literal>.
      </para>
      <programlisting language="c">
struct caml_ref_table {
  value **base;
  value **end;
  value **threshold;
  value **ptr;
  value **limit;
  asize_t size;
  asize_t reserve;
};
</programlisting>
      <para>
        The relationships of the pointers are as follows:
      </para>
      <programlisting>
                   limit
   base &lt;= ptr     threshold          end
     |----------------|----------------|
           size            reserve
</programlisting>
      <para>
        An address is added to <literal>caml_ref_table</literal> when
        all of these conditions are satisfied:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            a field in a block in the major heap is mutated
          </para>
        </listitem>
        <listitem>
          <para>
            the field previously did not point to the minor heap
          </para>
        </listitem>
        <listitem>
          <para>
            the field is being changed to point into the minor heap
          </para>
        </listitem>
      </itemizedlist>
      <para>
        In that case the entry is added at
        <literal>caml_ref_table.ptr</literal>, which is then
        incremented. If <literal>ptr</literal> is already at
        <literal>limit</literal>, the table is doubled in size before
        adding the address.
      </para>
      <para>
        The same address can occur in <literal>caml_ref_table</literal>
        multiple times if a block field is mutated repeatedly and
        alternated between pointing at the minor heap and the major
        heap. The field in <literal>caml_ref_table</literal> also may
        not always point into the minor heap (if it was changed after
        being added), since fields are never removed. The entire table
        is cleared as part of the minor collection process.
      </para>
      <sect3 id="the-write-barrier">
        <title>The write barrier</title>
        <para>
          The write barrier is one of the reasons why using immutable
          data structures can sometimes be faster than mutable records.
          The OCaml compiler keeps track of any mutable types and adds a
          call to <literal>caml_modify</literal> before making the
          change. The <literal>caml_modify</literal> checks that the
          remembered set is consistent, which, although reasonably
          efficient, can be slower than simply allocating a fresh value
          on the fast minor heap.
        </para>
        <para>
          Let's see this for ourselves with a simple test program:
        </para>
        <programlisting language="ocaml">
type t1 = { mutable iters1: int; mutable count1: float }
type t2 = { iters2: int; count2: float }

let rec test_mutable t1 =
  match t1.iters1 with
  |0 -&gt; ()
  |n -&gt;
    t1.iters1 &lt;- t1.iters1 - 1;
    t1.count1 &lt;- t1.count1 +. 1.0;
    test_mutable t1

let rec test_immutable t2 =
  match t2.iters2 with
  |0 -&gt; ()
  |n -&gt;
    let iters2 = n - 1 in
    let count2 = t2.count2 +. 1.0 in
    test_immutable { iters2; count2 }

open Printf
let time name fn arg =
  Gc.compact ();
  let w1 = Gc.((stat ()).minor_collections) in
  let t1 = Unix.gettimeofday () in
  fn arg;
  let w2 = Gc.((stat ()).minor_collections) in
  let t2 = Unix.gettimeofday () in
  printf &quot;%s: %.4fs (%d minor collections)\n&quot; name (t2 -. t1) (w2 - w1)

let _ =
  let iters = 1000000000 in
  time &quot;mutable&quot; test_mutable { iters1=iters; count1=0.0 };
  time &quot;immutable&quot; test_immutable { iters2=iters; count2=0.0 }
</programlisting>
        <para>
          This program defines a type <literal>t1</literal> that is
          mutable, and <literal>t2</literal> that is immutable. The main
          loop iterates over both fields and runs a simple counter. It
          measures two things: the wallclock time that all the
          iterations take, and the number of minor garbage collections
          that occurred during the test. The results should look
          something like this:
        </para>
        <programlisting>
mutable: 8.6923s (7629 minor collections)
immutable: 2.6186s (19073 minor collections)
</programlisting>
        <para>
          Notice the space/time tradeoff here. The mutable version runs
          almost 4 times slower than the immutable one, but has
          significantly fewer garbage collection cycles. Minor
          collections in OCaml are very fast, and so it is often
          acceptable to use immutable data structures in preference to
          the more conventional mutable versions. On the other hand, if
          you only rarely mutable a value, it can be faster to take the
          write barrier hit and not allocate at all.
        </para>
        <para>
          (<emphasis>avsm</emphasis>: it would be really nice to use a
          benchmark suite here and shorten the example. Investigate the
          options and edit this section)
        </para>
        <para>
          (<emphasis>avsm</emphasis>: need to mention when a value is
          allocated directly into the major heap somewhere)
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="how-garbage-collection-works">
    <title>How garbage collection works</title>
    <sect2 id="collecting-the-minor-heap">
      <title>Collecting the minor heap</title>
      <para>
        For those familiar with garbage collection terminology, here is
        OCaml's minor colection in one sentence. OCaml's minor
        collection uses copying collection with forwarding pointers, and
        does a depth-first traversal of the block graph using a stack
        represented as a linked list threaded through blocks that need
        to be scanned.
      </para>
      <para>
        The goal of minor collection is to empty the minor heap by
        moving to the major heap every block in the minor heap that
        might be used in the future, and updating each pointer to a
        moved block to the new version of the block. A block is
        <emphasis>live</emphasis> if is reachable by starting at some
        <emphasis>root</emphasis> pointer into a block in the minor
        heap,a nd then following pointers in blocks. There are many
        different kinds of roots:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            OCaml stack(s)
          </para>
        </listitem>
        <listitem>
          <para>
            C stack(s), identified by <literal>BeginRoots</literal> or
            <literal>CAMLparam</literal> in C code
            (<emphasis>avsm</emphasis>: xref C bindings chapter)
          </para>
        </listitem>
        <listitem>
          <para>
            Global roots
          </para>
        </listitem>
        <listitem>
          <para>
            Finalized values (<emphasis>avsm</emphasis>: ?)
          </para>
        </listitem>
        <listitem>
          <para>
            Intergenerational pointers in the
            <literal>caml_ref_table</literal>
            (<emphasis>avsm</emphasis>: xref above?)
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Moving a block between heaps is traditionally called
        <emphasis>forwarding</emphasis>. The OCaml runtime code uses
        that term as well as the term <emphasis>oldify</emphasis>, which
        is useful to understand when profiling hotspots in your code.
        The minor collector first visits all roots and forwards them if
        they point to a block in the minor heap. When a block is
        forwarded, the collector sets the tag of the original block to a
        special <literal>Forward_tag</literal> (250), and the first
        field of the original block to point to the new block. Then, if
        the collector ever encounters a pointer to the original block
        again, it can simply update the pointer directly into the
        forwarded block.
      </para>
      <para>
        Because a forwarded block might itself contain pointers, it must
        at some point be scanned to see if those pointers point to
        blocks in the minor heap, so that those blocks can also be
        forwarded. The collector maintains a linked list (called the
        <literal>oldify_todo_list</literal>) of forwarded objects that
        it still needs to scan. That linked list looks like:
      </para>
      <programlisting>
                oldify_todo_list
                   |
                   |
                   v
   minor heap  | 0 | v | f1 ... |      | 0 | v | f1 ... |
                     |                     ^ |
                     |      +--------------+ |      ---------- ...
                     v      |                v      |
   major heap    | h | f0 | ^ | ... |    | h | f0 | ^
</programlisting>
      <para>
        Each value on the <literal>oldify_todo_list</literal> is marked
        as forwarded, and the first word points to the new block in the
        major heap. That new version contains the actual value header,
        the real first field of the value, and a link (pointer) to the
        next value on the oldify_todo_list, or
        <subscript>NULL</subscript> at the end of the list. Clearly this
        approach won't work if an value has only one field, since there
        will be no second field to store the link in. Values with
        exactly one field are never put on the
        <literal>oldify_todo_list</literal>; instead, the collector
        immediately traverses them, essentially making a tail call in
        the depth-first search.
      </para>
      <para>
        Values that are known from the tag in their header to not
        contain pointers are simply forwarded and completely copied, and
        never placed on the <literal>oldify_todo_list</literal>. These
        tags are all greater than <literal>No_scan_tag</literal> and
        include strings and float arrays.
      </para>
      <para>
        (<emphasis>avsm</emphasis>: note from sweeks to investigate:
        There is a hack for objects whose tag is
        <literal>Forward_tag</literal> that does some kind of path
        compression, or at least removal of one link, but I'm not sure
        what's going on.)
      </para>
      <para>
        (<emphasis>avsm</emphasis>: I dont think we've introduced weak
        references yet, so this needs rearranging) At the end of the
        depth-first search in minor collection, the collector scans the
        <literal>weak-ref</literal> table, and clears any weak
        references that are still pointing into the minor heap. The
        collector then empties the <literal>weak-ref</literal> table and
        the minor heap.
      </para>
    </sect2>
    <sect2 id="collecting-the-major-heap">
      <title>Collecting the major heap</title>
      <para>
        The major heap collections operates incrementally, as the amount
        of memory being tracked is a lot larger than the minor heap. The
        major collector can be in any of a number of phases:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>Phase_idle</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>Phase_mark</literal>
          </para>
          <itemizedlist>
            <listitem>
              <para>
                <literal>Subphase_main</literal>: main marking phase
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>Subphase_weak1</literal>: clear weak pointers
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>Subphase_weak2</literal>: remove dead weak
                arrays, observe finalized values
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>Subphase_final</literal>: initialise for the
                sweep phase
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>Phase_sweep</literal>
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2 id="marking-the-major-heap">
      <title>Marking the major heap</title>
      <para>
        Marking maintains an array of gray blocks,
        <literal>gray_vals</literal>. It uses as them as a stack,
        pushing on a white block that is then colored gray, and popping
        off a gray block when it is scanned and colored black. The
        <literal>gray_vals</literal> array is allocated via
        <emphasis>malloc(3)</emphasis>, and there is a pointer,
        <literal>gray_vals_cur</literal>, to the next open spot in the
        array.
      </para>
      <para>
        The <literal>gray_vals</literal> array initially has 2048
        elements. <literal>gray_vals_cur</literal> starts at
        <literal>gray_vals</literal>, and increases until it reachs
        <literal>gray_vals_end</literal>, at which point the
        <literal>gray_vals</literal> array is doubled, as long as its
        size (in bytes) is less than 1/2^10th of the heap size
        (<literal>caml_stat_heap_size</literal>). When the gray vals is
        of its maximum allowed size, it isn't grown any further, and the
        heap is marked as impure (<literal>heap_is_pure=0</literal>),
        and last half of <literal>gray_vals</literal> is ignored (by
        setting <literal>gray_vals_cur</literal> back to the middle of
        the <literal>gray_vals</literal> array.
      </para>
      <para>
        If the marking is able to complete using just the gray list, it
        will. Otherwise, once the gray list is emptied, the mark phase
        will observe that the heap is impure and initiate a backup
        approach to marking. In this approach it marks the heap as pure
        and then walks through the entire heap block by block, in
        increasing order of memory address. If it finds a gray block, it
        adds it to the gray list and does a DFS marking using the gray
        list as a stack in the usual way. Once the scan of the complete
        heap is finished, the mark phase checks again whether the heap
        has again become impure, and if so initiates another scan. These
        full-heap scans will continue until a successful scan completes
        without overflowing the gray list.
      </para>
      <para>
        (<emphasis>avsm</emphasis>: I need to clarify this more,
        possibly a diagram too. It's not really clear what the
        implications of an impure heap are atm)
      </para>
    </sect2>
    <sect2 id="sweeping-unused-blocks-from-the-major-heap">
      <title>Sweeping unused blocks from the major heap</title>
      <para>
      </para>
    </sect2>
    <sect2 id="compaction-and-defragmenting-the-major-heap">
      <title>Compaction and defragmenting the major heap</title>
      <para>
      </para>
    </sect2>
  </sect1>
</chapter>
<chapter id="performance-tuning-and-profiling">
  <title>Performance Tuning and Profiling</title>
  <sect1 id="byte-code-profiling">
    <title>Byte code Profiling</title>
    <para>
      ocamlcp and call trace information
    </para>
  </sect1>
  <sect1 id="native-code-profiling">
    <title>Native Code Profiling</title>
    <sect2 id="gdb">
      <title>gdb</title>
      <para>
        requires shinwell's patch in ocaml trunk via opam
      </para>
    </sect2>
    <sect2 id="perf">
      <title>perf</title>
      <para>
        requires fabrice's frame pointer patch
      </para>
    </sect2>
    <sect2 id="dtrace">
      <title>dtrace</title>
      <para>
        requires my dtrace/instruments patch for libasmrun
      </para>
    </sect2>
  </sect1>
</chapter>
<chapter id="packaging-and-build-systems">
  <title>Packaging and Build Systems</title>
  <para>
    The OCaml toolchain is structured much like a C compiler, with
    several tools that generate intermediate files and finally link
    against a runtime. The final outputs don't have to be just
    executables. Many people embed OCaml code as object files that are
    called from other applications, or even compile it to Javascript and
    other esoteric targets. Let's start by covering some of the standard
    OCaml tools, and then move on to some of the higher level methods
    for packaging and publishing your code online.
  </para>
  <sect1 id="the-ocaml-toolchain">
    <title>The OCaml toolchain</title>
    <para>
      There are two distinct compilers for OCaml code included in the
      standard distribution. The first outputs bytecode that is
      interpreted at runtime, and the second generates fast, efficient
      native code directly. Both of these share the front-end
      type-checking logic, and only diverge when it comes to code
      generation.
    </para>
    <sect2 id="the-ocamlc-bytecode-compiler">
      <title>The <literal>ocamlc</literal> bytecode compiler</title>
      <para>
        The simplest code generator is the <literal>ocamlc</literal>
        compiler, which outputs bytecode that is interpreted via the
        <literal>ocamlrun</literal> runtime. The OCaml bytecode virtual
        machine is a stack machine (much like the Java Virtual Machine),
        with the exception of a single register that stores the most
        recent result. This provides a simple runtime model that is easy
        to implement or embed within other systems, but executes rather
        slowly due to being interpreted.
      </para>
      <para>
        Here are some of the intermediate files generated by
        <literal>ocamlc</literal>:
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left" />
          <colspec align="left" />
          <thead>
            <row>
              <entry>
                Extension
              </entry>
              <entry>
                Purpose
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                .ml
              </entry>
              <entry>
                Source files for compilation unit module
                implementations.
              </entry>
            </row>
            <row>
              <entry>
                .mli
              </entry>
              <entry>
                Source files for compilation unit module interfaces. If
                missing, generated from the <literal>.ml</literal> file.
              </entry>
            </row>
            <row>
              <entry>
                .cmi
              </entry>
              <entry>
                Compiled module interface from a corresponding
                <literal>.mli</literal> source file.
              </entry>
            </row>
            <row>
              <entry>
                .cmo
              </entry>
              <entry>
                Compiled bytecode object file of the module
                implementation.
              </entry>
            </row>
            <row>
              <entry>
                .cma
              </entry>
              <entry>
                Library of bytecode object files packed into a single
                file.
              </entry>
            </row>
            <row>
              <entry>
                .o
              </entry>
              <entry>
                C source files are compiled into native object files by
                the system <literal>cc</literal>.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        To obtain a bytecode executable, you need to compile a set of
        <literal>cmo</literal> object files, and then link them into an
        executable
      </para>
    </sect2>
    <sect2 id="the-ocamlopt-native-code-compiler">
      <title>The <literal>ocamlopt</literal> native code
      compiler</title>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left" />
          <colspec align="left" />
          <thead>
            <row>
              <entry>
                Extension
              </entry>
              <entry>
                Purpose
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                .cmi
              </entry>
              <entry>
                Compiled module interface from a corresponding
                <literal>.mli</literal> source file.
                (<emphasis>avsm</emphasis>: this is not compatible with
                the ocamlc version iirc)
              </entry>
            </row>
            <row>
              <entry>
                .o
              </entry>
              <entry>
                Compiled native object file of the module
                implementation.
              </entry>
            </row>
            <row>
              <entry>
                .cmx
              </entry>
              <entry>
                Contains extra information for linking and cross-module
                optimization of the object file.
              </entry>
            </row>
            <row>
              <entry>
                .cmxa/.a
              </entry>
              <entry>
                Library of <literal>cmx</literal> and
                <literal>o</literal> units, stored in the
                <literal>cmxa</literal> and <literal>a</literal> files
                respectively.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>
    <sect2 id="the-ocaml-top-level-loop">
      <title>The <literal>ocaml</literal> top-level loop</title>
      <para>
      </para>
    </sect2>
  </sect1>
  <sect1 id="the-findlib-compiler-frontend">
    <title>The Findlib compiler frontend</title>
    <para>
    </para>
  </sect1>
  <sect1 id="packaging-applications-with-oasis">
    <title>Packaging applications with OASIS</title>
    <sect2 id="ocamlbuild">
      <title>ocamlbuild</title>
      <para>
      </para>
    </sect2>
  </sect1>
  <sect1 id="distributing-applications-with-opam">
    <title>Distributing applications with OPAM</title>
    <para>
    </para>
  </sect1>
</chapter>
<chapter id="parsing-with-ocamllex-and-ocamlyacc">
  <title>Parsing with OCamllex and OCamlyacc</title>
  <para>
  </para>
</chapter>
<chapter id="installation">
  <title>Installation</title>
  <para>
    The easiest way to install OCaml is via the binary packages
    available in many operating systems. For day-to-day code
    development, it is easier to use a source-based manager that lets
    you recompile individual libraries easily.
  </para>
  <para>
    For the purposes of this book, we'll use the OPAM source manager.
    There are other alternatives available such as GODI and ODB, but not
    covered here. Let's get started with OPAM now, as you will need it
    to run the examples in the rest of the book. OPAM manages multiple
    simultaneous OCaml compiler and library installations, tracks
    library versions across upgrades, and recompiles dependencies
    automatically if they get out of date.
  </para>
  <sect1 id="opam-base-installation">
    <title>OPAM Base Installation</title>
    <para>
      To install OPAM, you will need a working OCaml installation to
      bootstrap the package manager. Once installed, all of the OPAM
      state is held in the <literal>$HOME/.opam</literal> directory, and
      you can reinitialise it by deleting this directory and starting
      over.
    </para>
    <important>
    <title>
    OCamlfind and OPAM
    </title>
    <para>
      OPAM maintains multiple compiler and library installations, but
      this can clash with a global installation of the
      <literal>ocamlfind</literal> tool. Uninstall any existing copies
      of <literal>ocamlfind</literal> before installing OPAM, and use
      the OPAM version instead.
    </para>
    </important>
    <sect2 id="macos-x">
      <title>MacOS X</title>
      <para>
        The easiest way to install OCaml on MacOS X is via the
        <literal>homebrew</literal> package manager, available from
        [http://github.com/mxcl/homebrew].
      </para>
      <programlisting>
$ brew install ocaml
$ brew install opam
</programlisting>
    </sect2>
    <sect2 id="linux">
      <title>Linux</title>
      <para>
        On Debian Linux, you should install OCaml via binary packages,
        and then install the latest OPAM release from source.
      </para>
      <programlisting>
$ sudo apt-get install build-essential ocaml ocaml-native-compilers camlp4-extra git
 tar -jxvf opam-&lt;version&gt;.tar.gz
$ cd opam-&lt;version&gt;.tar.gz
$ ./configure &amp;&amp; make &amp;&amp; sudo make install
</programlisting>
      <para>
        On Fedora/RHEL...?
      </para>
    </sect2>
    <sect2 id="windows">
      <title>Windows</title>
      <para>
        Investigate Protzenko's Windows installer.
      </para>
    </sect2>
    <sect2 id="using-the-opam-top-level">
      <title>Using the OPAM top-level</title>
      <para>
        All of the OPAM state is held in the <literal>.opam</literal>
        directory in your home directory, including compiler
        installations. You should never need to switch to an admin user
        to install packages.
      </para>
      <programlisting>
$ opam init
$ opam install utop async core_extra
$ eval `opam config -env`
</programlisting>
      <para>
        This will initialise OPAM with the default package set from
        <literal>opam.ocamlpro.com</literal>, and install the
        <literal>utop</literal> interactive top-level and the
        <literal>Async</literal> library. OPAM figures out the minimal
        set of dependencies required, and installs those too. The
        <literal>eval</literal> command is sets your
        <literal>PATH</literal> variable to point to the current active
        compiler, and you should add this to your shell
        <literal>.profile</literal> to run every time you open a new
        command shell.
      </para>
    </sect2>
    <sect2 id="switching-compiler-versions">
      <title>Switching compiler versions</title>
      <para>
        The default compiler installed by OPAM uses the system OCaml
        installation. You can use <literal>opam switch</literal> to swap
        between different compiler versions, or experiment with a
        different set of libraries or new compiler versions. For
        instance, one of the alternate compilers is patched to simplify
        the types that are output in the top-level. You can switch it to
        by:
      </para>
      <programlisting>
$ opam switch -list
$ opam switch 4.00.1+short-types
$ eval `opam config -env`
$ opam install utop async_extra
</programlisting>
      <para>
        The new compiler will be compiled and installed into
        <literal>~/.opam/4.00.1+short-types</literal> and the libraries
        will be tracked separately from your system installation. You
        can have any number of compilers installed simultaneously, but
        only one can be active at any time.
      </para>
    </sect2>
  </sect1>
  <sect1 id="editing-environment">
    <title>Editing Environment</title>
    <sect2 id="command-line">
      <title>Command Line</title>
      <para>
        The <literal>utop</literal> tool provides a convenient
        interactive top-level, with full command history, command macros
        and module name completion. An <literal>.ocamlinit</literal>
        file in your home directory will initialise
        <literal>utop</literal> with common libraries and syntax
        extensions open, e.g.:
      </para>
      <programlisting>
#use &quot;topfind&quot;
#camlp4o
#thread
#require &quot;core.top&quot;;;
#require &quot;async&quot;;;
open Core.Std
open Async.Std
</programlisting>
      <para>
        TODO: the <literal>.ocamlinit</literal> handling in OPAM is
        being finalised and is tracked in
        <ulink url="https://github.com/OCamlPro/opam/issues/185">issue
        185</ulink>.
      </para>
    </sect2>
    <sect2 id="editors">
      <title>Editors</title>
      <para>
        Emacs users have tuareg and
        <ulink url="http://www.typerex.org/">Typerex</ulink>.
      </para>
      <para>
        Vim users can use the built-in style, and
        <ulink url="http://github.com/avsm/ocaml-annot">ocaml-annot</ulink>
        may also be useful.
      </para>
      <para>
        Eclipse plugins: which one is maintained?
      </para>
    </sect2>
  </sect1>
  <sect1 id="developing-with-opam">
    <title>Developing with OPAM</title>
    <para>
      Package listings are obtained by adding
      <emphasis>remotes</emphasis> that provide package descriptions,
      installation instructions and URLs.
    </para>
  </sect1>
</chapter>
</book>
