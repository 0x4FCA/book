\labelchapter{exceptions}{Exceptions}

Exceptions are used in OCaml as a control mechanism, either to signal errors, or control the flow of
execution in some other way.  In their simplest form, exceptions are used to signal that the current
computation cannot proceed because of a run-time error.  For example, if we try to evaluate the
quotient \lstinline+1 / 0+ in the toploop, the runtime signals a \hbox{\lstinline/Division_by_zero/} error,
the computation is aborted, and the toploop prints an error message.

\begin{ocaml}
# 1 / 0;;
@
\begin{topoutput}
Exception: Division_by_zero.
\end{topoutput}
@
\end{ocaml}
%
Exceptions can also be defined and used explicitly by the programmer.  For example, suppose we
define a function \hbox{\lstinline/head/} that returns the first element in a list.  If the list is empty,
we would like to signal an error.

\label{keyword:exception}
\begin{ocaml}
# exception Fail of string;;
@
\begin{topoutput}
exception Fail of string
\end{topoutput}
@
# let head = function
     h :: _ -> h
   | [] -> raise (Fail "head: the list is empty");;
@
\begin{topoutput}
val head : 'a list -> 'a = <fun>
\end{topoutput}
@
# head [3; 5; 7];;
@
\begin{topoutput}
- : int = 3
\end{topoutput}
@
# head [];;
@
\begin{topoutput}
Exception: Fail "head: the list is empty".
\end{topoutput}
@
\end{ocaml}
%
The first line of this program defines a new exception, declaring
\hbox{\lstinline/Fail/} as an exception with a string argument.  The
\hbox{\lstinline/head/} function uses pattern matching---the result is
\hbox{\lstinline/h/} if the list has first element \hbox{\lstinline/h/}; otherwise, there is
no first element, and the \hbox{\lstinline/head/} function raises a \hbox{\lstinline/Fail/}
exception.  The expression \hbox{\lstinline/(Fail "head: the list is empty")/} is
a value of type \hbox{\lstinline/exn/}; the \hbox{\lstinline/raise/} function is responsible
for aborting the current computation.

\begin{ocaml}
# Fail "message";;
@
\begin{topoutput}
- : exn = Fail "message"
\end{topoutput}
@
# raise;;
@
\begin{topoutput}
- : exn -> 'a = <fun>
\end{topoutput}
@
# raise (Fail "message");;
@
\begin{topoutput}
Exception: Fail "message".
\end{topoutput}
@
\end{ocaml}
%
The type \hbox{\lstinline/exn -> 'a/} for the \hbox{\lstinline/raise/} function may seem striking at first---it
appears to say that the raise function can produce a value having \emph{any} type.  In fact, what it
really means is that the \hbox{\lstinline/raise/} function never returns, and so the type of the result
doesn't matter.  When a \hbox{\lstinline/raise/} expression occurs in a larger computation, the entire
computation is aborted.

\begin{ocaml}
# 1 + raise (Fail "abort") * 21;;
@
\begin{topoutput}
Exception: Fail "abort".
\end{topoutput}
@
\end{ocaml}
%
When an exception is raised, the current computation is aborted, and control is passed directly to
the currently active exception handler, which in this case is the toploop itself.

It is also possible to define explicit exception handlers.  Exception handlers have the same form as
a \hbox{\lstinline/match/} pattern match, but using the \hbox{\lstinline/try/} keyword instead.  The syntax is as follows.

\index{try@\lstinline/try/}
\label{keyword:try}
\begin{ocaml}
try $\nt{expression}_t$ with
 | $\nt{pattern}_1$ -> $\nt{expression}_1$
 | $\nt{pattern}_2$ -> $\nt{expression}_2$
 $\vdots$
 | $\nt{pattern}_n$ -> $\nt{expression}_n$
\end{ocaml}
%
First, $\nt{expression}_t$ is evaluated.  If it does not raise an exception, its value is returned
as the result of the \hbox{\lstinline/try/} statement.  Otherwise, if an exception is raised during
evaluation of $e$, the exception is matched against the patterns
$\nt{pattern}_1, \ldots, \nt{pattern}_n$.  If the first pattern to match the exception is
$\nt{pattern}_i$, the expression $\nt{expression}_i$ is evaluated and returned as the result of the
entire \hbox{\lstinline/try/} expression.  Unlike a \hbox{\lstinline/match/} expression, there is no requirement
that the pattern matching be complete.  If no pattern matches, the exception is not caught, and it
is propagated to the next exception handler (which may be the toploop).

For example, suppose we wish to define a function \hbox{\lstinline/head_default/}, similar
to \hbox{\lstinline/head/}, but returning a default value if the list is empty.  One way would be to write
a new function from scratch, but we can also choose to handle the exception from \hbox{\lstinline/head/}.

\begin{ocaml}
# let head_default l default =
     try head l with
        Fail _ -> default;;
@
\begin{topoutput}
val head_default : 'a list -> 'a -> 'a = <fun>
\end{topoutput}
@
# head_default [3; 5; 7] 0;;
@
\begin{topoutput}
- : int = 3
\end{topoutput}
@
# head_default [] 0;;
@
\begin{topoutput}
- : int = 0
\end{topoutput}
@
\end{ocaml}
%
In this case, if evaluation of
\hbox{\lstinline/head l/} raises an exception \hbox{\lstinline/Fail/}, the value
\hbox{\lstinline/default/} is returned.

\labelsection{nested-exceptions}{Nested exception handlers}

Exceptions are handled dynamically, and at run-time there may be many
active exception handlers.  To illustrate this, let's consider an
alternate form of a list-map function, defined using a function
\hbox{\lstinline/split/} that splits a non-empty list into its head and tail.

\begin{ocaml}
# exception Empty;;
@
\begin{topoutput}
exception Empty
\end{topoutput}
@
# let split = function
     h :: t -> h, t
   | [] -> raise Empty;;
@
\begin{topoutput}
val split : 'a list -> 'a * 'a list = <fun>
\end{topoutput}
@
# let rec map f l =
     try
        let h, t = split l in
           f h :: map f t
     with
        Empty -> [];;
@
\begin{topoutput}
val map : ('a -> 'b) -> 'a list -> 'b list = <fun>
\end{topoutput}
@
# map (fun i -> i + 1) [3; 5; 7];;
@
\begin{topoutput}
- : int list = [4; 6; 8]
\end{topoutput}
@
\end{ocaml}

The call to \hbox{\lstinline/map/} on the three-element list \hbox{\lstinline/[3; 5; 7]/} results in four
recursive calls corresponding to \hbox{\lstinline/map f [3; 5; 7]/},
\hbox{\lstinline/map f [5; 7]/},
\hbox{\lstinline/map f [7]/}, and
\hbox{\lstinline/map f []/}, before the function \hbox{\lstinline/split/} is
called on the empty list.  Each of the calls defines a new exception handler.

It is appropriate to think of these handlers forming an exception stack corresponding to the call
stack (this is, in fact, the way it is implemented in the OCaml implementation from INRIA).  When a
\hbox{\lstinline/try/} expression is evaluated, a new exception handler is pushed
onto the the stack; the handler is removed when evaluation completes.  When an exception is raised,
the entries of the stack are examined in stack order.  If the topmost handler contains a pattern
that matches the raised exception, it receives control.  Otherwise, the handler is popped from the
stack, and the next handler is examined.

In our example, when the \hbox{\lstinline/split/} function raises the \hbox{\lstinline/Empty/} exception, the top
four elements of the exception stack contain handlers corresponding to each of the recursive calls
of the \hbox{\lstinline/map/} function.  When the \hbox{\lstinline/Empty/} exception is raised,
control is passed to the innermost call \hbox{\lstinline/map f []/}, which returns
the empty list as a result.

\begin{center}
\begin{tabular}{|l|}
\hline
{\hbox{\lstinline/map f []/}}\\
{\hbox{\lstinline/map f [7]/}}\\
{\hbox{\lstinline/map f [5; 7]/}}\\
{\hbox{\lstinline/map f [3; 5; 7]/}}\\
\hline
\end{tabular}
\end{center}
%
This example also contains a something of a surprise.  Suppose the function \hbox{\lstinline/f/} raises
the \hbox{\lstinline/Empty/} exception.  The program gives no special status to \hbox{\lstinline/f/}, and control
is passed to the uppermost handler on the exception stack.  As a result, the list is truncated at
the point where the exception occurs.

\begin{ocaml}
# map (fun i ->
          if i = 0 then
             raise Empty
          else
             i + 1) [3; 5; 0; 7; 0; 9];;
@
\begin{topoutput}
- : int list = [4; 6]
\end{topoutput}
@
\end{ocaml}

\labelsection{exception-examples}{Examples of uses of exceptions}

Like many other powerful language constructs, exceptions can used to simplify programs and improve
their clarity.  They can also be abused.  In this section we cover some standard uses of exceptions.

\labelsubsection{exception-notfound}{The exception Not\_found}

The OCaml standard library uses exceptions for several different purposes.  One of the most common
exceptions is \hbox{\lstinline/Not_found/}, which is raised by functions that perform searching or lookup.
There are many such functions in OCaml.  One is the function \hbox{\lstinline/List.assoc/}, which
searches for a key-value pair in an association.  For example, suppose we were implementing a
grading program where the grades are represented as a list of name/grade pairs.

\begin{ocaml}
# let grades = [("John", "C+"); ("Jane", "A+"); ("Joan", "B")];;
@
\begin{topoutput}
val grades : (string * string) list = ...
\end{topoutput}
@
# List.assoc "Jane" grades;;
@
\begin{topoutput}
- : string = "A+"
\end{topoutput}
@
# List.assoc "June" grades;;
@
\begin{toperror}
Exception: Not_found.
\end{toperror}
@
\end{ocaml}
%
In typical programs, \hbox{\lstinline/Not_found/} exceptions routinely occur and can be expected to
happen during normal program operation.

\labelsubsection{exception-failure}{Invalid\_argument and Failure}
\index{exceptions!Invalid\_argument@\lstinline$Invalid_argument$}
\index{exceptions!Failure@\lstinline$Failure$}

An \hbox{\lstinline/Invalid_argument/} exception means that some kind of runtime error occurred,
like an array bounds violation.  The string argument describes the error.

\begin{ocaml}
# let a = [|5; 6; 7|];;
@
\begin{topoutput}
val a : int array = [|5; 6; 7|]
\end{topoutput}
@
# a.(2);;
@
\begin{topoutput}
- : int = 7
\end{topoutput}
@
# a.(3);;
@
\begin{toperror}
Exception: Invalid_argument "index out of bounds".
\end{toperror}
@
\end{ocaml}
%
The exception \hbox{\lstinline/Failure/} is similar to \hbox{\lstinline/Invalid_argument/}, but it
is usually used for less severe errors.  A \hbox{\lstinline/Failure/} exception also includes a
string describing the failure.  The standard convention is that this string should be the name of the
function that failed.

\begin{ocaml}
# int_of_string "0xa0";;
@
\begin{topoutput}
- : int = 160
\end{topoutput}
@
# int_of_string "0xag";;
@
\begin{toperror}
Exception: Failure "int_of_string".
\end{toperror}
@
\end{ocaml}
%
The \hbox{\lstinline/Invalid_argument/} and \hbox{\lstinline/Failure/} exceptions are quite similar---they each indicate a
run-time error, using a string to describe it, so what is the difference?

The difference is primarily a matter of style.  The \hbox{\lstinline/Invalid_argument/} exception is
usually used to indicate \emph{programming} errors, or errors that should never happen if the
program is correct.  The \hbox{\lstinline/Failure/} exception is used to indicate errors that are more
benign, where it is possible to recover, or where the cause is often due to external uncontrollable
events (for example, when a string \hbox{\lstinline/0xag/} is read in a place where a number is expected).

For illustration, let's return to the grading example, but suppose the grades are stored separately
from the names.  We are given a pair of lists, \hbox{\lstinline/names/} and \hbox{\lstinline/grades/}, that
describe the students taking a class.  We are told that every student in the class must have a
grade, but not every student is taking the class.  We might define the function to return a
student's grade by recursively searching through the two lists until the entry for the student is
found.

\begin{ocaml}
let rec find_grade name (names, grades) =
   match names, grades with
      name' :: _, grade :: _ when name' = name -> grade
    | _ :: names', _ :: grades' -> find_grade name (names', grades')
    | [], [] -> raise (Failure ("student is not enrolled: " ^ name))
    | (_ :: _), [] | [], (_ :: _) -> raise (Invalid_argument "corrupted database")
\end{ocaml}
%
The function \hbox{\lstinline/find_grade/} searches the lists, returning the first match if there is
one.  If the lists have different lengths, an \hbox{\lstinline/Invalid_argument/} exception is raised
because, 1) the implementation assumes that the lists have the same length, so the error violates a
program invariant, and 2) there is no easy way to recover.  The pattern \hbox{\lstinline/[], []/}
corresponds to the case where the student is not found, but the lists have the same length.  This is
expected to occur during normal operation, so the appropriate exception is \hbox{\lstinline/Failure/}
(or \hbox{\lstinline/Not_found/} since this is a search function).

As a matter of style, it's considered bad practice to catch \hbox{\lstinline/Invalid_argument/}
exceptions (in fact, some early OCaml implementations did not even allow it).  In
contrast, \hbox{\lstinline/Failure/} exceptions are routinely caught in order to recover from
correctable errors.

\labelsubsection{exception-match}{Pattern matching failure}
\index{exceptions!Match\_failure@\lstinline$Match_failure$}
\index{patterns!inexhaustive}

When a pattern matching is incompletely specified, the OCaml compiler issues a warning (and a
suggestion for the missing pattern).  At runtime, if the matching fails because it is incomplete,
the \hbox{\lstinline/Match_failure/} exception is raised with three values: the name of the file, the line
number, and the character offset within the line where the match failed.  It is often considered bad
practice to catch the \hbox{\lstinline/Match_failure/} exception because the failure indicates a
programming error (proper programming practice would dictate that all pattern matches be complete).

\begin{ocaml}
# let f x =
     match x with
        Some y -> y;;
@
\begin{toperror}
Warning: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
None
val f : 'a option -> 'a = <fun>
\end{toperror}
@
# f None;;
@
\begin{toperror}
Exception: Match_failure ("", 2, 3).
\end{toperror}
@
\end{ocaml}

\labelsubsection{exception-assert}{Assertions}
\index{exceptions!Assert\_failure@\lstinline$Assert_failure$}
\index{assertions}
\index{assert@\lstinline$assert$}
\label{keyword:assert}

Another common use of exceptions is for checking runtime invariants.  The \hbox{\lstinline/assert/} operator
evaluates a Boolean expression, raising an \hbox{\lstinline/Assert_failure/} exception if the value is
\hbox{\lstinline/false/}.  For example, in the following version of the factorial function, an assertion is used
to generate a runtime error if the function is called with a negative argument.  The three arguments
represent the file, line, and character offset of the failed assertion.  As
with \hbox{\lstinline/Invalid_argument/} and \hbox{\lstinline/Match_failure/}, it is considered bad programming
practice to catch the \verb/Assert_failure/ exception.

\begin{ocaml}
# let rec fact i =
     assert (i >= 0);
     if i = 0 then
        1
     else
        i * fact (i - 1);;
@
\begin{topoutput}
val fact : int -> int = <fun>
\end{topoutput}
@
# fact 10;;
@
\begin{topoutput}
- : int = 3628800
\end{topoutput}
@
# fact (-10);;
@
\begin{topoutput}
Exception: Assert_failure ("", 9, 3).
\end{topoutput}
@
\end{ocaml}

\labelsubsection{exception-failure}{Memory exhaustion exceptions}
\index{exceptions!Out\_of\_memory@\lstinline$Out_of_memory$}
\index{exceptions!Stack\_overflow@\lstinline$Stack_overflow$}

The two exceptions \hbox{\lstinline/Out_of_memory/} and \hbox{\lstinline/Stack_overflow/} indicate that memory
resources have been exhausted.  The \hbox{\lstinline/Out_of_memory/} exception is raised by the garbage
collector when there is insufficient memory to continue running the program.
The \hbox{\lstinline/Stack_overflow/} exception is similar, but it is restricted to just stack space.  The
\hbox{\lstinline/Stack_overflow/} exception is often caused by an infinite loop, or excessively deep recursion, for
example, using the function \hbox{\lstinline/List.map/} on a list with more than a few thousand elements.

Both errors are severe, and the exceptions should not be caught casually.  For the
exception \hbox{\lstinline/Out_of_memory/} it is often useless to catch the exception without freeing some
resources, since the exception handler will usually not be able to execute if all memory has been
exhausted.

Catching the \hbox{\lstinline/Stack_overflow/} exception is not advised for a different reason.  Although the
\hbox{\lstinline/Stack_overflow/} exception can be caught reliably by the byte-code interpreter, it is not
supported by the native-code compiler on all architectures.  In many cases, a stack overflow will
result in a system error (a ``segmentation fault''), instead of a runtime exception.  For
portability, it is often better to avoid catching the exception.

\labelsection{exception-control}{Other uses of exceptions}

Exceptions are also frequently used to modify the control flow of a program, without necessarily
being associated with any kind of error condition.

\labelsubsection{exception-remove}{Decreasing memory usage}
\index{exceptions!for decreasing memory usage}

As a simple example, suppose we wish to write a function to remove the first occurrence of a
particular element $x$ in a list $l$.  The straightforward implementation is defined as a
recursive function.

\begin{ocaml}
let rec remove x = function
   y :: l when x = y -> l
 | y :: l (* x <> y *) -> y :: remove x l
 | [] -> []
\end{ocaml}
%
The function \hbox{\lstinline/remove/} function searches through the list for the first occurrence of an
element \hbox{\lstinline/y/} that is equal to \hbox{\lstinline/x/}, reconstructing the list after the removal.

One problem with this function is that the entire list is copied needlessly when the element is not
found, potentially increasing the space needed to run the program.  Exceptions provide a convenient
way around this problem.  By raising an exception in the case where the element is not found, we can
avoid reconstructing the entire list.  In the following function, when the \hbox{\lstinline/Unchanged/} exception
is raised, the \hbox{\lstinline/remove/} function returns the original list \hbox{\lstinline/l/}.

\begin{ocaml}
exception Unchanged

let rec remove_inner x = function
   y :: l when x = y ->
      l
 | y :: l (* x <> y *) ->
      y :: remove_inner x l
 | [] ->
      raise Unchanged

let remove x l =
   try remove_inner x l with
      Unchanged ->
         l
\end{ocaml}

\labelsubsection{exception-break}{Break statements}
\index{exceptions!to implement break}

OCaml provides both ``for'' and ``while'' loops, but there is no ``break''
statement as found in languages like C and Java.  Instead, exceptions can be used to abort a loop
prematurely.  To illustrate this, suppose we want to define a function \hbox{\lstinline/cat/} that prints out all
the lines from the standard input channel.  We discuss input/output in more detail in Section~\reflabelsection{io}, but for this problem we can just use the standard functions \hbox{\lstinline/input_char/}
to read a character from the input channel, and \hbox{\lstinline/output_char/} to write it to the output
channel.  The \hbox{\lstinline/input_char/} function raises the exception \hbox{\lstinline/End_of_file/} when the end of the
input has been reached.

\begin{ocaml}
let cat in_channel out_channel =
   try
      while true do
         output_char out_channel (input_char in_channel)
      done
   with
      End_of_file ->
         ()
\end{ocaml}
%
The function \hbox{\lstinline/cat/} defines an infinite loop (\hbox{\lstinline/while true do... done/}) to copy the input
data to the output channel.  When the end of the input has been reached, the \hbox{\lstinline/input_char/}
function raises the \hbox{\lstinline/End_of_file/} exception, breaking out of the loop, returning the \hbox{\lstinline/()/}
value as the result of the function.

\labelsubsection{exception-unwind}{Unwind-protect (finally)}
\index{exceptions!unwind-protect}
\index{finally|see{exceptions}}
\index{unwind-protect|see{exceptions}}
\index{exceptions!finally}

In some cases where state is used, it is useful to define a ``finally'' clause (similar to an
``unwind-protect'' as seen in Lisp languages).  The purpose of a ``finally'' clause is to execute
some code (usually to clean up) after an expression is evaluated.  In addition, the finally clause
should be executed even if an exception is raised.  A generic \hbox{\lstinline/finally/} function can be defined
using a wildcard exception handler. In the following function, the type \hbox{\lstinline/result/} is used to
represent the result of executing the function \hbox{\lstinline/f/} on argument \hbox{\lstinline/x/}, returning a \hbox{\lstinline/Success/}
value if the evaluation was successful, and \hbox{\lstinline/Failed/} otherwise.  Once the result is computed,
the \hbox{\lstinline/cleanup/} function is called, and 1) the result is returned on \hbox{\lstinline/Success/}, or 2) the
exception is re-raised on \hbox{\lstinline/Failed/}.

\begin{ocaml}
type 'a result =
   Success of 'a
 | Failed of exn

let finally f x cleanup =
   let result =
      try Success (f x) with
         exn ->
            Failed exn
   in
      cleanup ();
      match result with
         Success y -> y
       | Failed exn -> raise exn
\end{ocaml}
%
For example, suppose we wish to process in input file. The file should be opened, processed, and it
should be closed afterward, whether or not the processing was successful.  We can implement this as
follows.

\begin{ocaml}
let process in_channel = $\cdots$

let process_file file_name =
   let in_channel = open_in file_name in
      finally process in_channel (fun () -> close_in in_channel)
\end{ocaml}
%
In this example the function \hbox{\lstinline/finally/} is used to ensure that the channel \hbox{\lstinline/in_channel/} is closed
after the input file is processed, whether or not the \hbox{\lstinline/process/} function was successful.

\labelsubsection{exception-type}{The \misspelled{\texttt{exn}} type}
\index{exceptions!as variants}

We close with a somewhat unorthodox use of exceptions completely unrelated to control
flow.  Exceptions (values of the \hbox{\lstinline/exn/} type) are first-class values; they can be passed as
arguments, stored in data structures, \emph{etc}.  The values in the \hbox{\lstinline/exn/} type are specified with
\hbox{\lstinline/exception/} definitions.  One unique property of the \hbox{\lstinline/exn/} type is that it is \emph{open}
so that new exceptions can be declared when desired.  This mechanism can be used to provide a kind of
dynamic typing, somewhat like the polymorphic variants discussed in Section~\reflabelsection{open-union-types}.

For example, suppose we want to define a list of values, where the type of the values can be
extended as desired.  Initially, we might want lists containing strings and integers.  Suppose we
wish to define a function \hbox{\lstinline/succ/} that increments every integer in the list, preserving all
other values.

\begin{ocaml}
# exception String of string;;
# exception Int of int;;
# let succ l =
     List.map (fun x ->
        match x with
           Int i -> Int (i + 1)
         | _ -> x) l;;
@
\begin{topoutput}
val succ : exn list -> exn list = <fun>
\end{topoutput}
@
# let l = succ [String "hello"; Int 1; Int 7];;
@
\begin{topoutput}
val l : exn list = [String "hello"; Int 2; Int 8]
\end{topoutput}
@
\end{ocaml}
%
Later, we might also decide to add floating-point numbers to the list, with their own successor function.

\begin{ocaml}
# exception Float of float;;
@
\begin{topoutput}
exception Float of float
\end{topoutput}
@
# let succ_float l =
     List.map (fun x ->
        match x with
           Float y -> Float (y +. 1.0)
         | _ -> x) l;;
@
\begin{topoutput}
val succ_float : exn list -> exn list = <fun>
\end{topoutput}
@
# succ_float (Float 2.3 :: l);;
@
\begin{topoutput}
- : exn list = [Float 3.3; String "hello"; Int 2; Int 8]
\end{topoutput}
@
\end{ocaml}
%
The main purpose of this example is to illustrate properties of exception values. In cases where
extendable unions are needed, the use of polymorphic variants is more appropriate. Needless to say,
it can be quite confusing to encounter data structures constructed from exceptions!

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
% vim:tw=100:fo=tcq:
