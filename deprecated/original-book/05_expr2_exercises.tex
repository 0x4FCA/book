%
%
%
\exercises

\begin{exercise}{comma}
The comma \hbox{\lstinline/,/} that is used to separate the elements of a tuple has one of the lowest
precedences in the language.  How many elements do the following tuples have, and what do the
expressions evaluate to?

\begin{enumerate}
\item \lstinline!1 + 2, 3, - 5!

\begin{answer}\ifanswers
The tuple is \hbox{\lstinline/(3, 3, -5)/} of arity 3.
\fi\end{answer}

\item \lstinline!"ABC", ( 1 , "def" ), ()!

\begin{answer}\ifanswers
The tuple has arity 3; it evaluates to itself.  The expression \hbox{\lstinline/(1, "def")/} is a
sub-tuple.  The expression \hbox{\lstinline/()/} is the value of type \hbox{\lstinline/unit/} (though it can be
thought of like a tuple of arity zero).
\fi\end{answer}

\item \lstinline!let x = 1 in x + 1, let y = 2 in y + 1, 4!

\begin{answer}\ifanswers
The tuple has arity 2; the value is \hbox{\lstinline/(2, (3, 4))/}.
\fi\end{answer}
\end{enumerate}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Types
%
\begin{exercise}{funinfer}
What are the types of the following functions?

\begin{enumerate}
\item \lstinline!let f (x, y, z, w) = x + z!

\begin{answer}\ifanswers
The type is \hbox{\lstinline/f : int * 'a * int * 'b -> int/}.
\fi\end{answer}

\item \lstinline!let f (x, y, z, w) = (w, z, y, x)!

\begin{answer}\ifanswers
The type is \hbox{\lstinline/f : 'a * 'b * 'c * 'd -> 'd * 'c * 'b * 'a/}.
\fi\end{answer}

\item \lstinline!let f [x; y; z; w] = x!

\begin{answer}\ifanswers
The type is \hbox{\lstinline/f : 'a list -> 'a/}.
\fi\end{answer}

\item \lstinline!let f [x; y] [z; w] = [x; z]!

\begin{answer}\ifanswers
The type is \hbox{\lstinline/f : 'a list -> 'a list -> 'a list/}.
\fi\end{answer}

\item \lstinline!let f (x, y) (z, w) = [x; z]!

\begin{answer}\ifanswers
The type is \hbox{\lstinline/f : 'a * 'b -> 'a * 'c -> 'a list/}.
\fi\end{answer}
\end{enumerate}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programing tuples.
%
\begin{exercise}{fst}
One of the issues with tuples is that there is no general destructor function that takes a tuple and
projects an element of it.  Suppose we try to write one for triples.

\begin{ocaml}
let nth i (x, y, z) =
   match i with
      1 -> x
    | 2 -> y
    | 3 -> z
    | _ -> raise (Invalid_argument "nth")
\end{ocaml}

\begin{enumerate}
\item What is the type of the \hbox{\lstinline/nth/} function?

\begin{answer}\ifanswers
The type is \hbox{\lstinline/nth : int -> 'a * 'a * 'a -> 'a/}
\fi\end{answer}

\item Is there a way to rewrite the function so that it allows the elements of the tuple to have different types?

\begin{answer}\ifanswers
If the elements of the tuple had different types, the function \hbox{\lstinline/nth/} would return values
of different types for different argument \hbox{\lstinline/i/}.  This is not expressible in the type system we
have seen.  Another argument is that, since the branches of a conditional (like \hbox{\lstinline/match/})
must have the same type, the elements of the tuple must have the same type.
\fi\end{answer}
\end{enumerate}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Relational database
%
\begin{exercise}{relational-database}
Suppose you are implementing a relational employee database, where the database is
a list of tuples \hbox{\lstinline/name * phone * salary/}.

\begin{ocaml}
let db =
   ["John", "x3456", 50.1;
    "Jane", "x1234", 107.3;
    "Joan", "unlisted", 12.7]
\end{ocaml}

\begin{enumerate}
\item Write a function \hbox{\lstinline/find_salary : string -> float/} that returns the salary
of an employee, given the name.

\begin{answer}\ifanswers
\begin{ocaml}
let find_salary name =
   let rec search = function
       (name', _, salary) :: rest when name' = name -> salary
     | _ :: rest -> search rest
     | [] -> raise (Invalid_argument "find_salary")
   in
      search db
\end{ocaml}
\fi\end{answer}


\item Write a general function
%
\begin{ocaml}
select : (string * string * float -> bool) -> (string * string * float) list
\end{ocaml}
that returns a list of all the tuples that match the predicate.  For example the expression
\hbox{\lstinline/select (fun (_, _, salary) -> salary < 100.0)/} would return the tuples for John
and Joan.

\begin{answer}\ifanswers
We can implement the function \hbox{\lstinline/select/} by examining each tuple in order, collecting the
matching tuples in an accumulator \hbox{\lstinline/found/}.
\begin{ocaml}
let select pred =
   let rec search found = function
      tuple :: rest when pred tuple ->
          search (tuple :: found) rest
    | _ :: rest -> search found rest
    | [] -> found
   in
       search db
\end{ocaml}
\fi\end{answer}
\end{enumerate}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Identity function
%
\begin{exercise}{identity}
We have seen that the identity function \hbox{\lstinline/(fun x -> x)/} has type \hbox{\lstinline/'a -> 'a/}.
Are there any other functions with type \hbox{\lstinline/'a -> 'a/}?

\begin{answer}\ifanswers
There are only two kinds of functions with type \hbox{\lstinline/'a -> 'a/}: the identity function (and all
equivalent functions), and functions that does not terminate, for example
%
\hbox{\lstinline/(fun x -> raise (Invalid_argument "error"))/}.  One way to think about it is that the
function takes an argument of some arbitrary type \hbox{\lstinline/'a/}.  Since the actual type is not
known, the function can do only one of two things: 1) it can return it without change, or 2) it can
fail to terminate.
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Value restriction
%
\begin{exercise}{value-restriction}
In Exercise~\ref{exercise:partial-application1} we saw that partial application is sometimes used to
improve performance of a function $f(x, y)$ under the following conditions:
\begin{itemize}
\item the function can be written in the form $f(x, y) = h(g(x), y)$, and
\item $f$ is to be called for multiple values of $y$ with $x$ fixed.
\end{itemize}
%
In this case, we code $f(x, y)$ as follows, so that $g(x)$ is computed when $f$ is partially
applied to its first argument.

\begin{ocaml}
let f x = h (g x)
\end{ocaml}
%
Unfortunately, this technique doesn't always work in the presence of polymorphism.
Suppose the original type of the function is \hbox{\lstinline/f : int -> 'a -> 'a/},
and we want to compute the values of \hbox{\lstinline/(f 0 "abc")/} and \hbox{\lstinline/(f 0 1.2)/}.

\begin{ocaml}
let f' = f 0
let v1 = f' "abc"
let v2 = f' 1.2
\end{ocaml}
%
What goes wrong?  How can you compute both values without computing \hbox{\lstinline/g 0/} twice?

\begin{answer}\ifanswers
The problem is the value restriction.  The expression \hbox{\lstinline/f 0/} has type
%
\hbox{\lstinline/'_a -> '_a/}, so it is not properly polymorphic.  The eta-expansion is not a good solution either,
because it does not optimize the computation of \hbox{\lstinline/g 0/}.
\begin{ocaml}
let f x y = h (g x) y
\end{ocaml}

The only real solution is to ``lift'' the computation \hbox{\lstinline/g x/} out of the function \hbox{\lstinline/f/},
so that it may be computed explicitly.

\begin{ocaml}
let z = g 0
let v1 = h z "abc"
let v2 = h z 1.2
\end{ocaml}
%
However, this may not always be desirable because it exposed the implementation of the function
\hbox{\lstinline/f/}.
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tail-recursion
%
\begin{exercise}{append}
The function \hbox{\lstinline/append : 'a list -> 'a list -> 'a list/} appends two lists.  It can be defined as follows.

\begin{ocaml}
let rec append l1 l2 =
   match l1 with
      h :: t -> h :: append t l2
    | [] -> l2
\end{ocaml}
%
Write a tail-recursive version of \hbox{\lstinline/append/}.

\begin{answer}\ifanswers
In contrast to the \hbox{\lstinline/map/} function, which reverses the result, it is easier to reverse the
argument for the \hbox{\lstinline/append/} function.

\begin{ocaml}
let append l1 l2 =
   let rec rev_append l2 = function
      x :: l1 -> rev_append (x :: l2) l1
    | [] -> l2
   in
      rev_append l2 (List.rev l1)
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Welfare crook.
%
\begin{exercise}{welfare-crook}
It is known that a welfare crook lives in Los Angeles.  You are given lists for 1) people receiving
welfare, 2) Hollywood actors, and 3) residents of Beverly Hills.  The names in each list are
sorted alphabetically (by \hbox{\lstinline/</}).  A welfare crook is someone who appears in all three
lists.  Write an algorithm to find at least one crook.

\begin{answer}\ifanswers
Since the lists are sorted, we can search them from first to last, skipping a name when it doesn't
match the other lists.  We'll use \hbox{\lstinline/l1/}, \hbox{\lstinline/l2/}, and \hbox{\lstinline/l3/} for the lists.

\begin{ocaml}
let rec find_crook l1 l2 l3 =
   match l1, l2, l3 with
      (h1 :: t1), (h2 :: t2), (h3 :: t3) ->
         if      h1 < h2 || h1 < h3 then find_crook t1 l2 l3
         else if h2 < h1 || h2 < h3 then find_crook l1 t2 l3
         else if h3 < h1 || h3 < h2 then find_crook l1 l2 t3
         else (* all three names h1,h2,h3 are the same *) h1
    | _ ->
         raise (Invalid_argument "no crooks")
\end{ocaml}
\fi\end{answer}
\end{exercise}

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
% vim:tw=100:fo=tcq:
