%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Exercises
%

\exercises

\begin{exercise}{poly-fields}
The restriction about free type variables applies only to non-private method
types.  Which of the following definitions are legal?  For those that
are legal, give their types.  For those that are not legal, explain
why.

\begin{enumerate}
\item

\begin{ocamllisting}
class c1 = object val x = [] end;;
\end{ocamllisting}

\item

\begin{ocamllisting}
class c2 = object val x = ref [] end;;
\end{ocamllisting}

\item

\begin{ocamllisting}
class c3 x = object val y = x end
\end{ocamllisting}

\item

\begin{ocamllisting}
class c4 x = object val y = x method z = y end
\end{ocamllisting}

\item

\begin{ocamllisting}
class c5 x = object val y = x + 1 method z = y end
\end{ocamllisting}

\item

\begin{ocamllisting}
class c6 (x : 'a) = object constraint 'a = int method y = x end;;
\end{ocamllisting}
\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item

Legal; the type is \hbox{\lstinline$class c1 : object val x : 'a list end$}

\item

Legal; the type produced by the toploop is

\begin{ocaml}
class c2 : object val x : 'a list ref end
\end{ocaml}
%
This typing seems a little strange, since \hbox{\lstinline$x$} is not truly
polymorphic (its type should be \hbox{\lstinline$'_a list ref$}).

\item

Legal; the type is \hbox{\lstinline$class c3 : 'a -> object val y : 'a end$}.

\item

Not legal; the method \hbox{\lstinline$z$} has a polymorphic
type \hbox{\lstinline$'a$}, which is not a parameter of the class definition.

\item

Legal; the type is
\hbox{\lstinline$class c5 : int -> object val y : int method z : int end$}.

\item

Legal; the constraint means the class type is not polymorphic.  The type
is \hbox{\lstinline$class c6 : int -> object method y : int end$}.
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{poly-imperative-map}
Write an imperative version of a polymorphic map.  A newly-created map
should be empty.  The class should have the following type.

\begin{ocaml}
class ['a, 'b] imp_map : ('a -> 'a -> ordering) ->
  object
    method find   : 'a -> 'b
    method insert : 'a -> 'b -> unit
  end
\end{ocaml}

\begin{answer}\ifanswers
Here is one implementation.

\begin{ocaml}
class ['key, 'value] imp_map (compare : 'key -> 'key -> comparison) =
   let equal key1 (key2, _) = compare key1 key2 = Equal in
   object (self : 'self)
      val mutable elements : ('key * 'value) list = []
      method insert key value = elements <- (key, value) :: elements
      method find key = snd (List.find (equal key) elements)
   end;;
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{virtual-compare1}
Reimplement the polymorphic map class from page~\pageref{page:poly-map}
so that the class takes no arguments, and \hbox{\lstinline$compare$} is a
virtual method.  Define a specific class \hbox{\lstinline$int_map$} where
the keys have type \hbox{\lstinline$int$} with the usual ordering.

\begin{answer}\ifanswers
When \hbox{\lstinline$compare$} is implemented as a method, the equality
function \hbox{\lstinline$equal$} must also be a method.  

\begin{ocaml}
class virtual ['key, 'value] map =
  object (self : 'self)
    val elements : ('key * 'value)
    method add key value = {< elements = (key, value) :: elements >}
    method find key = snd (List.find (self#equal key) elements)

    method private equal key1 (key2, _) = compare key1 key2 = Equal
    method private virtual compare : 'key -> 'key -> ordering
  end;;

class ['value] int_map =
  object (self : 'self)
    inherit [int, 'value] map

    method private compare i j =
      if i < j then Smaller
      else if i > j then Larger
      else Equal
  end
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{polyclasses-self1}
In the class type definition \hbox{\lstinline$['a] tree$} on
page~\pageref{page:poly-tree}, the method \hbox{\lstinline$add$} has
type \hbox{\lstinline$'a -> 'a tree$}.  What would happen if we defined the
class type as follows?

\begin{ocaml}
class type ['a] self_tree =
  object ('self)
    method add : 'a -> 'self
    method mem : 'a -> bool
  end
\end{ocaml}

\begin{answer}\ifanswers
The alternate definition, using \hbox{\lstinline$'self$} does not work because
the class \hbox{\lstinline$leaf$} must create a new internal node.  The expression
\hbox{\lstinline$new node x (self :> 'a tree) (self : 'a tree)$} has type
\hbox{\lstinline$'a tree$}.  It doesn't have type \hbox{\lstinline$'self$}.
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{object-tree-compare}
In the implementations for the \hbox{\lstinline$['a] node$}
and \hbox{\lstinline$['a] leaf$} classes in
Section~\reflabelsection{polymorphic-class-types}, the
function \hbox{\lstinline$compare$} is threaded through the class
definitions.  Implement a functor \hbox{\lstinline$MakeTree$},
specified as follows.

\begin{ocaml}
type ordering = Smaller | Equal | Larger

module type CompareSig = sig
   type t
   val compare : t -> t -> ordering
end;;

class type ['a] tree =
  object ('self)
    method add : 'a -> 'a tree
    method mem : 'a -> bool
  end;;

module MakeTree (Compare : CompareSig)
  : sig val empty : Compare.t tree end =
struct $\cdots$ end
\end{ocaml}

\begin{answer}\ifanswers
\begin{ocaml}
module MakeTree (Compare : CompareSig)
  : sig val empty : Compare.t tree end =
struct
   open Compare
   type key = Compare.t
   type t = key tree

   class node x (l : t) (r : t) =
     object (self : 'self)
       val label = x
       val left = l
       val right = r
       method mem x =
         match compare x label with
            Smaller -> left#mem x
          | Larger -> right#mem x
          | Equal -> true
       method add x =
         match compare x label with
            Smaller -> {< left = left#add x >}
          | Larger -> {< right = right#add x >}
          | Equal -> self
   end;;

   class leaf =
     object (self : 'self)
       method mem _ = false
       method add x = new node x (self :> t) (self :> t)
     end;;

   let empty = new leaf;;
end;;
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{object-tree-virtual}
Instead of defining a class type \hbox{\lstinline$class type ['a] tree$},
we could have specified it as a virtual class like the following.

\begin{ocaml}
class virtual ['a] virtual_tree =
  object (self : 'self)
    method virtual add : 'a -> 'a virtual_tree
    method virtual mem : 'a -> bool
  end;;
\end{ocaml}
%
Are there any advantages or disadvantages to this approach?

\begin{answer}\ifanswers
The new definition is nearly the same.  However, class definitions,
even virtual ones, are not allowed in signatures or interfaces
(\hbox{\lstinline$.mli$} files), so there is a disadvantage to using the
virtual class specification.
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{variance-annotations1}
Which of the following class definitions are legal?  Explain your answers.

\begin{enumerate}
\item

\begin{ocamllisting}
class [+'a] cl (x : 'a) =
  object (self : 'self)
    val f : 'a -> unit = fun x -> ()
    method value : unit -> 'a = fun () -> x
  end
\end{ocamllisting}

\item 

\begin{ocamllisting}
class [+'a] cl =
  object (self : 'self)
    method f : 'a -> unit = fun x -> ()
  end
\end{ocamllisting}

\item

\begin{ocamllisting}
class [+'a] cl =
  object (self : 'self)
    method private f : 'a -> unit = fun x -> ()
  end
\end{ocamllisting}

\item

\begin{ocamllisting}
class [+'a] cl =
  object (self : 'a)
    method copy : 'a = {< >}
  end
\end{ocamllisting}

\item

\begin{ocamllisting}
class [-'a] cl (x : 'a) =
  object (self : 'self)
    val mutable y = x
    method f x = y <- x
  end;;
\end{ocamllisting}

\item

\begin{ocamllisting}
class foo = object end
class ['a] cl (x : 'a) =
  object
    constraint 'a = #foo
    method value : #foo = x
  end
\end{ocamllisting}

\item

\begin{ocamllisting}
class foo = object end
class [-'a] cl (x : #foo as 'a) =
  object
    method value : #foo = x
  end
\end{ocamllisting}

\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item The annotation is legal, because fields are not part of the variance calculation.
\item The annotation is not legal, the type variable \hbox{\lstinline$'a$} occurs negatively.
\item The annotation is legal, because private methods are not part of the variance calculation.
\item The annotation is legal.
\item The annotation is legal, because \hbox{\lstinline$'a$} occurs only negatively in the type of the method \hbox{\lstinline$f$}.
\item The annotation is legal.
\item The annotation is not legal, because the type \hbox{\lstinline$#foo$} must be covariant.
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{animal-pair1}
Consider the following class definitions.

\begin{center}
\begin{tabular}{cc}
\begin{minipage}[t]{2.8in}
\begin{ocamllisting}
class ['a] alt_animal_pair1 (p : 'a) =
  object (self : 'self)
    constraint 'a = ('b, 'b) #pair
    constraint 'b = #animal
    method sleep =
      let a1, a2 = p#value in
      a1#sleep; a2#sleep
  end;;
\end{ocamllisting}
\end{minipage}
&
\begin{minipage}[t]{2.2in}
\begin{ocamllisting}
class ['a] alt_animal_pair2
  (a1 : 'b) (a2 : 'c) =
  object (self : 'self)
    inherit ['b, 'c] pair a1 a2
    constraint 'a = 'b * 'c
    constraint 'b = #animal
    constraint 'c = #animal
    method sleep =
      a1#sleep; a2#sleep
  end;;
\end{ocamllisting}
\end{minipage}
\end{tabular}
\end{center}
%
\begin{enumerate}
\item

The type variable \hbox{\lstinline$'b$} is not a type parameter
of \hbox{\lstinline$alt_animal_pair1$}.  Why is the definition legal?

\item

Is the type \hbox{\lstinline$['a] alt_animal_pair1$} covariant, contravariant, or invariant in \hbox{\lstinline$'a$}?

\item

Suppose we have a class \hbox{\lstinline$cat$} that is a subtype of \hbox{\lstinline$animal$}.
What is the type of the following expression?

\begin{ocaml}
new alt_animal_pair2 (new dog "Spot") (new cat "Fifi");;
\end{ocaml}

\item

What happens if the line \hbox{\lstinline$constraint 'a = 'b * 'c$} is left out
of the class definition for \hbox{\lstinline$alt_animal_pair2$}?

\item

What if the line is replaced with \hbox{\lstinline$constraint 'a = 'b -> 'c$}?

\item

In principle, is it ever necessary for a class to have more than one
type parameter?
\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item 

The definition is legal because the type variable \hbox{\lstinline$'b$} is
included as a part of \hbox{\lstinline$'a$}, so \hbox{\lstinline$'b$} is not free in
the definition.

\item

Technically, all three annotations \hbox{\lstinline$+'a$}, \hbox{\lstinline$-'a$},
and \hbox{\lstinline$'a$} are accepted.  However, since the
type \hbox{\lstinline$('b, 'b) pair$} is covariant in \hbox{\lstinline$'b$}, the
definition is also covariant in \hbox{\lstinline$'a$}.

\item

The type is \hbox{\lstinline$(dog * cat) alt_animal_pair2$}.  Note that the
type \hbox{\lstinline$dog * cat$} is artificial, it has nothing to do
with whether the class represents a pair.

\item

If the constraint is left out, the type variables \hbox{\lstinline$'b$}
and \hbox{\lstinline$'c$} become free in the class definition, so the
definition is rejected.

\item

The constraint \hbox{\lstinline$constraint 'a = 'b -> 'c$} is also legal, but
it means that the definition is no longer covariant in \hbox{\lstinline$'a$}.

\item

Strictly speaking, it isn't necessary.  Suppose we have a class type
\hbox{\lstinline/[-'a1, $\ldots$, -'an, +'b1, $\ldots$, +'bm] cl/}.
We can replace it with a single constraint \hbox{\lstinline/['c] cl/}
and the following constraint.

\begin{ocaml}
constraint 'c = ('a1 * $\cdots$ * 'an) -> ('b1 * $\cdots$ * 'bn)
\end{ocaml}
%
We can't specify the variance of \hbox{\lstinline$'c$}, but the constraint
enforces the variance.
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{env-variance}
In the object implementation of the evaluator in
Figure~\reffigure{implementing-evaluator}, the method \hbox{\lstinline$eval$}
takes an environment of exact type \hbox{\lstinline$int env$}.  Suppose we
try to change it to the following definition.

\begin{ocaml}
class type exp =
  object ('self)
    method eval : int #env -> int
  end

class int_exp (i : int) : exp =
  object (self : 'self)
    method eval (_ : int #env) = i
  end;;
$\cdots$
\end{ocaml}
%
\begin{enumerate}
\item

The new type definition is accepted, but the class
definition \hbox{\lstinline$int_exp$} is rejected.  How can it be fixed?

\item Are there any advantages to the new definition?
\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item

The problem is that the type \hbox{\lstinline$#env$} is polymorphic.
We can fix the definition by using a polymorphic method type.

\begin{ocaml}
class int_exp (i : int) : exp =
  object (self : 'self)
    method eval : 'a. (int #env as 'a) -> int = (fun _ -> i)
  end;;
\end{ocaml}

\item

There isn't really any reason to use the new definition, because 
an environment of type \hbox{\lstinline$int #env$} is no more useful than
an environment of type \hbox{\lstinline$int env$}.  The only savings is
in the outermost call to the evaluator, where is may be possible
to omit a coercion.
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{monoclasses}
Consider the following class definition.

\begin{ocaml}
# class type ['a] c1 = object method f : c2 -> 'a end
  and c2 = object method g : int c1 end;;
@
\begin{topoutput}
class type ['a] c1 = object constraint 'a = int method f : c2 -> 'a end
and c2 = object method g : int c1 end
\end{topoutput}
@
\end{ocaml}
%
Unfortunately, even though the class type \lstinline$['a] c1$ should
be polymorphic in \hbox{\lstinline$'a$}, a type constraint is inferred
that \hbox{\lstinline$'a = int$}.  The problem is that polymorphic
type definitions are not polymorphic \emph{within} a recursive
definition.

\begin{enumerate}
\item

Suggest a solution to the problem, where class type \lstinline$c1$ is
truly polymorphic.

\item

The following definition is rejected.

\begin{ocaml}
# class type ['a] c1 = object method f : c2 -> 'a end
  and c2 = object method g : 'a. 'a c1 -> 'a end;;
@
\begin{toperror}
Characters 79-94:
and c2 = object method g : 'a. 'a c1 -> 'a end;;
                           ^^^^^^^^^^^^^^^
This type scheme cannot quantify 'a :
it escapes this scope.
\end{toperror}
@
\end{ocaml}
%
The problem arises from the same issue---the class \lstinline$['a] c1$
is not polymorphic within the recursive definition, so the
type \lstinline$'a. 'a c1 -> 'a$ is rejected.

Suggest a solution to this problem.
\end{enumerate}

\begin{answer}\ifanswers
The solution in both cases is to break apart the recursive definition
by adding a type parameter to the class type \lstinline$c1$ that represents
the class \hbox{\lstinline$c2$}.

\begin{ocaml}
class type ['a, 'c2] pre_c1 = object method f : 'c2 -> 'a end
\end{ocaml}
%
The solutions are then as follows.

\begin{enumerate}
\item

\begin{ocamllisting}
class type c2 = object method g : (int, c2) pre_c1 end
class type ['a] c1 = ['a, c2] pre_c1
\end{ocamllisting}

\item

\begin{ocamllisting}
class type c2 = object method g : 'a. ('a, c2) pre_c1 -> 'a end
class type ['a] c1 = ['a, c2] pre_c1
\end{ocamllisting}
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{visitor-pattern}
As discussed in
Section~\reflabelsection{comparing-objects-and-modules}, one problem
with object-oriented implementations is that adding a new functionality
to a class hierarchy might require modifying all the classes
in the hierarchy.  \emph{Visitor design patterns} are one way in
which this problem can be addressed.

A \emph{visitor} is defined as an object with a method for each of the
kinds of data.  For the type \hbox{\lstinline$exp$}, a visitor would have the
following type.

\begin{ocaml}
class type visitor =
  object ('self)
    method visit_int : int_exp -> unit
    method visit_var : var_exp -> unit
    method visit_add : add_exp -> unit
    method visit_if  : if_exp  -> unit
    method visit_let : let_exp -> unit
  end;;
\end{ocaml}
%
The class type \hbox{\lstinline$exp$} is augmented with a
method \hbox{\lstinline$accept : visitor -> unit$} that guides the
visitor through an expression, visiting every subexpression in turn.
Here is a fragment of the code.

\begin{ocaml}
class type exp =
  object ('self)
    method eval : int env -> int
    method accept : visitor -> unit
  end;;

class int_exp (i : int) =
  object (self : 'self)
    method eval (_ : int env) = i
    method accept visitor = visitor#visit_int (self :> int_exp)
  end

class add_exp (e1 : #exp) (e2 : #exp) =
  object (self : 'self)
    method eval env = e1#eval env + e2#eval env
    method accept visitor =
      visitor#visit (self :> add_exp);
      e1#accept visitor;
      e2#accept visitor
  end
$\cdots$
\end{ocaml}

\begin{enumerate}
\item[1.]

One problem with this approach is the order of definitions.  For
example, the class type \hbox{\lstinline$visitor$} refers to the
class \hbox{\lstinline$add_exp$}, which refers back to
the \hbox{\lstinline$visitor$} type in the definition of the
method \hbox{\lstinline$accept$}.

\begin{enumerate}
\item We could simplify the types.  Would the following definition be acceptable?

\begin{ocaml}
class type exp =
  object ('self)
    method eval : int env -> int
    method accept : visitor -> unit
  end

and visitor =
  object ('self)
    method visit_int : exp -> unit
    method visit_var : exp -> unit
    $\cdots$
  end
\end{ocaml}

\item

What is a better way to solve this problem?
\end{enumerate}

\item[2.]

The class type \hbox{\lstinline$visitor$} has one method for each specific
kind of expression.  What must be done when a new kind of expression
is added?
\end{enumerate}
%
As defined, the visitor pattern is not very useful because the classes
do not provide any additional information about themselves.  Suppose
we add a method \hbox{\lstinline$explode$} that presents the contents
of the object as a tuple.  Here is a fragment.

\begin{ocaml}
class type exp = object $\cdots$ end
and visitor = object $\cdots$ end

and int_exp_type =
  object ('self)
    inherit exp
    method explode : int
  end

and add_exp_type =
  object ('self)
    inherit exp
    method explode : exp * exp
  end
$\cdots$
\end{ocaml}

\begin{enumerate}
\item[3.]

Since the method \hbox{\lstinline$explode$} exposes the internal representation,
it isn't really necessary for the \hbox{\lstinline$accept$} methods to perform the
recursive calls.  For example, we could make the following definition,
and assume that the visitor will handle the recursive calls itself.

\begin{ocaml}
class add_exp (e1 : #env) (e2 : #env) : add_exp_type =
  object (self : 'self)
    method eval env = e1#eval env + e2#eval env
    method accept visitor = visitor#visit_add (self :> add_exp_type)
    method explode = e1, e2
  end
\end{ocaml}
%
What are the advantages of this approach?  What are its disadvantages?

\item[4.]

Another approach is, instead of passing the objects directly to the
visitor, to pass the exploded values as arguments.  Here is the new visitor
type definition.

\begin{ocaml}
class type visitor =
  object ('self)
    method visit_int : int -> unit
    method visit_add : exp -> exp -> unit
    $\cdots$
  end
\end{ocaml}
%
What are the advantages of this approach?  What are its disadvantages?

\item[5.]

Write a visitor to print out an expression.
\end{enumerate}
%
The visitors we have specified are imperative.  It is also possible to
write pure visitors that compute without side-effects.  The visitor
has a polymorphic class type parameterized over the type of values it
computes.  As discussed in Exercise~\ref{exercise:monoclasses}, a recursive
definition does not work, so we break apart the recursive definition.

\begin{ocaml}
class type ['a, 'exp] pre_visitor =
  object ('self)
    method visit_int : int -> 'a
    method visit_var : string -> 'a
    method visit_add : 'exp -> 'exp -> 'a
    method visit_if  : 'exp -> 'exp -> 'exp -> 'a
    method visit_let : string -> 'exp -> 'exp -> 'a
  end;;

class type exp =
  object ('self)
    method eval   : int env -> int
    method accept : 'a. ('a, exp) pre_visitor -> 'a
  end

class type ['a] visitor = ['a, exp] pre_visitor
\end{ocaml}

\begin{enumerate}
\item[6.]

Rewrite the class definitions to implement the new \hbox{\lstinline$accept$} methods.

\item[7.]

Write an evaluator as a pure visitor \hbox{\lstinline$eval_visitor$}.
The \hbox{\lstinline$eval_visitor$} is not allowed to call the
method \hbox{\lstinline$eval$}, and it is not allowed to use assignment or
any other form of side-effect.
\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item

\begin{enumerate}
\item
The simplified class type \hbox{\lstinline$visitor$} is not acceptable because the
visitor methods are called with a plain expression \hbox{\lstinline$exp$}, which
isn't enough to do deconstruction.

\item

A better way is to define class types for each of the kinds of
expressions.  For example, an object of class \hbox{\lstinline$add_exp$}
might have a class type definition \hbox{\lstinline$add_exp_type$} that
includes a method \hbox{\lstinline$subterms$} to allow the visitor to
decompose the sum.

\begin{ocaml}
class type add_exp_type =
  object ('self)
    inherit exp
    method subterms : exp * exp
  end

class add_exp (e1 : exp) (e2 : exp) =
  object (self : 'self)
    $\cdots$
    method subterms = e1, e2
  end
\end{ocaml}
\end{enumerate}

\item

When a new kind of expression is added, the class type \lstinline$visitor$ must
be extended with a new method definition, and all visitors must be updated
to implement the new method.  This is the same issue that appears when adding
a new expression to the union representation.

\item 

The advantages of the approach is that the visitor can choose how to visit,
and in what order.  For example, the visitor might choose to visit an
expression from the bottom up, or from the top down.

The disadvantages are that the burden of traversal is shifted onto the
visitor, which means 1) each kind visitor must duplicate the traversal code,
and 2) the traversal code may become out of date as the original definitions
are modified.

One intermediate approach is to define virtual classes that provide
code for the common traversals.  Specific visitors would become
subclasses of some version of a traversal class.

\item 

Some advantages are that the new code may be slightly more efficient
because the visitor doesn't have to call the
method \hbox{\lstinline$explode$} to decompose the object.  In many cases,
the code may also be easier to write.  The principal disadvantage is
the the visitor no longer has access to the original object, which may
be required if, for example, the visitor wishes to modify the object
in-place.

\item

Here is an example printer, based on the exploded visitor definition from part 3.

\begin{ocaml}
class print_visitor : visitor =
  object (self : 'self)
    method visit_int (e : int_exp_type) =
       print_int e#explode
    method visit_var (e : var_exp_type) =
       print_string e#explode
    method visit_add (e : add_exp_type) =
       let e1, e2 = e#explode in
       print_string "(";
       e1#accept (self :> visitor);
       print_string " + ";
       e2#accept (self :> visitor);
       print_string ")"
    method visit_if (e : if_exp_type) =
       let e1, e2, e3 = e#explode in
       print_string "(if ";
       e1#accept (self :> visitor);
       print_string " then ";
       e2#accept (self :> visitor);
       print_string " else ";
       e3#accept (self :> visitor);
       print_string ")"
    method visit_let (e : let_exp_type) =
       let v, e1, e2 = e#explode in
       printf "(let %s = " v;
       e1#accept (self :> visitor);
       print_string " in ";
       e2#accept (self :> visitor);
       print_string ")"
  end;;
\end{ocaml}

\item 

Here are the definitions of the expression classes.  We change
the type of the method \hbox{\lstinline$accept$} slightly so that it is
possible to pass a subtype of a \hbox{\lstinline$visitor$} without coercing.
The method \hbox{\lstinline$eval$} has been omitted (we'll define it
as a visitor in the next part).

\begin{ocaml}
class type ['a, 'exp] visitor =
  object ('self)
    method visit_int : int -> 'a
    method visit_var : string -> 'a
    method visit_add : 'exp -> 'exp -> 'a
    method visit_if  : 'exp -> 'exp -> 'exp -> 'a
    method visit_let : string -> 'exp -> 'exp -> 'a
  end;;

class type exp =
  object ('self)
    method accept : 'a 'b. (('a, exp) #visitor as 'b) -> 'a
  end

class int_exp (i : int) =
  object (self : 'self)
    method accept : 'a 'b. (('a, exp) #visitor as 'b) -> 'a =
      fun visitor -> visitor#visit_int i
  end

class var_exp v =
  object (self : 'self)
    method accept : 'a 'b. (('a, exp) #visitor as 'b) -> 'a =
      fun visitor -> visitor#visit_var v
  end

class add_exp (e1 : #exp) (e2 : #exp) =
  object (self : 'self)
    method accept : 'a 'b. (('a, exp) #visitor as 'b) -> 'a =
      fun visitor -> visitor#visit_add e1 e2
  end

class if_exp (e1 : #exp) (e2 : #exp) (e3 : #exp) =
  object (self : 'self)
    method accept : 'a 'b. (('a, exp) #visitor as 'b) -> 'a =
      fun visitor -> visitor#visit_if e1 e2 e3
  end

class let_exp (v : string) (e1 : #exp) (e2 : #exp) =
  object (self : 'self)
    method accept : 'a 'b. (('a, exp) #visitor as 'b) -> 'a =
      fun visitor -> visitor#visit_let v e1 e2
  end;;
\end{ocaml}

\item

The evaluator object needs to include the environment so that
variables can be evaluated.  Here is a completely pure implementation.

\begin{ocaml}
class eval_visitor : [int, exp] visitor =
  object (self : 'self)
    val env = new env

    method visit_int (i : int) =
       i
    method visit_var v =
       env#find v
    method visit_add (e1 : exp) (e2 : exp) =
       e1#accept self + e2#accept self
    method visit_if (e1 : exp) (e2 : exp) (e3 : exp) =
       if e1#accept self <> 0
       then e2#accept self
       else e3#accept self
    method visit_let v (e1 : exp) (e2 : exp) =
       e2#accept {< env = env#add v (e1#accept self) >}
  end;;
\end{ocaml}
%
Note that this code is nearly as concise as the version defined over
the union representation of expressions.
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{exercise}{variants1}
We also stated in
Section~\reflabelsection{comparing-objects-and-modules} that one
problem with the traditional functional representation is that it is hard to add a
new case to a union, because each of the functions that operate on the
data must also be updated.

One way to address this is through the use of \emph{polymorphic
variants}, discussed in Section~\reflabelsection{open-union-types}.
Polymorphic variants can be defined as ``open'' types that can be
later extended.  For the evaluator example, here is how we might
define the initial type of expressions.

\begin{ocaml}
type 'a exp1 = 'a constraint 'a =
 [> `Int of int
  | `Var of string
  | `Add of 'a * 'a
  | `If  of 'a * 'a * 'a
  | `Let of string * 'a * 'a ]
\end{ocaml}
%
The type \lstinline$'a exp$ is an open type that includes at least
the cases specified in the type definition.
The type of an evaluator is defined as follows, where the
module \lstinline$Env$ is defined on
page~\pageref{page:polyclasses-env}.

\begin{ocaml}
type 'a evaluator = int Env.t -> 'a -> int
\end{ocaml}
%
\begin{enumerate}
\item[1.]

Write an evaluator (of type \hbox{\lstinline$'a exp evaluator$}).
\end{enumerate}
%
We can extend the type of expressions by adding an additional constraint
that specifies the new kinds of expressions.  For example, this is how we might
add products as a kind of expression.

\begin{ocaml}
type 'a exp2 = 'a
   constraint 'a = 'a exp1
   constraint 'a = [> `Mul of 'a * 'a ]
\end{ocaml}
%
The next step is to define an evaluator of type
\hbox{\lstinline$'a exp2 evaluator$}.
However, we don't want to reimplement it
completely---we would like to be able to re-use the previous
implementation.  For this, we need a kind of ``open recursion.''
Let's define a \emph{pre-evaluator} as a function of the following
type.  That is, a pre-evaluator takes an evaluator as an argument
for computing values of subterms.

\begin{ocaml}
type 'a pre_evaluator = 'a evaluator -> 'a evaluator

let pre_eval1 eval_subterm env = function
   `Add (e1, e2) -> eval_subterm env e1 + eval_subterm env e2
 | $\cdots$
\end{ocaml}
%
The function has type \hbox{\lstinline$pre_eval1 : 'a exp1 pre_evaluator$}.

\begin{enumerate}
\item[2.]

Write the complete definition of \lstinline$pre_eval1$.

\item[3.]

Write a function \lstinline$make_eval$ that turns a pre-evaluator into
an evaluator.  Hint: this is a kind of ``fixpoint'' definition, explored
in Exercise~\ref{exercise:tims-and-jasons-y-combinator}.

\begin{ocaml}
val make_eval : 'a pre_evaluator -> 'a evaluator
\end{ocaml}

\item[4.]

The pre-evaluator \hbox{\lstinline$pre_eval2 : 'a exp2 pre_evaluator$}
can be implemented as follows.

\begin{ocaml}
let pre_eval2 eval_subterm env = function
   `Mul (e1, e2) -> eval_subterm env e1 * eval_subterm env e2
 | e -> pre_eval1 eval_subterm env e
\end{ocaml}
%
Implement the evaluator \hbox{\lstinline$eval2 : 'a exp2 evaluator$}
in terms of \hbox{\lstinline$pre_eval2$}.
\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item

Here is a complete definition.  Since the type is open, there is a
wildcard case for unknown expressions.

\begin{ocaml}
let rec eval1 env = function
   `Int i -> i
 | `Var v -> Env.find env v
 | `Add (e1, e2) -> eval1 env e1 + eval1 env e2
 | `If (e1, e2, e3) ->
      if eval1 env e1 <> 0
      then eval1 env e2
      else eval1 env e3
 | `Let (v, e1, e2) ->
      let i = eval1 env e1 in
      let env' = Env.add env v i in
      eval1 env' e2
 | _ ->
      raise (Failure "eval")
\end{ocaml}

\item

The pre-evaluator \lstinline$pre_eval1$ is very similar
to \hbox{\lstinline$eval1$}, but it is not directly recursive.

\begin{ocaml}
let pre_eval1 eval_subterm env = function
   `Int i -> i
 | `Var v -> Env.find env v
 | `Add (e1, e2) ->
      eval_subterm env e1 + eval_subterm env e2
 | `If (e1, e2, e3) ->
      if eval_subterm env e1 <> 0
      then eval_subterm env e2
      else eval_subterm env e3
 | `Let (v, e1, e2) ->
      let i = eval_subterm env e1 in
      let env' = Env.add env v i in
      eval_subterm env' e2
 | _ ->
      raise (Failure "eval")
\end{ocaml}

\item

The function \lstinline$make_eval$ wraps the pre-evaluator in a
fixpoint definition.

\begin{ocaml}
let rec make_eval pre_eval env e =
   pre_eval (make_eval pre_eval) env e
\end{ocaml}

\item

The evaluator can be constructed using the function \lstinline$make_eval$.

\begin{ocaml}
let eval2 env e = make_eval pre_eval2 env e
\end{ocaml}
\end{enumerate}
\fi\end{answer}
\end{exercise}

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
% vim:tw=100:fo=tcq:
