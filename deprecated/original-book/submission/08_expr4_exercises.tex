%
%
%
\exercises

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Reference cells
%
\begin{exercise}{ref-record}
Reference cells are a special case of records, with the following type definition.

\begin{ocaml}
type 'a ref = { mutable contents : 'a }
\end{ocaml}
%
Implement the operations on reference cells.

\begin{ocaml}
val ref  : 'a -> 'a ref
val (!)  : 'a ref -> 'a
val (:=) : 'a ref -> 'a -> unit
\end{ocaml}

\begin{answer}\ifanswers
The operations are implemented with operations on records.

\begin{ocaml}
let ref x = { contents = x }
let (!) cell = cell.contents
let (:=) cell x = cell.contents <- x
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Value restriction.
%
\begin{exercise}{record-value-restriction}
Consider the following record type definition.

\begin{ocaml}
type ('a, 'b) mpair = { mutable fst : 'a; snd : 'b }
\end{ocaml}
%
What are the types of the following expressions?

\begin{enumerate}
\item \lstinline$[|[]|]$

\begin{answer}\ifanswers
The type is \hbox{\lstinline/[|[]|] : '_a list array/}.
\fi\end{answer}

\item \lstinline+{ fst = []; snd = [] }+

\begin{answer}\ifanswers
Mutable fields are not values, so the field \hbox{\lstinline/fst/} is not polymorphic because of the value restriction.
The type is \hbox{\lstinline/{ fst = []; snd = [] } : ('_a list, 'b list) mpair/}.
\fi\end{answer}

\item \lstinline+{ { fst = (); snd = 2 } with fst = 1 }+

\begin{answer}\ifanswers
During a functional update, it is legal for the types of polymorphic fields to change.
The expression \hbox{\lstinline/{ fst = (); snd = 2 }/} has type \hbox{\lstinline/(unit, int) mpair/},
but the final value is \hbox{\lstinline/{ fst = 1; snd = 2 }/} of type \hbox{\lstinline/(int, int) mpair/}.
\fi\end{answer}
\end{enumerate}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ADTs
%
\begin{exercise}{record-adt}
Records can be used to implement abstract data structures, where the data structure is viewed as
a record of functions, and the data representation is hidden.  For example, a type definition for a
functional dictionary is as follows.

\begin{ocaml}
type ('key, 'value) dictionary =
   { insert : 'key -> 'value -> ('key, 'value) dictionary;
     find   : 'key -> 'value
   }

val empty : ('key, 'value) dictionary
\end{ocaml}
%
Implement the empty dictionary \hbox{\lstinline/empty/}.  Your implementation should be pure, without side-effects.
You are free to use any internal representation of the dictionary.

\begin{answer}\ifanswers
We'll use association lists.  The function \hbox{\lstinline/insert/} adds to the list, and \hbox{\lstinline/find/}
searches the list.  The function \hbox{\lstinline/new_dictionary/} is used to form a dictionary from
an association list.

\begin{ocaml}
let empty =
   let rec find entries key =
      match entries with
         (key', value) :: _ when key' = key -> value
       | _ :: entries -> find entries key
       | [] -> raise Not_found
   in
   let rec new_dictionary entries =
      { insert = insert entries;
        find = find entries
      }
   and insert entries key value =
      new_dictionary ((key, value) :: entries)
   in
   new_dictionary []
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Objects
%
\begin{exercise}{record-objects1}
Records can also be used to implement a simple form of object-oriented programming.  Suppose we are
implementing a collection of geometric objects (blobs), where each blob has a position, a function (called a \emph{method}) to
compute the area covered by the blob, and methods to set the position and move the blob.  The
following record defines the methods for a generic object.

\begin{ocaml}
type blob =
   { get    : unit -> float * float;
     area   : unit -> float;
     set    : float * float -> unit;
     move   : float * float -> unit
   }
\end{ocaml}
%
An actual object like a rectangle might be defined as follows.

\begin{ocaml}
let new_rectangle x y w h =
   let pos = ref (x, y) in
   let rec r =
      { get  = (fun () -> !pos);
        area = (fun () -> w *. h);
        set  = (fun loc -> pos := loc);
        move = (fun (dx, dy) ->
                   let (x, y) = r.get () in
                   r.set (x +. dx, y +. dy))
      }
   in
   r
\end{ocaml}
%
The rectangle record is defined recursively so that the method \hbox{\lstinline/move/} can be defined in
terms of \hbox{\lstinline/get/} and \hbox{\lstinline/set/}.

Suppose we have created a new rectangle \hbox{\lstinline/rect1/}, manipulated it, and now we want to fix it
in position.  We might try to do this by redefining the method \hbox{\lstinline/set/}.

\begin{ocaml}
let rect1 = new_rectangle 0.0 0.0 1.0 1.0 in
rect1.move 1.2 3.4; $\cdots$
let rect2 = { rect1 with set = (fun _ -> ()) }
\end{ocaml}
%
\begin{enumerate}
\item What happens to \hbox{\lstinline/rect2/} when \hbox{\lstinline/rect2.move/} is called?  How can you prevent it from moving?
\item What happens to \hbox{\lstinline/rect2/} when \hbox{\lstinline/rect1.set/} is called?
\end{enumerate}

\begin{answer}\ifanswers
The problem is that the method \hbox{\lstinline/move/} refers to the definitions of \hbox{\lstinline/get/} and
\hbox{\lstinline/set/} when the rectangle is first created.  This is called \emph{early binding}, where
true object systems use \emph{late} binding.  Early binding means that the method \hbox{\lstinline/move/}
is not updated when \hbox{\lstinline/set/} is changed.

\begin{enumerate}
\item
The expression \hbox{\lstinline/rect2.move (dx, dy)/} moves \hbox{\lstinline/rect2/} by \hbox{\lstinline/(dx, dy)/}.  To
prevent this from happening, the method \hbox{\lstinline/move/} should be updated as well.

\begin{ocaml}
let rect2 = { rect1 with set = (fun _ -> ()); move = (fun _ -> ()) }
\end{ocaml}

\item The rectangles \hbox{\lstinline/rect2/} and \hbox{\lstinline/rect1/} refer to the same position \hbox{\lstinline/pos/},
so setting the position of \hbox{\lstinline/rect1/} also moves \hbox{\lstinline/rect2/}.
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Array reversal
%
\begin{exercise}{reverse}
Write a function \hbox{\lstinline/string_reverse : string -> unit/} to reverse a string in-place.

\begin{answer}\ifanswers
\begin{ocaml}
let string_reverse s =
   let len = String.length s in
   for i = 0 to len / 2 - 1 do
      let c = s.[i] in
      s.[i] <- s.[len - i - 1];
      s.[len - i - 1] <- c
   done
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Blit
%
\begin{exercise}{blit}
What problem might arise with the following implementation of an array blit function?
How can it be fixed?

\begin{ocaml}
let blit src src_off dst dst_off len =
   for i = 0 to len - 1 do
      dst.(dst_off + i) <- src.(src_off + i)
   done
\end{ocaml}

\begin{answer}\ifanswers
There can be a problem if the \hbox{\lstinline/src/} and \hbox{\lstinline/dst/} arrays are the same,
and the ranges to be copied overlap, and \hbox{\lstinline/dst_off > src_off/}.

For example, the following expression duplicates the first element of the array
instead of copying a subrange.

\begin{ocaml}
let data = [|1; 2; 3; 4; 5; 6; 7; 8; 9|];;
@
\begin{topoutput}
val data : int array = [|1; 2; 3; 4; 5; 6; 7; 8; 9|]
\end{topoutput}
@
# blit data 0 data 1 5;;
@
\begin{topoutput}
- : unit = ()
\end{topoutput}
@
# data;;
@
\begin{topoutput}
- : int array = [|1; 1; 1; 1; 1; 1; 7; 8; 9|]
\end{topoutput}
@
\end{ocaml}
%
An easy solution is to copy in reverse direction when \hbox{\lstinline/dst_off > src_off/}.

\begin{ocaml}
let blit src src_off dst dst_off len =
   if dst_off < src_off then
      for i = 0 to len - 1 do
         dst.(dst_off + i) <- src.(src_off + i)
      done
   else
      for i = len - 1 downto 0 do
         dst.(dst_off + i) <- src.(src_off + i)
      done
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Insertion sort
%
\begin{exercise}{insertion-sort}
\index{insertion sort}

\emph{Insertion sort}
is a sorting algorithm that works by inserting elements one-by-one
into an array of sorted elements.  Although the algorithm takes
$O(n^2)$ time to sort an array of $n$ elements, it is simple, and it
is also efficient when the array to be sorted is small.  The
pseudo-code is as follows.

\begin{ccode}
insert(array a, int i)
    x <- a[i]
    j <- i - 1
    while j >= 0 and a[j] > x
        a[j] <- a[j - 1]
        j = j - 1
    a[j + 1] <- x

insertion_sort(array a)
    i <- 1
    while i < length(a)
        insert(a, i)
        i <- i + 1
\end{ccode}
%
Write this program in OCaml.

\begin{answer}\ifanswers
Each of the constructs in the pseudo-code can be translated directly to OCaml.  However, it is
slightly more efficient to avoid the use of reference cells, and translate the while-loop as a
recursive function.

\begin{ocaml}
let insert a i =
   let x = a.(i) in
   let rec loop j =
      if j >= 0 && a.(j) > x then begin
         a.(j) <- a.(j - 1);
         loop (j - 1)
      end
      else
         j
   in
   let j = loop (i - 1) in
   a.(j) <- x

and insertion_sort a =
   for i = 1 to Array.length a - 1 do
      insert a i
   done
\end{ocaml}
\fi\end{answer}
\end{exercise}

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
% vim:tw=100:fo=tcq:
