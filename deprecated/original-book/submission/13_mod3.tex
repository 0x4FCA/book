%
%
%

\labelchapter{functors}{Functors}

Modules often refer to other modules. The modules we saw in
Chapter~\reflabelchapter{modules} referred to other modules by
name. Thus, all the module references \misspelled{we've} seen up to this point have
been to specific, constant modules.

\index{functors|see{modules}} \index{modules!functors} It's also possible in OCaml to write modules
that are parameterized by other modules.  To be used, functors are instantiated by supplying actual
module arguments for the functor's module parameters (similar to supplying arguments in a function
call).

To illustrate the use of a parameterized module, let's return to the
set implementation we have been using in the previous two
chapters. One of the problems with that implementation is that the
elements are compared using the OCaml built-in equality
function \hbox{\lstinline/=/}.  What if, for example, we want a set of
strings where equality is case-insensitive, or a set of floating-point
numbers where equality is to within a small constant?  Rather than
re-implementing a new set for each of new case, we can implement it as
a functor, where the equality function is provided as a parameter.  An
example is shown in Figure~\reffigure{mset1}, where we represent the
set as a list of elements.

\label{modules:application}
\begin{figure}
\begin{center}
\begin{tabular}[t]{l}
Set functor\\
\hline
\begin{ocamllisting}
module type EqualSig = sig
   type t
   val equal : t -> t -> bool
end;;

module MakeSet (Equal : EqualSig) = struct
   open Equal
   type elt = Equal.t
   type t = elt list
   let empty = []
   let mem x s = List.exists (equal x) s
   let add = (::)
   let find x s = List.find (equal x) s
end;;
\end{ocamllisting}\\
\\
Building a specific case\\
\hline
\begin{ocamllisting}
module StringCaseEqual = struct
   type t = string
   let equal s1 s2 =
      String.lowercase s1 = String.lowercase s2
end;;
module SSet = MakeSet (StringCaseEqual);;
\end{ocamllisting}\\
\\
Using the set\\
\hline
\begin{ocamllisting}
# let s = SSet.add "Great Expectations" SSet.empty;
val s : string list = ["Great Expectations"]
# SSet.mem "great eXpectations" s;;
- : bool = true
# SSet.find "great eXpectations" s;;
- StringCaseEqual.t = "Great Expectations"
\end{ocamllisting}
\end{tabular}
\end{center}
\caption{An implementation of sets based on lists.}
\labelfigure{mset1}
\label{page:mset1}
\end{figure}

In this example, the module \hbox{\lstinline/MakeSet/} is a functor
that takes another module \hbox{\lstinline/Equal/} with
signature \hbox{\lstinline/EqualSig/} as an
argument. The \hbox{\lstinline/Equal/} module provides two things---a
type of elements, and a function \hbox{\lstinline/equal/} to compare
two elements. The body of the functor \hbox{\lstinline/MakeSet/} is
much the same as the previous set implementations we have seen, except
now the elements are compared using the
function \hbox{\lstinline/equal x x'/} instead of the builtin-equality
%
\hbox{\lstinline/x = x'/}.
%
The expression \hbox{\lstinline$List.exists f s$} is true iff the
predicate \hbox{\lstinline/f/} is true for some element of the list \hbox{\lstinline/s/}.
The \hbox{\lstinline$List.find f s$} expression returns the first
element of \hbox{\lstinline/s/} for which the predicate \hbox{\lstinline/f/} is true, or
raises \hbox{\lstinline$Not_found$} if there is no such element.

To construct a specific set, we first build a module that implements
the equality function (in this case, the
module \hbox{\lstinline/StringCaseEqual/}), then apply
the \hbox{\lstinline/MakeSet/} functor module to construct the set
module (in this case, the module \hbox{\lstinline/SSet/}).

In many ways, functors are just like functions at the module level,
and they can be used just like functions.  However, there are a few
things to keep in mind.

\begin{enumerate}

\item{}

A functor parameter, like \hbox{\lstinline/(Equal : EqualSig)/} must be a module,
or another functor. It is not legal to pass non-module values (like
strings, lists, or integers).

\item{}

Syntactically, module and functor identifiers must always be
capitalized. Functor parameters, like
\hbox{\lstinline/(Equal : EqualSig)/},
must be enclosed in parentheses, and the signature is required. For
functor applications, like
\hbox{\lstinline/MakeSet (StringCaseEqual)/},
the argument must be enclosed in parenthesis.

\item{}

\index{modules!not first class}
Modules and functors are not first class. That is, they can't be
stored in data structures or passed as arguments like other values,
and module definitions cannot occur in function bodies.

\nocomment{JYH: we discussed this before.

Technically speaking, the primary reason for this restriction is that
type checking would become undecidable. Another reason is that module
constructions and functor applications are normally computed at
compile time, so it would not be legal to have a function compute a
module.}

\end{enumerate}
%
\index{modules!polymorphism}
Another point to keep in mind is that the new set implementation is no
longer polymorphic---it is now defined for a specific type of elements
defined by the \hbox{\lstinline/Equal/} module. This loss of
polymorphism occurs frequently when modules are parameterized, because
the goal of parameterizing is to define different behaviors for
different types of elements. While the loss of polymorphism is
inconvenient, in practice it is rarely an issue because modules can be
constructed for each specific type of parameter by using a functor
application.

\labelsection{sharing-constraints}{Sharing constraints}

In the \hbox{\lstinline/MakeSet/} example of Figure \reffigure{mset1},
we omitted the signature for sets. This leaves the set implementation
visible (for example, the \hbox{\lstinline/SSet.add/} function returns
a string list).  We can define a signature that hides the
implementation, preventing the rest of the program from depending on
these details.  Functor signatures are defined the usual way, by
specifying the signature after a colon, as shown in
Figure \reffigure{mset2}.

\begin{figure}
\begin{center}
\begin{tabular}[t]{l}
Set signature\\
\hline
\begin{ocamllisting}
module type SetSig = sig
   type t
   type elt
   val empty : t
   val mem   : elt -> t -> bool
   val add   : elt -> t -> t
   val find  : elt -> t -> elt
end;;

module MakeSet (Equal : EqualSig)
 : SetSig with type elt = Equal.t =
struct
   type elt = Equal.t
   $\cdots$
end;;
\end{ocamllisting}\\
\\
Building a specific case\\
\hline
\begin{ocamllisting}
module StringCaseEqual = struct $\cdots$ end;;
module SSet = MakeSet (StringCaseEqual);;
\end{ocamllisting}\\
\\
Using the set\\
\hline
\begin{ocaml}
# SSet.empty;;
@
\begin{topoutput}
- : SSet.t = <abstr>
\end{topoutput}
@
# open SSet;;
# let s = add "Paradise Lost" empty;;
@
\begin{topoutput}
val s : SSet.t = <abstr>
\end{topoutput}
@
# mem "paradise lOst" s;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# find "paradise loSt" s;;
@
\begin{topoutput}
- : string = "Paradise Lost"
\end{topoutput}
@
\end{ocaml}
\end{tabular}
\end{center}
\caption{Assigning a signature to the \hbox{\lstinline$MakeSet$} functor.}
\labelfigure{mset2}
\end{figure}

\index{modules!sharing constraints}
The \emph{sharing constraint}
\hbox{\lstinline$SetSig with type elt = Equal.t$}
is an important part of the construction.  In
the \hbox{\lstinline/SetSig/} signature, the type \texttt{elt} is
abstract.  If the \hbox{\lstinline/MakeSet/} functor were to return a
module with the plain signature \hbox{\lstinline/SetSig/}, the
type \hbox{\lstinline/SSet.elt/} would be abstract, and the set would
be useless.  If we repeat the construction without the sharing
constraint, the compiler produces an error message when we try to use
it.

\begin{ocaml}
# module MakeSet (Equal : EqualSig) : SetSig = struct ... end
# module SSet = MakeSet (StringCaseCompare);;
# SSet.add "The Magic Mountain" SSet.empty;;
@
\begin{toperror}
Characters 9-29:
  SSet.add "The Magic Mountain" SSet.empty;;
           ^^^^^^^^^^^^^^^^^^^^
This expression has type string but is here used with type
  SSet.elt = MakeSet(StringCaseEqual).elt
\end{toperror}
@
\end{ocaml}
%
The message indicates that the types \hbox{\lstinline$string$}
and \hbox{\lstinline$SSet.elt$} are not the same---and in fact, the
only property known is that the types \hbox{\lstinline$SSet.elt$}
and \hbox{\lstinline$MakeSet(StringCaseEqual).elt$} are equal.

\labelsection{module-sharing}{Module sharing constraints}

\index{modules!sharing constraints (modules)}
The sharing constraints that we have seen so far apply to types in a
module definition.  It is also possible to specify sharing constraints
on entire modules.  The effect of a module sharing constraint is to
equate two modules, including all the types contained within the
modules.  This can be a tremendous benefit when many types must be
constrained as part of a new module definition.

To see how this works, let's redefine the \hbox{\lstinline$MakeSet$}
functor using a sharing constraint on the \hbox{\lstinline$Equal$}
module.  The first step is to revise the
signature \hbox{\lstinline$SetSig$} to include the module.  In this
new module signature, the type \hbox{\lstinline$elt$} is now defined
as \hbox{\lstinline$Equal.t$}.

\begin{ocaml}
module type SetSig = sig
   module Equal : EqualSig

   type t
   type elt = Equal.t
   val empty : t
   val mem : elt -> t -> bool
   val add : elt -> t -> t
   val find : elt -> t -> elt
end;;
\end{ocaml}
%
The next step is to revise the \hbox{\lstinline$MakeSet$} functor to
include the \hbox{\lstinline$Equal$} module and the corresponding
sharing constraint.

\begin{ocaml}
module MakeSet (EqArg : EqualSig)
 : SetSig with module Equal = EqArg =
struct
   module Equal = EqArg

   type elt = Equal.t
   type t = elt list
   let empty = []
   ...
end;;
\end{ocaml}
%
The effect of the sharing constraint is to specify that the
types \hbox{\lstinline$elt$} and \hbox{\lstinline$Equal.t$} are
equivalent.  In this example, there is only one type, so there isn't
much benefit.  In general, however, the modules being constrained can
include many types, and the module constraint provides both clarity
and a reduction in code size.

\labelsection{module-reuse}{Module re-use using functors}

\index{modules!for re-use}
Now that we have successfully constructed the \hbox{\lstinline/MakeSet/} functor, let's move on to
our old friend, the \emph{map} or \emph{dictionary} data structure.  A map is a table that
associates a value with each element in a set. The data structure provides a
function \hbox{\lstinline/add/} to add an element and its value to the table, as well as a
function \hbox{\lstinline/find/} that retrieves that value associated with an element, or raises the
exception \hbox{\lstinline/Not_found/} if the element is not in the table.

The \emph{map} and \emph{set} data structures are very similar. Since
we have implemented sets already, we will try to re-use the
implementation for maps.  In this case, we will write a functor that
produces a \emph{map} data structure given a comparison function. The
code is shown in Figure~\reffigure{mkset3b}.

\begin{figure}
\begin{center}
\begin{tabular}{l}
Signature definitions\\
\hline
\begin{ocamllisting}
module type ValueSig = sig
   type value
end;;

module type MapSig = sig
   type t
   type key
   type value
   val empty : t
   val add : t -> key -> value -> t
   val find : t -> key -> value
end;;
\end{ocamllisting}
\end{tabular}
\end{center}
\caption{Signatures for the map module.}
\labelfigure{mkset3a}
\end{figure}

\begin{figure}
\begin{center}
\begin{tabular}{l}
\begin{ocamllisting}
module MakeMap (Equal : EqualSig) (Value : ValueSig)
 : MapSig
   with type key = Equal.t
   with type value = Value.value
= struct
   type key = Equal.t
   type value = Value.value
   type item = Key of key | Pair of key * value

   module EqualItem = struct
      type t = item
      let equal (Key key1 | Pair (key1, _)) (Key key2 | Pair (key2, _)) =
         Equal.equal key1 key2
   end;;
   module Set = MakeSet (EqualItem);;
   type t = Set.t

   let empty = Set.empty
   let add map key value =
      Set.add (Pair (key, value)) map
   let find map key =
      match Set.find (Key key) map with
         Pair (_, value) -> value
       | Key _ ->
            raise (Invalid_argument "find")
end;;
\end{ocamllisting}
\end{tabular}
\end{center}
\caption{Constructing a map (a dictionary) from a set.}
\labelfigure{mkset3b}
\end{figure}

The \hbox{\lstinline/MakeMap/} functor takes two parameters,
a \hbox{\lstinline/Equal/} module to compare keys, and
a \hbox{\lstinline/Value/} module that specifies the type of values
stored in the table.  The constructed module has three parts: 1) type
definitions, 2) the construction of a \hbox{\lstinline$Set$} module,
and 3) the implementation of the functions and values for
the \hbox{\lstinline$Map$}.

The \hbox{\lstinline$Set$} contains values of
type \hbox{\lstinline$item$}, which is defined as either
a \hbox{\lstinline$Key$} or a \hbox{\lstinline$Pair$}.  The set itself
always contains key/value pairs \hbox{\lstinline$Pair (key, value)$}.
The \hbox{\lstinline$Key key$} form is defined so that
the \hbox{\lstinline$find$} function can be implemented without
requiring a dummy value.

\labelsection{higher-order-functors}{Higher-order functors}

\index{modules!higher-order functors}
A \emph{higher-order} functor is a functor that takes another functor
as an argument. While higher-order functors are rarely used in
practice, there are times when they can be useful.

For example, in relation to our running example,
the \hbox{\lstinline/MakeMap/} functor is tied to a specific
definition of the \hbox{\lstinline/MakeSet/} functor. If we have
multiple ways to build sets (for example, as lists, trees, or some
other data structure), we may want to be able to use any of these sets
when building a map. The solution is to pass
the \hbox{\lstinline/MakeSet/} functor as a parameter
to \hbox{\lstinline/MakeMap/}.

\label{keyword:functor}
The type of a functor is specified using the \textbf{functor} keyword,
where \ensuremath{{\mathit{signature}}_{2}} is allowed to depend on
the argument \hbox{\lstinline/Arg/}.

\begin{center}
\texttt{functor (\nt{FunctorName} : $\ms{signature}_1$) -> $\ms{signature}_2$}
\end{center}
%
When passing the \hbox{\lstinline/MakeSet/} functor to \hbox{\lstinline/MakeMap/}, we need to
specify the functor type with its sharing constraint. The
\hbox{\lstinline/MakeMap/} definition changes as follows; the structure definition
itself doesn't change.

\begin{ocaml}
module MakeMap (Equal : EqualSig) (Value : ValueSig)
   (MakeSet : functor (Equal : EqualSig) ->
      SetSig with type elt = Equal.t)
 : MapSig
   with type key = Equal.t
   with type value = Value.value
= struct $\cdots$ end
\end{ocaml}
%
These types can get complicated!  Certainly, it can get even more
complicated with the ability to specify a functor argument that itself
takes a functor. However, as we mentioned, higher-order functors are
used fairly infrequently in practice, partly because they can be hard
to understand.  In general, it is wise to avoid gratuitous use of
higher-order functors.

\labelsection{recursive-functors}{Recursive modules and functors}

\index{modules!recursive}
In Section~\reflabelsection{recursive-modules} we saw how modules can
be defined recursively, as long as they are all defined in the same
file.  With functors, the situation becomes much better, because the
modules can now be implemented in separate files as functors (although
the final recursive construction must still be in a single file).

The syntax for recursive functors remains the same as before, using
the syntax \hbox{\lstinline/module rec $\cdots$ and $\cdots$/}, where
some of the definitions are functor applications.

To illustrate, let's build a more general versions of sets, where the
set elements may be integers or---in addition---other sets.  So, for
instance, sets like $\{ 1, 2 \}$, $\{ \{ 1, 2 \} \}$, and $\{ 17, \{
21 \}, \{ -3, \{ 88 \} \} \}$ should all be representable.

The immediate problem is that, if we wish to re-use
the \hbox{\lstinline$MakeSet$} functor we already defined to build the
set, there appears to be no way to define the type of set elements.

\begin{ocamly}
type elt = Int of int | Set of @???@
\end{ocamly}
%
What should be the type of sets to use in this type definition?
Certainly, it should be the type
%
\hbox{\lstinline$MakeSet(SetEqual).t$},
%
but the \hbox{\lstinline$SetEqual$} module must be able to compare sets
before the type is constructed.

To solution is to define the \hbox{\lstinline$SetEqual$} and the corresponding
%
\hbox{\lstinline$Set$} module recursively.
%
For now, let's just use the builtin equality \hbox{\lstinline$=$} to compare
sets.

\begin{ocaml}
type 'set element = Int of int | Set of 'set

module rec SetEqual
 : EqualSig with type t = Set.t element =
struct
    type t = Set.t element
    let equal = (=)
end

and Set : SetSig with type elt = SetEqual.t = MakeSet (SetEqual)
\end{ocaml}
%
The construction is necessarily
recursive---the \hbox{\lstinline$SetEqual$} module refers to
the \hbox{\lstinline$Set$} module and \textit{vice versa}.

Recursive module definitions are often more verbose than non-recursive
definitions because the modules are \emph{required} to have
signatures.  This often means that it is usually necessary to specify
types twice, once in the module body, and again in the signature.  In
this example, the type \hbox{\lstinline$t$} is defined twice as
%
\hbox{\lstinline$type t = Set.t element$}.
%
Another issue is that it isn't possible to define a sharing constraint
of the form
%
\hbox{\lstinline$EqualSig with type t = Int of int | Set of Set.t$}
%
because that would be a type definition, not a type constraint.  The
actual type definition must be given beforehand, and since the type of
sets is not known at that point, a type
variable \hbox{\lstinline$'set$} must be introduced to stand for the
type of sets.

In practice, recursive modules are used much less frequently than
simple non-recursive modules.  They are, however, a powerful tool that
adds significant expressivity to the module system.  Without
recursion, the \hbox{\lstinline$Set$} module could not be constructed
using the \hbox{\lstinline$MakeSet$} functor.  When used judiciously,
recursion is an important part in maintaining modularity in programs.

\labelsection{real-sets}{A complete example}

For simplicity, we have been using a list representation of sets.
However, this implementation is not practical except for very small
sets, because the set operations take time linear in the size of the
set.  Let's explore a more practical implementation based on a tree
representation, where the set operations are logarithmic in the size
of the set.  For this, we turn to the red-black trees discussed in
Section~\reflabelsection{balanced-red-black-trees}.

\index{red-black trees}
Red-black trees (and binary search trees in general) are labeled trees
where the nodes are \emph{in-order}; that is, given a node \hbox{\lstinline/n/}
with label \hbox{\lstinline/l/}, the left children of \hbox{\lstinline/n/} have labels smaller
than \hbox{\lstinline/l/}, and the right children have labels larger than \hbox{\lstinline/l/}.
The module \hbox{\lstinline$Equal$} that we have been using is too
coarse.  We need a more general comparison function, so the first step
is to define a module signature for it.

\begin{ocaml}
type comparison = LT | EQ | GT

module type CompareSig = sig
   type t
   val compare : t -> t -> comparison
end
\end{ocaml}
%
The \hbox{\lstinline$SetSig$} signature is unchanged for the most part, but
we include a \hbox{\lstinline$compare$} function so that it will be easy to
construct sets of sets.

\begin{ocaml}
module type SetSig = sig
   module Compare : CompareSig

   type t
   type elt = Compare.t
   val empty   : t
   val add     : elt -> t -> t
   val mem     : elt -> t -> bool
   val find    : elt -> t -> elt
   val compare : t -> t -> comparison
end
\end{ocaml}
%
The rest of the construction is now to define
the \hbox{\lstinline$MakeSet$} functor in terms of red-black trees.
The module sketch is as follows, where our objective is to fill in the
ellipses $\cdots$ with the actual implementation.

\begin{ocaml}
module MakeSet (Compare : CompareSig)
 : SetSig with module Compare = Compare =
struct
    module Compare = Compare
    type elt = Compare.t
    type color = Red | Black
    type t = Leaf | Node of color * elt * t * t
    let empty = Leaf
    let add x s = $\cdots$
    let mem x s = $\cdots$
    let find x s = $\cdots$
    let compare s1 s2 = $\cdots$
end
\end{ocaml}
%
The definition \hbox{\lstinline$module Compare = Compare$} may seem a
little silly at first, but it defines the placeholder that allows the
sharing constraint to be expressed---namely, that the type of elements
in the set is \hbox{\lstinline$Compare.t$}.

To implement the final four functions, we can use the implementation
of red-black trees, modified to take the comparison into account.
Let's start with the \hbox{\lstinline$find$} function, which traverses
the tree, looking for a matching element.  This is the usual recursive
inorder traversal.

\begin{ocaml}
let rec find x = function
   Leaf -> raise Not_found
 | Node (_, y, left, right) ->
      match Compare.compare x y with
         LT -> find x left
       | GT -> find x right
       | EQ -> y
\end{ocaml}
%
The \hbox{\lstinline$mem$} function is similar.  It is so similar in
fact, that we can simply implement it in terms
of \hbox{\lstinline$find$}, using the exception to determine
membership.  The expression
%
\hbox{\lstinline$ignore (find x s); true$}
%
discards the result of \hbox{\lstinline$find x s$}, returning \hbox{\lstinline$true$}.

\begin{ocaml}
let mem x s =
   try ignore (find x s); true with
      Not_found -> false
\end{ocaml}
%
The function \hbox{\lstinline$add$} is the same as
the function \hbox{\lstinline$insert$} from
page~\pageref{page:red-black-insert}, modified to use the generic
function \hbox{\lstinline$compare$}.  The \hbox{\lstinline$balance$}
function is as before.

\begin{ocaml}
let add x s =
   let rec insert = function
      Leaf -> Node (Red, x, Leaf, Leaf)
    | Node (color, y, a, b) as s ->
         match Compare.compare x y with
            LT -> balance (color, y, insert a, b)
          | GT -> balance (color, y, a, insert b)
          | EQ -> s
   in
      match insert s with  (* guaranteed to be non-empty *)
         Node (_, y, a, b) -> Node (Black, y, a, b)
       | Leaf -> raise (Invalid_argument "insert");;
\end{ocaml}
%
Finally, we must implement a \hbox{\lstinline$compare$} function on
sets.  The builtin equality \hbox{\lstinline$(=)$} is not appropriate.
First, we should be using the supplied
comparison \hbox{\lstinline$Compare$} instead, and second, there may
be many different red-black trees that represent the same set.  The
shape of the tree is determined partly by the order in which elements
are added to the set, while we want true set equality: two sets are
equal \emph{iff} they have the same elements.

There are many ways to define a set equality.  We will implement a
simple one that first converts the sets to lists, then performs a
lexicographic ordering on the lists.  This is not the most efficient
comparison, but it is adequate, taking time $O(\ms{max}(n, m))$ when
comparing two sets of size $n$ and $m$.

\begin{ocaml}
let rec to_list l = function
   Leaf -> l
 | Node (_, x, left, right) ->
      to_list (x :: to_list l right) left

let rec compare_lists l1 l2 =
   match l1, l2 with
      [], [] -> EQ
    | [], _ :: _ -> LT
    | _ :: _, [] -> GT
    | x1 :: t1, x2 :: t2 ->
         match Compare.compare x1 x2 with
            EQ -> compare_lists t1 t2
          | LT | GT as cmp -> cmp

let compare s1 s2 =
   compare_lists (to_list [] s1) (to_list [] s2)
\end{ocaml}
%
The expression \hbox{\lstinline$to_list [] s$} produces a list of
elements of the set in sorted order---this is important, because it
means that two equal sets have the same list representation.  The
function \hbox{\lstinline$compare_lists$} defines the lexicographic
ordering of two lists, and the function
\hbox{\lstinline$compare s1 s2$}
ties it together.

The \hbox{\lstinline$MakeSet$} functor is now finished.  For a final
step, let's repeat the recursive definition of a set of sets, from
Section~\reflabelsection{recursive-functors}.

\begin{ocaml}
type 'set element = Int of int | Set of 'set

module rec Compare
 : CompareSig with type t = Set.t element =
struct
   type t = Set.t element
   let compare x1 x2 =
      match x1, x2 with
         Int i1, Int i2 ->
            if i1 < i2 then LT else if i1 > i2 then GT else EQ
       | Int _, Set _ -> LT
       | Set _, Int _ -> GT
       | Set s1, Set s2 -> Set.compare s1 s2
end

and Set : SetSig with module Compare = Compare = MakeSet (Compare)
\end{ocaml}
%
The function \hbox{\lstinline$Compare.compare$} compares two elements; we
choose to use the usual ordering on integers, the \hbox{\lstinline$Set$}
ordering on sets, and integers are always smaller than sets.  Note
that the module definition is now recursive not only in the types
being defined, but also in the definition of the \hbox{\lstinline$compare$}
function.

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
