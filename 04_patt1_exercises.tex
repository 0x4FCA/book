%
%
%
\exercises

\begin{exercise}{patt1}
Which of the following expressions are legal in OCaml?  For those that are legal, what is the type
of the expression, and what does it evaluate to?

\begin{enumerate}
\item 

\begin{ocamllistinge}
match 1 with
   1 -> 2
 | _ -> 3
\end{ocamllistinge}

\begin{answer}\ifanswers
Legal.  The expression evaluates to \hbox{\lstinline/1 : int/}.
\fi\end{answer}

\item

\begin{ocamllistinge}
match 2 with
   1 + 1 -> 2
 | _ -> 3
\end{ocamllistinge}

\begin{answer}\ifanswers
Not legal.  The expression \hbox{\lstinline/1 + 1/} is not a constant, and it is not a pattern.
\fi\end{answer}

\item \lstinline!let _ as s = "abc" in s ^ "def"!

\begin{answer}\ifanswers
Legal.  This expression is the same as \hbox{\lstinline/let s = "abc" in s ^ "def"/}; the value
is \hbox{\lstinline/"abcdef" : string/}.
\fi\end{answer}

\item \lstinline!(fun (1 | 2) as i -> i + 1) 2!

\begin{answer}\ifanswers
Legal.  The pattern matching \hbox{\lstinline/(1 | 2)/} is legal but not exhaustive.  The value is
\hbox{\lstinline/3 : int/}.
\fi\end{answer}
\end{enumerate}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function matching
%
\begin{exercise}{fun-pattern}
We have seen pattern matching for values of all the basic types with one notable
exception---functions.  For example, the following code is rejected.

\begin{ocaml}
# match (fun i -> i + 1) with
     (fun i -> i + 1) -> true;;
@
\begin{toperror}
      ^^^
Syntax error
\end{toperror}
@
\end{ocaml}
%
Why do you think the OCaml designers left out function matching?

\begin{answer}\ifanswers
To implement pattern matching for any class of values, one must decide how to define equality on the
values being matched.  For simple types like integers, strings, \emph{etc}., equality is
well-defined.  The problem with functions is that function equality is undecidable in general.

As an alternative, it might be possible to compare the program \emph{text} that defines the
functions, rather then the functions themselves.  However, this would mean than variations in the
text, even insignificant ones, would affect the pattern matching.  The result would not be very
useful.
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Random
%
\begin{exercise}{subst-cipher1}
Suppose we have a crypto-system based on the following substitution cipher,
where each plain letter is encrypted according to the following table.

\begin{center}
\begin{tabular}{l|llll}
Plain     & A & B & C & D\\
\hline
Encrypted & C & A & D & B
\end{tabular}
\end{center}
%
For example, the string \hbox{\lstinline/BAD/} would be encrypted as \hbox{\lstinline/ACB/}.

Write a function \hbox{\lstinline/check/} that, given a plaintext string $s_1$ and a ciphertext string
$s_2$, returns \hbox{\lstinline/true/} if, and only if, $s_2$ is the ciphertext for $s_1$.  Your function
should raise an exception if $s_1$ is not a plaintext string.  You may wish to refer to the string
operations on page~\pageref{section:ocaml-doc-expr-string}.  How does your code scale as the alphabet gets
larger?

\begin{answer}\ifanswers
There are two general approaches.  One is to write a function to encrypt a string, then compare
encrypted strings.  The other is to compare the strings character-by-character.
For this solution, we'll write the former.  This solution grows linearly with the size of
the alphabet.

\begin{ocaml}
(* Encrypt a string *)
let encrypt_char = function
   'A' -> 'C'
 | 'B' -> 'A'
 | 'C' -> 'D'
 | 'D' -> 'B'
 | _ -> raise (Invalid_argument "encrypt_char")

(* Encrypt the string in place *)
let encrypt_string s =
   let len = String.length s in
   let rec loop i =
      if i < len then
         let () = s.[i] <- encrypt_char s.[i] in
         loop (i + 1)
   in
   loop 0

(* Compare the strings *)
let check s1 s2 =
   let () = encrypt_string s1 in
   s1 = s2
\end{ocaml}
\fi\end{answer}
\end{exercise}

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
% vim:tw=100:fo=tcq:
