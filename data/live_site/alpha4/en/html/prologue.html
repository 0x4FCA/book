<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Prologue / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha4',
                        page: 'prologue.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html" class="here">Prologue</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="prologue.html#why-ocaml">Why OCaml?</a>
                                            </li>
                                        
                                            <li>
                                                <a href="prologue.html#about-this-book">About this book</a>
                                            </li>
                                        
                                            <li>
                                                <a href="prologue.html#about-the-authors">About the Authors</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Prologue</h1>
                
                

    <section><h1 id="why-ocaml">Why OCaml?</h1><p id="idp4466768">
      The programming languages that you use affect the software you
      create. They influence your software's reliability, security and
      efficiency, and how easy it is to read, refactor, and extend. And
      the languages you know can also deeply affect how you think about
      programming and software design.
    </p><p id="idp5423424">
      But not all ideas about how to design a programming language are
      created equal. Over the last 40 years, a few key language features
      have emerged that together form a kind of sweet-spot in language
      design. These features include:
    </p><ul><li><p id="idp2648304">
<span><em>Garbage collection</em></span> for automatic memory
          management, now a feature of almost every modern high-level
          language.
        </p></li><li><p id="idp2907168">
<span><em>Higher-order functions</em></span> that can be passed
          around as first-class values, as seen in Javascript or Scala.
        </p></li><li><p id="idp3994144">
<span><em>Static type-checking</em></span> to reduce run-time
          errors, such as Java class interfaces or Objective-C methods.
        </p></li><li><p id="idp2154416">
<span><em>Generics</em></span> to enable abstractions to be
          constructed across different datatypes, available in Java and
          .NET.
        </p></li><li><p id="idp3412016">
<span><em>Immutable data structures</em></span> that cannot be
          destructively updated, famously enforced in Haskell but also a
          common feature of many distributed big data frameworks.
        </p></li><li><p id="idp5383296">
<span><em>Algebraic datatypes</em></span> and <span><em>pattern
          matching</em></span> to define and manipulate complex data
          structures, available in Miranda, F# and Standard ML.
        </p></li><li><p id="idp3409968">
<span><em>Automatic type inference</em></span> to avoid having
          to laboriously define the type of every single variable in a
          program, and instead have them inferred based on how a value
          is used. Available in Standard ML, F# and even modern C++11
          via its <code>auto</code> keyword.
        </p></li></ul><p id="idp4578416">
      Some of you will know and love these features, and others will be
      completely new to them. Most of you will have seen
      <span><em>some</em></span> of them in other languages that you've
      used. As we'll demonstrate over the course of this book, it turns
      out that there is something transformative about having them all
      together and able to interact in a single language. Despite their
      importance, these ideas have made only limited inroads into
      mainstream languages. And when they do arrive there, like
      higher-order functions in C# or parametric polymorphism in Java,
      it's typically in a limited and awkward form. The only languages
      that support these ideas well are statically-typed functional
      programming languages like OCaml, F#, Haskell, Scala and Standard
      ML.
    </p><p id="idp1875824">
      Among this worthy set of languages, OCaml stands apart because it
      manages to provide a great deal of power while remaining highly
      pragmatic, highly performant, and comparatively simple to use and
      understand. It is this that makes OCaml a great choice for
      programmers who want to step up to a better programming language,
      and at the same time want to get practical work done.
    </p><section><h1 id="a-brief-history-from-the-1960s">A brief history from the 1960s</h1><p id="idp3332352">
        OCaml was written in 1996 by Xavier Leroy, Jérôme Vouillon,
        Damien Doligez and Didier Rémy at INRIA in France. It was
        inspired by a long line of research into ML starting in the
        1960s, and continues to have deep links to the academic
        community.
      </p><p id="idp4550400">
        ML was originally the <span><em>meta language</em></span> of the
        LCF proof assistant released by Robin Milner in 1972 (at
        Stanford, and later at Cambridge). ML was turned into a compiler
        in order to make it easier to use LCF on different machines, and
        gradually turned into a fully fledged system of its own by the
        1980s.
      </p><p id="idp4629120">
        In 1990, Xavier Leroy and Damien Doligez built a new
        implementation called Caml Light that was based on a bytecode
        interpreter with a fast sequential garbage collector. Over the
        next few years useful libraries appeared, such as Michel Mauny's
        parsing system, and performance further improved with a fast
        native code compiler that made OCaml's performance competitive
        with mainstream languages such as C++. A module system inspired
        by Standard ML also provided powerful facilities for abstraction
        and larger scale programs.
      </p><p id="idp4599568">
        The modern OCaml emerged in 1996, when a powerful and elegant
        object system was implemented by Didier Rémy and Jérôme
        Vouillon. This object system was notable for supporting many
        common OO idioms in a statically type-safe way, whereas the same
        idioms required runtime checks in languages such as C++ or Java.
        In 2000, Jacques Garrique extended OCaml with several new
        features such as polymorphic methods and variants and labelled
        and optional arguments.
      </p><p id="idp3771360">
        The last decade has seen OCaml attract a significant user base,
        and language improvements have been steadily added to support
        the growing codebases that use the language both commercially
        and for academic use. First-class modules, GADTs and dynamic
        linking have improved the flexibility of the language, and there
        is fast native code support for x86_64, ARM, PowerPC and
        Sparc64, making OCaml a good choice for systems where resource
        usage, predictability and performance matters.
      </p></section><section><h1 id="the-core-standard-library">The Core Standard Library</h1><p id="idp245136">
        A language on its own isn't enough. You also need a rich set of
        libraries to base your applications on. A common source of
        frustration for those learning OCaml is that the standard
        library that ships with the OCaml compiler is not ideal. While
        it's well implemented, it is really intended for use within the
        compiler itself, and covers only a small subset of the
        functionality you expect for more general-purpose use.
      </p><p id="idp246016">
        But all is not lost! There is an effective alternative to the
        OCaml standard library called Core. Jane Street, a company that
        has been using OCaml for more than a decade, developed Core for
        its own internal use, but it was designed from the start with an
        eye towards being a general-purpose standard library, and has
        very broad applicability. Core is also engineered with
        correctness, reliability and performance very much in mind.
      </p><p id="idp247408">
        Core is also distributed with syntax extensions which provide
        useful new functionality to OCaml, and there are additional
        libraries such as the Async network communications library that
        extend the reach of Core into building complex distributed
        systems. All of these libraries are distributed under a liberal
        Apache-style license.
      </p><p id="idp248192">
        If you've learnt some OCaml before, this book may surprise you
        with some differences from your past experience. The Core
        standard library redefines most of the standard modules to be
        much more consistent, and so you'll need to adapt older code. We
        believe the Core model is worth learning; it's been successfully
        used on large, million-line codebases, and removes a big barrier
        to more widespread OCaml adoption. There will always exist code
        that uses only the compiler standard library of course, but
        there are other online resources available to learn that. Real
        World OCaml focuses on the techniques the authors have used in
        their personal experience to construct scalable, robust computer
        systems.
      </p></section><section><h1 id="the-ocaml-platform">The OCaml Platform</h1><p id="idp250544">
        Core is comprehensive and effective standard library, but
        there's a lot more out there than Core. A large community of
        programmers have been using OCaml since its first release in
        1996 and have generated a lot of useful libraries and tools. In
        Real World OCaml, we'll introduce some of these libraries for
        you to experiment with realistic examples. The installation and
        management of these third-party libraries is made much easier
        via a package management tool known as OPAM. We'll explain more
        about OPAM as the book unfolds, but it forms the basis of the
        Platform, which is a set of tools and libraries that, along with
        the OCaml compiler, let you build realistic applications quickly
        and effectively.
      </p><p id="idp251760">
        Another big improvement over the standard library is the
        <code>utop</code> interactive top level. This is a modern
        interactive tool that supports command history, macro expansion,
        module completion, and other niceties that make it much more
        pleasant to work with the language. We'll be using
        <code>utop</code> throughout the book instead of the
        normal OCaml toplevel. It can, of course, be installed using
        OPAM, and <a href="installation.html">Appendix A, <i>Installation</i></a> guides you
        through that process.
      </p></section></section><section><h1 id="about-this-book">About this book</h1><p id="idp5266112">
      Real World OCaml is aimed at programmers who have some experience
      with conventional programming languages, but not specifically with
      <span><em>statically-typed functional programming</em></span>. The
      world of dynamic scripting languages such as Javascript, Ruby and
      Python have all adopted healthy elements of functional
      programming, but not all of it. Real World OCaml takes you through
      the full lifecycle of how to construct software with static
      typing, including the powerful module system that makes code
      re-use so much more robust.
    </p><p id="idp5267504">
      At the same time, OCaml is not Haskell. It takes a much more
      pragmatic approach by being strictly evaluated by default and
      permitting arbitrary side-effects. In fact, you can write OCaml
      code that looks very similar to imperative C but remains
      completely type-safe. One of the major strengths of OCaml for
      systems programming is that, with some experience, you can predict
      the runtime behaviour of a block of code very easily, with very
      little compiler magic involved. We'll explain some of these tricks
      to you as we go through the book and gradually introduce more
      complex concepts.
    </p><section><h1 id="what-to-expect">What to expect</h1><p id="idp269952">
        Real World OCaml is split into three parts and appendices:
      </p><ul><li><p id="idp270848">
            Part I covers the basic concepts you'll need to know when
            building OCaml programs. You won't need to memorise all of
            this (objects, for example, are used rarely in practice),
            but understanding the concepts and examples is important.
            This part opens up with a guided tour to give you a quick
            overview of the language. It then moves onto modules,
            functors and objects, which may take some time to digest.
            Persevere though; even though these concepts may be
            difficult at first, they will put you in good stead even
            when switching to other languages, many of which have drawn
            inspiration from ML.
          </p></li><li><p id="idp272368">
            Part II builds on the basics by working through complete
            examples. Here you'll pick up useful techniques for building
            networked systems, as well as functional design patterns
            that help combine different features of the language to good
            effect. The focus throughout this section is on networked
            systems, and among other examples we'll build a running
            example that will perform Internet queries using the
            DuckDuckGo search engine.
          </p></li><li><p id="idp273696">
            Part III is all about understanding the runtime system in
            OCaml. It's a remarkably simple system in comparison to
            other language runtimes (such as Java or the .NET CLR), and
            you'll need to read this to build very high performance
            systems that have to minimise resource usage or interface to
            C libraries. This is also where we talk about profiling and
            debugging techniques using tools such as GNU
            <code>gdb</code> and <code>gprof</code>.
            Contributing your code back to the community is also
            important (if only to get bug fixes from other people!), and
            this part also explains how to do this via OPAM and Github.
          </p></li></ul><aside class="note"><h1>
      Note to reviewers
      </h1><p id="idp277088">
        Real World OCaml uses some tools that we've developed while
        writing this book. Some of these resulted in improvements to the
        OCaml compiler, which means that you will need to ensure that
        you have an up-to-date development environment (using the 4.01.0
        compiler). We've automated everything you need via the OPAM
        package manager, so please do follow the installation
        instructions in <a href="installation.html">Appendix A, <i>Installation</i></a>
        carefully.
      </p><p id="idp278640">
        At this stage, the Windows operating system is also unsupported,
        and only Mac OS X, Linux, FreeBSD and OpenBSD can be expected to
        work reliably. We realize this is a concern; there are no
        fundamental barriers to Windows support, but we're focussed on
        getting the main content finished before getting stuck into the
        porting effort.
      </p></aside></section></section><section><h1 id="about-the-authors">About the Authors</h1><section><h1 id="jason-hickey">Jason Hickey</h1><p id="idp281776">
        Jason Hickey is a Software Engineer at Google Inc. in Mountain
        View, California. He is part of the team that designs and
        develops the global computing infrastructure used to support
        Google services, including the software systems for managing and
        scheduling massively distributed computing resources.
      </p><p id="idp282528">
        Prior to joining Google, Jason was an Assistant Professor of
        Computer Science at Caltech, where his research was in reliable
        and fault-tolerant computing systems, including programming
        language design, formal methods, compilers, and new models of
        distributed computation. He obtained his PhD in Computer Science
        from Cornell University, where he studied programming languages.
        He is the author of the MetaPRL system, a logical framework for
        design and analysis of large software systems; and OMake, an
        advanced build system for large software projects. He is the
        author of the textbook, <span><em>An Introduction to Objective
        Caml</em></span> (unpublished).
      </p></section><section><h1 id="anil-madhavapeddy">Anil Madhavapeddy</h1><p id="idp285168">
        Anil Madhavapeddy is a Senior Research Fellow at the University
        of Cambridge, based in the Systems Research Group. He was on the
        original team that developed the Xen hypervisor, and helped
        develop an industry-leading cloud management toolstack written
        entirely in OCaml. This XenServer product has been deployed on
        millions of physical hosts, and drives critical infrastructure
        for many Fortune 500 companies.
      </p><p id="idp286048">
        Prior to obtaining his PhD in 2006 from the University of
        Cambridge, Anil had a diverse background in industry at NetApp,
        NASA and Internet Vision. He is an active member of the
        open-source development community with the OpenBSD operating
        system, is on the steering committee of the Commercial Uses of
        Functional Programming ACM workshop, and serves on the boards of
        startup companies where OCaml is extensively used. He has also
        developed the Mirage unikernel system that is written entirely
        in OCaml from the device drivers up.
      </p></section><section><h1 id="yaron-minsky">Yaron Minsky</h1><p id="idp288160">
        Yaron Minsky heads the Technology group at Jane Street, a
        proprietary trading firm that is the largest industrial user of
        OCaml. He was responsible for introducing OCaml to the company
        and for managing the company's transition to using OCaml for all
        of its core infrastructure. Today, billions of dollars worth of
        securities transactions flow each day through those systems.
      </p><p id="idp288992">
        Yaron obtained his PhD in Computer Science from Cornell
        University, where he studied distributed systems. Yaron has
        lectured, blogged and written about OCaml for years, with
        articles published in Communications of the ACM and the Journal
        of Functional Programming. He chairs the steering committee of
        the Commercial Users of Functional Programming, and is a member
        of the steering committee for the International Conference on
        Functional Programming.
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="index.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="pt01.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>