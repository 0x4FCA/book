<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 19. Foreign Function Interface / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha4',
                        page: 'foreign\u002Dfunction\u002Dinterface.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html" class="here">19. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="managing-external-memory-with-bigarrays.html">20. Managing External Memory with Bigarray</a>
                                            </li>
                                        
                                            <li>
                                                <a href="inside-the-runtime.html">21. Inside the Runtime</a>
                                            </li>
                                        
                                            <li>
                                                <a href="performance-tuning-and-profiling.html">22. Performance Tuning and Profiling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-ocamlyacc.html">23. Parsing with ocamllex and ocamlyacc</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-subtyping-and-inheritance.html">24. Object Subtyping and Inheritance</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 19. Foreign Function Interface</h1>
                
                

    <p id="idp9900864">
    Much of the static type information contained within an OCaml
    program is checked and discarded at compilation time, leaving a much
    simpler <span><em>runtime</em></span> representation for values.
    Understanding this difference is important for writing efficient
    programs, and also for interfacing with C libraries that work
    directly with the runtime system.
  </p><aside class="note"><h1>
  Why do OCaml types disappear at runtime?
  </h1><p id="idp9902768">
    The OCaml compiler runs through several phases of during the
    compilation process. After syntax checking, the next stage is
    <span><em>type checking</em></span>. In a validly typed program, a
    function cannot be applied with an unexpected type. For example, the
    <code>print_endline</code> function must receive a single
    <code>string</code> argument, and an <code>int</code>
    will result in a type error.
  </p><p id="idp9906016">
    Since OCaml verifies these properties at compile time, it doesn't
    need to keep track of as much information at runtime. Thus, later
    stages of the compiler can discard and simplify the type
    declarations to a much more minimal subset that's actually required
    to distinguish polymorphic values at runtime. This is a major
    performance win versus something like a Java or .NET method call,
    where the runtime must look up the concrete instance of the object
    and dispatch the method call. Those languages amortize some of the
    cost via &quot;Just-in-Time&quot; dynamic patching, but OCaml
    prefers runtime simplicity instead.
  </p></aside><p id="idp9907680">
    Let's start by explaining the memory layout, and then move onto the
    details of how C bindings work.
  </p><section><h1 id="the-garbage-collector">The garbage collector</h1><p id="idp9909344">
      A running OCaml program uses blocks of memory (i.e. contiguous
      sequences of words in RAM) to represent many of the values that it
      deals with such as tuples, records, closures or arrays. An OCaml
      program implicitly allocates a block of memory when such a value
      is created.
    </p><pre id="idp9910048">
# let x = { foo = 13; bar = 14 } ;;
</pre><p id="idp9910752">
      An expression such as the record above requires a new block of
      memory with two words of available space. One word holds the
      <code>foo</code> field and the second word holds the
      <code>bar</code> field. The OCaml compiler translates such
      an expression into an explicit allocation for the block from
      OCaml's runtime system: a C library that provides a collection of
      routines that can be called by running OCaml programs. The runtime
      system manages a <span><em>heap</em></span>, which a collection of
      memory regions it obtains from the operating system using
      <span><em>malloc(3)</em></span>. The OCaml runtime uses these
      memory regions to hold <span><em>heap blocks</em></span>, which it
      then fills up in response to allocation requests by the OCaml
      program.
    </p><p id="idp9914512">
      When there is'nt enough memory available to satisfy an allocation
      request from the allocated heap blocks, the runtime system invokes
      the <span><em>garbage collector</em></span> (or GC). An OCaml
      program does not explicitly free a heap block when it is done with
      it, and the GC must determine which heap blocks are
      &quot;alive&quot; and which heap blocks are
      <span><em>dead</em></span>, i.e. no longer in use. Dead blocks are
      collected and their memory made available for re-use by the
      application.
    </p><p id="idp9916384">
      The garbage collector does not keep constant track of blocks as
      they are allocated and used. Instead, it regularly scans blocks by
      starting from a set of <span><em>roots</em></span>, which are
      values that the application always has access to (such as the
      stack). The GC maintains a directed graph in which heap blocks are
      nodes, and there is an edge from heap block <code>b1</code>
      to heap block <code>b2</code> if some field of
      <code>b1</code> points to <code>b2</code>. All blocks
      reachable from the roots by following edges in the graph must be
      retained, and unreachable blocks can be reused.
    </p><p id="idp9920592">
      With the typical OCaml programming style, many small blocks are
      frequently allocated, used for a short period of time, and then
      never used again. OCaml takes advantage of this fact to improve
      the performance of allocation and collection by using a
      <span><em>generational</em></span> garbage collector. This means
      that it has different memory regions to hold blocks based on how
      long the blocks have been alive. OCaml's heap is split in two;
      there is a small, fixed-size <span><em>minor heap</em></span> used
      for initially allocating most blocks, and a large, variable-sized
      <span><em>major heap</em></span> for holding blocks that have been
      alive longer or are larger than 4KB. A typical functional
      programming style means that young blocks tend to die young, and
      old blocks tend to stay around for longer than young ones (this is
      referred to as the <span><em>generational hypothesis</em></span>).
      To reflect this, OCaml uses different memory layouts and garbage
      collection algorithms for the major and minor heaps.
    </p><section><h1 id="the-fast-minor-heap">The fast minor heap</h1><p id="idp9924736">
        The minor heap is one contiguous chunk of memory containing a
        sequence of heap blocks that have been allocated. If there is
        space, allocating a new block is a fast constant-time operation
        in which the pointer to the end of the heap is incremented by
        the desired size. To garbage collect the minor heap, OCaml uses
        <span><em>copying collection</em></span> to copy all live blocks
        in the minor heap to the major heap. This only takes work
        proportional to the number of live blocks in the minor heap,
        which is typically small according to the generational
        hypothesis.
      </p><p id="idp9926192">
        One complexity of generational collection is that in order to
        know which blocks in the minor heap are live, the collector must
        know which minor-heap blocks are directly pointed to by
        major-heap blocks. To do this, OCaml maintains a set of such
        inter-generational pointers, and, through cooperation with the
        compiler, uses a write barrier to update this set whenever a
        major-heap block is modified to point at a minor-heap block.
      </p></section><section><h1 id="the-long-lived-major-heap">The long-lived major heap</h1><p id="idp9928304">
        The major heap consists of a number of chunks of memory, each
        containing live blocks interspersed with regions of free memory.
        The runtime system maintains a free list data structure that
        indexes all the free memory, and this list is used to satisfy
        allocation requests. OCaml uses mark and sweep garbage
        collection for the major heap. The <span><em>mark</em></span>
        phase to traverses the block graph and marks all live blocks by
        setting a bit in the color tag of the block header.
        (<span><em>avsm</em></span>: we only explain the color tag in the
        next section, so rephrase or xref).
      </p><p id="idp9930192">
        The <span><em>sweep</em></span> phase sequentially scans all heap
        memory and identifies dead blocks that weren't marked earlier.
        The <span><em>compact</em></span> phase relocates live blocks to
        eliminate the gaps of free memory between them and ensure memory
        does not fragment.
      </p><p id="idp9931728">
        A garbage collection must <span><em>stop the world</em></span>
        (that is, halt the application) in order to ensure that blocks
        can be safely moved. The mark and sweep phases run incrementally
        over slices of memory, and are broken up into a number of steps
        that are interspersed with the running OCaml program. Only a
        compaction touches all the memory in one go, and is a relatively
        rare operation.
      </p><p id="idp9932976">
        The <code>Gc</code> module lets you control all these
        parameters from your application, and we will discuss garbage
        collection tuning in (<span><em>avsm</em></span>: crossref).
      </p></section></section><section><h1 id="the-representation-of-values">The representation of values</h1><p id="idp9936032">
      Every OCaml <span><em>value</em></span> is a single word that is
      either an integer or a pointer. If the lowest bit of the word is
      non-zero, the value is an unboxed integer. Several OCaml types map
      onto this integer representation, including
      <code>bool</code>, <code>int</code>, the empty list,
      <code>unit</code>, and variants without constructors.
      Integers are the only unboxed runtime values in OCaml, and are the
      cheapest values to allocate.
    </p><p id="idp9939344">
      If the lowest bit of the <code>value</code> is zero, then
      the value is a pointer. A pointer value is stored unmodified,
      since pointers are guaranteed to be word-aligned and the bottom
      bits are always zero. If the pointer is inside an area managed by
      the OCaml runtime, it is assumed to point to an OCaml
      <span><em>block</em></span>. If it points outside the OCaml runtime
      area, it is is treated as an opaque C pointer to some other system
      resource.
    </p><section><h1 id="blocks-and-values">Blocks and values</h1><p id="idp9942704">
        An OCaml <span><em>block</em></span> is the basic unit of
        allocation on the heap. A block consists of a one-word header
        (either 32- or 64-bits) followed by variable-length data, which
        is either opaque bytes or <span><em>fields</em></span>. The
        collector never inspects opaque bytes, but fields are valid
        OCaml values. The runtime always inspects fields, and follows
        them as part of the garbage collection process described
        earlier. Every block header has a multipurpose tag byte that
        defines whether to interprete the subsequent data as opaque or
        OCaml fields.
      </p><p id="idp9944560">
        (<span><em>avsm</em></span>: pointers to blocks actually point
        4/8 bytes into it, for some efficiency reason that I cannot
        recall right now).
      </p><pre id="idp9945552">
+------------------------+-------+----------+----------+----------+----
| size of block in words |  col  | tag byte | value[0] | value[1] | ...
+------------------------+-------+----------+----------+----------+----
 &lt;-either 22 or 54 bits-&gt; &lt;2 bit&gt; &lt;--8 bit--&gt;
</pre><p id="idp9946656">
        The size field records the length of the block in memory words.
        Note that it is limited to 22-bits on 32-bit platforms, which is
        the reason why OCaml strings are limited to 16MB on that
        architecture. If you need bigger strings, either switch to a
        64-bit host, or use the <code>Bigarray</code> module
        (<span><em>avsm</em></span>: xref). The 2-bit color field is used
        by the garbage collector to keep track of its status, and is not
        exposed directly to OCaml programs.
      </p><table><thead><tr><th>
                Tag Color
              </th><th>
                Block Status
              </th></tr></thead><tbody><tr><td>
                blue
              </td><td>
                on the free list and not currently in use
              </td></tr><tr><td>
                white
              </td><td>
                not reached yet, but possibly reachable
              </td></tr><tr><td>
                gray
              </td><td>
                reachable, but its fields have not been scanned
              </td></tr><tr><td>
                black
              </td><td>
                reachable, and its fields have been scanned
              </td></tr></tbody></table><p id="idp9957968">
        A block's tag byte is multi-purpose, and indicates whether the
        data array represents opaque bytes or fields. If a block's tag
        is greater than or equal to <code>No_scan_tag</code>
        (251), then the block's data are all opaque bytes, and are not
        scanned by the collector. The most common such block is the
        <code>string</code> type, which we describe more below.
      </p><p id="idp9960144">
        (<span><em>avsm</em></span>: too much info here) If the header is
        zero, then the object has been forwarded as part of minor
        collection, and the first field points to the new location.
        Also, if the block is on the
        <code>oldify_todo_list</code>, part of the minor gc, then
        the second field points to the next entry on the
        oldify_todo_list.
      </p><p id="idp9962032">
        The exact representation of values inside a block depends on
        their OCaml type. They are summarised in the table below, and
        then we'll examine some of them in greater detail.
      </p><table><thead><tr><th>
                OCaml Value
              </th><th>
                Representation
              </th></tr></thead><tbody><tr><td>
                any <code>int</code> or <code>char</code>
</td><td>
                directly as a value, shifted left by 1 bit, with the
                least significant bit set to 1
              </td></tr><tr><td>
<code>unit</code>, <code>[]</code>,
                <code>false</code>
</td><td>
                as OCaml <code>int</code> 0.
              </td></tr><tr><td>
<code>true</code>
</td><td>
                as OCaml <code>int</code> 1.
              </td></tr><tr><td>
<code>Foo | Bar</code>
</td><td>
                as ascending OCaml <code>int</code>s, starting
                from 0.
              </td></tr><tr><td>
<code>Foo | Bar of int</code>
</td><td>
                variants with parameters are boxed, while entries with
                no parameters are unboxed (see below).
              </td></tr><tr><td>
                polymorphic variants
              </td><td>
                variable space usage depending on the number of
                parameters (see below).
              </td></tr><tr><td>
                floating point number
              </td><td>
                as a block with a single field containing the
                double-precision float.
              </td></tr><tr><td>
                string
              </td><td>
                word-aligned byte arrays that are also directly
                compatible with C strings.
              </td></tr><tr><td>
<code>[1; 2; 3]</code>
</td><td>
                as <code>1::2::3::[]</code> where
                <code>[]</code> is an int, and
                <code>h::t</code> a block with tag 0 and two
                parameters.
              </td></tr><tr><td>
                tuples, records and arrays
              </td><td>
                an array of values. Arrays can be variable size, but
                structs and tuples are fixed size.
              </td></tr><tr><td>
                records or arrays, all float
              </td><td>
                special tag for unboxed arrays of floats. Doesn't apply
                to tuples.
              </td></tr></tbody></table></section><section><h1 id="integers-characters-and-other-basic-types">Integers, characters and other basic types</h1><p id="idp9992736">
        Many basic types are stored directly as unboxed values at
        runtime. The native <code>int</code> type is the most
        obvious, although it drops a single bit of precision due to the
        tag bit described earlier. Other atomic types such as the
        <code>unit</code> and empty list <code>[]</code>
        value are stored as constant integers. Boolean values have a
        value of <code>0</code> and <code>1</code> for
        <code>true</code> and <code>false</code>
        respectively.
      </p><aside class="note"><h1>
      Why are OCaml integers missing a bit?
      </h1><p id="idp9999104">
        Since the lowest bit of an OCaml value is reserved, native OCaml
        integers have a maximum allowable length of 31- or 63-bits,
        depending on the host architecture. The rationale for reserving
        the lowest bit is for efficiency. Pointers always point to
        word-aligned addresses, and so their lower bits are normally
        zero. By setting the lower bit to a non-zero value for integers,
        the garbage collector can simply iterate over every header tag
        to distinguish integers from pointers. This reduces the garbage
        collection overhead on the overall program.
      </p></aside><p id="idp10000256">
        (<span><em>avsm</em></span>: explain that integer manipulation is
        almost as fast due to isa quirks)
      </p></section><section><h1 id="tuples-records-and-arrays">Tuples, records and arrays</h1><pre id="idp10002448">
+---------+----------+----------- - - - - 
| header  | value[0] | value[1] | ....
+---------+----------+----------+- - - - -
</pre><p id="idp10003248">
        Tuples, records and arrays are all represented identically at
        runtime, with a block with tag <code>0</code>. Tuples and
        records have constant sizes determined at compile-time, whereas
        arrays can be of variable length. While arrays are restricted to
        containing a single type of element in the OCaml type system,
        this is not required by the memory representation.
      </p><p id="idp10004720">
        You can check the difference between a block and a direct
        integer yourself using the <code>Obj</code> module, which
        exposes the internal representation of values to OCaml code.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">is_block</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">is_block</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="mi">1</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp10007072">
        The <code>Obj.repr</code> function retrieves the runtime
        representation of any OCaml value.
        <code>Obj.is_block</code> checks the bottom bit to
        determine if the value is a block header or an unboxed integer.
      </p></section><section><h1 id="floating-point-numbers-and-arrays">Floating point numbers and arrays</h1><p id="idp10010368">
        Floating point numbers in OCaml are always stored as full
        double-precision values. Individual floating point values are
        stored as a block with a single field that contains the number.
        This block has the <code>Double_tag</code> set which
        signals to the collector that the floating point value is not to
        be scanned.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">tag</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="o">=</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">double_tag</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">253</span>
<span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">double_tag</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">253</span>
</pre></div><p id="idp10012864">
        Since each floating-point value is boxed in a separate memory
        block, it can be inefficient to handle large arrays of floats in
        comparison to unboxed integers. OCaml therefore special-cases
        records or arrays that contain <span><em>only</em></span>
<code>float</code> types. These are stored in a block that
        contains the floats packed directly in the data section, with
        the <code>Double_array_tag</code> set to signal to the
        collector that the contents are not OCaml values.
      </p><pre id="idp10015552">
+---------+----------+----------- - - - - 
| header  | float[0] | float[1] | ....
+---------+----------+----------+- - - - -
</pre><p id="idp10016352">
        You can test this for yourself using the
        <code>Obj.tag</code> function to check that the allocated
        block has the expected runtime tag, and
        <code>Obj.double_field</code> to retrieve a float from
        within the block.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">open</span> <span class="nc">Obj</span> <span class="o">;;</span>
<span class="o">#</span> <span class="n">tag</span> <span class="o">(</span><span class="n">repr</span> <span class="o">[|</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">;</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">;</span> <span class="mi">3</span><span class="o">.</span><span class="mi">0</span> <span class="o">|])</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">254</span>
<span class="o">#</span> <span class="n">tag</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span> 
<span class="o">#</span> <span class="n">double_field</span> <span class="o">(</span><span class="n">repr</span> <span class="o">[|</span> <span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">.</span><span class="mi">3</span> <span class="o">|]</span> <span class="o">)</span> <span class="mi">1</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span>
<span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">double_field</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="mi">1</span><span class="o">.</span><span class="mi">234</span><span class="o">)</span> <span class="mi">0</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">234</span>
</pre></div><p id="idp10019568">
        Notice that float tuples are <span><em>not</em></span> optimized
        in the same way as float records or arrays, and so they have the
        usual tuple tag value of <code>0</code>. Only records and
        arrays can have the array optimization, and only if every single
        field is a float.
      </p></section><section><h1 id="variants-and-lists">Variants and lists</h1><p id="idp10022592">
        Basic variant types with no extra parameters for any of their
        branches are simply stored as an OCaml integer, starting with
        <code>0</code> for the first option and in ascending
        order.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">open</span> <span class="nc">Obj</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Apple</span> <span class="o">|</span> <span class="nc">Orange</span> <span class="o">|</span> <span class="nc">Pear</span> <span class="o">;;</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Apple</span> <span class="o">|</span> <span class="nc">Orange</span> <span class="o">|</span> <span class="nc">Pear</span>
<span class="o">#</span> <span class="o">((</span><span class="n">magic</span> <span class="o">(</span><span class="n">repr</span> <span class="nc">Apple</span><span class="o">))</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="o">((</span><span class="n">magic</span> <span class="o">(</span><span class="n">repr</span> <span class="nc">Pear</span><span class="o">))</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">is_block</span> <span class="o">(</span><span class="n">repr</span> <span class="nc">Apple</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp10025040">
<code>Obj.magic</code> unsafely forces a type cast between
        any two OCaml types; in this example the <code>int</code>
        type hint retrieves the runtime integer value. The
        <code>Obj.is_block</code> confirms that the value isn't a
        more complex block, but just an OCaml <code>int</code>.
      </p><p id="idp10028416">
        Variants that have parameters arguments are a little more
        complex. They are stored as blocks, with the value
        <span><em>tags</em></span> ascending from 0 (counting from
        leftmost variants with parameters). The parameters are stored as
        words in the block.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Apple</span> <span class="o">|</span> <span class="nc">Orange</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Pear</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Kiwi</span> <span class="o">;;</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Apple</span> <span class="o">|</span> <span class="nc">Orange</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Pear</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Kiwi</span>
<span class="o">#</span> <span class="n">is_block</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Orange</span> <span class="mi">1234</span><span class="o">))</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">tag</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Orange</span> <span class="mi">1234</span><span class="o">))</span> <span class="o">;;</span> 
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="n">tag</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Pear</span> <span class="s2">&quot;xyz&quot;</span><span class="o">))</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="o">(</span><span class="n">magic</span> <span class="o">(</span><span class="n">field</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Orange</span> <span class="mi">1234</span><span class="o">))</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="o">(</span><span class="n">magic</span> <span class="o">(</span><span class="n">field</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Pear</span> <span class="s2">&quot;xyz&quot;</span><span class="o">))</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="kt">string</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;xyz&quot;</span>
</pre></div><p id="idp10030928">
        In the above example, the <code>Apple</code> and
        <code>Kiwi</code> values are still stored as normal OCaml
        integers with values <code>0</code> and
        <code>1</code> respectively. The <code>Orange</code>
        and <code>Pear</code> values both have parameters, and are
        stored as blocks whose tags ascend from <code>0</code>
        (and so <code>Pear</code> has a tag of
        <code>1</code>, as the use of <code>Obj.tag</code>
        verifies). Finally, the parameters are fields which contain
        OCaml values within the block, and <code>Obj.field</code>
        can be used to retrieve them.
      </p><p id="idp10039392">
        Lists are stored with a representation that is exactly the same
        as if the list was written as a variant type with
        <code>Head</code> and <code>Cons</code>. The empty
        list <code>[]</code> is an integer <code>0</code>,
        and subsequent blocks have tag <code>0</code> and two
        parameters: a block with the current value, and a pointer to the
        rest of the list.
      </p><aside class="warning"><h1>
Obj module considered harmful
      </h1><p id="idp10044928">
        The <code>Obj</code> module is an undocumented module that
        exposes the internals of the OCaml compiler and runtime. It is
        very useful for examining and understanding how your code will
        behave at runtime, but should <span><em>never</em></span> be used
        for production code unless you understand the implications. The
        module bypasses the OCaml type system, making memory corruption
        and segmentation faults possible.
      </p><p id="idp10046880">
        Some theorem provers such as Coq do output code which uses
        <code>Obj</code> internally, but the external module
        signatures never expose it. Unless you too have a machine proof
        of correctness to accompany your use of <code>Obj</code>,
        stay away from it except for debugging!
      </p></aside><p id="idp10049056">
        Due to this encoding, there is a limit around 240 variants with
        parameters that applies to each type definition, but the only
        limit on the number of variants without parameters is the size
        of the native integer (either 31- or 63-bits). This limit arises
        because of the size of the tag byte, and that some of the high
        numbered tags are reserved.
      </p></section><section><h1 id="polymorphic-variants-1">Polymorphic variants</h1><p id="idp10051136">
        Polymorphic variants are more flexible than normal variants when
        writing code, but can be less efficient at runtime. This is
        because there isn't as much static compile-time information
        available to optimise their memory layout. This isn't always the
        case, however. A polymorphic variant without any parameters is
        stored as an unboxed integer and so only takes up one word of
        memory. Unlike normal variants, the integer value is determined
        by apply a hash function to the <span><em>name</em></span> of the
        variant. The hash function isn't exposed directly by the
        compiler, but the <code>type_conv</code> library from Core
        provides an alternative implementation.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;type_conv&quot;</span> <span class="o">;;</span>
<span class="o">#</span> <span class="nn">Pa_type_conv</span><span class="p">.</span><span class="n">hash_variant</span> <span class="s2">&quot;Foo&quot;</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3505894</span>
<span class="o">#</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">magic</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="o">`</span><span class="nc">Foo</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3505894</span>
</pre></div><p id="idp10054736">
        The hash function is designed to give the same results on 32-bit
        and 64-bit architectures, so the memory representation is stable
        across different CPUs and host types.
      </p><p id="idp10055328">
        Polymorphic variants use more memory space when parameters are
        included in the datatype constructors. Normal variants use the
        tag byte to encode the variant value, but this byte is
        insufficient to encode the hashed value for polymoprhic
        variants. Therefore, they must allocate a new block (with tag
        <code>0</code>) and store the value in there instead. This
        means that polymorphic variants with constructors use one word
        of memory more than normal variant constructors.
      </p><p id="idp10056928">
        Another inefficiency is when a polymorphic variant constructor
        has more than one parameter. Normal variants hold parameters as
        a single flat block with multiple fields for each entry, but
        polymorphic variants must adopt a more flexible uniform memory
        representation since they may be re-used in a different context.
        They allocate a tuple block for the parameters that is pointed
        to from the argument field of the variant. Thus, there are three
        additional words for such variants, along with an extra memory
        indirection due to the tuple.
      </p></section><section><h1 id="string-values">String values</h1><p id="idp10059776">
        Strings are standard OCaml blocks with the header size defining
        the size of the string in machine words. The
        <code>String_tag</code> (252) is higher than the
        <code>No_scan_tag</code>, indicating that the contents of
        the block are opaque to the collector. The block contents are
        the contents of the string, with padding bytes to align the
        block on a word boundary.
      </p><div class="highlight"><pre><span class="o">+---------------+----------------+--------+-----------+</span>
<span class="o">|</span> <span class="n">header</span>        <span class="o">|</span> <span class="sc">'a'</span> <span class="sc">'b'</span> <span class="sc">'c'</span> <span class="sc">'d'</span> <span class="sc">'e'</span> <span class="sc">'f'</span> <span class="o">|</span> <span class="k">'</span><span class="err">\</span><span class="nc">O'</span> <span class="k">'</span><span class="err">\</span><span class="mi">1</span><span class="k">'</span> <span class="o">|</span>
<span class="o">+---------------+----------------+--------+-----------+</span>
                <span class="nc">L</span> <span class="n">data</span>                    <span class="nc">L</span> <span class="n">padding</span>
</pre></div><p id="idp10063120">
        On a 32-bit machine, the padding is calculated based on the
        modulo of the string length and word size to ensure the result
        is word-aligned. A 64-bit machine extends the potential padding
        up to 7 bytes instead of 3.
      </p><table><thead><tr><th>
                String length mod 4
              </th><th>
                Padding
              </th></tr></thead><tbody><tr><td>
                0
              </td><td>
<code>00 00 00 03</code>
</td></tr><tr><td>
                1
              </td><td>
<code>00 00 02</code>
</td></tr><tr><td>
                2
              </td><td>
<code>00 01</code>
</td></tr><tr><td>
                3
              </td><td>
<code>00</code>
</td></tr></tbody></table><p id="idp10075392">
        This string representation is a clever way to ensure that the
        string contents are always zero-terminated by the padding word,
        and still compute its length efficiently without scanning the
        whole string. The following formula is used:
      </p><pre id="idp10076064">
number_of_words_in_block * sizeof(word) - last_byte_of_block - 1
</pre><p id="idp10076800">
        The guaranteed NULL-termination comes in handy when passing a
        string to C, but is not relied upon to compute the length from
        OCaml code. Thus, OCaml strings can contain null bytes at any
        point within the string, but care should be taken that any C
        library functions can also cope with this.
      </p></section><section><h1 id="custom-heap-blocks">Custom heap blocks</h1><p id="idp10078752">
        OCaml supports <span><em>custom</em></span> heap blocks via a
        <code>Custom_tag</code> that let the runtime perform
        user-defined operations over OCaml values. A custom block lives
        in the OCaml heap like an ordinary block and can be of whatever
        size the user desires. The <code>Custom_tag</code> (255)
        is higher than <code>No_scan_tag</code> and so cannot
        contain any OCaml values.
      </p><p id="idp10082048">
        The first word of the data within the custom block is a C
        pointer to a <code>struct</code> of custom operations. The
        custom block cannot have pointers to OCaml blocks and is opaque
        to the garbage collector.
      </p><pre id="idp10083392">
struct custom_operations {
  char *identifier;
  void (*finalize)(value v);
  int (*compare)(value v1, value v2);
  intnat (*hash)(value v);
  void (*serialize)(value v,
                    /*out*/ uintnat * wsize_32 /*size in bytes*/,
                    /*out*/ uintnat * wsize_64 /*size in bytes*/);
  uintnat (*deserialize)(void * dst);
  int (*compare_ext)(value v1, value v2);
};
</pre><p id="idp10084448">
        The custom operations specify how the runtime should perform
        polymorphic comparison, hashing and binary marshalling. They
        also optionally contain a finalizer, which the runtime will call
        just before the block is garbage collected. This finalizer has
        nothing to do with ordinary OCaml finalizers, as created by
        <code>Gc.finalise</code>. (<span><em>avsm</em></span>: xref
        to GC module explanation)
      </p><p id="idp10086416">
        When a custom block is allocated, you can also specify the
        proportion of &quot;extra-heap resources&quot; consumed by the
        block, which will affect the garbage collector's decision as to
        how much work to do in the next major slice.
        (<span><em>avsm</em></span>: elaborate on this or move to the C
        interface section)
      </p></section></section><section><h1 id="interfacing-with-c">Interfacing with C</h1><p id="idp10089392">
      Now that you understand the runtime structure of the garbage
      collector, interfacing with C libraries is actually pretty simple.
      OCaml defines an <code>external</code> keyword that maps
      OCaml functions to a C symbol. That C function will be passed the
      arguments with the C <code>value</code> type which
      corresponds to the memory layout for OCaml values described
      earlier.
    </p><section><h1 id="getting-started-with-a-hello-world-c-binding">Getting started with a &quot;Hello World&quot; C
      binding</h1><p id="idp10092848">
        Let's define a simple &quot;Hello World&quot; C binding to see
        how this works. First create a <code>hello.ml</code> that
        contains the external declaration:
      </p><div class="highlight"><pre><span class="k">external</span> <span class="n">hello_world</span><span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="s2">&quot;caml_hello_world&quot;</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">hello_world</span> <span class="bp">()</span>
</pre></div><p id="idp10095296">
        If you try to compile this module now, you should receive a
        linker error:
      </p><pre id="idp10095792">
$ ocamlopt -o hello hello.ml
Undefined symbols for architecture x86_64:
  &quot;_caml_hello_world&quot;, referenced from:
      .L100 in hello.o
      _camlHello in hello.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
File &quot;caml_startup&quot;, line 1:
Error: Error during linking
</pre><p id="idp10097184">
        This is the system linker telling you that there is a missing
        <code>caml_hello_world</code> symbol that must be provided
        before a binary can be linked. Now create a file called
        <code>hello_stubs.c</code> which contains the C function.
      </p><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;caml/mlvalues.h&gt;</span>

<span class="n">CAMLprim</span> <span class="n">value</span>
<span class="nf">caml_hello_world</span><span class="p">(</span><span class="n">value</span> <span class="n">v_unit</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello OCaml World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Val_unit</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><p id="idp10100368">
        Now attempt to recompile the <code>hello</code> binary
        with the C file also included in the compiler invocation, and it
        should succeed:
      </p><pre id="idp10101616">
$ ocamlopt -o hello hello.ml hello_stubs.c
$ ./hello
Hello OCaml World!
</pre><p id="idp10102368">
        The compiler uses the file extensions to determine how to
        compile each file. In the case of the <code>.c</code>
        extension, it passes it to the system C compiler and appends an
        include directory containing the OCaml runtime header files that
        define conversion functions to-and-from OCaml values.
      </p><p id="idp10103808">
        The <code>mlvalues.h</code> header is the basic header
        that all C bindings need. Locate it in your system by using
        <code>ocamlc -where</code> to find your system OCaml
        installation. It defines a few important typedefs early on that
        should be familiar after the earlier explanations:
      </p><div class="highlight"><pre><span class="k">typedef</span> <span class="n">intnat</span> <span class="n">value</span><span class="p">;</span>

<span class="cp">#define Is_long(x)   (((x) &amp; 1) != 0)</span>
<span class="cp">#define Is_block(x)  (((x) &amp; 1) == 0)</span>

<span class="cp">#define Val_unit Val_int(0)</span>
</pre></div><p id="idp10107104">
        The <code>value</code> typedef is a word that can either
        be an integer if <code>Is_long</code> is true, or a heap
        block if <code>Is_block</code> is true. Our C function
        definition of <code>caml_hello_world</code> accepts a
        single parameter, and returns a <code>value</code>. In our
        simple example, all the types of parameters and returns are
        <code>unit</code>, and so we use the
        <code>Val_unit</code> macro to construct the return value.
      </p><p id="idp10112800">
        You must be <span><em>very</em></span> careful that the value you
        return from the C function corresponds exactly to the memory
        representation of the types you declared earlier in the
        <code>external</code> declaration of the ML file, or else
        heap carnage and corruption will ensure.
      </p><aside class="tip"><h1>
      Activating the debug runtime
      </h1><p id="idp10115328">
        Despite your best efforts, it is easy to introduce a bug into C
        bindings that cause heap invariants to be violated. OCaml
        includes a variant of the runtime library that is compiled with
        debugging symbols, and includes regular memory integrity checks
        upon every garbage collection. Running these often will abort
        the program near the point of corruption and helps track it down
        quickly.
      </p><p id="idp10116176">
        To use this, just recompile with
        <code>-runtime-variant d</code> set:
      </p><pre id="idp10117344">
$ ocamlopt -runtime-variant d -verbose -o hello hello.ml hello_stubs.c
$ ./hello 
### OCaml runtime: debug mode ###
Initial minor heap size: 2048k bytes
Initial major heap size: 992k bytes
Initial space overhead: 80%
Initial max overhead: 500%
Initial heap increment: 992k bytes
Initial allocation policy: 0
Hello OCaml World!
</pre></aside></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt03.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="managing-external-memory-with-bigarrays.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>