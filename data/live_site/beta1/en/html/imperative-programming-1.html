<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 8. Imperative Programming / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta1',
                        page: 'imperative\u002Dprogramming\u002D1.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">4. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html" class="here">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">10. First class modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="objects.html">11. Objects</a>
                                            </li>
                                        
                                            <li>
                                                <a href="classes.html">12. Classes</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 8. Imperative Programming</h1>
                
                

    <p id="idp8563088">
    Most of the code shown so far in this book, and indeed, most OCaml
    code in general, is <span><em>pure</em></span>. Pure code works
    without mutating the program's internal state, performing I/O,
    reading the clock, or in any other way interacting with changeable
    parts of the world. Thus, a pure function behaves like a
    mathematical function, always returning the same results when given
    the same inputs, and never affecting the world except insofar as it
    returns the value of its computation.
    <span><em>Imperative</em></span> code, on the other hand, operates by
    side-effects that modify a program's internal state or interact with
    the outside world. An imperative function has a new effect, and
    potentially returns different results, every time it's called.
  </p><p id="idp8565456">
    Pure code is the default in OCaml, and for good reason --- it's
    generally easier to reason about, less error prone and more
    composable. But imperative code is of fundamental importance to any
    practical programming language because real-world tasks require that
    you interact with the outside world, which is by its nature
    imperative. Imperative programming can also be important for
    performance. While pure code is quite efficient in OCaml, there are
    many algorithms that can only be implemented efficiently using
    imperative techniques.
  </p><p id="idp8566432">
    OCaml offers a happy compromise here, making it easy and natural to
    program in a pure style, but also providing great support for
    imperative programming where you need it. This chapter will walk you
    through OCaml's imperative features, and help you use them to their
    fullest.
  </p><section><h1 id="example-imperative-dictionaries">Example: Imperative dictionaries</h1><p id="idp8568016">
      We'll start with the implementation of a simple imperative
      dictionary, <span><em>i.e.</em></span>, a mutable mapping from keys
      to values. This is really for illustration purposes; both Core and
      the standard library provide imperative dictionaries, and for most
      real world tasks, you should use one of those implementations.
    </p><p id="idp8569152">
      Our dictionary, like those in Core and the standard library, will
      be implemented as a hash table. In particular, we'll use an
      <span><em>open hashing</em></span> scheme, which is to say the hash
      table will be an array of buckets, each bucket containing a list
      of key/value pairs that have been hashed into that bucket.
    </p><p id="idp8570272">
      Here's the interface we'll match, provided as an
      <code>mli</code>. Here, the type
      <code>('a, 'b) t</code> is used for a dictionary with keys
      of type <code>'a</code> and data of type
      <code>'b</code>.
    </p><div class="highlight"><pre><span class="c">(* file: dictionary.mli *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">length</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">add</span>    <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">find</span>   <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">iter</span>   <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</pre></div><p id="idp8574448">
      The <code>mli</code> also includes a collection of helper
      functions whose purpose and behavior should be largely inferrable
      from their names and type signatures. Notice that a number of the
      functions, in particular, ones like <code>add</code> that
      modify the dictionary, return unit. This is typical of functions
      that act by side-effect.
    </p><p id="idp8576448">
      We'll now walk through the implementation (contained in the
      corresponding <code>ml</code> file) piece by piece,
      explaining different imperative constructs as they come up.
    </p><p id="idp8577664">
      Our first step is to define the type of a dictionary as a record
      with two fields.
    </p><div class="highlight"><pre><span class="c">(* file: dictionary.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="n">length</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
                    <span class="n">buckets</span><span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="kt">list</span> <span class="kt">array</span><span class="o">;</span>
                  <span class="o">}</span>
</pre></div><p id="idp8579200">
      The first field, <code>length</code> is declared as mutable.
      In OCaml, records are immutable by default, but individual fields
      are mutable when marked as such. The second field,
      <code>buckets</code>, is immutable, but contains an array,
      which is itself a mutable data structure, as we'll see.
    </p><p id="idp8581136">
      Now we'll start putting together the basic functions for
      manipulating a dictionary.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">17</span>

<span class="k">let</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span><span class="o">)</span> <span class="ow">mod</span> <span class="n">num_buckets</span>

<span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="o">{</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">buckets</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">len</span><span class="o">:</span><span class="n">num_buckets</span> <span class="bp">[]</span><span class="o">;</span>
  <span class="o">}</span>

<span class="k">let</span> <span class="n">length</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span>

<span class="k">let</span> <span class="n">find</span> <span class="n">t</span> <span class="n">key</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">find_map</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">hash_bucket</span> <span class="n">key</span><span class="o">)</span>
    <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key'</span><span class="o">,</span><span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">key'</span> <span class="o">=</span> <span class="n">key</span> <span class="k">then</span> <span class="nc">Some</span> <span class="n">data</span> <span class="k">else</span> <span class="nc">None</span><span class="o">)</span>
</pre></div><p id="idp8583072">
      Note that <code>num_buckets</code> is a constant. That's
      because, for simplicity's sake, we're using a fixed-length bucket
      array. For a practical implementation, the length of the array
      would have to be able to grow as the number of elements in the
      dictionary increases.
    </p><p id="idp8584368">
      The function <code>hash_bucket</code> is used throughout the
      rest of the module to choose the position in the array that a
      given key should be stored at. It is implemented on top of
      <code>Hashtbl.hash</code>, which is a hash function provided
      by the OCaml runtime that can be applied to values of any type.
      Thus, its own type is polymorphic:
      <code>'a -&gt; int</code>.
    </p><p id="idp8586976">
      While <code>Hashtbl.hash</code> can be used with any type,
      it won't necessarily succeed for all values.
      <code>Hashtbl.hash</code> will throw an exception if it
      encounters a value it can't handle, like a function or a value
      from a C libraries that lives outside the OCaml heap.
    </p><p id="idp8588880">
      The other functions defined above are fairly straightforward:
    </p><ul><li><p id="idp8589872">
<code>create</code> creates an empty dictionary.
        </p></li><li><p id="idp8591264">
<code>length</code> grabs the length from the
          corresponding record field, thus returning the number of
          entries stored in the dictionary.
        </p></li><li><p id="idp8592816">
<code>find</code> looks for a matching key in the table
          and returns the corresponding value if found as an option.
        </p></li></ul><p id="idp8594208">
      Another bit of syntax has popped up in <code>find</code>: we
      write <code>array.(index)</code> to grab a value from an
      array. Also, <code>find</code> uses
      <code>List.find_map</code>, which you can see the type of by
      typing it into the toplevel:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">find_map</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">option</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8598224">
<code>List.find_map</code> iterates over the elements of the
      list, calling <code>f</code> on each one until a
      <code>Some</code> is returned by <code>f</code>, at
      which point the value returned by <code>f</code> is returned
      by <code>find_map</code>. If <code>f</code> returns
      <code>None</code> on all values, then
      <code>None</code> is returned by
      <code>find_map</code>.
    </p><p id="idp8604848">
      Now let's look at the implementation of <code>iter</code>:
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">iter</span> <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span><span class="o">)</span>
  <span class="k">done</span>
</pre></div><p id="idp8606960">
<code>iter</code> is designed to walk over all the entries
      in the dictionary. In particular, <code>iter t ~f</code>
      will call <code>f</code> for each key/value pair in
      dictionary <code>t</code>. Note that <code>f</code>
      must return <code>unit</code>, since it is expected to work
      by side effect rather than by returning a value, and the overall
      <code>iter</code> function returns <code>unit</code>
      as well.
    </p><p id="idp8612560">
      The code for <code>iter</code> uses two forms of iteration:
      a <code>for</code> loop to walk over the array of buckets;
      and within that loop, and a call to <code>List.iter</code>
      to walk over the list of values in a given bucket. We could have
      done the outer loop with a recursive function instead of a
      <code>for</code> loop, but <code>for</code> loops are
      syntactically convenient, and are more familiar and idiomatic in
      the context of imperative code.
    </p><p id="idp8616464">
      The following code is for adding and removing mappings from the
      dictionary.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">bucket_has_key</span> <span class="n">t</span> <span class="n">i</span> <span class="n">key</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key'</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="n">key'</span> <span class="o">=</span> <span class="n">key</span><span class="o">)</span>

<span class="k">let</span> <span class="n">add</span> <span class="n">t</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">replace</span> <span class="o">=</span> <span class="n">bucket_has_key</span> <span class="n">t</span> <span class="n">i</span> <span class="n">key</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">filtered_bucket</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">replace</span> <span class="k">then</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key'</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="n">key'</span> <span class="o">&lt;&gt;</span> <span class="n">key</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="o">::</span> <span class="n">filtered_bucket</span><span class="o">;</span>
  <span class="k">if</span> <span class="n">not</span> <span class="n">replace</span> <span class="k">then</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">let</span> <span class="n">remove</span> <span class="n">t</span> <span class="n">key</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">bucket_has_key</span> <span class="n">t</span> <span class="n">i</span> <span class="n">key</span> <span class="k">then</span> <span class="o">(</span>
    <span class="k">let</span> <span class="n">filtered_bucket</span> <span class="o">=</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key'</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="n">key'</span> <span class="o">&lt;&gt;</span> <span class="n">key</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">filtered_bucket</span><span class="o">;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="o">)</span>
</pre></div><p id="idp8618560">
      This above code is made more complicated by the fact that we need
      to detect whether we are overwriting or removing an existing
      binding, so we can decide whether <code>t.length</code>
      needs to be changed. The helper function
      <code>bucket_has_key</code> is used for this purpose.
    </p><p id="idp8620384">
      Another piece of syntax shows up in both <code>add</code>
      and <code>remove</code>: the use of the
      <code>&lt;-</code> operator to update elements of an array
      (<code>array.(i) &lt;- expr</code>) and for updating a
      record field (<code>record.field &lt;- expression</code>).
    </p><p id="idp8623888">
      We also use a single semicolon, <code>;</code>, as a
      sequencing operator, to allow us to do a sequence of
      side-effecting operations in a row: first, update the bucket, then
      update the count. We could have done this using let bindings:
    </p><div class="highlight"><pre>    <span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">filtered_bucket</span> <span class="k">in</span>
    <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div><p id="idp8626192">
      but <code>;</code> is more concise and idiomatic. More
      generally,
    </p><div class="highlight"><pre><span class="o">&lt;</span><span class="n">expr1</span><span class="o">&gt;;</span>
<span class="o">&lt;</span><span class="n">expr2</span><span class="o">&gt;;</span>
<span class="o">...</span>
<span class="o">&lt;</span><span class="n">exprN</span><span class="o">&gt;</span>
</pre></div><p id="idp8628144">
      is equivalent to
    </p><div class="highlight"><pre><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">expr1</span><span class="o">&gt;</span> <span class="k">in</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">expr2</span><span class="o">&gt;</span> <span class="k">in</span>
<span class="o">...</span>
<span class="o">&lt;</span><span class="n">exprN</span><span class="o">&gt;</span>
</pre></div><p id="idp8629488">
      When a sequence expression <code>expr1; expr2</code> is
      evaluated, <code>expr1</code> is evaluated first, and then
      <code>expr2</code>. The expression <code>expr1</code>
      should have type <code>unit</code> (though this is a warning
      rather than a hard restriction), and the value of
      <code>expr2</code> is returned as the value of the entire
      sequence. For example, the sequence
      <code>print_string &quot;hello world&quot;; 1 + 2</code>
      first prints the string
      <code>&quot;hello world&quot;</code>, then returns the
      integer <code>3</code>.
    </p><p id="idp8635808">
      Note also that we do all of the side-effecting operations at the
      very end of each function. This is good practice because it
      minimizes the chance that such operations will be interrupted with
      an exception, leaving the data structure in an inconsistent state.
    </p></section><section><h1 id="primitive-mutable-data">Primitive mutable data</h1><p id="idp8637504">
      Now that we've looked at a complete example, let's take a more
      systematic look at imperative programming in OCaml. We encountered
      two different forms of mutable data above: records with mutable
      fields and arrays. We'll now discuss these in more detail, along
      with the other primitive forms of mutable data that are available
      in OCaml.
    </p><section><h1 id="array-like-data">Array-like data</h1><p id="idp8639168">
        OCaml supports a number of array-like data structures;
        <span><em>i.e.</em></span>, mutable integer-indexed containers
        that provide constant-time access to their elements. We'll
        discuss several of them below.
      </p><section><h1 id="ordinary-arrays">Ordinary arrays</h1><p id="idp8641072">
          The <code>array</code> type is used for general purpose
          polymorphic arrays. The <code>Array</code> module has a
          variety of utility functions for interacting with arrays,
          including a number of mutating operations. These include
          <code>Array.set</code>, for setting an individual
          element, and <code>Array.blit</code>, for efficiently
          copying values from one range of indices to another.
        </p><p id="idp8644320">
          Arrays also come with special syntax for retrieving an element
          from an array:
        </p><div class="highlight"><pre><span class="kt">array</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span>
</pre></div><p id="idp8645696">
          and for setting an element in an array:
        </p><div class="highlight"><pre><span class="kt">array</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">expr</span>
</pre></div><p id="idp8647024">
          Array literals are written using <code>[|</code> and
          <code>|]</code> as delimiters. Thus,
          <code>[| 1; 2; 3 |]</code> is a literal integer array.
        </p></section><section><h1 id="strings">Strings</h1><p id="idp8650288">
          Strings are essentially byte-arrays which are often used for
          textual data. The main advantage of using a
          <code>string</code> in place of a
          <code>Char.t array</code> (a <code>Char.t</code>
          is an 8-bit character) is that the former is considerably more
          space efficient; an array uses one word --- 8 bytes on a
          64-bit machine --- to store a single entry, whereas strings
          use one byte per character.
        </p><p id="idp8652976">
          Strings also come with their own syntax for getting and
          setting values: <code>string.[index]</code> and
          <code>string.[index] &lt;- expr</code> respectively, and
          string literals are bounded by quotes. There's also a module
          <code>String</code> where you'll find useful functions
          for working with strings.
        </p></section><section><h1 id="bigarrays">Bigarrays</h1><p id="idp8656560">
          A <code>Bigarray.t</code> is a handle to a block of
          memory stored outside of the OCaml heap. These are mostly
          useful for interacting with C or Fortran libraries, and are
          discussed in
          <a href="memory-representation-of-values.html">Chapter 21, <i>Memory Representation of Values</i></a>.
          Bigarrays too have their own getting and setting syntax:
          <code>bigarray.{index}</code> and
          <code>bigarray.{index} &lt;- expr</code>. There is no
          literal syntax for bigarrays.
        </p></section></section><section><h1 id="mutable-record-and-object-fields-and-ref-cells">Mutable record and object fields and ref cells</h1><p id="idp8660832">
        As we've seen, records are immutable by default, but individual
        record fields can be declared as mutable. These mutable fields
        can be set using the <code>&lt;-</code> operator,
        <span><em>i.e.</em></span>,
        <code>record.field &lt;- expr</code>.
      </p><p id="idp8663040">
        As we'll see in <a href="objects.html">Chapter 11, <i>Objects</i></a>, fields of
        an object can similarly be declared as mutable, and can then be
        modified in much the same way as record fields.
      </p><section><h1 id="ref-cells">Ref Cells</h1><p id="idp8664960">
          Variables in OCaml are never mutable --- they can refer to
          mutable data, but what the variable points to can't be
          changed. Sometimes, though, you want to do exactly what you
          would do with a mutable variable in another language: define a
          single, mutable value. In OCaml this is typically achieved
          using a <code>ref</code>, which is essentially a
          container with a single mutable polymorphic field.
        </p><p id="idp8666464">
          The definition for the ref type is as follows:
        </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="n">contents</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">}</span>
</pre></div><p id="idp8667792">
          The standard library defines the following operators for
          working with refs.
        </p><ul><li><p id="idp8668816">
<code>ref expr</code> constructs a reference cell
              containing the value defined by the expression
              <code>expr</code>.
            </p></li><li><p id="idp8670960">
<code>!refcell</code> returns the contents of the
              reference cell.
            </p></li><li><p id="idp8672432">
<code>refcell := expr</code> replaces the contents
              of the reference cell.
            </p></li></ul><p id="idp8673792">
          You can see these in action below.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">1</span><span class="o">}</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8675184">
          The above are just ordinary OCaml functions which could be
          defined as follows.
        </p><div class="highlight"><pre><span class="k">let</span> <span class="n">ref</span> <span class="n">x</span> <span class="o">=</span> <span class="o">{</span> <span class="n">contents</span> <span class="o">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="k">let</span> <span class="o">(!)</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">contents</span>
<span class="k">let</span> <span class="o">(:=)</span> <span class="n">r</span> <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="n">x</span>
</pre></div></section></section><section><h1 id="foreign-functions">Foreign functions</h1><p id="idp8677872">
        Another source of imperative operations in OCaml is resources
        that come from interfacing with external libraries through
        OCaml's foreign function interface (FFI). The FFI opens OCaml up
        to imperative constructs that are exported by system calls or
        other external libraries. Many of these come built in, like
        access to the <code>write</code> system call, or to the
        <code>clock</code>; while others come from user libraries,
        like LAPACK bindings.
      </p></section></section><section><h1 id="for-and-while-loops-1"><code>for</code> and <code>while</code>
    loops</h1><p id="idp8682240">
      OCaml provides support for traditional imperative looping
      constructs, in particular, <code>for</code> and
      <code>while</code> loops, even though neither of them is
      strictly necessary. Anything you can do with such a loop you can
      also do with a recursive function, and you can also write
      higher-order functions like <code>Array.iter</code> that
      cover much of the same ground.
    </p><p id="idp8684832">
      Nonetheless, explicit <code>for</code> and
      <code>while</code> loops are both more idiomatic for
      imperative programming and often more concise.
    </p><p id="idp8686576">
      The <code>for</code> loop is the simpler of the two. Indeed,
      we've already seen the <code>for</code> loop in action ---
      the <code>iter</code> function in
      <code>Dictionary</code> is built using it. Here's a simple
      example of <code>for</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span> <span class="k">done</span><span class="o">;;</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8691280">
      As you can see, the upper and lower bounds are inclusive. We can
      also use <code>downto</code> to iterate in the other
      direction.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span> <span class="k">done</span><span class="o">;;</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8693520">
      OCaml also supports <code>while</code> loops, which include
      a condition and a body. The loop first evaluates the condition,
      and then, if it evaluates to true, evaluates the body and starts
      the loop again. Here's a simple example of a function for
      reversing an array in-place.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">rev_inplace</span> <span class="n">ar</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">ar</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">in</span>
    <span class="c">(* terminate when the upper and lower indices meet *)</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">j</span> <span class="k">do</span>
      <span class="c">(* swap the two elements *)</span>
      <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.(!</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
      <span class="n">ar</span><span class="o">.(!</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">ar</span><span class="o">.(!</span><span class="n">j</span><span class="o">);</span>
      <span class="n">ar</span><span class="o">.(!</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span><span class="o">;</span>
      <span class="c">(* bump the indices *)</span>
      <span class="n">incr</span> <span class="n">i</span><span class="o">;</span>
      <span class="n">decr</span> <span class="n">j</span>
    <span class="k">done</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">rev_inplace</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">array</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">|];;</span>
<span class="k">val</span> <span class="n">nums</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">|]</span>
<span class="o">#</span> <span class="n">rev_inplace</span> <span class="n">nums</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">nums</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">5</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">1</span><span class="o">|]</span>
</pre></div><p id="idp8696544">
      In the above, we used <code>incr</code> and
      <code>decr</code>, which are build-in functions for
      incrementing and decrementing an <code>int ref</code> by
      one, respectively.
    </p></section><section><h1 id="example-doubly-linked-lists">Example: Doubly-linked lists</h1><p id="idp8699904">
      Another common imperative data structure is the doubly-linked
      list. Doubly-linked lists can be traversed in both directions and
      elements can be added and removed from the list in constant time.
      Core defines a doubly-linked list (the module is called
      <code>Doubly_linked</code>), but we'll define our own linked
      list library as an illustration.
    </p><p id="idp8701312">
      Here's the <code>mli</code> of the module we'll build.
    </p><div class="highlight"><pre><span class="c">(* file: dlist.mli *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span>

<span class="c">(** Basic list operations  *)</span>
<span class="k">val</span> <span class="n">create</span>   <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>

<span class="c">(** Navigation using [element]s *)</span>
<span class="k">val</span> <span class="n">first</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">next</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">prev</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>

<span class="c">(** Whole-data-structure iteration *)</span>
<span class="k">val</span> <span class="n">iter</span>    <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">find_el</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>

<span class="c">(** Mutation *)</span>
<span class="k">val</span> <span class="n">insert_first</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span>
<span class="k">val</span> <span class="n">insert_after</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span>
<span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</pre></div><p id="idp8704400">
      Note that there are two types defined here:
      <code>'a t</code>, the type of a list, and
      <code>'a element</code>, the type of an element. Elements
      act as pointers to the interior of a list, and allow us to
      navigate the list and give us a point at which to apply mutating
      operations.
    </p><p id="idp8706320">
      Now let's look at the implementation. We'll start by defining
      <code>'a element</code> and <code>'a t</code>.
    </p><div class="highlight"><pre><span class="c">(* file: dlist.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">=</span>
  <span class="o">{</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">prev</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
  <span class="o">}</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span> <span class="n">ref</span>
</pre></div><p id="idp8709120">
      An <code>'a element</code> is a record containing the value
      to be stored in that node as well as optional (and mutable) fields
      pointing to the previous and next elements. At the beginning of
      the list, the <code>prev</code> field is
      <code>None</code>, and at the end of the list, the
      <code>next</code> field is <code>None</code>.
    </p><p id="idp8712832">
      The type of the list itself, <code>'a t</code>, is an
      mutable reference to an optional <code>element</code>. This
      reference is <code>None</code> if the list is empty, and
      <code>Some</code> otherwise.
    </p><p id="idp8715712">
      Now we can define a few basic functions that operate on lists and
      elements.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>
<span class="k">let</span> <span class="n">is_empty</span> <span class="n">t</span> <span class="o">=</span> <span class="o">!</span><span class="n">t</span> <span class="o">=</span> <span class="nc">None</span>

<span class="k">let</span> <span class="n">value</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">value</span>

<span class="k">let</span> <span class="n">first</span> <span class="n">t</span> <span class="o">=</span> <span class="o">!</span><span class="n">t</span>
<span class="k">let</span> <span class="n">next</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">next</span>
<span class="k">let</span> <span class="n">prev</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">prev</span>
</pre></div><p id="idp8717232">
      These all follow relatively straight-forwardly from our type
      definitions.
    </p><aside class="note"><h1> 
    Cyclic data structures
    </h1><p id="idp8718240">
      Doubly-linked lists are a cyclic data structure, meaning that it
      is possible to follow a nontrivial sequence of pointers that
      closes in on itself. In general, building cyclic data structures
      requires the use of side-effects. This is done by constructing the
      data elements first, and then adding cycles using assignment
      afterwards.
    </p><p id="idp8719008">
      There is an exception to this, though: you can construct
      fixed-size cyclic data-structures using
      <code>let rec</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">endless_loop</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="n">endless_loop</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">endless_loop</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span>
   <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span>
   <span class="o">...]</span>
</pre></div><p id="idp8721280">
      This approach is quite limited, however. General purpose cyclic
      data structures require mutation.
    </p></aside><section><h1 id="modifying-the-list">Modifying the list</h1><p id="idp8722800">
        Now, we'll start considering operations that mutate the list,
        starting with <code>insert_first</code>, which inserts an
        element at the front of the list.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">insert_first</span> <span class="n">t</span> <span class="n">value</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">new_elt</span> <span class="o">=</span> <span class="o">{</span> <span class="n">prev</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="o">!</span><span class="n">t</span><span class="o">;</span> <span class="n">value</span> <span class="o">}</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="o">!</span><span class="n">t</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">old_first</span> <span class="o">-&gt;</span> <span class="n">old_first</span><span class="o">.</span><span class="n">prev</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">new_elt</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">new_elt</span><span class="o">;</span>
  <span class="n">new_elt</span>
</pre></div><p id="idp8725136">
<code>insert_first</code> first defines a new element
        <code>new_elt</code>, and then links it into the list,
        finally setting the list itself to point to
        <code>new_elt</code>. Note that the precedence of a
        <code>match</code> expression is very low, so to separate
        it from the following assignment
        (<code>t := Some new_elt</code>) we surround the match
        with <code>begin ... end</code>. We could have used
        parenthesis for the same purpose. Without some kind of
        bracketing, the final assignment would incorrectly become part
        of the <code>None -&gt; ...</code> case.
      </p><p id="idp8730304">
        We can use <code>insert_after</code> to insert elements
        later in the list. <code>insert_after</code> takes as
        arguments both an <code>element</code> after which to
        insert the new node, and a value to insert.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">insert_after</span> <span class="n">elt</span> <span class="n">value</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">new_elt</span> <span class="o">=</span> <span class="o">{</span> <span class="n">value</span><span class="o">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="nc">Some</span> <span class="n">elt</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="o">}</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">old_next</span> <span class="o">-&gt;</span> <span class="n">old_next</span><span class="o">.</span><span class="n">prev</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">new_elt</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">new_elt</span><span class="o">;</span>
  <span class="n">new_elt</span>
</pre></div><p id="idp8733824">
        Finally, we need a <code>remove</code> function.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">remove</span> <span class="n">t</span> <span class="n">elt</span> <span class="o">=</span>
  <span class="k">let</span> <span class="o">{</span> <span class="n">prev</span><span class="o">;</span> <span class="n">next</span><span class="o">;</span> <span class="o">_</span> <span class="o">}</span> <span class="o">=</span> <span class="n">elt</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="n">prev</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">prev</span> <span class="o">-&gt;</span> <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="n">next</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">next</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="n">next</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">next</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="o">.</span><span class="n">prev</span> <span class="o">&lt;-</span> <span class="n">prev</span><span class="o">;</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">elt</span><span class="o">.</span><span class="n">prev</span> <span class="o">&lt;-</span> <span class="nc">None</span><span class="o">;</span>
  <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="nc">None</span>
</pre></div><p id="idp8736112">
        Note that the above code is careful to change the
        <code>prev</code> pointer of the following element, and
        the <code>next</code> pointer of the previous element, if
        they exist. If there's no previous element, then the list
        pointer itself is updated. In any case, the next and previous
        pointers of the element itself are set to
        <code>None</code>.
      </p><p id="idp8738688">
        These functions are more fragile than they may seem. In
        particular, misuse of the interface may lead to corrupted data.
        For example, double-removing an element will cause the main list
        reference to be set to <code>None</code>, thus emptying
        the list. Similar problems arise from removing an element from a
        list it doesn't belong to.
      </p><p id="idp8740096">
        This shouldn't be a big surprise. Complex imperative data
        structures can be quite tricky; considerably trickier than their
        pure equivalents. The issues described above can be dealt with
        by more careful error detection, and such error correction is
        taken care of in modules like Core's
        <code>Doubly_linked</code>. You should use imperative data
        structures from a well-designed library when you can. And when
        you can't, you should make sure that the code you write is
        careful about error detection.
      </p></section><section><h1 id="iteration-functions">Iteration functions</h1><p id="idp8742704">
        When defining containers like lists, dictionaries and trees,
        you'll typically want to define a set of iteration functions,
        like <code>iter</code>, <code>map</code>, and
        <code>fold</code>, which let you concisely express common
        iteration patterns.
      </p><p id="idp8745232">
<code>Dlist</code> has two such iterators:
        <code>iter</code>, the goal of which is to call a
        <code>unit</code> producing function on every element of
        the list, in order; and <code>find_el</code>, which runs a
        provided test function on each values stored in the list,
        returning the first <code>element</code> that passes the
        test. Both <code>iter</code> and
        <code>find_el</code> are implemented using simple
        recursive loops that use <code>next</code> to walk from
        element to element, and <code>value</code> to extract the
        element from a given node.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">iter</span> <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">value</span> <span class="n">el</span><span class="o">);</span> <span class="n">loop</span> <span class="o">(</span><span class="n">next</span> <span class="n">el</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="o">!</span><span class="n">t</span>

<span class="k">let</span> <span class="n">find_el</span> <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">elt</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">f</span> <span class="o">(</span><span class="n">value</span> <span class="n">elt</span><span class="o">)</span> <span class="k">then</span> <span class="nc">Some</span> <span class="n">elt</span>
      <span class="k">else</span> <span class="n">loop</span> <span class="o">(</span><span class="n">next</span> <span class="n">elt</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="o">!</span><span class="n">t</span>
</pre></div></section></section><section><h1 id="laziness-and-other-benign-effects">Laziness and other benign effects</h1><p id="idp8754064">
      There are many instances where you basically want to program in a
      pure style, but you want to make limited use of side-effects to
      improve the performance of your code, without really changing
      anything else. Such side effects are sometimes called
      <span><em>benign effects</em></span>, and they are a useful way of
      leveraging OCaml's imperative features while still maintaining
      most of the benefits of pure programming.
    </p><p id="idp8755584">
      One of the simplest benign effect is
      <span><em>laziness</em></span>. A lazy value is one that is not
      computed until it is actually needed. In OCaml, lazy values are
      created using the <code>lazy</code> keyword, which can be
      used to prefix any expression, returning a value of type
      <code>'a Lazy.t</code>. The evaluation of that expression is
      delayed until forced with the <code>Lazy.force</code>
      function.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">print_string</span> <span class="s2">&quot;performing lazy computation</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sqrt</span> <span class="mi">16</span><span class="o">.);;</span>
<span class="k">val</span> <span class="n">v</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">lazy_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">lazy</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="n">performing</span> <span class="k">lazy</span> <span class="n">computation</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">4</span><span class="o">.</span>
</pre></div><p id="idp8759664">
      You can see from the print statement that the actual computation
      was performed only once, and only after <code>force</code>
      had been called.
    </p><p id="idp8760800">
      To better understand how laziness works, let's walk through the
      implementation of our own lazy type. We'll start by declaring
      types to represent a lazy value.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">lazy_state</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Delayed</span> <span class="k">of</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Value</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span>
  <span class="o">|</span> <span class="nc">Exn</span> <span class="k">of</span> <span class="n">exn</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">lazy_state</span> <span class="o">=</span> <span class="nc">Delayed</span> <span class="k">of</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">|</span> <span class="nc">Value</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Exn</span> <span class="k">of</span> <span class="n">exn</span>
</pre></div><p id="idp8762592">
      A <code>lazy_state</code> represents the possible states of
      a lazy value. A lazy value is <code>Delayed</code> before it
      has been run, where <code>Delayed</code> holds a function
      for computing the value in question. A lazy value is in the
      <code>Value</code> state when it has been forced and the
      computation ended normally. The <code>Exn</code> case is for
      when the lazy value has been forced, but the computation ended
      with an exception. A lazy value is simply a <code>ref</code>
      containing a <code>lazy_state</code>, where the
      <code>ref</code> makes it possible to change from being in
      the <code>Delayed</code> state to being in the
      <code>Value</code> or <code>Exn</code> states.
    </p><p id="idp8770272">
      We can create a lazy value based on a thunk,
      <span><em>i.e.</em></span>, a function that takes a unit argument.
      Wrapping an expression in a thunk is another way to suspend the
      computation of an expression.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">create_lazy</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="nc">Delayed</span> <span class="n">f</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">create_lazy</span> <span class="o">:</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">lazy_state</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">create_lazy</span>
    <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">print_string</span> <span class="s2">&quot;performing lazy computation</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sqrt</span> <span class="mi">16</span><span class="o">.);;</span>
  <span class="k">val</span> <span class="n">v</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">lazy_state</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="nc">Delayed</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;}</span>
</pre></div><p id="idp8772496">
      Now we just need a way to force a lazy value. The following
      function does just that.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">force</span> <span class="n">v</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">!</span><span class="n">v</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Value</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="nc">Exn</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">e</span>
    <span class="o">|</span> <span class="nc">Delayed</span> <span class="n">f</span> <span class="o">-&gt;</span>
      <span class="k">try</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span>
        <span class="n">v</span> <span class="o">:=</span> <span class="nc">Value</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">x</span>
      <span class="k">with</span> <span class="n">exn</span> <span class="o">-&gt;</span>
        <span class="n">v</span> <span class="o">:=</span> <span class="nc">Exn</span> <span class="n">exn</span><span class="o">;</span>
        <span class="k">raise</span> <span class="n">exn</span>
   <span class="o">;;</span>
<span class="k">val</span> <span class="n">force</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">lazy_state</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8774240">
      Which we can use in the same way we used
      <code>Lazy.force</code>:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="n">performing</span> <span class="k">lazy</span> <span class="n">computation</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">#</span> <span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">4</span><span class="o">.</span>
</pre></div><p id="idp8776208">
      The main user-visible difference between our implementation of
      laziness and the built-in version is syntax. Rather than writing
      <code>create_lazy (fun () -&gt; sqrt 16.)</code>, we can
      with the built-in <code>lazy</code> just write
      <code>lazy (sqrt 16.)</code>.
    </p><section><h1 id="memoization-and-dynamic-programming">Memoization and dynamic programming</h1><p id="idp8779504">
        Another benign effect is <span><em>memoization</em></span>. A
        memoized function remembers the result of previous invocations
        of the function so that they can be returned without further
        computation when the same arguments are presented again.
      </p><p id="idp8780496">
        Here's a function that takes as an argument an arbitrary
        single-argument function and returns a memoized version of that
        function. Here we'll use Core's <code>Hashtbl</code>
        module, rather than our toy <code>Dictionary</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">memoize</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="nn">Poly</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="n">x</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">y</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="k">in</span>
        <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add_exn</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">x</span> <span class="o">~</span><span class="n">data</span><span class="o">:</span><span class="n">y</span><span class="o">;</span>
        <span class="n">y</span>
    <span class="o">);;</span>
<span class="k">val</span> <span class="n">memoize</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8783712">
        The code above is a bit tricky. <code>memoize</code> takes
        as its argument a function <code>f</code>, and then
        allocates a hashtable (called <code>table</code>) and
        returns a new function as the memoized version of
        <code>f</code>. When called, this new function looks in
        <code>table</code> first, and if it fails to find a value,
        calls <code>f</code> and stashes the result in
        <code>table</code>. Note that <code>table</code>
        doesn't go out of scope as long as the function returned by
        <code>memoize</code> is in scope.
      </p><p id="idp8789904">
        Memoization can be useful whenever you have a function that is
        expensive to recompute, and you don't mind caching old values
        indefinitely. One important caution: every time you create a
        memoized function, there's something of a built-in memory leak.
        As long as you hold on to the memoized function, you're holding
        every result it has returned thus far.
      </p><p id="idp8790720">
        Memoization is also useful for efficiently implementing some
        recursive algorithms. One good example is the algorithm for
        computing the <span><em>edit distance</em></span> (also called
        the Levenshtein distance) between two strings. The edit distance
        is the number of single-character changes (including letter
        switches, insertions and deletions) required to convert one
        string to the other. This kind of distance metric can be useful
        for a variety of approximate string matching problems, like
        spell checkers.
      </p><p id="idp8792080">
        Consider the following code for computing the edit distance.
        Understanding the algorithm isn't important here, but you should
        pay attention to the structure of the recursive calls.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">edit_distance</span> <span class="n">s</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span><span class="o">,</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">t</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="o">(</span><span class="n">len_s</span><span class="o">,</span><span class="n">len_t</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">s'</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">drop_suffix</span> <span class="n">s</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">t'</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">drop_suffix</span> <span class="n">t</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">cost_to_drop_both</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.[</span><span class="n">len_s</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.[</span><span class="n">len_t</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
      <span class="k">in</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">reduce_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">min</span>
        <span class="o">[</span> <span class="n">edit_distance</span> <span class="n">s'</span> <span class="n">t</span>  <span class="o">+</span> <span class="mi">1</span>
        <span class="o">;</span> <span class="n">edit_distance</span> <span class="n">s</span>  <span class="n">t'</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="o">;</span> <span class="n">edit_distance</span> <span class="n">s'</span> <span class="n">t'</span> <span class="o">+</span> <span class="n">cost_to_drop_both</span>
        <span class="o">]</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">edit_distance</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;ocaml&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8794720">
        The thing to note is that if you call
        <code>edit_distance &quot;OCaml&quot; &quot;ocaml&quot;</code>,
        then that will in turn dispatch the following calls:
      </p><div class="highlight"><pre><span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocaml&quot;</span>
<span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;ocam&quot;</span>
<span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocam&quot;</span>
</pre></div><p id="idp8796784">
        And these calls will in turn dispatch other calls:
      </p><div class="highlight"><pre><span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocaml&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCa&quot;</span> <span class="s2">&quot;ocaml&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCa&quot;</span> <span class="s2">&quot;ocam&quot;</span>
<span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;oca&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;oca&quot;</span>
<span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCa&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;oca&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCa&quot;</span> <span class="s2">&quot;oca&quot;</span>
</pre></div><p id="idp8798640">
        As you can see, some of these calls are repeats. For example,
        there are two different calls to
        <code>edit_distance &quot;OCam&quot; &quot;oca&quot;</code>.
        The number of redundant calls grows exponentially with the size
        of the strings, meaning that our implementation of
        <code>edit_distance</code> is brutally slow for large
        strings. We can see this by writing a small timing function.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">time</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="n">now</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">stop</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="n">now</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="n">printf</span> <span class="s2">&quot;Time: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">to_string</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="n">diff</span> <span class="n">stop</span> <span class="n">start</span><span class="o">));</span>
    <span class="n">x</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">time</span> <span class="o">:</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8801792">
        And now we can use this to try out some examples.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;ocaml&quot;</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">5</span><span class="o">.</span><span class="mi">11003</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">edit_distance</span> <span class="s2">&quot;OCaml 4.01&quot;</span> <span class="s2">&quot;ocaml 4.01&quot;</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">19</span><span class="o">.</span><span class="mi">3322</span><span class="n">s</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8803408">
        Just those few extra characters made it almost four thousand
        times slower!
      </p><p id="idp8803904">
        Memoization would be a huge help here, but to fix the problem,
        we need to memoize the calls that
        <code>edit_distance</code> makes to itself. This technique
        is sometimes referred to as <span><em>dynamic
        programming</em></span>. To see how to do this, let's step away
        from <code>edit_distance</code>, and instead consider a
        much simpler example: computing the nth element of the Fibonacci
        sequence. The Fibonacci sequence by definition starts out with
        two <code>1</code>'s, with every subsequent element being
        the sum of the previous two. The classic recursive definition of
        Fibonacci is as follows:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);;</span>
</pre></div><p id="idp8808224">
        This is, however, exponentially slow, for the same reason that
        <code>edit_distance</code> was slow: we end up making many
        redundant calls to <code>fib</code>. It shows up quite
        dramatically in the performance.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">20</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">5</span><span class="o">.</span><span class="mi">17392</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10946</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">40</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">51</span><span class="o">.</span><span class="mi">4205</span><span class="n">s</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">165580141</span>
</pre></div><p id="idp8811184">
        Here, <code>fib 40</code> takes almost a minute to
        compute, as opposed to five <span><em>milliseconds</em></span>
        for <code>fib 20</code>.
      </p><p id="idp8813440">
        So, how can we use memoization to make this faster? The tricky
        bit is that we need to insert the memoization before the
        recursive calls within <code>fib</code>. We can't just
        define <code>fib</code> in the ordinary way and memoize it
        after the fact and expect the first call to
        <code>fib</code> to be improved (though of course repeated
        calls will be improved).
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">memoize</span> <span class="n">fib</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">40</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">52</span><span class="o">.</span><span class="mi">6</span><span class="n">s</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">165580141</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">40</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">0</span><span class="o">.</span><span class="mi">00596046</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">165580141</span>
</pre></div><p id="idp8817472">
        In order to make <code>fib</code> fast, our first step
        will be to rewrite <code>fib</code> in a way that unwinds
        the recursion. The following version expects as its first
        argument a function (called <code>fib</code>) that will be
        called in lieu of the usual recursive call.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fib_norec</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">i</span>
    <span class="k">else</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">fib_norec</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8821344">
        We can now turn this back into an ordinary Fibonacci function by
        tying the recursive knot, as shown below.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">=</span> <span class="n">fib_norec</span> <span class="n">fib</span> <span class="n">i</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">fib</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div><p id="idp8822912">
        We can even write a polymorphic function that we'll call
        <code>make_rec</code> that can tie the recursive not for
        any function of this form.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">make_rec</span> <span class="n">f_norec</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f_norec</span> <span class="n">f</span> <span class="n">x</span> <span class="k">in</span>
    <span class="n">f</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">make_rec</span> <span class="o">:</span> <span class="o">((</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">make_rec</span> <span class="n">fib_norec</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">fib</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div><p id="idp8825504">
        This is a pretty strange piece of code, and it may take a few
        minutes of thought to figure out what's going on. Like
        <code>fib_norec</code>, the function
        <code>f_norec</code> passed into
        <code>make_rec</code> is a function that isn't recursive,
        but takes as an argument a function that it will call. What
        <code>make_rec</code> does is to essentially feed
        <code>f_norec</code> to itself, thus making it a true
        recursive function.
      </p><p id="idp8829808">
        This is clever enough, but all we've really done is find a new
        way to implement the same old slow Fibonacci function. To make
        it faster, we need variant on <code>make_rec</code> that
        inserts memoization when it ties the recursive knot. We'll call
        that function <code>memo_rec</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">memo_rec</span> <span class="n">f_norec</span> <span class="n">x</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">fref</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span><span class="o">)</span> <span class="k">in</span>
     <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">memoize</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f_norec</span> <span class="o">!</span><span class="n">fref</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
     <span class="n">fref</span> <span class="o">:=</span> <span class="n">f</span><span class="o">;</span>
     <span class="n">f</span> <span class="n">x</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">memo_rec</span> <span class="o">:</span> <span class="o">((</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8833216">
        Note that <code>memo_rec</code> has the same signature as
        <code>make_rec</code>.
      </p><p id="idp8835088">
        We're using the reference here as a way of tying the recursive
        knot without using a <code>let rec</code>, which for
        reasons we'll describe later wouldn't work here.
      </p><p id="idp8836368">
        Using <code>memo_rec</code>, we can now build an efficient
        version of <code>fib</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">memo_rec</span> <span class="n">fib_norec</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">40</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">0</span><span class="o">.</span><span class="mi">236034</span><span class="n">ms</span>
</pre></div><p id="idp8839360">
        And as you can see, the exponential time complexity is now gone.
      </p><p id="idp8839840">
        The memory behavior here is important. If you look back at the
        definition of <code>memo_rec</code>, you'll see that the
        call to memo_rec does not trigger a call to
        <code>memoize</code>. Only when the final argument to
        <code>fib</code> is presented does
        <code>memoize</code> get called, and the result of that
        call falls out of scope when the <code>fib</code> call
        returns. That means that, unlike ordinary memoization, calling
        <code>memo_rec</code> on a function does not create a
        memory leak --- the memoization table is collected after the
        computation completes.
      </p><p id="idp8844896">
        We can use <code>memo_rec</code> as part of a single
        declaration that makes this look like it's little more than a
        special form of <code>let rec</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">memo_rec</span> <span class="o">(</span><span class="k">fun</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8848048">
        Memoization is overkill for implementing Fibonacci, and indeed,
        the <code>fib</code> defined above is not especially
        efficient, allocating space linear in the number passed in to
        <code>fib</code>. It's easy enough to write a Fibonacci
        function that takes a constant amount of space.
      </p><p id="idp8850080">
        But memoization is a good approach for optimizing
        <code>edit_distance</code>, and we can apply the same
        approach we used on <code>fib</code> here. We will need to
        change <code>edit_distance</code> to take a pair of
        strings as a single argument, since <code>memo_rec</code>
        only works on single-argument functions. (We can always recover
        the original interface with a wrapper function.) With just that
        change and the addition of the <code>memo_rec</code> call,
        we can get a memoized version of
        <code>edit_distance</code>:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">edit_distance</span> <span class="o">=</span> <span class="n">memo_rec</span> <span class="o">(</span><span class="k">fun</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span><span class="o">,</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">t</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="o">(</span><span class="n">len_s</span><span class="o">,</span><span class="n">len_t</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">s'</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">drop_suffix</span> <span class="n">s</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">t'</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">drop_suffix</span> <span class="n">t</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">cost_to_drop_both</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.[</span><span class="n">len_s</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.[</span><span class="n">len_t</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
      <span class="k">in</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">reduce_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">min</span>
        <span class="o">[</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="n">s'</span><span class="o">,</span><span class="n">t</span> <span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="o">;</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="n">s</span> <span class="o">,</span><span class="n">t'</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="o">;</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="n">s'</span><span class="o">,</span><span class="n">t'</span><span class="o">)</span> <span class="o">+</span> <span class="n">cost_to_drop_both</span>
        <span class="o">])</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">edit_distance</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8857648">
        This new version of <code>edit_distance</code> is much
        more efficient than the one we started with; the following call
        is about ten thousand times faster than it was without
        memoization.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="s2">&quot;OCaml 4.01&quot;</span><span class="o">,</span><span class="s2">&quot;ocaml 4.01&quot;</span><span class="o">));;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">2</span><span class="o">.</span><span class="mi">14601</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><aside class="note"><h1> 
      Limitations of let rec
</h1><p id="idp8861360">
        You might wonder why we didn't tie the recursive knot in
        <code>memo_rec</code> using <code>let rec</code>, as
        we did for <code>make_rec</code> earlier. Here's code that
        tries to do just that:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">memo_rec</span> <span class="n">f_norec</span> <span class="o">=</span>
     <span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="o">=</span> <span class="n">memoize</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f_norec</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
     <span class="n">f</span>
  <span class="o">;;</span>
      <span class="nc">Characters</span> <span class="mi">41</span><span class="o">-</span><span class="mi">72</span><span class="o">:</span>
       <span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="o">=</span> <span class="n">memoize</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f_norec</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
                   <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">kind</span> <span class="k">of</span> <span class="n">expression</span> <span class="n">is</span> <span class="n">not</span> <span class="n">allowed</span> <span class="k">as</span> <span class="n">right</span><span class="o">-</span><span class="n">hand</span> <span class="n">side</span> <span class="k">of</span> <span class="o">`</span><span class="k">let</span> <span class="k">rec'</span>
</pre></div><p id="idp8865424">
        OCaml rejects the definition because OCaml, as a strict
        language, has limits on what it can put on the right hand side
        of a <code>let rec</code>. In particular, imagine how the
        following code snippet would be compiled.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div><p id="idp8867728">
        Note that <code>x</code> is an ordinary value, not a
        function. As such, it's not clear how to execute this code. In
        some sense, you could imagine it compiling down to an infinite
        loop, but there's no looping control structure to make that
        happen.
      </p><p id="idp8869072">
        To avoid such cases, the compiler only allows three possible
        constructs to show up on the right-hand side of a
        <code>let rec</code>: a function definition, a
        constructor, or the lazy keyword. This excludes some reasonable
        things, like our definition of <code>memo_rec</code>, but
        it also blocks things that don't make sense, like our definition
        of <code>x</code>.
      </p><p id="idp8871952">
        It's worth noting that these restrictions don't show up in a
        lazy language like Haskell. Indeed, we can make something like
        our definition of <code>x</code> work if we use OCaml's
        laziness:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">x</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">lazy_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">lazy</span><span class="o">&gt;</span>
</pre></div><p id="idp8874240">
        Of course, actually trying to compute this will fail. OCaml's
        <code>lazy</code> throws an exception when a lazy value
        tries to force itself as part of its own evaluation.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">x</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nn">Lazy</span><span class="p">.</span><span class="nn">Undefined</span><span class="p">.</span>
</pre></div><p id="idp8876528">
        But we can also create useful recursive definitions with
        <code>lazy</code>. In particular, we can use laziness to
        make our definition of <code>memo_rec</code> work without
        explicit mutation.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">lazy_memo_rec</span> <span class="n">f_norec</span> <span class="n">x</span> <span class="o">=</span>
     <span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">memoize</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f_norec</span> <span class="o">(</span><span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span><span class="o">))</span> <span class="k">in</span>
     <span class="o">(</span><span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">lazy_memo_rec</span> <span class="o">:</span> <span class="o">((</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">lazy_memo_rec</span> <span class="n">fib_norec</span> <span class="mi">40</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">0</span><span class="o">.</span><span class="mi">298977</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">102334155</span>
</pre></div><p id="idp8879936">
        Laziness is more constrained than explicit mutation, and so in
        some cases can lead to code whose behavior is easier to think
        about.
      </p></aside></section></section><section><h1 id="input-and-output">Input and Output</h1><p id="idp8881920">
      Imperative programming is about more than modifying in-memory
      data-structures. Any function that doesn't boil down to a
      deterministic transformation from its arguments to its return
      value is imperative in nature. That includes not only things that
      mutate your program's data, but also operations that interact with
      the world outside of your program. An important example of this
      kind of interaction is I/O, <span><em>i.e.</em></span>, operations
      for reading or writing data to things like files, terminal input
      and output, and network sockets.
    </p><p id="idp8883328">
      There are multiple I/O libraries in OCaml. In this section we'll
      discuss OCaml's buffered I/O library that can be used through the
      <code>In_channel</code> and <code>Out_channel</code>
      modules in Core. Other I/O primitives are also available through
      the <code>Unix</code> module in Core as well as
      <code>Async</code>, the asynchronous I/O library that is
      covered in
      <a href="concurrent-programming-with-async.html">Chapter 18, <i>Concurrent Programming with Async</i></a>.
      Most of the functionality in Core's <code>In_channel</code>,
      <code>Out_channel</code> (and in Core's
      <code>Unix</code> module) derives from the standard library,
      but we'll use Core's interfaces here.
    </p><section><h1 id="terminal-io">Terminal I/O</h1><p id="idp8891008">
        OCaml's buffered I/O library is organized around two types:
        <code>in_channel</code>, for channels you read from, and
        <code>out_channel</code>, for channels you write to.
        <code>In_channel</code> and <code>Out_channel</code>
        modules only have direct support for channels corresponding to
        files and terminals; other kinds of channels can be created
        through the <code>Unix</code> module.
      </p><p id="idp8895280">
        We'll start our discussion of I/O by focusing on the terminal.
        Following the UNIX model, communication with the terminal is
        organized around three channels, which correspond to the three
        standard file descriptors in Unix:
      </p><ul><li><p id="idp8896448">
<code>In_channel.stdin</code>. The &quot;standard
            input&quot; channel. By default, input comes from the
            terminal, which handles keyboard input.
          </p></li><li><p id="idp8898304">
<code>Out_channel.stdout</code>. The &quot;standard
            output&quot; channel. By default, output written to
            <code>stdout</code> appears on the user terminal.
          </p></li><li><p id="idp8900800">
<code>Out_channel.stderr</code>. The &quot;standard
            error&quot; channel. This is similar to
            <code>stdout</code>, but is intended for error
            messages.
          </p></li></ul><p id="idp8902992">
        The values <code>stdin</code>, <code>stdout</code>
        and <code>stderr</code> are useful enough that they are
        also available in the global name-space directly, without having
        to go through the <code>In_channel</code> and
        <code>Out_channel</code> modules.
      </p><p id="idp8907088">
        Let's see this in action in a simple interactive application.
        The following program, <code>time_converter</code>,
        prompts the user for a timezone, and then prints out the current
        time in that timezone. Here, we use Core's
        <code>Zone</code> module for looking up a timezone, and
        the <code>Time</code> module for computing the current
        time and printing it out in the timezone in question.
      </p><div class="highlight"><pre><span class="c">(* file: time_converter.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Out_channel</span><span class="p">.</span><span class="n">output_string</span> <span class="n">stdout</span> <span class="s2">&quot;Pick a timezone: &quot;</span><span class="o">;</span>
  <span class="nn">Out_channel</span><span class="p">.</span><span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
  <span class="k">match</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">input_line</span> <span class="n">stdin</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;No timezone provided&quot;</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">zone_string</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">zone</span> <span class="o">=</span> <span class="nn">Zone</span><span class="p">.</span><span class="n">find_exn</span> <span class="n">zone_string</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">time_string</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="n">to_localized_string</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="n">now</span> <span class="bp">()</span><span class="o">)</span> <span class="n">zone</span> <span class="k">in</span>
    <span class="nn">Out_channel</span><span class="p">.</span><span class="n">output_string</span> <span class="n">stdout</span>
      <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span>
         <span class="o">[</span><span class="s2">&quot;The time in &quot;</span><span class="o">;</span><span class="nn">Zone</span><span class="p">.</span><span class="n">to_string</span> <span class="n">zone</span><span class="o">;</span><span class="s2">&quot; is &quot;</span><span class="o">;</span> <span class="n">time_string</span><span class="o">;</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">]);</span>
    <span class="nn">Out_channel</span><span class="p">.</span><span class="n">flush</span> <span class="n">stdout</span>
</pre></div><p id="idp8911440">
        We can build this program (using <code>ocamlbuild</code>
        with the <code>_tags</code> file described in
        <a href="files-modules-and-programs.html#single-file-programs">the section called “Single File Programs”</a>) and run it,
        you'll see that it prompts you for input, as follows:
      </p><pre id="idp8914176">
$ ./time_converter.byte
Pick a timezone:
</pre><p id="idp8914864">
        You can then type in the name of a timezone and hit return, and
        it will print out the current time in the timezone in question.
      </p><pre id="idp8915408">
Pick a timezone: Europe/London
The time in Europe/London is 2013-03-06 02:15:13.602033
</pre><p id="idp8916176">
        We called <code>Out_channel.flush</code> on
        <code>stdout</code> because
        <code>out_channel</code>s are buffered, which is to say
        that OCaml doesn't immediately do a write every time you call
        <code>output_string</code>. Instead, writes are buffered
        until either enough has been written to trigger the flushing of
        the buffers, or until a flush is explicitly requested. This
        greatly increases the efficiency of the writing process, by
        reducing the number of system calls.
      </p><p id="idp8919840">
        Note that <code>In_channel.input_line</code> returns a
        <code>string option</code>, with <code>None</code>
        indicating that the input stream has ended
        (<span><em>i.e.</em></span>, an end-of-file condition).
        <code>Out_channel.output_string</code> is used to print
        the final output, and <code>Out_channel.flush</code> is
        called to flush that output to the screen. The final flush is
        not technically required, since the program ends after that
        instruction, at which point all remaining output will be flushed
        anyway, but the flush is nonetheless good practice.
      </p></section><section><h1 id="formatted-output-with-printf">Formatted output with <code>printf</code></h1><p id="idp8926544">
        Generating output with functions like
        <code>Out_channel.output_string</code> is simple and easy
        to understand, but can be a bit verbose. OCaml also supports
        formatted output using the <code>printf</code> function,
        which is modeled after <code>printf</code> in the C
        standard library. <code>printf</code> takes a
        <span><em>format string</em></span> that describe what to print
        and how to format it, as well as arguments to be printed, as
        determined by the formatting directives embedded in the format
        string. So, for example, we can write:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">printf</span> <span class="s2">&quot;%i is an integer, %F is a float, </span><span class="se">\&quot;</span><span class="s2">%s</span><span class="se">\&quot;</span><span class="s2"> is a string</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="mi">3</span> <span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="s2">&quot;five&quot;</span><span class="o">;;</span>
<span class="mi">3</span> <span class="n">is</span> <span class="n">an</span> <span class="n">integer</span><span class="o">,</span> <span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="n">is</span> <span class="n">a</span> <span class="kt">float</span><span class="o">,</span> <span class="s2">&quot;five&quot;</span> <span class="n">is</span> <span class="n">a</span> <span class="kt">string</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8931904">
        Importantly, and unlike C's <code>printf</code>, the
        <code>printf</code> in OCaml is type-safe. In particular,
        if we provide an argument whose type doesn't match what's
        presented in the format string, we'll get a type error.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">printf</span> <span class="s2">&quot;An integer: %i</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="mi">4</span><span class="o">.</span><span class="mi">5</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">26</span><span class="o">-</span><span class="mi">29</span><span class="o">:</span>
  <span class="n">printf</span> <span class="s2">&quot;An integer: %i</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="mi">4</span><span class="o">.</span><span class="mi">5</span><span class="o">;;</span>
                            <span class="o">^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">float</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="kt">int</span>
</pre></div><aside class="note"><h1> 
      Understanding format strings
      </h1><p id="idp8936160">
        The format strings used by <code>printf</code> turn out to
        be quite different from ordinary strings. This difference ties
        to the fact that OCaml format strings, unlike their equivalent
        in C, are type-safe. In particular, the compiler checks that the
        types referred to by the format string match the types of the
        rest of the arguments passed to <code>printf</code>.
      </p><p id="idp8938352">
        To check this, OCaml needs to analyze the contents of the format
        string at compile time, which means the format string needs to
        be available as a string literal at compile time. Indeed, if you
        try to pass an ordinary string to <code>printf</code>, the
        compiler will complain.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;%i is an integer, %F is a float, </span><span class="se">\&quot;</span><span class="s2">%s</span><span class="se">\&quot;</span><span class="s2"> is a string</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fmt</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;%i is an integer, %F is a float, </span><span class="se">\&quot;</span><span class="s2">%s</span><span class="se">\&quot;</span><span class="s2"> is a string</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="o">#</span> <span class="n">printf</span> <span class="n">fmt</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="s2">&quot;five&quot;</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">7</span><span class="o">-</span><span class="mi">10</span><span class="o">:</span>
  <span class="n">printf</span> <span class="n">fmt</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="s2">&quot;five&quot;</span><span class="o">;;</span>
         <span class="o">^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">string</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">d</span><span class="o">,</span> <span class="n">out_channel</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">format</span> <span class="o">=</span>
           <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">d</span><span class="o">,</span> <span class="n">out_channel</span><span class="o">,</span> <span class="kt">unit</span><span class="o">,</span> <span class="kt">unit</span><span class="o">,</span> <span class="kt">unit</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span>
           <span class="n">format6</span>
</pre></div><p id="idp8941440">
        If OCaml infers that a given string literal is a format string,
        then it parses it at compile time as such, choosing its type in
        accordance with the formatting directives it finds. Thus, if we
        add a type-annotation indicating that the string we're defining
        is actually a format string, it will be interpreted as such:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fmt</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">,</span> <span class="k">'</span><span class="n">c</span><span class="o">)</span> <span class="n">format</span> <span class="o">=</span>
    <span class="s2">&quot;%i is an integer, %F is a float, </span><span class="se">\&quot;</span><span class="s2">%s</span><span class="se">\&quot;</span><span class="s2"> is a string</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
  <span class="k">val</span> <span class="n">fmt</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">,</span> <span class="k">'</span><span class="n">c</span><span class="o">)</span> <span class="n">format</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp8943344">
        And accordingly, we can pass it to <code>printf</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">printf</span> <span class="n">fmt</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="s2">&quot;five&quot;</span><span class="o">;;</span>
<span class="mi">3</span> <span class="n">is</span> <span class="n">an</span> <span class="n">integer</span><span class="o">,</span> <span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="n">is</span> <span class="n">a</span> <span class="kt">float</span><span class="o">,</span> <span class="s2">&quot;five&quot;</span> <span class="n">is</span> <span class="n">a</span> <span class="kt">string</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8945616">
        If this looks different from everything else you've seen so far,
        that's because it is. This is really a special case in the
        type-system. Most of the time, you don't need to worry about
        this special handling of format strings --- you can just use
        <code>printf</code> and not worry about the details. But
        it's useful to keep the broad outlines of the story in the back
        of your head.
      </p></aside><p id="idp8947280">
        Now let's see how we can rewrite our time conversion program to
        be a little more concise using <code>printf</code>.
      </p><div class="highlight"><pre><span class="c">(* file: time_converter.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">printf</span> <span class="s2">&quot;Pick a timezone: %!&quot;</span><span class="o">;</span>
  <span class="k">match</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">input_line</span> <span class="n">stdin</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;No timezone provided&quot;</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">zone_string</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">zone</span> <span class="o">=</span> <span class="nn">Zone</span><span class="p">.</span><span class="n">find_exn</span> <span class="n">zone_string</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">time_string</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="n">to_localized_string</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="n">now</span> <span class="bp">()</span><span class="o">)</span> <span class="n">zone</span> <span class="k">in</span>
    <span class="n">printf</span> <span class="s2">&quot;The time in %s is %s.</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="o">(</span><span class="nn">Zone</span><span class="p">.</span><span class="n">to_string</span> <span class="n">zone</span><span class="o">)</span> <span class="n">time_string</span>
</pre></div><p id="idp8950272">
        In the above example, we've used only two formatting directives:
        <code>%s</code>, for including a string, and
        <code>%!</code> which causes <code>printf</code> to
        flush the channel.
      </p><p id="idp8952928">
<code>printf</code>'s formatting directives offer a
        significant amount of control, allowing you to specify things
        like:
      </p><ul><li><p id="idp8954656">
            alignment and padding
          </p></li><li><p id="idp8955488">
            escaping rules for strings
          </p></li><li><p id="idp8956320">
            whether numbers should be formatted in decimal, hex or
            binary
          </p></li><li><p id="idp8957200">
            precision of float conversions
          </p></li></ul><p id="idp8957904">
        There are also <code>printf</code>-style functions that
        target outputs other than <code>stdout</code>, including:
      </p><ul><li><p id="idp8960336">
<code>eprintf</code>, which prints to
            <code>stderr</code>.
          </p></li><li><p id="idp8962560">
<code>fprintf</code>, which prints to an arbitrary
            <code>out_channel</code>
</p></li><li><p id="idp8964768">
<code>sprintf</code>, which returns a formatted string
          </p></li></ul><p id="idp8966160">
        All of this, and a good deal more, is described in the API
        documentation for the <code>Printf</code> module in the
        OCaml Manual.
      </p></section><section><h1 id="file-io">File I/O</h1><p id="idp8968576">
        Another common use of <code>in_channel</code>s and
        <code>out_channel</code>s is for working with files.
        Here's a couple of functions, one that creates a file full of
        numbers, and the other that reads in such a file and returns the
        sum of those numbers.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">create_number_file</span> <span class="n">filename</span> <span class="n">numbers</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">outc</span> <span class="o">=</span> <span class="nn">Out_channel</span><span class="p">.</span><span class="n">create</span> <span class="n">filename</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">numbers</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">fprintf</span> <span class="n">outc</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">x</span><span class="o">);</span>
    <span class="nn">Out_channel</span><span class="p">.</span><span class="n">close</span> <span class="n">outc</span>
  <span class="o">;;</span>
 <span class="k">val</span> <span class="n">create_number_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">List</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">sum_file</span> <span class="n">filename</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">create</span> <span class="n">filename</span> <span class="k">in</span>
     <span class="k">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">of_string</span> <span class="o">(</span><span class="nn">In_channel</span><span class="p">.</span><span class="n">input_lines</span> <span class="n">file</span><span class="o">)</span> <span class="k">in</span>
     <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:(+)</span> <span class="n">numbers</span> <span class="k">in</span>
     <span class="nn">In_channel</span><span class="p">.</span><span class="n">close</span> <span class="n">file</span><span class="o">;</span>
     <span class="n">sum</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sum_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">create_number_file</span> <span class="s2">&quot;numbers.txt&quot;</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">sum_file</span> <span class="s2">&quot;numbers.txt&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div><p id="idp8973136">
        For both of these functions we followed the same basic sequence:
        we first create the channel, then use the channel, and finally
        close the channel. The closing of the channel is important,
        since without it, we won't release resources associated with the
        file back to the operating system.
      </p><p id="idp8973872">
        One problem with the code above is that if it throws an
        exception in the middle of its work, it won't actually close the
        file. If we try to read a file that doesn't actually contain
        numbers, we'll see such an error:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">sum_file</span> <span class="s2">&quot;/etc/hosts&quot;</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="o">(</span><span class="nc">Failure</span> <span class="s2">&quot;Int.of_string: </span><span class="se">\&quot;</span><span class="s2">##</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">).</span>
</pre></div><p id="idp8975568">
        And if we do this over and over in a loop, we'll eventually run
        out of file descriptors.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="mi">10000</span> <span class="k">do</span> <span class="k">try</span> <span class="n">ignore</span> <span class="o">(</span><span class="n">sum_file</span> <span class="s2">&quot;/etc/hosts&quot;</span><span class="o">)</span> <span class="k">with</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span> <span class="k">done</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">sum_file</span> <span class="s2">&quot;numbers.txt&quot;</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="o">(</span><span class="nc">Sys_error</span> <span class="s2">&quot;numbers.txt: Too many open files&quot;</span><span class="o">).</span>
</pre></div><p id="idp8977280">
        And now, you'll need to restart your toplevel if you want to
        open any more files!
      </p><p id="idp8977792">
        To avoid this, we need to make sure that our code cleans up
        after itself. We can do this using the
        <code>protect</code> function described in
        <a href="error-handling.html">Chapter 7, <i>Error Handling</i></a>, as follows.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">sum_file</span> <span class="n">filename</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">create</span> <span class="n">filename</span> <span class="k">in</span>
     <span class="n">protect</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
         <span class="k">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">of_string</span> <span class="o">(</span><span class="nn">In_channel</span><span class="p">.</span><span class="n">input_lines</span> <span class="n">file</span><span class="o">)</span> <span class="k">in</span>
         <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:(+)</span> <span class="n">numbers</span><span class="o">)</span>
       <span class="o">~</span><span class="n">finally</span><span class="o">:(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">close</span> <span class="n">file</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sum_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8981376">
        And now, the file descriptor leak is gone:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="mi">10000</span> <span class="k">do</span> <span class="k">try</span> <span class="n">ignore</span> <span class="o">(</span><span class="n">sum_file</span> <span class="s2">&quot;/etc/hosts&quot;</span><span class="o">)</span> <span class="k">with</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span> <span class="k">done</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">sum_file</span> <span class="s2">&quot;numbers.txt&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div><p id="idp8983040">
        This is really an example of a more general complexity of
        imperative programming. When programming imperatively, you need
        to be quite careful to make sure that exceptions don't leave you
        in an awkward state.
      </p><p id="idp8983680">
<code>In_channel</code> also supports some idioms that
        handle some of the details of this for you. For example, the
        <code>with_file</code> function takes a filename and a
        function for processing that file, and takes care of the opening
        and closing of the file transparently.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">sum_file</span> <span class="n">filename</span> <span class="o">=</span>
     <span class="nn">In_channel</span><span class="p">.</span><span class="n">with_file</span> <span class="n">filename</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">file</span> <span class="o">-&gt;</span>
       <span class="k">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">of_string</span> <span class="o">(</span><span class="nn">In_channel</span><span class="p">.</span><span class="n">input_lines</span> <span class="n">file</span><span class="o">)</span> <span class="k">in</span>
       <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:(+)</span> <span class="n">numbers</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sum_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8987296">
        Another misfeature of our implementation of
        <code>sum_file</code> is that we read the entire file into
        memory before processing it. For a large file, it's more
        efficient to process a line at a time. You can use the
        <code>In_channel.fold_lines</code> function to do just
        that.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">sum_file</span> <span class="n">filename</span> <span class="o">=</span>
     <span class="nn">In_channel</span><span class="p">.</span><span class="n">with_file</span> <span class="n">filename</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">file</span> <span class="o">-&gt;</span>
       <span class="nn">In_channel</span><span class="p">.</span><span class="n">fold_lines</span> <span class="n">file</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">sum</span> <span class="n">line</span> <span class="o">-&gt;</span>
         <span class="n">sum</span> <span class="o">+</span> <span class="nn">Int</span><span class="p">.</span><span class="n">of_string</span> <span class="n">line</span><span class="o">))</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sum_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8990784">
        This is just a taste of the functionality of
        <code>In_channel</code> and
        <code>Out_channel</code>. To get a fuller understanding
        you should review the API documentation for those modules.
      </p></section></section><section><h1 id="order-of-evaluation">Order of evaluation</h1><p id="idp8994144">
      The order in which expressions are evaluated is an important part
      of the definition of a programming language, and it is
      particularly important when programming imperatively. Most
      programming languages you're likely to have encountered are
      <span><em>strict</em></span>, and OCaml is too. In a strict
      language, when you bind an identifier to the result of some
      expression, the expression is evaluated before the variable is
      defined. Similarly, if you call a function on a set of arguments,
      those arguments are evaluated before they are passed to the
      function.
    </p><p id="idp8995568">
      Consider the following simple example. Here, we have a collection
      of angles and we want to determine if any of them have a negative
      `sin. The following snippet of code would answer that question.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span> <span class="mi">120</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span> <span class="mi">75</span><span class="o">.</span>  <span class="k">in</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sin</span> <span class="mi">128</span><span class="o">.</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.)</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">;</span><span class="n">z</span><span class="o">]</span>
  <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div><p id="idp8997328">
      In some sense, we don't really need to compute the
      <code>sin 128</code>, because <code>sin 75.</code> is
      negative, so we could know the answer before even computing
      <code>sin 128</code>.
    </p><p id="idp9000016">
      It doesn't have to be this way. Using the <code>lazy</code>
      keyword, we can write the original computation so that
      <code>sin 128.</code> won't ever be computed.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">sin</span> <span class="mi">120</span><span class="o">.)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">sin</span> <span class="mi">75</span><span class="o">.)</span>  <span class="k">in</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">sin</span> <span class="mi">128</span><span class="o">.)</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.)</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">;</span><span class="n">z</span><span class="o">]</span>
  <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div><p id="idp9003136">
      We can confirm that fact by a few well placed
      <code>printf</code>s.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">printf</span> <span class="s2">&quot;1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sin</span> <span class="mi">120</span><span class="o">.)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">printf</span> <span class="s2">&quot;2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sin</span> <span class="mi">75</span><span class="o">.)</span>  <span class="k">in</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">printf</span> <span class="s2">&quot;3</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sin</span> <span class="mi">128</span><span class="o">.)</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.)</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">;</span><span class="n">z</span><span class="o">]</span>
  <span class="o">;;</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div><p id="idp9005696">
      OCaml is strict by default for a good reason: Lazy evaluation and
      imperative programming generally don't mix well, because laziness
      makes it harder to reason about when a given side effect is going
      to occur. Understanding the order of side-effects is essential to
      reasoning about the behavior of an imperative program.
    </p><p id="idp9006448">
      In a strict language, we know that expressions that are bound by a
      sequence of let-bindings will be evaluated in the order that
      they're defined. But what about the evaluation order within a
      single expression? Officially, the answer is that evaluation order
      within an expression is undefined. In practice, OCaml has only one
      compiler, and that behavior is a kind of <span><em>de
      facto</em></span> standard. Unfortunately, the evaluation order in
      this case is often the oppose of what one might expect.
    </p><p id="idp9007792">
      Consider the following example.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.)</span>
    <span class="o">[</span> <span class="o">(</span><span class="n">printf</span> <span class="s2">&quot;1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sin</span> <span class="mi">120</span><span class="o">.);</span>
      <span class="o">(</span><span class="n">printf</span> <span class="s2">&quot;2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sin</span> <span class="mi">75</span><span class="o">.);</span>
      <span class="o">(</span><span class="n">printf</span> <span class="s2">&quot;3</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sin</span> <span class="mi">128</span><span class="o">.);</span> <span class="o">]</span>
  <span class="o">;;</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div><p id="idp9009344">
      Here, you can see that the sub-expression that came last was
      actually evaluated first! This is generally the case for many
      different kinds of expressions. If you want to make sure of the
      evaluation order of different sub-expressions, you should express
      them as a series of <code>let</code> bindings.
    </p></section><section><h1 id="side-effects-and-weak-polymorphism">Side-effects and weak polymorphism</h1><p id="idp9012000">
      Consider the following simple imperative function.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">remember</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span> <span class="k">in</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span>
       <span class="k">match</span> <span class="o">!</span><span class="n">cache</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">y</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">cache</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">x</span><span class="o">;</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">;;</span>
</pre></div><p id="idp9013680">
<code>remember</code> simply caches the first value that's
      passed to it, returning that value on every call. Note that we've
      carefully written <code>remember</code> so that
      <code>cache</code> is created and initialized once, and is
      shared across invocations of <code>remember</code>.
    </p><p id="idp9017120">
<code>remember</code> is not a terribly useful function, but
      it raises an interesting question: what type should it have?
    </p><p id="idp9018320">
      On its first call, <code>remember</code> returns the same
      value its passed, which means its input type and return type
      should match. Accordingly, <code>remember</code> should have
      the type <code>t -&gt; t</code> for some type
      <code>t</code>. There's nothing about
      <code>remember</code> that ties the choice of
      <code>t</code> to any particular type, so you might expect
      OCaml to generalize, replacing <code>t</code> with a
      polymorphic type variable. It's this kind of generalization that
      gives us polymorphic types in the first place. The identity
      function, as an example, gets a polymorphic type in this way.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">identity</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">identity</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">identity</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">#</span> <span class="n">identity</span> <span class="s2">&quot;five&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;five&quot;</span>
</pre></div><p id="idp9025312">
      As you can see, the polymorphic type of
      <code>identity</code> lets it operate on values with
      different types.
    </p><p id="idp9026528">
      This is not what happens with <code>remember</code>, though.
      Here's the type that OCaml infers for remember, which looks
      almost, but not quite, like the type of the identity function.
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">remember</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9028800">
      The underscore in the type variable <code>'_a</code> tells
      us that the variable is only <span><em>weakly
      polymorphic</em></span>, which is to say that it can be used with
      any <span><em>single</em></span> type. That makes sense, because,
      unlike <code>identity</code>, <code>remember</code>
      always returns the value it was passed on its first invocation,
      which means it can only be used with one type.
    </p><p id="idp9032464">
      OCaml will convert a weakly polymorphic variable to a concrete
      type as soon as it gets a clue as to what concrete type it is to
      be used as, as you can see below.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">remember_three</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">remember</span> <span class="mi">3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">remember_three</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">remember</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">remember</span> <span class="s2">&quot;avocado&quot;</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">9</span><span class="o">-</span><span class="mi">18</span><span class="o">:</span>
  <span class="n">remember</span> <span class="s2">&quot;avocado&quot;</span><span class="o">;;</span>
           <span class="o">^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">string</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="kt">int</span>
</pre></div><p id="idp9034336">
      Note that the type of <code>remember</code> was settled by
      the definition of <code>remember_three</code>, even though
      <code>remember_three</code> was never called!
    </p><section><h1 id="the-value-restriction">The Value Restriction</h1><p id="idp9038112">
        So, when does the compiler infer weakly polymorphic types? As
        we've seen, we need weakly polymorphic types when a value of
        unknown type is stored in a persistent mutable cell. Because the
        type-system isn't precise enough to determine all cases where
        this might happen, OCaml uses a rough rule to flag cases where
        it's sure there are no persistent refs, and to only infer
        polymorphic types in those cases. This rule is called
        <span><em>the value restriction</em></span>.
      </p><p id="idp9039456">
        The core of the value restriction is the observation that some
        kinds of simple values by their nature can't contain refs,
        including:
      </p><ul><li><p id="idp9040528">
            Constants (<span><em>i.e.</em></span>, things like integer
            and floating point literals)
          </p></li><li><p id="idp9041856">
            Constructors that contain only other simple values
          </p></li><li><p id="idp9042720">
            Function declarations, <span><em>i.e.</em></span>,
            expressions that begin with <code>fun</code> or
            <code>function</code>, or, the equivalent let binding,
            <code>let f x = ...</code>.
          </p></li><li><p id="idp9046176">
<code>let</code> bindings of the form
            <code>let var = &lt;expr1&gt; in &lt;expr2&gt;</code>,
            where both <code>&lt;expr1&gt;</code> and
            <code>&lt;expr2&gt;</code> are simple values.
          </p></li></ul><p id="idp9049760">
        Thus, the following expression is a simple value, and as a
        result, the types of values contained within it are allowed to
        be polymorphic.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">x</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9051360">
        But, if we write down an expression that isn't a simple value by
        the above definition, we'll get different results. For example,
        consider what happens if we try to memoize the function defined
        above.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">memoize</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">x</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9053056">
        The memoized version of the function does in fact need to be
        restricted to a single type, because it uses mutable state
        behind the scenes to cache previous invocations of the function
        it has passed. But OCaml would make the same determination even
        if the function in question did no such thing. Consider this
        example:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">identity</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">x</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9054880">
        It would be safe to infer a weakly polymorphic variable here,
        but because OCaml's type system doesn't distinguish between pure
        and impure functions, it can't separate those two cases.
      </p><p id="idp9055488">
        The value restriction doesn't require that there is no mutable
        state, only that there is no <span><em>persistent</em></span>
        mutable state that could share values between uses of the same
        function. Thus, a function that produces a fresh reference every
        time it's called can have a fully polymorphic type:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">f</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9057664">
        But a function that has a mutable cache that persists across
        calls, like memoize, can only be weakly polymorphic.
      </p></section><section><h1 id="partial-application-and-the-value-restriction">Partial application and the value restriction</h1><p id="idp9059520">
        Most of the time, when the value restriction kicks in, it's for
        a good reason, <span><em>i.e.</em></span>, it's because the value
        in question can actually only safely be used with a single type.
        But sometimes, the value restriction kicks in when you don't
        want it. The most common such case is partially applied
        functions. A partially applied function, like any function
        application, is not a simple value, and as such, functions
        created by partial application are sometimes less general than
        you might expect.
      </p><p id="idp9060912">
        Consider the <code>List.init</code> function, which is
        used for creating lists where each element is created by calling
        a function on the index of that element.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">init</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">init</span> <span class="mi">10</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">to_string</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;0&quot;</span><span class="o">;</span> <span class="s2">&quot;1&quot;</span><span class="o">;</span> <span class="s2">&quot;2&quot;</span><span class="o">;</span> <span class="s2">&quot;3&quot;</span><span class="o">;</span> <span class="s2">&quot;4&quot;</span><span class="o">;</span> <span class="s2">&quot;5&quot;</span><span class="o">;</span> <span class="s2">&quot;6&quot;</span><span class="o">;</span> <span class="s2">&quot;7&quot;</span><span class="o">;</span> <span class="s2">&quot;8&quot;</span><span class="o">;</span> <span class="s2">&quot;9&quot;</span><span class="o">]</span>
</pre></div><p id="idp9063376">
        Imagine we wanted to create a specialized version of
        <code>List.init</code> that always created lists of length
        10. We could do that using partial application, as follows.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">list_init_10</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">init</span> <span class="mi">10</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">list_init_10</span> <span class="o">:</span> <span class="n">f</span><span class="o">:(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9065728">
        As you can see, we now infer a weakly polymorphic type for the
        resulting function, and for good reason. There's nothing that
        tells us that <code>List.init</code> isn't creating a
        persistent <code>ref</code> somewhere inside of it that
        would be shared across multiple calls to
        <code>list_init_10</code>. We can eliminate this
        possibility, and at the same time get the compiler to infer a
        polymorphic type, by using explicit variables rather than
        partial application.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">list_init_10</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">init</span> <span class="mi">10</span> <span class="o">~</span><span class="n">f</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">list_init_10</span> <span class="o">:</span> <span class="n">f</span><span class="o">:(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9069760">
        This transformation is referred to as <span><em>eta
        expansion</em></span>, and is often useful to resolve problems
        that arise from the value restriction.
      </p></section><section><h1 id="relaxing-the-value-restriction">Relaxing the value restriction</h1><p id="idp9072016">
        OCaml is actually a little better at inferring polymorphic types
        than is implied above. The value restriction as we described it
        above is basically a syntactic check: there are a few operations
        that you can do that count as simple values, and anything that's
        a simple value can be generalized.
      </p><p id="idp9072752">
        But OCaml actually has a relaxed version of the value
        restriction that can make some use of type information to allow
        polymorphic types for things that are not simple values.
      </p><p id="idp9073360">
        For example, we saw above that a function application, even a
        simple application of the identity function, is not a simple
        value and thus can turn a polymorphic value into a weakly
        polymorphic one.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">identity</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">x</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9075056">
        But that's not always the case. When the type of the returned
        value is immutable, then OCaml can typically infer a fully
        polymorphic type.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">identity</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span>
</pre></div><p id="idp9076608">
        On the other hand, if the returned type is potentially mutable,
        then the result will be weakly polymorphic.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">[||];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[||]</span>
<span class="o">#</span> <span class="n">identity</span> <span class="o">[||];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[||]</span>
</pre></div><p id="idp9078144">
        A more important example of this comes up when defining abstract
        data types. Consider the following simple data-structure for an
        immutable list type that supports constant-time concatenation.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Concat_list</span> <span class="o">:</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">singleton</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">concat</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>  <span class="c">(* constant time *)</span>
    <span class="k">val</span> <span class="n">to_list</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>       <span class="c">(* linear time   *)</span>
  <span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Singleton</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Concat</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

    <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="nc">Empty</span>
    <span class="k">let</span> <span class="n">singleton</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Singleton</span> <span class="n">x</span>
    <span class="k">let</span> <span class="n">concat</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Concat</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span>

    <span class="k">let</span> <span class="k">rec</span> <span class="n">to_list_with_tail</span> <span class="n">t</span> <span class="n">tail</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="n">tail</span>
      <span class="o">|</span> <span class="nc">Singleton</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tail</span>
      <span class="o">|</span> <span class="nc">Concat</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">to_list_with_tail</span> <span class="n">x</span> <span class="o">(</span><span class="n">to_list_with_tail</span> <span class="n">y</span> <span class="n">tail</span><span class="o">)</span>

    <span class="k">let</span> <span class="n">to_list</span> <span class="n">t</span> <span class="o">=</span>
      <span class="n">to_list_with_tail</span> <span class="n">t</span> <span class="bp">[]</span>

  <span class="k">end</span><span class="o">;;</span>
 <span class="k">module</span> <span class="nc">Concat_list</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">singleton</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">concat</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">to_list</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
  <span class="k">end</span>
</pre></div><p id="idp9081184">
        The details of the implementation don't matter so much, but it's
        important to note that a <code>Concat_list.t</code> is
        unquestionably an immutable value. However, when it comes to the
        value restriction, OCaml treats it as if it were mutable.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Concat_list</span><span class="p">.</span><span class="n">empty</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Concat_list</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">identity</span> <span class="nn">Concat_list</span><span class="p">.</span><span class="n">empty</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="nn">Concat_list</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp9083792">
        The issue here is that the signature, by virtue of being
        abstract, has obscured the fact that
        <code>Concat_list.t</code> is in fact an immutable
        data-type. We can resolve this in one of two ways: either by
        making the type concrete (<span><em>i.e.</em></span>, exposing
        the implementation in the <code>mli</code>), which is
        often not desirable; or by marking the type variable in question
        as <span><em>covariant</em></span>. We'll learn more about
        variance and covariance in <a href="objects.html">Chapter 11, <i>Objects</i></a>,
        but for now, you can think of it as an annotation which can be
        put in the interface of a pure data structure.
      </p><p id="idp9087696">
        Thus, if we replace <code>type 'a t</code> in the
        interface with <code>type +'a t</code>, that will make it
        explicit in the interface that the data-structure doesn't
        contain any persistent references to values of type
        <code>'a</code>, at which point, OCaml can infer
        polymorphic types for expressions of this type that are not
        simple values.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">identity</span> <span class="nn">Concat_list</span><span class="p">.</span><span class="n">empty</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Concat_list</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="error-handling.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="functors.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>