<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 3. Lists and Patterns / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta1',
                        page: 'lists\u002Dand\u002Dpatterns.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html" class="here">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">4. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">10. First class modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="objects.html">11. Objects</a>
                                            </li>
                                        
                                            <li>
                                                <a href="classes.html">12. Classes</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 3. Lists and Patterns</h1>
                
                

    <p id="idp7653952">
    This chapter will focus on two common elements of programming in
    OCaml: lists and pattern matching. Both of these were discussed in
    <a href="a-guided-tour.html">Chapter 1, <i>A Guided Tour</i></a>, but we'll go into more
    depth here, presenting the two topics together and using one to help
    illustrate the other.
  </p><section><h1 id="list-basics">List Basics</h1><p id="idp7656016">
      An OCaml list is an immutable, finite sequence of elements of the
      same type. As we've seen, OCaml lists can be generated using a
      bracket-and-semicolon notation:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div><p id="idp7657472">
      And they can also be generated using the equivalent
      <code>::</code> notation.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">(</span><span class="mi">2</span> <span class="o">::</span> <span class="o">(</span><span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">))</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
<span class="o">#</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div><p id="idp7659536">
      As you can see, the <code>::</code> operator is
      right-associative, which means that we can built up lists without
      parenthesis. The empty list <code>[]</code> is used to
      terminate a list.
    </p><p id="idp7661296">
      The <code>::</code> operator conveys something important
      about the nature of lists, which is that they are implemented as
      singly-linked lists. The following is a rough graphical
      representation of how the list
      <code>1 :: 2 :: 3 :: []</code> is laid out as a
      data-structure. The final arrow (from the box containing
      <code>3</code>) points to the empty list.
    </p><pre id="idp7663872">
+---+---+   +---+---+   +---+---+
| 1 | *----&gt;| 2 | *----&gt;| 3 | *----&gt;||
+---+---+   +---+---+   +---+---+
</pre><p id="idp7664784">
      Each <code>::</code> essentially adds a new block to the
      picture above. Such a block contains two things: a reference to
      the data in that list element, and a reference to the remainder of
      the list. This is why <code>::</code> can extend a list
      without modifying it; extension allocates a new list element but
      doesn't need to change any of the existing ones, as you can see:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">l</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">l</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">m</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
<span class="o">#</span> <span class="n">l</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div></section><section><h1 id="using-patterns-to-extract-data-from-a-list">Using patterns to extract data from a list</h1><p id="idp7668848">
      We can read data out of a list using a match statement. Here's a
      simple example of a recursive function that computes the sum of
      all elements of a list.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">sum</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">sum</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">6</span>
<span class="o">#</span> <span class="n">sum</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div><p id="idp7670576">
      This code follows the convention of using <code>hd</code> to
      represent the first element (or head) of the list, and
      <code>tl</code> to represent the remainder (or tail).
    </p><p id="idp7672288">
      The match statement in <code>sum</code> is really doing two
      things: first, it's acting as a case-analysis tool, breaking down
      the possibilities into a pattern-indexed list of cases. Second, it
      lets you name sub-structures within the data-structure being
      matched. In this case, the variables <code>hd</code> and
      <code>tl</code> are bound by the pattern that defines the
      first case of the match statement. Variables that are bound in
      this way can be used in the expression to the right of the arrow
      for the pattern in question.
    </p><p id="idp7675072">
      The fact that match statements can be used to bind new variables
      can be a source of confusion. To see how, imagine we wanted to
      write a function that filtered out from a list all elements equal
      to a particular value. You might be tempted to write that code as
      follows.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">drop_value</span> <span class="n">l</span> <span class="n">to_drop</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">to_drop</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">drop_value</span> <span class="n">tl</span> <span class="n">to_drop</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">drop_value</span> <span class="n">tl</span> <span class="n">to_drop</span>
  <span class="o">;;</span>
</pre></div><p id="idp7676992">
      But when we type this in, the compiler will immediately warn us
      that something is wrong.
    </p><pre id="idp7677504">
Characters 114-122:
      | hd :: tl -&gt; hd :: drop_value tl to_drop
        ^^^^^^^^
Warning 11: this match case is unused.
val drop_value : 'a list -&gt; 'a -&gt; 'a list = &lt;fun&gt;
</pre><p id="idp7678528">
      Moreover, the function clearly does the wrong thing, filtering out
      all elements of the list rather than just those equal to the
      provided value, as you can see below.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">drop_value</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span>
</pre></div><p id="idp7679984">
      So, what's going on?
    </p><p id="idp7680368">
      The key observation is that the appearance of
      <code>to_drop</code> in the second case doesn't imply a
      check that the first element is equal to the value
      <code>to_drop</code> passed in as an argument to
      <code>drop_value</code>. Instead, it just causes a new
      variable <code>to_drop</code> to be bound to whatever
      happens to be in the first element of the list, shadowing the
      earlier definition of <code>to_drop</code>. The third case
      is unused because it is essentially the same pattern as we had in
      the second case.
    </p><p id="idp7684336">
      A better way to write this code is not to use pattern matching for
      determining whether the first element is equal to
      <code>to_drop</code>, but to instead use an ordinary
      if-statement.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">drop_value</span> <span class="n">l</span> <span class="n">to_drop</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">new_tl</span> <span class="o">=</span> <span class="n">drop_value</span> <span class="n">tl</span> <span class="n">to_drop</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">to_drop</span> <span class="k">then</span> <span class="n">new_tl</span> <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">new_tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">drop_value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">drop_value</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div><p id="idp7686976">
      Note that if we wanted to drop a particular literal value (rather
      than a value that was passed in), we could do this using something
      like our original implementation of <code>drop_value</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">drop_zero</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="mi">0</span>  <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">drop_zero</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">drop_zero</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">drop_zero</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">drop_zero</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">0</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div></section><section><h1 id="limitations-and-blessings-of-pattern-matching">Limitations (and blessings) of pattern matching</h1><p id="idp7690400">
      The above example highlights an important fact about patterns,
      which is that they can't be used to express arbitrary conditions.
      Patterns can characterize the layout of a data-structure, and can
      even include literals as in the <code>drop_zero</code>
      example, but that's where they stop. A pattern can check if a list
      has two elements, but it can't check if the first two elements are
      equal to each other.
    </p><p id="idp7691872">
      You can think of patterns as a specialized sub-language that can
      express a limited (though still quite rich) set of conditions. The
      fact that the pattern language is limited turns out to be a very
      good thing, making it possible to build better support for
      patterns in the compiler. In particular, both the efficiency of
      match statements and the ability of the compiler to detect errors
      in matches depend on the constrained nature of patterns.
    </p><section><h1 id="performance">Performance</h1><p id="idp7693648">
        Naively, you might think that it would be necessary to check
        each case in a <code>match</code> in sequence to figure
        out which one fires. If the cases of a match were guarded by
        arbitrary code, that would be the case. But OCaml is often able
        to generate machine code that jumps directly to the matched case
        based on an efficiently chosen set of runtime checks.
      </p><p id="idp7695088">
        As an example, consider the following rather silly functions for
        incrementing an integer by one. The first is implemented with a
        match statement, and the second with a sequence of if
        statements.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">plus_one_match</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span>
    <span class="o">|</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">2</span>
    <span class="o">|</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

  <span class="k">let</span> <span class="n">plus_one_if</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">if</span>      <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">2</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">then</span> <span class="mi">3</span>
    <span class="k">else</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">plus_one_match</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">plus_one_if</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7697120">
        Note the use of <code>_</code> in the above match. This is
        a wild-card pattern that matches any value, but without binding
        a variable name to the value in question.
      </p><p id="idp7698304">
        If you benchmark these functions, you'll see that
        <code>plus_one_if</code> is considerably slower than
        <code>plus_one_match</code>, and the advantage gets larger
        as the number of cases increases. Here, we'll benchmark these
        functions using the <code>core_bench</code> library.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;core_bench&quot;</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">open</span> <span class="nn">Core_bench</span><span class="p">.</span><span class="nc">Std</span><span class="o">;;</span>
<span class="o">#</span> <span class="o">[</span> <span class="nn">Bench</span><span class="p">.</span><span class="nn">Test</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">name</span><span class="o">:</span><span class="s2">&quot;plus_one_match&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="n">ignore</span> <span class="o">(</span><span class="n">plus_one_match</span> <span class="mi">10</span><span class="o">))</span>
  <span class="o">;</span> <span class="nn">Bench</span><span class="p">.</span><span class="nn">Test</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">name</span><span class="o">:</span><span class="s2">&quot;plus_one_if&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="n">ignore</span> <span class="o">(</span><span class="n">plus_one_if</span> <span class="mi">10</span><span class="o">))</span> <span class="o">]</span>
  <span class="o">|&gt;</span> <span class="nn">Bench</span><span class="p">.</span><span class="n">bench</span>
  <span class="o">;;</span>
<span class="nc">Estimated</span> <span class="n">testing</span> <span class="n">time</span> <span class="mi">20</span><span class="n">s</span> <span class="o">(</span><span class="n">change</span> <span class="n">using</span> <span class="o">-</span><span class="n">quota</span> <span class="nc">SECS</span><span class="o">).</span>
<span class="o">+----------------+-----------+----------+</span>
<span class="o">|</span> <span class="nc">Name</span>           <span class="o">|</span> <span class="nc">Time</span> <span class="o">(</span><span class="n">ns</span><span class="o">)</span> <span class="o">|</span> <span class="o">%</span> <span class="k">of</span> <span class="n">max</span> <span class="o">|</span>
<span class="o">|----------------+-----------+----------|</span>
<span class="o">|</span> <span class="n">plus_one_match</span> <span class="o">|</span>    <span class="mi">369</span><span class="o">.</span><span class="mi">38</span> <span class="o">|</span>    <span class="mi">83</span><span class="o">.</span><span class="mi">40</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">plus_one_if</span>    <span class="o">|</span>    <span class="mi">442</span><span class="o">.</span><span class="mi">88</span> <span class="o">|</span>   <span class="mi">100</span><span class="o">.</span><span class="mi">00</span> <span class="o">|</span>
<span class="o">+----------------+-----------+----------+</span>
</pre></div><p id="idp7703232">
        Here's another less artificial example. We can rewrite the
        <code>sum</code> function we described earlier in the
        chapter using an <code>if</code> statement rather than a
        match. We can then use the functions
        <code>is_empty</code>, <code>hd_exn</code> and
        <code>tl_exn</code> from the <code>List</code>
        module to deconstruct the list, allowing us to implement the
        entire function without pattern matching.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">sum_if</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">is_empty</span> <span class="n">l</span> <span class="k">then</span> <span class="mi">0</span>
    <span class="k">else</span> <span class="nn">List</span><span class="p">.</span><span class="n">hd_exn</span> <span class="n">l</span> <span class="o">+</span> <span class="n">sum_if</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">tl_exn</span> <span class="n">l</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sum_if</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7708912">
        Again, we can benchmark these to see the difference.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">range</span> <span class="mi">0</span> <span class="mi">1000</span> <span class="k">in</span>
  <span class="o">[</span> <span class="nn">Bench</span><span class="p">.</span><span class="nn">Test</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">name</span><span class="o">:</span><span class="s2">&quot;sum_if&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">ignore</span> <span class="o">(</span><span class="n">sum_if</span> <span class="n">numbers</span><span class="o">))</span>
  <span class="o">;</span> <span class="nn">Bench</span><span class="p">.</span><span class="nn">Test</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">name</span><span class="o">:</span><span class="s2">&quot;sum&quot;</span>    <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">ignore</span> <span class="o">(</span><span class="n">sum</span> <span class="n">numbers</span><span class="o">))</span> <span class="o">]</span>
  <span class="o">|&gt;</span> <span class="nn">Bench</span><span class="p">.</span><span class="n">bench</span>
  <span class="o">;;</span>
<span class="nc">Estimated</span> <span class="n">testing</span> <span class="n">time</span> <span class="mi">20</span><span class="n">s</span> <span class="o">(</span><span class="n">change</span> <span class="n">using</span> <span class="o">-</span><span class="n">quota</span> <span class="nc">SECS</span><span class="o">).</span>
<span class="o">+--------+-----------+----------+</span>
<span class="o">|</span> <span class="nc">Name</span>   <span class="o">|</span> <span class="nc">Time</span> <span class="o">(</span><span class="n">ns</span><span class="o">)</span> <span class="o">|</span> <span class="o">%</span> <span class="k">of</span> <span class="n">max</span> <span class="o">|</span>
<span class="o">|--------+-----------+----------|</span>
<span class="o">|</span> <span class="n">sum_if</span> <span class="o">|</span>   <span class="mi">650_463</span> <span class="o">|</span>   <span class="mi">100</span><span class="o">.</span><span class="mi">00</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">sum</span>    <span class="o">|</span>   <span class="mi">177_740</span> <span class="o">|</span>    <span class="mi">27</span><span class="o">.</span><span class="mi">32</span> <span class="o">|</span>
<span class="o">+--------+-----------+----------+</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp7711600">
        In this case, the match-based implementation is more than three
        times faster than the one using if. The difference comes because
        we need to effectively do the same work multiple times, since
        each function we call has to re-examine the first element of the
        list to determine whether or not it's the empty cell. With a
        match statement, this work happens exactly once per list
        element.
      </p><p id="idp7712448">
        Generally, pattern matching is more efficient than the
        alternatives you might code by hand. One notable exception is
        matches over strings, which are in fact tested sequentially, and
        which for long lists can be outperformed by a hashtable. But
        most of the time, pattern matching is a clear performance win.
      </p></section><section><h1 id="detecting-errors">Detecting errors</h1><p id="idp7714208">
        The error-detecting capabilities of match statements are if
        anything more important than their performance. We've already
        seen one example of OCaml's ability to find problems in a
        pattern match: in our broken implementation of
        <code>drop_value</code>, OCaml warned us that the final
        case was redundant. There are no algorithms for determining if a
        predicate written in a general-purpose language is redundant,
        but it can be solved reliably in the context of patterns.
      </p><p id="idp7715776">
        OCaml also checks match statements for exhaustiveness. Consider
        what happens if we modify <code>drop_zero</code> by
        deleting the handler for one of the cases.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">drop_zero</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="mi">0</span>  <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">drop_zero</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7717984">
        The compiler will produce a warning that we've missed a case,
        along with an example of an unmatched pattern.
      </p><pre id="idp7718512">
val drop_zero : int list -&gt; 'a list = &lt;fun&gt;
Characters 26-84:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
1::_
</pre><p id="idp7719520">
        For simple examples like this, exhaustiveness checks are useful
        enough. But as we'll see in
        <a href="variants.html">Chapter 6, <i>Variants</i></a>, as you get to more
        complicated examples, especially those involving user-defined
        types, exhaustiveness checks become a lot more valuable. In
        addition to catching outright errors, they act as a sort of
        refactoring tool, guiding you to the locations where you need to
        adapt your code to deal with changing types.
      </p></section></section><section><h1 id="using-the-list-module-effectively">Using the <code>List</code> module effectively</h1><p id="idp7722656">
      We've so far written a fair amount of list-munging code using
      pattern matching and recursive functions. But in real life, you're
      usually better off using the <code>List</code> module, which
      is full of reusable functions that abstract out common patterns
      for computing with lists.
    </p><p id="idp7724000">
      Let's work through a concrete example to see this in action. We'll
      write a function <code>render_table</code> that, given a
      list of column headers and a list of rows, prints them out in a
      well formatted text table. So, if you were to write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span>
   <span class="o">(</span><span class="n">render_table</span>
     <span class="o">[</span><span class="s2">&quot;language&quot;</span><span class="o">;</span><span class="s2">&quot;architect&quot;</span><span class="o">;</span><span class="s2">&quot;first release&quot;</span><span class="o">]</span>
     <span class="o">[</span> <span class="o">[</span><span class="s2">&quot;Lisp&quot;</span> <span class="o">;</span><span class="s2">&quot;John McCarthy&quot;</span> <span class="o">;</span><span class="s2">&quot;1958&quot;</span><span class="o">]</span> <span class="o">;</span>
       <span class="o">[</span><span class="s2">&quot;C&quot;</span>    <span class="o">;</span><span class="s2">&quot;Dennis Ritchie&quot;</span><span class="o">;</span><span class="s2">&quot;1969&quot;</span><span class="o">]</span> <span class="o">;</span>
       <span class="o">[</span><span class="s2">&quot;ML&quot;</span>   <span class="o">;</span><span class="s2">&quot;Robin Milner&quot;</span>  <span class="o">;</span><span class="s2">&quot;1973&quot;</span><span class="o">]</span> <span class="o">;</span>
       <span class="o">[</span><span class="s2">&quot;OCaml&quot;</span><span class="o">;</span><span class="s2">&quot;Xavier Leroy&quot;</span>  <span class="o">;</span><span class="s2">&quot;1996&quot;</span><span class="o">]</span> <span class="o">;</span>
     <span class="o">]);;</span>
</pre></div><p id="idp7726560">
      it would generate the following output.
    </p><pre id="idp7726944">
| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |
</pre><p id="idp7727856">
      The first step is to write a function to compute the maximum width
      of each column of data. We can do this by converting the header
      and each row into a list of integer lengths, and then taking the
      element-wise max of those lists of lengths. Writing the code for
      all of this directly would be a bit of a chore, but we can do it
      quite concisely by making use of three functions from the
      <code>List</code> module: <code>map</code>,
      <code>map2_exn</code>, and <code>fold</code>.
    </p><p id="idp7731184">
<code>List.map</code> is the simplest to explain. It takes a
      list and a function for transforming elements of that list, and
      returns a new list with the transformed elements. Thus, we can
      write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="o">[</span><span class="s2">&quot;Hello&quot;</span><span class="o">;</span> <span class="s2">&quot;World!&quot;</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">]</span>
</pre></div><p id="idp7733456">
<code>List.map2_exn</code> is similar to
      <code>List.map</code>, except that it takes two lists and a
      function for combining them. Thus, we might write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">1</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div><p id="idp7736144">
      The <code>_exn</code> is there because the function throws
      an exception if the lists are of mismatched length.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">1</span><span class="o">;</span><span class="mi">0</span><span class="o">];;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;length mismatch in rev_map2_exn: 3 &lt;&gt; 4 &quot;</span><span class="o">).</span>
</pre></div><p id="idp7738304">
<code>List.fold</code> is the most complicated of the three,
      taking three arguments: a list to process, an initial accumulator
      value, and a function for updating the accumulator with the
      information from a list element. <code>List.fold</code>
      walks over the list from left to right, updating the accumulator
      at each step and returning the final value of the accumulator when
      it's done. You can see some of this by looking at the
      type-signature for <code>fold</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">accum</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">accum</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">accum</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7742048">
      We can use <code>List.fold</code> for something as simple as
      summing up a list:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:(+)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div><p id="idp7744000">
      This example is particularly simple because the accumulator and
      the list elements are of the same type. But
      <code>fold</code> is not limited to such cases. We can for
      example use <code>fold</code> to reverse a list, in which
      case the accumulator is itself a list.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="kt">list</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="kt">list</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">1</span><span class="o">]</span>
</pre></div><p id="idp7747088">
      Let's bring our three functions together to compute the maximum
      column widths.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">max_widths</span> <span class="n">header</span> <span class="n">rows</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">lengths</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">l</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="n">rows</span>
      <span class="o">~</span><span class="n">init</span><span class="o">:(</span><span class="n">lengths</span> <span class="n">header</span><span class="o">)</span>
      <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">row</span> <span class="o">-&gt;</span>
        <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="n">acc</span> <span class="o">(</span><span class="n">lengths</span> <span class="n">row</span><span class="o">))</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">max_widths</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7748768">
      Using <code>List.map</code> we define the function
      <code>lengths</code> which converts a list of strings to a
      list of integer lengths. <code>List.fold</code> is then used
      to iterate over the rows, using <code>map2_exn</code> to
      take the max of the accumulator with the lengths of the strings in
      each row of the table, with the accumulator initialized to the
      lengths of the header row.
    </p><p id="idp7751920">
      Now that we know how to compute column widths, we can write the
      code to generate the line that separates the header from the rest
      of the text table. We'll do this in part by mapping
      <code>String.make</code> over the lengths of the columns to
      generate a string of dashes of the appropriate length. We'll then
      join these sequences of dashes together using
      <code>String.concat</code>, which concatenates a list of
      strings with an optional separator string, and
      <code>^</code>, which is a pairwise string concatenation
      function, to add the delimiters on the outside.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">render_separator</span> <span class="n">widths</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">pieces</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">widths</span>
      <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">w</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="o">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="sc">'-'</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="s2">&quot;|&quot;</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;+&quot;</span> <span class="n">pieces</span> <span class="o">^</span> <span class="s2">&quot;|&quot;</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">render_separator</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">render_separator</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span><span class="mi">6</span><span class="o">;</span><span class="mi">2</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;|-----+--------+----|&quot;</span>
</pre></div><p id="idp7756096">
      Note that we make the line of dashes two larger than the provided
      width to provide some whitespace around each entry in the table.
    </p><aside class="note"><h1>
    Performance of String.concat and
    ^
</h1><p id="idp7758528">
      In the above, we're using two different ways of concatenating
      strings, <code>String.concat</code>, which operates on lists
      of strings, and <code>^</code>, which is a pairwise
      operator. You should avoid <code>^</code> for joining long
      numbers of strings, since, it allocates a new string every time it
      runs. Thus, the following code:
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span> <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>
</pre></div><p id="idp7762016">
      will allocate a string of length 2, 3, 4, 5, 6 and 7, whereas this
      code:
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">[</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">]</span>
</pre></div><p id="idp7763504">
      allocates one string of size 7, as well as a list of length 7. At
      these small sizes, the differences don't amount to much, but for
      assembling of large strings, it can be a serious performance
      issue.
    </p></aside><p id="idp7764256">
      Now we need code for rendering a row with data in it. We'll first
      write a function <code>pad</code> for padding out a string
      to a specified length plus one blank space on either side.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">pad</span> <span class="n">s</span> <span class="n">length</span> <span class="o">=</span>
    <span class="s2">&quot; &quot;</span> <span class="o">^</span> <span class="n">s</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="o">(</span><span class="n">length</span> <span class="o">-</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="sc">' '</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">pad</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">pad</span> <span class="s2">&quot;hello&quot;</span> <span class="mi">10</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot; hello      &quot;</span>
</pre></div><p id="idp7766640">
      We can render a row of data by merging together the padded
      strings. Again, we'll use <code>List.map2_exn</code> for
      combining the list of data in the row with the list of widths.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">render_row</span> <span class="n">row</span> <span class="n">widths</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">padded</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="n">row</span> <span class="n">widths</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">pad</span> <span class="k">in</span>
    <span class="s2">&quot;|&quot;</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;|&quot;</span> <span class="n">padded</span> <span class="o">^</span> <span class="s2">&quot;|&quot;</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">render_row</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">render_row</span> <span class="o">[</span><span class="s2">&quot;Hello&quot;</span><span class="o">;</span><span class="s2">&quot;World&quot;</span><span class="o">]</span> <span class="o">[</span><span class="mi">10</span><span class="o">;</span><span class="mi">15</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;| Hello      | World           |&quot;</span>
</pre></div><p id="idp7769104">
      Now we can bring this all together in a single function that
      renders the table.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">render_table</span> <span class="n">header</span> <span class="n">rows</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">widths</span> <span class="o">=</span> <span class="n">max_widths</span> <span class="n">header</span> <span class="n">rows</span> <span class="k">in</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="o">(</span><span class="n">render_row</span> <span class="n">header</span> <span class="n">widths</span>
       <span class="o">::</span> <span class="n">render_separator</span> <span class="n">widths</span>
       <span class="o">::</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">rows</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">row</span> <span class="o">-&gt;</span> <span class="n">render_row</span> <span class="n">row</span> <span class="n">widths</span><span class="o">)</span>
      <span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">render_table</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><section><h1 id="more-useful-list-functions">More useful list functions</h1><p id="idp7771968">
        The example we worked through above only touched on three of the
        function in <code>List</code>. We won't cover the entire
        interface, but there are a few more functions that are useful
        enough to mention here.
      </p><p id="idp7773248">
        Very often when processing lists, one wants to restrict
        attention to just a subset of values. The
        <code>List.filter</code> function does just that.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">;</span> <span class="mi">4</span><span class="o">]</span>
</pre></div><p id="idp7775488">
        Sometimes, you want to both transform and filter as part of the
        same computation. <code>List.filter_map</code> allows you
        to do just that. The function passed to
        <code>List.filter_map</code> returns an optional value,
        and <code>List.filter_map</code> drops all elements for
        which <code>None</code> is returned.
      </p><p id="idp7778560">
        Here's an example. The following expression computes the list of
        file extensions in the current directory, piping the results
        through <code>List.dedup</code> to remove duplicates. Note
        that this example also uses some functions from other modules,
        including <code>Sys.ls_dir</code> to get a directory
        listing, and <code>String.rsplit2</code> to split a string
        on the rightmost appearance of a given character.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter_map</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="s2">&quot;.&quot;</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">fname</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">rsplit2</span> <span class="o">~</span><span class="n">on</span><span class="o">:</span><span class="sc">'.'</span> <span class="n">fname</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span>  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(_,</span><span class="n">ext</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="nc">Some</span> <span class="n">ext</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">dedup</span>
  <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;byte&quot;</span><span class="o">;</span> <span class="s2">&quot;ml&quot;</span><span class="o">;</span> <span class="s2">&quot;mli&quot;</span><span class="o">;</span> <span class="s2">&quot;native&quot;</span><span class="o">;</span> <span class="s2">&quot;txt&quot;</span><span class="o">]</span>
</pre></div><p id="idp7782352">
        One feature of OCaml's pattern language that we've encountered
        here for the first time is <span><em>or-patterns</em></span>,
        which allow you to have multiple sub-patterns within a larger
        pattern. In this case,
        <code>None | Some (&quot;&quot;,_)</code> is an
        or-pattern. As we'll see later, or-patterns can be nested
        anywhere within larger patterns.
      </p><p id="idp7784144">
        Another function that is similar to <code>filter</code> is
        <code>partition_tf</code>, which takes a list and
        partitions it into a pair of lists based on a boolean condition.
        <code>tf</code> is a mnemonic to remind the reader that
        <code>true</code> elements go to the first bucket and
        <code>false</code> ones go to the second. Thus, one could
        write:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">is_ocaml_source</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">rsplit2</span> <span class="n">s</span> <span class="o">~</span><span class="n">on</span><span class="o">:</span><span class="sc">'.'</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(_,(</span><span class="s2">&quot;ml&quot;</span><span class="o">|</span><span class="s2">&quot;mli&quot;</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">is_ocaml_source</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">ml_files</span><span class="o">,</span><span class="n">other_files</span><span class="o">)</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">partition_tf</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="s2">&quot;.&quot;</span><span class="o">)</span>  <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">is_ocaml_source</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">ml_files</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;example.ml&quot;</span><span class="o">]</span>
<span class="k">val</span> <span class="n">other_files</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;_build&quot;</span><span class="o">;</span> <span class="s2">&quot;_tags&quot;</span><span class="o">]</span>
</pre></div><p id="idp7789424">
        Note the use of a nested or-pattern in
        <code>is_ocaml_source</code>.
      </p><p id="idp7790512">
        Another very common operation on lists is concatenation. The
        list module actually comes with a few different ways of doing
        this. First, there's <code>List.append</code>, for
        concatenating a pair of lists.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">;</span><span class="mi">6</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">]</span>
</pre></div><p id="idp7792656">
        There's also <code>@</code>, an operator equivalent of
        <code>List.append</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">@</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">;</span><span class="mi">6</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">]</span>
</pre></div><p id="idp7795232">
        In addition, there is <code>List.concat</code>, for
        concatenating a list of lists.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat</span> <span class="o">[[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">];[</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">];[</span><span class="mi">6</span><span class="o">];</span><span class="bp">[]</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">]</span>
</pre></div><p id="idp7797200">
        Here's an example of using <code>List.concat</code> along
        with <code>List.map</code> to compute a recursive listing
        of a directory tree.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">ls_rec</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">is_file_exn</span> <span class="o">~</span><span class="n">follow_symlinks</span><span class="o">:</span><span class="bp">true</span> <span class="n">s</span>
    <span class="k">then</span> <span class="o">[</span><span class="n">s</span><span class="o">]</span>
    <span class="k">else</span>
      <span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="n">s</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">sub</span> <span class="o">-&gt;</span> <span class="n">ls_rec</span> <span class="o">(</span><span class="n">s</span> <span class="o">^</span> <span class="s2">&quot;/&quot;</span> <span class="o">^</span> <span class="n">sub</span><span class="o">))</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat</span>
  <span class="o">;;</span>
<span class="o">#</span> <span class="n">all_files</span> <span class="s2">&quot;.&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span>
<span class="o">[</span><span class="s2">&quot;./_build/_digests&quot;</span><span class="o">;</span> <span class="s2">&quot;./_build/_log&quot;</span><span class="o">;</span> <span class="s2">&quot;./_build/example.ml&quot;</span><span class="o">;</span>
 <span class="s2">&quot;./_build/example.ml.depends&quot;</span><span class="o">;</span> <span class="s2">&quot;./_build/ocamlc.where&quot;</span><span class="o">;</span> <span class="s2">&quot;./_tags&quot;</span><span class="o">;</span>
 <span class="s2">&quot;./example.ml&quot;</span><span class="o">]</span>
</pre></div><p id="idp7800304">
        The above combination of <code>List.map</code> and
        <code>List.concat</code> is common enough that there is a
        function <code>List.concat_map</code> that combines these
        into one, more efficient operation.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">ls_rec</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">is_file_exn</span> <span class="o">~</span><span class="n">follow_symlinks</span><span class="o">:</span><span class="bp">true</span> <span class="n">s</span>
    <span class="k">then</span> <span class="o">[</span><span class="n">s</span><span class="o">]</span>
    <span class="k">else</span>
      <span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="n">s</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat_map</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">sub</span> <span class="o">-&gt;</span> <span class="n">ls_rec</span> <span class="o">(</span><span class="n">s</span> <span class="o">^/</span> <span class="n">sub</span><span class="o">))</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">ls_rec</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div></section></section><section><h1 id="tail-recursion">Tail recursion</h1><p id="idp7804896">
      The only way to compute the length of an OCaml list is to walk the
      list from beginning to end. As a result, computing the length of a
      list takes time linear in the size of the list. Here's a simple
      function for doing so.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">length</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="o">#</span> <span class="n">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div><p id="idp7806704">
      This looks simple enough, but you'll discover that this
      implementation runs into problems on very large lists. Here are
      some examples, using another useful function from the
      <code>List</code> module, <code>List.init</code>, to
      create the lists. <code>List.init</code> takes an integer
      <code>n</code> and a function <code>f</code> and
      creates a list of length <code>n</code> where the data for
      each element is created by calling <code>f</code> on the
      index of that element.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">make_list</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">init</span> <span class="n">n</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">make_list</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">make_list</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">9</span><span class="o">]</span>
<span class="o">#</span> <span class="n">length</span> <span class="o">(</span><span class="n">make_list</span> <span class="mi">10_000_000</span><span class="o">);;</span>
<span class="nc">Stack</span> <span class="n">overflow</span> <span class="n">during</span> <span class="n">evaluation</span> <span class="o">(</span><span class="n">looping</span> <span class="n">recursion</span><span class="o">?).</span>
</pre></div><p id="idp7813104">
      To understand what went wrong, you need to learn a bit more about
      how function calls work. Typically, a function call needs some
      space to keep track of information associated with the call, such
      as the arguments passed to the function, or the location of the
      code that needs to start executing when the function call is
      complete. To allow for nested function calls, this information is
      typically organized in a stack, where a new <span><em>stack
      frame</em></span> is allocated for each nested function call, and
      then deallocated when the function call is complete.
    </p><p id="idp7814496">
      And that's the problem with our call to <code>length</code>:
      it tried to allocate ten million stack frames, which exhausted the
      available stack space. Happily, there's a way around this problem.
      Consider the following alternative implementation.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">length_plus_n</span> <span class="n">l</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">n</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">length_plus_n</span> <span class="n">tl</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">length_plus_n</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">length</span> <span class="n">l</span> <span class="o">=</span> <span class="n">length_plus_n</span> <span class="n">l</span> <span class="mi">0</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">length</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div><p id="idp7816960">
      This implementation depends on a helper function,
      <code>length_plus_n</code>, that computes the length of a
      given list plus a given <code>n</code>. In practice,
      <code>n</code> acts as an accumulator in which the answer is
      built up, step by step. As a result, we can do the additions along
      the way rather than doing them as we unwind the nested sequence of
      function calls, as we did in our first implementation of
      <code>length</code>.
    </p><p id="idp7820272">
      The advantage of this approach is that the recursive call in
      <code>length_plus_n</code> is a <span><em>tail
      call</em></span>. We'll explain more precisely what it means to be
      a tail call shortly, but the reason it's important is that tail
      calls don't require the allocation of a new stack frame, due to
      what is called the <span><em>tail-call optimization</em></span>. A
      recursive function is said to be <span><em>tail
      recursive</em></span> if all of its recursive calls are tail calls.
      <code>length_plus_n</code> is indeed tail recursive, and as
      a result, <code>length</code> can take a long list as input
      without blowing the stack.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">length</span> <span class="o">(</span><span class="n">make_list</span> <span class="mi">10_000_000</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10000000</span>
</pre></div><p id="idp7824960">
      So when is a call a tail call? Let's think about the situation of
      one function (the <span><em>caller</em></span>) invokes another
      (the <span><em>callee</em></span>). The invocation is considered a
      tail call when the caller doesn't do anything with the value
      returned by the callee except to return it. The tail-call
      optimization makes sense because, when a caller makes a tail call,
      the caller's stack frame need never be used again, and so you
      don't need to keep it around. Thus, instead of allocating a new
      stack frame for the callee, the compiler is free to reuse the
      caller's stack frame.
    </p><p id="idp7826720">
      Tail recursion is important for more than just lists. Ordinary
      (non-tail) recursive calls are reasonable when the dealing with
      data-structures like binary trees where the depth of the tree is
      logarithmic in the size of your data. But when dealing with
      situations where the depth of the sequence of nested calls is on
      the order of the size of your data, tail recursion is usually the
      right approach.
    </p></section><section><h1 id="more-concise-and-faster-patterns">More concise and faster patterns</h1><p id="idp7828576">
      Now that we know more about how lists and patterns work, let's
      consider how we can improve on an example from
      <a href="a-guided-tour.html#recursive-list-functions">the section called “Recursive list functions”</a>: the function
      <code>destutter</code>, which removes sequential duplicates
      from a list. Here's the implementation that was described earlier.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">destutter</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="o">[</span><span class="n">hd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">hd</span><span class="o">]</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">hd'</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">hd'</span> <span class="k">then</span> <span class="n">destutter</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span>
      <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">destutter</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">destutter</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7831696">
      We'll consider some ways of making this code more concise and more
      efficient.
    </p><p id="idp7832192">
      First, let's consider efficiency. One problem with the
      <code>destutter</code> code above is that it in some cases
      recreates on the right-hand side of the arrow a value that already
      existed on the left hand side. Thus, the pattern
      <code>[hd] -&gt; [hd]</code> actually allocates a new list
      element, which really, it should be able to just return the list
      being matched. We can reduce allocation here by using an
      <code>as</code> pattern, which allows us to declare a name
      for the thing matched by a pattern or sub-pattern. While we're at
      it, we'll use the <code>function</code> keyword to eliminate
      the need for an explicit match.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="o">|</span> <span class="o">[_]</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="n">tl</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">hd'</span> <span class="k">then</span> <span class="n">destutter</span> <span class="n">tl</span>
      <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">destutter</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">destutter</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7836912">
      We can further collapse this by combining the first two cases into
      one, using an or-pattern.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[_]</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="n">tl</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">hd'</span> <span class="k">then</span> <span class="n">destutter</span> <span class="n">tl</span>
      <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">destutter</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">destutter</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7838720">
      We can make the code slightly terser now by using a
      <code>when</code> clause. A <code>when</code> clause
      allows one to add an extra precondition on a pattern in the form
      of an arbitrary OCaml expression. In this case, we can use it to
      include the check on whether the first two elements are equal.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[_]</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="n">tl</span><span class="o">)</span> <span class="k">when</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">hd'</span> <span class="o">-&gt;</span> <span class="n">destutter</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">destutter</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">destutter</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><aside class="note"><h1> 
    Polymorphic compare
    </h1><p id="idp7842464">
      In the <code>destutter</code> example above, we made use of
      the fact that OCaml lets us test equality between values of any
      type, using the <code>=</code> operator. Thus, we can write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="o">[</span><span class="nc">Some</span> <span class="mi">3</span><span class="o">;</span> <span class="nc">None</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="nc">None</span><span class="o">;</span> <span class="nc">Some</span> <span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp7845232">
      Indeed, if we look at the type of the equality operator, we'll see
      that it is polymorphic:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="o">(=);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7846704">
      OCaml actually comes with a whole family of polymorphic comparison
      operators, including the standard infix comparators,
      <code>&lt;</code>, <code>&gt;=</code>,
      <span><em>etc.</em></span>, as well as the function
      <code>compare</code> that returns <code>-1</code>,
      <code>0</code> or <code>1</code> to flag whether the
      first operator is smaller than, equal to, or greater than the
      second, respectively.
    </p><p id="idp7851520">
      You might wonder how you could build function like these yourself
      if OCaml didn't come with them built-in. It turns out that you
      <span><em>can't</em></span> build these functions on your own.
      OCaml's polymorphic comparison functions are actually built-in to
      the runtime to a low level. These comparisons are polymorphic on
      the basis of ignoring almost everything about the types of the
      values that are being compared, paying attention only to the
      structure of the values as they're laid out in memory.
    </p><p id="idp7852848">
      Polymorphic compare does have some limitations. For example, they
      will fail at runtime if they encounter functions:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;equal: functional value&quot;</span><span class="o">).</span>
</pre></div><p id="idp7854480">
      Similarly, it will fail on values that come from outside the OCaml
      heap, like values from C-bindings. But they will work in a
      reasonable way for other kinds of values.
    </p><p id="idp7855072">
      For simple atomic types, polymorphic compare has the semantics you
      would expect: for floating point numbers and integer, polymorphic
      compare corresponds to the expected numerical comparison
      functions. For strings, it's a lexicographic comparison.
    </p><p id="idp7855744">
      Sometimes, however, the type-ignoring nature of polymorphic
      compare is a problem, particularly when you have your own notion
      of equality and ordering that you want to impose. We'll discuss
      this issue more, as well as some of the other downsides of
      polymorphic compare, in
      <a href="maps-and-hashtables.html">Chapter 13, <i>Maps and Hashtables</i></a>.
    </p></aside><p id="idp7857072">
      Note that <code>when</code> clauses have some downsides. As
      we noted earlier, the static checks associated with pattern
      matches rely on the fact that patterns are restricted in what they
      can express. Once we add the ability to add an arbitrary condition
      to a pattern, something will be lost. In particular, the ability
      for the compiler to determine if a match is exhaustive, or if some
      case is redundant, is compromised.
    </p><p id="idp7858528">
      Consider the following function which takes a list of optional
      values, and returns the number of those values that are
      <code>Some</code>. Because this implementation uses
      <code>when</code> clauses, the compiler can't tell that the
      code is exhaustive.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">count_some</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_some</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">count_some</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="nc">Characters</span> <span class="mi">30</span><span class="o">-</span><span class="mi">169</span><span class="o">:</span>
<span class="k">val</span> <span class="n">count_some</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="nc">Warning</span> <span class="mi">8</span><span class="o">:</span> <span class="n">this</span> <span class="n">pattern</span><span class="o">-</span><span class="n">matching</span> <span class="n">is</span> <span class="n">not</span> <span class="n">exhaustive</span><span class="o">.</span>
<span class="nc">Here</span> <span class="n">is</span> <span class="n">an</span> <span class="n">example</span> <span class="k">of</span> <span class="n">a</span> <span class="n">value</span> <span class="n">that</span> <span class="n">is</span> <span class="n">not</span> <span class="n">matched</span><span class="o">:</span>
<span class="o">_::_</span>
<span class="o">(</span><span class="nc">However</span><span class="o">,</span> <span class="n">some</span> <span class="n">guarded</span> <span class="n">clause</span> <span class="n">may</span> <span class="k">match</span> <span class="n">this</span> <span class="n">value</span><span class="o">.)</span>
</pre></div><p id="idp7862320">
      Despite the warning, the function does work fine.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">count_some</span> <span class="o">[</span><span class="nc">Some</span> <span class="mi">3</span><span class="o">;</span> <span class="nc">None</span><span class="o">;</span> <span class="nc">Some</span> <span class="mi">4</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp7863648">
      If we add another redundant case without a <code>when</code>
      clause, the compiler will stop complaining about exhaustiveness,
      and won't produce a warning about the redundancy.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">count_some</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="c">(* unreachable *)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">count_some</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7866032">
      Probably a better approach is to simply drop the second
      <code>when</code> clause.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">count_some</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_some</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7868304">
      This is a little less clear, however, than the direct pattern
      matching solution, where the meaning of each pattern is clearer on
      its own.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">count_some</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="nc">None</span>   <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_some</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7870032">
      The takeaway from all of this is that, while
      <code>when</code> clauses can be useful, one should prefer
      patterns wherever they are sufficient.
    </p><p id="idp7871232">
      As a side note, the above implementation of
      <code>count_some</code> is longer than necessary, and even
      worse is not tail recursive. In real life, you would probably just
      use the <code>List.count</code> function from
      <code>Core</code>:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">count_some</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">count</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="n">l</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">count_some</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="variables-and-functions.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="files-modules-and-programs.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>