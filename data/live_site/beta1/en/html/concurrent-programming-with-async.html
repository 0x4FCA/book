<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 18. Concurrent Programming with Async / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta1',
                        page: 'concurrent\u002Dprogramming\u002Dwith\u002Dasync.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="maps-and-hashtables.html">13. Maps and Hashtables</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html">14. Command Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">15. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-menhir.html">16. Parsing with OCamllex and Menhir</a>
                                            </li>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html">17. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html" class="here">18. Concurrent Programming with Async</a>
                                            </li>
                                        
                                            <li>
                                                <a href="fast-binary-serialization.html">19. Fast Binary Serialization</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 18. Concurrent Programming with Async</h1>
                
                

    <p id="idp11023744">
    The logic of building programs that interact with the outside world
    is often dominated by waiting: waiting for the click of a mouse, or
    for data to be fetched from disk, or for space to be available on an
    outgoing network buffer. Even mildly sophisticated interactive
    applications are typically <span><em>concurrent</em></span>, needing
    to wait for multiple different events at the same time, responding
    immediately to whatever event happens first.
  </p><p id="idp11025024">
    A common approach to concurrency is to use preemptive system
    threads, which is the most common solution in languages like Java or
    C#. In this model, each task that may require simultaneous waiting
    is given an operating system thread of its own, so it can block
    without stopping the entire program. Other language runtimes such as
    Javascript are single-threaded, and applications register function
    callbacks to be triggered upon external events such as a timeout or
    browser click.
  </p><p id="idp11025936">
    Each of these mechanisms has its own trade-offs. Preemptive threads
    require significant memory and other resources per thread. Also, the
    operating system can arbitrarily interleave the execution of
    preemptive threads, requiring the programmer to carefully protect
    shared resources with locks and condition variables, which can be
    exceedingly error-prone.
  </p><p id="idp11026720">
    Single-threaded event-driven systems, on the other hand, execute a
    single task at a time and do not require the same kind of complex
    synchronization that preemptive threads do. However, the inverted
    control structure of an event-driven program often means that your
    own control flow has to be threaded awkwardly through the system's
    event loop, leading to a maze of event callbacks.
  </p><p id="idp11027536">
    This chapter covers the Async library, which offers a hybrid model
    that aims to provide the best of both worlds, avoiding the
    performance compromises and synchronization woes of preemptive
    threads without the confusing inversion of control that usually
    comes with event-driven systems.
  </p><section><h1 id="async-basics">Async basics</h1><p id="idp11029344">
      Consider a typical function for doing I/O in Core.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">read_all</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11030832">
      Since the function returns a concrete string, it has to block
      until the read completes. The blocking nature of the call means
      that no progress can be made on anything else until the read is
      completed, as you can see below.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Out_channel</span><span class="p">.</span><span class="n">write_all</span> <span class="s2">&quot;test.txt&quot;</span> <span class="o">~</span><span class="n">data</span><span class="o">:</span><span class="s2">&quot;This is only a test.&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">read_all</span> <span class="s2">&quot;test.txt&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;This is only a test.&quot;</span>
</pre></div><p id="idp11032768">
      In Async, well-behaved functions never block. Instead, they return
      a value of type <code>Deferred.t</code> that acts as a
      placeholder that will eventually be filled in with the result. As
      an example, consider the signature of the Async equivalent of
      <code>In_channel.read_all</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">open</span> <span class="nn">Async</span><span class="p">.</span><span class="nc">Std</span><span class="o">;;</span>
<span class="o">#</span> <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11035904">
      Note that we opened <code>Async.Std</code>, which adds a
      number of new identifiers and modules into our environment that
      make using Async more convenient. Opening
      <code>Async.Std</code> is standard practice for writing
      programs using Async, much like opening
      <code>Core.Std</code> is for using Core.
    </p><p id="idp11038704">
      A deferred is essentially a handle to a value that may be computed
      in the future. As such, if we call
      <code>Reader.file_contents</code>, the resulting deferred
      will initially be empty, as you can see by calling
      <code>Deferred.peek</code> on the resulting deferred.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">contents</span> <span class="o">=</span> <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="s2">&quot;test.txt&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">contents</span> <span class="o">:</span> <span class="kt">string</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">peek</span> <span class="n">contents</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
</pre></div><p id="idp11041952">
      The value in <code>contents</code> isn't yet determined in
      part because there's nothing running that could do the necessary
      I/O. When using Async, processing of I/O and other events is
      handled by the Async scheduler. When writing a stand-alone
      program, you need to start the scheduler explicitly, but utop
      knows about Async, and can start the scheduler automatically. More
      than that, utop knows about deferred values, and when you type in
      an expression of type <code>Deferred.t</code>, it will make
      sure the scheduler is running and block until the deferred is
      determined. Thus, we can write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">contents</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;This is only a test.</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">peek</span> <span class="n">contents</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">&quot;This is only a test.</span><span class="se">\n</span><span class="s2">&quot;</span>
</pre></div><p id="idp11045536">
      In order to do real work with deferreds, we need a way of
      sequencing deferred computations, which we do using
      <code>Deferred.bind</code>. First, let's consider the
      type-signature of bind.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">bind</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11047968">
      Thus, <code>Deferred.bind d f</code> takes a deferred value
      <code>d</code> and a function f that is to be run with the
      value of <code>d</code> once it's determined. The call to
      <code>Deferred.bind</code> returns a new deferred that
      becomes determined when the deferred returned by
      <code>f</code> is determined. It also implicitly registers
      with the scheduler an <span><em>Async job</em></span> that is
      responsible for running <code>f</code> once
      <code>d</code> is determined.
    </p><p id="idp11054016">
      Here's a simple use of bind for a function that replaces a file
      with an uppercase version of its contents.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">uppercase_file</span> <span class="n">filename</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">text</span> <span class="o">=</span> <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="n">filename</span> <span class="k">in</span>
    <span class="nn">Deferred</span><span class="p">.</span><span class="n">bind</span> <span class="n">text</span> <span class="o">(</span><span class="k">fun</span> <span class="n">text</span> <span class="o">-&gt;</span>
      <span class="nn">Writer</span><span class="p">.</span><span class="n">save</span> <span class="n">filename</span> <span class="o">~</span><span class="n">contents</span><span class="o">:(</span><span class="nn">String</span><span class="p">.</span><span class="n">uppercase</span> <span class="n">text</span><span class="o">))</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">uppercase_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">uppercase_file</span> <span class="s2">&quot;test.txt&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="s2">&quot;test.txt&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;THIS IS ONLY A TEST.&quot;</span>
</pre></div><p id="idp11055952">
      Writing out <code>Deferred.bind</code> explicitly can be
      rather verbose, and so <code>Async.Std</code> includes an
      infix operator for it: <code>&gt;&gt;=</code>. Using this
      operator, we can rewrite <code>uppercase_file</code> as
      follows.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">uppercase_file</span> <span class="n">filename</span> <span class="o">=</span>
    <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="n">filename</span>
    <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">text</span> <span class="o">-&gt;</span>
    <span class="nn">Writer</span><span class="p">.</span><span class="n">save</span> <span class="n">filename</span> <span class="o">~</span><span class="n">contents</span><span class="o">:(</span><span class="nn">String</span><span class="p">.</span><span class="n">uppercase</span> <span class="n">text</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">uppercase_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11060768">
      In the above we've dropped the parenthesis around the function on
      the right-hand side of the bind, and we didn't add a level of
      indentation for the contents of that function. This is standard
      practice for using the bind operator.
    </p><p id="idp11061424">
      Now let's look at another potential use of bind. In this case,
      we'll write a function that counts the number of lines in a file.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">count_lines</span> <span class="n">filename</span> <span class="o">=</span>
    <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="n">filename</span>
    <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">text</span> <span class="o">-&gt;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">split</span> <span class="n">text</span> <span class="o">~</span><span class="n">on</span><span class="o">:</span><span class="sc">'\n'</span><span class="o">)</span>
  <span class="o">;;</span>
</pre></div><p id="idp11063056">
      This looks reasonable enough, but when we try to compile it, we
      get the following error.
    </p><pre id="idp11063568">
Error: This expression has type int but an expression was expected of type
         'a Deferred.t
</pre><p id="idp11064336">
      The issue here is that bind expects a function that returns a
      deferred, but we've provided it a function that simply returns the
      result. To make these signatures match, we need a function for
      taking an ordinary value and wrapping it in a deferred. This
      function is a standard part of Async, and is called
      <code>return</code>:
    </p><pre id="idp11065792">
# return;;
- : 'a -&gt; 'a Deferred.t = &lt;fun&gt;
# let three = return 3;;
val three : int Deferred.t = &lt;abstr&gt;
# three;;
- : int = 3
</pre><p id="idp11066656">
      Using <code>return</code>, we can make
      <code>count_lines</code> compile.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">count_lines</span> <span class="n">filename</span> <span class="o">=</span>
    <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="n">filename</span>
    <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">text</span> <span class="o">-&gt;</span>
    <span class="n">return</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">split</span> <span class="n">text</span> <span class="o">~</span><span class="n">on</span><span class="o">:</span><span class="sc">'\n'</span><span class="o">))</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">count_lines</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11069904">
      Together, <code>bind</code> and <code>return</code>
      form a design pattern in functional programming known as a
      <span><em>monad</em></span>. You'll run across this signature in
      many applications beyond just threads. Indeed, we already ran
      across monads in
      <a href="error-handling.html#bind-and-other-error-handling-idioms">the section called “<code>bind</code> and other error-handling
      idioms”</a>.
    </p><p id="idp11073200">
      Calling <code>bind</code> and <code>return</code>
      together is a fairly common pattern, and as such there is a
      standard shortcut for it called <code>Deferred.map</code>,
      which has the following signature:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">map</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11076928">
      and comes with its own infix equivalent,
      <code>&gt;&gt;|</code>. Using it, we can rewrite
      <code>count_lines</code> again a bit more succinctly:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">count_lines</span> <span class="n">filename</span> <span class="o">=</span>
    <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="n">filename</span>
    <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="n">text</span> <span class="o">-&gt;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">split</span> <span class="n">text</span> <span class="o">~</span><span class="n">on</span><span class="o">:</span><span class="sc">'\n'</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">count_lines</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><section><h1 id="ivars-and-upon">Ivars and upon</h1><p id="idp11081280">
        Deferreds are usually built using combinations of
        <code>bind</code>, <code>map</code> and
        <code>return</code>, but sometimes you want to construct a
        deferred that you can determine explicitly with user-code. This
        is done using an <span><em>ivar</em></span>, which is a handle
        that lets you control precisely when a deferred becomes
        determined.
      </p><p id="idp11084512">
        There are three fundamental operations for working with an ivar;
        you can create one, using <code>Ivar.create</code>, you
        can read off the deferred that corresponds to the ivar in
        question, using <code>Ivar.read</code>, and you can fill
        an ivar, thus causing that deferred to become determined, using
        <code>Ivar.fill</code>. These operations are illustrated
        below.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">ivar</span> <span class="o">=</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">ivar</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">def</span> <span class="o">=</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">read</span> <span class="n">ivar</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">def</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="nn">Ivar</span><span class="p">.</span><span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">peek</span> <span class="n">def</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
<span class="o">#</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">fill</span> <span class="n">ivar</span> <span class="s2">&quot;Hello&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">peek</span> <span class="n">def</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">&quot;Hello&quot;</span>
</pre></div><p id="idp11088688">
        Ivars are something of a low-level feature; operators like map,
        bind and return are typically easier to use and think about. But
        ivars can be useful when you want to build complicated
        synchronization patterns that can't be constructed naturally
        otherwise.
      </p><p id="idp11089392">
        As an example, imagine we wanted a way of scheduling a sequence
        of actions that would run after a fixed delay. In addition, we'd
        like to guarantee that these delayed actions are executed in the
        same order they were scheduled in. One could imagine building a
        module for handling this with the following interface.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Delayer_intf</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">schedule</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp11091264">
        An action is handed to <code>schedule</code> in the form
        of a deferred-returning thunk (a thunk is a function whose
        argument is of type <code>unit</code>). A deferred is
        handed back to the caller of <code>schedule</code> that
        will eventually be filled with the contents of the deferred
        value returned by the thunk to be scheduled. We can implement
        this using an ivar which we fill after the thunk is called and
        the deferred it returns becomes determined. Instead of using
        <code>bind</code> or <code>map</code> for scheduling
        these events, we'll use a different operator called
        <code>upon</code>. Here's the signature of
        <code>upon</code>:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">upon</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11098192">
        Like <code>bind</code> and <code>return</code>,
        <code>upon</code> schedules a callback to be executed when
        the deferred it is passed is determined; but unlike those calls,
        it doesn't create a new deferred for this callback to fill.
      </p><p id="idp11100944">
        Our delayer implementation is organized around a queue of
        thunks, where every call to <code>schedule</code> adds a
        thunk to the queue, and also schedules a job in the future to
        grab a thunk off the queue and run it. The waiting will be done
        using the function <code>after</code> which takes a time
        span and returns a deferred which becomes determined after that
        time span elapses. The role of the ivar here is to take the
        value returned by the thunk and use it to fill the deferred
        returned by the provided thunk.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Delayer</span> <span class="o">:</span> <span class="nc">Delayer_intf</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">delay</span><span class="o">:</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
               <span class="n">jobs</span><span class="o">:</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="nn">Queue</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
             <span class="o">}</span>

    <span class="k">let</span> <span class="n">create</span> <span class="n">delay</span> <span class="o">=</span>
      <span class="o">{</span> <span class="n">delay</span><span class="o">;</span> <span class="n">jobs</span> <span class="o">=</span> <span class="nn">Queue</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="o">}</span>

    <span class="k">let</span> <span class="n">schedule</span> <span class="n">t</span> <span class="n">thunk</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">ivar</span> <span class="o">=</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
      <span class="nn">Queue</span><span class="p">.</span><span class="n">enqueue</span> <span class="n">t</span><span class="o">.</span><span class="n">jobs</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
        <span class="n">upon</span> <span class="o">(</span><span class="n">thunk</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">fill</span> <span class="n">ivar</span> <span class="n">x</span><span class="o">));</span>
      <span class="n">upon</span> <span class="o">(</span><span class="n">after</span> <span class="n">t</span><span class="o">.</span><span class="n">delay</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">job</span> <span class="o">=</span> <span class="nn">Queue</span><span class="p">.</span><span class="n">dequeue_exn</span> <span class="n">t</span><span class="o">.</span><span class="n">jobs</span> <span class="k">in</span>
        <span class="n">job</span> <span class="bp">()</span><span class="o">);</span>
      <span class="nn">Ivar</span><span class="p">.</span><span class="n">read</span> <span class="n">ivar</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Delayer</span> <span class="o">:</span> <span class="nc">Delayer_intf</span>
</pre></div><p id="idp11105056">
        This code isn't particularly long, but it is a bit subtle. This
        is typical of code that involves ivars and
        <code>upon</code>, and because of this, you should stick
        to the simpler map/bind/return style of working with deferreds
        when you can.
      </p></section></section><section><h1 id="examples-an-echo-server">Examples: an echo server</h1><p id="idp11107888">
      Now that we have the basics of Async under our belt, let's look at
      a small complete stand-alone Async program. In particular, we'll
      write an echo server, <span><em>i.e.</em></span>, a program that
      accepts connections from clients and spits back every line of text
      sent to it.
    </p><p id="idp11108976">
      The first step is to create a function that can copy data from an
      input to an output. Here, we'll use Async's
      <code>Reader</code> and <code>Writer</code> modules
      which provide a convenient abstraction for working with input and
      output channels.
    </p><div class="highlight"><pre><span class="c">(* filename: echo.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">open</span> <span class="nn">Async</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* Copy data from the reader to the writer, using the provided buffer</span>
<span class="c">   as scratch space *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">copy_blocks</span> <span class="n">buffer</span> <span class="n">r</span> <span class="n">w</span> <span class="o">=</span>
  <span class="nn">Reader</span><span class="p">.</span><span class="n">read</span> <span class="n">r</span> <span class="n">buffer</span>
  <span class="o">&gt;&gt;=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Eof</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="bp">()</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Ok</span> <span class="n">bytes_read</span> <span class="o">-&gt;</span>
    <span class="nn">Writer</span><span class="p">.</span><span class="n">write</span> <span class="n">w</span> <span class="n">buffer</span> <span class="o">~</span><span class="n">len</span><span class="o">:</span><span class="n">bytes_read</span><span class="o">;</span>
    <span class="nn">Writer</span><span class="p">.</span><span class="n">flushed</span> <span class="n">w</span>
    <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">copy_blocks</span> <span class="n">buffer</span> <span class="n">r</span> <span class="n">w</span>
</pre></div><p id="idp11112400">
      Bind is used in the above code to sequence the operations: first,
      we call <code>Reader.read</code> to get a block of input.
      Then, when that's complete and if a new block was returned, we
      write that block to the writer. Finally, we wait until the
      writer's buffers are flushed, waiting on the deferred returned by
      <code>Writer.flushed</code>, at which point we recur. If we
      hit an end-of-file condition, the loop is ended. The deferred
      returned by a call to <code>copy_blocks</code> becomes
      determined only once the end-of-file condition is hit.
    </p><p id="idp11115440">
      One important aspect of how this is written is that it uses
      <span><em>pushback</em></span>, which is to say that if the writer
      can't make progress writing, the reader will stop reading. If you
      don't implement pushback in your servers, then a stopped client
      can cause your program to leak memory, since you'll need to
      allocate space for the data that's been read in but not yet
      written out.
    </p><p id="idp11116688">
      Another memory leak you might be concerned with is the chain of
      deferreds that is built up as you go through the loop. After all,
      this code constructs an ever-growing chain of binds, each of which
      creates a deferred. In this case, however, all of the deferreds
      should become determined precisely when the final deferred in the
      chain is determined, in this case, when the <code>Eof</code>
      condition is hit. Because of this, we could safely replace all of
      these deferreds with a single deferred. Async has logic to do just
      this, which is essentially a form of tail-call optimization.
    </p><p id="idp11118448">
<code>copy_blocks</code> provides the logic for handling a
      client connection, but we still need to set up a server to receive
      such connections and dispatch to <code>copy_blocks</code>.
      For this, we'll use Async's <code>Tcp</code> module, which
      has a collection of utilities for creating simple TCP clients and
      servers.
    </p><div class="highlight"><pre><span class="c">(** Starts a TCP server, which listens on the specified port, invoking</span>
<span class="c">    copy_blocks every time a client connects. *)</span>
<span class="k">let</span> <span class="n">run</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">host_and_port</span> <span class="o">=</span>
    <span class="nn">Tcp</span><span class="p">.</span><span class="nn">Server</span><span class="p">.</span><span class="n">create</span>
      <span class="o">~</span><span class="n">on_handler_error</span><span class="o">:`</span><span class="nc">Raise</span>
      <span class="o">(</span><span class="nn">Tcp</span><span class="p">.</span><span class="n">on_port</span> <span class="mi">8765</span><span class="o">)</span>
      <span class="o">(</span><span class="k">fun</span> <span class="o">_</span><span class="n">addr</span> <span class="n">r</span> <span class="n">w</span> <span class="o">-&gt;</span>
         <span class="k">let</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">)</span> <span class="k">in</span>
         <span class="n">copy_blocks</span> <span class="n">buffer</span> <span class="n">r</span> <span class="n">w</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="n">ignore</span> <span class="o">(</span><span class="n">host_and_port</span> <span class="o">:</span> <span class="o">(</span><span class="nn">Socket</span><span class="p">.</span><span class="nn">Address</span><span class="p">.</span><span class="nn">Inet</span><span class="p">.</span><span class="n">t</span><span class="o">,</span> <span class="kt">int</span><span class="o">)</span> <span class="nn">Tcp</span><span class="p">.</span><span class="nn">Server</span><span class="p">.</span><span class="n">t</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</pre></div><p id="idp11122704">
      The result of calling <code>Tcp.Server.create</code> is a
      <code>Tcp.Server.t</code>, which is a handle to the server
      that lets you shut the server down. We don't use that
      functionality here, so we explicitly ignore [server] to suppress
      the unused-variables error. We put in a type annotation around the
      ignored value to make the nature of the value we're ignoring
      explicit.
    </p><p id="idp11124880">
      The most important argument to
      <code>Tcp.Server.create</code> is the final one, which is
      the client connection handler. Notably, the above code does
      nothing explicit to close down the client connections when the
      communication is done. That's because the server will
      automatically shut down the connection once the deferred returned
      by the handler becomes determined.
    </p><p id="idp11126368">
      Finally, we need to initiate the server and start the Async
      scheduler.
    </p><div class="highlight"><pre><span class="c">(* Call [run], and then start the scheduler *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">run</span> <span class="bp">()</span><span class="o">;</span>
  <span class="n">never_returns</span> <span class="o">(</span><span class="nn">Scheduler</span><span class="p">.</span><span class="n">go</span> <span class="bp">()</span><span class="o">)</span>
</pre></div><p id="idp11127904">
      One of the most common newbie errors with Async is to forget to
      run the scheduler. It can be a bewildering mistake, because
      without the scheduler, your program won't do anything at all; even
      calls to <code>printf</code> won't actually reach the
      terminal.
    </p><p id="idp11129280">
      It's worth noting that even though we didn't spend much explicit
      effort on thinking about multiple clients, this server is able to
      handle many concurrent clients without further modification.
    </p><p id="idp11129888">
      Now that we have the echo server, we can try it out using
      <code>netcat</code>.
    </p><pre id="idp11131072">
echo_server $ ./echo.native &amp;
[1] 25030
echo_server $ nc 127.0.0.1 8765
This is an echo server
This is an echo server
It repeats whatever I write.
It repeats whatever I write.
</pre><aside class="note"><h1>
    Functions that never return
    </h1><p id="idp11132848">
      You might wonder what's going on with the call to
      <code>never_returns</code> above.
      <code>never_returns</code> is an idiom that comes from
      <code>Core</code> that is used to mark functions that don't
      return. Typically, a function that doesn't return is inferred as
      having return type <code>'a</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">loop_forever</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">loop_forever</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">loop_forever</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">always_fail</span> <span class="bp">()</span> <span class="o">=</span> <span class="k">assert</span> <span class="bp">false</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">always_fail</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11137552">
      This can be surprising when you call a function like this
      expecting it to return unit, and really it never returns. The
      type-checker won't necessarily complain in such a case.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">do_stuff</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">loop_forever</span> <span class="bp">()</span><span class="o">;</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">n</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">do_stuff</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11139392">
      With a name like <code>loop_forever</code>, the meaning is
      clear enough in this case. But with something like
      <code>Scheduler.go</code>, the fact that it never returns is
      less clear, and so we use the type-system to make it more explicit
      by giving it a return type of <code>never_returns</code>. To
      make it clearer how this works, let's do the same trick with
      <code>loop_forever</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">loop_forever</span> <span class="bp">()</span> <span class="o">:</span> <span class="n">never_returns</span> <span class="o">=</span> <span class="n">loop_forever</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">loop_forever</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">never_returns</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11144080">
      The type <code>never_returns</code> is uninhabited, so a
      function can't return a value of type
      <code>never_returns</code>, which means only functions that
      never return can have it as their return type! Now, if we rewrite
      our <code>do_stuff</code> function, we'll get a helpful type
      error.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">do_stuff</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">loop_forever</span> <span class="bp">()</span><span class="o">;</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">n</span>
  <span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">unit</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="n">never_returns</span>
</pre></div><p id="idp11148256">
      We can resolve the error by calling the function
      <code>never_returns</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">never_returns</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">never_returns</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">do_stuff</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">never_returns</span> <span class="o">(</span><span class="n">loop_forever</span> <span class="bp">()</span><span class="o">);</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">n</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">do_stuff</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11150640">
      Thus, we got the compilation to go through by explicitly marking
      in the source that the call to <code>loop_forever</code>
      never returns.
    </p></aside><section><h1 id="improving-the-echo-server">Improving the echo server</h1><p id="idp11153216">
        Let's try to go a little bit farther with our echo server. Let's
        walk through a few small improvements:
      </p><ul><li><p id="idp11154256">
            Add a proper command-line interface with
            <code>Command</code>
</p></li><li><p id="idp11155792">
            Add a flag to specify the port to listen on, and a flag to
            make the server echo back the capitalized version of
            whatever was sent to it.
          </p></li><li><p id="idp11156768">
            Simplify the code using Async's <code>Pipe</code>
            interface.
          </p></li></ul><p id="idp11158208">
        Here's the improved code below.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">run</span> <span class="o">~</span><span class="n">uppercase</span> <span class="o">~</span><span class="n">port</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">host_and_port</span> <span class="o">=</span>
    <span class="nn">Tcp</span><span class="p">.</span><span class="nn">Server</span><span class="p">.</span><span class="n">create</span>
      <span class="o">~</span><span class="n">on_handler_error</span><span class="o">:`</span><span class="nc">Raise</span>
      <span class="o">(</span><span class="nn">Tcp</span><span class="p">.</span><span class="n">on_port</span> <span class="n">port</span><span class="o">)</span>
      <span class="o">(</span><span class="k">fun</span> <span class="o">_</span><span class="n">addr</span> <span class="n">r</span> <span class="n">w</span> <span class="o">-&gt;</span>
        <span class="nn">Pipe</span><span class="p">.</span><span class="n">transfer</span> <span class="o">(</span><span class="nn">Reader</span><span class="p">.</span><span class="n">pipe</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="nn">Writer</span><span class="p">.</span><span class="n">pipe</span> <span class="n">w</span><span class="o">)</span>
           <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">if</span> <span class="n">uppercase</span> <span class="k">then</span> <span class="nn">String</span><span class="p">.</span><span class="n">uppercase</span> <span class="k">else</span> <span class="nn">Fn</span><span class="p">.</span><span class="n">id</span><span class="o">))</span>
  <span class="k">in</span>
  <span class="n">ignore</span> <span class="o">(</span><span class="n">host_and_port</span> <span class="o">:</span> <span class="o">(</span><span class="nn">Socket</span><span class="p">.</span><span class="nn">Address</span><span class="p">.</span><span class="nn">Inet</span><span class="p">.</span><span class="n">t</span><span class="o">,</span> <span class="kt">int</span><span class="o">)</span> <span class="nn">Tcp</span><span class="p">.</span><span class="nn">Server</span><span class="p">.</span><span class="n">t</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="o">);</span>
  <span class="nn">Deferred</span><span class="p">.</span><span class="n">never</span> <span class="bp">()</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Command</span><span class="p">.</span><span class="n">async_basic</span>
    <span class="o">~</span><span class="n">summary</span><span class="o">:</span><span class="s2">&quot;Start an echo server&quot;</span>
    <span class="nn">Command</span><span class="p">.</span><span class="nn">Spec</span><span class="p">.</span><span class="err">(</span>
      <span class="n">empty</span>
      <span class="o">+&gt;</span> <span class="n">flag</span> <span class="s2">&quot;-uppercase&quot;</span> <span class="n">no_arg</span>
        <span class="o">~</span><span class="n">doc</span><span class="o">:</span><span class="s2">&quot; Convert to uppercase before echoing back&quot;</span>
      <span class="o">+&gt;</span> <span class="n">flag</span> <span class="s2">&quot;-port&quot;</span> <span class="o">(</span><span class="n">optional_with_default</span> <span class="mi">8765</span> <span class="kt">int</span><span class="o">)</span>
        <span class="o">~</span><span class="n">doc</span><span class="o">:</span><span class="s2">&quot; Port to listen on (default 8765)&quot;</span>
    <span class="o">)</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">uppercase</span> <span class="n">port</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">run</span> <span class="o">~</span><span class="n">uppercase</span> <span class="o">~</span><span class="n">port</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nn">Command</span><span class="p">.</span><span class="n">run</span>
</pre></div><p id="idp11160752">
        The most notable change in this function is the use of Async's
        <code>Pipe</code>. A <code>Pipe</code> is a
        communication channel that's used for connecting different parts
        of your program. You can think of it as a consumer/producer
        queue that uses deferreds for communicating when the pipe is
        ready to be read from or written to. Our use of pipes is fairly
        minimal here, but they are an important part of Async, so it's
        worth discussing them in some detail.
      </p><p id="idp11163072">
        Pipes are created in connected read/write pairs, as you can see
        below.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="nn">Pipe</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">r</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="nn">Pipe</span><span class="p">.</span><span class="nn">Reader</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">w</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="nn">Pipe</span><span class="p">.</span><span class="nn">Writer</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp11164640">
<code>r</code> and <code>w</code> are really just
        read and write handles to the same underlying object. Note that
        <code>r</code> and <code>w</code> have weakly
        polymorphic types. That's because a pipe is mutable and so can
        contain elements of only one type, which will be settled by the
        compiler once we try to use the pipe for anything.
      </p><p id="idp11168112">
        If we just try and write to the writer, we'll see that we block
        indefinitely in utop. You can break out of the wait by hitting
        <code>Control-C</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Pipe</span><span class="p">.</span><span class="n">write</span> <span class="n">w</span> <span class="s2">&quot;Hello World!&quot;</span><span class="o">;;</span>
<span class="nn">Interrupted</span><span class="p">.</span>
</pre></div><p id="idp11170432">
        The deferred returned by write completes on its own once the
        value written into the pipe has been read out:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="nn">Pipe</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">r</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="nn">Pipe</span><span class="p">.</span><span class="nn">Reader</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">w</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="nn">Pipe</span><span class="p">.</span><span class="nn">Writer</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">write_complete</span> <span class="o">=</span> <span class="nn">Pipe</span><span class="p">.</span><span class="n">write</span> <span class="n">w</span> <span class="s2">&quot;Hello World!&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">write_complete</span> <span class="o">:</span> <span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Pipe</span><span class="p">.</span><span class="n">read</span> <span class="n">r</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Eof</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ok</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Ok</span> <span class="s2">&quot;Hello World!&quot;</span>
<span class="o">#</span> <span class="n">write_complete</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp11172224">
        In the function <code>run</code> above, we're taking
        advantage of one of the many utility functions provided for
        pipes in the <code>Pipe</code> module. In particular,
        we're using <code>Pipe.transfer</code> to set up a process
        that takes data from a reader-pipe and moves it to a
        writer-pipe. Here's the type of
        <code>Pipe.transfer</code>:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Pipe</span><span class="p">.</span><span class="n">transfer</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Pipe</span><span class="p">.</span><span class="nn">Reader</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Pipe</span><span class="p">.</span><span class="nn">Writer</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11176896">
        The two pipes being connected are generated by the
        <code>Reader.pipe</code> and
        <code>Writer.pipe</code> call respectively. Note that
        pushback is preserved throughout the process, so that if the
        writer gets blocked, the writer's pipe will stop pulling data
        from the reader's pipe, which will prevent the reader from
        reading in more data.
      </p><p id="idp11179056">
        Importantly, the deferred returned by
        <code>Pipe.transfer</code> becomes determined once the
        reader has been closed and the last element is transferred from
        the reader to the writer. Once that deferred becomes determined,
        the server will shut down that client connection. So, when a
        client disconnects, the rest of the shutdown happens
        transparently.
      </p><p id="idp11180544">
        The command-line parsing for this program is based on the
        <code>Command</code> library that we introduced in
        <a href="command-line-parsing.html">Chapter 14, <i>Command Line Parsing</i></a>. When you open
        <code>Async.Std</code>, the <code>Command</code>
        module has added to it the <code>async_basic</code> call:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Command</span><span class="p">.</span><span class="n">async_basic</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">summary</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
    <span class="o">?</span><span class="n">readme</span><span class="o">:(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">string</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="nn">Command</span><span class="p">.</span><span class="nn">Spec</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nn">Command</span><span class="p">.</span><span class="n">t</span>
<span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11185792">
        This differs from the ordinary <code>Command.basic</code>
        call in that the main function must return a
        <code>Deferred.t</code>, and that the running of the
        command (using <code>Command.run</code>) automatically
        starts the async scheduler, without requiring an explicit call
        to <code>Scheduler.go</code>.
      </p></section></section><section><h1 id="example-searching-definitions-with-duckduckgo">Example: searching definitions with DuckDuckGo</h1><p id="idp11190720">
      DuckDuckGo is a search engine with a freely available search
      interface. In this section, we'll use Async to write a small
      command-line utility for querying DuckDuckGo to extract
      definitions for a collection of terms.
    </p><p id="idp11191360">
      Our code is going to rely on a number of other libraries, all of
      which can be installed using OPAM. Refer to
      <a href="installation.html">Appendix A, <i>Installation</i></a> if you need help on the
      installation. Here's the list of libraries we'll need.
    </p><ul><li><p id="idp11193184">
<code>textwrap</code>, a library for wrapping long
          lines. We'll use this for printing out our results.
        </p></li><li><p id="idp11194720">
<code>uri</code>, a library for handling URI's, or
          &quot;Uniform Resource Identifiers&quot;, of which HTTP URL's
          are an example.
        </p></li><li><p id="idp11196464">
<code>yojson</code>, a JSON parsing library that was
          described in <a href="handling-json-data.html">Chapter 15, <i>Handling JSON data</i></a>
</p></li><li><p id="idp11198736">
<code>cohttp</code>, a library for creating HTTP clients
          and servers. We need Async support, which comes with the
          <code>cohttp.async</code> package.
        </p></li></ul><p id="idp11200880">
      Now let's dive into the implementation.
    </p><section><h1 id="uri-handling">URI handling</h1><p id="idp11202480">
        You're probably familiar with HTTP URLs, which identify
        endpoints across the World Wide Web. These are actually part of
        a more general family known as Uniform Resource Identifiers
        (URIs). The full URI specification is defined in
        <a href="http://tools.ietf.org/html/rfc3986" target="_top">RFC3986</a>,
        and is rather complicated. Luckily, the <code>uri</code>
        library provides a strongly-typed interface which takes care of
        much of the hassle.
      </p><p id="idp11204704">
        We'll need a function for generating the URI's that we're going
        to use to query the DuckDuckGo servers.
      </p><div class="highlight"><pre><span class="c">(* file: search.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">open</span> <span class="nn">Async</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* Generate a DuckDuckGo search URI from a query string *)</span>
<span class="k">let</span> <span class="n">query_uri</span> <span class="n">query</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">base_uri</span> <span class="o">=</span> <span class="nn">Uri</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">&quot;http://api.duckduckgo.com/?format=json&quot;</span> <span class="k">in</span>
  <span class="nn">Uri</span><span class="p">.</span><span class="n">add_query_param</span> <span class="n">base_uri</span> <span class="o">(</span><span class="s2">&quot;q&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">query</span><span class="o">])</span>
</pre></div><p id="idp11206512">
        A <code>Uri.t</code> is constructed from the
        <code>Uri.of_string</code> function, and a query parameter
        <code>q</code> is added with the desired search query. The
        library takes care of encoding the URI correctly when outputting
        it in the network protocol.
      </p></section><section><h1 id="parsing-json-strings">Parsing JSON strings</h1><p id="idp11210480">
        The HTTP response from DuckDuckGo is in JSON, a common (and
        thankfully simple) format that is specified in
        <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_top">RFC4627</a>.
        We'll parse the JSON data using the Yojson library, which we
        already introduced in
        <a href="handling-json-data.html">Chapter 15, <i>Handling JSON data</i></a>.
      </p><p id="idp11212512">
        We expect the response from DuckDuckGo to come across as a JSON
        record, which is represented by the <code>Assoc</code> tag
        in Yojson's JSON variant. We expect the definition itself to
        come across under either the key &quot;Abstract&quot; or
        &quot;Definition&quot;, and so the code below looks under both
        keys, returning the first one for which a non-empty value is
        defined.
      </p><div class="highlight"><pre><span class="c">(* Extract the &quot;Definition&quot; or &quot;Abstract&quot; field from the DuckDuckGo results *)</span>
<span class="k">let</span> <span class="n">get_definition_from_json</span> <span class="n">json</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Safe</span><span class="p">.</span><span class="n">from_string</span> <span class="n">json</span> <span class="k">with</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="n">kv_list</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">find</span> <span class="n">key</span> <span class="o">=</span>
      <span class="k">begin</span> <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">find</span> <span class="n">kv_list</span> <span class="n">key</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">|</span> <span class="nc">Some</span> <span class="o">(`</span><span class="nc">String</span> <span class="s2">&quot;&quot;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Yojson</span><span class="p">.</span><span class="nn">Safe</span><span class="p">.</span><span class="n">to_string</span> <span class="n">s</span><span class="o">)</span>
      <span class="k">end</span>
    <span class="k">in</span>
    <span class="k">begin</span> <span class="k">match</span> <span class="n">find</span> <span class="s2">&quot;Abstract&quot;</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">_</span> <span class="k">as</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">find</span> <span class="s2">&quot;Definition&quot;</span>
    <span class="k">end</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div></section><section><h1 id="executing-an-http-client-query">Executing an HTTP client query</h1><p id="idp11217520">
        Now let's look at the code for dispatching the search queries
        over HTTP, using the Cohttp library.
      </p><div class="highlight"><pre><span class="c">(* Execute the DuckDuckGo search *)</span>
<span class="k">let</span> <span class="n">get_definition</span> <span class="n">word</span> <span class="o">=</span>
  <span class="nn">Cohttp_async</span><span class="p">.</span><span class="nn">Client</span><span class="p">.</span><span class="n">get</span> <span class="o">(</span><span class="n">query_uri</span> <span class="n">word</span><span class="o">)</span>
  <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="o">(_,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
  <span class="nn">Pipe</span><span class="p">.</span><span class="n">to_list</span> <span class="n">body</span>
  <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="n">strings</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">get_definition_from_json</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="n">strings</span><span class="o">))</span>
</pre></div><p id="idp11219552">
        To better understand what's going on, it's useful to look at the
        type for <code>Cohttp_async.Client.get</code>, which we
        can do in utop.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;cohttp.async&quot;</span><span class="o">;;</span>
<span class="o">#</span> <span class="nn">Cohttp_async</span><span class="p">.</span><span class="nn">Client</span><span class="p">.</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">?</span><span class="n">interrupt</span><span class="o">:</span><span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
    <span class="o">?</span><span class="n">headers</span><span class="o">:</span><span class="nn">Cohttp</span><span class="p">.</span><span class="nn">Header</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
    <span class="nn">Uri</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Cohttp</span><span class="p">.</span><span class="nn">Response</span><span class="p">.</span><span class="n">r</span> <span class="o">*</span> <span class="nn">Cohttp_async</span><span class="p">.</span><span class="n">body</span><span class="o">)</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span>
<span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11222208">
        The <code>get</code> call takes as a required argument a
        URI, and returns a deferred value containing a
        <code>Cohttp.Response.t</code> (which we ignore) and a
        pipe reader to which the body of the request will be written to
        as it is received.
      </p><p id="idp11224224">
        In this case, the HTTP body probably isn't very large, so we
        call <code>Pipe.to_list</code> to collect the strings from
        the pipe as a single deferred list of strings. We then join
        those strings using <code>String.concat</code> and pass
        the result through our parsing function.
      </p><p id="idp11226304">
        Running a single search isn't that interesting from a
        concurrency perspective, so let's write code for dispatching
        multiple searches in parallel. First, we need code for
        formatting and printing out the search result.
      </p><div class="highlight"><pre><span class="c">(* Print out a word/definition pair *)</span>
<span class="k">let</span> <span class="n">print_result</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">definition</span><span class="o">)</span> <span class="o">=</span>
  <span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">%s</span><span class="se">\n\n</span><span class="s2">%s</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="n">word</span>
    <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">init</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">word</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="sc">'-'</span><span class="o">))</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">definition</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="s2">&quot;No definition found&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">def</span> <span class="o">-&gt;</span>
      <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="o">(</span><span class="nn">Wrapper</span><span class="p">.</span><span class="n">wrap</span> <span class="o">(</span><span class="nn">Wrapper</span><span class="p">.</span><span class="n">make</span> <span class="mi">70</span><span class="o">)</span> <span class="n">def</span><span class="o">))</span>
</pre></div><p id="idp11228352">
        We use the <code>Wrapper</code> module from the
        <code>textwrap</code> package to do the line-wrapping. It
        may not be obvious that this routine is using Async, but it
        does: the version of <code>printf</code> that's called
        here is actually Async's specialized <code>printf</code>
        that goes through the Async scheduler rather than printing
        directly. The original definition of <code>printf</code>
        is shadowed by this new one when you open
        <code>Async.Std</code>. An important side effect of this
        is that if you write an Async program and forget to start the
        scheduler, calls like <code>printf</code> won't actually
        generate any output!
      </p><p id="idp11234272">
        The next function dispatches the searches in parallel, waits for
        the results, and then prints.
      </p><div class="highlight"><pre><span class="c">(* Run many searches in parallel, printing out the results after they're all</span>
<span class="c">   done. *)</span>
<span class="k">let</span> <span class="n">search_and_print</span> <span class="n">words</span> <span class="o">=</span>
  <span class="nn">Deferred</span><span class="p">.</span><span class="n">all</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">words</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">get_definition</span><span class="o">)</span>
  <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="n">results</span> <span class="o">-&gt;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">results</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">print_result</span>
</pre></div><p id="idp11236080">
        We used <code>List.map</code> to call
        <code>get_definition</code> on each word, and
        <code>Deferred.all</code> to wait for all the results.
        Here's the type of <code>Deferred.all</code>:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">all</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11240464">
        Note that the list returned by <code>Deferred.all</code>
        reflects the order of the deferreds passed to it. As such, the
        definitions will be printed out in the same order that the
        search words are passed in, no matter what orders the queries
        return in. We could rewrite this code to print out the results
        as they're received (and thus potentially out of order) as
        follows.
      </p><div class="highlight"><pre><span class="c">(* Run many searches in parallel, printing out the results as you go *)</span>
<span class="k">let</span> <span class="n">search_and_print</span> <span class="n">words</span> <span class="o">=</span>
  <span class="nn">Deferred</span><span class="p">.</span><span class="n">all_unit</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">words</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">word</span> <span class="o">-&gt;</span>
    <span class="n">get_definition</span> <span class="n">word</span> <span class="o">&gt;&gt;|</span> <span class="n">print_result</span><span class="o">))</span>
</pre></div><p id="idp11243232">
        The difference is that we both dispatch the query and print out
        the result in the closure passed to <code>map</code>,
        rather than waiting for all of the results to get back and then
        printing them out together. We use
        <code>Deferred.all_unit</code>, which takes a list of
        <code>unit</code> deferreds and returns a single
        <code>unit</code> deferred that becomes determined when
        every deferred on the input list is determined. We can see the
        type of this function in utop.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">all_unit</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11247936">
        Finally, we create a command line interface using
        <code>Command.async_basic</code>.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Command</span><span class="p">.</span><span class="n">async_basic</span>
    <span class="o">~</span><span class="n">summary</span><span class="o">:</span><span class="s2">&quot;Retrieve definitions from duckduckgo search engine&quot;</span>
    <span class="nn">Command</span><span class="p">.</span><span class="nn">Spec</span><span class="p">.</span><span class="err">(</span>
      <span class="n">empty</span>
      <span class="o">+&gt;</span> <span class="n">anon</span> <span class="o">(</span><span class="n">sequence</span> <span class="o">(</span><span class="s2">&quot;word&quot;</span> <span class="o">%:</span> <span class="kt">string</span><span class="o">))</span>
    <span class="o">)</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">words</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">search_and_print</span> <span class="n">words</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nn">Command</span><span class="p">.</span><span class="n">run</span>
</pre></div><p id="idp11250352">
        And that's all we need to create a simple but usable definition
        searcher.
      </p><pre id="idp11250848">
$ ./search.native &quot;Concurrent Programming&quot; &quot;OCaml&quot;
Concurrent Programming
----------------------

&quot;Concurrent computing is a form of computing in which programs are
designed as collections of interacting computational processes that
may be executed in parallel.&quot;

OCaml
-----

&quot;OCaml, originally known as Objective Caml, is the main implementation
of the Caml programming language, created by Xavier Leroy, Jérôme
Vouillon, Damien Doligez, Didier Rémy and others in 1996.&quot;
</pre></section></section><section><h1 id="exception-handling">Exception handling</h1><p id="idp11253456">
      When programming with external resources, errors are everywhere:
      everything from a flaky server to a network outage to exhausting
      of local resources can lead to a runtime error. When programming
      in OCaml, some of these errors will show up explicitly in a
      function's return type, and some of them will show up as
      exceptions. We covered exception handling in OCaml in
      <a href="error-handling.html#exceptions">the section called “Exceptions”</a>, but as we'll see,
      exception handling in a concurrent program presents some new
      challenges.
    </p><p id="idp11255536">
      Let's get a better sense of how exceptions work in Async by
      creating an asynchronous computation that (sometimes) fails with
      an exception. The function <code>maybe_raise</code> below
      blocks for half a second, and then either throws an exception or
      returns unit, alternating between the two behaviors on subsequent
      calls.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">maybe_raise</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">should_fail</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">false</span> <span class="k">in</span>
    <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">will_fail</span> <span class="o">=</span> <span class="o">!</span><span class="n">should_fail</span> <span class="k">in</span>
      <span class="n">should_fail</span> <span class="o">:=</span> <span class="n">not</span> <span class="n">will_fail</span><span class="o">;</span>
      <span class="n">after</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">of_sec</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="o">)</span>
      <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">will_fail</span> <span class="k">then</span> <span class="k">raise</span> <span class="nc">Exit</span> <span class="k">else</span> <span class="n">return</span> <span class="bp">()</span>
 <span class="o">;;</span>
<span class="k">val</span> <span class="n">maybe_raise</span> <span class="o">:</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">maybe_raise</span> <span class="bp">()</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">maybe_raise</span> <span class="bp">()</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span>
<span class="o">(</span><span class="n">lib</span><span class="o">/</span><span class="n">monitor</span><span class="o">.</span><span class="n">ml</span><span class="o">.</span><span class="nc">Error_</span>
 <span class="o">((</span><span class="n">exn</span> <span class="nc">Exit</span><span class="o">)</span> <span class="o">(</span><span class="n">backtrace</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">))</span>
  <span class="o">(</span><span class="n">monitor</span>
   <span class="o">(((</span><span class="n">name</span> <span class="n">block_on_async</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">5</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">true</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">true</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">))</span>
    <span class="o">((</span><span class="n">name</span> <span class="n">main</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">false</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">false</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">)))))).</span>
</pre></div><p id="idp11259392">
      In utop, the exception thrown by <code>maybe_raise ()</code>
      terminates the evaluation of just that expression, but in a
      stand-alone program, an uncaught exception would bring down the
      entire process.
    </p><p id="idp11260704">
      So, how could we capture and handle such an exception? You might
      try to do this using OCaml's built-in <code>try/with</code>
      statement, but as you can see below, that doesn't quite do the
      trick.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">handle_error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">try</span>
      <span class="n">maybe_raise</span> <span class="bp">()</span>
      <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;success&quot;</span>
    <span class="k">with</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="s2">&quot;failure&quot;</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">handle_error</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">handle_error</span> <span class="bp">()</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;success&quot;</span>
<span class="o">#</span> <span class="n">handle_error</span> <span class="bp">()</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span>
<span class="o">(</span><span class="n">lib</span><span class="o">/</span><span class="n">monitor</span><span class="o">.</span><span class="n">ml</span><span class="o">.</span><span class="nc">Error_</span>
 <span class="o">((</span><span class="n">exn</span> <span class="nc">Exit</span><span class="o">)</span> <span class="o">(</span><span class="n">backtrace</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">))</span>
  <span class="o">(</span><span class="n">monitor</span>
   <span class="o">(((</span><span class="n">name</span> <span class="n">block_on_async</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">58</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">true</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">true</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">))</span>
    <span class="o">((</span><span class="n">name</span> <span class="n">main</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">false</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">false</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">)))))).</span>
</pre></div><p id="idp11264048">
      This didn't work because <code>try/with</code> only captures
      exceptions that are thrown in the code directly executed within
      it, while <code>maybe_raise</code> schedules an Async job to
      run in the future, and it's that job that throws an exception.
    </p><p id="idp11266080">
      We can capture this kind of asynchronous error use the
      <code>try_with</code> function provided by Async:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">handle_error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="n">try_with</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">maybe_raise</span> <span class="bp">()</span><span class="o">)</span>
    <span class="o">&gt;&gt;|</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Ok</span> <span class="bp">()</span>   <span class="o">-&gt;</span> <span class="s2">&quot;success&quot;</span>
    <span class="o">|</span> <span class="nc">Error</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="s2">&quot;failure&quot;</span>
  <span class="o">;;</span>
<span class="o">#</span> <span class="n">handle_error</span> <span class="bp">()</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;success&quot;</span>
<span class="o">#</span> <span class="n">handle_error</span> <span class="bp">()</span><span class="o">;;</span>
  <span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;failure&quot;</span>
</pre></div><p id="idp11268688">
<code>try_with f</code> takes as its argument a
      deferred-returning thunk <code>f</code>, and returns a
      deferred that becomes determined either as <code>Ok</code>
      of whatever <code>f</code> returned, or
      <code>Error exn</code> if <code>f</code> threw an
      exception before its return value became determined.
    </p><section><h1 id="monitors">Monitors</h1><p id="idp11274576">
<code>try_with</code> is a a great way of handling
        exceptions in Async, but it's not the whole story. All of
        Async's exception-handling mechanisms,
        <code>try_with</code> included, are built on top of
        Async's system of <span><em>monitors</em></span>, which are
        inspired by the error-handling mechanism in Erlang of the same
        name. Monitors are fairly low-level and are only occasionally
        used directly, but it's nonetheless worth understanding how they
        work.
      </p><p id="idp11277248">
        In Async, a monitor is a context that determines what to do when
        there is an unhandled exception. Every Async job runs within the
        context of some monitor, which, when the job is running, is
        referred to as the current monitor. When a new Async job is
        scheduled, say, using <code>bind</code> or
        <code>map</code>, it inherits the current monitor of the
        job that spawned it.
      </p><p id="idp11279440">
        Monitors are arranged in a tree -- when a new monitor is created
        (say, using <code>Monitor.create</code>) it is a child of
        the current monitor. You can explicitly run jobs within a
        monitor using <code>within</code>, which takes a thunk
        that returns a non-deferred value, or
        <code>within'</code>, which takes a thunk that returns a
        deferred. Here's an example.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">blow_up</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">monitor</span> <span class="o">=</span> <span class="nn">Monitor</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">name</span><span class="o">:</span><span class="s2">&quot;blow up monitor&quot;</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="n">within'</span> <span class="o">~</span><span class="n">monitor</span> <span class="n">maybe_raise</span>
  <span class="o">;;</span>
<span class="o">#</span> <span class="n">blow_up</span> <span class="bp">()</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">blow_up</span> <span class="bp">()</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span>
<span class="o">(</span><span class="n">lib</span><span class="o">/</span><span class="n">monitor</span><span class="o">.</span><span class="n">ml</span><span class="o">.</span><span class="nc">Error_</span>
 <span class="o">((</span><span class="n">exn</span> <span class="nc">Exit</span><span class="o">)</span> <span class="o">(</span><span class="n">backtrace</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">))</span>
  <span class="o">(</span><span class="n">monitor</span>
   <span class="o">(((</span><span class="n">name</span> <span class="s2">&quot;blow up monitor&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">73</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">true</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">false</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">))</span>
    <span class="o">((</span><span class="n">name</span> <span class="n">block_on_async</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">72</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">false</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">true</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">))</span>
    <span class="o">((</span><span class="n">name</span> <span class="n">main</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">false</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">false</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">)))))).</span>
</pre></div><p id="idp11284992">
        In addition to the ordinary stack-trace, the exception displays
        the trace of monitors through which the exception traveled,
        starting at the one we created, called &quot;blow up
        monitor&quot;. The other monitors you see come from utop's
        special handling of deferreds.
      </p><p id="idp11285776">
        Monitors can do more than just augment the error-trace of an
        exception. You can also use a monitor to explicitly handle
        errors delivered to that monitor. The
        <code>Monitor.errors</code> call is a particularly
        important one. It detaches the monitor from its parent, handing
        back the stream of errors that would otherwise have been
        delivered to the parent monitor. This allows one to do custom
        handling of errors, which may include re-raising errors to the
        parent. Here is a very simple example of function that captures
        and ignores errors in the processes it spawns.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">swallow_error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">monitor</span> <span class="o">=</span> <span class="nn">Monitor</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="nn">Stream</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">Monitor</span><span class="p">.</span><span class="n">errors</span> <span class="n">monitor</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">_</span><span class="n">exn</span> <span class="o">-&gt;</span>
      <span class="n">printf</span> <span class="s2">&quot;an error happened</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">);</span>
    <span class="n">within'</span> <span class="o">~</span><span class="n">monitor</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="n">after</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">of_sec</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="o">)</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;Kaboom!&quot;</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">swallow_error</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">swallow_error</span> <span class="bp">()</span><span class="o">;;</span>
<span class="n">an</span> <span class="n">error</span> <span class="n">happened</span>
</pre></div><p id="idp11288960">
        The message &quot;an error happened&quot; is printed out, but
        the deferred returned by <code>swallow_error</code> is
        never determined. This makes sense, since the calculation never
        actually completes, so there's no value to return. You can break
        out of this in utop by hitting <code>Control-C</code>.
      </p><p id="idp11291168">
        Here's an example of a monitor which passes some exceptions
        through to the parent, and handles others. Exceptions are sent
        to the parent using <code>Monitor.send_exn</code>, with
        <code>Monitor.current</code> being called to find the
        current monitor, which is the parent of the newly created
        monitor.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">exception</span> <span class="nc">Ignore_me</span><span class="o">;;</span>
<span class="k">exception</span> <span class="nc">Ignore_me</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">swallow_some_errors</span> <span class="n">exn_to_raise</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">child_monitor</span>  <span class="o">=</span> <span class="nn">Monitor</span><span class="p">.</span><span class="n">create</span>  <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">parent_monitor</span> <span class="o">=</span> <span class="nn">Monitor</span><span class="p">.</span><span class="n">current</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="nn">Stream</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">Monitor</span><span class="p">.</span><span class="n">errors</span> <span class="n">child_monitor</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">error</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">Monitor</span><span class="p">.</span><span class="n">extract_exn</span> <span class="n">error</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Ignore_me</span> <span class="o">-&gt;</span> <span class="n">printf</span> <span class="s2">&quot;ignoring exn</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nn">Monitor</span><span class="p">.</span><span class="n">send_exn</span> <span class="n">parent_monitor</span> <span class="n">error</span><span class="o">);</span>
    <span class="n">within'</span> <span class="o">~</span><span class="n">monitor</span><span class="o">:</span><span class="n">child_monitor</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
       <span class="n">after</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">of_sec</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="o">)</span>
       <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">exn_to_raise</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">swallow_some_errors</span> <span class="o">:</span> <span class="n">exn</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11295312">
        Note that we use <code>Monitor.extract_exn</code> to grab
        the underlying exception that was thrown. Async wraps exceptions
        it catches with extra information, including the monitor trace,
        so you need to grab the underlying exception to match on it.
      </p><p id="idp11296672">
        If we pass in an exception other than
        <code>Ignore_me</code>, like, say, the built-in exception
        <code>Not_found</code>, then the exception will be passed
        to the parent monitor and delivered as usual.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">swallow_some_errors</span> <span class="nc">Not_found</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span>
<span class="o">(</span><span class="n">lib</span><span class="o">/</span><span class="n">monitor</span><span class="o">.</span><span class="n">ml</span><span class="o">.</span><span class="nc">Error_</span>
 <span class="o">((</span><span class="n">exn</span> <span class="nc">Not_found</span><span class="o">)</span> <span class="o">(</span><span class="n">backtrace</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">))</span>
  <span class="o">(</span><span class="n">monitor</span>
   <span class="o">(((</span><span class="n">name</span> <span class="o">(</span><span class="n">id</span> <span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">true</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">true</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">))</span>
    <span class="o">((</span><span class="n">name</span> <span class="n">block_on_async</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">true</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">true</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">))</span>
    <span class="o">((</span><span class="n">name</span> <span class="n">main</span><span class="o">)</span> <span class="o">(</span><span class="n">here</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">id</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">has_seen_error</span> <span class="bp">false</span><span class="o">)</span>
     <span class="o">(</span><span class="n">someone_is_listening</span> <span class="bp">false</span><span class="o">)</span> <span class="o">(</span><span class="n">kill_index</span> <span class="mi">0</span><span class="o">)))))).</span>
</pre></div><p id="idp11300720">
        If instead we use <code>Ignore_me</code>, the exception
        will be ignored, and we again see that the deferred never
        returns, but the exception was caught and ignored.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">swallow_some_errors</span> <span class="nc">Ignore_me</span><span class="o">;;</span>
<span class="n">ignoring</span> <span class="n">exn</span>
</pre></div><p id="idp11302992">
        In practice, you should rarely use monitors directly, instead
        using functions like <code>try_with</code> and
        <code>Monitor.protect</code> that are built on top of
        monitors. One example of a library that uses monitors directly
        is <code>Tcp.Server.create</code>, which tracks both
        exceptions thrown by the logic that handles the network
        connection and by the callback for responding to an individual
        request, in either case responding to an exception by closing
        the connection. It is for building this kind of custom error
        handling that monitors can be helpful.
      </p></section><section><h1 id="example-handling-exceptions-with-duckduckgo">Example: Handling exceptions with DuckDuckGo</h1><p id="idp11307344">
        Let's now go back and improve the exception handling of our
        DuckDuckGo client. In particular, we'll change it so that any
        individual queries that fail are reported as such, without
        preventing other queries from succeeding.
      </p><p id="idp11308000">
        The search code as it is fails rarely, so let's make a change
        that allows us to trigger failures more predictably. We'll do
        this by making it possible to distribute the requests over
        multiple servers. Then, we'll handle the errors that occur when
        one of those servers is misspecified.
      </p><p id="idp11308736">
        First we'll need to change <code>query_uri</code> to take
        an argument specifying the server to connect to, as follows.
      </p><div class="highlight"><pre><span class="c">(* Generate a DuckDuckGo search URI from a query string *)</span>
<span class="k">let</span> <span class="n">query_uri</span> <span class="o">~</span><span class="n">server</span> <span class="n">query</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">base_uri</span> <span class="o">=</span>
    <span class="nn">Uri</span><span class="p">.</span><span class="n">of_string</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">[</span><span class="s2">&quot;http://&quot;</span><span class="o">;</span><span class="n">server</span><span class="o">;</span><span class="s2">&quot;/?format=json&quot;</span><span class="o">])</span>
  <span class="k">in</span>
  <span class="nn">Uri</span><span class="p">.</span><span class="n">add_query_param</span> <span class="n">base_uri</span> <span class="o">(</span><span class="s2">&quot;q&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">query</span><span class="o">])</span>
</pre></div><p id="idp11311184">
        and then making the appropriate changes to get the list of
        servers on the command-line, and to distribute the search
        queries round-robin over the list of servers. Now, let's see
        what happens if we rebuild the application and run it giving it
        a list of servers, some of which won't respond to the query.
      </p><pre id="idp11311936">
$ ./search_with_configurable_server.native \
     -servers localhost,api.duckduckgo.com \
     &quot;Concurrent Programming&quot; OCaml
(&quot;unhandled exception&quot;
 ((lib/monitor.ml.Error_
   ((exn (Unix.Unix_error &quot;Connection refused&quot; connect 127.0.0.1:80))
    (backtrace
     (&quot;Raised by primitive operation at file \&quot;lib/unix_syscalls.ml\&quot;, line 793, characters 12-69&quot;
      &quot;Called from file \&quot;lib/deferred.ml\&quot;, line 24, characters 62-65&quot;
      &quot;Called from file \&quot;lib/scheduler.ml\&quot;, line 120, characters 6-17&quot;
      &quot;Called from file \&quot;lib/jobs.ml\&quot;, line 73, characters 8-13&quot; &quot;&quot;))
    (monitor
     (((name Tcp.close_sock_on_error) (here ()) (id 3) (has_seen_error true)
       (someone_is_listening true) (kill_index 0))
      ((name main) (here ()) (id 1) (has_seen_error true)
       (someone_is_listening false) (kill_index 0))))))
  (Pid 1352)))
</pre><p id="idp11313648">
        As you can see, we got a &quot;Connection refused&quot; failure
        which ends the entire program, even though one of the two
        queries would have gone through successfully. We can handle the
        failures of individual connections separately by using the
        <code>try_with</code> function within each call to
        <code>get_definition</code>, as follows.
      </p><div class="highlight"><pre><span class="c">(* Execute the DuckDuckGo search *)</span>
<span class="k">let</span> <span class="n">get_definition</span> <span class="o">~</span><span class="n">server</span> <span class="n">word</span> <span class="o">=</span>
  <span class="n">try_with</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="nn">Cohttp_async</span><span class="p">.</span><span class="nn">Client</span><span class="p">.</span><span class="n">get</span> <span class="o">(</span><span class="n">query_uri</span> <span class="o">~</span><span class="n">server</span> <span class="n">word</span><span class="o">)</span>
    <span class="o">&gt;&gt;=</span> <span class="k">fun</span>  <span class="o">(_,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="nn">Pipe</span><span class="p">.</span><span class="n">to_list</span> <span class="n">body</span>
    <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="n">strings</span> <span class="o">-&gt;</span>
    <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">get_definition_from_json</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="n">strings</span><span class="o">)))</span>
  <span class="o">&gt;&gt;|</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Ok</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">result</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Ok</span> <span class="n">result</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Error</span> <span class="o">_</span>          <span class="o">-&gt;</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Error</span> <span class="s2">&quot;Unexpected failure&quot;</span><span class="o">)</span>
</pre></div><p id="idp11317472">
        Here, we use <code>try_with</code> to capture the
        exception, which we then use map (the
        <code>&gt;&gt;|</code> operator) to convert the error into
        the form we want: a pair whose first element is the word being
        searched for, and the second element is the (possibly erroneous)
        result.
      </p><p id="idp11319568">
        Now we just need to change the code for
        <code>print_result</code> so that it can handle the new
        type.
      </p><div class="highlight"><pre><span class="c">(* Print out a word/definition pair *)</span>
<span class="k">let</span> <span class="n">print_result</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">definition</span><span class="o">)</span> <span class="o">=</span>
  <span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">%s</span><span class="se">\n\n</span><span class="s2">%s</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="n">word</span>
    <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">init</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">word</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="sc">'-'</span><span class="o">))</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">definition</span> <span class="k">with</span>
     <span class="o">|</span> <span class="nc">Error</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="s2">&quot;DuckDuckGo query failed: &quot;</span> <span class="o">^</span> <span class="n">s</span>
     <span class="o">|</span> <span class="nc">Ok</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="s2">&quot;No definition found&quot;</span>
     <span class="o">|</span> <span class="nc">Ok</span> <span class="o">(</span><span class="nc">Some</span> <span class="n">def</span><span class="o">)</span> <span class="o">-&gt;</span>
       <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
         <span class="o">(</span><span class="nn">Wrapper</span><span class="p">.</span><span class="n">wrap</span> <span class="o">(</span><span class="nn">Wrapper</span><span class="p">.</span><span class="n">make</span> <span class="mi">70</span><span class="o">)</span> <span class="n">def</span><span class="o">))</span>
</pre></div><p id="idp11322176">
        Now, if we run that same query, we'll get individualized
        handling of the connection failures:
      </p><pre id="idp11322688">
$ ./search_with_error_handling.native \
     -servers localhost,api.duckduckgo.com \
     &quot;Concurrent Programming&quot; OCaml
Concurrent Programming
----------------------

DuckDuckGo query failed unexpectedly

OCaml
-----

&quot;OCaml, originally known as Objective Caml, is the main implementation
of the Caml programming language, created by Xavier Leroy, Jérôme
Vouillon, Damien Doligez, Didier Rémy and others in 1996.&quot;
</pre><p id="idp11323936">
        Now, only the query that went to <code>localhost</code>
        failed.
      </p><p id="idp11325104">
        Note that in this code, we're relying on the fact that
        <code>Cohttp_async.Client.get</code> will clean up after
        itself after an exception, in particular by closing its file
        descriptors. If you need to implement such functionality
        directly, you may want to use the
        <code>Monitor.protect</code> call, which is analogous to
        the <code>protect</code> call described in
        <a href="error-handling.html#cleaning-up-in-the-presence-of-exceptions">the section called “Cleaning up in the presence of exceptions”</a>.
      </p></section></section><section><h1 id="timeouts-cancellation-and-choices">Timeouts, Cancellation and Choices</h1><p id="idp11330176">
      In a concurrent program, one often needs to combine results from
      multiple distinct concurrent sub-computations going on in the same
      program. We already saw this in our DuckDuckGo example, where we
      used <code>Deferred.all</code> and
      <code>Deferred.all_unit</code> to wait for a list of
      deferreds to become determined. Another useful primitive is
      <code>Deferred.both</code>, which lets you wait until two
      deferreds of different types have returned, returning both values
      as a tuple. Here, we use the function <code>sec</code>,
      which is shorthand for creating a time-span equal to a given
      number of seconds.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">string_and_float</span> <span class="o">=</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">both</span>
   <span class="o">(</span><span class="n">after</span> <span class="o">(</span><span class="n">sec</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="o">)</span>  <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;A&quot;</span><span class="o">)</span>
   <span class="o">(</span><span class="n">after</span> <span class="o">(</span><span class="n">sec</span> <span class="mi">0</span><span class="o">.</span><span class="mi">25</span><span class="o">)</span> <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="mi">32</span><span class="o">.</span><span class="mi">33</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">string_and_float</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">string_and_float</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">(</span><span class="s2">&quot;A&quot;</span><span class="o">,</span> <span class="mi">32</span><span class="o">.</span><span class="mi">33</span><span class="o">)</span>
</pre></div><p id="idp11335264">
      Sometimes, however, we want to wait only for the first of multiple
      events to occur. This happens particularly often when dealing with
      timeouts. In that case, we can use the call
      <code>Deferred.any</code>, which, given a list of deferreds,
      returns a single deferred that will become determined once any of
      the values on the list is determined.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">any</span> <span class="o">[</span> <span class="o">(</span><span class="n">after</span> <span class="o">(</span><span class="n">sec</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="o">)</span> <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;half a second&quot;</span><span class="o">)</span>
               <span class="o">;</span> <span class="o">(</span><span class="n">after</span> <span class="o">(</span><span class="n">sec</span> <span class="mi">10</span><span class="o">.)</span> <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;ten seconds&quot;</span><span class="o">)</span> <span class="o">]</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;half a second&quot;</span>
</pre></div><p id="idp11337904">
      Let's use this to add timeouts to our DuckDuckGo searches. We'll
      do this by writing a wrapper for <code>get_definition</code>
      that takes a timeout (in the form of a
      <code>Time.Span.t</code>) as an argument, and returns either
      the definition, or, if that takes too long, the timeout.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">get_definition_with_timeout</span> <span class="o">~</span><span class="n">server</span> <span class="o">~</span><span class="n">timeout</span> <span class="n">word</span> <span class="o">=</span>
  <span class="nn">Deferred</span><span class="p">.</span><span class="n">any</span>
    <span class="o">[</span> <span class="o">(</span><span class="n">after</span> <span class="n">timeout</span> <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="nc">Error</span> <span class="s2">&quot;Timed out&quot;</span><span class="o">))</span>
    <span class="o">;</span> <span class="o">(</span><span class="n">get_definition</span> <span class="o">~</span><span class="n">server</span> <span class="n">word</span>
       <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">result</span><span class="o">)</span> <span class="o">-&gt;</span>
       <span class="k">let</span> <span class="n">result'</span> <span class="o">=</span> <span class="k">match</span> <span class="n">result</span> <span class="k">with</span>
         <span class="o">|</span> <span class="nc">Ok</span> <span class="o">_</span> <span class="k">as</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
         <span class="o">|</span> <span class="nc">Error</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Error</span> <span class="s2">&quot;Unexpected failure&quot;</span>
       <span class="k">in</span>
       <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">result'</span><span class="o">)</span>
      <span class="o">)</span>
    <span class="o">]</span>
</pre></div><p id="idp11341344">
      We use <code>&gt;&gt;|</code> above to transform the
      deferred values we're waiting for so that
      <code>Deferred.any</code> can choose between values of the
      same type.
    </p><p id="idp11343296">
      A problem with this code is that the HTTP query kicked off by
      <code>get_definition</code> is not actually shut down when
      the timeout fires. As such,
      <code>get_definition_with_timeout</code> essentially leaks
      an open connection. Happily, Cohttp does provide a way of shutting
      down a client. You can pass a deferred under the label
      <code>interrupt</code> to
      <code>Cohttp_async.Client.get</code>. Once
      <code>interrupt</code> is determined, the client connection
      will terminated and the corresponding connections closed.
    </p><p id="idp11347696">
      The following code shows how you can change
      <code>get_definition</code> and
      <code>get_definition_with_timeout</code> to cancel the
      <code>get</code> call if the timeout expires.
    </p><div class="highlight"><pre><span class="c">(* Execute the DuckDuckGo search *)</span>
<span class="k">let</span> <span class="n">get_definition</span> <span class="o">~</span><span class="n">server</span> <span class="o">~</span><span class="n">interrupt</span> <span class="n">word</span> <span class="o">=</span>
  <span class="n">try_with</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="nn">Cohttp_async</span><span class="p">.</span><span class="nn">Client</span><span class="p">.</span><span class="n">get</span> <span class="o">~</span><span class="n">interrupt</span> <span class="o">(</span><span class="n">query_uri</span> <span class="o">~</span><span class="n">server</span> <span class="n">word</span><span class="o">)</span>
    <span class="o">&gt;&gt;=</span> <span class="k">fun</span>  <span class="o">(_,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="nn">Pipe</span><span class="p">.</span><span class="n">to_list</span> <span class="n">body</span>
    <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="n">strings</span> <span class="o">-&gt;</span>
    <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">get_definition_from_json</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="n">strings</span><span class="o">)))</span>
  <span class="o">&gt;&gt;|</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Ok</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">result</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Ok</span> <span class="n">result</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Error</span> <span class="n">exn</span>        <span class="o">-&gt;</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Error</span> <span class="n">exn</span><span class="o">)</span>
</pre></div><p id="idp11351728">
      Next, we'll modify <code>get_definition_with_timeout</code>
      to create a deferred to pass in to
      <code>get_definition</code> which will become determined
      when our timeout expires.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">get_definition_with_timeout</span> <span class="o">~</span><span class="n">server</span> <span class="o">~</span><span class="n">timeout</span> <span class="n">word</span> <span class="o">=</span>
  <span class="n">get_definition</span> <span class="o">~</span><span class="n">server</span> <span class="o">~</span><span class="n">interrupt</span><span class="o">:(</span><span class="n">after</span> <span class="n">timeout</span><span class="o">)</span> <span class="n">word</span>
  <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">result</span><span class="o">)</span> <span class="o">-&gt;</span>
  <span class="k">let</span> <span class="n">result'</span> <span class="o">=</span> <span class="k">match</span> <span class="n">result</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Ok</span> <span class="o">_</span> <span class="k">as</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="nc">Error</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Error</span> <span class="s2">&quot;Unexpected failure&quot;</span>
  <span class="k">in</span>
  <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">result'</span><span class="o">)</span>
</pre></div><p id="idp11355152">
      This will work, and will cause the connection to shut-down cleanly
      when we time out; but our code no longer explicitly knows whether
      or not the timeout has kicked in. In particular, the error message
      on a timeout will now be <code>Unexpected failure</code>
      rather than <code>Timed out</code>, which it was in our
      previous implementation. This is a minor issue in this case, but
      if we wanted to have special behavior in the case of a timeout, it
      would be a more serious issue.
    </p><p id="idp11357440">
      We can get more precise handling of timeouts using Async's
      <code>choose</code> operator, which lets you pick between a
      collection of different deferreds, reacting to exactly one of
      them. Each deferred is combined, using the function
      <code>choice</code>, with a function that is called if and
      only if that is the chosen deferred. Here's the type signature of
      <code>choice</code> and <code>choose</code>:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">choice</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">choice</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">choose</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">choice</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11362176">
<code>choose</code> provides no guarantee that the
      <code>choice</code> built around the first deferred to
      become determined will in fact be chosen. But
      <code>choose</code> does guarantee that only one
      <code>choice</code> will be chosen, and only the chosen
      <code>choice</code> will execute the attached closure.
    </p><p id="idp11366336">
      In the following, we use <code>choose</code> to ensure that
      the <code>interrupt</code> deferred becomes determined if
      and only if the timeout-deferred is chosen. Here's the code.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">get_definition_with_timeout</span> <span class="o">~</span><span class="n">server</span> <span class="o">~</span><span class="n">timeout</span> <span class="n">word</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">interrupt</span> <span class="o">=</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="n">choose</span>
    <span class="o">[</span> <span class="n">choice</span> <span class="o">(</span><span class="n">after</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
       <span class="nn">Ivar</span><span class="p">.</span><span class="n">fill</span> <span class="n">interrupt</span> <span class="bp">()</span><span class="o">;</span>
       <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="nc">Error</span> <span class="s2">&quot;Timed out&quot;</span><span class="o">))</span>
    <span class="o">;</span> <span class="n">choice</span> <span class="o">(</span><span class="n">get_definition</span> <span class="o">~</span><span class="n">server</span> <span class="o">~</span><span class="n">interrupt</span><span class="o">:(</span><span class="nn">Ivar</span><span class="p">.</span><span class="n">read</span> <span class="n">interrupt</span><span class="o">)</span> <span class="n">word</span><span class="o">)</span>
        <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">result</span><span class="o">)</span> <span class="o">-&gt;</span>
           <span class="k">let</span> <span class="n">result'</span> <span class="o">=</span> <span class="k">match</span> <span class="n">result</span> <span class="k">with</span>
             <span class="o">|</span> <span class="nc">Ok</span> <span class="o">_</span> <span class="k">as</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
             <span class="o">|</span> <span class="nc">Error</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Error</span> <span class="s2">&quot;Unexpected failure&quot;</span>
           <span class="k">in</span>
           <span class="o">(</span><span class="n">word</span><span class="o">,</span><span class="n">result'</span><span class="o">)</span>
        <span class="o">)</span>
    <span class="o">]</span>
</pre></div><p id="idp11370032">
      Now, if we run this with a suitably small timeout, we'll see that
      some queries succeed and some fail, and the timeouts are reported
      as such.
    </p><pre id="idp11370592">
$ ./search_with_timeout_no_leak.native &quot;concurrent programming&quot; ocaml -timeout 0.1s
concurrent programming
----------------------

DuckDuckGo query failed: Timed out

ocaml
-----

&quot;OCaml or Objective Caml, is the main implementation of the Caml
programming language, created by Xavier Leroy, Jérôme Vouillon,
Damien Doligez, Didier Rémy and others in 1996.&quot;
</pre></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="data-serialization-with-s-expressions.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="fast-binary-serialization.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>