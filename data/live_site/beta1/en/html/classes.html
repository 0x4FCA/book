<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 12. Classes / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta1',
                        page: 'classes.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">4. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">10. First class modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="objects.html">11. Objects</a>
                                            </li>
                                        
                                            <li>
                                                <a href="classes.html" class="here">12. Classes</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 12. Classes</h1>
                
                

    <p id="idp9703952">
    Programming with objects directly is great for encapsulation, but
    one of the main goals of object-oriented programming is code reuse
    through inheritance. For inheritance, we need to introduce
    <span><em>classes</em></span>. In object-oriented programming, a
    class is a &quot;recipe&quot; for creating objects. The recipe can
    be changed by adding new methods and fields, or it can be changed by
    modifying existing methods.
  </p><section><h1 id="ocaml-classes">OCaml Classes</h1><p id="idp9706576">
      In OCaml, class definitions must be defined as toplevel statements
      in a module. A class is not an object, and a class definition is
      not an expression. The syntax for a class definition uses the
      keyword <code>class</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">point</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">y</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">point</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span>
</pre></div><p id="idp9709424">
      The type <code>class point : ... end</code> is a
      <span><em>class type</em></span>. This particular type specifies
      that the <code>point</code> class defines a mutable field
      <code>x</code>, a method <code>get</code> that returns
      an <code>int</code>, and a method <code>set</code>
      with type <code>int -&gt; unit</code>.
    </p><p id="idp9715248">
      To produce an object, classes are instantiated with the keyword
      <code>new</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">point</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">p</span> <span class="o">:</span> <span class="n">point</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div><p id="idp9717664">
      Inheritance uses an existing class to define a new one. For
      example, the following class definition supports an addition
      method <code>moveby</code> that moves the point by a
      relative amount.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">movable_point</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
    <span class="k">inherit</span> <span class="n">point</span>
    <span class="k">method</span> <span class="n">moveby</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="o">(</span><span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="o">+</span> <span class="n">dx</span><span class="o">)</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">movable_point</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">moveby</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
    <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span>
</pre></div><p id="idp9720352">
      This new <code>movable_point</code> class also makes use of
      the <code>(self : 'self)</code> binding after the
      <code>object</code> keyword. The variable
      <code>self</code> stands for the current object, allowing
      self-invocation, and the type variable <code>'self</code>
      stands for the type of the current object (which in general is a
      subtype of <code>movable_point</code>).
    </p></section><section><h1 id="an-example-cryptokit">An Example: Cryptokit</h1><p id="idp9726512">
      Let's take a break from describing the object system with a more
      practical example that uses the OCaml cryptographic library.
    </p><aside class="note"><h1>
    Installing the Cryptokit library
    </h1><p id="idp9727760">
      The Cryptokit library can be installed via OPAM via
      <code>opam install cryptokit</code>. Once that's finished
      compiling and installing, you just need to
      <code>#require &quot;cryptokit&quot;</code> in your toplevel
      to load the library and make the modules available.
    </p></aside><p id="idp9729920">
      Our first example mimics the <code>md5</code> command, which
      reads in an input file and returns a hexadecimal representation of
      its MD5 cryptographic hash. Cryptokit defines a number of
      different functions and collects them together under the
      <code>Cryptokit.hash</code> class type:
    </p><div class="highlight"><pre><span class="k">class</span> <span class="k">type</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">object</span>
  <span class="k">method</span> <span class="n">add_byte</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">method</span> <span class="n">add_char</span> <span class="o">:</span> <span class="kt">char</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">method</span> <span class="n">add_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">method</span> <span class="n">add_substring</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">method</span> <span class="n">hash_size</span> <span class="o">:</span> <span class="kt">int</span>
  <span class="k">method</span> <span class="n">result</span> <span class="o">:</span> <span class="kt">string</span>
  <span class="k">method</span> <span class="n">wipe</span> <span class="o">:</span> <span class="kt">unit</span>
<span class="k">end</span>

<span class="k">val</span> <span class="n">hash_string</span> <span class="o">:</span> <span class="n">hash</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</pre></div><p id="idp9733552">
      Concrete hash objects can be instantiated from various sub-modules
      in Cryptokit. The simplest ones such as MD5 or SHA1 do not take
      any special input parameters to build the object. The
      <code>hmac_sha1</code> takes a string key to initialise the
      Message Authenticate Code for that particular hash function.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Cryptokit</span><span class="p">.</span><span class="nn">Hash</span><span class="p">.</span><span class="n">md5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Cryptokit</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Cryptokit</span><span class="p">.</span><span class="nn">Hash</span><span class="p">.</span><span class="n">sha1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Cryptokit</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Cryptokit</span><span class="p">.</span><span class="nn">MAC</span><span class="p">.</span><span class="n">hmac_sha1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Cryptokit</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9736128">
      Hash objects hold state and are thus naturally imperative. Once
      instantiated, data is fed into them by the addition functions, the
      <code>result</code> is computed and finally the contents
      erased via <code>wipe</code>. The
      <code>hash_string</code> convenience function applies the
      hash function fully to a string, and returns the result. The
      <code>md5</code> command is quite straight-forward now:
    </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">open</span> <span class="nc">Cryptokit</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">In_channel</span><span class="p">.</span><span class="err">(</span><span class="n">input_all</span> <span class="n">stdin</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="n">hash_string</span> <span class="o">(</span><span class="nn">Hash</span><span class="p">.</span><span class="n">md5</span> <span class="bp">()</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="n">transform_string</span> <span class="o">(</span><span class="nn">Hexa</span><span class="p">.</span><span class="n">encode</span> <span class="bp">()</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="n">print_endline</span>
</pre></div><p id="idp9740960">
      After opening the right modules, we read in the entire standard
      input into an OCaml string. This is then passed onto the MD5 hash
      function, which returns a binary string. This binary is passed
      through the <code>Hexa</code> hexadecimal encoder, which
      returns an ASCII representation of the input. The output of this
      command will be the same as the <code>md5</code> command (or
      <code>md5sum</code> in some systems).
    </p><p id="idp9743840">
      We can extend this simple example by selecting either the
      <code>md5</code> or <code>sha1</code> hash function at
      runtime depending on the name of our binary.
      <code>Sys.argv</code> is an array containing the arguments
      the command was invoked with, and the first entry is the name of
      the binary itself.
    </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">open</span> <span class="nc">Cryptokit</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">hash_fn</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">Filename</span><span class="p">.</span><span class="n">basename</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">argv</span><span class="o">.(</span><span class="mi">0</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span><span class="s2">&quot;md5&quot;</span> <span class="o">-&gt;</span> <span class="nn">Hash</span><span class="p">.</span><span class="n">md5</span> <span class="bp">()</span>
    <span class="o">|</span><span class="s2">&quot;sha1&quot;</span> <span class="o">-&gt;</span> <span class="nn">Hash</span><span class="p">.</span><span class="n">sha1</span> <span class="bp">()</span>
    <span class="o">|_</span> <span class="o">-&gt;</span> <span class="nn">Hash</span><span class="p">.</span><span class="n">md5</span> <span class="bp">()</span>
  <span class="k">in</span>
  <span class="nn">In_channel</span><span class="p">.</span><span class="err">(</span><span class="n">input_all</span> <span class="n">stdin</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="n">hash_string</span> <span class="n">hash_fn</span>
  <span class="o">|&gt;</span> <span class="n">transform_string</span> <span class="o">(</span><span class="nn">Hexa</span><span class="p">.</span><span class="n">encode</span> <span class="bp">()</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="n">print_endline</span>
</pre></div><p id="idp9748000">
      Now let's try something more advanced. The
      <code>openssl</code> library is installed on most systems,
      and can be used to encrypt plaintext using several encryption
      strategies. At its simplest, it will take a secret phrase and
      derive an appropriate key and initialisation vector.
    </p><pre id="idp9749408">
$ openssl enc -nosalt -aes-128-cbc -base64 -k &quot;ocaml&quot; -P
key=6217C07FF169F6AB2EB2731F855095F1
iv =8164D5477E66E6A9EC99A8D58ACAADAF
</pre><p id="idp9750432">
      We've selected the <code>-nosalt</code> option here to make
      the output deterministic, and the <code>-P</code> option
      prints out the derived key and IV and exits. The algorithm used to
      derive these results is described in the
      <code>man EVP_BytesToKey</code> manual page (you may need to
      install the OpenSSL documentation packages on your system first).
      We can implement this derivation function using an imperative
      style:
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">md5</span> <span class="n">s</span> <span class="o">=</span> <span class="n">hash_string</span> <span class="o">(</span><span class="nn">Hash</span><span class="p">.</span><span class="n">md5</span> <span class="bp">()</span><span class="o">)</span> <span class="n">s</span>

<span class="k">let</span> <span class="n">evp_byte_to_key</span> <span class="n">password</span> <span class="n">tlen</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">o</span> <span class="o">=</span> <span class="nn">Hexa</span><span class="p">.</span><span class="n">encode</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="n">md5</span> <span class="n">password</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">o</span><span class="o">#</span><span class="n">put_string</span> <span class="o">!</span><span class="n">v</span><span class="o">;</span>
  <span class="k">while</span> <span class="n">o</span><span class="o">#</span><span class="n">available_output</span><span class="o">/</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">tlen</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">md5</span> <span class="o">(!</span><span class="n">v</span> <span class="o">^</span> <span class="n">password</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">o</span><span class="o">#</span><span class="n">put_string</span> <span class="n">n</span><span class="o">;</span>
    <span class="n">v</span> <span class="o">:=</span> <span class="n">n</span><span class="o">;</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="nn">String</span><span class="p">.</span><span class="n">uppercase</span> <span class="n">o</span><span class="o">#</span><span class="n">get_string</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">secret</span> <span class="o">=</span> <span class="s2">&quot;ocaml&quot;</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">key_len</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">iv_len</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">evp_byte_to_key</span> <span class="n">secret</span> <span class="o">(</span><span class="n">key_len</span><span class="o">+</span><span class="n">iv_len</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">sub</span> <span class="n">x</span> <span class="o">~</span><span class="n">pos</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">len</span><span class="o">:</span><span class="n">key_len</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">iv</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">sub</span> <span class="n">x</span> <span class="o">~</span><span class="n">pos</span><span class="o">:</span><span class="n">key_len</span> <span class="o">~</span><span class="n">len</span><span class="o">:</span><span class="n">iv_len</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;key=%s</span><span class="se">\n</span><span class="s2">iv =%s</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">key</span> <span class="n">iv</span>
</pre></div><p id="idp9755472">
      The derivation algorithm takes an input password and desired total
      length (the addition of the key and IV length). It initialises a
      <code>Hexa.encode</code> transformer, which will accept
      arbitrary binary data and output a hexadecimal string (with two
      output bytes per input byte). A reference stores the last digest
      that's been calculated, and then the algorithm iterates until it
      has sufficient data to satisfy the required key length.
    </p><p id="idp9757024">
      Notice how the encoder object is used as an accumulator, by using
      the <code>put_string</code> and
      <code>available_output</code> to keep track of progress.
      Objects don't <span><em>require</em></span> an imperative style
      though, and the same algorithm can be written more functionally:
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">evp_byte_to_key</span> <span class="n">password</span> <span class="n">tlen</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">acc</span> <span class="n">v</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">acc</span> <span class="o">&lt;</span> <span class="n">tlen</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">true</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">md5</span> <span class="o">(</span><span class="n">v</span> <span class="o">^</span> <span class="n">password</span><span class="o">)</span> <span class="k">in</span>
      <span class="n">aux</span> <span class="o">(</span><span class="n">acc</span><span class="o">^</span><span class="n">v</span><span class="o">)</span> <span class="n">v</span>
    <span class="o">|</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="n">acc</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">md5</span> <span class="n">password</span> <span class="k">in</span>
  <span class="nn">String</span><span class="p">.</span><span class="n">uppercase</span> <span class="o">(</span><span class="n">transform_string</span> <span class="o">(</span><span class="nn">Hexa</span><span class="p">.</span><span class="n">encode</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">aux</span> <span class="n">v</span> <span class="n">v</span><span class="o">))</span>
</pre></div><p id="idp9760944">
      In this version, we don't use any references, and instead a
      recursive function keeps track of the last digest in use and the
      accumulated result string. This version isn't quite as efficient
      as the previous one due to the careless use of string
      concatenation for the accumulator, but this can easily be fixed by
      using the <code>Buffer</code> module instead.
    </p></section><section><h1 id="class-parameters-and-polymorphism">Class parameters and polymorphism</h1><p id="idp9763696">
      A class definition serves as the <span><em>constructor</em></span>
      for the class. In general, a class definition may have parameters
      that must be provided as arguments when the object is created with
      <code>new</code>.
    </p><p id="idp9765424">
      Let's build an example of an imperative singly-linked list using
      object-oriented techniques. First, we'll want to define a class
      for a single element of the list. We'll call it a
      <code>node</code>, and it will hold a value of type
      <code>'a</code>. When defining the class, the type
      parameters are placed in square brackets before the class name in
      the class definition. We also need a parameter
      <code>x</code> for the initial value.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span>
<span class="k">object</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>

  <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">method</span> <span class="n">set</span> <span class="n">x</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;-</span> <span class="n">x</span>

  <span class="k">method</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next_node</span>
  <span class="k">method</span> <span class="n">set_next</span> <span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span> <span class="o">&lt;-</span> <span class="n">node</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9769568">
      The <code>value</code> is the value stored in the node, and
      it can be retrieved and changed with the <code>get</code>
      and <code>set</code> methods. The
      <code>next_node</code> field is the link to the next element
      in the stack. Note that the type parameter <code>['a]</code>
      in the definition uses square brackets, but other uses of the type
      can omit them (or use parentheses if there is more than one type
      parameter).
    </p><p id="idp9773808">
      The type annotations on the <code>val</code> declarations
      are used to constrain type inference. If we omit these
      annotations, the type inferred for the class will be &quot;too
      polymorphic,&quot; <code>x</code> could have some type
      <code>'b</code> and <code>next_node</code> some type
      <code>'c option</code>.
    </p><div class="highlight"><pre>  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">=</span> <span class="nc">None</span>

    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">x</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;-</span> <span class="n">x</span>

    <span class="k">method</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next_node</span>
    <span class="k">method</span> <span class="n">set_next</span> <span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span> <span class="o">&lt;-</span> <span class="n">node</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Some</span> <span class="k">type</span> <span class="n">variables</span> <span class="n">are</span> <span class="n">unbound</span> <span class="k">in</span> <span class="n">this</span> <span class="k">type</span><span class="o">:</span>
         <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="o">:</span>
           <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span>
           <span class="k">object</span>
             <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span>
             <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span>
             <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span>
             <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span>
             <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
             <span class="k">method</span> <span class="n">set_next</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
           <span class="k">end</span>
       <span class="nc">The</span> <span class="k">method</span> <span class="n">get</span> <span class="n">has</span> <span class="k">type</span> <span class="k">'</span><span class="n">b</span> <span class="n">where</span> <span class="k">'</span><span class="n">b</span> <span class="n">is</span> <span class="n">unbound</span>
</pre></div><p id="idp9779744">
      In general, we need to provide enough constraints so that the
      compiler will infer the correct type. We can add type constraints
      to the parameters, to the fields, and to the methods. It is a
      matter of preference how many constraints to add. You can add type
      constraints in all three places, but the extra text may not help
      clarity. A convenient middle ground is to annotate the fields
      and/or class parameters, and add constraints to methods only if
      necessary.
    </p><p id="idp9780656">
      Next, we can define the list itself. We'll keep a field
      <code>head</code> that refers to the first element in the
      list, and <code>last</code> that refers to the final element
      in the list. The method <code>insert</code> adds an element
      to the end of the list.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span>
<span class="k">object</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="n">first</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="n">last</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>

   <span class="k">method</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="nc">None</span>

   <span class="k">method</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Some</span> <span class="o">(</span><span class="k">new</span> <span class="n">node</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">last</span> <span class="k">with</span>
         <span class="nc">Some</span> <span class="n">last_node</span> <span class="o">-&gt;</span>
            <span class="n">last_node</span><span class="o">#</span><span class="n">set_next</span> <span class="n">new_node</span><span class="o">;</span>
            <span class="n">last</span> <span class="o">&lt;-</span> <span class="n">new_node</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
            <span class="n">first</span> <span class="o">&lt;-</span> <span class="n">new_node</span><span class="o">;</span>
            <span class="n">last</span> <span class="o">&lt;-</span> <span class="n">new_node</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="object-types">Object types</h1><p id="idp9786096">
      This definition of the class <code>slist</code> is not
      complete, we can construct lists, but we also need to add the
      ability to traverse the elements in the list. One common style for
      doing this is to define a class for an <code>iterator</code>
      object. An iterator provides a generic mechanism to inspect and
      traverse the elements of a collection. This pattern isn't
      restricted to lists, it can be used for many different kinds of
      collections.
    </p><p id="idp9788352">
      There are two common styles for defining abstract interfaces like
      this. In Java, an iterator would normally be specified with an
      interface, which specifies a set of method types. In languages
      without interfaces, like C++, the specification would normally use
      <span><em>abstract</em></span> classes to specify the methods
      without implementing them (C++ uses the &quot;= 0&quot; definition
      to mean &quot;not implemented&quot;).
    </p><div class="highlight"><pre><span class="c1">// Java-style iterator, specified as an interface.</span>
<span class="kd">interface</span> <span class="err">&lt;</span><span class="nc">T</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">{</span>
  <span class="n">T</span> <span class="nf">Get</span><span class="o">();</span>
  <span class="kt">boolean</span> <span class="nf">HasValue</span><span class="o">();</span>
  <span class="kt">void</span> <span class="nf">Next</span><span class="o">();</span>
<span class="o">};</span>

<span class="c1">// Abstract class definition in C++.</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kd">class</span> <span class="nc">Iterator</span> <span class="o">{</span>
 <span class="kd">public</span><span class="o">:</span>
  <span class="n">virtual</span> <span class="o">~</span><span class="n">Iterator</span><span class="o">()</span> <span class="o">{}</span>
  <span class="n">virtual</span> <span class="n">T</span> <span class="nf">get</span><span class="o">()</span> <span class="kd">const</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">virtual</span> <span class="n">bool</span> <span class="nf">has_value</span><span class="o">()</span> <span class="kd">const</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">virtual</span> <span class="kt">void</span> <span class="nf">next</span><span class="o">()</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">};</span>
</pre></div><p id="idp9791056">
      OCaml support both styles. In fact, OCaml is more flexible than
      these approaches because an object type can be implemented by any
      object with the appropriate methods; it does not have to be
      specified by the object's class <span><em>a priori</em></span>.
      We'll leave abstract classes for later. Let's demonstrate the
      technique using object types.
    </p><p id="idp9792240">
      First, we'll define an object type <code>iterator</code>
      that specifies the methods in an iterator.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;;;</span>
</pre></div><p id="idp9794560">
      Next, we'll define an actual iterator for the class
      <code>slist</code>. We can represent the position in the
      list with a field <code>current</code>, following links as
      we traverse the list.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="n">cur</span> <span class="o">=</span>
<span class="k">object</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">current</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="n">cur</span>

  <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">current</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>

  <span class="k">method</span> <span class="n">get</span> <span class="o">=</span>
     <span class="k">match</span> <span class="n">current</span> <span class="k">with</span>
        <span class="nc">Some</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">node</span><span class="o">#</span><span class="n">get</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;no value&quot;</span><span class="o">)</span>

  <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
     <span class="k">match</span> <span class="n">current</span> <span class="k">with</span>
        <span class="nc">Some</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">current</span> <span class="o">&lt;-</span> <span class="n">node</span><span class="o">#</span><span class="n">next</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;no value&quot;</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9797952">
      Finally, we add a method <code>iterator</code> to the slist
      class to produce an iterator. To do so, we construct an
      <code>slist_iterator</code> that refers to the first node in
      the list, but we want to return a value with the object type
      <code>iterator</code>. This requires an explicit coercion
      using the <code>:&gt;</code> operator.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span> <span class="k">object</span>
<span class="o">...</span>
   <span class="k">method</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">slist_iterator</span> <span class="n">first</span> <span class="o">:&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span><span class="o">)</span>
<span class="k">end</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">slist</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="o">#</span><span class="n">iterator</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9803184">
      We may also wish to define functional-style methods,
      <code>iter f</code> takes a function <code>f</code>
      and applies it to each of the elements of the list.
    </p><div class="highlight"><pre><span class="k">method</span> <span class="n">iter</span> <span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
  <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
    <span class="n">f</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span>
    <span class="n">it</span><span class="o">#</span><span class="n">next</span>
  <span class="k">done</span>
</pre></div><p id="idp9806144">
      What about functional operations similar to
      <code>List.map</code> or <code>List.fold</code>? In
      general, these methods take a function that produces a value of
      some other type than the elements of the set. For example, the
      function <code>List.fold</code> has type
      <code>'a list -&gt; ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</code>,
      where <code>'b</code> is an arbitrary type. To replicate
      this in the <code>slist</code> class, we need a method type
      <code>('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</code>, where
      the method type is polymorphic over <code>'b</code>.
    </p><p id="idp9812576">
      The solution is to use a type quantifier, as shown in the
      following example. The method type must be specified directly
      after the method name, which means that method parameters must be
      expressed using a <code>fun</code> or
      <code>function</code> expression.
    </p><div class="highlight"><pre><span class="k">method</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="o">.</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
   <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span>
         <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">x</span> <span class="k">in</span>
         <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
         <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
            <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">!</span><span class="n">y</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
            <span class="n">it</span><span class="o">#</span><span class="n">next</span>
         <span class="k">done</span><span class="o">;</span>
         <span class="o">!</span><span class="n">y</span><span class="o">)</span>
</pre></div></section><section><h1 id="class-types">Class types</h1><p id="idp9817392">
      Once we have defined the list implementation, the next step is to
      wrap it in a module or <code>.ml</code> file and give it a
      type so that it can be used in the rest of our code. What is the
      type?
    </p><p id="idp9818720">
      Before we begin, let's wrap up the implementation in an explicit
      module (we'll use explicit modules for illustration, but the
      process is similar when we want to define a
      <code>.mli</code> file). In keeping with the usual style for
      modules, we define a type <code>'a t</code> to represent the
      type of list values.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">SList</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>
   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>
   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>

   <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span> <span class="k">new</span> <span class="n">slist</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9822560">
      We have multiple choices in defining the module type, depending on
      how much of the implementation we want to expose. At one extreme,
      a maximally-abstract signature would completely hide the class
      definitions.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">AbstractSList</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

   <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">end</span> <span class="o">=</span> <span class="nc">SList</span>
</pre></div><p id="idp9824384">
      The abstract signature is simple because we ignore the classes.
      But what if we want to include them in the signature, so that
      other modules can inherit from the class definitions? For this, we
      need to specify types for the classes, called <span><em>class
      types</em></span>. Class types do not appear in mainstream
      object-oriented programming languages, so you may not be familiar
      with them, but the concept is pretty simple. A class type
      specifies the type of each of the visible parts of the class,
      including both fields and methods. Just like for module types, you
      don't have to give a type for everything; anything you omit will
      be hidden.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">VisibleSList</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span>
  <span class="k">object</span>
     <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span>
     <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
     <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
     <span class="k">method</span> <span class="n">set_next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">-&gt;</span>
  <span class="k">object</span>
     <span class="k">method</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span>
     <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span>
     <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">first</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">last</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
    <span class="k">method</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span>
    <span class="k">method</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
    <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
  <span class="k">end</span>

  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">slist</span>
<span class="k">end</span> <span class="o">=</span> <span class="nc">SList</span>
</pre></div><p id="idp9828480">
      In this signature, we've chosen to make nearly everything visible.
      The class type for <code>slist</code> specifies the types of
      the fields <code>first</code> and <code>last</code>,
      as well as the types of each of the methods. We've also included a
      class type for <code>slist_iterator</code>, which is of
      somewhat more questionable value, since the type doesn't appear in
      the type for <code>slist</code> at all.
    </p><p id="idp9832784">
      One more thing, in this example the function
      <code>make</code> has type
      <code>unit -&gt; 'a slist</code>. But wait, we've stressed
      <span><em>classes are not types</em></span>, so what's up with
      that? In fact, what we've said is entirely true, classes and class
      names <span><em>are not</em></span> types. However, class names can
      be used to stand for types. When the compiler sees a class name in
      type position, it automatically constructs an object type from it
      by erasing all the fields and keeping only the method types. In
      this case, the type expression <code>'a slist</code> is
      exactly equivalent to <code>'a t</code>.
    </p><section><h1 id="binary-methods">Binary methods</h1><p id="idp9838544">
        A <span><em>binary method</em></span> is a method that takes an
        object of <code>self</code> type. One common example is
        defining a method for equality.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">square</span> <span class="n">w</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> 
    <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">width</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">square</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="k">object</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">method</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">rectangle</span> <span class="n">w</span> <span class="n">h</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
    <span class="k">method</span> <span class="n">height</span> <span class="o">=</span> <span class="n">h</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">height</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">width</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="o">#</span><span class="n">height</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">height</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">...</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">)#</span><span class="n">equals</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">rectangle</span> <span class="mi">5</span> <span class="mi">6</span><span class="o">)#</span><span class="n">equals</span> <span class="o">(</span><span class="k">new</span> <span class="n">rectangle</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9842416">
        This works, but there is a problem lurking here. The method
        <code>equals</code> takes an object of the exact type
        <code>square</code> or <code>rectangle</code>.
        Because of this, we can't define a common base class
        <code>shape</code> that also includes an equality method.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">sq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="o">(</span><span class="n">sq</span> <span class="o">:&gt;</span> <span class="n">shape</span><span class="o">);;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">13</span><span class="o">:</span>
  <span class="o">(</span><span class="n">sq</span> <span class="o">:&gt;</span> <span class="n">shape</span><span class="o">);;</span>
  <span class="o">^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Type</span> <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">square</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span>
       <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">subtype</span> <span class="k">of</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">&gt;</span> 
<span class="nc">Type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">&gt;</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">subtype</span> <span class="k">of</span>
  <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">square</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span> 
</pre></div><p id="idp9847456">
        The problem is that a <code>square</code> expects to be
        compared with a <code>square</code>, not an arbitrary
        shape; similarly for <code>rectangle</code>.
      </p><p id="idp9850096">
        This problem is fundamental. Many languages solve it either with
        narrowing (with dynamic type checking), or by method
        overloading. Since OCaml has neither of these, what can we do?
      </p><p id="idp9850704">
        One proposal we could consider is, since the problematic method
        is equality, why not just drop it from the base type
        <code>shape</code> and use polymorphic equality instead?
        Unfortunately, the builtin equality has very poor behavior when
        applied to objects.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">(</span><span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">end</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">end</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9853120">
        The problem here is that the builtin polymorphic equality
        compares the method implementations, not their return values.
        The method implementations (the function values that implement
        the methods) are different, so the equality comparison is false.
        There are other reasons not to use the builtin polymorphic
        equality, but these false negatives are a showstopper.
      </p><p id="idp9853936">
        If we want to define equality for shapes in general, the
        remaining solution is to use the same approach as we described
        for narrowing. That is, introduce a
        <span><em>representation</em></span> type implemented using
        variants, and implement the comparison based on the
        representation type.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">shape_repr</span> <span class="o">=</span>
 <span class="o">|</span> <span class="nc">Square</span> <span class="k">of</span> <span class="kt">int</span>
 <span class="o">|</span> <span class="nc">Circle</span> <span class="k">of</span> <span class="kt">int</span>
 <span class="o">|</span> <span class="nc">Rectangle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">;;</span>
 
<span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;;;</span>

<span class="k">class</span> <span class="n">square</span> <span class="n">w</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
  <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
  <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">method</span> <span class="n">repr</span> <span class="o">=</span> <span class="nc">Square</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="n">shape</span><span class="o">)</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">repr</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">repr</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9856800">
        The binary method <code>equals</code> is now implemented
        in terms of the concrete type <code>shape_repr</code>. In
        fact, the objects are now isomorphic to the
        <code>shape_repr</code> type. When using this pattern, you
        will not be able to hide the <code>repr</code> method, but
        you can hide the type definition using the module system.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Shapes</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">shape_repr</span>
  <span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">&gt;</span>
  
  <span class="k">class</span> <span class="n">square</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span>
    <span class="k">object</span>
      <span class="k">method</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span>
      <span class="k">method</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span>
      <span class="k">method</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span>
      <span class="k">method</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">shape_repr</span> <span class="o">=</span> <span class="nc">Square</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Circle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Rectangle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
  <span class="o">...</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section></section><section><h1 id="private-methods">Private methods</h1><p id="idp9863376">
      Methods can be declared <span><em>private</em></span>, which means
      that they may be called by subclasses, but they are not visible
      otherwise (similar to a <span><em>protected</em></span> method in
      C++).
    </p><p id="idp9864816">
      To illustrate, let's build a class <code>vector</code> that
      contains an array of integers, resizing the storage array on
      demand. The field <code>values</code> contains the actual
      values, and the <code>get</code>, <code>set</code>,
      and <code>length</code> methods implement the array access.
      For clarity, the resizing operation is implemented as a private
      method <code>ensure_capacity</code> that resizes the array
      if necessary.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">vector</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">val</span> <span class="k">mutable</span> <span class="n">values</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[||]</span>
  
     <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">set</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span>
        <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="n">i</span><span class="o">;</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">x</span>
     <span class="k">method</span> <span class="n">length</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span>
  
     <span class="k">method</span> <span class="k">private</span> <span class="n">ensure_capacity</span> <span class="n">i</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">self</span><span class="o">#</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="k">then</span>
           <span class="k">let</span> <span class="n">new_values</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">in</span>
           <span class="nn">Array</span><span class="p">.</span><span class="n">blit</span> <span class="n">values</span> <span class="mi">0</span> <span class="n">new_values</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span><span class="o">);</span>
           <span class="n">values</span> <span class="o">&lt;-</span> <span class="n">new_values</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">get</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="kt">int</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="mi">10</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span>
  <span class="n">v</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="mi">10</span><span class="o">;;</span>
  <span class="o">^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="n">vector</span>
       <span class="nc">It</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">ensure_capacity</span>
</pre></div><p id="idp9871760">
      To be precise, the method <code>ensure_capacity</code> is
      part of the class type, but it is not part of the object type.
      This means the object <code>v</code> has no method
      <code>ensure_capacity</code>. However, it is available to
      subclasses. We can extend the class, for example, to include a
      method <code>swap</code> that swaps two elements.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">swappable_vector</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">inherit</span> <span class="n">vector</span>

     <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
        <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="o">(</span><span class="n">max</span> <span class="n">i</span> <span class="n">j</span><span class="o">);</span>
        <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">);</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9876560">
      Yet another reason for private methods is to factor the
      implementation and support recursion. Moving along with this
      example, let's build a binary heap, which is a binary tree in heap
      order: where the label of parent elements is smaller than the
      labels of its children. One efficient implementation is to use an
      array to represent the values, where the root is at index 0, and
      the children of a parent node at index <code>i</code> are at
      indexes <code>2 * i</code> and <code>2 * i + 1</code>.
      To insert a node into the tree, we add it as a leaf, and then
      recursively move it up the tree until we restore heap order.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">binary_heap</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">values</span> <span class="o">=</span> <span class="k">new</span> <span class="n">swappable_vector</span>

   <span class="k">method</span> <span class="n">min</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">values</span><span class="o">#</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
         <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;heap is empty&quot;</span><span class="o">);</span>
      <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="mi">0</span>

   <span class="k">method</span> <span class="n">add</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">values</span><span class="o">#</span><span class="n">length</span> <span class="k">in</span>
      <span class="n">values</span><span class="o">#</span><span class="n">set</span> <span class="n">pos</span> <span class="n">x</span><span class="o">;</span>
      <span class="n">self</span><span class="o">#</span><span class="n">move_up</span> <span class="n">pos</span>

   <span class="k">method</span> <span class="k">private</span> <span class="n">move_up</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span>
         <span class="k">let</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="n">parent</span> <span class="k">then</span> <span class="k">begin</span>
               <span class="n">values</span><span class="o">#</span><span class="n">swap</span> <span class="n">i</span> <span class="n">parent</span><span class="o">;</span>
               <span class="n">self</span><span class="o">#</span><span class="n">move_up</span> <span class="n">parent</span>
            <span class="k">end</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9881648">
      The method <code>move_up</code> implements the process of
      restoring heap order as a recursive method (though it would be
      straightforward avoid the recursion and use iteration here).
    </p><p id="idp9882928">
      The key property of private methods is that they are visible to
      subclasses, but not anywhere else. If you want the stronger
      guarantee that a method is <span><em>really</em></span> private,
      not even accessible in subclasses, you can use an explicit typing
      that omits the method. In the following code, the
      <code>move_up</code> method is explicitly omitted from the
      object type, and it can't be invoked in subclasses.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">binary_heap</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">min</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">method</span> <span class="k">private</span> <span class="n">move_up</span> <span class="n">i</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="virtual-classes-and-methods">Virtual classes and methods</h1><p id="idp9887648">
      A <span><em>virtual</em></span> class is a class where some methods
      or fields are declared, but not implemented. This should not be
      confused with the word &quot;virtual&quot; as it is used in C++.
      In C++, a &quot;virtual&quot; method uses dynamic dispatch,
      regular non-virtual methods use static dispatched. In OCaml,
      <span><em>all</em></span> methods use dynamic dispatch, but the
      keyword <span><em>virtual</em></span> means the method or field is
      not implemented.
    </p><p id="idp9890192">
      In the previous section, we defined a class
      <code>swappable_vector</code> that inherits from
      <code>array_vector</code> and adds a <code>swap</code>
      method. In fact, the <code>swap</code> method could be
      defined for any object with <code>get</code> and
      <code>set</code> methods; it doesn't have to be the specific
      class <code>array_vector</code>.
    </p><p id="idp9895744">
      One way to do this is to declare the
      <code>swappable_vector</code> abstractly, declaring the
      methods <code>get</code> and <code>set</code>, but
      leaving the implementation for later. However, the
      <code>swap</code> method can be defined immediately.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="n">abstract_swappable_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="n">i</span> <span class="k">in</span>
      <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="n">i</span> <span class="o">(</span><span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="n">j</span><span class="o">);</span>
      <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="n">j</span> <span class="n">tmp</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9900672">
      At some future time, we may settle on a concrete implementation
      for the vector. We can inherit from the
      <code>abstract_swappable_bvector</code> to get the
      <code>swap</code> method &quot;for free.&quot; Here's one
      implementation using arrays.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">array_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">inherit</span> <span class="n">abstract_swappable_vector</span>

   <span class="k">val</span> <span class="k">mutable</span> <span class="n">values</span> <span class="o">=</span> <span class="o">[||]</span>
   <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
   <span class="k">method</span> <span class="n">set</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span>
      <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="n">i</span><span class="o">;</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">x</span>
   <span class="k">method</span> <span class="n">length</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span>

   <span class="k">method</span> <span class="k">private</span> <span class="n">ensure_capacity</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">self</span><span class="o">#</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="k">then</span>
         <span class="k">let</span> <span class="n">new_values</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">in</span>
            <span class="nn">Array</span><span class="p">.</span><span class="n">blit</span> <span class="n">values</span> <span class="mi">0</span> <span class="n">new_values</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span><span class="o">);</span>
            <span class="n">values</span> <span class="o">&lt;-</span> <span class="n">new_values</span>
<span class="k">end</span>
</pre></div><p id="idp9904864">
      Here's a different implementation using
      <code>HashTbl</code>.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">hash_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">inherit</span> <span class="n">abstract_swappable_vector</span>

   <span class="k">val</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">19</span>

   <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="n">i</span> <span class="k">with</span>
         <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="mi">0</span>

   <span class="k">method</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">table</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9907360">
      One way to view a <code>virtual</code> class is that it is
      like a functor, where the &quot;inputs&quot; are the declared, but
      not defined, virtual methods and fields. The functor application
      is implemented through inheritance, when virtual methods are given
      concrete implementations.
    </p><p id="idp9909120">
      We've been mentioning that fields can be virtual too. Here is
      another implementation of the swapper, this time with direct
      access to the array of values.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="n">abstract_swappable_array_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="k">virtual</span> <span class="n">values</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span>
   <span class="k">method</span> <span class="k">private</span> <span class="k">virtual</span> <span class="n">ensure_capacity</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

   <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
      <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="o">(</span><span class="n">max</span> <span class="n">i</span> <span class="n">j</span><span class="o">);</span>
      <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">);</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9910960">
      This level of dependency on the implementation details is
      possible, but it is hard to justify the use of a virtual class --
      why not just define the <code>swap</code> method as part of
      the concrete class? Virtual classes are better suited for
      situations where there are multiple (useful) implementations of
      the virtual parts. In most cases, this will be public virtual
      methods.
    </p></section><section><h1 id="multiple-inheritance">Multiple inheritance</h1><p id="idp9913744">
      When a class inherits from more than one superclass, it is using
      <span><em>multiple inheritance</em></span>. Multiple inheritance
      extends the variety of ways in which classes can be combined, and
      it can be quite useful, particularly with virtual classes.
      However, it can be tricky to use, particularly when the
      inheritance hierarchy is a graph rather than a tree, so it should
      be used with care.
    </p><section><h1 id="how-names-are-resolved">How names are resolved</h1><p id="idp9916128">
        The main &quot;trickiness&quot; of multiple inheritance is due
        to naming -- what happens when a method or field with some name
        is defined in more than one class?
      </p><p id="idp9916912">
        If there is one thing to remember about inheritance in OCaml, it
        is this: inheritance is like textual inclusion. If there is more
        than one definition for a name, the last definition wins. Let's
        look at some artificial, but illustrative, examples.
      </p><p id="idp9917600">
        First, let's consider what happens when we define a method more
        than once. In the following example, the method
        <code>get</code> is defined twice; the second definition
        &quot;wins,&quot; meaning that it overrides the first one.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m1</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="k">method</span> <span class="n">f</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">get</span>
   <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m1</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">m1</span><span class="o">)#</span><span class="n">f</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9920240">
        Fields have similar behavior, though the compiler produces a
        warning message about the override.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m2</span> <span class="o">=</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m2</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
     <span class="k">method</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">69</span><span class="o">-</span><span class="mi">74</span><span class="o">:</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
         <span class="o">^^^^^</span>
<span class="nc">Warning</span> <span class="mi">13</span><span class="o">:</span> <span class="n">the</span> <span class="n">instance</span> <span class="n">variable</span> <span class="n">x</span> <span class="n">is</span> <span class="n">overridden</span><span class="o">.</span>
<span class="nc">The</span> <span class="n">behaviour</span> <span class="n">changed</span> <span class="k">in</span> <span class="n">ocaml</span> <span class="mi">3</span><span class="o">.</span><span class="mi">10</span> <span class="o">(</span><span class="n">previous</span> <span class="n">behaviour</span> <span class="n">was</span> <span class="n">hiding</span><span class="o">.)</span>
<span class="k">class</span> <span class="n">m2</span> <span class="o">:</span> <span class="k">object</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">m2</span><span class="o">)#</span><span class="n">f</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9922064">
        Of course, it is unlikely that you will define two methods or
        two fields of the same name in the same class. However, the
        rules for inheritance follow the same pattern: the last
        definition wins. In the following definition, the
        <code>inherit</code> declaration comes last, so the method
        definition <code>method get = 2</code> overrides the
        previous definition, always returning 2.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m4</span> <span class="o">=</span> <span class="k">object</span> <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m5</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">x'</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">x'</span>
    <span class="k">inherit</span> <span class="n">m4</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m5</span> <span class="o">:</span> <span class="k">object</span> <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">m5</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m5</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9925808">
        To reiterate, to understand what inheritance means, replace each
        <code>inherit</code> directive with its definition, and
        take the last definition of each method or field. This holds
        even for private methods. However, it does
        <span><em>not</em></span> hold for private methods that are
        &quot;really&quot; private, meaning that they have been hidden
        by a type constraint. In the following definitions, there are
        three definitions of the private method <code>g</code>.
        However, the definition of <code>g</code> in
        <code>m8</code> is not overridden, because it is not part
        of the class type for <code>m8</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m6</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m6</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f1</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m7</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m7</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f2</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m8</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m8</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m9</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">inherit</span> <span class="n">m6</span>
     <span class="k">inherit</span> <span class="n">m7</span>
     <span class="k">inherit</span> <span class="n">m8</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m9</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">f1</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">f2</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">m9</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m9</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">f1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">f3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></section><section><h1 id="mixins">Mixins</h1><p id="idp9934592">
        When should you use multiple inheritance? If you ask multiple
        people, you're likely to get multiple (perhaps heated) answers.
        Some will argue that multiple inheritance is overly complicated;
        others will argue that inheritance is problematic in general,
        and one should use object composition instead. But regardless of
        who you talk to, you will rarely hear that multiple inheritance
        is great and you should use it widely.
      </p><p id="idp9935472">
        In any case, if you're programming with objects, there's one
        general pattern for multiple inheritance that is both useful and
        reasonably simple, the <span><em>mixin</em></span> pattern.
        Generically, a <span><em>mixin</em></span> is just a virtual
        class that implements a feature based on another one. If you
        have a class that implements methods <span><em>A</em></span>, and
        you have a mixin <span><em>M</em></span> that provides methods
        <span><em>B</em></span> from <span><em>A</em></span>, then you can
        inherit from <span><em>M</em></span> -- &quot;mixing&quot; it in
        -- to get features <span><em>B</em></span>.
      </p><p id="idp9939760">
        That's too abstract, so let's give an example based on
        collections. In Section XXX:Objecttypes, we introduced the
        <span><em>iterator</em></span> pattern, where an
        <span><em>iterator</em></span> object is used to enumerate the
        elements of a collection. Lots of containers can have iterators,
        singly-linked lists, dictionaries, vectors, etc.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">vector</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">deque</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">]</span> <span class="n">map</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="o">...</span>
</pre></div><p id="idp9943200">
        The collections are different is some ways, but they share a
        common pattern for iteration that we can reuse. For a simple
        example, let's define a mixin that implements an arithmetic sum
        for a collection of integers.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="k">virtual</span> <span class="n">int_sum_mixin</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="k">virtual</span> <span class="n">iterator</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">iterator</span>
     <span class="k">method</span> <span class="n">sum</span> <span class="o">=</span>
        <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">total</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
        <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
           <span class="n">total</span> <span class="o">:=</span> <span class="o">!</span><span class="n">total</span> <span class="o">+</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
           <span class="n">it</span><span class="o">#</span><span class="n">next</span>
        <span class="k">done</span><span class="o">;</span>
        <span class="o">!</span><span class="n">total</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">int_slist</span> <span class="o">=</span>
  <span class="k">object</span>
     <span class="k">inherit</span> <span class="o">[</span><span class="kt">int</span><span class="o">]</span> <span class="n">slist</span>
     <span class="k">inherit</span> <span class="n">int_sum_mixin</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">int_slist</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">l</span> <span class="o">:</span> <span class="n">int_slist</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="mi">12</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">sum</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">int_deque</span> <span class="o">=</span>
  <span class="k">object</span>
     <span class="k">inherit</span> <span class="o">[</span><span class="kt">int</span><span class="o">]</span> <span class="n">deque</span>
     <span class="k">inherit</span> <span class="n">int_sum_mixin</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9945680">
        In this particular case, the mixin works only for a collection
        of integers, so we can't add the mixin to the polymorphic class
        definition <code>['a] slist</code> itself. However, the
        result of using the mixin is that the integer collection has a
        method <code>sum</code>, and it is done with very little
        of the fuss we would need if we used object composition instead.
      </p><p id="idp9947840">
        The mixin pattern isn't limited to non-polymorphic classes, of
        course. We can use it to implement generic features as well. The
        following mixin defines functional-style iteration in terms of
        the imperative iterator pattern.
      </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">fold_mixin</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
   <span class="k">method</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="o">.</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span>
            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">x</span> <span class="k">in</span>
            <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
            <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
               <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">!</span><span class="n">y</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
               <span class="n">it</span><span class="o">#</span><span class="n">next</span>
            <span class="k">done</span><span class="o">;</span>
            <span class="o">!</span><span class="n">y</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>

<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_with_fold</span> <span class="o">=</span>
<span class="k">object</span>
   <span class="k">inherit</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span>
   <span class="k">inherit</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">fold_mixin</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><aside class="note"><h1>
      Production note
      </h1><p id="idp9951200">
        This chapter contains significant external contributions from
        Leo White.
      </p></aside></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="objects.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="pt02.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>