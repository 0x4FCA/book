<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 8. Error Handling / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha1',
                        page: 'error\u002Dhandling.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-json-xml-and-s-expressions.html">7. Data Serialization with JSON, XML and S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html" class="here">8. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">9. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">10. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors-and-first-class-modules.html">11. Functors and First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="input-and-output.html">12. Input and Output</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">13. Concurrent Programming with Async</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">14. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 8. Error Handling</h1>
                
                

    <p id="idp8201872">
    Nobody likes dealing with errors. It's tedious, it's easy to get
    wrong, and it's usually just not as fun as planning out how your
    program is going to succeed. But error handling is important, and
    however much you don't like thinking about it, having your software
    fail due to poor error handling code is worse.
  </p><p id="idp8202608">
    Thankfully, OCaml has powerful tools for handling errors reliably
    and with a minimum of pain. In this chapter we'll discuss some of
    the different approaches in OCaml to handling errors, and give some
    advice on how to design interfaces that help rather than hinder
    error handling.
  </p><p id="idp8203312">
    We'll start by describing the two basic approaches for reporting
    errors in OCaml: error-aware return types and exceptions.
  </p><section><h1 id="error-aware-return-types">Error-aware return types</h1><p id="idp8204720">
      The best way in OCaml to signal an error is to include that error
      in your return value. Consider the type of the
      <code>find</code> function in the list module.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">find</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span>
</pre></div><p id="idp8206816">
      The option in the return type indicates that the function may not
      succeed in finding a suitable element, as you can see below.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">find</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">2</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">find</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
</pre></div><p id="idp8208496">
      Having errors be explicit in the return values of your functions
      tells the caller that there is an error that needs to be handled.
      The caller can then handle the error explicitly, either recovering
      from the error or propagating it onward.
    </p><p id="idp8209168">
      The function <code>compute_bounds</code> below is an example
      of how you can handle errors in this style. The function takes a
      list and a comparison function, and returns upper and lower bounds
      for the list by finding the smallest and largest element on the
      list. <code>List.hd</code> and <code>List.last</code>,
      which return <code>None</code> when they encounter an empty
      list, are used to extract the largest and smallest element of the
      list.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">compute_bounds</span> <span class="o">~</span><span class="n">cmp</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">sorted</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="o">~</span><span class="n">cmp</span> <span class="kt">list</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">smallest</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">sorted</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">largest</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">last</span> <span class="n">sorted</span> <span class="k">in</span>
    <span class="k">match</span> <span class="n">smallest</span><span class="o">,</span> <span class="n">largest</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span><span class="o">,_</span> <span class="o">|</span> <span class="o">_,</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Some</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">compute_bounds</span> <span class="o">:</span>
  <span class="n">cmp</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8213728">
      The match statement is used to handle the error cases, propagating
      an error in <code>hd</code> or <code>last</code> into
      the return value of <code>compute_bounds</code>. On the
      other hand, in <code>find_mismatches</code> below, errors
      encountered during the computation do not propagate to the return
      value of the function. <code>find_mismatches</code> takes
      two hashtables as its arguments and tries to find keys that are
      stored in both. As such, a failure to find a key in one of the
      tables isn't really an error.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">find_mismatches</span> <span class="n">table1</span> <span class="n">table2</span> <span class="o">=</span>
     <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">fold</span> <span class="n">table1</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="n">errors</span> <span class="o">-&gt;</span>
        <span class="k">match</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">table2</span> <span class="n">key</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Some</span> <span class="n">data'</span> <span class="k">when</span> <span class="n">data'</span> <span class="o">&lt;&gt;</span> <span class="n">data</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">::</span> <span class="n">errors</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">errors</span>
     <span class="o">)</span>
 <span class="o">;;</span>
<span class="k">val</span> <span class="n">find_mismatches</span> <span class="o">:</span>
  <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8219024">
      The use of options to encode errors underlines the fact that it's
      not clear whether a particular outcome, like not finding something
      on a list, is really an error, or just another valid outcome of
      your function. This turns out to be very context-dependent, and
      error-aware return types give you a uniform way of handling the
      result that works well for both situations.
    </p><section><h1 id="encoding-errors-with-result">Encoding errors with <code>Result</code></h1><p id="idp8221216">
        Options aren't always a sufficiently expressive way to report
        errors. Specifically, when you encode an error as
        <code>None</code>, there's nowhere to say anything about
        the nature of the error.
      </p><p id="idp8222480">
<code>Result.t</code> is meant to address this deficiency.
        Here's the definition:
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Result</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span><span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Ok</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span>
                    <span class="o">|</span> <span class="nc">Error</span> <span class="k">of</span> <span class="k">'</span><span class="n">b</span>
<span class="k">end</span>
</pre></div><p id="idp8224560">
        A <code>Result.t</code> is essentially an option augmented
        with the ability to store other information in the error case.
        Like <code>Some</code> and <code>None</code> for
        options, the constructors <code>Ok</code> and
        <code>Error</code> are promoted to the top-level by
        <code>Core.Std</code>. As such, we can write:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">[</span> <span class="nc">Ok</span> <span class="mi">3</span><span class="o">;</span> <span class="nc">Error</span> <span class="s2">&quot;abject failure&quot;</span><span class="o">;</span> <span class="nc">Ok</span> <span class="mi">4</span> <span class="o">];;</span>
<span class="o">[</span><span class="nc">Ok</span> <span class="mi">3</span><span class="o">;</span> <span class="nc">Error</span> <span class="s2">&quot;abject failure&quot;</span><span class="o">;</span> <span class="nc">Ok</span> <span class="mi">4</span><span class="o">]</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="kt">string</span><span class="o">)</span> <span class="nn">Result</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">=</span>
<span class="o">[</span><span class="nc">Ok</span> <span class="mi">3</span><span class="o">;</span> <span class="nc">Error</span> <span class="s2">&quot;abject failure&quot;</span><span class="o">;</span> <span class="nc">Ok</span> <span class="mi">4</span><span class="o">]</span>
</pre></div><p id="idp8230064">
        without first opening the <code>Result</code> module.
      </p></section><section><h1 id="error-and-or_error"><code>Error</code> and
      <code>Or_error</code></h1><p id="idp8233072">
<code>Result.t</code> gives you complete freedom to choose
        the type of value you use to represent errors, but it's often
        useful to standardize on an error type. Among other things, this
        makes it easier to write utility functions to automate common
        error handling patterns.
      </p><p id="idp8234384">
        But which type to choose? Is it better to represent errors as
        strings? Or S-expressions? Or something else entirely?
      </p><p id="idp8234928">
        Core's answer to this question is the <code>Error.t</code>
        type, which tries to forge a good compromise between efficiency,
        convenience and control over the presentation of errors.
      </p><p id="idp8236096">
        It might not be obvious at first why efficiency is an issue at
        all. But generating error messages is an expensive business. An
        ASCII representation of a type can be quite time-consuming to
        construct, particularly if it includes expensive-to-convert
        numerical datatypes.
      </p><p id="idp8236816">
<code>Error</code> gets around this issue through
        laziness. In particular, an <code>Error.t</code> allows
        you to put off generation of the actual error string until you
        actually need, which means a lot of the time you never have to
        construct it at all. You can of course construct an error
        directly from a string:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Error</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">&quot;something went wrong&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Error</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;something went wrong&quot;</span>
</pre></div><p id="idp8239808">
        A more interesting construction message from a performance point
        of view is to construct an <code>Error.t</code> from a
        thunk:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Error</span><span class="p">.</span><span class="n">of_thunk</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">sprintf</span> <span class="s2">&quot;something went wrong: %f&quot;</span> <span class="mi">32</span><span class="o">.</span><span class="mi">3343</span><span class="o">);;</span>
  <span class="o">-</span> <span class="o">:</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Error</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;something went wrong: 32.334300&quot;</span>
</pre></div><p id="idp8241984">
        In this case, we can benefit from the laziness of
        <code>Error</code>, since the thunk won't be called until
        the <code>Error.t</code> is converted to a string.
      </p><p id="idp8243696">
        We can also create an <code>Error.t</code> based on an
        s-expression converter. This is probably the most common idiom
        in Core.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Error</span><span class="p">.</span><span class="n">create</span> <span class="s2">&quot;Something failed a long time ago&quot;</span> <span class="nn">Time</span><span class="p">.</span><span class="n">epoch</span> <span class="nn">Time</span><span class="p">.</span><span class="n">sexp_of_t</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Error</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
<span class="s2">&quot;Something failed a long time ago: (1969-12-31 19:00:00.000000)&quot;</span>
</pre></div><p id="idp8246112">
        Here, the value <code>Time.epoch</code> is included in the
        error, but <code>Time.sexp_of_t</code>, which is used for
        converting the time to an s-expression, isn't run until the
        error is converted to a string. Using the Sexplib
        syntax-extension, which is discussed in more detail in chapter
        {{SYNTAX}}, we can inline create an s-expression converter for a
        collection of types, thus allowing us to register multiple
        pieces of data in an <code>Error.t</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Error</span><span class="p">.</span><span class="n">create</span> <span class="s2">&quot;Something went terribly wrong&quot;</span>
    <span class="o">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">5</span><span class="o">,</span> <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="o">;</span><span class="s2">&quot;b&quot;</span><span class="o">;</span><span class="s2">&quot;c&quot;</span><span class="o">],</span><span class="mi">6034</span><span class="o">)</span>
    <span class="o">&lt;:</span><span class="n">sexp_of</span><span class="o">&lt;</span><span class="kt">float</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">*</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Error</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;Something went terribly wrong: (3.5(a b c)6034)&quot;</span>
</pre></div><p id="idp8249968">
        Here, the declaration
        <code>&lt;:sexp_of&lt;float * string list * int&gt;&gt;</code>
        asks Sexplib to generate the sexp-converter for the tuple.
      </p><p id="idp8251184">
        Error also has operations for transforming errors. For example,
        it's often useful to augment an error with some extra
        information about the context of the error, or to combine
        multiplier errors together. <code>Error.of_list</code> and
        <code>Error.tag</code> fill these roles.
      </p><p id="idp8253072">
        The type <code>'a Or_error.t</code> is just a shorthand
        for <code>('a,Error.t) Result.t</code>, and it is, after
        <code>option</code>, the most common way of returning
        errors in Core.
      </p></section><section><h1 id="bind-and-other-error-handling-idioms"><code>bind</code> and other error-handling
      idioms</h1><p id="idp8256912">
        As you write more error handling code, you'll discover that
        certain patterns start to emerge. A number of these common
        patterns been codified in the interfaces of modules like
        <code>Option</code> and <code>Result</code>. One
        particularly useful one is built around the function
        <code>bind</code>, which is both an ordinary function and
        an infix operator <code>&gt;&gt;=</code>, both with the
        same type signature:
      </p><div class="highlight"><pre><span class="k">val</span> <span class="o">(&gt;&gt;=)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">option</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">option</span>
</pre></div><p id="idp8261136">
<code>bind</code> is a way of sequencing together
        error-producing functions so that that the first one to produce
        an error terminates the computation. In particular,
        <code>None &gt;&gt;= f</code> returns
        <code>None</code> without calling <code>f</code>,
        and <code>Some x &gt;&gt;= f</code> returns
        <code>f x</code>. We can use a nested sequence of these
        binds to express a multi-stage computation that can fail at any
        stage. Here's a rewrite <code>compute_bounds</code> in
        this style.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">compute_bounds</span> <span class="o">~</span><span class="n">cmp</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">open</span> <span class="nn">Option</span><span class="p">.</span><span class="nc">Monad_infix</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">sorted</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="o">~</span><span class="n">cmp</span> <span class="kt">list</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">sorted</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">first</span> <span class="o">-&gt;</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">last</span> <span class="n">sorted</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">last</span> <span class="o">-&gt;</span>
        <span class="nc">Some</span> <span class="o">(</span><span class="n">first</span><span class="o">,</span><span class="n">last</span><span class="o">)))</span>
</pre></div><p id="idp8267376">
        Note that we locally open the
        <code>Option.Monad_infix</code> module to get access to
        the infix operator <code>&gt;&gt;=</code>. The module is
        called <code>Monad_infix</code> because the bind operator
        is part of a sub-interface called <code>Monad</code>,
        which we'll talk about more in
        <a href="concurrent-programming-with-async.html">Chapter 13, <i>Concurrent Programming with Async</i></a>.
      </p><p id="idp8270832">
        This is a bit easier to read if we write it with fewer
        parentheses and less indentation, as follows.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">compute_bounds</span> <span class="o">~</span><span class="n">cmp</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">open</span> <span class="nn">Option</span><span class="p">.</span><span class="nc">Monad_infix</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">sorted</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="o">~</span><span class="n">cmp</span> <span class="kt">list</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">sorted</span>   <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">first</span> <span class="o">-&gt;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">last</span> <span class="n">sorted</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">last</span>  <span class="o">-&gt;</span>
    <span class="nc">Some</span> <span class="o">(</span><span class="n">first</span><span class="o">,</span><span class="n">last</span><span class="o">)</span>
</pre></div><p id="idp8272496">
        There are other useful idioms encoded in the functions in
        <code>Option</code>. Another example is
        <code>Option.both</code>, which takes two optional values
        and produces a new optional pair that is <code>None</code>
        if either of its arguments are <code>None</code>. Using
        <code>Option.both</code>, we can make
        <code>compute_bounds</code> even shorter.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">compute_bounds</span> <span class="o">~</span><span class="n">cmp</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">sorted</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="o">~</span><span class="n">cmp</span> <span class="kt">list</span> <span class="k">in</span>
    <span class="nn">Option</span><span class="p">.</span><span class="n">both</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">sorted</span><span class="o">)</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">last</span> <span class="n">sorted</span><span class="o">)</span>
</pre></div><p id="idp8277824">
        These error-handling functions are valuable because they let you
        express your error handling both explicitly and concisely. We've
        only discussed these functions in the context of the
        <code>Option</code> module, but similar functionality is
        available in both <code>Result</code> and
        <code>Or_error</code>.
      </p></section></section><section><h1 id="exceptions">Exceptions</h1><p id="idp8281536">
      Exceptions in OCaml are not that different from exceptions in many
      other languages, like Java, C# and Python. In all these cases,
      exceptions are a way to terminate a computation and report an
      error, while providing a mechanism to catch and handle (and
      possibly recover from) exceptions that are triggered by
      sub-computations.
    </p><p id="idp8282304">
      We'll see an exception triggered in OCaml if, for example, we try
      to divide an integer by zero:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">0</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nn">Division_by_zero</span><span class="p">.</span>
</pre></div><p id="idp8283680">
      And an exception can terminate a computation even if it happens
      nested a few levels deep in a computation.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">x</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">0</span><span class="o">;</span><span class="mi">4</span><span class="o">];;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nn">Division_by_zero</span><span class="p">.</span>
</pre></div><p id="idp8285296">
      In addition to built-in exceptions like
      <code>Divide_by_zero</code>, OCaml lets you define your own.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">exception</span> <span class="nc">Key_not_found</span> <span class="k">of</span> <span class="kt">string</span><span class="o">;;</span>
<span class="k">exception</span> <span class="nc">Key_not_found</span> <span class="k">of</span> <span class="kt">string</span>
<span class="o">#</span> <span class="nc">Key_not_found</span> <span class="s2">&quot;a&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">exn</span> <span class="o">=</span> <span class="nc">Key_not_found</span><span class="o">(</span><span class="s2">&quot;a&quot;</span><span class="o">)</span>
</pre></div><p id="idp8287360">
      Here's an example of a function for looking up a key in an
      <span><em>association list</em></span>, <span><em>i.e.</em></span> a
      list of key/value pairs which uses this newly-defined exception:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">find_exn</span> <span class="n">alist</span> <span class="n">key</span> <span class="o">=</span> <span class="k">match</span> <span class="n">alist</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Key_not_found</span> <span class="n">key</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">(</span><span class="n">key'</span><span class="o">,</span><span class="n">data</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key'</span> <span class="k">then</span> <span class="n">data</span> <span class="k">else</span> <span class="n">find_exn</span> <span class="n">tl</span> <span class="n">key</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">find_exn</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">alist</span> <span class="o">=</span> <span class="o">[(</span><span class="s2">&quot;a&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span> <span class="o">(</span><span class="s2">&quot;b&quot;</span><span class="o">,</span><span class="mi">2</span><span class="o">)];;</span>
<span class="k">val</span> <span class="n">alist</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[(</span><span class="s2">&quot;a&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="o">(</span><span class="s2">&quot;b&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)]</span>
<span class="o">#</span> <span class="n">find_exn</span> <span class="n">alist</span> <span class="s2">&quot;a&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">find_exn</span> <span class="n">alist</span> <span class="s2">&quot;c&quot;</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nc">Key_not_found</span><span class="o">(</span><span class="s2">&quot;c&quot;</span><span class="o">).</span>
</pre></div><p id="idp8290000">
      Note that we named the function <code>find_exn</code> to
      warn the user that the function routinely throws exceptions, a
      convention that is used heavily in Core.
    </p><p id="idp8291152">
      In the above example, <code>raise</code> throws the
      exception, thus terminating the computation. The type of raise is
      a bit surprising when you first see it:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">raise</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">exn</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8293168">
      Having the return type be an otherwise unused type variable
      <code>'a</code> suggests that <code>raise</code> could
      return a value of any type. That seems impossible, and it is.
      <code>raise</code> has this type because it never returns at
      all. This behavior isn't restricted to functions like
      <code>raise</code> that terminate by throwing exceptions.
      Here's another example of a function that doesn't return a value.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">forever</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">forever</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">forever</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8297488">
<code>forever</code> doesn't return a value for a different
      reason: it is an infinite loop.
    </p><p id="idp8298592">
      This all matters because it means that the return type of
      <code>raise</code> can be whatever it needs to be to fit in
      to the context it is called in. Thus, the type system will let us
      throw an exception anywhere in a program.
    </p><section><h1><b>
    Declaring exceptions with <code>with sexp</code>
</b></h1><p id="idp8301120">
      OCaml can't always generate a useful textual representation of
      your exception, for example:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">exception</span> <span class="nc">Wrong_date</span> <span class="k">of</span> <span class="nn">Date</span><span class="p">.</span><span class="n">t</span><span class="o">;;</span>
<span class="k">exception</span> <span class="nc">Wrong_date</span> <span class="k">of</span> <span class="nn">Date</span><span class="p">.</span><span class="n">t</span>
<span class="o">#</span> <span class="nc">Wrong_date</span> <span class="o">(</span><span class="nn">Date</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">&quot;2011-02-23&quot;</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">exn</span> <span class="o">=</span> <span class="nc">Wrong_date</span><span class="o">(_)</span>
</pre></div><p id="idp8302704">
      But if you declare the exception using
      <code>with sexp</code> (and the constituent types have sexp
      converters), we'll get something with more information.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">exception</span> <span class="nc">Wrong_date</span> <span class="k">of</span> <span class="nn">Date</span><span class="p">.</span><span class="n">t</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="k">exception</span> <span class="nc">Wrong_date</span> <span class="k">of</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Date</span><span class="p">.</span><span class="n">t</span>
<span class="o">#</span> <span class="nc">Wrong_date</span> <span class="o">(</span><span class="nn">Date</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">&quot;2011-02-23&quot;</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">exn</span> <span class="o">=</span> <span class="o">(.</span><span class="nc">Wrong_date</span> <span class="mi">2011</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">23</span><span class="o">)</span>
</pre></div><p id="idp8304960">
      The period in front of <code>Wrong_date</code> is there
      because the representation generated by
      <code>with sexp</code> includes the full module path of the
      module where the exception in question is defined. This is quite
      useful in tracking down which precise exception is being reported.
      In this case, since we've declared the exception at the toplevel,
      that module path is trivial.
    </p></section><section><h1 id="exception-handlers">Exception handlers</h1><p id="idp8307984">
        So far, we've only seen exceptions fully terminate the execution
        of a computation. But often, we want a program to be able to
        respond to and recover from an exception. This is achieved
        through the use of <span><em>exception handlers</em></span>.
      </p><p id="idp8309008">
        In OCaml, an exception handler is declared using a
        <code>try</code>/<code>with</code> statement. Here's
        the basic syntax.
      </p><div class="highlight"><pre><span class="k">try</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span> <span class="k">with</span>
<span class="o">|</span> <span class="o">&lt;</span><span class="n">pat1</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="n">expr1</span><span class="o">&gt;</span>
<span class="o">|</span> <span class="o">&lt;</span><span class="n">pat2</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="n">expr2</span><span class="o">&gt;</span>
<span class="o">...</span>
</pre></div><p id="idp8311696">
        A <code>try</code>/<code>with</code> clause would
        first evaluate <code>&lt;expr&gt;</code>, and if that
        evaluation completes without returning an exception, then the
        value of the overall expression is the value of
        <code>&lt;expr&gt;</code>.
      </p><p id="idp8314736">
        But if evaluating <code>&lt;expr&gt;</code> leads to an
        exception being thrown, then the exception will be fed to the
        pattern match statements following the <code>with</code>.
        If the exception matches a pattern, then the expression on the
        right hand side of that pattern will be evaluated. Otherwise,
        the original exception continues up the call stack, to be
        handled by the next outer exception handler, or terminate the
        program if there is none.
      </p></section><section><h1 id="cleaning-up-in-the-presence-of-exceptions">Cleaning up in the presence of exceptions</h1><p id="idp8317856">
        One headache with exceptions is that they can terminate your
        execution at unexpected places, leaving your program in an
        awkward state. Consider the following code snippet:
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">load_config</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">inc</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">create</span> <span class="n">filename</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">Config</span><span class="p">.</span><span class="n">t_of_sexp</span> <span class="o">(</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">input_sexp</span> <span class="n">inc</span><span class="o">)</span> <span class="k">in</span>
  <span class="nn">In_channel</span><span class="p">.</span><span class="n">close</span> <span class="n">inc</span><span class="o">;</span>
  <span class="n">config</span>
</pre></div><p id="idp8319504">
        The problem with this code is that the function that loads the
        s-expression and parses it into a <code>Config.t</code>
        might throw an exception if the config file in question is
        malformed. Unfortunately, that means that the
        <code>In_channel.t</code> that was opened will never be
        closed, leading to a file-descriptor leak.
      </p><p id="idp8321520">
        We can fix this using Core's <code>protect</code>
        function. The basic purpose of <code>protect</code> is to
        ensure that the <code>finally</code> thunk will be called
        when <code>f</code> exits, whether it exited normally or
        with an exception. Here's how it could be used to fix
        <code>load_config</code>.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">load_config</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">inc</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">create</span> <span class="n">filename</span> <span class="k">in</span>
  <span class="n">protect</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="nn">Config</span><span class="p">.</span><span class="n">t_of_sexp</span> <span class="o">(</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">input_sexp</span> <span class="n">inc</span><span class="o">)</span>
    <span class="o">~</span><span class="n">finally</span><span class="o">:(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">close</span> <span class="n">inc</span><span class="o">)</span>
</pre></div></section><section><h1 id="catching-specific-exceptions">Catching specific exceptions</h1><p id="idp8327232">
        OCaml's exception-handling system allows you to tune your
        error-recovery logic to the particular error that was thrown.
        For example, <code>List.find_exn</code> always throws
        <code>Not_found</code>. You can take advantage of this in
        your code, for example, let's define a function called
        <code>lookup_weight</code>, with the following signature:
      </p><div class="highlight"><pre><span class="c">(** [lookup_weight ~compute_weight alist key] Looks up a</span>
<span class="c">    floating-point weight by applying [compute_weight] to the data</span>
<span class="c">    associated with [key] by [alist].  If [key] is not found, then</span>
<span class="c">    return 0.</span>
<span class="c">*)</span>
<span class="k">val</span> <span class="n">lookup_weight</span> <span class="o">:</span>
  <span class="n">compute_weight</span><span class="o">:(</span><span class="k">'</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="kt">float</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">key</span> <span class="o">*</span> <span class="k">'</span><span class="n">data</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</pre></div><p id="idp8331184">
        We can implement such a function using exceptions as follows:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">lookup_weight</span> <span class="o">~</span><span class="n">compute_weight</span> <span class="n">alist</span> <span class="n">key</span> <span class="o">=</span>
    <span class="k">try</span>
      <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">find_exn</span> <span class="n">alist</span> <span class="n">key</span> <span class="k">in</span>
      <span class="n">compute_weight</span> <span class="n">data</span>
    <span class="k">with</span>
      <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">.</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">lookup_weight</span> <span class="o">:</span>
  <span class="n">compute_weight</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">float</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span>
  <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8332864">
        This implementation is more problematic than it looks. In
        particular, what happens if <code>compute_weight</code>
        itself throws an exception? Ideally,
        <code>lookup_weight</code> should propagate that exception
        on, but if the exception happens to be
        <code>Not_found</code>, then that's not what will happen:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">lookup_weight</span> <span class="o">~</span><span class="n">compute_weight</span><span class="o">:(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Not_found</span><span class="o">)</span>
    <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="o">,</span><span class="mi">3</span><span class="o">;</span> <span class="s2">&quot;b&quot;</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="s2">&quot;a&quot;</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
</pre></div><p id="idp8336432">
        This kind of problem is hard to detect in advance, because the
        type system doesn't tell us what kinds of exceptions a given
        function might throw. Because of this kind of confusion, it's
        usually better to avoid catching specific exceptions. In this
        case, we can improve the code by catching the exception in a
        narrower scope.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">lookup_weight</span> <span class="o">~</span><span class="n">compute_weight</span> <span class="n">alist</span> <span class="n">key</span> <span class="o">=</span>
    <span class="k">match</span>
      <span class="k">try</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">find_exn</span> <span class="n">alist</span> <span class="n">key</span><span class="o">)</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">.</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">data</span> <span class="o">-&gt;</span> <span class="n">compute_weight</span> <span class="n">data</span> <span class="o">;;</span>
</pre></div><p id="idp8338352">
        At which point, it makes sense to simply use the non-exception
        throwing function, <code>List.Assoc.find</code>, instead.
      </p></section><section><h1 id="backtraces">Backtraces</h1><p id="idp8340480">
        A big part of the point of exceptions is to give useful
        debugging information. But at first glance, OCaml's exceptions
        can be less than informative. Consider the following simple
        program.
      </p><div class="highlight"><pre><span class="c">(* exn.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">exception</span> <span class="nc">Empty_list</span>

<span class="k">let</span> <span class="n">list_max</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty_list</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="n">tl</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="n">hd</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span><span class="o">)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">printf</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">list_max</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]);</span>
  <span class="n">printf</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">list_max</span> <span class="bp">[]</span><span class="o">)</span>
</pre></div><p id="idp8342432">
        If we build and run this program, we'll get a pretty
        uninformative error:
      </p><div class="highlight"><pre><span class="nv">$ </span>./exn
3
Fatal error: exception Exn.Empty_list
</pre></div><p id="idp8343792">
        The example in question is short enough that it's quite easy to
        see where the error came from. But in a complex program, simply
        knowing which exception was thrown is usually not enough
        information to figure out what went wrong.
      </p><p id="idp8344464">
        We can get more information from OCaml if we turn on stack
        traces. This can be done by setting the
        <code>OCAMLRUNPARAM</code> environment variable, as shown:
      </p><div class="highlight"><pre>exn <span class="nv">$ </span><span class="nb">export </span><span class="nv">OCAMLRUNPARAM</span><span class="o">=</span>b
exn <span class="nv">$ </span>./exn
3
Fatal error: exception Exn.Empty_list
Raised at file <span class="s2">&quot;exn.ml&quot;</span>, line 7, characters 16-26
Called from file <span class="s2">&quot;exn.ml&quot;</span>, line 12, characters 17-28
</pre></div><p id="idp8346688">
        Backtraces can also be obtained at runtime. In particular,
        <code>Exn.backtrace</code> will return the backtrace of
        the most recently thrown exception.
      </p></section><section><h1 id="exceptions-for-control-flow">Exceptions for control flow</h1><p id="idp8348896">
</p></section><section><h1 id="from-exceptions-to-error-aware-types-and-back-again">From exceptions to error-aware types and back again</h1><p id="idp8350288">
        Both exceptions and error-aware types are necessary parts of
        programming in OCaml. As such, you often need to move between
        these two worlds. Happily, Core comes with some useful helper
        functions to help you do just that. For example, given a piece
        of code that can throw an exception, you can capture that
        exception into an option as follows:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">find</span> <span class="n">alist</span> <span class="n">key</span> <span class="o">=</span>
    <span class="nn">Option</span><span class="p">.</span><span class="n">try_with</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">find_exn</span> <span class="n">alist</span> <span class="n">key</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">find</span> <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">;</span> <span class="s2">&quot;b&quot;</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="s2">&quot;c&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Option</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">None</span>
<span class="o">#</span> <span class="n">find</span> <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">;</span> <span class="s2">&quot;b&quot;</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="s2">&quot;b&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Option</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">2</span>
</pre></div><p id="idp8352416">
        And <code>Result</code> and <code>Or_error</code>
        have similar <code>try_with</code> functions. So, we could
        write:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">find</span> <span class="n">alist</span> <span class="n">key</span> <span class="o">=</span>
    <span class="nn">Result</span><span class="p">.</span><span class="n">try_with</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">find_exn</span> <span class="n">alist</span> <span class="n">key</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="n">exn</span><span class="o">)</span> <span class="nn">Result</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">find</span> <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">;</span> <span class="s2">&quot;b&quot;</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="s2">&quot;c&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">exn</span><span class="o">)</span> <span class="nn">Result</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Result</span><span class="p">.</span><span class="nc">Error</span> <span class="nc">Key_not_found</span><span class="o">(</span><span class="s2">&quot;c&quot;</span><span class="o">)</span>
</pre></div><p id="idp8356112">
        And then we can re-raise that exception:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Result</span><span class="p">.</span><span class="n">ok_exn</span> <span class="o">(</span><span class="n">find</span> <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">;</span> <span class="s2">&quot;b&quot;</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="s2">&quot;b&quot;</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="nn">Result</span><span class="p">.</span><span class="n">ok_exn</span> <span class="o">(</span><span class="n">find</span> <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">;</span> <span class="s2">&quot;b&quot;</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="s2">&quot;c&quot;</span><span class="o">);;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nc">Key_not_found</span><span class="o">(</span><span class="s2">&quot;c&quot;</span><span class="o">).</span>
</pre></div></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="data-serialization-with-json-xml-and-s-expressions.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="imperative-programming-1.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>