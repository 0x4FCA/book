<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 9. Data Serialization with S-Expressions / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha2',
                        page: 'data\u002Dserialization\u002Dwith\u002Ds\u002Dexpressions.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html" class="here">9. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">10. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="xml-streams-and-trees.html">11. XML Streams and Trees</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 9. Data Serialization with S-Expressions</h1>
                
                

    <p id="idp8527120">
    Data serialization, <span><em>i.e.</em></span> reading and writing
    program data to a sequence of bytes, is an important and common
    programming task. Sometimes you need to match someone else's data
    format (such as XML), and other times you just want to quickly dump
    some values to disk and read them back later. To this end, OCaml
    comes with several techniques for data serialization depending on
    what your problem is.
  </p><p id="idp8528304">
    We'll start by introducing some features in Core that make it really
    easy to manipulate s-expressions and safe binary serialisers
    directly from OCaml types. After this section, we'll move onto
    interoperating with other third-party formats in
    <a href="handling-json-data.html">Chapter 10, <i>Handling JSON data</i></a> and
    <a href="xml-streams-and-trees.html">Chapter 11, <i>XML Streams and Trees</i></a>.
  </p><p id="idp8529952">
    S-expressions are nested paranthetical strings whose atomic values
    are strings. They were first popularized by the Lisp programming
    language in the 1960s, and have remained a simple way to encode data
    structures since then.
  </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Sexp</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Atom</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">List</span> <span class="k">of</span> <span class="n">t</span> <span class="kt">list</span>
<span class="k">end</span>
</pre></div><p id="idp8531536">
    An s-expression is in essence a nested parenthetical list whose
    atomic values are strings. The <code>Sexp</code> module comes
    with functionality for parsing and printing s-expressions.
  </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">sexp</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">a</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">Atom</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">l</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">List</span> <span class="n">x</span> <span class="k">in</span>
    <span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;this&quot;</span><span class="o">;</span><span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;is&quot;</span><span class="o">;</span> <span class="n">a</span> <span class="s2">&quot;an&quot;</span><span class="o">];</span> <span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;s&quot;</span><span class="o">;</span> <span class="n">a</span> <span class="s2">&quot;expression&quot;</span><span class="o">]];;</span>
<span class="k">val</span> <span class="n">sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="n">this</span> <span class="o">(</span><span class="n">is</span> <span class="n">an</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">expression</span><span class="o">))</span>
</pre></div><p id="idp8534064">
    In addition, most of the base types in Core support conversion to
    and from s-expressions. For example, we can write:
  </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Int</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">sexp_of_t</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">List</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="nn">Int</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">)</span>
</pre></div><p id="idp8535856">
    Notice that <code>List.sexp_of_t</code> is polymorphic, and
    takes as its first argument another conversion function to handle
    the elements of the list to be converted. Core uses this scheme more
    generally for defining sexp-converters for polymorphic types.
  </p><p id="idp8537120">
    But what if you want a function to convert some brand new type to an
    s-expression? You can of course write it yourself:
  </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar</span><span class="o">:</span> <span class="kt">float</span> <span class="o">};;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">sexp_of_t</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">a</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">Atom</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">l</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">List</span> <span class="n">x</span> <span class="k">in</span>
    <span class="n">l</span> <span class="o">[</span> <span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;foo&quot;</span><span class="o">;</span> <span class="nn">Int</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="n">t</span><span class="o">.</span><span class="n">foo</span>  <span class="o">];</span>
        <span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;bar&quot;</span><span class="o">;</span> <span class="nn">Float</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="n">t</span><span class="o">.</span><span class="n">bar</span><span class="o">];</span> <span class="o">]</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">bar</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="o">.</span><span class="mi">5</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">foo</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="o">-</span><span class="mi">5</span><span class="o">.</span><span class="mi">5</span><span class="o">))</span>
</pre></div><p id="idp8539184">
    This is somewhat tiresome to write, and it gets more so when you
    consider the parser, <span><em>i.e.</em></span>,
    <code>t_of_sexp</code>, which is considerably more complex.
    Writing this kind of parsing and printing code by hand is mechanical
    and error prone, not to mention a drag.
  </p><p id="idp8540864">
    Given how mechanical the code is, you could imagine writing a
    program that inspected the type definition and auto-generated the
    conversion code for you. That is precisely where syntax extensions
    come in. Using Sexplib and adding <code>with sexp</code> as an
    annotation to our type definition, we get the functions we want for
    free.
  </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar</span><span class="o">:</span> <span class="kt">float</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">t_of_sexp__</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">t_of_sexp</span> <span class="o">(</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">&quot;((bar 35) (foo 3))&quot;</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span><span class="n">foo</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">35</span><span class="o">.}</span>
</pre></div><p id="idp8543664">
    (You can ignore <code>t_of_sexp__</code>, which is a helper
    function that is needed in very rare cases.)
  </p><p id="idp8544752">
    The syntax-extensions in Core that we're going to discuss all have
    this same basic structure: they auto-generate code based on type
    definitions, implementing functionality that you could in theory
    have implemented by hand, but with far less programmer effort.
  </p><p id="idp8545424">
    There are several syntax extensions distributed with Core,
    including:
  </p><ul><li><p id="idp8546416">
<span><strong>Sexplib</strong></span>: provides
        serialization for s-expressions.
      </p></li><li><p id="idp8547888">
<span><strong>Bin_prot</strong></span>: provides
        serialization to an efficient binary format.
      </p></li><li><p id="idp8549360">
<span><strong>Fieldslib</strong></span>: generates
        first-class values that represent fields of a record, as well as
        accessor functions and setters for mutable record fields.
      </p></li><li><p id="idp8550928">
<span><strong>Variantslib</strong></span>: like Fieldslib
        for variants, producing first-class variants and other helper
        functions for interacting with variant types.
      </p></li><li><p id="idp8552480">
<span><strong>Pa_compare</strong></span>: generates
        efficient, type-specialized comparison functions.
      </p></li><li><p id="idp8553968">
<span><strong>Pa_typehash</strong></span>: generates a hash
        value for a type definition, <span><em>i.e.</em></span>, an
        integer that is highly unlikely to be the same for two distinct
        types.
      </p></li></ul><p id="idp8555808">
    We'll discuss each of these syntax extensions in detail, starting
    with Sexplib.
  </p><section><h1 id="sexplib">Sexplib</h1><section><h1 id="formatting-of-s-expressions">Formatting of s-expressions</h1><p id="idp8558064">
        Sexplib's format for s-expressions is pretty straightforward: an
        s-expression is written down as a nested parenthetical
        expression, with whitespace-separated strings as the atoms.
        Quotes are used for atoms that contain parenthesis or spaces
        themselves, backslash is the escape character, and semicolons
        are used to introduce comments. Thus, if you create the
        following file:
      </p><div class="highlight"><pre><span class="c1">;; foo.scm</span>

<span class="p">((</span><span class="nf">foo</span> <span class="mf">3.3</span><span class="p">)</span> <span class="c1">;; Shall I compare thee  to a summer's dream?</span>
 <span class="p">(</span><span class="nf">bar</span> <span class="s">&quot;this is () an \&quot; atom&quot;</span><span class="p">))</span>
</pre></div><p id="idp8559936">
        we can load it up and print it back out again:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">load_sexp</span> <span class="s2">&quot;foo.scm&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">foo</span> <span class="mi">3</span><span class="o">.</span><span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="s2">&quot;this is () an </span><span class="se">\&quot;</span><span class="s2"> atom&quot;</span><span class="o">))</span>
</pre></div><p id="idp8561424">
        Note that the comments were dropped from the file upon reading.
        This is expected, since there's no place in the
        <code>Sexp.t</code> type to store comments.
      </p><p id="idp8562592">
        If we introduce an error into our s-expression, by, say,
        deleting the open-paren in front of <code>bar</code>,
        we'll get a parse error:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Exn</span><span class="p">.</span><span class="n">handle_uncaught</span> <span class="o">~</span><span class="n">exit</span><span class="o">:</span><span class="bp">false</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">ignore</span> <span class="o">(</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">load_sexp</span> <span class="s2">&quot;foo.scm&quot;</span><span class="o">));;</span>
  <span class="nc">Uncaught</span> <span class="k">exception</span><span class="o">:</span>

  <span class="o">(</span><span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="nc">Parse_error</span>
   <span class="o">((</span><span class="n">location</span> <span class="n">parse</span><span class="o">)</span> <span class="o">(</span><span class="n">err_msg</span> <span class="s2">&quot;unexpected character: ')'&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">text_line</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">(</span><span class="n">text_char</span> <span class="mi">29</span><span class="o">)</span> <span class="o">(</span><span class="n">global_offset</span> <span class="mi">94</span><span class="o">)</span> <span class="o">(</span><span class="n">buf_pos</span> <span class="mi">94</span><span class="o">)))</span>
</pre></div><p id="idp8564960">
        (In the above, we use <code>Exn.handle_uncaught</code> to
        make sure that the exception gets printed out in full detail.)
      </p></section><section><h1 id="sexp-converters">Sexp converters</h1><p id="idp8567072">
        The most important functionality provided by Sexplib is the
        auto-generation of converters for new types. We've seen a bit of
        how this works already, but let's walk through a complete
        example. Here's the source for the beginning of a library for
        representing integer intervals.
      </p><div class="highlight"><pre><span class="c">(* file: int_interval.ml *)</span>
<span class="c">(* Module for representing closed integer intervals *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* Invariant: For any Range (x,y), y &gt; x *)</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Range</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
         <span class="o">|</span> <span class="nc">Empty</span>
<span class="k">with</span> <span class="n">sexp</span>

<span class="k">let</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="k">function</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">true</span> <span class="o">|</span> <span class="nc">Range</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>
<span class="k">let</span> <span class="n">create</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">Empty</span> <span class="k">else</span> <span class="nc">Range</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span>
<span class="k">let</span> <span class="n">contains</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">false</span>
   <span class="o">|</span> <span class="nc">Range</span> <span class="o">(</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">low</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">high</span>
</pre></div><p id="idp8569280">
        We can now use this module as follows:
      </p><div class="highlight"><pre><span class="c">(* file: test_interval.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="n">intervals</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">module</span> <span class="nc">I</span> <span class="o">=</span> <span class="nc">Int_interval</span> <span class="k">in</span>
  <span class="o">[</span> <span class="nn">I</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;</span>
    <span class="nn">I</span><span class="p">.</span><span class="n">create</span> <span class="mi">5</span> <span class="mi">4</span><span class="o">;</span> <span class="c">(* should be empty *)</span>
    <span class="nn">I</span><span class="p">.</span><span class="n">create</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">;</span>
    <span class="nn">I</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="mi">6</span><span class="o">;</span>
  <span class="o">]</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">intervals</span>
  <span class="o">|!</span> <span class="nn">List</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">sexp_of_t</span>
  <span class="o">|!</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">to_string_hum</span>
  <span class="o">|!</span> <span class="n">print_endline</span>
</pre></div><p id="idp8570848">
        But we're still missing something: we haven't created an
        <code>mli</code> for <code>Int_interval</code> yet.
        Note that we need to explicitly export the s-expression
        converters that were created within the ml. If we don't:
      </p><div class="highlight"><pre><span class="c">(* file: int_interval.mli *)</span>
<span class="c">(* Module for representing closed integer intervals *)</span>

<span class="k">type</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</pre></div><p id="idp8573840">
        then we'll get the following error:
      </p><pre id="idp8574224">
File &quot;test_interval.ml&quot;, line 15, characters 20-42:
Error: Unbound value Int_interval.sexp_of_t
Command exited with code 2.
</pre><p id="idp8575200">
        We could export the types by hand:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
</pre></div><p id="idp8576528">
        But Sexplib has a shorthand for this as well, so that we can
        instead write simply:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span> <span class="k">with</span> <span class="n">sexp</span>
</pre></div><p id="idp8577904">
        at which point <code>test_interval.ml</code> will compile
        again, and if we run it, we'll get the following output:
      </p><pre id="idp8579008">
$ ./test_interval.native
((Range 3 4) Empty (Range 2 3) (Range 1 6))
</pre><section><h1><b>
      Preserving invariants
      </b></h1><p id="idp8580352">
        One easy mistake to make when dealing with sexp converters is to
        ignore the fact that those converters can violate the invariants
        of your code. For example, the <code>Int_interval</code>
        module depends for the correctness of the
        <code>is_empty</code> check on the fact that for any value
        <code>Range (x,y)</code>, <code>y</code> is greater
        than or equal to <code>x</code>. The
        <code>create</code> function preserves this invariant, but
        the <code>t_of_sexp</code> function does not.
      </p><p id="idp8585392">
        We can fix this problem by writing a custom sexp-converter, in
        this case, using the sexp-converter that we already have:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Range</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
         <span class="o">|</span> <span class="nc">Empty</span>
<span class="k">with</span> <span class="n">sexp</span>

<span class="k">let</span> <span class="n">create</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">Empty</span> <span class="k">else</span> <span class="nc">Range</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span>

<span class="k">let</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Range</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">when</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">-&gt;</span>
    <span class="n">of_sexp_error</span> <span class="s2">&quot;Upper and lower bound of Range swapped&quot;</span> <span class="n">sexp</span>
  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Range</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">t</span>
</pre></div><p id="idp8587392">
        We call the function <code>of_sexp_error</code> to raise
        an exception because that improves the error reporting that
        Sexplib can provide when a conversion fails.
      </p></section></section><section><h1 id="getting-good-error-messages">Getting good error messages</h1><p id="idp8589696">
        There are two steps to deserializing a type from an
        s-expression: first, converting the bytes in a file to an
        s-expression, and the second, converting that s-expression into
        the type in question. One problem with this is that it can be
        hard to localize errors to the right place using this scheme.
        Consider the following example:
      </p><div class="highlight"><pre><span class="c">(* file: read_foo.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">c</span><span class="o">:</span> <span class="kt">float</span> <span class="n">option</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span>

<span class="k">let</span> <span class="n">run</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span>
    <span class="nn">Sexp</span><span class="p">.</span><span class="n">load_sexp</span> <span class="s2">&quot;foo.scm&quot;</span>
    <span class="o">|!</span> <span class="n">t_of_sexp</span>
  <span class="k">in</span>
  <span class="n">printf</span> <span class="s2">&quot;b is: %d</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">t</span><span class="o">.</span><span class="n">b</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Exn</span><span class="p">.</span><span class="n">handle_uncaught</span> <span class="o">~</span><span class="n">exit</span><span class="o">:</span><span class="bp">true</span> <span class="n">run</span>
</pre></div><p id="idp8591648">
        If you were to run this on a malformatted file, say, this one:
      </p><pre id="idp8592128">
;; foo.scm
((a not-an-integer)
 (b not-an-integer)
 (c ()))
</pre><p id="idp8592832">
        you'll get the following error:
      </p><pre id="idp8593216">
read_foo $ ./read_foo.native
Uncaught exception:

  (Sexplib.Conv.Of_sexp_error
   (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;) not-an-integer)
</pre><p id="idp8594048">
        If all you have is the error message and the string, it's not
        terribly informative. In particular, you know that the parsing
        error-ed out on the atom &quot;not-an-integer&quot;, but you
        don't know which one! In a large file, this kind of bad error
        message can be pure misery.
      </p><p id="idp8594800">
        But there's hope! If we make small change to the
        <code>run</code> function as follows:
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">run</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">load_sexp_conv_exn</span> <span class="s2">&quot;foo.scm&quot;</span> <span class="n">t_of_sexp</span> <span class="k">in</span>
  <span class="n">printf</span> <span class="s2">&quot;b is: %d</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">t</span><span class="o">.</span><span class="n">b</span>
</pre></div><p id="idp8596864">
        and run it again, we'll get the following much more helpful
        error message:
      </p><div class="highlight"><pre><span class="n">read_foo</span> <span class="o">$</span> <span class="o">./</span><span class="n">read_foo</span><span class="o">.</span><span class="n">native</span>
<span class="nc">Uncaught</span> <span class="k">exception</span><span class="o">:</span>

  <span class="o">(</span><span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Conv</span><span class="p">.</span><span class="nc">Of_sexp_error</span>
   <span class="o">(</span><span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="nn">Annotated</span><span class="p">.</span><span class="nc">Conv_exn</span> <span class="n">foo</span><span class="o">.</span><span class="n">scm</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">4</span>
    <span class="o">(</span><span class="nc">Failure</span> <span class="s2">&quot;int_of_sexp: (Failure int_of_string)&quot;</span><span class="o">))</span>
   <span class="n">not</span><span class="o">-</span><span class="n">an</span><span class="o">-</span><span class="n">integer</span><span class="o">)</span>
</pre></div><p id="idp8598528">
        In the above error, &quot;foo.scm:3:4&quot; tells us that the
        error occurred on &quot;foo.scm&quot;, line 3, character 4,
        which is a much better start for figuring out what has gone
        wrong.
      </p></section><section><h1 id="sexp-conversion-directives">Sexp-conversion directives</h1><p id="idp8600144">
        Sexplib supports a collection of directives for modifying the
        default behavior of the auto-generated sexp-converters. These
        directives allow you to customize the way in which types are
        represented as s-expressions without having to write a custom
        parser. We describe these directives below.
      </p><section><h1 id="sexp-opaque"><code>sexp-opaque</code></h1><p id="idp8602128">
          The most commonly used directive is
          <code>sexp_opaque</code>, whose purpose is to mark a
          given component of a type as being unconvertible. Anything
          marked with <code>sexp_opaque</code> will be presented
          as the atom <code>&lt;opaque&gt;</code> by the to-sexp
          converter, and will trigger an exception from the from-sexp
          converter. Note that the type of a component marked as opaque
          doesn't need to have a sexp-converter defined. Here, if we
          define a type without a sexp-converter, and then try to use it
          another type with a sexp-converter, we'll error out:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">no_converter</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">no_converter</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
<span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="n">no_converter</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">14</span><span class="o">-</span><span class="mi">26</span><span class="o">:</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="n">no_converter</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
                <span class="o">^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="n">value</span> <span class="n">no_converter_of_sexp</span>
</pre></div><p id="idp8606128">
          But with <code>sexp_opaque</code>, we won't:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="n">no_converter</span> <span class="n">sexp_opaque</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">no_converter</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="n">sexp_opaque</span><span class="o">;</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">string</span><span class="o">;</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">t_of_sexp__</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8608352">
          And if we now convert a value of this type to an s-expression,
          we'll see the contents of field <code>a</code> marked as
          opaque:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">opaque</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">b</span> <span class="n">foo</span><span class="o">))</span>
</pre></div></section><section><h1 id="sexp_option"><code>sexp_option</code></h1><p id="idp8611888">
          Another common directive is <code>sexp_opaque</code>,
          which is used to make an optional field in a record. Ordinary
          optional values are represented either as
          <code>()</code> for <code>None</code>, or as
          <code>(x)</code> for <code>Some x</code>. If you
          put an option in a record field, then the record field will
          always be required, and its value will be presented in the way
          an ordinary optional value would. For example:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="kt">int</span> <span class="n">option</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">a</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">hello</span><span class="o">))</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">3</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">a</span> <span class="o">(</span><span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">b</span> <span class="n">hello</span><span class="o">))</span>
</pre></div><p id="idp8617072">
          But what if we want a field to be optional,
          <span><em>i.e.</em></span>, we want to allow it to be omitted
          from the record entirely? In that case, we can mark it with
          <code>sexp_option</code>:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="kt">int</span> <span class="n">sexp_option</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">3</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">a</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">hello</span><span class="o">))</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">b</span> <span class="n">hello</span><span class="o">))</span>
</pre></div></section><section><h1 id="sexp_list"><code>sexp_list</code></h1><p id="idp8621344">
          One problem with the auto-generated sexp-converters is that
          they can have more parentheses than one would ideally like.
          Consider, for example, the following variant type:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">compatible_versions</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Specific</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span>
                             <span class="o">|</span> <span class="nc">All</span>
  <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">sexp_of_compatible_versions</span> <span class="o">(</span><span class="nc">Specific</span> <span class="o">[</span><span class="s2">&quot;3.12.0&quot;</span><span class="o">;</span> <span class="s2">&quot;3.12.1&quot;</span><span class="o">;</span> <span class="s2">&quot;3.13.0&quot;</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Specific</span> <span class="o">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">12</span><span class="o">.</span><span class="mi">0</span> <span class="mi">3</span><span class="o">.</span><span class="mi">12</span><span class="o">.</span><span class="mi">1</span> <span class="mi">3</span><span class="o">.</span><span class="mi">13</span><span class="o">.</span><span class="mi">0</span><span class="o">))</span>
</pre></div><p id="idp8623120">
          You might prefer to make the syntax a bit less
          parenthesis-laden by dropping the parentheses around the list.
          <code>sexp_list</code> gives us this alternate syntax:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">compatible_versions</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Specific</span> <span class="k">of</span> <span class="kt">string</span> <span class="n">sexp_list</span>
                             <span class="o">|</span> <span class="nc">All</span>
  <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">sexp_of_compatible_versions</span> <span class="o">(</span><span class="nc">Specific</span> <span class="o">[</span><span class="s2">&quot;3.12.0&quot;</span><span class="o">;</span> <span class="s2">&quot;3.12.1&quot;</span><span class="o">;</span> <span class="s2">&quot;3.13.0&quot;</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Specific</span> <span class="mi">3</span><span class="o">.</span><span class="mi">12</span><span class="o">.</span><span class="mi">0</span> <span class="mi">3</span><span class="o">.</span><span class="mi">12</span><span class="o">.</span><span class="mi">1</span> <span class="mi">3</span><span class="o">.</span><span class="mi">13</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span>
</pre></div></section></section></section><section><h1 id="bin_prot">Bin_prot</h1><p id="idp8626736">
      S-expressions are a good serialization format when you need
      something machine-parseable as well as human readable and
      editable. But Sexplib's s-expressions are not particularly
      performant. There are a number of reasons for this. For one thing,
      s-expression serialization goes through an intermediate type,
      <code>Sexp.t</code>, which must be allocated and is then
      typically thrown away, putting non-trivial pressure on the GC. In
      addition, parsing and printing to strings in an ASCII format can
      be expensive for types like <code>int</code>s,
      <code>float</code>s and <code>Time.t</code>s where
      some real computation needs to be done to produce or parse the
      ASCII representation.
    </p><p id="idp8630320">
      Bin_prot is a library designed to address these issues by
      providing fast serialization in a compact binary format. Kicking
      off the syntax extension is done by putting
      <code>with bin_io</code>. (This looks a bit unsightly in the
      top-level because of all the definitions that are generated. We'll
      elide those definitions here, but you can see it for yourself in
      the toplevel.)
    </p><p id="idp8631760">
      Here's a small complete example of a program that can read and
      write values using bin-io. Here, the serialization is of types
      that might be used as part of a message-queue, where each message
      has a topic, some content, and a source, which is in turn a
      hostname and a port.
    </p><div class="highlight"><pre><span class="c">(* file: message_example.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* The type of a message *)</span>
<span class="k">module</span> <span class="nc">Message</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">module</span> <span class="nc">Source</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">hostname</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
               <span class="n">port</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
             <span class="o">}</span>
    <span class="k">with</span> <span class="n">bin_io</span>
  <span class="k">end</span>

  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">topic</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
             <span class="n">content</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
             <span class="n">source</span><span class="o">:</span> <span class="nn">Source</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
           <span class="o">}</span>
  <span class="k">with</span> <span class="n">bin_io</span>
<span class="k">end</span>

<span class="c">(* Create the 1st-class module providing the binability of messages *)</span>
<span class="k">let</span> <span class="n">binable</span> <span class="o">=</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Message</span> <span class="o">:</span> <span class="nn">Binable</span><span class="p">.</span><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>

<span class="c">(* Saves a message to an output channel.  The message is serialized to</span>
<span class="c">   a bigstring before being written out to the channel.  Also, a</span>
<span class="c">   binary encoding of an integer is written out to tell the reader how</span>
<span class="c">   long of a message to expect.  *)</span>
<span class="k">let</span> <span class="n">save_message</span> <span class="n">outc</span> <span class="n">msg</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Binable</span><span class="p">.</span><span class="n">to_bigstring</span> <span class="n">binable</span> <span class="n">msg</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">Bigstring</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span> <span class="k">in</span>
  <span class="nn">Out_channel</span><span class="p">.</span><span class="n">output_binary_int</span> <span class="n">outc</span> <span class="n">len</span><span class="o">;</span>
  <span class="nn">Bigstring</span><span class="p">.</span><span class="n">really_output</span> <span class="n">outc</span> <span class="n">s</span>

<span class="c">(* Loading the message is done by first reading in the length, and by</span>
<span class="c">   then reading in the appropriate number of bytes into a Bigstring</span>
<span class="c">   created for that purpose. *)</span>
<span class="k">let</span> <span class="n">load_message</span> <span class="n">inc</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">input_binary_int</span> <span class="n">inc</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;Couldn't load message: length missing from header&quot;</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">len</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">Bigstring</span><span class="p">.</span><span class="n">create</span> <span class="n">len</span> <span class="k">in</span>
    <span class="nn">Bigstring</span><span class="p">.</span><span class="n">really_input</span> <span class="o">~</span><span class="n">pos</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">len</span> <span class="n">inc</span> <span class="n">buf</span><span class="o">;</span>
    <span class="nn">Binable</span><span class="p">.</span><span class="n">of_bigstring</span> <span class="n">binable</span> <span class="n">buf</span>

<span class="c">(* To generate some example messages *)</span>
<span class="k">let</span> <span class="n">example</span> <span class="n">content</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">source</span> <span class="o">=</span>
    <span class="o">{</span> <span class="nn">Message</span><span class="p">.</span><span class="nn">Source</span><span class="p">.</span>
      <span class="n">hostname</span> <span class="o">=</span> <span class="s2">&quot;ocaml.org&quot;</span><span class="o">;</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">2322</span> <span class="o">}</span>
  <span class="k">in</span>
  <span class="o">{</span> <span class="nn">Message</span><span class="p">.</span>
    <span class="n">topic</span> <span class="o">=</span> <span class="s2">&quot;rwo-example&quot;</span><span class="o">;</span> <span class="n">content</span><span class="o">;</span> <span class="n">source</span><span class="o">;</span> <span class="o">}</span>

<span class="c">(* write out three messages... *)</span>
<span class="k">let</span> <span class="n">write_messages</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">outc</span> <span class="o">=</span> <span class="nn">Out_channel</span><span class="p">.</span><span class="n">create</span> <span class="s2">&quot;tmp.bin&quot;</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="n">save_message</span> <span class="n">outc</span><span class="o">)</span> <span class="o">[</span>
    <span class="n">example</span> <span class="s2">&quot;a wonderful&quot;</span><span class="o">;</span>
    <span class="n">example</span> <span class="s2">&quot;trio&quot;</span><span class="o">;</span>
    <span class="n">example</span> <span class="s2">&quot;of messages&quot;</span><span class="o">;</span>
  <span class="o">];</span>
  <span class="nn">Out_channel</span><span class="p">.</span><span class="n">close</span> <span class="n">outc</span>

<span class="c">(* ... and read them back in *)</span>
<span class="k">let</span> <span class="n">read_messages</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">inc</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">create</span> <span class="s2">&quot;tmp.bin&quot;</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">load_message</span> <span class="n">inc</span> <span class="k">in</span>
    <span class="n">printf</span> <span class="s2">&quot;msg %d: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span> <span class="n">msg</span><span class="o">.</span><span class="nn">Message</span><span class="p">.</span><span class="n">content</span>
  <span class="k">done</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">write_messages</span> <span class="bp">()</span><span class="o">;</span> <span class="n">read_messages</span> <span class="bp">()</span>
</pre></div></section><section><h1 id="fieldslib">Fieldslib</h1><p id="idp8636672">
      One common idiom when using records is to provide field accessor
      functions for a particular record.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">topic</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
           <span class="n">content</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
           <span class="n">source</span><span class="o">:</span> <span class="nn">Source</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
         <span class="o">}</span>

<span class="k">let</span> <span class="n">topic</span>   <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">topic</span>
<span class="k">let</span> <span class="n">content</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">content</span>
<span class="k">let</span> <span class="n">source</span>  <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">source</span>
</pre></div><p id="idp8638240">
      Similarly, sometimes you simultaneously want an accessor to a
      field of a record and a textual representation of the name of that
      field. This might come up if you were validating a field and
      needed the string representation to generate an error message, or
      if you wanted to scaffold a form in a GUI automatically based on
      the fields of a record. Fieldslib provides a module
      <code>Field</code> for this purpose. Here's some code for
      creating <code>Field.t</code>'s for all the fields of our
      type <code>t</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Fields</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">topic</span> <span class="o">=</span>
      <span class="o">{</span> <span class="nn">Field</span><span class="p">.</span>
        <span class="n">name</span>   <span class="o">=</span> <span class="s2">&quot;topic&quot;</span><span class="o">;</span>
        <span class="n">setter</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">topic</span><span class="o">);</span>
        <span class="n">fset</span>   <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="n">topic</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">t</span> <span class="k">with</span> <span class="n">topic</span> <span class="o">});</span>
      <span class="o">}</span>
    <span class="k">let</span> <span class="n">content</span> <span class="o">=</span>
      <span class="o">{</span> <span class="nn">Field</span><span class="p">.</span>
        <span class="n">name</span>   <span class="o">=</span> <span class="s2">&quot;content&quot;</span><span class="o">;</span>
        <span class="n">setter</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">content</span><span class="o">);</span>
        <span class="n">fset</span>   <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="n">content</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">t</span> <span class="k">with</span> <span class="n">content</span> <span class="o">});</span>
      <span class="o">}</span>
    <span class="k">let</span> <span class="n">source</span> <span class="o">=</span>
      <span class="o">{</span> <span class="nn">Field</span><span class="p">.</span>
        <span class="n">name</span>   <span class="o">=</span> <span class="s2">&quot;source&quot;</span><span class="o">;</span>
        <span class="n">setter</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">source</span><span class="o">);</span>
        <span class="n">fset</span>   <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="n">source</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">t</span> <span class="k">with</span> <span class="n">source</span> <span class="o">});</span>
      <span class="o">}</span>
  <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Fields</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">val</span> <span class="n">topic</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="kt">string</span> <span class="kt">list</span><span class="o">)</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Field</span><span class="p">.</span><span class="n">t</span>
    <span class="k">val</span> <span class="n">content</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="kt">string</span><span class="o">)</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Field</span><span class="p">.</span><span class="n">t</span>
    <span class="k">val</span> <span class="n">source</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="nn">Source</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Field</span><span class="p">.</span><span class="n">t</span>
  <span class="k">end</span>
</pre></div></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt02.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="handling-json-data.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>