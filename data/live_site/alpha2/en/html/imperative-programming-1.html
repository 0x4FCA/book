<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 7. Imperative Programming / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha2',
                        page: 'imperative\u002Dprogramming\u002D1.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">3. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">4. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">5. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">6. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html" class="here">7. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">8. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 7. Imperative Programming</h1>
                
                

    <p id="idp7925824">
    The OCaml programming language is <span><em>functional</em></span>,
    meaning that functions are first-class values that can be passed
    around like any other. However, this doesn't mean that OCaml
    programs are <span><em>pure</em></span>.
  </p><p id="idp7927152">
    Pure functions behave like mathematical functions, which means that
    they always evaluate to the same result on the same arguments,
    without any side-effects on the state or input/output. In pure
    programs, evaluation order may affect performance, but it doesn't
    affect correctness. In contrast, <span><em>imperative</em></span>
    programs operate through side-effects on the state (as well as
    input/output). Imperative programs define sequences of commands for
    the computer to perform, and evaluation order is strict.
  </p><p id="idp7928480">
    While the majority of code you write in OCaml may be pure,
    imperative programming can be used effectively. The language
    includes assignment and mutable values like arrays and strings.
    Evaluation order is strict and sequential. In principle, you can
    port many imperative programs directly to OCaml. If you find
    yourself using imperative features a lot, then you're probably not
    using OCaml to its fullest. However, there are times when imperative
    programming is both appropriate and efficient, and OCaml shines at
    supporting programs with both functional and imperative aspects.
  </p><p id="idp7929504">
    To illustrate imperative programming, let's start by implementing a
    hash table. Hash tables are an efficient way to implement imperative
    <span><em>dictionaries</em></span>, which implement a map from keys
    to values. There are full-featured implementations of hash tables in
    Core as well as in the OCaml standard library. For illustration,
    we'll construct just a basic dictionary using <span><em>open
    hashing</em></span>, where the hash table consists of an array of
    buckets, each of which contain a linked list of elements. We'll use
    regular (pure) OCaml lists, and an array for the buckets.
  </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">HashMap</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">option</span>
  <span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="kt">list</span> <span class="kt">array</span>

  <span class="k">let</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">17</span>
  <span class="k">let</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span><span class="o">)</span> <span class="ow">mod</span> <span class="n">num_buckets</span>

  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="n">num_buckets</span> <span class="bp">[]</span>

  <span class="k">let</span> <span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
    <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="o">::</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">find</span> <span class="o">=</span> <span class="k">function</span>
     <span class="o">|</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">k</span> <span class="o">=</span> <span class="n">key</span> <span class="k">then</span> <span class="nc">Some</span> <span class="n">d</span> <span class="k">else</span> <span class="n">find</span> <span class="n">t</span>
     <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="k">in</span>
    <span class="n">find</span> <span class="n">table</span><span class="o">.(</span><span class="n">hash_bucket</span> <span class="n">key</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">iter</span> <span class="n">table</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">num_buckets</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">table</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span><span class="o">)</span>
    <span class="k">done</span>
<span class="k">end</span>
</pre></div><p id="idp7933312">
    The signature for the <code>HashMap</code> declares the type
    of dictionaries <code>('a, 'b) t</code>, with keys of type
    <code>'a</code> and associated values of type
    <code>'b</code>. It also includes functions for add, removing,
    and enumerating entries in the dictionary.
  </p><p id="idp7936304">
    The table is implemented as an array of buckets (the array is
    fixed-size, in this example). The OCaml runtime provides a builtin
    polymorphic hash function <code>Hashtbl.hash</code> that works
    for almost any value in OCaml, excluding functions and values from C
    libraries that live outside the heap.
  </p><ul><li><p id="idp7938160">
        The <code>create</code> function creates a new array where
        all buckets are empty.
      </p></li><li><p id="idp7939648">
        The <code>add</code> function uses the hash function to
        determine the appropriate bucket, then adds a new key/value
        association to the bucket through an array
        <span><em>assignment</em></span>
<code>table.(index) &lt;- (key, data) :: table.(index)</code>,
        which <span><em>replaces</em></span> the bucket with a new one
        where the new key/value pair is added to the front of the list.
      </p></li><li><p id="idp7942880">
        The <code>find</code> function performs a linear search
        through the appropriate bucket to find the value associated with
        a key.
      </p></li><li><p id="idp7944416">
        The <code>iter</code> function iterates through each of
        the elements in the buckets.
      </p></li></ul><section><h1 id="imperative-operations">Imperative operations</h1><p id="idp7946656">
      This example illustrates one of the mutating operations in OCaml:
      array element assignment. There are a handful of other mutable
      data types.
    </p><ul><li><p id="idp7947728">
          Arrays. Array elements can be assigned with the expression
          <code>array.(index) &lt;-   expr</code>. See the
          <code>Array</code> module for other imperative
          operations. Bigarray elements can be mutated with the syntax
          <code>bigarray.{index} &lt;- expr</code>.
        </p></li><li><p id="idp7950592">
          Strings. String elements can be mutated with the expression
          <code>string.[index]   &lt;- char</code>. See the
          <code>String</code> module for other imperative
          operations.
        </p></li><li><p id="idp7952784">
          Record fields can be mutated with the expression
          <code>record.label &lt;- expr</code>. The field
          <code>label</code> must be declared as
          <code>mutable</code> in the type definition for the
          record.
        </p></li><li><p id="idp7955584">
          Object fields can be mutated with the expression
          <code>object.label &lt;- expr</code>. The field
          <code>label</code> must be declared as
          <code>mutable</code> in the object definition.
        </p></li></ul><p id="idp7958176">
      Note that variables are not mutable. Variables can refer to
      mutable data, but the binding of a variable cannot be changed. For
      convenience, OCaml defines a type of &quot;reference cell,&quot;
      which is a like a &quot;box&quot; where the contents can be
      mutated.
    </p><ul><li><p id="idp7959456">
<code>ref expr</code> constructs a reference cell
          containing the value defined by the expression
          <code>expr</code>.
        </p></li><li><p id="idp7961584">
<code>! refcell</code> returns the contents of the
          reference cell.
        </p></li><li><p id="idp7963056">
<code>refcell := expr</code> replaces the contents of
          the reference cell.
        </p></li></ul><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">1</span><span class="o">}</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">7</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span>
<span class="o">#</span> <span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="mi">12</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">x</span><span class="o">.</span><span class="n">contents</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">12</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div><p id="idp7965504">
      As the example shows, reference cells are actually just a short
      form for record operations. The <code>ref</code> type is a
      record with a single mutable field <code>contents</code>,
      with the following definition. The expression
      <code>!x</code> is equivalent to
      <code>x.contents</code>, and <code>x := e</code> is
      equivalent to <code>x.contents &lt;- e</code>.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="n">contents</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">};;</span>
</pre></div></section><section><h1 id="looping">Looping</h1><p id="idp7971712">
      The <code>iter</code> function iterates through all of the
      elements in the table using a <code>for</code> loop. There
      are two kinds of loops in OCaml, <code>for</code> loops and
      <code>while</code> loops.
    </p><div class="highlight"><pre><span class="k">for</span> <span class="n">index</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">initial</span><span class="o">&gt;</span> <span class="k">to</span> <span class="o">&lt;</span><span class="n">final</span><span class="o">&gt;</span> <span class="k">do</span> <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span> <span class="k">done</span>
<span class="k">for</span> <span class="n">index</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">initial</span><span class="o">&gt;</span> <span class="k">downto</span> <span class="o">&lt;</span><span class="n">final</span><span class="o">&gt;</span> <span class="k">do</span> <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span> <span class="k">done</span>
<span class="k">while</span> <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span> <span class="k">do</span> <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span> <span class="k">done</span>
</pre></div><p id="idp7975712">
      A loop using <code>to</code> advances by from the
      <code>&lt;initial&gt;</code> integer to the
      <code>&lt;final&gt;</code> one (inclusive). No iterations
      are evaluated if <code>&lt;final&gt;</code> is smaller than
      <code>&lt;initial&gt;</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span>
  <span class="k">done</span><span class="o">;;</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp7980352">
      A <code>downto</code> loop advances downward by 1 on each
      iteration. Again, the bounds <code>&lt;initial&gt;</code>
      and <code>&lt;final&gt;</code> are inclusive.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span> <span class="k">done</span><span class="o">;;</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp7983840">
      A while-loop iterates until the condition is false.
    </p><div class="highlight"><pre><span class="c">(* reverses an array in place. *)</span>
<span class="k">let</span> <span class="n">rev_inplace</span> <span class="n">t</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="n">length</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">j</span><span class="o">;</span> <span class="k">do</span>
    <span class="n">swap</span> <span class="n">t</span> <span class="o">!</span><span class="n">i</span> <span class="o">!</span><span class="n">j</span><span class="o">;</span>
    <span class="n">incr</span> <span class="n">i</span><span class="o">;</span>
    <span class="n">decr</span> <span class="n">j</span><span class="o">;</span>
  <span class="k">done</span><span class="o">;;</span>
</pre></div></section><section><h1 id="doubly-linked-lists">Doubly-linked lists</h1><p id="idp7986432">
      Another common imperative data structure is the doubly-linked
      list, which allows traversal in both directions, as well as O(1)
      deletion of any element. Doubly-linked lists are a cyclic data
      structure, meaning that it is possible to follow a nontrivial
      sequence of references from an element, through other elements,
      back to itself. In general, building cyclic data structures
      requires the use of side-effects (although in some limited cases,
      they can be constructed using <code>let rec</code>). This is
      done by constructing the data elements first, and then adding
      cycles using assignment afterwards.
    </p><p id="idp7988128">
      Core defines a standard doubly-linked list, but let's define our
      own implementation for illustration. First, we define an element
      <code>'a element</code> with a reference both to the
      previous and next elements. The elements at the ends have nothing
      to refer to, so we use an option to allow the reference to be
      <code>None</code>. The element record fields are declared as
      <code>mutable</code> to allow them to be modified when the
      list is mutated.
    </p><p id="idp7990816">
      The list itself is either empty, or it refers to the first element
      of the list. We use the type
      <code>type 'a dlist = 'a element option ref</code>; the
      <code>ref</code> allows the list to be mutated, and the
      value is either <code>None</code> for the empty list, or
      <code>Some first_element</code> if the list is non-empty.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">=</span>
  <span class="o">{</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">previous</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
  <span class="o">}</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">dlist</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span> <span class="n">ref</span>

<span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>

<span class="k">let</span> <span class="n">is_empty</span> <span class="n">l</span> <span class="o">=</span> <span class="o">(!</span><span class="n">l</span> <span class="o">=</span> <span class="nc">None</span><span class="o">)</span>

<span class="k">let</span> <span class="n">value</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">value</span>

<span class="k">let</span> <span class="n">first</span> <span class="n">l</span> <span class="o">=</span> <span class="o">!</span><span class="n">l</span>
<span class="k">let</span> <span class="n">next</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">next</span>
<span class="k">let</span> <span class="n">previous</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">previous</span>
</pre></div><p id="idp7995104">
      The function <code>create</code> creates an empty list. The
      function <code>is_empty l</code> dereferences the list using
      the <code>!</code> operator, returning true if the value is
      <code>None</code>, or false otherwise. The
      <code>value</code> function returns the value stored in an
      element. The <code>first</code>, <code>next</code>,
      and <code>previous</code> functions allow navigation through
      the list.
    </p><p id="idp8000640">
      Next, let's define the function that inserts a value into the list
      as a new first element. We define a new element
      <code>elt</code>, link it into the list, and set the list
      reference.
    </p><div class="highlight"><pre>   <span class="k">let</span> <span class="n">insert_first</span> <span class="n">l</span> <span class="n">value</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">elt</span> <span class="o">=</span> <span class="o">{</span> <span class="n">previous</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="o">!</span><span class="n">l</span><span class="o">;</span> <span class="n">value</span> <span class="o">}</span> <span class="k">in</span>
     <span class="k">begin</span> <span class="k">match</span> <span class="o">!</span><span class="n">l</span> <span class="k">with</span>
     <span class="o">|</span> <span class="nc">Some</span> <span class="n">old_first</span> <span class="o">-&gt;</span> <span class="n">old_first</span><span class="o">.</span><span class="n">previous</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">elt</span>
     <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
     <span class="k">end</span><span class="o">;</span>
     <span class="n">l</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">elt</span><span class="o">;</span>
     <span class="n">elt</span>
</pre></div><p id="idp8003024">
      This example introduces the sequencing operator
      <code>;</code> to separate the steps to be executed in
      order: first, create the new element <code>elt</code>; then
      set <code>old_first.previous</code> to point to it; then set
      the list <code>l</code> to refer to the
      <code>elt</code> element; then return the element
      <code>elt</code>.
    </p><p id="idp8007328">
      In general, when a sequence expression
      <code>expr1; expr2</code> is evaluated,
      <code>expr1</code> is evaluated first, and then
      <code>expr2</code>. The expression <code>expr1</code>
      must have type <code>unit</code>, and the the value of
      <code>expr2</code> is returned as the value of the entire
      sequence. For example, the sequence
      <code>print_string &quot;hello world&quot;; 1 + 2</code>
      first prints the string
      <code>&quot;hello world&quot;</code>, then returns the
      integer <code>3</code>.
    </p><p id="idp8013536">
      There are a few more things to note. First, semicolon
      <code>;</code> is a <span><em>separator</em></span>, not a
      terminator, like it is in C or Java. The compiler is somewhat
      relaxed about parsing a terminating semicolon, so it may work for
      you, but you should not rely on it.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">print_string</span> <span class="s2">&quot;Hello world</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="k">in</span> <span class="n">i</span><span class="o">;;</span>
<span class="nc">Hello</span> <span class="n">world</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8016272">
      Also note, the precedence of a <code>match</code> expression
      is very low, so to separate it from the following assignment
      <code>l := Some new_front</code>, we surround the match in a
      <code>begin ... end</code> bracketing (we could also use
      parentheses). If we did not, the final assignment would become
      part of the <code>None -&gt; ...</code> case, which is not
      what we want.
    </p><p id="idp8019376">
      To complete this initial part of the implementation, let's define
      a function for removal.
    </p><div class="highlight"><pre>   <span class="k">let</span> <span class="n">remove</span> <span class="n">l</span> <span class="n">elt</span> <span class="o">=</span>
     <span class="k">let</span> <span class="o">{</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span> <span class="o">}</span> <span class="o">=</span> <span class="n">elt</span> <span class="k">in</span>
     <span class="o">(</span><span class="k">match</span> <span class="n">previous</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="n">next</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">check_is_first_element</span> <span class="n">l</span> <span class="n">elt</span><span class="o">;</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">next</span><span class="o">);</span>
     <span class="o">(</span><span class="k">match</span> <span class="n">next</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">previous</span> <span class="o">&lt;-</span> <span class="n">previous</span><span class="o">;</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
     <span class="n">elt</span><span class="o">.</span><span class="n">previous</span> <span class="o">&lt;-</span> <span class="nc">None</span><span class="o">;</span>
     <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="nc">None</span>
</pre></div><p id="idp8021280">
      The <code>remove</code> function unlinks the element from
      the list, the resets the <code>previous</code> and
      <code>next</code> links to <code>None</code>. For
      safety, we detect duplicate removals with a check. In the case
      where the previous element is <code>None</code>, the element
      must be first in the list. Here is the implementation of the
      <code>check_is_first_element</code> function.
    </p><div class="highlight"><pre>   <span class="k">let</span> <span class="n">check_is_first_element</span> <span class="n">l</span> <span class="n">elt1</span> <span class="o">=</span>
      <span class="k">match</span> <span class="o">!</span><span class="n">l</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">elt2</span> <span class="k">when</span> <span class="n">elt1</span> <span class="o">==</span> <span class="n">elt2</span> <span class="o">-&gt;</span> <span class="bp">()</span>
      <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;element has already been removed&quot;</span><span class="o">)</span>
</pre></div></section><section><h1 id="iteration">Iteration</h1><p id="idp8027792">
      When defining containers like lists, dictionaries, trees, etc. it
      is conventional to define some kind of iteration to allow the
      elements of the collection to be enumerated. When the containers
      are immutable, like <code>'a list</code>, this is normaly
      done with functions like <code>iter</code>,
      <code>map</code>, and <code>fold</code>. Each of these
      iteration functions takes a function that will be applied to each
      of the elements in order.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span>  <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Element: %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span><span class="o">);;</span>
<span class="nc">Element</span><span class="o">:</span> <span class="mi">1</span>
<span class="nc">Element</span><span class="o">:</span> <span class="mi">2</span>
<span class="nc">Element</span><span class="o">:</span> <span class="mi">3</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span> <span class="o">~</span><span class="n">f</span><span class="o">:((+)</span> <span class="mi">10</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">11</span><span class="o">;</span> <span class="mi">12</span><span class="o">;</span> <span class="mi">13</span><span class="o">]</span>
</pre></div><p id="idp8032336">
      Defining this for doubly-linked lists is simple enough. The
      following function iterates through the list, applying the
      function <code>f</code> to each element in turn.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">iter</span> <span class="n">l</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">v</span><span class="o">;</span> <span class="n">loop</span> <span class="n">next</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="o">!</span><span class="n">l</span><span class="o">;;</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">create</span> <span class="bp">()</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">2</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">3</span><span class="o">;</span>
  <span class="n">iter</span> <span class="n">l</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Item: %d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">);;</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">3</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">2</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">1</span>
</pre></div><p id="idp8034960">
      This style of iteration is concise and completely general.
      However, with imperative containers, we often want more control.
      We may not want to iterate through all elements, and we often want
      to mutate the container as we iterate. One conventional way to do
      this is to define a generic <code>iterator</code> type that
      can be used to enumerate and/or mutate the elements in a
      container. This is a style seen, for example, in Java (type
      <code>Iterator</code>) or the C++ Standard Template Library.
    </p><p id="idp8037088">
      Let's define a Java-style kind of generic iterator object that
      allows manual enumeration and mutation of the container. Here is
      the Java interface.
    </p><div class="highlight"><pre><span class="kd">public</span> <span class="n">iterface</span> <span class="n">Iterator</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">next</span><span class="o">();</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">();</span>
<span class="o">};</span>
</pre></div><p id="idp8038656">
      At any time, a <code>Iterator</code> object refers
      (optionally) to some element of a container. The
      <code>hasNext()</code> method returns true if the iterator
      refers to an element; the method <code>next()</code> returns
      the element, and also advances to the next one; and
      <code>remove()</code> removes the last element returned by
      the iterator.
    </p><p id="idp8041904">
      When we define a similar iterator concept in OCaml, we need to
      choose how to represent it. We <span><em>could</em></span> define a
      separate iterator type for each kind of container, but this would
      be inconvenient, since iterators have similar behavior for many
      different kinds of containers. To define a
      <span><em>generic</em></span> iterator, there are several
      reasonable choices: we can use first-class modules, or we can use
      objects. One of the simpler approaches is to use objects.
    </p><p id="idp8043600">
      You can skip forward to the Objects chapter for more informatation
      about objects, but we'll be using basic objects, which are just
      collections of methods, similar to having a record of functions --
      we could also implement the iterator as a record of functions, but
      the code would be somewhat more verbose.
    </p><p id="idp8044336">
      First, we need to define a generic iterator type. For clarity,
      we'll use a more verbose type than in Java. We'll separate
      retrieving a value from advacing to the next element. The object
      type is specified like a record type, but using angle brackets
      <code>&lt; ... &gt;</code>.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span>
   <span class="o">&lt;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">remove</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
</pre></div><p id="idp8046736">
      Each of the labeled parts <code>has_value</code>,
      <code>value</code>, etc. are object
      <span><em>methods</em></span>. This object type corresponds to an
      <span><em>interface</em></span> consisting of a set of methods.
    </p><p id="idp8049136">
      Next, to define the iterator implementation, we implement each of
      the methods, bracketed by <code>object ... end</code>,
      declaring each method with the <code>method</code> keyword.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">iterator</span> <span class="o">(</span><span class="kt">list</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">!</span><span class="kt">list</span> <span class="k">in</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="o">!</span><span class="n">current</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>
    <span class="k">method</span> <span class="n">value</span> <span class="o">=</span>
      <span class="k">match</span> <span class="o">!</span><span class="n">current</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="n">v</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;next&quot;</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
      <span class="k">match</span> <span class="o">!</span><span class="n">current</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="n">current</span> <span class="o">:=</span> <span class="n">next</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;next&quot;</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">remove</span> <span class="o">=</span>
      <span class="k">match</span> <span class="o">!</span><span class="n">current</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span> <span class="o">}</span> <span class="o">-&gt;</span>
            <span class="o">(</span><span class="k">match</span> <span class="n">previous</span> <span class="k">with</span>
              <span class="o">|</span> <span class="nc">Some</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">el</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="n">next</span>
              <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="kt">list</span> <span class="o">:=</span> <span class="n">next</span><span class="o">);</span>
            <span class="o">(</span><span class="k">match</span> <span class="n">next</span> <span class="k">with</span>
              <span class="o">|</span> <span class="nc">Some</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">el</span><span class="o">.</span><span class="n">previous</span> <span class="o">&lt;-</span> <span class="n">previous</span><span class="o">;</span>
              <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
            <span class="n">current</span> <span class="o">:=</span> <span class="n">next</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;remove&quot;</span><span class="o">)</span>
  <span class="k">end</span>
</pre></div><p id="idp8052896">
      The reference cell <code>current</code> holds the current
      position in the list. The method <code>has_value</code>
      returns true if <code>current</code> refers to an element,
      <code>value</code> returns the element, and
      <code>next</code> advances the iterator. The method
      <code>remove</code> unlinks the <code>current</code>
      element by setting the previous element's <code>next</code>
      pointer, and the next's elements <code>previous</code>
      pointer, then advancing <code>current</code> to the next
      element. The following example illustrates the semantics.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">create</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">l</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="n">dlist</span>
<span class="o">#</span> <span class="n">push_front</span> <span class="n">l</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">2</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">3</span><span class="o">;</span>
  <span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Item: %d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span> <span class="n">l</span><span class="o">;;</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">3</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">2</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">1</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">iterator</span> <span class="n">l</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">remove</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span> <span class="n">l</span><span class="o">;;</span>
<span class="mi">3</span>
<span class="mi">1</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8061472">
      Note that the doubly-linked list is a <span><em>cyclic</em></span>
      data structure. Most notably, the builtin equality <span><em>does
      not work</em></span> in general with cyclic values.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">create</span><span class="bp">()</span><span class="o">;</span>
<span class="k">val</span> <span class="n">l2</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="n">dlist</span>
<span class="o">#</span> <span class="n">push_front</span> <span class="n">l2</span> <span class="mi">1</span><span class="o">;</span> <span class="n">push_front</span> <span class="n">l2</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">l</span> <span class="o">==</span> <span class="n">l2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;;</span>
<span class="nc">Out</span> <span class="k">of</span> <span class="n">memory</span> <span class="n">during</span> <span class="n">evaluation</span><span class="o">.</span>
</pre></div></section><section><h1 id="doubly-linked-list-module">Doubly-linked list module</h1><p id="idp8064752">
      Now that we have defined iterators, let's declare the complete
      signature for doubly-linked lists as a module. The type of
      elements <code>'a element</code> is internal to the
      implementation, and the type of lists
      <code>'a DList.t</code> is abstract.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">DList</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">push_front</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">val</span> <span class="n">front</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
   <span class="k">val</span> <span class="n">pop_front</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
   <span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">val</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
   <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
<span class="k">end</span>
</pre></div><p id="idp8068096">
      We have seen the definition of all of the functions except
      <code>find</code>, which searches for an element in the list
      (sequentially), returning an iterator that refers to that element
      if it exists. The implementation simply creates an iterator, then
      uses a loop to search sequentially for the element. If the element
      is found, the returned iterator refers to that value, otherwise
      the iterator does not have a value.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">DList</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="o">...</span>

   <span class="k">let</span> <span class="n">find</span> <span class="n">l</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">iterator</span> <span class="n">l</span> <span class="k">in</span>
     <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span> <span class="o">&lt;&gt;</span> <span class="n">data</span> <span class="k">do</span>
        <span class="n">it</span><span class="o">#</span><span class="n">next</span>
     <span class="k">done</span><span class="o">;</span>
     <span class="n">it</span>
<span class="k">end</span>
</pre></div></section><section><h1 id="hash-tables-with-iterators">Hash tables with iterators</h1><p id="idp8071696">
      Let's return to the example of hash tables, but this time let's
      define an iterator-style interface. We'll use the same
      <code>iterator</code> object type as we did for
      doubly-linked lists, but this time the iteration is over key/value
      pairs. The signature changes slightly, the main change being tat
      the <code>find</code> function returns an iterator. This
      allows retrieval of the value associated with a key, and it also
      allows the entry to be deleted.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">IterableHashMap</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">iterator</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">iterator</span>
  <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">iterator</span>
<span class="k">end</span>
</pre></div><p id="idp8075072">
      The implementation of <code>IterableHashMap</code> is
      similar to the original <code>HashMap</code> using lists,
      except now we will use doubly-linked lists. The
      <code>create</code> function creates an array of
      doubly-linked lists. The <code>add</code> function first
      removes any existing entry, then add the new element to the front
      of the bucket.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">IterableHashMap</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">DList</span><span class="p">.</span><span class="n">t</span> <span class="kt">array</span>

  <span class="k">let</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">17</span>
  <span class="k">let</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span><span class="o">)</span> <span class="ow">mod</span> <span class="n">num_buckets</span>

  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">num_buckets</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nn">DList</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">DList</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">~</span><span class="n">data</span><span class="o">:(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">then</span> <span class="n">it</span><span class="o">#</span><span class="n">remove</span><span class="o">;</span>
    <span class="nn">DList</span><span class="p">.</span><span class="n">push_front</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span>

  <span class="o">...</span>
<span class="k">end</span>
</pre></div><p id="idp8080464">
      We can define iterators in the hash table as a pair of a bucket
      index and <code>DList</code> iterator into the bucket. To
      define this as an object, we'll introduce a few more object
      concepts, including mutable fields, private methods, and
      initializers. The function
      <code>make_iterator table index_ dlist_it_</code> returns an
      iterator for the bucket with index <code>index_</code> and
      list iterator <code>dlist_it_</code>.
    </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">make_iterator</span> <span class="n">table</span> <span class="n">index_</span> <span class="n">dlist_it_</span> <span class="o">=</span>
    <span class="k">object</span> <span class="o">(</span><span class="n">self</span><span class="o">)</span>
      <span class="k">val</span> <span class="k">mutable</span> <span class="n">index</span> <span class="o">=</span> <span class="n">index_</span>
      <span class="k">val</span> <span class="k">mutable</span> <span class="n">dlist_it</span> <span class="o">=</span> <span class="n">dlist_it_</span>
      <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">dlist_it</span><span class="o">#</span><span class="n">has_value</span>
      <span class="k">method</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dlist_it</span><span class="o">#</span><span class="n">value</span>
      <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
         <span class="n">dlist_it</span><span class="o">#</span><span class="n">next</span><span class="o">;</span>
         <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
      <span class="k">method</span> <span class="n">remove</span> <span class="o">=</span>
         <span class="n">dlist_it</span><span class="o">#</span><span class="n">remove</span><span class="o">;</span>
         <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
      <span class="k">method</span> <span class="k">private</span> <span class="n">normalize</span> <span class="o">=</span>
        <span class="k">while</span> <span class="n">not</span> <span class="n">dlist_it</span><span class="o">#</span><span class="n">has_value</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">num_buckets</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="n">index</span> <span class="o">&lt;-</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
          <span class="n">dlist_it</span> <span class="o">&lt;-</span> <span class="nn">DList</span><span class="p">.</span><span class="n">iterator</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span>
        <span class="k">done</span>
      <span class="k">initializer</span> <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
    <span class="k">end</span>
</pre></div><p id="idp8085376">
      The iterator implementation relies on a &quot;normal&quot; form,
      where the list iterator <span><em>always</em></span> refers to an
      element. This is handled by the <code>normalize</code>
      method, which advances past empty buckets until either a non-empty
      bucket is found, or the end of the table is reached.
    </p><p id="idp8087040">
      The <code>normalize</code> method is declared a
      <code>private</code>, so that it does not appear as part of
      the iterator type. The <code>has_value</code> and
      <code>value</code> methods delagate directly to the list
      iterator. The <code>next</code> and
      <code>remove</code> methods also delagate to the list
      iterator; however, since the iterator has been mutated, the
      <code>normalize</code> method is called to advance to the
      next element.
    </p><p id="idp8092160">
      There are several more things to note. The syntax
      <code>object (self) ... end</code> means that the variable
      <code>self</code> refers to the object itself, allowing
      other method in the object to be called (like
      <code>self#normalize</code>). The fields
      <code>index</code> and <code>dlist_it</code> are
      declared as <code>val mutable</code>, which means that they
      can be modified by assignment using the <code>&lt;-</code>
      syntax seen in the <code>normalize</code> method. Finally,
      the object also has an <code>initializer</code> expression,
      which is called when the object is first created, in this case
      normalizing the iterator.
    </p><p id="idp8098560">
      Now that the iterator is defined, we can complete the
      <code>IterableHashMap</code> implementation.
    </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">iterator</span> <span class="n">table</span> <span class="o">=</span>
    <span class="n">make_iterator</span> <span class="n">table</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">DList</span><span class="p">.</span><span class="n">iterator</span> <span class="n">table</span><span class="o">.(</span><span class="mi">0</span><span class="o">))</span>

  <span class="k">let</span> <span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">DList</span><span class="p">.</span><span class="n">iterator</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="o">&amp;&amp;</span> <span class="n">fst</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span> <span class="o">&lt;&gt;</span> <span class="n">key</span> <span class="k">do</span>
      <span class="n">it</span><span class="o">#</span><span class="n">next</span>
    <span class="k">done</span><span class="o">;</span>
    <span class="k">if</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">then</span>
       <span class="n">make_iterator</span> <span class="n">table</span> <span class="n">index</span> <span class="n">it</span>
    <span class="k">else</span>
       <span class="n">make_iterator</span> <span class="n">table</span> <span class="n">num_buckets</span> <span class="n">it</span>
</pre></div><p id="idp8100944">
      The <code>iterator</code> function returns in iterator that
      refers to the first element in the table (if the table is
      non-empty). The <code>find</code> function searches for an
      element in the table, returning an iterator referring to that
      value if found, or else the an iterator at the end of the table.
    </p></section><section><h1 id="lazy-computation">Lazy computation</h1><p id="idp8103920">
      There are many instances where imperative programming is used to
      change or improve the performance characteristics of a program,
      without otherwise changing the behavior. In other words, the
      program could be written without side-effects, but performance is
      improved by techniques like lazy computation, caching,
      memoization, etc.
    </p><p id="idp8104688">
      One of the simplest of these is the builtin lazy computation. The
      keyword <code>lazy</code> can be used to prefix any
      expression, returning a value of type
      <code>'a Lazy.t</code>. The computation is delayed until
      forced with the <code>Lazy.force</code> function, and then
      saved thereafter.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">print_string</span> <span class="s2">&quot;performing lazy computation</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="mi">1</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">v</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">lazy_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">lazy</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="n">performing</span> <span class="k">lazy</span> <span class="n">computation</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div><p id="idp8108272">
      The builtin <code>lazy</code> computation has a nice syntax,
      but the technique is pretty generic, and we can implement it with
      a mutable value.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">ImpLazy</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">force</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">delayed</span> <span class="o">=</span> <span class="nc">Delayed</span> <span class="k">of</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">|</span> <span class="nc">Value</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="n">delayed</span> <span class="n">ref</span>

   <span class="k">let</span> <span class="n">create</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="nc">Delayed</span> <span class="n">f</span><span class="o">)</span>
   <span class="k">let</span> <span class="n">force</span> <span class="n">v</span> <span class="o">=</span>
     <span class="k">match</span> <span class="o">!</span><span class="n">v</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Delayed</span> <span class="n">f</span> <span class="o">-&gt;</span>
           <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span>
           <span class="n">v</span> <span class="o">:=</span> <span class="nc">Value</span> <span class="n">x</span><span class="o">;</span>
           <span class="n">x</span>
      <span class="o">|</span> <span class="nc">Value</span> <span class="n">x</span> <span class="o">-&gt;</span>
           <span class="n">x</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8111184">
      The <code>'a delayed</code> type contains a delayed value
      represented as a function, or else an actual value. The
      <code>ImpLazy.force</code> function forces the computation;
      if it is delayed, the function is evaluated, and the value is
      mutated to save the resulting value. Subsequent calls to
      <code>ImpLazy.force</code> will fall into the
      <code>Value</code> case, without needing to reevaluate the
      function. The main difference between our module
      <code>ImpLazy</code> and the builtin module
      <code>Lazy</code> is the nice syntax for the latter. Rather
      than writing <code>ImpLazy.create (fun () -&gt; e)</code>,
      the builtin syntax is just <code>lazy e</code>.
    </p><section><h1 id="memoization">Memoization</h1><p id="idp8117936">
        We can generalize lazy computations to function
        <span><em>memoization</em></span>, where we save the result of
        function applications to avoid their recomputation. One simple
        implementation is to use a hash table to save the values by side
        effect.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Memo</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">apply</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">arg</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">t</span>

   <span class="k">let</span> <span class="n">create</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">create</span>
   <span class="k">let</span> <span class="n">apply</span> <span class="n">table</span> <span class="o">~</span><span class="n">func</span> <span class="o">~</span><span class="n">arg</span> <span class="o">=</span>
      <span class="k">try</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">arg</span> <span class="k">with</span>
         <span class="nc">Not_found</span> <span class="o">-&gt;</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">func</span> <span class="n">arg</span> <span class="k">in</span>
            <span class="nn">HashMap</span><span class="p">.</span><span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">arg</span> <span class="o">~</span><span class="n">data</span><span class="o">:</span><span class="n">x</span><span class="o">;</span>
            <span class="n">x</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8120784">
        Memoization is useful for <span><em>dynamic
        programming</em></span>, where problems are solved by breraking
        them down into simpler subproblems. If subproblems occur more
        than once, memoization can be used to avoid recomputing the
        subproblem. A canonical example of this is the Fibonacci
        sequence, which is defined by the following program, which
        produces the sequence <span><em>0, 1, 1, 2, 3, 5, 8, 13, 21,
        ...</em></span> starting from 0.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">=</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);;</span>
</pre></div><p id="idp8123344">
        The complexity of this function is exponential
        <span><em>O(2^i)</em></span>, because for large inputs the
        function computes two similar-sized subproblems. To illustrate,
        let's time the computation using the <code>Sys.time</code>
        function to measure the wall clock.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">time</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">time</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="k">in</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Time: %g sec</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">time</span> <span class="bp">()</span> <span class="o">-.</span> <span class="n">start</span><span class="o">);</span>
    <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">time</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">time</span> <span class="n">fib</span> <span class="mi">40</span><span class="o">;;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">5</span><span class="o">.</span><span class="mi">53724</span> <span class="n">sec</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">102334155</span>
</pre></div><p id="idp8126208">
        Next, let's construct a memoized version of the function, where
        the recursive calls are made through a memo table. This makes a
        dramatic improvement in performance. Since the recursive calls
        are computed just once, the complexity is linear, and the
        computation is fast.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">memo_fib</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">memo</span> <span class="o">=</span> <span class="nn">Memo</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span>
         <span class="n">i</span>
      <span class="k">else</span>
         <span class="nn">Memo</span><span class="p">.</span><span class="n">apply</span> <span class="n">memo</span> <span class="o">~</span><span class="n">func</span><span class="o">:</span><span class="n">fib</span> <span class="o">~</span><span class="n">arg</span><span class="o">:(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span>
         <span class="nn">Memo</span><span class="p">.</span><span class="n">apply</span> <span class="n">memo</span> <span class="o">~</span><span class="n">func</span><span class="o">:</span><span class="n">fib</span> <span class="o">~</span><span class="n">arg</span><span class="o">:(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="n">fib</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">memo_fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">time</span> <span class="n">memo_fib</span> <span class="mi">40</span><span class="o">;;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mf">3.7e-05</span> <span class="n">sec</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">102334155</span>
</pre></div><p id="idp8128480">
        Note that this use of memoization relies on side-effects to
        cache intermediate computations, but it doesn't change the
        values of the function. Its purpose is to improve performance.
      </p></section><section><h1 id="hash-consing">Hash consing</h1><p id="idp8130096">
        &quot;Hash consing&quot; is a technique to share values that are
        structurally equal. The term comes from Lisp, where the
        technique is used to share s-expressions that are equal. In some
        situations, hash-consing can result in dramatic performance
        improvements in two ways. First, space can be reduced by using a
        single physical representation for values that are equal.
        Second, values can be compared for equality using the
        constant-time physical equality operator <code>==</code>.
      </p><p id="idp8132240">
        One of the simplest ways to implement hash-consing is to use a
        hash-table to remember (memoize) values that have already been
        created. To illustrate, let's define a kind of numerical
        expression <code>Exp.t</code> consisting of integers,
        variables, addition, and multiplication (we can define more
        operators, but let's keep the example simple).
      </p><p id="idp8133664">
        The type <code>Exp.t</code> is declared as
        <code>private</code>, meaning that pattern matching can be
        used on the expressions outside the module, but expressions
        can't be constructed without explicitly using the constructors
        <code>num</code>, <code>var</code>,
        <code>plus</code>, <code>times</code> provided by
        the <code>Exp</code> module. These functions enforce the
        hash-consing, ensuring that structurally equal expressions are
        mapped to physically equal representations.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Exp</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="k">private</span>
   <span class="o">|</span> <span class="nc">Num</span> <span class="k">of</span> <span class="kt">int</span>
   <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
   <span class="o">|</span> <span class="nc">Plus</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
   <span class="o">|</span> <span class="nc">Times</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">num</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">var</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">times</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span>
   <span class="o">|</span> <span class="nc">Num</span> <span class="k">of</span> <span class="kt">int</span>
   <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
   <span class="o">|</span> <span class="nc">Plus</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
   <span class="o">|</span> <span class="nc">Times</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">let</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span>
  <span class="k">let</span> <span class="n">merge</span> <span class="n">exp</span> <span class="o">=</span>
     <span class="k">try</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">exp</span> <span class="k">with</span>
        <span class="nc">Not_found</span> <span class="o">-&gt;</span>
           <span class="nn">HashMap</span><span class="p">.</span><span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">exp</span> <span class="o">~</span><span class="n">data</span><span class="o">:</span><span class="n">exp</span><span class="o">;</span>
           <span class="n">exp</span>

  <span class="k">let</span> <span class="n">num</span> <span class="n">i</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">i</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">var</span> <span class="n">s</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Var</span> <span class="n">s</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">plus</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Plus</span> <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>
  <span class="k">let</span> <span class="n">times</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Times</span> <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8140624">
        The implementation defines a hash table
        <code>table</code>, and a <code>merge</code>
        function that merges an expression into the table, returning the
        previous value if there was one, or inserting a new value if
        there is not. The constructors can rely on the fact that
        subexpressions have already been hash-consed, so they simply
        call the merge function to memoize the value.
      </p><p id="idp8142688">
        Note that expressions that are structurally equal are now also
        physically equal.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">e1</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">num</span> <span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;x&quot;</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;y&quot;</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">e1</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;x&quot;</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span><span class="o">))</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">e2</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">num</span> <span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;x&quot;</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;y&quot;</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">e2</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;x&quot;</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span><span class="o">))</span>
<span class="o">#</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div><p id="idp8144432">
        Expressions that are not equal are equal are not physically
        equal either, however common subexpressions are equal.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">e3</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">num</span> <span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;z&quot;</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;y&quot;</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">e3</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;z&quot;</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span><span class="o">))</span>
<span class="o">#</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="k">let</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(_,</span> <span class="n">a2</span><span class="o">))</span> <span class="o">=</span> <span class="n">e1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">a1</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span>
<span class="k">val</span> <span class="n">a2</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span>
<span class="o">#</span> <span class="k">let</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="n">b1</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(_,</span> <span class="n">b2</span><span class="o">))</span> <span class="o">=</span> <span class="n">e3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">b1</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span>
<span class="k">val</span> <span class="n">b2</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span>
<span class="o">#</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">b1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">a2</span> <span class="o">==</span> <span class="n">b2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div></section><section><h1 id="weak-hash-consing">Weak hash consing</h1><p id="idp8147760">
        There is two issues with hash-consing as we have just defined
        it. A minor problem is that hashing is linear in the size of the
        expression. This can be fixed by storing the hash code in the
        expression itself, avoiding the recursive computation. If
        expressions are small, this won't be much of a benefit, but it
        can save time if large expressions are frequently constructed.
      </p><p id="idp8148592">
        A more serious problem is that the hash table holds onto
        expressions <span><em>forever</em></span>, even if they are no
        longer used in the program. This can result in a space leak that
        cancels out any space saving we had in the first place, perhaps
        making it even worse.
      </p><p id="idp8149680">
        To deal with this problem, we can use &quot;weak&quot; hash
        tables, implemented in the <code>Weak</code> module in the
        OCaml standard library. The main difference is that a weak table
        may drop values that are no longer being used elsewhere. Weak
        tables are tied into the garbage collector, which removes values
        that are no longer live.
      </p><p id="idp8151088">
        We define the type <code>WExp.t</code> much as before,
        except including the hash code for the <code>Plus</code>
        and <code>Times</code> expressions.
      </p><p id="idp8153424">
        The weak hash table requires that hash and equality functions be
        provided explicitly, so we construct a module
        <code>HashExp</code> that defines the
        <code>equal</code> and <code>hash</code> functions.
        Note that equality and hashing are both constant-time functions
        -- equality can rely on physical equality of subexpressions, and
        hashing can use the explcitly represented hash values.
      </p><p id="idp8156080">
        The module <code>WeakHash</code> has the semantics of a
        set of elements. The <code>WeakHash.merge</code> function
        retrieves an element if it already exists, or adds it otherwise.
        The constructors are much as before.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">WExp</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="k">private</span>
   <span class="o">|</span> <span class="nc">Num</span> <span class="k">of</span> <span class="kt">int</span>
   <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
   <span class="o">|</span> <span class="nc">Plus</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
   <span class="o">|</span> <span class="nc">Times</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">num</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">var</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">times</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span>
   <span class="o">|</span> <span class="nc">Num</span> <span class="k">of</span> <span class="kt">int</span>
   <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
   <span class="o">|</span> <span class="nc">Plus</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
   <span class="o">|</span> <span class="nc">Times</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">module</span> <span class="nc">HashExp</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="n">exp</span>
    <span class="k">let</span> <span class="n">equal</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Num</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Num</span> <span class="n">i2</span> <span class="o">-&gt;</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i2</span>
       <span class="o">|</span> <span class="nc">Var</span> <span class="n">v1</span><span class="o">,</span> <span class="nc">Var</span> <span class="n">v2</span> <span class="o">-&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">v2</span>
       <span class="o">|</span> <span class="nc">Plus</span> <span class="o">(_,</span> <span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">),</span> <span class="nc">Plus</span> <span class="o">(_,</span> <span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">)</span>
       <span class="o">|</span> <span class="nc">Times</span> <span class="o">(_,</span> <span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">),</span> <span class="nc">Times</span> <span class="o">(_,</span> <span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">)</span> <span class="o">-&gt;</span>
            <span class="n">a1</span> <span class="o">==</span> <span class="n">b1</span> <span class="o">&amp;&amp;</span> <span class="n">a2</span> <span class="o">==</span> <span class="n">b2</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">function</span>
     <span class="o">|</span> <span class="nc">Num</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="ow">lxor</span> <span class="mh">0xabababab</span>
     <span class="o">|</span> <span class="nc">Var</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">v</span><span class="o">)</span> <span class="ow">lxor</span> <span class="mh">0xcdcdcdcdc</span>
     <span class="o">|</span> <span class="nc">Plus</span> <span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="o">_,</span> <span class="o">_)</span>
     <span class="o">|</span> <span class="nc">Times</span> <span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="o">_,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="n">hash</span>
  <span class="k">end</span>

  <span class="k">module</span> <span class="nc">WeakHash</span> <span class="o">=</span> <span class="nn">Weak</span><span class="p">.</span><span class="nc">Make</span> <span class="o">(</span><span class="nc">HashExp</span><span class="o">);;</span>

  <span class="k">let</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">WeakHash</span><span class="p">.</span><span class="n">create</span> <span class="mi">17</span>
  <span class="k">let</span> <span class="n">merge</span> <span class="n">e</span> <span class="o">=</span> <span class="nn">WeakHash</span><span class="p">.</span><span class="n">merge</span> <span class="n">table</span> <span class="n">e</span>

  <span class="k">let</span> <span class="n">num</span> <span class="n">i</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">i</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">var</span> <span class="n">s</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Var</span> <span class="n">s</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">plus</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="nn">HashExp</span><span class="p">.</span><span class="n">hash</span> <span class="n">e1</span><span class="o">)</span> <span class="ow">lxor</span> <span class="o">(</span><span class="nn">HashExp</span><span class="p">.</span><span class="n">hash</span> <span class="n">e2</span><span class="o">)</span> <span class="ow">lxor</span> <span class="mh">0x12345678</span> <span class="k">in</span>
     <span class="n">merge</span> <span class="o">(</span><span class="nc">Plus</span> <span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>

  <span class="k">let</span> <span class="n">times</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="nn">HashExp</span><span class="p">.</span><span class="n">hash</span> <span class="n">e1</span><span class="o">)</span> <span class="ow">lxor</span> <span class="o">(</span><span class="nn">HashExp</span><span class="p">.</span><span class="n">hash</span> <span class="n">e2</span><span class="o">)</span> <span class="ow">lxor</span> <span class="mh">0xdeadbeef</span> <span class="k">in</span>
     <span class="n">merge</span> <span class="o">(</span><span class="nc">Times</span> <span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section></section><section><h1 id="concurrency">Concurrency</h1><p id="idp8162896">
      Concurrency is another tool OCaml programmers can use to simplify
      programs in certain cases. In OCaml, threads do not introduce
      parallelism; only one thread may be running at a time. However,
      threads can be used to simplify control flow -- a program can
      devote some threads to reading input, others for performing work,
      others for producing output, etc.
    </p><p id="idp8163696">
      The OCaml standard library supports threads, where individual
      threads of control can be created that run concurrently (but only
      one thread at a time), and context switches are
      <span><em>involuntary</em></span>, meaning that a thread may be
      preempted at any time.
    </p><p id="idp8164768">
      When threads share imperative state, this gives rise to the
      standard synchronization issues, where multiple threads may be
      mutating shared state at the same time. To illustrate, let's write
      a program with two threads that increment a shared reference cell
      concurrently.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span>

<span class="k">let</span> <span class="n">loop</span> <span class="bp">()</span> <span class="o">=</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span>
     <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="o">!</span><span class="n">value</span> <span class="k">in</span>
     <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span><span class="o">;</span>
     <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
     <span class="n">value</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="k">done</span>

<span class="k">let</span> <span class="n">thread1</span> <span class="o">=</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">create</span> <span class="n">loop</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">thread2</span> <span class="o">=</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">create</span> <span class="n">loop</span> <span class="bp">()</span><span class="o">;;</span>

<span class="nn">Thread</span><span class="p">.</span><span class="n">join</span> <span class="n">thread1</span><span class="o">;;</span>
<span class="nn">Thread</span><span class="p">.</span><span class="n">join</span> <span class="n">thread2</span><span class="o">;;</span>

<span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;value = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">!</span><span class="n">value</span>
</pre></div><p id="idp8167120">
      The reference cell <code>value</code> holds a shared value
      that is incremented 10 times, in a loop, by the
      <code>loop</code> function. Each iteration of the loop
      prints the current value, then assigns the new value. We create
      two threads with the <code>Thread.create</code> expressions,
      then use <code>Thread.join</code> to block until the threads
      terminate.
    </p><p id="idp8170240">
      The exact behavior of the program is nondeterminstic -- it depends
      on the relative sopeed of the two theads. One output is listed
      below.
    </p><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ii</span>  <span class="o">==</span>  <span class="mi">01</span>

<span class="n">ii</span>  <span class="o">==</span>  <span class="mi">12</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">value</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div><p id="idp8171664">
      This represents a nearly perfect interleaving of the thread
      executions. Each thread fetches the value from the
      <code>value</code> reference cell, prints the value, then
      performs the assignment. Since both threads effectively run in
      lockstep, the final value in the <code>value</code>
      reference cell is the same as if there were just one thread
      running.
    </p><p id="idp8173696">
      If this is not the behavior that was expected, one solution is to
      use a <code>Mutex</code> to ensure that the increment
      operation is atomic. We can allocate a lock with
      <code>Mutex.create</code>, then acquire the lock in the loop
      body.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span>
<span class="k">let</span> <span class="n">mutex</span> <span class="o">=</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span>

<span class="k">let</span> <span class="n">loop</span> <span class="bp">()</span> <span class="o">=</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span>
     <span class="nn">Mutex</span><span class="p">.</span><span class="n">lock</span> <span class="n">mutex</span><span class="o">;</span>
     <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="o">!</span><span class="n">value</span> <span class="k">in</span>
     <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span><span class="o">;</span>
     <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
     <span class="n">value</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
     <span class="nn">Mutex</span><span class="p">.</span><span class="n">unlock</span> <span class="n">mutex</span>
   <span class="k">done</span>
</pre></div><p id="idp8176720">
      When we run this program, it produces a deterministic output.
    </p><pre id="idp8177200">
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
value = 6
</pre><section><h1 id="dealing-with-concurrency">Dealing with concurrency</h1><p id="idp8178704">
        In general the interaction of concurrency with imperative
        programs causes problems with races. There are many techniques
        you can use to address the issue.
      </p><ul><li><p id="idp8179808">
            Do not use assignment, mutable data structures, or perform
            input/output in threads.
          </p></li><li><p id="idp8180704">
            Use <span><em>cooperative</em></span> multitasking, where
            only one thread runs at a time, and context switches are
            <span><em>voluntary</em></span>. This is the dominant model
            in <code>Async</code>.
          </p></li><li><p id="idp8182976">
            Do not share mutable data between threads. In practice, this
            usually includes explicit communication channels between
            threads that otherwise have isolated state.
          </p></li><li><p id="idp8183968">
            Give in, and use threads, and the standard synchronization
            toolkit that comes with OCaml, including locks
            (<code>Mutex</code>), condition variables, etc.
          </p></li></ul><p id="idp8185392">
        Out of all of these choices, the simplest one is to use the
        <code>Async</code> model and cooperative multitasking.
        However, let's go ahead and work through some examples of using
        traditional concurrent programming using locks and other
        synchronization primitives to build a concurrency library.
      </p></section><section><h1 id="concurrent-hash-tables">Concurrent hash tables</h1><p id="idp8187760">
        Let's extend our hash table example to support concurrency. To
        begin, let's first give the signature of the module we will
        implement. The table has operations to add, remove, and find
        elements, and it also supports imperative iterators.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">ConcurrentHashMap</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span>
  <span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">iterator</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">iterator</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
</pre></div><p id="idp8189664">
        We'll use the same basic construction that we used to implement
        the <code>HashMap</code> -- a hash table contains an array
        of buckets. In addition we'll add locking to ensure that
        concurrent operations do not interfere. In addition, to reduce
        lock contention, we'll use an array of locks to partition the
        table into multiple parts. If operations are randomly
        disitribted, this should reduce lock contention.
      </p><div class="highlight"><pre>  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">element</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">key</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">locks</span> <span class="o">:</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">t</span> <span class="kt">array</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">buckets</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">element</span> <span class="kt">list</span> <span class="kt">array</span>
  <span class="o">}</span>

  <span class="k">let</span> <span class="n">num_locks</span> <span class="o">=</span> <span class="mi">32</span>
  <span class="k">let</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">256</span>

  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">locks</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">num_locks</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span><span class="o">);</span>
    <span class="n">buckets</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="n">num_buckets</span> <span class="bp">[]</span>
  <span class="o">}</span>
</pre></div><p id="idp8192592">
        Each <code>element</code> is a key/value pair, where the
        value is mutable so that the <code>add</code> function can
        mutate it in place. For this implementation, we'll use 32 locks,
        and start with 256 buckets.
      </p><p id="idp8194448">
        Each bucket is an <span><em>association list</em></span>, meaning
        that it is list of key/value pairs that implement a dictionary.
        We can start the implementation by defining dictionary
        operations for association lists. The function
        <code>find_assoc</code> finds the value associated with a
        key, and <code>remove_assoc</code> removes an association.
        Both functions raise an exception <code>Not_found</code>
        if the list does not contain the association.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="k">rec</span> <span class="n">find_assoc</span> <span class="n">key</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">{</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key'</span> <span class="o">}</span> <span class="k">as</span> <span class="n">element</span> <span class="o">::</span> <span class="o">_</span> <span class="k">when</span> <span class="n">key'</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">element</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">find_assoc</span> <span class="n">key</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Not_found</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">remove_assoc</span> <span class="n">key</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">{</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key'</span> <span class="o">}</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="n">key'</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">remove_assoc</span> <span class="n">key</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Not_found</span>
</pre></div><p id="idp8198912">
        The locks are intended to partition the table into multiple
        sub-parts, where each lock provides synchronization for a
        contiguous range of buckets. To make synchronization each we
        define a function <code>synchronize</code> that takes a
        bucket index and a function, and evaluates the function with the
        bucket lock acquired, releasing the lock before returning.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">locks</span><span class="o">.(</span><span class="n">index</span> <span class="o">*</span> <span class="n">num_locks</span> <span class="o">/</span> <span class="n">num_buckets</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">Mutex</span><span class="p">.</span><span class="n">lock</span> <span class="n">lock</span><span class="o">;</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="nn">Mutex</span><span class="p">.</span><span class="n">unlock</span> <span class="n">lock</span><span class="o">;</span>
    <span class="n">result</span>
</pre></div><p id="idp8201392">
        Note that the <code>synchronize</code> function is
        <span><em>not</em></span> exception-safe, meaning that if
        evaluation of <code>f ()</code> raises an exception, the
        lock will not be released. An exception-safe version would catch
        all exceptions; when an exception is raised, the lock would be
        released, and the exception re-raised.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">synchronize_exn</span> <span class="n">table</span> <span class="n">index</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">locks</span><span class="o">.(</span><span class="n">index</span> <span class="o">*</span> <span class="n">num_locks</span> <span class="o">/</span> <span class="n">num_buckets</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">Mutex</span><span class="p">.</span><span class="n">lock</span> <span class="n">lock</span><span class="o">;</span>
    <span class="k">try</span> <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">unlock</span> <span class="n">lock</span><span class="o">;</span> <span class="n">result</span> <span class="k">with</span>
      <span class="n">exn</span> <span class="o">-&gt;</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">unlock</span> <span class="n">lock</span><span class="o">;</span> <span class="k">raise</span> <span class="n">exn</span>
</pre></div><p id="idp8204928">
        To add a new entry to the table, the <code>add</code>
        function acquires the bucket lock, then uses
        <code>find_assoc</code> to look for an existing
        association. If one is found, the <code>value</code> is
        updated in-place to the new value. Otherwise, a new entry is
        added to the beginning of the bucket.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="ow">mod</span> <span class="n">num_buckets</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span> <span class="k">in</span>
    <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="k">try</span> <span class="o">(</span><span class="n">find_assoc</span> <span class="n">key</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)).</span><span class="n">value</span> <span class="o">&lt;-</span> <span class="n">data</span> <span class="k">with</span>
        <span class="nc">Not_found</span> <span class="o">-&gt;</span>
          <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">{</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">data</span> <span class="o">}</span> <span class="o">::</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">))</span>
</pre></div><p id="idp8208720">
        Removing an element from the table is similar. If here is a
        previous entry in the table, the entry is removed. Otherwise,
        the table is left unchanged.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">remove</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="ow">mod</span> <span class="n">num_buckets</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span> <span class="k">in</span>
    <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="k">try</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">remove_assoc</span> <span class="n">key</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="k">with</span>
        <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">)</span>
</pre></div><p id="idp8210528">
        The function to find an association in the table is similar --
        we jsut find the entry in the table and return the value part.
        However, this particular implementation is somewhat more subtle,
        because it omits the synchronization step, examining the bucket
        <span><em>without</em></span> acquiring the lock.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="ow">mod</span> <span class="n">num_buckets</span> <span class="k">in</span>
    <span class="c">(* Unsynchronized! *)</span>
    <span class="o">(</span><span class="n">find_assoc</span> <span class="n">key</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)).</span><span class="n">value</span>
</pre></div><p id="idp8212672">
        From a performance perspective, this is clearly a win, because
        retrieving elements from the table has no locking at all. But
        why is it valid?
      </p><p id="idp8213248">
        The reasoning has to do with two things: 1) the semantics we
        expect from the table, and 2) the OCaml memory model. Ideally,
        the semantics we would expect is <span><em>sequential
        semantics</em></span>, meaning that all memory operations are
        processed in <span><em>some</em></span> sequence that is
        compatible with the order in which they were performed in each
        thread. Thus, if some thread adds two entries for keys
        <code>K1</code> and <code>K2</code> in sequential
        order, then all other threads will see either, 1) neither entry,
        or 2) a entry for <code>K1</code>, or 3) a entry for both
        <code>K1</code> and <code>K2</code>, but it will
        <span><em>not</em></span> see an entry for <code>K2</code>
        without also having an entry for <code>K1</code>.
      </p><p id="idp8219728">
        Unfortunately, for some processor architectures, primary memory
        does not have sequential semantics, due to caching and other
        effects. Fortunately for us, OCaml does provide sequential
        memory semantics due to its threading model where: 1) only one
        thread executes at a time, and 2) there is a memory barrier the
        prevents reordering of thread context switches and memort
        operations, and 3) the compiler does not reorder memory
        operations in ways that would violate sequential memory
        semantics.
      </p><p id="idp8220704">
        Note, OCaml does not a <span><em>guarantee</em></span> this
        semantics. The OCaml implementation may change to support
        parallelism. If it does, the memory semantics will change
        accordingly. The simplest fix is just to synchronize the access.
        Performance of <code>find</code> operations will decrease
        somewhat due to contention.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">synchronized_find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="ow">mod</span> <span class="n">num_buckets</span> <span class="k">in</span>
    <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="o">(</span><span class="n">find_assoc</span> <span class="n">key</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)).</span><span class="n">value</span><span class="o">)</span>
</pre></div><p id="idp8223616">
        For the final part of the implementation, let's define
        imperative iteration. The iterator object contains a bucket
        index, and the field <code>elements</code> refers to some
        suffix of the list stored in the bucket. The
        <code>value</code> method returns the current elements,
        and the <code>next</code> method advances the
        <code>elements</code> field. The method
        <code>normalize</code> is used to maintain the invariant
        that the <code>elements</code> field always refers to a
        value in the table unless the iterator has advanced past the
        final element. The <code>remove</code> method removes the
        current element from the bucket in which it is stored.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="k">rec</span> <span class="n">remove_element</span> <span class="n">elements</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">(_</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="k">as</span> <span class="n">elements'</span> <span class="k">when</span> <span class="n">elements'</span> <span class="o">==</span> <span class="n">elements</span> <span class="o">-&gt;</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">remove_element</span> <span class="n">elements</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Not_found</span>

  <span class="k">let</span> <span class="n">iterator</span> <span class="n">table</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span> <span class="k">in</span>
    <span class="k">object</span> <span class="o">(</span><span class="n">self</span><span class="o">)</span>
      <span class="k">val</span> <span class="k">mutable</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">val</span> <span class="k">mutable</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">.(</span><span class="mi">0</span><span class="o">)</span>
      <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">elements</span> <span class="o">&lt;&gt;</span> <span class="bp">[]</span>
      <span class="k">method</span> <span class="n">value</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">elements</span> <span class="k">with</span>
        <span class="o">|</span> <span class="o">{</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">}</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span>
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;value&quot;</span><span class="o">)</span>
      <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
        <span class="n">elements</span> <span class="o">&lt;-</span> <span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="n">elements</span><span class="o">;</span>
        <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
      <span class="k">method</span> <span class="n">remove</span> <span class="o">=</span>
        <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
          <span class="k">try</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">remove_element</span> <span class="n">elements</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="k">with</span>
            <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
        <span class="n">self</span><span class="o">#</span><span class="n">next</span>
      <span class="k">method</span> <span class="k">private</span> <span class="n">normalize</span> <span class="o">=</span>
        <span class="k">while</span> <span class="n">elements</span> <span class="o">=</span> <span class="bp">[]</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">num_buckets</span> <span class="k">do</span>
          <span class="n">index</span> <span class="o">&lt;-</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
      <span class="n">elements</span> <span class="o">&lt;-</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span>
        <span class="k">done</span>
      <span class="k">initializer</span> <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
    <span class="k">end</span>
</pre></div><p id="idp8231552">
        All method are unsychronized except the method
        <code>remove</code>, which mutates the bucket. As a
        consequence, it means that hash operations that add and remove
        elements from the list can happen concurrently with iteration.
        Again, this is great from a performance perspective, but it
        means that iteration has non-sequential semantics. In
        particular, whenever iteration enters a new bucket, subsequent
        concurrent operations that add new elements or remove old ones
        from that bucket have <span><em>no effect</em></span> on the
        iteration. Iteration advances through that bucket as if it were
        unchanged.
      </p><p id="idp8233648">
        One advantage of this relaxed iteration semantics is peformance,
        since iteration is largely unsynchronized. Another advantage is
        that deadlock is less likely. If we were to
        <span><em>lock</em></span> the bucket during iteration, then
        changes to that bucket would not be allowed during iteration
        (even by the iterating thread). We might allow lock recursion to
        allow mutations by the iterating thread, but in general the
        synchronization might involve multiple threads, resulting in
        deadlock. Lock-free iteration ensures that the
        <code>ConcurrentHashMap</code> will not be involved in a
        deadlock cycle.
      </p></section></section><section><h1 id="input-and-output-fix-this-chapter-heading">Input and output (fix this chapter heading)</h1><p id="idp8236880">
      Input and output I/O is another kind of imperative operation,
      where the purpose is to either read input from a file, stream, or
      device, <span><em>consuming</em></span> the input by side-effect;
      or write output to a file, stream, or device,
      <span><em>modifying</em></span> the output by side-effect. There
      are several I/O libraries in OCaml. There is the basic builtin I/O
      library in the <code>Pervasives</code> module, and there are
      moe advanced I/O libraries in the <code>Unix</code> and
      <code>Async</code> modules. Let's look at the basic library
      -- the advanced libraries will be described elsewhere.
    </p><p id="idp8240528">
      For basic I/O OCaml models input and output with
      <span><em>channels</em></span>. An <code>in_channel</code> is
      used for reading input, and and <code>out_channel</code> for
      producing output. Each OCaml process has three standard channels,
      similar to the three standard files in Unix.
    </p><ul><li><p id="idp8243280">
<code>stdin : in_channel</code>. The &quot;standard
          input&quot; channel. By default, input comes from the
          terminal, which handles keyboard input.
        </p></li><li><p id="idp8245056">
<code>stdout : out_channel</code>. The &quot;standard
          output&quot; channel. By default, output written to
          <code>stdout</code> appears on the user terminal.
        </p></li><li><p id="idp8247344">
<code>stderr : out_channel</code>. The &quot;standard
          error&quot; channel. This is similar to
          <code>stdout</code>, but it is intended for error
          messages.
        </p></li></ul><p id="idp8249408">
      The standard library has several functions for reading from and
      writing to the standard channels.
    </p><ul><li><p id="idp8250432">
<code>print_char : char -&gt; unit</code> prints a
          single character to <code>stdout</code>.
        </p></li><li><p id="idp8252448">
<code>print_string : string -&gt; unit</code> prints a
          <code>string</code> to <code>stdout</code> as a
          sequence of characters, without quotes.
        </p></li><li><p id="idp8255168">
<code>print_int : int -&gt; unit</code> prints an
          integer to <code>stdout</code>.
        </p></li><li><p id="idp8257184">
<code>print_float : float -&gt; unit</code> prints a
          floating-point number to <code>stdout</code>.
        </p></li></ul><p id="idp8259072">
      Functions to write to <code>stderr</code> have similar
      names, using the prefix <code>prerr_</code> rather than
      <code>print_</code> (for example,
      <code>prerr_string</code>).
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">print_string</span> <span class="s2">&quot;The value of i is &quot;</span><span class="o">;</span> <span class="n">print_int</span> <span class="n">i</span><span class="o">;</span> <span class="n">print_string</span> <span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="nc">The</span> <span class="n">value</span> <span class="k">of</span> <span class="n">i</span> <span class="n">is</span> <span class="mi">1</span><span class="o">.</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8263024">
      Input is similar, but there are only a few functions.
    </p><ul><li><p id="idp8264000">
<code>read_line : unit -&gt; string</code> reads a line
          of input from <code>stdin</code>.
        </p></li><li><p id="idp8266016">
<code>read_int : unit -&gt; int</code> reads a decimal
          integer from <code>stdin</code>.
        </p></li><li><p id="idp8268032">
<code>read_float : unit -&gt; float</code> reads a
          floating-point number from <code>stdin</code>.
        </p></li></ul><p id="idp8269920">
      These functions raise the exception <code>End_of_file</code>
      if the input channel is terminated before the input is read.
    </p><p id="idp8271024">
      Here is a function to read a sequence of integers from
      <code>stdin</code>, sorting them and printing the result to
      <code>stdout</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">collate_input</span> <span class="bp">()</span> <span class="o">=</span>
   <span class="k">let</span> <span class="k">rec</span> <span class="n">read_input</span> <span class="n">items</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="k">try</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">read_int</span> <span class="bp">()</span><span class="o">)</span> <span class="k">with</span> <span class="nc">End_of_file</span> <span class="o">-&gt;</span> <span class="nc">None</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">item</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">read_input</span> <span class="o">(</span><span class="n">i</span> <span class="o">::</span> <span class="n">items</span><span class="o">)</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">items</span>
   <span class="k">in</span>
   <span class="k">let</span> <span class="n">items</span> <span class="o">=</span> <span class="n">read_input</span> <span class="bp">[]</span> <span class="k">in</span>
   <span class="k">let</span> <span class="n">sorted</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="o">(-)</span> <span class="n">items</span> <span class="k">in</span>
   <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">print_int</span> <span class="n">i</span><span class="o">;</span> <span class="n">print_char</span> <span class="sc">' '</span><span class="o">)</span> <span class="n">sorted</span><span class="o">;</span>
   <span class="n">print_string</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">collate_input</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span>   <span class="n">collate_input</span> <span class="bp">()</span><span class="o">;;</span>
<span class="mi">8</span>
<span class="mi">56</span>
<span class="mi">2</span>
<span class="mi">34</span>
<span class="o">-</span><span class="mi">120</span>
<span class="mi">19</span>
<span class="o">-</span><span class="mi">120</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">19</span> <span class="mi">34</span> <span class="mi">56</span> 
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8274288">
      Using exceptions to signal the end of input is a little awkward.
      The <code>read_input</code> loop above converts the
      exception into an <code>int option</code>, so that matching
      can be performed with <code>match</code> and the function is
      tail-recursive. The following function is <span><em>not</em></span>
      tail recursive, and should be avoided.
    </p><div class="highlight"><pre>  <span class="c">(* AVOID -- non tail-recursive input reader *)</span>
<span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">read_input</span> <span class="n">items</span> <span class="o">=</span>
   <span class="k">try</span> <span class="n">read_input</span> <span class="o">(</span><span class="n">read_int</span> <span class="bp">()</span> <span class="o">::</span> <span class="n">items</span><span class="o">)</span> <span class="k">with</span>
      <span class="nc">End_of_file</span> <span class="o">-&gt;</span> <span class="n">items</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">read_input</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">read_input</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="mi">34</span>
<span class="mi">45</span>
<span class="mi">56</span>
<span class="o">-</span><span class="mi">1</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">1</span><span class="o">;</span> <span class="mi">56</span><span class="o">;</span> <span class="mi">45</span><span class="o">;</span> <span class="mi">34</span><span class="o">]</span>
</pre></div><p id="idp8278272">
      Another way to address the input issue is to use iteration, rather
      than recursion. This requires collecting the input in a container
      than can be mutated by side-effect.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">read_input</span> <span class="bp">()</span> <span class="o">=</span>
   <span class="k">let</span> <span class="n">items</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>
   <span class="k">try</span>
      <span class="k">while</span> <span class="bp">true</span> <span class="k">do</span>
         <span class="n">items</span> <span class="o">:=</span> <span class="n">read_int</span> <span class="bp">()</span> <span class="o">::</span> <span class="o">!</span><span class="n">items</span>
      <span class="k">done</span><span class="o">;</span>
      <span class="bp">[]</span>  <span class="c">(* not reached *)</span>
   <span class="k">with</span> <span class="nc">End_of_file</span> <span class="o">-&gt;</span>
      <span class="o">!</span><span class="n">items</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">read_input</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">read_input</span> <span class="bp">()</span><span class="o">;;</span>
<span class="mi">45</span>
<span class="mi">78</span>
<span class="o">-</span><span class="mi">345</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">345</span><span class="o">;</span> <span class="mi">78</span><span class="o">;</span> <span class="mi">45</span><span class="o">]</span>
</pre></div><p id="idp8280096">
      In this loop, the value returns from a successful call to
      <code>read_int ()</code> is added to the
      <code>items</code> list by side-effect. When
      <code>read_int ()</code> reaches the end of input, it raises
      the <code>End_of_file</code> exception, terminating the
      loop. The <code>while</code> loop never terminates; the
      <code>[]</code> value afterward is only to satisfy the type
      checker.
    </p><section><h1 id="basic-file-input-and-output">Basic file input and output</h1><p id="idp8285264">
        It isn't necessary to perform all input through the standard
        channels. There are also functions to open files for reading and
        writing.
      </p><ul><li><p id="idp8286336">
<code>open_out : string -&gt; out_channel</code> open
            a file for writing.
          </p></li><li><p id="idp8287728">
<code>open_in : string -&gt; in_channel</code> open a
            file for reading.
          </p></li><li><p id="idp8289120">
<code>close_out : out_channel -&gt; unit</code> close
            an output channel, flushing any pending output to the file.
          </p></li><li><p id="idp8290624">
<code>close_in : in_channel -&gt; unit</code> close an
            input channel.
          </p></li></ul><p id="idp8291888">
        The functions for input and output are similar to the
        <code>print_...</code> and <code>read_...</code>
        functions, but they use the prefix <code>output_</code>
        and <code>input_</code> and they take a channel as an
        argument. Let's write a function to print the contents of a
        file.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">cat</span> <span class="n">filename</span> <span class="o">=</span>
   <span class="k">let</span> <span class="n">inx</span> <span class="o">=</span> <span class="n">open_in</span> <span class="n">filename</span> <span class="k">in</span>
   <span class="k">try</span>
      <span class="k">while</span> <span class="bp">true</span> <span class="k">do</span>
         <span class="n">print_string</span> <span class="o">(</span><span class="n">input_line</span> <span class="n">inx</span><span class="o">);</span> <span class="n">print_char</span> <span class="sc">'\n'</span>
      <span class="k">done</span>
   <span class="k">with</span> <span class="nc">End_of_file</span> <span class="o">-&gt;</span>
      <span class="n">close_in</span> <span class="n">inx</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">cat</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">outf</span> <span class="o">=</span> <span class="n">open_out</span> <span class="s2">&quot;file.txt&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">outf</span> <span class="o">:</span> <span class="n">out_channel</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">output_string</span> <span class="n">outf</span> <span class="s2">&quot;Hello world</span><span class="se">\n</span><span class="s2">1</span><span class="se">\n</span><span class="s2">2</span><span class="se">\n</span><span class="s2">3</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">close_out</span> <span class="n">outf</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">cat</span> <span class="s2">&quot;file.txt&quot;</span><span class="o">;;</span>
<span class="nc">Hello</span> <span class="n">world</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8296656">
        It is important to close channels when you are finished with
        them, for two reasons. One reason is that the runtime system
        will usually have a limit on the number of channels that may be
        open simultaneously. To avoid problems, you should close
        channels you are not using. In addition, for efficiency, output
        is buffered and written to output channels in larger blocks. The
        output may not actually be written to the file unless the
        <code>out_channel</code> is closed, or with an explicit
        call to the <code>flush</code> function.
      </p><ul><li><p id="idp8299312">
<code>flush : out_channel -&gt; unit</code>
</p></li></ul><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">outf</span> <span class="o">=</span> <span class="n">open_out</span> <span class="s2">&quot;file.txt&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">outf</span> <span class="o">:</span> <span class="n">out_channel</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">output_string</span> <span class="n">outf</span> <span class="s2">&quot;Hello world</span><span class="se">\n</span><span class="s2">1</span><span class="se">\n</span><span class="s2">2</span><span class="se">\n</span><span class="s2">3</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">cat</span> <span class="s2">&quot;file.txt&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">flush</span> <span class="n">outf</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">cat</span> <span class="s2">&quot;file.txt&quot;</span><span class="o">;;</span>
<span class="nc">Hello</span> <span class="n">world</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div></section><section><h1 id="formatted-output-with-printf">Formatted output with Printf</h1><p id="idp8302880">
        Output with the standard library functions like
        <code>output_char</code>, <code>output_int</code>,
        <code>output_string</code>, etc. is simple, but there is
        little flexibility, and it is often verbose. OCaml also supports
        <span><em>formatted</em></span> output using the
        <code>printf</code> function, which is modeled after
        <code>printf</code> in the C standard library. The
        <code>printf</code> function takes a <span><em>format
        string</em></span> that describe what to print and how to format
        it, as well as arguments to be printed.
      </p><div class="highlight"><pre><span class="n">printf</span> <span class="n">format</span> <span class="n">arg1</span> <span class="o">...</span> <span class="n">argN</span>
</pre></div><p id="idp8308960">
        The format string can contain character literals, which are
        printed without change, as well as conversion specifications,
        which specify how to print an value that is provided as an
        argument. A conversion specification begins with a percent
        (<code>%</code>) character, some flags, and a type
        specification. For example, <code>%d</code> is a
        conversion specification for printing an integer,
        <code>%s</code> prints a string, and <code>%f</code>
        prints a floating-point value.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">open</span> <span class="nc">Printf</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">printf</span> <span class="s2">&quot;int=%d string=%s float=%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="mi">10</span> <span class="s2">&quot;abc&quot;</span> <span class="mf">1e5</span><span class="o">;;</span>
<span class="kt">int</span><span class="o">=</span><span class="mi">10</span> <span class="kt">string</span><span class="o">=</span><span class="n">abc</span> <span class="kt">float</span><span class="o">=</span><span class="mi">100000</span><span class="o">.</span><span class="mi">000000</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8313568">
        Conversions can also specify additional parameters for
        formatting the value. The general form has flags, width
        specified in number of characters, and decimal precision used
        for printing floating-point values. These parameters are
        optional.
      </p><div class="highlight"><pre><span class="o">%</span> <span class="o">[</span><span class="n">flags</span><span class="o">]</span> <span class="o">[</span><span class="n">width</span><span class="o">]</span> <span class="o">[.</span><span class="n">precision</span><span class="o">]</span> <span class="k">type</span>
</pre></div><p id="idp8315120">
        There are several flags of interest, the flag
        <code>'-'</code> left-justifies the output, and the flag
        <code>'0'</code> pads numerical values with leading
        zeroes. Let's write a program to print a price list in a tabular
        form.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">print_prices</span> <span class="n">prices</span> <span class="o">=</span>
    <span class="n">print_string</span> <span class="s2">&quot;--------------------------------</span><span class="se">\n</span><span class="s2">\</span>
<span class="s2">                  | Size   | Hexcode    | Price  |</span><span class="se">\n</span><span class="s2">\</span>
<span class="s2">                  --------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">code</span><span class="o">,</span> <span class="n">price</span><span class="o">)</span> <span class="o">-&gt;</span>
          <span class="n">printf</span> <span class="s2">&quot;| %-6s | 0x%08x | %6.2f |</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">size</span> <span class="n">code</span> <span class="n">price</span><span class="o">)</span> <span class="n">prices</span><span class="o">;</span>
    <span class="n">print_string</span> <span class="s2">&quot;--------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">print_prices</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">print_prices</span>
   <span class="o">[(</span><span class="s2">&quot;small&quot;</span><span class="o">,</span> <span class="mh">0x35</span><span class="o">,</span> <span class="mi">1</span><span class="o">.</span><span class="mi">02</span><span class="o">);</span>
    <span class="o">(</span><span class="s2">&quot;medium&quot;</span><span class="o">,</span> <span class="mh">0x7a1</span><span class="o">,</span> <span class="mi">50</span><span class="o">.</span><span class="mi">75</span><span class="o">);</span>
    <span class="o">(</span><span class="s2">&quot;large&quot;</span><span class="o">,</span> <span class="mh">0xbad</span><span class="o">,</span> <span class="mi">400</span><span class="o">.</span><span class="mi">8</span><span class="o">);</span>
    <span class="o">(</span><span class="s2">&quot;vente&quot;</span><span class="o">,</span> <span class="mh">0x11</span><span class="o">,</span> <span class="mi">4136</span><span class="o">.);</span>
    <span class="o">(</span><span class="s2">&quot;enormous&quot;</span><span class="o">,</span> <span class="mi">100000</span><span class="o">,</span> <span class="mi">100</span><span class="o">.)];;</span>
<span class="o">--------------------------------</span>
<span class="o">|</span> <span class="nc">Size</span>   <span class="o">|</span> <span class="nc">Hexcode</span>    <span class="o">|</span> <span class="nc">Price</span>  <span class="o">|</span>
<span class="o">--------------------------------</span>
<span class="o">|</span> <span class="n">small</span>  <span class="o">|</span> <span class="mh">0x00000035</span> <span class="o">|</span>   <span class="mi">1</span><span class="o">.</span><span class="mi">02</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">medium</span> <span class="o">|</span> <span class="mh">0x000007a1</span> <span class="o">|</span>  <span class="mi">50</span><span class="o">.</span><span class="mi">75</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">large</span>  <span class="o">|</span> <span class="mh">0x00000bad</span> <span class="o">|</span> <span class="mi">400</span><span class="o">.</span><span class="mi">80</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">vente</span>  <span class="o">|</span> <span class="mh">0x00000011</span> <span class="o">|</span> <span class="mi">4136</span><span class="o">.</span><span class="mi">00</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">enormous</span> <span class="o">|</span> <span class="mh">0x000186a0</span> <span class="o">|</span> <span class="mi">100</span><span class="o">.</span><span class="mi">00</span> <span class="o">|</span>
<span class="o">--------------------------------</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8318816">
        The format specification
        <code>&quot;| %-6s | 0x%08x | %6.2f |\n&quot;</code>
        specifies that the first argument is a string that is to be
        left-justified and printed six characters wide; the second
        argument is an integer that should be printed in hexidecimal
        (format type <code>x</code>) eight characters wide with
        leading zeroes; and the third argument is a floating point value
        that should be printed right-justified, six characters wide,
        with two digits after the decimal point.
      </p><p id="idp8321008">
        Note that the width specifies a <span><em>minimum</em></span>
        width. If the value requires more width to print completely the
        width is increased. The price <code>4136.00</code> and the
        size <code>enormous</code> both overflow the width,
        breaking the tabular form.
      </p></section><section><h1 id="strong-typing-and-format-strings">Strong typing and format strings</h1><p id="idp8324240">
        In OCaml, <code>printf</code> is type safe. The format is
        checked against the arguments at compile time, and rejected if
        the format string is malformed, or if the format does not match
        the arguments. In the following examples, <code>%v</code>
        is not a valid conversion specification, and floating-point
        values can't be printed with a decimal conversion specification.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">printf</span> <span class="s2">&quot;Hello %v&quot;</span> <span class="mi">1</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">7</span><span class="o">-</span><span class="mi">17</span><span class="o">:</span>
  <span class="n">printf</span> <span class="s2">&quot;Hello %v&quot;</span> <span class="mi">1</span><span class="o">;;</span>
         <span class="o">^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Bad</span> <span class="n">conversion</span> <span class="o">%</span><span class="n">v</span><span class="o">,</span> <span class="n">at</span> <span class="kt">char</span> <span class="n">number</span> <span class="mi">6</span> <span class="k">in</span> <span class="n">format</span> <span class="kt">string</span> <span class="o">``</span><span class="nc">Hello</span> <span class="o">%</span><span class="n">v''</span>
<span class="o">#</span> <span class="n">printf</span> <span class="s2">&quot;Hello %d&quot;</span> <span class="mi">1</span><span class="o">.;;</span>
<span class="nc">Characters</span> <span class="mi">18</span><span class="o">-</span><span class="mi">20</span><span class="o">:</span>
  <span class="n">printf</span> <span class="s2">&quot;Hello %d&quot;</span> <span class="mi">1</span><span class="o">.;;</span>
                    <span class="o">^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">float</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="kt">int</span>
</pre></div><p id="idp8327584">
        A consequence of strong typing is that the format string must
        ultimately be a string <span><em>literal</em></span>, known at
        compile time. It can't be computed by the program at runtime.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;%s&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fmt</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;%s&quot;</span>
<span class="o">#</span> <span class="n">printf</span> <span class="n">fmt</span> <span class="s2">&quot;Hello&quot;</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">7</span><span class="o">-</span><span class="mi">10</span><span class="o">:</span>
  <span class="n">printf</span> <span class="n">fmt</span> <span class="s2">&quot;Hello&quot;</span><span class="o">;;</span>
         <span class="o">^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">string</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">,</span> <span class="n">out_channel</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">format</span> <span class="o">=</span>
           <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">,</span> <span class="n">out_channel</span><span class="o">,</span> <span class="kt">unit</span><span class="o">,</span> <span class="kt">unit</span><span class="o">,</span> <span class="kt">unit</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">format6</span>
</pre></div><p id="idp8330080">
        Actually, this is not entirely true. The
        <code>printf</code> function takes a format string of type
        <code>('a, 'b, 'c) format</code> and it is only the type
        conversion from <code>string</code> to
        <code>format</code> where the string is required to be a
        literal.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fmt</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">,</span> <span class="k">'</span><span class="n">c</span><span class="o">)</span> <span class="n">format</span> <span class="o">=</span> <span class="s2">&quot;Size: %s.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fmt</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">,</span> <span class="k">'</span><span class="n">c</span><span class="o">)</span> <span class="n">format</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">printf</span> <span class="n">fmt</span> <span class="s2">&quot;small&quot;</span><span class="o">;;</span>
<span class="nc">Size</span><span class="o">:</span> <span class="n">small</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div></section><section><h1 id="output-to-channels-strings-and-buffers">Output to channels, strings, and buffers</h1><p id="idp8335200">
        The function <code>printf</code> prints to the standard
        output channel <code>stdout</code>. There are alse several
        variations.
      </p><ul><li><p id="idp8337344">
<code>eprintf format arg1 ... argN</code>. Print to
            the standard error channel <code>stderr</code>.
          </p></li><li><p id="idp8339360">
<code>fprintf channel format arg1 ... argN</code>.
            Print to the channel <code>channel</code>.
          </p></li><li><p id="idp8341376">
<code>sprintf format arg1 ... argN</code>. Produce a
            string as output.
          </p></li><li><p id="idp8342768">
<code>bprintf buffer format arg1 ... argN</code>.
            Print to a string buffer <code>buffer</code> of type
            <code>Buffer.t</code>.
          </p></li></ul><div class="highlight"><pre><span class="o">#</span> <span class="n">sprintf</span> <span class="s2">&quot;The number is %10d.&quot;</span> <span class="mi">123</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;The number is        123.&quot;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">32</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">buf</span> <span class="o">:</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">bprintf</span> <span class="n">buf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="s2">&quot;First line&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">bprintf</span> <span class="n">buf</span> <span class="s2">&quot;%20s.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="s2">&quot;Second line&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buf</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;First line</span><span class="se">\n</span><span class="s2">         Second line.</span><span class="se">\n</span><span class="s2">&quot;</span>
</pre></div></section><section><h1 id="formatted-input-with-scanf">Formatted input with Scanf</h1><p id="idp8347808">
        The <code>scanf</code> function can be used for reading
        input, similar to <code>printf</code>. The general form
        takes a format string and a &quot;receiver&quot; function that
        is applied to the input. The format string contains literal
        characters, which must be read literally, and conversion
        specifications similar to <code>printf</code>. The result
        of the receiver function is returned as the result of
        <code>scanf</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">scanf</span> <span class="s2">&quot;%d&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">);;</span>
<span class="mi">1871</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1871</span>
</pre></div><p id="idp8352416">
        For another example, consider the parsing a date string that
        might be in one of two forms, <span><em>month day,
        year</em></span> or <span><em>month/day/year</em></span>. The
        <code>scanf</code> functions raise the exception
        <code>Scan_failure</code> on error, so we can read a date
        string by trying both kinds of format.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">month</span> <span class="o">=</span> <span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">month</span> <span class="o">=</span> <span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">scan_date_string</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">try</span>
      <span class="n">sscanf</span> <span class="n">s</span> <span class="s2">&quot;%s %d, %d&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">month</span> <span class="n">day</span> <span class="n">year</span> <span class="o">-&gt;</span>
             <span class="n">year</span><span class="o">,</span> <span class="nc">String</span> <span class="n">month</span><span class="o">,</span> <span class="n">day</span><span class="o">)</span>
    <span class="k">with</span> <span class="nc">Scan_failure</span> <span class="o">_</span> <span class="o">|</span> <span class="nc">End_of_file</span> <span class="o">-&gt;</span>
      <span class="n">sscanf</span> <span class="n">s</span> <span class="s2">&quot;%d/%d/%d&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">month</span> <span class="n">day</span> <span class="n">year</span> <span class="o">-&gt;</span>
             <span class="n">year</span><span class="o">,</span> <span class="nc">Int</span> <span class="n">month</span><span class="o">,</span> <span class="n">day</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">scan_date_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">month</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">scan_date_string</span> <span class="s2">&quot;May 3, 1921&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">month</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1921</span><span class="o">,</span> <span class="nc">String</span> <span class="s2">&quot;May&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">#</span> <span class="n">scan_date_string</span> <span class="s2">&quot;10/11/2001&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">month</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">2001</span><span class="o">,</span> <span class="nc">Int</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">)</span>
<span class="o">#</span> <span class="n">scan_date_string</span> <span class="s2">&quot;May 3&quot;</span><span class="o">;;</span>
<span class="nc">Exception</span><span class="o">:</span>
<span class="nn">Scanf</span><span class="p">.</span><span class="nc">Scan_failure</span>
 <span class="s2">&quot;scanf: bad input at char number 0: ``character 'M' is not a decimal digit''&quot;</span><span class="o">.</span>
</pre></div></section></section><section><h1 id="summary">Summary</h1><p id="idp8358352">
      The OCaml language supports a fairly standard imperative
      programming model, with looping, assignment, mutable arrays,
      records, and objects. If desired, we can write programs that
      correspond directly to what we would have written in some other
      imperative language like C or Java. Of course, doing so is really
      not the best match -- if you want to write imperative programs,
      you should probably use an imperative programming language.
    </p><p id="idp8359232">
      However, there are times when imperative programming might provide
      efficiency (as with lazy evaluation, or memoization), or you might
      require techniques or data structures that are traditional
      imperative (like graphs represented with adjacency lists), and in
      these cases OCaml usually shines. Used with discretion, imperative
      programming can lead to smaller, simpler programs.
    </p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="functors.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="object-oriented-programming.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>