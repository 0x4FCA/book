<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 8. Object Oriented Programming / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha2',
                        page: 'object\u002Doriented\u002Dprogramming.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">3. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">4. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">5. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">6. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">7. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html" class="here">8. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 8. Object Oriented Programming</h1>
                
                

    <p id="idp8361056">
    We've already seen several tools that OCaml provides for organizing
    programs, particularly first-class modules. In addition, OCaml also
    supports object-oriented programming. There are objects, classes,
    and their associated types. Objects are good for encapsulation and
    abstraction, and classes are good for code re-use.
  </p><section><h1 id="when-to-use-objects">When to use objects</h1><p id="idp8362672">
      You might wonder when to use objects. First-class modules are more
      expressive (a module can include types, classes and objects
      cannot), and modules, functors, and algebraic data types offer a
      wide range of ways to express program structure. In fact, many
      seasoned OCaml programmers rarely use classes and objects, if at
      all.
    </p><p id="idp8363440">
      What exactly is object-oriented programming? Mitchell (TODO: xref)
      points out four fundamental properties.
    </p><ul><li><p id="idp8364480">
<span><em>Abstraction</em></span>: the details of the
          implementation are hidden in the object; the interface is just
          the set of publically-accessible methods.
        </p></li><li><p id="idp8365808">
<span><em>Dynamic lookup</em></span>: when a message is sent to
          an object, the method to be executed is determined by the
          implementation of the object, not by some static property of
          the program. In other words, different objects may react to
          the same message in different ways.
        </p></li><li><p id="idp8367264">
<span><em>Subtyping</em></span>: if an object
          <code>a</code> has all the functionality of an object
          <code>b</code>, then we may use <code>a</code> in
          any context where <code>b</code> is expected.
        </p></li><li><p id="idp8370912">
<span><em>Inheritance</em></span>: the definition of one kind
          of object can be re-used to produce a new kind of object.
        </p></li></ul><p id="idp8372064">
      Modules already provide these features in some form, but the main
      focus of classes is on code re-use through inheritance and late
      binding of methods. This is a critical property of classes: the
      methods that implement an object are determined when the object is
      instantiated, a form of <span><em>dynamic</em></span> binding. In
      the meantime, while classes are being defined, it is possible (and
      necessary) to refer to methods without knowing statically how they
      will be implemented.
    </p><p id="idp8373376">
      In contrast, modules use static (lexical) scoping. If you want to
      parameterize your module code so that some part of it can be
      implemented later, you would write a function/functor. This is
      more explicit, but often more verbose than overriding a method in
      a class.
    </p><p id="idp8374080">
      In general, a rule of thumb might be: use classes and objects in
      situations where dynamic binding is a big win, for example if you
      have many similar variations in the implementation of a concept.
      Two good examples is Xavier Leroy's
      <a href="http://gallium.inria.fr/~xleroy/software.html#cryptokit" target="_top">Cryptokit</a>,
      which provides a variety of cryptographic primitives that can be
      combined in building-block style, and the
      <a href="TODO%20XREF" target="_top">Camlgraphics</a> library which
      manipulates various graphical file formats.
    </p><p id="idp8376208">
      In this chapter, we'll introduce you to the basics of object
      definition and use in OCaml, and then demonstrate their use with
      an example using Cryptokit. We'll return to the more advanced
      areas of object use later on in the book in
      <a href="object-subtyping-and-inheritance.html">Chapter 12, <i>Object Subtyping and Inheritance</i></a>.
    </p></section><section><h1 id="ocaml-objects">OCaml objects</h1><p id="idp8378368">
      If you already know about object oriented programming in a
      language like Java or C++, the OCaml object system may come as a
      surprise. Foremost is the complete separation of subtyping and
      inheritance in OCaml. In a language like Java, a class name is
      also used as the type of objects created by instantiating it, and
      the subtyping rule corresponds to inheritance. For example. if we
      implement a class <code>Stack</code> in Java by inheriting
      from a class <code>Deque</code>, we would be allowed to pass
      a stack anywhere a deque is expected (this is a silly example of
      course, practitioners will point out that we shouldn't do it).
    </p><p id="idp8380656">
      OCaml is entirely different. Classes are used to construct objects
      and support inheritance, including non-subtyping inheritance.
      Classes are not types. Instead, objects have <span><em>object
      types</em></span>, and if you want to use objects, you aren't
      required to use classes at all. Here is an example of a simple
      object.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">p</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">i</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">p</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
</pre></div><p id="idp8382816">
      The object has an integer value <code>x</code>, a method
      <code>get</code> that returns x, and a method
      <code>set</code> that updates the value of x.
    </p><p id="idp8385072">
      The object type is enclosed in angle brackets
      <code>&lt; ... &gt;</code>, containing just the types of the
      methods. Fields, like x, are not part of the public interface of
      an object. All interaction with an object is through its methods.
      The syntax for a method invocation (also called &quot;sending a
      message&quot; to the object) uses the <code>#</code>
      character.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">set</span> <span class="mi">17</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span>
</pre></div><p id="idp8388224">
      Objects can also be constructed by functions. If we want to
      specify the initial value of the object, we can define a function
      that takes the initial value and produces an object.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">make</span> <span class="n">i</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">y</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make</span> <span class="mi">5</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">p</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div><p id="idp8390128">
      Note that the types of the function <code>make</code> and
      the returned object now use the polymorphic type
      <code>'a</code>. When make is invoked on a concrete value
      <code>5</code>, we get the same object type as before, with
      type <code>int</code> for the value.
    </p></section><section><h1 id="object-polymorphism">Object Polymorphism</h1><p id="idp8394176">
<span><em>(yminsky: Maybe this is a good time to talk about the
      nature of object subtyping?)</em></span>
</p><p id="idp8395056">
      Functions can also take object arguments. Let's construct a new
      object <code>average</code> that's the average of any two
      objects with a <code>get</code> method.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">average</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="o">(</span><span class="n">p1</span><span class="o">#</span><span class="n">get</span> <span class="o">+</span> <span class="n">p2</span><span class="o">#</span><span class="n">get</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">average</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">make</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">make</span> <span class="mi">15</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">average</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">a</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">#</span> <span class="n">p2</span><span class="o">#</span><span class="n">set</span> <span class="mi">25</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">a</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div><p id="idp8398304">
      Note that the type for <code>average</code> uses the object
      type <code>&lt; get : int; .. &gt;</code>. The
      <code>..</code> are ellipsis, standing for any other
      methods. The type <code>&lt; get : int; .. &gt;</code>
      specifies an object that must have at least a
      <code>get</code> method, and possibly some others as well.
      If we try using the exact type
      <code>&lt; get : int &gt;</code> for an object with more
      methods, type inference will fail.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;)</span> <span class="o">=</span> <span class="n">make</span> <span class="mi">5</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">&gt;</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span>
       <span class="nc">The</span> <span class="n">second</span> <span class="k">object</span> <span class="k">type</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">set</span>
</pre></div><aside class="note"><h1>
    Elisions are polymorphic
    </h1><p id="idp8404672">
      The <code>..</code> in an object type is an elision,
      standing for &quot;possibly more methods.&quot; It may not be
      apparent from the syntax, but an elided object type is actually
      polymorphic. If we try to write a type definition, we get an
      obscure error.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">point</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">A</span> <span class="k">type</span> <span class="n">variable</span> <span class="n">is</span> <span class="n">unbound</span> <span class="k">in</span> <span class="n">this</span> <span class="k">type</span> <span class="n">declaration</span><span class="o">.</span>
<span class="nc">In</span> <span class="k">type</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="k">as</span> <span class="k">'</span><span class="n">a</span> <span class="n">the</span> <span class="n">variable</span> <span class="k">'</span><span class="n">a</span> <span class="n">is</span> <span class="n">unbound</span>
</pre></div><p id="idp8407360">
      A <code>..</code> in an object type is called a
      <span><em>row variable</em></span> and this typing scheme is called
      <span><em>row polymorphism</em></span>. Even though
      <code>..</code> doesn't look like a type variable, it
      actually is. The error message suggests a solution, which is to
      add the <code>as 'a</code> type constraint.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">point</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="k">as</span> <span class="k">'</span><span class="n">a</span><span class="o">;;</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">point</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="k">constraint</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span>
</pre></div><p id="idp8411584">
      In other words, the type <code>'a point</code> is equal to
      <code>'a</code>, where
      <code>'a = &lt; get : int; .. &gt;</code>. That may seem
      like an odd way to say it, and in fact, this type definition is
      not really an abbreviation because <code>'a</code> refers to
      the entire type.
    </p></aside><p id="idp8414816">
      An object of type <code>&lt; get:int; .. &gt;</code> can be
      any object with a method <code>get:int</code>, it doesn't
      matter how it is implemented. So far, we've constructed two
      objects with that type; the function <code>make</code>
      constructed one, and so did <code>average</code>. When the
      method <code>#get</code> is invoked, the actual method that
      is run is determined by the object.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">print_point</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Point: %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">print_point</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">print_point</span> <span class="o">(</span><span class="n">make</span> <span class="mi">5</span><span class="o">);;</span>
<span class="nc">Point</span><span class="o">:</span> <span class="mi">5</span>
<span class="o">#</span> <span class="n">print_point</span> <span class="o">(</span><span class="n">average</span> <span class="o">(</span><span class="n">make</span> <span class="mi">5</span><span class="o">)</span> <span class="o">(</span><span class="n">make</span> <span class="mi">15</span><span class="o">));;</span>
<span class="nc">Point</span><span class="o">:</span> <span class="mi">10</span>
</pre></div></section><section><h1 id="classes">Classes</h1><p id="idp8420944">
      Programming with objects directly is great for encapsulation, but
      one of the main goals of object-oriented programming is code
      re-use through inheritance. For inheritance, we need to introduce
      <span><em>classes</em></span>. In object-oriented programming, a
      class is a &quot;recipe&quot; for creating objects. The recipe can
      be changed by adding new methods and fields, or it can be changed
      by modifying existing methods.
    </p><p id="idp8422496">
      In OCaml, class definitions must be defined as top-level
      statements in a module. A class is not an object, and a class
      definition is not an expression. The syntax for a class definition
      uses the keyword <code>class</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">point</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">y</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">point</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span>
</pre></div><p id="idp8425184">
      The type <code>class point : ... end</code> is a
      <span><em>class type</em></span>. This particular type specifies
      that the <code>point</code> class defines a mutable field
      <code>x</code>, a method <code>get</code> that returns
      an <code>int</code>, and a method <code>set</code>
      with type <code>int -&gt; unit</code>.
    </p><p id="idp8430320">
      To produce an object, classes are instantiated with the keyword
      <code>new</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">point</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">p</span> <span class="o">:</span> <span class="n">point</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div><p id="idp8432608">
<span><em>(yminsky: You say that inheritance uses an existing
      class to define a new one, but the example below looks like using
      an existing class to define a new module. Is that what's going on?
      Or is a new class being created implicitly? If the latter, it
      might be better to be more explicit in this example and name the
      new class.)</em></span>
</p><p id="idp8433744">
      Inheritance uses an existing class to define a new one. For
      example, the following class definition supports an addition
      method <code>moveby</code> that moves the point by a
      relative amount. This also makes use of the
      <code>(self : 'self)</code> binding after the
      <code>object</code> keyword. The variable
      <code>self</code> stands for the current object, allowing
      self-invocation, and the type variable <code>'self</code>
      stands for the type of the current object (which in general is a
      subtype of <code>movable_point</code>).
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">movable_point</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
    <span class="k">inherit</span> <span class="n">point</span>
    <span class="k">method</span> <span class="n">moveby</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="o">(</span><span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="o">+</span> <span class="n">dx</span><span class="o">)</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="class-parameters-and-polymorphism">Class parameters and polymorphism</h1><p id="idp8440352">
      A class definition serves as the <span><em>constructor</em></span>
      for the class. In general, a class definition may have parameters
      that must be provided as arguments when the object is created with
      <code>new</code>.
    </p><p id="idp8441920">
      Let's build an example of an imperative singly-linked list using
      object-oriented techniques. First, we'll want to define a class
      for a single element of the list. We'll call it a
      <code>node</code>, and it will hold a value of type
      <code>'a</code>. When defining the class, the type
      parameters are placed in square brackets before the class name in
      the class definition. We also need a parameter
      <code>x</code> for the initial value.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span>
<span class="k">object</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>

  <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">method</span> <span class="n">set</span> <span class="n">x</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;-</span> <span class="n">x</span>

  <span class="k">method</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next_node</span>
  <span class="k">method</span> <span class="n">set_next</span> <span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span> <span class="o">&lt;-</span> <span class="n">node</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8445760">
      The <code>value</code> is the value stored in the node, and
      it can be retrieved and changed with the <code>get</code>
      and <code>set</code> methods. The
      <code>next_node</code> field is the link to the next element
      in the stack. Note that the type parameter <code>['a]</code>
      in the definition uses square brackets, but other uses of the type
      can omit them (or use parentheses if there is more than one type
      parameter).
    </p><p id="idp8449648">
      The type annotations on the <code>val</code> declarations
      are used to constrain type inference. If we omit these
      annotations, the type inferred for the class will be &quot;too
      polymorphic,&quot; <code>x</code> could have some type
      <code>'b</code> and <code>next_node</code> some type
      <code>'c option</code>.
    </p><div class="highlight"><pre>  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">=</span> <span class="nc">None</span>
  
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">x</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;-</span> <span class="n">x</span>
  
    <span class="k">method</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next_node</span>
    <span class="k">method</span> <span class="n">set_next</span> <span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span> <span class="o">&lt;-</span> <span class="n">node</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Some</span> <span class="k">type</span> <span class="n">variables</span> <span class="n">are</span> <span class="n">unbound</span> <span class="k">in</span> <span class="n">this</span> <span class="k">type</span><span class="o">:</span>
         <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="o">:</span>
           <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span>
           <span class="k">object</span>
             <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span>
             <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span>
             <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span>
             <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span>
             <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
             <span class="k">method</span> <span class="n">set_next</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
           <span class="k">end</span>
       <span class="nc">The</span> <span class="k">method</span> <span class="n">get</span> <span class="n">has</span> <span class="k">type</span> <span class="k">'</span><span class="n">b</span> <span class="n">where</span> <span class="k">'</span><span class="n">b</span> <span class="n">is</span> <span class="n">unbound</span>
</pre></div><p id="idp8455120">
      In general, we need to provide enough constraints so that the
      compiler will infer the correct type. We can add type constraints
      to the parameters, to the fields, and to the methods. It is a
      matter of preference how many constraints to add. You can add type
      constraints in all three places, but the extra text may not help
      clarity. A convenient middle ground is to annotate the fields
      and/or class parameters, and add constraints to methods only if
      necessary.
    </p><p id="idp8456032">
      Next, we can define the list itself. We'll keep a field
      <code>head</code> the refers to the first element in the
      list, and <code>last</code> refers to the final element in
      the list. The method <code>insert</code> adds an element to
      the end of the list.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span>
<span class="k">object</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="n">first</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="n">last</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>

   <span class="k">method</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="nc">None</span>

   <span class="k">method</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Some</span> <span class="o">(</span><span class="k">new</span> <span class="n">node</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">last</span> <span class="k">with</span>
         <span class="nc">Some</span> <span class="n">last_node</span> <span class="o">-&gt;</span>
            <span class="n">last_node</span><span class="o">#</span><span class="n">set_next</span> <span class="n">new_node</span><span class="o">;</span>
            <span class="n">last</span> <span class="o">&lt;-</span> <span class="n">new_node</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
            <span class="n">first</span> <span class="o">&lt;-</span> <span class="n">new_node</span><span class="o">;</span>
            <span class="n">last</span> <span class="o">&lt;-</span> <span class="n">new_node</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="object-types">Object types</h1><p id="idp8460944">
      This definition of the class <code>slist</code> is not
      complete, we can construct lists, but we also need to add the
      ability to traverse the elements in the list. One common style for
      doing this is to define a class for an <code>iterator</code>
      object. An iterator provides a generic mechanism to inspect and
      traverse the elements of a collection. This pattern isn't
      restricted to lists, it can be used for many different kinds of
      collections.
    </p><p id="idp8463024">
      There are two common styles for defining abstract interfaces like
      this. In Java, an iterator would normally be specified with an
      interface, which specifies a set of method types. In languages
      without interfaces, like C++, the specification would normally use
      <span><em>abstract</em></span> classes to specify the methods
      without implementing them (C++ uses the &quot;= 0&quot; definition
      to mean &quot;not implemented&quot;).
    </p><pre id="idp8464272">
// Java-style iterator, specified as an interface.
interface &lt;T&gt; iterator {
  T Get();
  boolean HasValue();
  void Next();
};

// Abstract class definition in C++.
template&lt;typename T&gt;
class Iterator {
 public:
  virtual ~Iterator() {}
  virtual T get() const = 0;
  virtual bool has_value() const = 0;
  virtual void next() = 0;
};
</pre><p id="idp8465392">
      OCaml support both styles. In fact, OCaml is more flexible than
      these approaches because an object type can be implemented by any
      object with the appropriate methods, it does not have to be
      specified by the object's class <span><em>a priori</em></span>.
      We'll leave abstract classes for later. Let's demonstrate the
      technique using object types.
    </p><p id="idp8466544">
      First, we'll define an object type <code>iterator</code>
      that specifies the methods in an iterator.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;;;`</span>
</pre></div><p id="idp8468608">
      Next, we'll define an actual iterator for the class
      <code>slist</code>. We can represent the position in the
      list with a field <code>current</code>, following links as
      we traverse the list.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="n">cur</span> <span class="o">=</span>
<span class="k">object</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">current</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="n">cur</span>

  <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">current</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>

  <span class="k">method</span> <span class="n">get</span> <span class="o">=</span>
     <span class="k">match</span> <span class="n">current</span> <span class="k">with</span>
        <span class="nc">Some</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">node</span><span class="o">#</span><span class="n">get</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;no value&quot;</span><span class="o">)</span>

  <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
     <span class="k">match</span> <span class="n">current</span> <span class="k">with</span>
        <span class="nc">Some</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">current</span> <span class="o">&lt;-</span> <span class="n">node</span><span class="o">#</span><span class="n">next</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;no value&quot;</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8471744">
      Finally, we add a method <code>iterator</code> to the slist
      class to produce an iterator. To do so, we construct an
      <code>slist_iterator</code> that refers to the first node in
      the list, but we want to return a value with the object type
      <code>iterator</code>. This requires an explicit coercion
      using the <code>:&gt;</code> operator.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span> <span class="k">object</span>
<span class="o">...</span>
   <span class="k">method</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">slist_iterator</span> <span class="n">first</span> <span class="o">:&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span><span class="o">)</span>
<span class="k">end</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">slist</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="o">#</span><span class="n">iterator</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp8476512">
      We may also wish to define functional-style methods,
      <code>iter f</code> takes a function <code>f</code>
      and applies it to each of the elements of the list.
    </p><div class="highlight"><pre><span class="k">method</span> <span class="n">iter</span> <span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
  <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
    <span class="n">f</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span>
    <span class="n">it</span><span class="o">#</span><span class="n">next</span>
  <span class="k">end</span>
</pre></div><p id="idp8479280">
      What about functional operations similar to
      <code>List.map</code> or <code>List.fold</code>? In
      general, these methods take a function that produces a value of
      some other type than the elements of the set. For example, the
      function <code>List.fold</code> has type
      <code>'a list -&gt; ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</code>,
      where <code>'b</code> is an arbitrary type. To replicate
      this in the <code>slist</code> class, we need a method type
      <code>('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</code>, where
      the method type is polymorphic over <code>'b</code>.
    </p><p id="idp8484912">
      The solution is to use a type quantifier, as shown in the
      following example. The method type must be specified directly
      after the method name, which means that method parameters must be
      expressed using a <code>fun</code> or
      <code>function</code> expression.
    </p><div class="highlight"><pre><span class="k">method</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="o">.</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
   <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span>
         <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">x</span> <span class="k">in</span>
         <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
         <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
            <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">!</span><span class="n">y</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
            <span class="n">it</span><span class="o">#</span><span class="n">next</span>
         <span class="k">done</span><span class="o">;</span>
         <span class="o">!</span><span class="n">y</span><span class="o">)</span>
</pre></div></section><section><h1 id="immutable-objects">Immutable objects</h1><p id="idp8489296">
      Many people consider object-oriented programming to be
      intrinsically imperative, where an object is like a state machine.
      Sending a message to an object causes it to change state,
      possibily sending messages to other objects.
    </p><p id="idp8489952">
      Indeed, in many programs, this makes sense, but it is by no means
      required. Let's define an object-oriented version of lists similar
      to the imperative list above. We'll implement it with a regular
      list type <code>'a list</code>, and insertion will be to the
      beginning of the list instead of to the end.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">flist</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">elements</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span>

   <span class="k">method</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="n">elements</span> <span class="o">=</span> <span class="bp">[]</span>

   <span class="k">method</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span> <span class="o">=</span> <span class="o">{&lt;</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">x</span> <span class="o">::</span> <span class="n">elements</span> <span class="o">&gt;}</span>

   <span class="k">method</span> <span class="n">iterator</span> <span class="o">=</span>
      <span class="o">(</span><span class="k">new</span> <span class="n">flist_iterator</span> <span class="n">elements</span> <span class="o">:&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span><span class="o">)</span>

   <span class="k">method</span> <span class="n">iter</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">f</span> <span class="n">elements</span>

   <span class="k">method</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="o">.</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">f</span> <span class="n">x</span> <span class="n">elements</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8492880">
      A key part of the implementation is the definition of the method
      <code>insert</code>. The expression
      <code>{&lt; ... &gt;}</code> produces a copy of the current
      object, with the same type, and the specified fields updated. In
      other words, the <code>new_fst new_x</code> method produces
      a copy of the object, with <code>x</code> replaced by
      <code>new_x</code>. The original object is not modified, and
      the value of <code>y</code> is also unaffected.
    </p><p id="idp8497328">
      There are some restriction on the use of the expression
      <code>{&lt; ... &gt;}</code>. It can be used only within a
      method body, and only the values of fields may be updated. Method
      implementations are fixed at the time the object is created, they
      cannot be changed dynamically.
    </p><p id="idp8498656">
      We use the same object type <code>iterator</code> for
      iterators, but implement it differently.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">flist_iterator</span> <span class="n">l</span> <span class="o">=</span>
<span class="k">object</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="n">elements</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="n">l</span>

   <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="bp">[]</span>

   <span class="k">method</span> <span class="n">get</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
         <span class="n">h</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">h</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;list is empty&quot;</span><span class="o">)</span>

   <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
         <span class="o">_</span> <span class="o">::</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">elements</span> <span class="o">&lt;-</span> <span class="n">l</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;list is empty&quot;</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="class-types">Class types</h1><p id="idp8502064">
      Once we have defined the list implementation, the next step is to
      wrap it in a module or <code>.ml</code> file and give it a
      type so that it can be used in the rest of our code. What is the
      type?
    </p><p id="idp8503312">
      Before we begin, let's wrap up the implementation in an explicit
      module (we'll use explicit modules for illustration, but the
      process is similar when we want to define a
      <code>.mli</code> file). In keeping with the usual style for
      modules, we define a type <code>'a t</code> to represent the
      type of list values.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">SList</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>
   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>
   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>
   
   <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span> <span class="k">new</span> <span class="n">slist</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8506896">
      We have multiple choices in definining the module type, depending
      on how much of the implementation we want to expose. At one
      extreme, a maximally-abstract signature would completely hide the
      class definitions.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">AbstractSList</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

   <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">end</span> <span class="o">=</span> <span class="nc">SList</span>
</pre></div><p id="idp8508656">
      The abstract signature is simple because we ignore the classes.
      But what if we want to include them in the signature, so that
      other modules can inherit from the class definitions? For this, we
      need to specify types for the classes, called <span><em>class
      types</em></span>. Class types do not appear in mainstream
      object-oriented programming languages, so you may not be familiar
      with them, but the concept is pretty simple. A class type
      specifies the type of each of the visible parts of the class,
      including both fields and methods. Just like for module types, you
      don't have to give a type for everything; anything you omit will
      be hidden.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">VisibleSList</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span>
  <span class="k">object</span>
     <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span>
     <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
     <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
     <span class="k">method</span> <span class="n">set_next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">-&gt;</span>
  <span class="k">object</span>
     <span class="k">method</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span>
     <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span>
     <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">first</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">last</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
    <span class="k">method</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span>
    <span class="k">method</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
    <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
  <span class="k">end</span>

  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">slist</span>
<span class="k">end</span> <span class="o">=</span> <span class="nc">SList</span>
</pre></div><p id="idp8512912">
      In this signature, we've chosen to make nearly everything visible.
      The class type for <code>slist</code> specifies the types of
      the fields <code>first</code> and <code>last</code>,
      as well ad the types of each of the methods. We've also included a
      class type for <code>slist_iterator</code>, which is of
      somewhat more questionable value, since the type doesn't appear in
      the type for <code>slist</code> at all.
    </p><p id="idp8516768">
      One more thing, in this example the function
      <code>make</code> has type
      <code>unit -&gt; 'a slist</code>. But wait, we've stressed
      <span><em>classes are not types</em></span>, so what's up with
      that? In fact, what we've said is entirely true, classes and class
      names <span><em>are not</em></span> types. However, class names can
      be used to stand for types. When the compiler sees a class name in
      type position, it automatically constructs an object type from it
      by erasing all the fields and keeping only the method types. In
      this case, the type expression <code>'a slist</code> is
      exactly equivalent to <code>'a t</code>.
    </p></section><section><h1 id="cryptokit">Cryptokit</h1><p id="idp8521936">
      Let's take a break from describing the object system with a more
      practical example.
    </p><aside class="note"><h1>
    Installing the Cryptokit library
    </h1><p id="idp8523072">
      The Cryptokit library can be installed via OPAM by
      <code>opam install cryptokit</code>. The OCamlfind package
      also has the same name, so you just need to
      <code>#require &quot;cryptokit&quot;</code> in your toplevel
      to load the library and make the modules available.
    </p></aside><p id="idp8525104">
      TODO: example
    </p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="imperative-programming-1.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="pt02.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>