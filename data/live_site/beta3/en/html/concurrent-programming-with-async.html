<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 18. Concurrent Programming with Async / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta3',
                        page: 'concurrent\u002Dprogramming\u002Dwith\u002Dasync.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="maps-and-hash-tables.html">13. Maps and Hash Tables</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html">14. Command Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">15. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-menhir.html">16. Parsing with OCamllex and Menhir</a>
                                            </li>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html">17. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html" class="here">18. Concurrent Programming with Async</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 18. Concurrent Programming with Async</h1>
                
                

    <p id="idp10773616">
    The logic of building programs that interact with the outside world
    is often dominated by waiting: waiting for the click of a mouse, or
    for data to be fetched from disk, or for space to be available on an
    outgoing network buffer. Even mildly sophisticated interactive
    applications are typically <span><em>concurrent</em></span>, needing
    to wait for multiple different events at the same time, responding
    immediately to whatever event happens first.
  </p><p id="idp10774896">
    One approach to concurrency is to use preemptive system threads,
    which is the dominant approach in languages like Java or C#. In this
    model, each task that may require simultaneous waiting is given an
    operating system thread of its own, so it can block without stopping
    the entire program.
  </p><p id="idp10775616">
    Another approach is to have a single-threaded program where that
    single thread runs an <span><em>event loop</em></span>, whose job is
    to react to external events like timeouts or mouse clicks by
    invoking a callback function that has been registered for that
    purpose. This approach shows up in languages like JavaScript that
    have single-threaded runtimes as well as in many GUI toolkits.
  </p><p id="idp10776832">
    Each of these mechanisms has its own trade-offs. System threads
    require significant memory and other resources per thread. Also, the
    operating system can arbitrarily interleave the execution of system
    threads, requiring the programmer to carefully protect shared
    resources with locks and condition variables, which is exceedingly
    error-prone.
  </p><p id="idp10777600">
    Single-threaded event-driven systems, on the other hand, execute a
    single task at a time and do not require the same kind of complex
    synchronization that preemptive threads do. However, the inverted
    control structure of an event-driven program often means that your
    own control flow has to be threaded awkwardly through the system's
    event loop, leading to a maze of event callbacks.
  </p><p id="idp10778416">
    This chapter covers the Async library, which offers a hybrid model
    that aims to provide the best of both worlds, avoiding the
    performance compromises and synchronization woes of preemptive
    threads without the confusing inversion of control that usually
    comes with event-driven systems.
  </p><section><h1 id="async-basics">Async basics</h1><p id="idp10780272">
      Recall how I/O is typically done in Core. Here's a simple example.
    </p><div class="rwocode"><pre><code># <span class="keyword5">In_channel.</span>read_all<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string -&gt; string = &lt;fun&gt;
</div># <span class="keyword5">Out_channel.</span>write_all <span class="keyword7">&quot;test.txt&quot;</span> ~data<span class="keyword2">:</span><span class="keyword7">&quot;This is only a test.&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># <span class="keyword5">In_channel.</span>read_all <span class="keyword7">&quot;test.txt&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;This is only a test.&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10781472">
      From the type of <code>In_channel.read_all</code>, you can
      see that it must be a blocking operation. In particular, the fact
      that it returns a concrete string means it can't return until the
      read has completed. The blocking nature of the call means that no
      progress can be made on anything else until the read is completed.
    </p><p id="idp10782912">
      In Async, well-behaved functions never block. Instead, they return
      a value of type <code>Deferred.t</code> that acts as a
      placeholder that will eventually be filled in with the result. As
      an example, consider the signature of the Async equivalent of
      <code>In_channel.read_all</code>.
    </p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;async&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword5">Async.</span>Std<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword5">Reader.</span>file_contents<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string -&gt; string Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10785712">
      We first load the Async package in the toplevel using
      <code>#require</code>, and then open
      <code>Async.Std</code>, which adds a number of new
      identifiers and modules into our environment that make using Async
      more convenient. Opening <code>Async.Std</code> is standard
      practice for writing programs using Async, much like opening
      <code>Core.Std</code> is for using Core.
    </p><p id="idp10789248">
      A deferred is essentially a handle to a value that may be computed
      in the future. As such, if we call
      <code>Reader.file_contents</code>, the resulting deferred
      will initially be empty, as you can see by calling
      <code>Deferred.peek</code> on the resulting deferred.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> contents <span class="keyword2">=</span> <span class="keyword5">Reader.</span>file_contents <span class="keyword7">&quot;test.txt&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val contents : string Deferred.t = &lt;abstr&gt;
</div># <span class="keyword5">Deferred.</span>peek contents<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string option = None
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10792032">
      The value in <code>contents</code> isn't yet determined in
      part because there's nothing running that could do the necessary
      I/O. When using Async, processing of I/O and other events is
      handled by the Async scheduler. When writing a standalone program,
      you need to start the scheduler explicitly, but
      <span><strong>utop</strong></span> knows about Async, and can start the
      scheduler automatically. More than that, <span><strong>utop</strong></span>
      knows about deferred values, and when you type in an expression of
      type <code>Deferred.t</code>, it will make sure the
      scheduler is running and block until the deferred is determined.
      Thus, we can write:
    </p><div class="rwocode"><pre><code># contents<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;This is only a test.&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10796576">
      If we peek again, we'll see that the value of
      <code>contents</code> has been determined.
    </p><div class="rwocode"><pre><code># <span class="keyword5">Deferred.</span>peek contents<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string option = Some &quot;This is only a test.&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10798496">
      In order to do real work with deferreds, we need a way of waiting
      for a deferred computation to finish, which we do using
      <code>Deferred.bind</code>. First, let's consider the
      type-signature of bind.
    </p><div class="rwocode"><pre><code># <span class="keyword5">Deferred.</span>bind <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Deferred.t -&gt; ('a -&gt; 'b Deferred.t) -&gt; 'b Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10800528">
<code>Deferred.bind d f</code> takes a deferred value
      <code>d</code> and a function <code>f</code> that is
      to be run with the value of <code>d</code> once it's
      determined. You can think of <code>Deferred.bind</code> as a
      kind of sequencing operator, and what we're doing is essentially
      taking an asynchronous computation <code>d</code> and
      tacking on another stage comprised by the actions of the function
      <code>f</code>.
    </p><p id="idp10806032">
      At a more concrete level, the call to
      <code>Deferred.bind</code> returns a new deferred that
      becomes determined when the deferred returned by
      <code>f</code> is determined. It also implicitly registers
      with the scheduler an <span><em>Async job</em></span> that is
      responsible for running <code>f</code> once
      <code>d</code> is determined.
    </p><p id="idp10809872">
      Here's a simple use of bind for a function that replaces a file
      with an uppercase version of its contents.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> uppercase_file filename <span class="keyword2">=</span>
    <span class="keyword5">Deferred.</span>bind <span class="keyword2">(</span><span class="keyword5">Reader.</span>file_contents filename<span class="keyword2">)</span>
     <span class="keyword2">(</span><span class="keyword1">fun</span> text -<span class="keyword2">&gt;</span>
         <span class="keyword5">Writer.</span>save filename ~contents<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword5">String.</span>uppercase text<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val uppercase_file : string -&gt; unit Deferred.t = &lt;fun&gt;
</div># uppercase_file <span class="keyword7">&quot;test.txt&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># <span class="keyword5">Reader.</span>file_contents <span class="keyword7">&quot;test.txt&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;THIS IS ONLY A TEST.&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10811120">
      Writing out <code>Deferred.bind</code> explicitly can be
      rather verbose, and so <code>Async.Std</code> includes an
      infix operator for it: <code>&gt;&gt;=</code>. Using this
      operator, we can rewrite <code>uppercase_file</code> as
      follows.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> uppercase_file filename <span class="keyword2">=</span>
    <span class="keyword5">Reader.</span>file_contents filename
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span> text -<span class="keyword2">&gt;</span>
    <span class="keyword5">Writer.</span>save filename ~contents<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword5">String.</span>uppercase text<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val uppercase_file : string -&gt; unit Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10815232">
      In the above we've dropped the parentheses around the function on
      the right-hand side of the bind, and we didn't add a level of
      indentation for the contents of that function. This is standard
      practice for using the bind operator.
    </p><p id="idp10815888">
      Now let's look at another potential use of bind. In this case,
      we'll write a function that counts the number of lines in a file.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> count_lines filename <span class="keyword2">=</span>
    <span class="keyword5">Reader.</span>file_contents filename
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span> text -<span class="keyword2">&gt;</span>
    <span class="keyword5">List.</span>length <span class="keyword2">(</span><span class="keyword5">String.</span>split text ~on<span class="keyword2">:</span>'\n'<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 85-125:
Error: This expression has type int but an expression was expected of type
         'a Deferred.t
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 10) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10817152">
      This looks reasonable enough, but as you can see, the compiler is
      unhappy. The issue here is that bind expects a function that
      returns a deferred, but we've provided it a function that returns
      the non-deferred result directly. To make these signatures match,
      we need a function for taking an ordinary value and wrapping it in
      a deferred. This function is a standard part of Async, and is
      called <code>return</code>:
    </p><div class="rwocode"><pre><code># return<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a -&gt; 'a Deferred.t = &lt;fun&gt;
</div># <span class="keyword4">let</span> three <span class="keyword2">=</span> return <span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val three : int Deferred.t = &lt;abstr&gt;
</div># three<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 3
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 11) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10819424">
      Using <code>return</code>, we can make
      <code>count_lines</code> compile.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> count_lines filename <span class="keyword2">=</span>
    <span class="keyword5">Reader.</span>file_contents filename
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span> text -<span class="keyword2">&gt;</span>
    return <span class="keyword2">(</span><span class="keyword5">List.</span>length <span class="keyword2">(</span><span class="keyword5">String.</span>split text ~on<span class="keyword2">:</span>'\n'<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val count_lines : string -&gt; int Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 12) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10822000">
      Together, <code>bind</code> and <code>return</code>
      form a design pattern in functional programming known as a
      <span><em>monad</em></span>. You'll run across this signature in
      many applications beyond just threads. Indeed, we already ran
      across monads in
      <a href="error-handling.html#bind-and-other-error-handling-idioms">the section called “<code>bind</code> and other error-handling
      idioms”</a>.
    </p><p id="idp10825296">
      Calling <code>bind</code> and <code>return</code>
      together is a fairly common pattern, and as such there is a
      standard shortcut for it called <code>Deferred.map</code>,
      which has the following signature:
    </p><div class="rwocode"><pre><code># <span class="keyword5">Deferred.</span>map<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Deferred.t -&gt; f:('a -&gt; 'b) -&gt; 'b Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 13) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10828720">
      and comes with its own infix equivalent,
      <code>&gt;&gt;|</code>. Using it, we can rewrite
      <code>count_lines</code> again a bit more succinctly:
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> count_lines filename <span class="keyword2">=</span>
    <span class="keyword5">Reader.</span>file_contents filename
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> text -<span class="keyword2">&gt;</span>
    <span class="keyword5">List.</span>length <span class="keyword2">(</span><span class="keyword5">String.</span>split text ~on<span class="keyword2">:</span>'\n'<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val count_lines : string -&gt; int Deferred.t = &lt;fun&gt;
</div># count_lines <span class="keyword7">&quot;/etc/hosts&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 12
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 14) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10831312">
      Note that <code>count_lines</code> returns a deferred, but
      <span><strong>utop</strong></span> waits for that deferred to become
      determined, and shows us the contents of the deferred instead.
    </p><section><h1 id="ivars-and-upon">Ivars and upon</h1><p id="idp10834432">
        Deferreds are usually built using combinations of
        <code>bind</code>, <code>map</code> and
        <code>return</code>, but sometimes you want to construct a
        deferred that you can determine explicitly with user-code. This
        is done using an <span><em>ivar</em></span>. (The term ivar dates
        back to a language called Concurrent ML that was developed by
        John Reppy in the early 90's. The &quot;i&quot; in ivar stands
        for incremental.)
      </p><p id="idp10837824">
        There are three fundamental operations for working with an ivar;
        you can create one, using <code>Ivar.create</code>, you
        can read off the deferred that corresponds to the ivar in
        question, using <code>Ivar.read</code>, and you can fill
        an ivar, thus causing the corresponding deferred to become
        determined, using <code>Ivar.fill</code>. These operations
        are illustrated below.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> ivar <span class="keyword2">=</span> <span class="keyword5">Ivar.</span>create <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ivar : '_a Ivar.t = &lt;abstr&gt;
</div># <span class="keyword4">let</span> def <span class="keyword2">=</span> <span class="keyword5">Ivar.</span>read ivar<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val def : '_a Deferred.t = &lt;abstr&gt;
</div># <span class="keyword5">Deferred.</span>peek def<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : '_a option = None
</div># <span class="keyword5">Ivar.</span>fill ivar <span class="keyword7">&quot;Hello&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># <span class="keyword5">Deferred.</span>peek def<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string option = Some &quot;Hello&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 15) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10841440">
        Ivars are something of a low-level feature; operators like map,
        bind and return are typically easier to use and think about. But
        ivars can be useful when you want to build a synchronization
        patterns that isn't already well supported.
      </p><p id="idp10842112">
        As an example, imagine we wanted a way of scheduling a sequence
        of actions that would run after a fixed delay. In addition, we'd
        like to guarantee that these delayed actions are executed in the
        same order they were scheduled in. Here's a reasonable signature
        that captures this idea.
      </p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">Delayer_intf </span><span class="keyword2">=</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> t
    <span class="keyword4">val</span> create <span class="keyword2">:</span> <span class="keyword5">Time.</span><span class="keyword5">Span.</span>t -<span class="keyword2">&gt;</span> t
    <span class="keyword4">val</span> schedule <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>unit -<span class="keyword2">&gt;</span> 'a <span class="keyword5">Deferred.</span>t<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> 'a <span class="keyword5">Deferred.</span>t
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module type Delayer_intf =
  sig
    type t
    val create : Core.Span.t -&gt; t
    val schedule : t -&gt; (unit -&gt; 'a Deferred.t) -&gt; 'a Deferred.t
  end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 16) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10843568">
        An action is handed to <code>schedule</code> in the form
        of a deferred-returning thunk (a thunk is a function whose
        argument is of type <code>unit</code>). A deferred is
        handed back to the caller of <code>schedule</code> that
        will eventually be filled with the contents of the deferred
        value returned by the thunk. To implement this, we'll use an
        operator called <code>upon</code>, which has the following
        signature.
      </p><div class="rwocode"><pre><code># upon<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Deferred.t -&gt; ('a -&gt; unit) -&gt; unit = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 17) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10847904">
        Like <code>bind</code> and <code>return</code>,
        <code>upon</code> schedules a callback to be executed when
        the deferred it is passed is determined; but unlike those calls,
        it doesn't create a new deferred for this callback to fill.
      </p><p id="idp10850656">
        Our delayer implementation is organized around a queue of
        thunks, where every call to <code>schedule</code> adds a
        thunk to the queue, and also schedules a job in the future to
        grab a thunk off the queue and run it. The waiting will be done
        using the function <code>after</code> which takes a time
        span and returns a deferred which becomes determined after that
        time span elapses.
      </p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Delayer </span><span class="keyword2">:</span> <span class="keyword6">Delayer_intf </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> delay<span class="keyword2">:</span> <span class="keyword5">Time.</span><span class="keyword5">Span.</span>t<span class="keyword2">;</span>
               jobs<span class="keyword2">:</span> <span class="keyword2">(</span>unit -<span class="keyword2">&gt;</span> unit<span class="keyword2">)</span> <span class="keyword5">Queue.</span>t<span class="keyword2">;</span>
             <span class="keyword2">}</span>

    <span class="keyword4">let</span> create delay <span class="keyword2">=</span>
      <span class="keyword2">{</span> delay<span class="keyword2">;</span> jobs <span class="keyword2">=</span> <span class="keyword5">Queue.</span>create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">}</span>

    <span class="keyword4">let</span> schedule t thunk <span class="keyword2">=</span>
      <span class="keyword4">let</span> ivar <span class="keyword2">=</span> <span class="keyword5">Ivar.</span>create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
      <span class="keyword5">Queue.</span>enqueue t.jobs <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
        upon <span class="keyword2">(</span>thunk <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> <span class="keyword5">Ivar.</span>fill ivar x<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
      upon <span class="keyword2">(</span>after t.delay<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
        <span class="keyword4">let</span> job <span class="keyword2">=</span> <span class="keyword5">Queue.</span>dequeue_exn t.jobs <span class="keyword4">in</span>
        job <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
      <span class="keyword5">Ivar.</span>read ivar
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Delayer : Delayer_intf
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 18) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10853584">
        This code isn't particularly long, but it is subtle. In
        particular, note how the queue of thunks is used to ensure that
        the enqueued actions are run in order, even if the thunks
        scheduled by <code>upon</code> are run out-of-order. This
        kind of subtlety is typical of code that involves ivars and
        <code>upon</code>, and because of this, you should stick
        to the simpler map/bind/return style of working with deferreds
        when you can.
      </p></section></section><section><h1 id="examples-an-echo-server">Examples: an echo server</h1><p id="idp10857328">
      Now that we have the basics of Async under our belt, let's look at
      a small standalone Async program. In particular, we'll write an
      echo server, <span><em>i.e.</em></span>, a program that accepts
      connections from clients and spits back whatever is sent to it.
    </p><p id="idp10858384">
      The first step is to create a function that can copy data from an
      input to an output. Here, we'll use Async's
      <code>Reader</code> and <code>Writer</code> modules
      which provide a convenient abstraction for working with input and
      output channels.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Async.Std
</span>
<span class="comments">(* Copy data from the reader to the writer, using the provided buffer
   as scratch space *)</span>
<span class="keyword4">let</span> <span class="keyword4">rec</span> copy_blocks buffer r w <span class="keyword2">=</span>
  <span class="keyword5">Reader.</span>read r buffer
  <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">function</span>
  <span class="keyword2">|</span> <span class="keyword6">`Eof </span>-<span class="keyword2">&gt;</span> return <span class="keyword2">(</span><span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Ok </span>bytes_read -<span class="keyword2">&gt;</span>
    <span class="keyword5">Writer.</span>write w buffer ~len<span class="keyword2">:</span>bytes_read<span class="keyword2">;</span>
    <span class="keyword5">Writer.</span>flushed w
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    copy_blocks buffer r w</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/echo.ml">async/echo.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10861168">
      Bind is used in the above code to sequence the operations: first,
      we call <code>Reader.read</code> to get a block of input.
      Then, when that's complete and if a new block was returned, we
      write that block to the writer. Finally, we wait until the
      writer's buffers are flushed, waiting on the deferred returned by
      <code>Writer.flushed</code>, at which point we recurse. If
      we hit an end-of-file condition, the loop is ended. The deferred
      returned by a call to <code>copy_blocks</code> becomes
      determined only once the end-of-file condition is hit.
    </p><p id="idp10864208">
      One important aspect of how this is written is that it uses
      <span><em>pushback</em></span>, which is to say that if the writer
      can't make progress writing, the reader will stop reading. If you
      don't implement pushback in your servers, then a stopped client
      can cause your program to leak memory, since you'll need to
      allocate space for the data that's been read in but not yet
      written out.
    </p><p id="idp10865456">
      You might also be concerned that the chain of deferreds that is
      built up as you go through the loop would lead to a memory leak.
      After all, this code constructs an ever-growing chain of binds,
      each of which creates a deferred. In this case, however, all of
      the deferreds should become determined precisely when the final
      deferred in the chain is determined, in this case, when the
      <code>Eof</code> condition is hit. Because of this, we could
      safely replace all of these deferreds with a single deferred.
      Async has logic to do just this, and so there's no memory leak
      after all. This is essentially a form of tail-call optimization,
      lifted to the Async monad.
    </p><p id="idp10867296">
<code>copy_blocks</code> provides the logic for handling a
      client connection, but we still need to set up a server to receive
      such connections and dispatch to <code>copy_blocks</code>.
      For this, we'll use Async's <code>Tcp</code> module, which
      has a collection of utilities for creating TCP clients and
      servers.
    </p><div class="rwocode"><pre><code><span class="comments">(** Starts a TCP server, which listens on the specified port, invoking
    copy_blocks every time a client connects. *)</span>
<span class="keyword4">let</span> run <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> host_and_port <span class="keyword2">=</span>
    <span class="keyword5">Tcp.</span><span class="keyword5">Server.</span>create
      ~on_handler_error<span class="keyword2">:</span><span class="keyword6">`Raise
</span>      <span class="keyword2">(</span><span class="keyword5">Tcp.</span>on_port <span class="keyword8">8765</span><span class="keyword2">)</span>
      <span class="keyword2">(</span><span class="keyword1">fun</span> _addr r w -<span class="keyword2">&gt;</span>
         <span class="keyword4">let</span> buffer <span class="keyword2">=</span> <span class="keyword5">String.</span>create <span class="keyword2">(</span><span class="keyword8">16</span> <span class="keyword2">*</span> <span class="keyword8">1024</span><span class="keyword2">)</span> <span class="keyword4">in</span>
         copy_blocks buffer r w<span class="keyword2">)</span>
  <span class="keyword4">in</span>
  ignore <span class="keyword2">(</span>host_and_port <span class="keyword2">:</span> <span class="keyword2">(</span><span class="keyword5">Socket.</span><span class="keyword5">Address.</span><span class="keyword5">Inet.</span>t, <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword5">Tcp.</span><span class="keyword5">Server.</span>t <span class="keyword5">Deferred.</span>t<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/echo.ml">async/echo.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10870800">
      The result of calling <code>Tcp.Server.create</code> is a
      <code>Tcp.Server.t</code>, which is a handle to the server
      that lets you shut the server down. We don't use that
      functionality here, so we explicitly ignore
      <code>server</code> to suppress the unused-variables error.
      We put in a type annotation around the ignored value to make the
      nature of the value we're ignoring explicit.
    </p><p id="idp10873664">
      The most important argument to
      <code>Tcp.Server.create</code> is the final one, which is
      the client connection handler. Notably, the above code does
      nothing explicit to close down the client connections when the
      communication is done. That's because the server will
      automatically shut down the connection once the deferred returned
      by the handler becomes determined.
    </p><p id="idp10875152">
      Finally, we need to initiate the server and start the Async
      scheduler.
    </p><div class="rwocode"><pre><code><span class="comments">(* Call [run], and then start the scheduler *)</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  run <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span>
  never_returns <span class="keyword2">(</span><span class="keyword5">Scheduler.</span>go <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/echo.ml">async/echo.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10876368">
      One of the most common newbie errors with Async is to forget to
      run the scheduler. It can be a bewildering mistake, because
      without the scheduler, your program won't do anything at all; even
      calls to <code>printf</code> won't reach the terminal.
    </p><p id="idp10877728">
      It's worth noting that even though we didn't spend much explicit
      effort on thinking about multiple clients, this server is able to
      handle many concurrent clients without further modification.
    </p><p id="idp10878336">
      Now that we have the echo server, we can connect to the echo
      server using the netcat tool, which is invoked as
      <code>nc</code>.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./echo.native &amp;
</div><div class="highlight"><span class="gp">$</span> nc 127.0.0.1 8765
</div><div class="rwocodeout">This is an echo server</div><div class="rwocodeout">This is an echo server</div><div class="rwocodeout">It repeats whatever I write.</div><div class="rwocodeout">It repeats whatever I write.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/run_echo.out">async/run_echo.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1><b>
    Functions that never return
    </b></h1><p id="idp10880960">
      You might wonder what's going on with the call to
      <code>never_returns</code> above.
      <code>never_returns</code> is an idiom that comes from
      <code>Core</code> that is used to mark functions that don't
      return. Typically, a function that doesn't return is inferred as
      having return type <code>'a</code>.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> loop_forever <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> loop_forever <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val loop_forever : unit -&gt; 'a = &lt;fun&gt;
</div># <span class="keyword4">let</span> always_fail <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword1">assert</span> false<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val always_fail : unit -&gt; 'a = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 19) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10885136">
      This can be surprising when you call a function like this
      expecting it to return unit. The type-checker won't necessarily
      complain in such a case.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> do_stuff n <span class="keyword2">=</span>
    <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword8">3</span> <span class="keyword4">in</span>
    <span class="keyword1">if</span> n <span class="keyword2">&gt;</span> <span class="keyword8">0</span> <span class="keyword1">then</span> loop_forever <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span>
    x <span class="keyword2">+</span> n
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val do_stuff : int -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 20) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10886432">
      With a name like <code>loop_forever</code>, the meaning is
      clear enough. But with something like
      <code>Scheduler.go</code>, the fact that it never returns is
      less clear, and so we use the type system to make it more explicit
      by giving it a return type of <code>never_returns</code>.
      Let's do the same trick with <code>loop_forever</code>.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> loop_forever <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">:</span> never_returns <span class="keyword2">=</span> loop_forever <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val loop_forever : unit -&gt; never_returns = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 21) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10890656">
      The type <code>never_returns</code> is uninhabited, so a
      function can't return a value of type
      <code>never_returns</code>, which means only a function that
      never return can have <code>never_returns</code> as its
      return type! Now, if we rewrite our <code>do_stuff</code>
      function, we'll get a helpful type error.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> do_stuff n <span class="keyword2">=</span>
    <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword8">3</span> <span class="keyword4">in</span>
    <span class="keyword1">if</span> n <span class="keyword2">&gt;</span> <span class="keyword8">0</span> <span class="keyword1">then</span> loop_forever <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span>
    x <span class="keyword2">+</span> n
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 38-67:
Error: This expression has type unit but an expression was expected of type
         never_returns
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 22) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10894848">
      We can resolve the error by calling the function
      <code>never_returns</code>.
    </p><div class="rwocode"><pre><code># never_returns<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : never_returns -&gt; 'a = &lt;fun&gt;
</div># <span class="keyword4">let</span> do_stuff n <span class="keyword2">=</span>
    <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword8">3</span> <span class="keyword4">in</span>
    <span class="keyword1">if</span> n <span class="keyword2">&gt;</span> <span class="keyword8">0</span> <span class="keyword1">then</span> never_returns <span class="keyword2">(</span>loop_forever <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
    x <span class="keyword2">+</span> n
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val do_stuff : int -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 23) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10896752">
      Thus, we got the compilation to go through by explicitly marking
      in the source that the call to <code>loop_forever</code>
      never returns.
    </p></section><section><h1 id="improving-the-echo-server">Improving the echo server</h1><p id="idp10899280">
        Let's try to go a little bit farther with our echo server by
        walking through a few improvements. In particular, we will
      </p><ul><li><p id="idp10900336">
            add a proper command-line interface with
            <code>Command</code>,
          </p></li><li><p id="idp10901904">
            add a flag to specify the port to listen on, and a flag to
            make the server echo back the capitalized version of
            whatever was sent to it,
          </p></li><li><p id="idp10902880">
            simplify the code using Async's <code>Pipe</code>
            interface.
          </p></li></ul><p id="idp10904320">
        The code below does all of this.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Async.Std
</span>
<span class="keyword4">let</span> run ~uppercase ~port <span class="keyword2">=</span>
  <span class="keyword4">let</span> host_and_port <span class="keyword2">=</span>
    <span class="keyword5">Tcp.</span><span class="keyword5">Server.</span>create
      ~on_handler_error<span class="keyword2">:</span><span class="keyword6">`Raise
</span>      <span class="keyword2">(</span><span class="keyword5">Tcp.</span>on_port port<span class="keyword2">)</span>
      <span class="keyword2">(</span><span class="keyword1">fun</span> _addr r w -<span class="keyword2">&gt;</span>
        <span class="keyword5">Pipe.</span>transfer <span class="keyword2">(</span><span class="keyword5">Reader.</span>pipe r<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword5">Writer.</span>pipe w<span class="keyword2">)</span>
           ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">if</span> uppercase <span class="keyword1">then</span> <span class="keyword5">String.</span>uppercase <span class="keyword1">else</span> <span class="keyword5">Fn.</span>id<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword4">in</span>
  ignore <span class="keyword2">(</span>host_and_port <span class="keyword2">:</span> <span class="keyword2">(</span><span class="keyword5">Socket.</span><span class="keyword5">Address.</span><span class="keyword5">Inet.</span>t, <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword5">Tcp.</span><span class="keyword5">Server.</span>t <span class="keyword5">Deferred.</span>t<span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword5">Deferred.</span>never <span class="keyword2">(</span><span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>async_basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Start an echo server&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> flag <span class="keyword7">&quot;-uppercase&quot;</span> no_arg
        ~doc<span class="keyword2">:</span><span class="keyword7">&quot; Convert to uppercase before echoing back&quot;</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> flag <span class="keyword7">&quot;-port&quot;</span> <span class="keyword2">(</span>optional_with_default <span class="keyword8">8765</span> <span class="keyword3">int</span><span class="keyword2">)</span>
        ~doc<span class="keyword2">:</span><span class="keyword7">&quot; Port to listen on (default 8765)&quot;</span>
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> uppercase port <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> run ~uppercase ~port<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/better_echo.ml">async/better_echo.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10905488">
        Note the use of <code>Deferred.never</code> in the
        <code>run</code> function. As you might guess from the
        name <code>Deferred.never</code> returns a deferred that
        is never determined. In this case, that indicates that the echo
        server doesn't ever shut down.
      </p><p id="idp10908256">
        The biggest change in the above code is the use of Async's
        <code>Pipe</code>. A <code>Pipe</code> is an
        asynchronous communication channel that's used for connecting
        different parts of your program. You can think of it as a
        consumer/producer queue that uses deferreds for communicating
        when the pipe is ready to be read from or written to. Our use of
        pipes is fairly minimal here, but they are an important part of
        Async, so it's worth discussing them in some detail.
      </p><p id="idp10910592">
        Pipes are created in connected read/write pairs, as you can see
        below.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword2">(</span>r,w<span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">Pipe.</span>create <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val r : '_a Pipe.Reader.t = &lt;abstr&gt;
val w : '_a Pipe.Writer.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 24) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10911808">
<code>r</code> and <code>w</code> are really just
        read and write handles to the same underlying object. Note that
        <code>r</code> and <code>w</code> have weakly
        polymorphic types, as discussed in
        <a href="a-guided-tour.html#imperative-programming">the section called “Imperative programming”</a>, and so can
        only contain values of a single yet to be determined type.
      </p><p id="idp10915936">
        If we just try and write to the writer, we'll see that we block
        indefinitely in <span><strong>utop</strong></span>. You can break out of
        the wait by hitting <code>Control-C</code>.
      </p><div class="rwocode"><pre><code># <span class="keyword5">Pipe.</span>write w <span class="keyword7">&quot;Hello World!&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Interrupted.</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/pipe_write_break.rawscript">async/pipe_write_break.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10918608">
        The deferred returned by write completes on its own once the
        value written into the pipe has been read out:
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword2">(</span>r,w<span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">Pipe.</span>create <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val r : '_a Pipe.Reader.t = &lt;abstr&gt;
val w : '_a Pipe.Writer.t = &lt;abstr&gt;
</div># <span class="keyword4">let</span> write_complete <span class="keyword2">=</span> <span class="keyword5">Pipe.</span>write w <span class="keyword7">&quot;Hello World!&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val write_complete : unit Deferred.t = &lt;abstr&gt;
</div># <span class="keyword5">Pipe.</span>read r<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : [ `Eof | `Ok of string ] = `Ok &quot;Hello World!&quot;
</div># write_complete<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 25) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10919856">
        In the function <code>run</code> above, we're taking
        advantage of one of the many utility functions provided for
        pipes in the <code>Pipe</code> module. In particular,
        we're using <code>Pipe.transfer</code> to set up a process
        that takes data from a reader-pipe and moves it to a
        writer-pipe. Here's the type of
        <code>Pipe.transfer</code>:
      </p><div class="rwocode"><pre><code># <span class="keyword5">Pipe.</span>transfer<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Pipe.Reader.t -&gt; 'b Pipe.Writer.t -&gt; f:('a -&gt; 'b) -&gt; unit Deferred.t =
&lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 26) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10924096">
        The two pipes being connected are generated by the
        <code>Reader.pipe</code> and
        <code>Writer.pipe</code> call respectively. Note that
        pushback is preserved throughout the process, so that if the
        writer gets blocked, the writer's pipe will stop pulling data
        from the reader's pipe, which will prevent the reader from
        reading in more data.
      </p><p id="idp10926256">
        Importantly, the deferred returned by
        <code>Pipe.transfer</code> becomes determined once the
        reader has been closed and the last element is transferred from
        the reader to the writer. Once that deferred becomes determined,
        the server will shut down that client connection. So, when a
        client disconnects, the rest of the shutdown happens
        transparently.
      </p><p id="idp10927744">
        The command-line parsing for this program is based on the
        <code>Command</code> library that we introduced in
        <a href="command-line-parsing.html">Chapter 14, <i>Command Line Parsing</i></a>. Opening
        <code>Async.Std</code>, shadows the
        <code>Command</code> module with an extended version that
        contains the <code>async_basic</code> call.
      </p><div class="rwocode"><pre><code># <span class="keyword5">Command.</span>async_basic<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    ('a, unit -&gt; unit Deferred.t) Command.Spec.t -&gt; 'a -&gt; Command.t
= &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 27) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10932560">
        This differs from the ordinary <code>Command.basic</code>
        call in that the main function must return a
        <code>Deferred.t</code>, and that the running of the
        command (using <code>Command.run</code>) automatically
        starts the async scheduler, without requiring an explicit call
        to <code>Scheduler.go</code>.
      </p></section></section><section><h1 id="example-searching-definitions-with-duckduckgo">Example: searching definitions with DuckDuckGo</h1><p id="idp10937552">
      DuckDuckGo is a search engine with a freely available search
      interface. In this section, we'll use Async to write a small
      command-line utility for querying DuckDuckGo to extract
      definitions for a collection of terms.
    </p><p id="idp10938192">
      Our code is going to rely on a number of other libraries, all of
      which can be installed using OPAM. Refer to
      <a href="installation.html">Appendix A, <i>Installation</i></a> if you need help on the
      installation. Here's the list of libraries we'll need.
    </p><ul><li><p id="idp10940016">
<code>textwrap</code>, a library for wrapping long
          lines. We'll use this for printing out our results.
        </p></li><li><p id="idp10941552">
<code>uri</code>, a library for handling URIs, or
          &quot;Uniform Resource Identifiers&quot;, of which HTTP URL's
          are an example.
        </p></li><li><p id="idp10943280">
<code>yojson</code>, a JSON parsing library that was
          described in <a href="handling-json-data.html">Chapter 15, <i>Handling JSON data</i></a>
</p></li><li><p id="idp10945488">
<code>cohttp</code>, a library for creating HTTP clients
          and servers. We need Async support, which comes with the
          <code>cohttp.async</code> package.
        </p></li></ul><p id="idp10947632">
      Now let's dive into the implementation.
    </p><section><h1 id="uri-handling">URI handling</h1><p id="idp10949232">
        HTTP URLs, which identify endpoints across the web, are actually
        part of a more general family known as Uniform Resource
        Identifiers (URIs). The full URI specification is defined in
        <a href="http://tools.ietf.org/html/rfc3986" target="_top">RFC3986</a>,
        and is rather complicated. Luckily, the <code>uri</code>
        library provides a strongly-typed interface which takes care of
        much of the hassle.
      </p><p id="idp10951392">
        We'll need a function for generating the URIs that we're going
        to use to query the DuckDuckGo servers.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Async.Std
</span>
<span class="comments">(* Generate a DuckDuckGo search URI from a query string *)</span>
<span class="keyword4">let</span> query_uri query <span class="keyword2">=</span>
  <span class="keyword4">let</span> base_uri <span class="keyword2">=</span> <span class="keyword5">Uri.</span>of_string <span class="keyword7">&quot;http://api.duckduckgo.com/?format=json&quot;</span> <span class="keyword4">in</span>
  <span class="keyword5">Uri.</span>add_query_param base_uri <span class="keyword2">(</span><span class="keyword7">&quot;q&quot;</span>, <span class="keyword2">[</span>query<span class="keyword2">]</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search.ml">async/search.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10952640">
        A <code>Uri.t</code> is constructed from the
        <code>Uri.of_string</code> function, and a query parameter
        <code>q</code> is added with the desired search query. The
        library takes care of encoding the URI correctly when outputting
        it in the network protocol.
      </p></section><section><h1 id="parsing-json-strings">Parsing JSON strings</h1><p id="idp10956592">
        The HTTP response from DuckDuckGo is in JSON, a common (and
        thankfully simple) format that is specified in
        <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_top">RFC4627</a>.
        We'll parse the JSON data using the Yojson library, which was
        introduced in <a href="handling-json-data.html">Chapter 15, <i>Handling JSON data</i></a>.
      </p><p id="idp10958608">
        We expect the response from DuckDuckGo to come across as a JSON
        record, which is represented by the <code>Assoc</code> tag
        in Yojson's JSON variant. We expect the definition itself to
        come across under either the key &quot;Abstract&quot; or
        &quot;Definition&quot;, and so the code below looks under both
        keys, returning the first one for which a non-empty value is
        defined.
      </p><div class="rwocode"><pre><code><span class="comments">(* Extract the &quot;Definition&quot; or &quot;Abstract&quot; field from the DuckDuckGo results *)</span>
<span class="keyword4">let</span> get_definition_from_json json <span class="keyword2">=</span>
  <span class="keyword1">match</span> <span class="keyword5">Yojson.</span><span class="keyword5">Safe.</span>from_string json <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">`Assoc </span>kv_list -<span class="keyword2">&gt;</span>
    <span class="keyword4">let</span> find key <span class="keyword2">=</span>
      <span class="keyword4">begin</span> <span class="keyword1">match</span> <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>find kv_list key <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">None </span><span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword6">`String </span><span class="keyword7">&quot;&quot;</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword6">None
</span>      <span class="keyword2">|</span> <span class="keyword6">Some </span>s -<span class="keyword2">&gt;</span> <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword5">Yojson.</span><span class="keyword5">Safe.</span>to_string s<span class="keyword2">)</span>
      <span class="keyword4">end</span>
    <span class="keyword4">in</span>
    <span class="keyword4">begin</span> <span class="keyword1">match</span> find <span class="keyword7">&quot;Abstract&quot;</span> <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword8">_</span> <span class="keyword1">as</span> x -<span class="keyword2">&gt;</span> x
    <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> find <span class="keyword7">&quot;Definition&quot;</span>
    <span class="keyword4">end</span>
  <span class="keyword2">|</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> None</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search.ml">async/search.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="executing-an-http-client-query">Executing an HTTP client query</h1><p id="idp10962544">
        Now let's look at the code for dispatching the search queries
        over HTTP, using the Cohttp library.
      </p><div class="rwocode"><pre><code><span class="comments">(* Execute the DuckDuckGo search *)</span>
<span class="keyword4">let</span> get_definition word <span class="keyword2">=</span>
  <span class="keyword5">Cohttp_async.</span><span class="keyword5">Client.</span>get <span class="keyword2">(</span>query_uri word<span class="keyword2">)</span>
  <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword8">_</span>, body<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
  <span class="keyword5">Pipe.</span>to_list body
  <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> strings -<span class="keyword2">&gt;</span>
  <span class="keyword2">(</span>word, get_definition_from_json <span class="keyword2">(</span><span class="keyword5">String.</span>concat strings<span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search.ml">async/search.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10963792">
        To better understand what's going on, it's useful to look at the
        type for <code>Cohttp_async.Client.get</code>, which we
        can do in <span><strong>utop</strong></span>.
      </p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;cohttp.async&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword5">Cohttp_async.</span><span class="keyword5">Client.</span>get<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : ?interrupt:unit Deferred.t -&gt;
    ?headers:Cohttp.Header.t -&gt;
    Uri.t -&gt; (Cohttp.Response.t * string Pipe.Reader.t) Deferred.t
= &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 28) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10966464">
        The <code>get</code> call takes as a required argument a
        URI, and returns a deferred value containing a
        <code>Cohttp.Response.t</code> (which we ignore) and a
        pipe reader to which the body of the request will be written.
      </p><p id="idp10968448">
        In this case, the HTTP body probably isn't very large, so we
        call <code>Pipe.to_list</code> to collect the strings from
        the pipe as a single deferred list of strings. We then join
        those strings using <code>String.concat</code> and pass
        the result through our parsing function.
      </p><p id="idp10970528">
        Running a single search isn't that interesting from a
        concurrency perspective, so let's write code for dispatching
        multiple searches in parallel. First, we need code for
        formatting and printing out the search result.
      </p><div class="rwocode"><pre><code><span class="comments">(* Print out a word/definition pair *)</span>
<span class="keyword4">let</span> print_result <span class="keyword2">(</span>word,definition<span class="keyword2">)</span> <span class="keyword2">=</span>
  printf <span class="keyword7">&quot;%s\n%s\n\n%s\n\n&quot;</span>
    word
    <span class="keyword2">(</span><span class="keyword5">String.</span>init <span class="keyword2">(</span><span class="keyword5">String.</span>length word<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> '-'<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">match</span> definition <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword7">&quot;No definition found&quot;</span>
    <span class="keyword2">|</span> <span class="keyword6">Some </span>def -<span class="keyword2">&gt;</span>
      <span class="keyword5">String.</span>concat ~sep<span class="keyword2">:</span><span class="keyword7">&quot;\n&quot;</span>
        <span class="keyword2">(</span><span class="keyword5">Wrapper.</span>wrap <span class="keyword2">(</span><span class="keyword5">Wrapper.</span>make <span class="keyword8">70</span><span class="keyword2">)</span> def<span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search.ml">async/search.ml</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10971904">
        We use the <code>Wrapper</code> module from the
        <code>textwrap</code> package to do the line-wrapping. It
        may not be obvious that this routine is using Async, but it
        does: the version of <code>printf</code> that's called
        here is actually Async's specialized <code>printf</code>
        that goes through the Async scheduler rather than printing
        directly. The original definition of <code>printf</code>
        is shadowed by this new one when you open
        <code>Async.Std</code>. An important side effect of this
        is that if you write an Async program and forget to start the
        scheduler, calls like <code>printf</code> won't actually
        generate any output!
      </p><p id="idp10977824">
        The next function dispatches the searches in parallel, waits for
        the results, and then prints.
      </p><div class="rwocode"><pre><code><span class="comments">(* Run many searches in parallel, printing out the results after they're all
   done. *)</span>
<span class="keyword4">let</span> search_and_print words <span class="keyword2">=</span>
  <span class="keyword5">Deferred.</span>all <span class="keyword2">(</span><span class="keyword5">List.</span>map words ~f<span class="keyword2">:</span>get_definition<span class="keyword2">)</span>
  <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> results -<span class="keyword2">&gt;</span>
  <span class="keyword5">List.</span>iter results ~f<span class="keyword2">:</span>print_result</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search.ml">async/search.ml</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10979056">
        We used <code>List.map</code> to call
        <code>get_definition</code> on each word, and
        <code>Deferred.all</code> to wait for all the results.
        Here's the type of <code>Deferred.all</code>:
      </p><div class="rwocode"><pre><code># <span class="keyword5">Deferred.</span>all<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Deferred.t list -&gt; 'a list Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 29) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10983136">
        Note that the list returned by <code>Deferred.all</code>
        reflects the order of the deferreds passed to it. As such, the
        definitions will be printed out in the same order that the
        search words are passed in, no matter what orders the queries
        return in. We could rewrite this code to print out the results
        as they're received (and thus potentially out of order) as
        follows.
      </p><div class="rwocode"><pre><code><span class="comments">(* Run many searches in parallel, printing out the results as you go *)</span>
<span class="keyword4">let</span> search_and_print words <span class="keyword2">=</span>
  <span class="keyword5">Deferred.</span>all_unit <span class="keyword2">(</span><span class="keyword5">List.</span>map words ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> word -<span class="keyword2">&gt;</span>
    get_definition word <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> print_result<span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search_out_of_order.ml">async/search_out_of_order.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10985392">
        The difference is that we both dispatch the query and print out
        the result in the closure passed to <code>map</code>,
        rather than waiting for all of the results to get back and then
        printing them out together. We use
        <code>Deferred.all_unit</code>, which takes a list of
        <code>unit</code> deferreds and returns a single
        <code>unit</code> deferred that becomes determined when
        every deferred on the input list is determined. We can see the
        type of this function in <span><strong>utop</strong></span>.
      </p><div class="rwocode"><pre><code># <span class="keyword5">Deferred.</span>all_unit<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit Deferred.t list -&gt; unit Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 30) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10990480">
        Finally, we create a command line interface using
        <code>Command.async_basic</code>.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>async_basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Retrieve definitions from duckduckgo search engine&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span>sequence <span class="keyword2">(</span><span class="keyword7">&quot;word&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> words <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> search_and_print words<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search.ml">async/search.ml</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10992384">
        And that's all we need for a simple but usable definition
        searcher.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg cohttp.async,yojson,textwrap search.native
</div><div class="highlight"><span class="gp">$</span> ./search.native <span class="s2">&quot;Concurrent Programming&quot;</span> <span class="s2">&quot;OCaml&quot;</span>
</div><div class="rwocodeout">Concurrent Programming</div><div class="rwocodeout">----------------------</div><div class="rwocodeout"> </div><div class="rwocodeout">&quot;Concurrent computing is a form of computing in which programs are</div><div class="rwocodeout">designed as collections of interacting computational processes that</div><div class="rwocodeout">may be executed in parallel.&quot;</div><div class="rwocodeout"> </div><div class="rwocodeout">OCaml</div><div class="rwocodeout">-----</div><div class="rwocodeout"> </div><div class="rwocodeout">&quot;OCaml, originally known as Objective Caml, is the main implementation</div><div class="rwocodeout">of the Caml programming language, created by Xavier Leroy, Jérôme</div><div class="rwocodeout">Vouillon, Damien Doligez, Didier Rémy and others in 1996.&quot;</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/run_search.out">async/run_search.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section></section><section><h1 id="exception-handling">Exception handling</h1><p id="idp10994960">
      When programming with external resources, errors are everywhere:
      everything from a flaky server to a network outage to exhausting
      of local resources can lead to a runtime error. When programming
      in OCaml, some of these errors will show up explicitly in a
      function's return type, and some of them will show up as
      exceptions. We covered exception handling in OCaml in
      <a href="error-handling.html#exceptions">the section called “Exceptions”</a>, but as we'll see,
      exception handling in a concurrent program presents some new
      challenges.
    </p><p id="idp10996640">
      Let's get a better sense of how exceptions work in Async by
      creating an asynchronous computation that (sometimes) fails with
      an exception. The function <code>maybe_raise</code> below
      blocks for half a second, and then either throws an exception or
      returns unit, alternating between the two behaviors on subsequent
      calls.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> maybe_raise <span class="keyword2">=</span>
    <span class="keyword4">let</span> should_fail <span class="keyword2">=</span> ref false <span class="keyword4">in</span>
    <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword4">let</span> will_fail <span class="keyword2">=</span> <span class="keyword2">!</span>should_fail <span class="keyword4">in</span>
      should_fail <span class="keyword2">:</span><span class="keyword2">=</span> not will_fail<span class="keyword2">;</span>
      after <span class="keyword2">(</span><span class="keyword5">Time.</span><span class="keyword5">Span.</span>of_sec <span class="keyword8">0</span>.<span class="keyword8">5</span><span class="keyword2">)</span>
      <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword1">if</span> will_fail <span class="keyword1">then</span> <span class="keyword1">raise</span> <span class="keyword6">Exit </span><span class="keyword1">else</span> return <span class="keyword2">(</span><span class="keyword2">)</span>
 <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val maybe_raise : unit -&gt; unit Deferred.t = &lt;fun&gt;
</div># maybe_raise <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># maybe_raise <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception:
(lib/monitor.ml.Error_
 ((exn Exit) (backtrace (&quot;&quot;))
  (monitor
   (((name block_on_async) (here ()) (id 55) (has_seen_error true)
     (someone_is_listening true) (kill_index 0))
    ((name main) (here ()) (id 1) (has_seen_error false)
     (someone_is_listening false) (kill_index 0)))))).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 31) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10998768">
      In <span><strong>utop</strong></span>, the exception thrown by
      <code>maybe_raise ()</code> terminates the evaluation of
      just that expression, but in a standalone program, an uncaught
      exception would bring down the entire process.
    </p><p id="idp11000784">
      So, how could we capture and handle such an exception? You might
      try to do this using OCaml's built-in <code>try/with</code>
      statement, but as you can see below, that doesn't quite do the
      trick.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> handle_error <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
    <span class="keyword1">try</span>
      maybe_raise <span class="keyword2">(</span><span class="keyword2">)</span>
      <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;success&quot;</span>
    <span class="keyword1">with</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> return <span class="keyword7">&quot;failure&quot;</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val handle_error : unit -&gt; string Deferred.t = &lt;fun&gt;
</div># handle_error <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;success&quot;
</div># handle_error <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception:
(lib/monitor.ml.Error_
 ((exn Exit) (backtrace (&quot;&quot;))
  (monitor
   (((name block_on_async) (here ()) (id 59) (has_seen_error true)
     (someone_is_listening true) (kill_index 0))
    ((name main) (here ()) (id 1) (has_seen_error false)
     (someone_is_listening false) (kill_index 0)))))).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 32) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11002800">
      This didn't work because <code>try/with</code> only captures
      exceptions that are thrown in the code directly executed within
      it, while <code>maybe_raise</code> schedules an Async job to
      run in the future, and it's that job that throws an exception.
    </p><p id="idp11004832">
      We can capture this kind of asynchronous error use the
      <code>try_with</code> function provided by Async:
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> handle_error <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
    try_with <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> maybe_raise <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">function</span>
    <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword2">(</span><span class="keyword2">)</span>   -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;success&quot;</span>
    <span class="keyword2">|</span> <span class="keyword6">Error </span><span class="keyword8">_</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;failure&quot;</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val handle_error : unit -&gt; string Deferred.t = &lt;fun&gt;
</div># handle_error <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;success&quot;
</div># handle_error <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;failure&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 33) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11006752">
<code>try_with f</code> takes as its argument a
      deferred-returning thunk <code>f</code>, and returns a
      deferred that becomes determined either as <code>Ok</code>
      of whatever <code>f</code> returned, or
      <code>Error exn</code> if <code>f</code> threw an
      exception before its return value became determined.
    </p><section><h1 id="monitors">Monitors</h1><p id="idp11012640">
<code>try_with</code> is a great way of handling
        exceptions in Async, but it's not the whole story. All of
        Async's exception-handling mechanisms,
        <code>try_with</code> included, are built on top of
        Async's system of <span><em>monitors</em></span>, which are
        inspired by the error-handling mechanism in Erlang of the same
        name. Monitors are fairly low-level and are only occasionally
        used directly, but it's nonetheless worth understanding how they
        work.
      </p><p id="idp11015312">
        In Async, a monitor is a context that determines what to do when
        there is an unhandled exception. Every Async job runs within the
        context of some monitor, which, when the job is running, is
        referred to as the current monitor. When a new Async job is
        scheduled, say, using <code>bind</code> or
        <code>map</code>, it inherits the current monitor of the
        job that spawned it.
      </p><p id="idp11017504">
        Monitors are arranged in a tree—when a new monitor is created
        (say, using <code>Monitor.create</code>) it is a child of
        the current monitor. You can explicitly run jobs within a
        monitor using <code>within</code>, which takes a thunk
        that returns a non-deferred value, or
        <code>within'</code>, which takes a thunk that returns a
        deferred. Here's an example.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> blow_up <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
    <span class="keyword4">let</span> monitor <span class="keyword2">=</span> <span class="keyword5">Monitor.</span>create ~name<span class="keyword2">:</span><span class="keyword7">&quot;blow up monitor&quot;</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    within' ~monitor maybe_raise
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val blow_up : unit -&gt; unit Deferred.t = &lt;fun&gt;
</div># blow_up <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># blow_up <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception:
(lib/monitor.ml.Error_
 ((exn Exit) (backtrace (&quot;&quot;))
  (monitor
   (((name &quot;blow up monitor&quot;) (here ()) (id 71) (has_seen_error true)
     (someone_is_listening false) (kill_index 0))
    ((name block_on_async) (here ()) (id 70) (has_seen_error false)
     (someone_is_listening true) (kill_index 0))
    ((name main) (here ()) (id 1) (has_seen_error false)
     (someone_is_listening false) (kill_index 0)))))).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 34) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11021200">
        In addition to the ordinary stack-trace, the exception displays
        the trace of monitors through which the exception traveled,
        starting at the one we created, called &quot;blow up
        monitor&quot;. The other monitors you see come from
        <span><strong>utop</strong></span>'s special handling of deferreds.
      </p><p id="idp11022736">
        Monitors can do more than just augment the error-trace of an
        exception. You can also use a monitor to explicitly handle
        errors delivered to that monitor. The
        <code>Monitor.errors</code> call is a particularly
        important one. It detaches the monitor from its parent, handing
        back the stream of errors that would otherwise have been
        delivered to the parent monitor. This allows one to do custom
        handling of errors, which may include re-raising errors to the
        parent. Here is a very simple example of a function that
        captures and ignores errors in the processes it spawns.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> swallow_error <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
    <span class="keyword4">let</span> monitor <span class="keyword2">=</span> <span class="keyword5">Monitor.</span>create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword5">Stream.</span>iter <span class="keyword2">(</span><span class="keyword5">Monitor.</span>errors monitor<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> _exn -<span class="keyword2">&gt;</span>
      printf <span class="keyword7">&quot;an error happened\n&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span>
    within' ~monitor <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      after <span class="keyword2">(</span><span class="keyword5">Time.</span><span class="keyword5">Span.</span>of_sec <span class="keyword8">0</span>.<span class="keyword8">5</span><span class="keyword2">)</span> <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> failwith <span class="keyword7">&quot;Kaboom!&quot;</span><span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val swallow_error : unit -&gt; 'a Deferred.t = &lt;fun&gt;</div># swallow_error <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">an error happened
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main-35.rawscript">async/main-35.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11025184">
        The message &quot;an error happened&quot; is printed out, but
        the deferred returned by <code>swallow_error</code> is
        never determined. This makes sense, since the calculation never
        actually completes, so there's no value to return. You can break
        out of this in <span><strong>utop</strong></span> by hitting
        <span><strong>Control</strong></span>+<span><strong>C</strong></span>.
      </p><p id="idp11029024">
        Here's an example of a monitor which passes some exceptions
        through to the parent, and handles others. Exceptions are sent
        to the parent using <code>Monitor.send_exn</code>, with
        <code>Monitor.current</code> being called to find the
        current monitor, which is the parent of the newly created
        monitor.
      </p><div class="rwocode"><pre><code># <span class="keyword1">exception</span> Ignore_me<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">exception Ignore_me
</div># <span class="keyword4">let</span> swallow_some_errors exn_to_raise <span class="keyword2">=</span>
    <span class="keyword4">let</span> child_monitor  <span class="keyword2">=</span> <span class="keyword5">Monitor.</span>create  <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword4">let</span> parent_monitor <span class="keyword2">=</span> <span class="keyword5">Monitor.</span>current <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword5">Stream.</span>iter <span class="keyword2">(</span><span class="keyword5">Monitor.</span>errors child_monitor<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> error -<span class="keyword2">&gt;</span>
      <span class="keyword1">match</span> <span class="keyword5">Monitor.</span>extract_exn error <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">Ignore_me </span>-<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;ignoring exn\n&quot;</span>
      <span class="keyword2">|</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Monitor.</span>send_exn parent_monitor error<span class="keyword2">)</span><span class="keyword2">;</span>
    within' ~monitor<span class="keyword2">:</span>child_monitor <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       after <span class="keyword2">(</span><span class="keyword5">Time.</span><span class="keyword5">Span.</span>of_sec <span class="keyword8">0</span>.<span class="keyword8">5</span><span class="keyword2">)</span>
       <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword1">raise</span> exn_to_raise<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val swallow_some_errors : exn -&gt; 'a Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 36) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11031856">
        Note that we use <code>Monitor.extract_exn</code> to grab
        the underlying exception that was thrown. Async wraps exceptions
        it catches with extra information, including the monitor trace,
        so you need to grab the underlying exception to match on it.
      </p><p id="idp11033216">
        If we pass in an exception other than
        <code>Ignore_me</code>, like, say, the built-in exception
        <code>Not_found</code>, then the exception will be passed
        to the parent monitor and delivered as usual.
      </p><div class="rwocode"><pre><code># swallow_some_errors Not_found<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception:
(lib/monitor.ml.Error_
 ((exn Not_found) (backtrace (&quot;&quot;))
  (monitor
   (((name (id 75)) (here ()) (id 75) (has_seen_error true)
     (someone_is_listening true) (kill_index 0))
    ((name block_on_async) (here ()) (id 74) (has_seen_error true)
     (someone_is_listening true) (kill_index 0))
    ((name main) (here ()) (id 1) (has_seen_error false)
     (someone_is_listening false) (kill_index 0)))))).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 37) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11035936">
        If instead we use <code>Ignore_me</code>, the exception
        will be ignored, and we again see that the deferred never
        returns, but the exception was caught and ignored.
      </p><div class="rwocode"><pre><code># swallow_some_errors Ignore_me<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">ignoring exn</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main-38.rawscript">async/main-38.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11037936">
        In practice, you should rarely use monitors directly, instead
        using functions like <code>try_with</code> and
        <code>Monitor.protect</code> that are built on top of
        monitors. One example of a library that uses monitors directly
        is <code>Tcp.Server.create</code>, which tracks both
        exceptions thrown by the logic that handles the network
        connection and by the callback for responding to an individual
        request, in either case responding to an exception by closing
        the connection. It is for building this kind of custom error
        handling that monitors can be helpful.
      </p></section><section><h1 id="example-handling-exceptions-with-duckduckgo">Example: Handling exceptions with DuckDuckGo</h1><p id="idp11042336">
        Let's now go back and improve the exception handling of our
        DuckDuckGo client. In particular, we'll change it so that any
        individual queries that fail are reported as such, without
        preventing other queries from succeeding.
      </p><p id="idp11042992">
        The search code as it is fails rarely, so let's make a change
        that allows us to trigger failures more predictably. We'll do
        this by making it possible to distribute the requests over
        multiple servers. Then, we'll handle the errors that occur when
        one of those servers is misspecified.
      </p><p id="idp11043728">
        First we'll need to change <code>query_uri</code> to take
        an argument specifying the server to connect to, as follows.
      </p><div class="rwocode"><pre><code><span class="comments">(* Generate a DuckDuckGo search URI from a query string *)</span>
<span class="keyword4">let</span> query_uri ~server query <span class="keyword2">=</span>
  <span class="keyword4">let</span> base_uri <span class="keyword2">=</span>
    <span class="keyword5">Uri.</span>of_string <span class="keyword2">(</span><span class="keyword5">String.</span>concat <span class="keyword2">[</span><span class="keyword7">&quot;http://&quot;</span><span class="keyword2">;</span>server<span class="keyword2">;</span><span class="keyword7">&quot;/?format=json&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span>
  <span class="keyword4">in</span>
  <span class="keyword5">Uri.</span>add_query_param base_uri <span class="keyword2">(</span><span class="keyword7">&quot;q&quot;</span>, <span class="keyword2">[</span>query<span class="keyword2">]</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search_with_configurable_server.ml">async/search_with_configurable_server.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11045680">
        and then making the appropriate changes to get the list of
        servers on the command-line, and to distribute the search
        queries round-robin over the list of servers. Now, let's see
        what happens if we rebuild the application and run it giving it
        a list of servers, some of which won't respond to the query.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg cohttp.async,yojson,textwrap <span class="se">\</span>
</div><div class="rwocodeout">    search_with_configurable_server.native</div><div class="highlight"><span class="gp">$</span> ./search_with_configurable_server.native <span class="se">\</span>
</div><div class="rwocodeout">    -servers localhost,api.duckduckgo.com \</div><div class="rwocodeout">    &quot;Concurrent Programming&quot; OCaml</div><div class="rwocodeout">(&quot;unhandled exception&quot;</div><div class="rwocodeout"> ((lib/monitor.ml.Error_</div><div class="rwocodeout">   ((exn (Unix.Unix_error &quot;Connection refused&quot; connect 127.0.0.1:80))</div><div class="rwocodeout">    (backtrace</div><div class="rwocodeout">     (&quot;Raised by primitive operation at file \&quot;lib/unix_syscalls.ml\&quot;, line 797, characters 12-69&quot;</div><div class="rwocodeout">      &quot;Called from file \&quot;lib/deferred.ml\&quot;, line 20, characters 62-65&quot;</div><div class="rwocodeout">      &quot;Called from file \&quot;lib/scheduler.ml\&quot;, line 125, characters 6-17&quot;</div><div class="rwocodeout">      &quot;Called from file \&quot;lib/jobs.ml\&quot;, line 65, characters 8-13&quot; &quot;&quot;))</div><div class="rwocodeout">    (monitor</div><div class="rwocodeout">     (((name Tcp.close_sock_on_error) (here ()) (id 5) (has_seen_error true)</div><div class="rwocodeout">       (someone_is_listening true) (kill_index 0))</div><div class="rwocodeout">      ((name main) (here ()) (id 1) (has_seen_error true)</div><div class="rwocodeout">       (someone_is_listening false) (kill_index 0))))))</div><div class="rwocodeout">  (Pid 15971)))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/run_search_with_configurable_server.out">async/run_search_with_configurable_server.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11047168">
        As you can see, we got a &quot;Connection refused&quot; failure
        which ends the entire program, even though one of the two
        queries would have gone through successfully. We can handle the
        failures of individual connections separately by using the
        <code>try_with</code> function within each call to
        <code>get_definition</code>, as follows.
      </p><div class="rwocode"><pre><code><span class="comments">(* Execute the DuckDuckGo search *)</span>
<span class="keyword4">let</span> get_definition ~server word <span class="keyword2">=</span>
  try_with <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    <span class="keyword5">Cohttp_async.</span><span class="keyword5">Client.</span>get <span class="keyword2">(</span>query_uri ~server word<span class="keyword2">)</span>
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span>  <span class="keyword2">(</span><span class="keyword8">_</span>, body<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    <span class="keyword5">Pipe.</span>to_list body
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> strings -<span class="keyword2">&gt;</span>
    <span class="keyword2">(</span>word, get_definition_from_json <span class="keyword2">(</span><span class="keyword5">String.</span>concat strings<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">function</span>
  <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword2">(</span>word,result<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>word, <span class="keyword6">Ok </span>result<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">Error </span><span class="keyword8">_</span>          -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>word, <span class="keyword6">Error </span><span class="keyword7">&quot;Unexpected failure&quot;</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search_with_error_handling.ml">async/search_with_error_handling.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11050352">
        Here, we first use <code>try_with</code> to capture the
        exception, and then use map (the <code>&gt;&gt;|</code>
        operator) to convert the error into the form we want: a pair
        whose first element is the word being searched for, and the
        second element is the (possibly erroneous) result.
      </p><p id="idp11052464">
        Now we just need to change the code for
        <code>print_result</code> so that it can handle the new
        type.
      </p><div class="rwocode"><pre><code><span class="comments">(* Print out a word/definition pair *)</span>
<span class="keyword4">let</span> print_result <span class="keyword2">(</span>word,definition<span class="keyword2">)</span> <span class="keyword2">=</span>
  printf <span class="keyword7">&quot;%s\n%s\n\n%s\n\n&quot;</span>
    word
    <span class="keyword2">(</span><span class="keyword5">String.</span>init <span class="keyword2">(</span><span class="keyword5">String.</span>length word<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> '-'<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">match</span> definition <span class="keyword1">with</span>
     <span class="keyword2">|</span> <span class="keyword6">Error </span>s -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;DuckDuckGo query failed: &quot;</span> <span class="keyword2">^</span> s
     <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword7">&quot;No definition found&quot;</span>
     <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword2">(</span><span class="keyword6">Some </span>def<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword5">String.</span>concat ~sep<span class="keyword2">:</span><span class="keyword7">&quot;\n&quot;</span>
         <span class="keyword2">(</span><span class="keyword5">Wrapper.</span>wrap <span class="keyword2">(</span><span class="keyword5">Wrapper.</span>make <span class="keyword8">70</span><span class="keyword2">)</span> def<span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search_with_error_handling.ml">async/search_with_error_handling.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11054416">
        Now, if we run that same query, we'll get individualized
        handling of the connection failures:
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg cohttp.async,yojson,textwrap <span class="se">\</span>
</div><div class="rwocodeout">    search_with_error_handling.native</div><div class="highlight"><span class="gp">$</span> ./search_with_error_handling.native <span class="se">\</span>
</div><div class="rwocodeout">    -servers localhost,api.duckduckgo.com \</div><div class="rwocodeout">    &quot;Concurrent Programming&quot; OCaml</div><div class="rwocodeout">Concurrent Programming</div><div class="rwocodeout">----------------------</div><div class="rwocodeout"> </div><div class="rwocodeout">DuckDuckGo query failed: Unexpected failure</div><div class="rwocodeout"> </div><div class="rwocodeout">OCaml</div><div class="rwocodeout">-----</div><div class="rwocodeout"> </div><div class="rwocodeout">&quot;OCaml, originally known as Objective Caml, is the main implementation</div><div class="rwocodeout">of the Caml programming language, created by Xavier Leroy, Jérôme</div><div class="rwocodeout">Vouillon, Damien Doligez, Didier Rémy and others in 1996.&quot;</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/run_search_with_error_handling.out">async/run_search_with_error_handling.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11055664">
        Now, only the query that went to <code>localhost</code>
        failed.
      </p><p id="idp11056832">
        Note that in this code, we're relying on the fact that
        <code>Cohttp_async.Client.get</code> will clean up after
        itself after an exception, in particular by closing its file
        descriptors. If you need to implement such functionality
        directly, you may want to use the
        <code>Monitor.protect</code> call, which is analogous to
        the <code>protect</code> call described in
        <a href="error-handling.html#cleaning-up-in-the-presence-of-exceptions">the section called “Cleaning up in the presence of exceptions”</a>.
      </p></section></section><section><h1 id="timeouts-cancellation-and-choices">Timeouts, cancellation and choices</h1><p id="idp11061968">
      In a concurrent program, one often needs to combine results from
      multiple distinct concurrent sub-computations going on in the same
      program. We already saw this in our DuckDuckGo example, where we
      used <code>Deferred.all</code> and
      <code>Deferred.all_unit</code> to wait for a list of
      deferreds to become determined. Another useful primitive is
      <code>Deferred.both</code>, which lets you wait until two
      deferreds of different types have returned, returning both values
      as a tuple. Here, we use the function <code>sec</code>,
      which is shorthand for creating a time-span equal to a given
      number of seconds.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> string_and_float <span class="keyword2">=</span> <span class="keyword5">Deferred.</span>both
   <span class="keyword2">(</span>after <span class="keyword2">(</span>sec <span class="keyword8">0</span>.<span class="keyword8">5</span><span class="keyword2">)</span>  <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;A&quot;</span><span class="keyword2">)</span>
   <span class="keyword2">(</span>after <span class="keyword2">(</span>sec <span class="keyword8">0</span>.<span class="keyword8">25</span><span class="keyword2">)</span> <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword8">32</span>.<span class="keyword8">33</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val string_and_float : (string * float) Deferred.t = &lt;abstr&gt;
</div># string_and_float<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string * float = (&quot;A&quot;, 32.33)
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 39) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11066496">
      Sometimes, however, we want to wait only for the first of multiple
      events to occur. This happens particularly when dealing with
      timeouts. In that case, we can use the call
      <code>Deferred.any</code>, which, given a list of deferreds,
      returns a single deferred that will become determined once any of
      the values on the list is determined.
    </p><div class="rwocode"><pre><code># <span class="keyword5">Deferred.</span>any <span class="keyword2">[</span> <span class="keyword2">(</span>after <span class="keyword2">(</span>sec <span class="keyword8">0</span>.<span class="keyword8">5</span><span class="keyword2">)</span> <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;half a second&quot;</span><span class="keyword2">)</span>
               <span class="keyword2">;</span> <span class="keyword2">(</span>after <span class="keyword2">(</span>sec <span class="keyword8">10</span>.<span class="keyword2">)</span> <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;ten seconds&quot;</span><span class="keyword2">)</span> <span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;half a second&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 40) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11068672">
      Let's use this to add timeouts to our DuckDuckGo searches. The
      code below is a wrapper for <code>get_definition</code> that
      takes a timeout (in the form of a <code>Time.Span.t</code>),
      and returns either the definition, or, if that takes too long, an
      error.
    </p><div class="rwocode"><pre><code><span class="keyword4">let</span> get_definition_with_timeout ~server ~timeout word <span class="keyword2">=</span>
  <span class="keyword5">Deferred.</span>any
    <span class="keyword2">[</span> <span class="keyword2">(</span>after timeout <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>word,<span class="keyword6">Error </span><span class="keyword7">&quot;Timed out&quot;</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">;</span> <span class="keyword2">(</span>get_definition ~server word
       <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span>word,result<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword4">let</span> result' <span class="keyword2">=</span> <span class="keyword1">match</span> result <span class="keyword1">with</span>
         <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword8">_</span> <span class="keyword1">as</span> x -<span class="keyword2">&gt;</span> x
         <span class="keyword2">|</span> <span class="keyword6">Error </span><span class="keyword8">_</span> -<span class="keyword2">&gt;</span> <span class="keyword6">Error </span><span class="keyword7">&quot;Unexpected failure&quot;</span>
       <span class="keyword4">in</span>
       <span class="keyword2">(</span>word,result'<span class="keyword2">)</span>
      <span class="keyword2">)</span>
    <span class="keyword2">]</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search_with_timeout.ml">async/search_with_timeout.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11071472">
      We use <code>&gt;&gt;|</code> above to transform the
      deferred values we're waiting for so that
      <code>Deferred.any</code> can choose between values of the
      same type.
    </p><p id="idp11073424">
      A problem with this code is that the HTTP query kicked off by
      <code>get_definition</code> is not actually shut down when
      the timeout fires. As such,
      <code>get_definition_with_timeout</code> essentially leaks
      an open connection. Happily, Cohttp does provide a way of shutting
      down a client. You can pass a deferred under the label
      <code>interrupt</code> to
      <code>Cohttp_async.Client.get</code>. Once
      <code>interrupt</code> is determined, the client connection
      will terminated and the corresponding connections closed.
    </p><p id="idp11077824">
      The following code shows how you can change
      <code>get_definition</code> and
      <code>get_definition_with_timeout</code> to cancel the
      <code>get</code> call if the timeout expires.
    </p><div class="rwocode"><pre><code><span class="comments">(* Execute the DuckDuckGo search *)</span>
<span class="keyword4">let</span> get_definition ~server ~interrupt word <span class="keyword2">=</span>
  try_with <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    <span class="keyword5">Cohttp_async.</span><span class="keyword5">Client.</span>get ~interrupt <span class="keyword2">(</span>query_uri ~server word<span class="keyword2">)</span>
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">=</span> <span class="keyword1">fun</span>  <span class="keyword2">(</span><span class="keyword8">_</span>, body<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    <span class="keyword5">Pipe.</span>to_list body
    <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> strings -<span class="keyword2">&gt;</span>
    <span class="keyword2">(</span>word, get_definition_from_json <span class="keyword2">(</span><span class="keyword5">String.</span>concat strings<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">function</span>
  <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword2">(</span>word,result<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>word, <span class="keyword6">Ok </span>result<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">Error </span>exn        -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>word, <span class="keyword6">Error </span>exn<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search_with_timeout_no_leak_simple.ml">async/search_with_timeout_no_leak_simple.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11081200">
      Next, we'll modify <code>get_definition_with_timeout</code>
      to create a deferred to pass in to
      <code>get_definition</code> which will become determined
      when our timeout expires.
    </p><div class="rwocode"><pre><code><span class="keyword4">let</span> get_definition_with_timeout ~server ~timeout word <span class="keyword2">=</span>
  get_definition ~server ~interrupt<span class="keyword2">:</span><span class="keyword2">(</span>after timeout<span class="keyword2">)</span> word
  <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span>word,result<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
  <span class="keyword4">let</span> result' <span class="keyword2">=</span> <span class="keyword1">match</span> result <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword8">_</span> <span class="keyword1">as</span> x -<span class="keyword2">&gt;</span> x
    <span class="keyword2">|</span> <span class="keyword6">Error </span><span class="keyword8">_</span> -<span class="keyword2">&gt;</span> <span class="keyword6">Error </span><span class="keyword7">&quot;Unexpected failure&quot;</span>
  <span class="keyword4">in</span>
  <span class="keyword2">(</span>word,result'<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search_with_timeout_no_leak_simple.ml">async/search_with_timeout_no_leak_simple.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11083920">
      This will work, and will cause the connection to shutdown cleanly
      when we time out; but our code no longer explicitly knows whether
      or not the timeout has kicked in. In particular, the error message
      on a timeout will now be
      <code>&quot;Unexpected failure&quot;</code> rather than
      <code>&quot;Timed out&quot;</code>, which it was in our
      previous implementation.
    </p><p id="idp11086080">
      We can get more precise handling of timeouts using Async's
      <code>choose</code> function. <code>choose</code> lets
      you pick between a collection of different deferreds, reacting to
      exactly one of them. Each deferred is paired, using the function
      <code>choice</code>, with a function that is called if and
      only if that is deferred is chosen. Here's the type signature of
      <code>choice</code> and <code>choose</code>:
    </p><div class="rwocode"><pre><code># choice<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Deferred.t -&gt; ('a -&gt; 'b) -&gt; 'b Deferred.choice = &lt;fun&gt;
</div># choose<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Deferred.choice list -&gt; 'a Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 41) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11091120">
      Note that there's no guarantee that the winning deferred will be
      the one that becomes determined first. But
      <code>choose</code> does guarantee that only one
      <code>choice</code> will be chosen, and only the chosen
      <code>choice</code> will execute the attached function.
    </p><p id="idp11093888">
      In the following, we use <code>choose</code> to ensure that
      the <code>interrupt</code> deferred becomes determined if
      and only if the timeout-deferred is chosen. Here's the code.
    </p><div class="rwocode"><pre><code><span class="keyword4">let</span> get_definition_with_timeout ~server ~timeout word <span class="keyword2">=</span>
  <span class="keyword4">let</span> interrupt <span class="keyword2">=</span> <span class="keyword5">Ivar.</span>create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  choose
    <span class="keyword2">[</span> choice <span class="keyword2">(</span>after timeout<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword5">Ivar.</span>fill interrupt <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span>
       <span class="keyword2">(</span>word,<span class="keyword6">Error </span><span class="keyword7">&quot;Timed out&quot;</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">;</span> choice <span class="keyword2">(</span>get_definition ~server ~interrupt<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword5">Ivar.</span>read interrupt<span class="keyword2">)</span> word<span class="keyword2">)</span>
        <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>word,result<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
           <span class="keyword4">let</span> result' <span class="keyword2">=</span> <span class="keyword1">match</span> result <span class="keyword1">with</span>
             <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword8">_</span> <span class="keyword1">as</span> x -<span class="keyword2">&gt;</span> x
             <span class="keyword2">|</span> <span class="keyword6">Error </span><span class="keyword8">_</span> -<span class="keyword2">&gt;</span> <span class="keyword6">Error </span><span class="keyword7">&quot;Unexpected failure&quot;</span>
           <span class="keyword4">in</span>
           <span class="keyword2">(</span>word,result'<span class="keyword2">)</span>
        <span class="keyword2">)</span>
    <span class="keyword2">]</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/search_with_timeout_no_leak.ml">async/search_with_timeout_no_leak.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11096592">
      Now, if we run this with a suitably small timeout, we'll see that
      one query succeeds and the other fails reporting a timeout.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg cohttp.async,yojson,textwrap <span class="se">\</span>
</div><div class="rwocodeout">     search_with_timeout_no_leak.native</div><div class="highlight"><span class="gp">$</span> ./search_with_timeout_no_leak.native <span class="se">\</span>
</div><div class="rwocodeout">     &quot;concurrent programming&quot; ocaml -timeout 0.2s</div><div class="rwocodeout">concurrent programming</div><div class="rwocodeout">----------------------</div><div class="rwocodeout"> </div><div class="rwocodeout">DuckDuckGo query failed: Timed out</div><div class="rwocodeout"> </div><div class="rwocodeout">ocaml</div><div class="rwocodeout">-----</div><div class="rwocodeout"> </div><div class="rwocodeout">&quot;OCaml or Objective Caml, is the main implementation of the Caml</div><div class="rwocodeout">programming language, created by Xavier Leroy, Jérôme Vouillon,</div><div class="rwocodeout">Damien Doligez, Didier Rémy and others in 1996.&quot;</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/run_search_with_timeout_no_leak.out">async/run_search_with_timeout_no_leak.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="working-with-system-threads">Working with system threads</h1><p id="idp11099136">
      Although we haven't worked with them yet, OCaml does have built-in
      support for true system threads, <span><em>i.e.</em></span>,
      kernel-level threads whose interleaving is controlled by the
      operating system. We discussed in the beginning of the chapter why
      Async is generally a better choice than system threads, but even
      if you mostly use Async, OCaml's system threads are sometimes
      necessary, and it's worth understanding them.
    </p><p id="idp11100416">
      The most surprising aspect of OCaml's system threads is that they
      don't afford you any access to physical parallelism. That's
      because OCaml's runtime has a single runtime lock which at most
      one thread can be holding at a time.
    </p><p id="idp11101072">
      Given that threads don't provide physical parallelism, why are
      they useful at all?
    </p><p id="idp11101568">
      The most common reason for using system threads is that there are
      some operating system calls that have no non-blocking alternative,
      which means that you can't run them directly in a system like
      Async without blocking your entire program. For this reason, Async
      maintains a thread pool for running such calls. Most of the time,
      as a user of Async you don't need to think about this, but it is
      happening under the covers.
    </p><p id="idp11102432">
      Another reason to have multiple threads is to deal with non-OCaml
      libraries that have their own event loop or for another reason
      need their own threads. In that case, it's sometimes useful to run
      some OCaml code on the foreign thread as part of the communication
      to your main program. OCaml's foreign function interface is
      discussed in more detail in
      <a href="foreign-function-interface.html">Chapter 19, <i>Foreign Function Interface</i></a>.
    </p><p id="idp11103984">
      Another occasional use for system threads is to better
      interoperate with compute-intensive OCaml code. In Async, if you
      have a long-running computation that never calls
      <code>bind</code> or <code>map</code>, then that
      computation will block out the async runtime until it completes.
    </p><p id="idp11106048">
      One way of dealing with this is to explicitly break up the
      calculation into smaller pieces that are separated by binds. But
      sometimes this explicit yielding is impractical, since it may
      involve intrusive changes to an existing codebase. Another
      solution is to run the code in question in a separate thread.
      Async's <code>In_thread</code> module provides multiple
      facilities for doing just this, <code>In_thread.run</code>
      being the simplest. We can simply write
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> def <span class="keyword2">=</span> <span class="keyword5">In_thread.</span>run <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">List.</span>range <span class="keyword8">1</span> <span class="keyword8">10</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val def : int list Deferred.t = &lt;abstr&gt;
</div># def<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 42) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11109040">
      to cause <code>List.range 1 10</code> to be run on one of
      Async's worker threads. When the computation is complete, the
      result is placed in the deferred, where it can be used in the
      ordinary way from Async.
    </p><p id="idp11110352">
      Interoperability between Async and system threads can be quite
      tricky. Consider the following function for testing how responsive
      Async is. The function takes a deferred-returning thunk, and it
      first runs that thunk, and then uses
      <code>Clock.every</code> to wake up every 100 milliseconds
      and print out a timestamp, until the returned deferred becomes
      determined, at which point it prints out one last timestamp.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> log_delays thunk <span class="keyword2">=</span>
    <span class="keyword4">let</span> start <span class="keyword2">=</span> <span class="keyword5">Time.</span>now <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword4">let</span> print_time <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
      <span class="keyword4">let</span> diff <span class="keyword2">=</span> <span class="keyword5">Time.</span>diff <span class="keyword2">(</span><span class="keyword5">Time.</span>now <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> start <span class="keyword4">in</span>
      printf <span class="keyword7">&quot;%s, &quot;</span> <span class="keyword2">(</span><span class="keyword5">Time.</span><span class="keyword5">Span.</span>to_string diff<span class="keyword2">)</span>
    <span class="keyword4">in</span>
    <span class="keyword4">let</span> d <span class="keyword2">=</span> thunk <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword5">Clock.</span>every <span class="keyword2">(</span>sec <span class="keyword8">0</span>.<span class="keyword8">1</span><span class="keyword2">)</span> ~stop<span class="keyword2">:</span>d print_time<span class="keyword2">;</span>
    d <span class="keyword1">&gt;&gt;</span><span class="keyword2">|</span> <span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> print_time <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span> printf <span class="keyword7">&quot;\n&quot;</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val log_delays : (unit -&gt; unit Deferred.t) -&gt; unit Deferred.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main.topscript">async/main.topscript</a> , continued (part 43) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11112608">
      If we feed this function a simple timeout deferred, it works as
      you might expect, waking up roughly every 100 milliseconds.
    </p><div class="rwocode"><pre><code># log_delays <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> after <span class="keyword2">(</span>sec <span class="keyword8">0</span>.<span class="keyword8">5</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">0.154972ms, 102.126ms, 203.658ms, 305.73ms, 407.903ms, 501.563ms,
- : unit = ()</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main-44.rawscript">async/main-44.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11113872">
      Now see what happens if, instead of waiting on a clock event, we
      wait for a busy-loop to finish running.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> busy_loop n <span class="keyword2">=</span>
    <span class="keyword4">let</span> x <span class="keyword2">=</span> ref <span class="keyword6">None </span><span class="keyword4">in</span>
    <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword1">to</span> <span class="keyword8">100_000_000</span> <span class="keyword1">do</span> x <span class="keyword2">:</span><span class="keyword2">=</span> <span class="keyword6">Some </span>i <span class="keyword1">done</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val busy_loop : 'a -&gt; unit = &lt;fun&gt;</div># log_delays <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> return <span class="keyword2">(</span>busy_loop <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">19.2185s,
- : unit = ()</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main-45.rawscript">async/main-45.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11115120">
      As you can see, instead of waking up ten times a second,
      <code>log_delays</code> is blocked out entirely while
      <code>busy_loop</code> churns away.
    </p><p id="idp11116992">
      If, on the other hand, we use <code>In_thread.run</code> to
      offload this to a different system thread, the behavior will be
      different.
    </p><div class="rwocode"><pre><code># log_delays <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">In_thread.</span>run busy_loop<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">0.332117ms, 16.6319s, 18.8722s,
- : unit = ()</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main-46.rawscript">async/main-46.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11118944">
      Now <code>log_delays</code> does get a chance to run, but
      not nearly as often as every 100 milliseconds. The reason for this
      is that now that we're using system threads, we are at the mercy
      of the operating system to decide when each thread gets scheduled.
      The behavior of threads is very much dependent on the operating
      system and how it is configured.
    </p><p id="idp11120432">
      Another tricky aspect of dealing with OCaml threads has to do with
      allocation. When compiling to native-code, OCaml's threads only
      get a chance to give up the runtime lock when they interact with
      the allocator, so if there's a piece of code that doesn't allocate
      at all, then it will never allow another OCaml thread to run.
      Byte-code doesn't have this behavior, so if we run a
      non-allocating loop in byte-code, our timer process will get to
      run.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> noalloc_busy_loop <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
    <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">to</span> <span class="keyword8">100_000_000</span> <span class="keyword1">do</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword1">done</span>
<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val noalloc_busy_loop : unit -&gt; unit = &lt;fun&gt;</div># log_delays <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">In_thread.</span>run noalloc_busy_loop<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">0.169039ms, 4.58345s, 4.77866s, 4.87957s, 12.4723s, 15.0134s,
- : unit = ()</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/main-47.rawscript">async/main-47.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11122048">
      But if we compile this to a native-code executable, then the
      non-allocating busy-loop will block anything else from running.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg async native_code_log_delays.native
</div><div class="highlight"><span class="gp">$</span> ./native_code_log_delays.native
</div><div class="rwocodeout">15.5686s, </div><div class="highlight"><span class="gp">$</span> 
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/async/run_native_code_log_delays.out">async/run_native_code_log_delays.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11123328">
      The takeaway from these examples is that predicting thread
      interleavings is a subtle business. Staying within the bounds of
      Async has its limitations, but it leads to more predictable
      behavior.
    </p><section><h1 id="thread-safety-and-locking">Thread-safety and locking</h1><p id="idp11125088">
        Once you start working with system threads, you'll need to be
        careful about mutable data structures. Most mutable OCaml data
        structures do not have well-defined semantics when accessed
        concurrently by multiple threads. The issues you can run into
        range from runtime exceptions to corrupted data structures to,
        in some rare cases, segfaults. That means you should always use
        mutexes when sharing mutable data between different systems
        threads. Even data structures that seem like they should be safe
        but are mutable under the covers, like lazy values, can have
        undefined behavior when accessed from multiple threads.
      </p><p id="idp11126192">
        There are two commonly available mutex packages for OCaml: the
        <code>Mutex</code> module that's part of the standard
        library, which is just a wrapper over OS-level mutexes, and
        <code>Nano_mutex</code>, a more efficient alternative that
        takes advantage of some of the locking done by the OCaml runtime
        to avoid needing to create an OS-level mutex much of the time.
        As a result, creating a <code>Nano_mutex.t</code> is 20x
        faster than creating a <code>Mutex.t</code>, and acquiring
        the mutex is about 40% faster.
      </p><p id="idp11129904">
        Overall, combining Async and threads is quite tricky, but it can
        be done safely if you follow the following hold:
      </p><ul><li><p id="idp11130960">
            There is no shared mutable state between the various threads
            involved.
          </p></li><li><p id="idp11131856">
            The computations executed by
            <code>In_thread.run</code> do not make any calls to
            the async library.
          </p></li></ul><p id="idp11133328">
        It is possible to safely use threads in ways that violate these
        constraints. In particular, foreign threads can acquire the
        Async lock using calls from the <code>Thread_safe</code>
        module in Async, and thereby run Async computations safely. This
        is a very flexible way of connecting threads to the Async world,
        but it's a complex use-case that is beyond the scope of this
        chapter.
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="data-serialization-with-s-expressions.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="pt03.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>