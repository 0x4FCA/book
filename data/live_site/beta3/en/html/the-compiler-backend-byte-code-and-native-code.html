<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 23. The Compiler Backend: Byte-code and Native-code / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta3',
                        page: 'the\u002Dcompiler\u002Dbackend\u002Dbyte\u002Dcode\u002Dand\u002Dnative\u002Dcode.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html">19. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="memory-representation-of-values.html">20. Memory Representation of Values</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">21. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-frontend-parsing-and-type-checking.html">22. The Compiler Frontend: Parsing and Type Checking</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-backend-byte-code-and-native-code.html" class="here">23. The Compiler Backend: Byte-code and Native-code</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 23. The Compiler Backend: Byte-code and Native-code</h1>
                
                

    <p id="idp12197040">
    Once OCaml has passed the type checking stage, it can stop emitting
    syntax and type errors and begin the process of compiling the
    well-formed modules into executable code.
  </p><p id="idp12197632">
    In this chapter, we'll cover the following topics:
  </p><ul><li><p id="idp12198608">
        the untyped intermediate lambda code where pattern matching is
        optimized.
      </p></li><li><p id="idp12199488">
        the bytecode <span><strong>ocamlc</strong></span> compiler and
        <span><strong>ocamlrun</strong></span> interpreter.
      </p></li><li><p id="idp12201728">
        the native code <span><strong>ocamlopt</strong></span> code generator, and
        debugging and profiling native code.
      </p></li></ul><section><h1 id="the-untyped-lambda-form">The untyped lambda form</h1><p id="idp12204304">
      The first code generation phase eliminates all the static type
      information into a simpler intermediate <span><em>lambda
      form</em></span>. The lambda form discards higher-level constructs
      such as modules and objects and replaces them with simpler values
      such as records and function pointers. Pattern matches are also
      analyzed and compiled into highly optimized automata.
    </p><p id="idp12205504">
      The lambda form is the key stage that discards the OCaml type
      information and maps the source code to the runtime memory model
      described in
      <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a>. This
      stage also performs some optimizations, most notably converting
      pattern match statements into more optimized but low-level
      statements.
    </p><section><h1 id="pattern-matching-optimization">Pattern matching optimization</h1><p id="idp12208064">
        The compiler dumps the lambda form in an s-expression syntax if
        you add the <code>-dlambda</code> directive to the
        command-line. Let's use this to learn more about how the OCaml
        pattern matching engine works by building three different
        pattern matches and comparing their lambda forms.
      </p><p id="idp12209488">
        Let's start by creating a straightforward exhaustive pattern
        match using four normal variants.
      </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Alice </span><span class="keyword2">|</span> <span class="keyword6">Bob </span><span class="keyword2">|</span> <span class="keyword6">Charlie </span><span class="keyword2">|</span> <span class="keyword6">David
</span>
<span class="keyword4">let</span> test v <span class="keyword2">=</span>
  <span class="keyword1">match</span> v <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
  <span class="keyword2">|</span> <span class="keyword6">Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span>
  <span class="keyword2">|</span> <span class="keyword6">Charlie </span>-<span class="keyword2">&gt;</span> <span class="keyword8">102</span>
  <span class="keyword2">|</span> <span class="keyword6">David </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">103</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/pattern_monomorphic_large.ml">back-end/pattern_monomorphic_large.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12210736">
        The lambda output for this code looks like this.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dlambda -c pattern_monomorphic_large.ml 2&gt;&amp;1
</div><div class="rwocodeout">(setglobal Pattern_monomorphic_large!</div><div class="rwocodeout">  (let</div><div class="rwocodeout">    (test/1013</div><div class="rwocodeout">       (function v/1014</div><div class="rwocodeout">         (switch* v/1014</div><div class="rwocodeout">          case int 0: 100</div><div class="rwocodeout">          case int 1: 101</div><div class="rwocodeout">          case int 2: 102</div><div class="rwocodeout">          case int 3: 103)))</div><div class="rwocodeout">    (makeblock 0 test/1013)))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/lambda_for_pattern_monomorphic_large.out">back-end/lambda_for_pattern_monomorphic_large.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12211952">
        It's not important to understand every detail of this internal
        form and it is explicitly undocumented since it can change
        across compiler revisions. Despite these caveats, some
        interesting points emerge from reading it.
      </p><ul><li><p id="idp12213120">
            There are no mention of modules or types any more. Global
            values are created via <code>setglobal</code> and
            OCaml values are constructed by
            <code>makeblock</code>. The blocks are the runtime
            values you should remember from
            <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a>.
          </p></li><li><p id="idp12216320">
            The pattern match has turned into a switch case that jumps
            to the right case depending on the header tag of
            <code>v</code>. Recall that variants without
            parameters are stored in memory as integers in the order
            which they appear. The pattern matching engine knows this
            and has transformed the pattern into an efficient jump
            table.
          </p></li><li><p id="idp12218192">
            Values are addressed by a unique name that distinguished
            shadowed values by appending a number
            (<span><em>e.g.</em></span> <code>v/1014</code>). The
            type safety checks in the earlier phase ensure that these
            low-level accesses never violate runtime memory safety, so
            this layer doesn't do any dynamic checks. Unwise use of
            unsafe features such as the <code>Obj.magic</code>
            module can still easily induce crashes at this level.
          </p></li></ul><p id="idp12221136">
        The compiler computes a jump table in order to handle all four
        cases. If we drop the number of variants to just two, then
        there's no need for the complexity of computing this table.
      </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Alice </span><span class="keyword2">|</span> <span class="keyword6">Bob </span>

<span class="keyword4">let</span> test v <span class="keyword2">=</span>
  <span class="keyword1">match</span> v <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
  <span class="keyword2">|</span> <span class="keyword6">Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/pattern_monomorphic_small.ml">back-end/pattern_monomorphic_small.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12222480">
        The lambda output for this code is now quite different.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dlambda -c pattern_monomorphic_small.ml 2&gt;&amp;1
</div><div class="rwocodeout">(setglobal Pattern_monomorphic_small!</div><div class="rwocodeout">  (let (test/1011 (function v/1012 (if (!= v/1012 0) 101 100)))</div><div class="rwocodeout">    (makeblock 0 test/1011)))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/lambda_for_pattern_monomorphic_small.out">back-end/lambda_for_pattern_monomorphic_small.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12223680">
        The compiler emits simpler conditional jumps rather than setting
        up a jump table, since it statically determines that the range
        of possible variants is small enough. Finally, let's look at the
        same code, but with polymorphic variants instead of normal
        variants.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> test v <span class="keyword2">=</span>
  <span class="keyword1">match</span> v <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">`Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
  <span class="keyword2">|</span> <span class="keyword6">`Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span>
  <span class="keyword2">|</span> <span class="keyword6">`Charlie </span>-<span class="keyword2">&gt;</span> <span class="keyword8">102</span>
  <span class="keyword2">|</span> <span class="keyword6">`David </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">103</span>
  <span class="keyword2">|</span> <span class="keyword6">`Eve </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">104</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/pattern_polymorphic.ml">back-end/pattern_polymorphic.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12225104">
        The lambda form for this also shows up the runtime
        representation of polymorphic variants.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dlambda -c pattern_polymorphic.ml 2&gt;&amp;1
</div><div class="rwocodeout">(setglobal Pattern_polymorphic!</div><div class="rwocodeout">  (let</div><div class="rwocodeout">    (test/1008</div><div class="rwocodeout">       (function v/1009</div><div class="rwocodeout">         (if (!= v/1009 3306965)</div><div class="rwocodeout">           (if (&gt;= v/1009 482771474) (if (&gt;= v/1009 884917024) 100 102)</div><div class="rwocodeout">             (if (&gt;= v/1009 3457716) 104 103))</div><div class="rwocodeout">           101)))</div><div class="rwocodeout">    (makeblock 0 test/1008)))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/lambda_for_pattern_polymorphic.out">back-end/lambda_for_pattern_polymorphic.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12226352">
        We mentioned earlier in <a href="variants.html">Chapter 6, <i>Variants</i></a>
        that pattern matching over polymorphic variants is slightly less
        efficient, and it should be clearer why this is the case now.
        Polymorphic variants have a runtime value that's calculated by
        hashing the variant name, and so the compiler can't use a jump
        table as it does for normal variants. Instead, it creates a
        decision tree that compares the hash values against the input
        variable in as few comparisons as possible.
      </p><aside class="note"><h1>
      Learning more about pattern matching compilation
      </h1><p id="idp12228624">
        Pattern matching is an important part of OCaml programming.
        You'll often encounter deeply nested pattern matches over
        complex data structures in real code. A good paper that
        describes the fundamental algorithms implemented in OCaml is
        <a href="http://dl.acm.org/citation.cfm?id=507641" target="_top">&quot;Optimizing
        pattern matching&quot;</a> by Fabrice Le Fessant and Luc
        Maranget.
      </p><p id="idp12230144">
        The paper describes the backtracking algorithm used in classical
        pattern matching compilation, and also several OCaml-specific
        optimizations such as the use of exhaustiveness information and
        control flow optimizations via static exceptions.
      </p><p id="idp12230832">
        It's not essential that you understand all of this just to use
        pattern matching of course, but it'll give you insight as to why
        pattern matching is such a lightweight language construct to use
        in OCaml code.
      </p></aside></section><section><h1 id="benchmarking-pattern-matching">Benchmarking pattern matching</h1><p id="idp12232864">
        Let's benchmark these three pattern matching techniques to
        quantify their runtime costs more accurately. The
        <code>Core_bench</code> module runs the tests thousands of
        times and also calculates statistical variance of the results.
        You'll need to <code>opam install core_bench</code> to get
        the library.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Core_bench.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Alice </span><span class="keyword2">|</span> <span class="keyword6">Bob </span>
<span class="keyword4">type</span> s <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">A </span><span class="keyword2">|</span> <span class="keyword6">B </span><span class="keyword2">|</span> <span class="keyword6">C </span><span class="keyword2">|</span> <span class="keyword6">D </span><span class="keyword2">|</span> <span class="keyword6">E
</span>
<span class="keyword4">let</span> polymorphic_pattern <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> test v <span class="keyword2">=</span>
    <span class="keyword1">match</span> v <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">`Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
    <span class="keyword2">|</span> <span class="keyword6">`Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span>
    <span class="keyword2">|</span> <span class="keyword6">`Charlie </span>-<span class="keyword2">&gt;</span> <span class="keyword8">102</span>
    <span class="keyword2">|</span> <span class="keyword6">`David </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">103</span>
    <span class="keyword2">|</span> <span class="keyword6">`Eve </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">104</span>
  <span class="keyword4">in</span>
  <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> v -<span class="keyword2">&gt;</span> ignore<span class="keyword2">(</span>test v<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">[</span>`Alice<span class="keyword2">;</span> `Bob<span class="keyword2">;</span> `Charlie<span class="keyword2">;</span> `David<span class="keyword2">]</span>

<span class="keyword4">let</span> monomorphic_pattern_small <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> test v <span class="keyword2">=</span>
    <span class="keyword1">match</span> v <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
    <span class="keyword2">|</span> <span class="keyword6">Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span> <span class="keyword4">in</span>
  <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> v -<span class="keyword2">&gt;</span> ignore<span class="keyword2">(</span>test v<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">[</span> Alice<span class="keyword2">;</span> <span class="keyword6">Bob </span><span class="keyword2">]</span>

<span class="keyword4">let</span> monomorphic_pattern_large <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> test v <span class="keyword2">=</span>
    <span class="keyword1">match</span> v <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">A </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
    <span class="keyword2">|</span> <span class="keyword6">B </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">101</span>
    <span class="keyword2">|</span> <span class="keyword6">C </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">102</span>
    <span class="keyword2">|</span> <span class="keyword6">D </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">103</span>
    <span class="keyword2">|</span> <span class="keyword6">E </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">104</span>
  <span class="keyword4">in</span>
  <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> v -<span class="keyword2">&gt;</span> ignore<span class="keyword2">(</span>test v<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">[</span> A<span class="keyword2">;</span> B<span class="keyword2">;</span> C<span class="keyword2">;</span> <span class="keyword6">D </span><span class="keyword2">]</span>

<span class="keyword4">let</span> tests <span class="keyword2">=</span> <span class="keyword2">[</span>
  <span class="keyword7">&quot;Polymorphic pattern&quot;</span>, polymorphic_pattern<span class="keyword2">;</span>
  <span class="keyword7">&quot;Monomorphic larger pattern&quot;</span>, monomorphic_pattern_large<span class="keyword2">;</span>
  <span class="keyword7">&quot;Monomorphic small pattern&quot;</span>, monomorphic_pattern_small<span class="keyword2">;</span>
<span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">List.</span>map tests ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>name,test<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create ~name test<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span>make_command
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/bench_patterns.ml">back-end-bench/bench_patterns.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12235648">
        Building and executing this example will run for around 30
        seconds by default, and you'll see the results summarized in a
        neat table.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg core_bench bench_patterns.native
</div><div class="highlight"><span class="gp">$</span> ./bench_patterns.native -ascii
</div><div class="rwocodeout">Estimated testing time 30s (change using -quota SECS).</div><div class="rwocodeout">                                                     </div><div class="rwocodeout">  Name                         Time (ns)   % of max  </div><div class="rwocodeout"> ---------------------------- ----------- ---------- </div><div class="rwocodeout">  Polymorphic pattern              31.51     100.00  </div><div class="rwocodeout">  Monomorphic larger pattern       29.19      92.62  </div><div class="rwocodeout">  Monomorphic small pattern        16.25      51.57  </div><div class="rwocodeout">                                                     </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/run_bench_patterns.out">back-end-bench/run_bench_patterns.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12236944">
        These results confirm our earlier performance hypothesis
        obtained from inspecting the lambda code. The shortest running
        time comes from the small conditional pattern match and
        polymorphic variant pattern matching is the slowest. There isn't
        a hugely significant difference in these examples, but you can
        use the same techniques to peer into the innards of your own
        source code and narrow down any performance hotspots.
      </p><p id="idp12238304">
        The lambda form is primarily a stepping stone to the bytecode
        executable format that we'll cover next. It's often easier to
        look at the textual output from this stage than to wade through
        the native assembly code from compiled executables.
      </p></section></section><section><h1 id="generating-portable-bytecode">Generating portable bytecode</h1><p id="idp12240432">
      After the lambda form has been generated, we are very close to
      having executable code. The OCaml tool-chain branches into two
      separate compilers at this point. We'll describe the bytecode
      compiler first, which consists of two pieces:
    </p><ul><li><p id="idp12241600">
<span><strong>ocamlc</strong></span> compiles files into a bytecode that
          is a close mapping to the lambda form.
        </p></li><li><p id="idp12243168">
<span><strong>ocamlrun</strong></span> is a portable interpreter that
          executes the bytecode.
        </p></li></ul><p id="idp12244592">
      The big advantage of using bytecode is simplicity, portability and
      compilation speed. The mapping from the lambda form to bytecode is
      straightforward, and this results in predictable (but slow)
      execution speed.
    </p><p id="idp12245232">
      The bytecode interpreter implements a stack-based virtual machine.
      The OCaml stack and an associated accumulator stores values that
      consist of:
    </p><ul><li><p id="idp12246304">
<span><em>long</em></span> values corresponding to an OCaml
          <code>int</code> type.
        </p></li><li><p id="idp12248240">
<span><em>block</em></span> values that contain the block
          header and a memory address with the data fields that contain
          further OCaml values indexed by an integer.
        </p></li><li><p id="idp12249600">
<span><em>code offset</em></span> values that are relative to
          the starting code address.
        </p></li></ul><p id="idp12250752">
      The interpreter virtual machine only has seven registers in total:
      the program counter, stack pointer, accumulator, exception and
      argument pointers, and environment and global data. You can
      display the bytecode instructions in textual form via
      <code>-dinstr</code>. Try this on one of our earlier pattern
      matching examples.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dinstr pattern_monomorphic_small.ml 2&gt;&amp;1
</div><div class="rwocodeout">	branch L2</div><div class="rwocodeout">L1:	acc 0</div><div class="rwocodeout">	push</div><div class="rwocodeout">	const 0</div><div class="rwocodeout">	neqint</div><div class="rwocodeout">	branchifnot L3</div><div class="rwocodeout">	const 101</div><div class="rwocodeout">	return 1</div><div class="rwocodeout">L3:	const 100</div><div class="rwocodeout">	return 1</div><div class="rwocodeout">L2:	closure L1, 0</div><div class="rwocodeout">	push</div><div class="rwocodeout">	acc 0</div><div class="rwocodeout">	makeblock 1, 0</div><div class="rwocodeout">	pop 1</div><div class="rwocodeout">	setglobal Pattern_monomorphic_small!</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/instr_for_pattern_monomorphic_small.out">back-end/instr_for_pattern_monomorphic_small.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12252944">
      The bytecode above has been simplified from the lambda form into a
      set of simple instructions that are executed serially by the
      interpreter.
    </p><p id="idp12253504">
      There are around 140 instructions in total, but most are just
      minor variants of commonly encountered operations
      (<span><em>e.g.</em></span> function application at a specific
      arity). You can find full details
      <a href="http://cadmium.x9c.fr/distrib/caml-instructions.pdf" target="_top">online</a>.
    </p><aside class="note"><h1>
    Where did the bytecode instruction set come from?
    </h1><p id="idp12256016">
      The bytecode interpreter is much slower than compiled native code,
      but is still remarkably performant for an interpreter without a
      JIT compiler. Its efficiency can be traced back to Xavier Leroy's
      ground-breaking work in 1990 on
      <a href="http://hal.inria.fr/docs/00/07/00/49/PS/RT-0117.ps" target="_top">&quot;The
      ZINC experiment: An Economical Implementation of the ML
      Language&quot;</a>.
    </p><p id="idp12257568">
      This paper laid the theoretical basis for the implementation of an
      instruction set for a strictly evaluated functional language such
      as OCaml. The bytecode interpreter in modern OCaml is still based
      on the ZINC model. The native code compiler uses a different model
      since it uses CPU registers for function calls instead of always
      passing arguments on the stack as the bytecode interpreter does.
    </p><p id="idp12258400">
      Understanding the reasoning behind the different implementations
      of the bytecode interpreter and the native compiler is a very
      useful exercise for any budding language hacker.
    </p></aside><section><h1 id="compiling-and-linking-bytecode">Compiling and linking bytecode</h1><p id="idp12260320">
        The <span><strong>ocamlc</strong></span> command compiles individual
        <code>ml</code> files into bytecode files that have a
        <code>cmo</code> extension. The compiled bytecode files
        are matched with the associated <code>cmi</code> interface
        which contains the type signature exported to other compilation
        units.
      </p><p id="idp12263776">
        A typical OCaml library consists of multiple source files, and
        hence multiple <code>cmo</code> files that all need to be
        passed as command-line arguments to use the library from other
        code. The compiler can combine these multiple files into a more
        convenient single archive file by using the
        <code>-a</code> flag. Bytecode archives are denoted by the
        <code>cma</code> extension.
      </p><p id="idp12266672">
        The individual objects in the library are linked as regular
        <code>cmo</code> files in the order specified when the
        library file was built. If an object file within the library
        isn't referenced elsewhere in the program, then it isn't
        included in the final binary unless the
        <code>-linkall</code> flag forces its inclusion. This
        behavior is analogous to how C handles object files and archives
        (<code>.o</code> and <code>.a</code> respectively).
      </p><p id="idp12270288">
        The bytecode files are then linked together with the OCaml
        standard library to produce an executable program. The order in
        which <code>.cmo</code> arguments are presented on the
        command line defines the order in which compilation units are
        initialized at runtime. Remember that OCaml has no single
        <code>main</code> function like C, so this link order is
        more important than in C programs.
      </p></section><section><h1 id="executing-bytecode">Executing bytecode</h1><p id="idp12273808">
        The bytecode runtime comprises three parts: the bytecode
        interpreter, garbage collector, and a set of C functions that
        implement the primitive operations. The bytecode contains
        instructions to call these C functions when required.
      </p><p id="idp12274480">
        The OCaml linker produces bytecode that targets the standard
        OCaml runtime by default, and so needs to know about any C
        functions that are referenced from other libraries that aren't
        loaded by default.
      </p><p id="idp12275120">
        Information about these extra libraries can be specified while
        linking a bytecode archive.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -a -o mylib.cma a.cmo b.cmo -dllib -lmylib
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/link_dllib.out">back-end-embed/link_dllib.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12276352">
        The <code>dllib</code> flag embeds the arguments in the
        archive file. Any subsequent packages linking this archive will
        also include the extra C linking directive. This in turn lets
        the interpreter dynamically load the external library symbols
        when it executes the bytecode.
      </p><p id="idp12277760">
        You can also generate a complete standalone executable that
        bundles the <span><strong>ocamlrun</strong></span> interpreter with the
        bytecode in a single binary. This is known as a <span><em>custom
        runtime</em></span> mode and is built as follows.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -a -o mylib.cma -custom a.cmo b.cmo -cclib -lmylib
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/link_custom.out">back-end-embed/link_custom.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12280224">
        OCamlbuild takes care of much of the details of this with its
        built-in rules. The <code>%.byte</code> rule that you've
        been using throughout the book builds a bytecode executable and
        adding the <code>custom</code> tag will bundle the
        interpreter with it too.
      </p><p id="idp12282304">
        The custom mode is the most similar mode to native code
        compilation, as both generate standalone executables. There are
        quite a few other options available for compiling bytecode
        (notably with shared libraries or building custom runtimes).
        Full details can be found in the
        <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual022.html" target="_top">manual</a>.
      </p></section><section><h1 id="embedding-ocaml-bytecode-in-c">Embedding OCaml bytecode in C</h1><p id="idp12285120">
        A consequence of using the bytecode compiler is that the final
        link phase must be performed by <span><strong>ocamlc</strong></span>.
        However, you might sometimes want to embed your OCaml code
        inside an existing C application. OCaml also supports this mode
        of operation via the <code>-output-obj</code> directive.
      </p><p id="idp12287232">
        This mode causes <span><strong>ocamlc</strong></span> to output a C object
        file that containing the bytecode for the OCaml part of the
        program, as well as a <code>caml_startup</code> function.
        All of the OCaml modules are linked into this object file as
        bytecode, just as they would be for an executable.
      </p><p id="idp12289344">
        This object file can then be linked with C code using the
        standard C compiler, and only needs the bytecode runtime library
        (which is installed as <code>libcamlrun.a</code>).
        Creating an executable just requires you to link the runtime
        library with the bytecode object file. Here's an example to show
        how it all fits together.
      </p><p id="idp12290816">
        Create two OCaml source files that contain a single print line.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> print_endline <span class="keyword7">&quot;hello embedded world 1&quot;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/embed_me1.ml">back-end-embed/embed_me1.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> print_endline <span class="keyword7">&quot;hello embedded world 2&quot;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/embed_me2.ml">back-end-embed/embed_me2.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12292736">
        Next, create a C file which will be your main entry point.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;caml/alloc.h&gt;</span>
<span class="cp">#include &lt;caml/mlvalues.h&gt;</span>
<span class="cp">#include &lt;caml/memory.h&gt;</span>
<span class="cp">#include &lt;caml/callback.h&gt;</span>

<span class="kt">int</span> 
<span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Before calling OCaml</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
  <span class="n">caml_startup</span> <span class="p">(</span><span class="n">argv</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;After calling OCaml</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/main.c">back-end-embed/main.c</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12293920">
        Now compile the OCaml files into a standalone object file.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> rm -f embed_out.c
</div><div class="highlight"><span class="gp">$</span> ocamlc -output-obj -o embed_out.o embed_me1.ml embed_me2.ml
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/build_embed.out">back-end-embed/build_embed.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12295120">
        After this point, you no longer need the OCaml compiler, as
        <code>embed_out.o</code> has all of the OCaml code
        compiled and linked into a single object file. Compile an output
        binary using <span><strong>gcc</strong></span> to test this out.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> gcc -fPIC -Wall -I<span class="sb">`</span>ocamlc -where<span class="sb">`</span> -L<span class="sb">`</span>ocamlc -where<span class="sb">`</span> -ltermcap -lm -ldl <span class="se">\</span>
</div><div class="rwocodeout">  -o finalbc.native main.c embed_out.o -lcamlrun</div><div class="highlight"><span class="gp">$</span> ./finalbc.native
</div><div class="rwocodeout">Before calling OCaml</div><div class="rwocodeout">hello embedded world 1</div><div class="rwocodeout">hello embedded world 2</div><div class="rwocodeout">After calling OCaml</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/build_embed_binary.out">back-end-embed/build_embed_binary.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12297872">
        You can inspect the commands that <span><strong>ocamlc</strong></span> is
        invoking by adding <code>-verbose</code> to the command
        line to help figure out the GCC command-line if you get stuck.
        You can even obtain the C source code to the
        <code>-output-obj</code> result by specifying a
        <code>.c</code> output file extension instead of the
        <code>.o</code> we used earlier.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -output-obj -o embed_out.c embed_me1.ml embed_me2.ml
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/build_embed_c.out">back-end-embed/build_embed_c.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12302800">
        Embedding OCaml code like this lets you write OCaml that
        interfaces with any environment that works with a C compiler.
        You can even cross back from the C code into OCaml by using the
        <code>Callback</code> module to register named entry
        points in the OCaml code. This is explained in detail in the
        <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual033.html#toc149" target="_top">interfacing
        with C</a> section of the OCaml manual.
      </p></section></section><section><h1 id="compiling-fast-native-code">Compiling fast native code</h1><p id="idp12306496">
      The native code compiler is ultimately the tool that most
      production OCaml code goes through. It compiles the lambda form
      into fast native code executables, with cross-module inlining and
      additional optimization passes that the bytecode interpreter
      doesn't perform. Care is taken to ensure compatibility with the
      bytecode runtime, so the same code should run identically when
      compiled with either toolchain.
    </p><p id="idp12307344">
      The <span><strong>ocamlopt</strong></span> command is the frontend to the
      native code compiler, and has a very similar interface to
      <span><strong>ocamlc</strong></span>. It also accepts <code>ml</code>
      and <code>mli</code> files, but compiles them to:
    </p><ul><li><p id="idp12311184">
          A <code>.o</code> file containing native object code.
        </p></li><li><p id="idp12312704">
          A <code>.cmx</code> file containing extra information
          for linking and cross-module optimization.
        </p></li><li><p id="idp12314304">
          A <code>.cmi</code> compiled interface file that is the
          same as the bytecode compiler.
        </p></li></ul><p id="idp12315760">
      When the compiler links modules together into an executable, it
      uses the contents of the <code>cmx</code> files to perform
      cross-module inlining across compilation units. This can be a
      significant speedup for standard library functions that are
      frequently used outside of their module.
    </p><p id="idp12317136">
      Collections of <code>.cmx</code> and <code>.o</code>
      files can also be be linked into a <code>.cmxa</code>
      archive by passing the <code>-a</code> flag to the compiler.
      However, unlike the bytecode version, you must keep the individual
      <code>cmx</code> files in the compiler search path so that
      they are available for cross-module inlining. If you don't do
      this, the compilation will still succeed, but you will have missed
      out on an important optimization and have slower binaries.
    </p><section><h1 id="inspecting-assembly-output">Inspecting assembly output</h1><p id="idp12322560">
        The native code compiler generates assembly language that is
        then passed to the system assembler for compiling into object
        files. You can get <span><strong>ocamlopt</strong></span> to output the
        assembly by passing the <code>-S</code> flag to the
        compiler command-line.
      </p><p id="idp12324592">
        The assembly code is highly architecture specific, so the
        discussion below assumes an Intel or AMD 64-bit platform. We've
        generated the example code using <code>-inline 20</code>
        and <code>-nodynlink</code> since it's best to generate
        assembly code with the full optimizations that the compiler
        supports. Even though these optimizations make the code a bit
        harder to read, it will give you a more accurate picture of what
        executes on the CPU. Don't forget that you can use the lambda
        code from earlier to get a slightly higher level picture of the
        code if you get lost in the more verbose assembly.
      </p><section><h1 id="the-impact-of-polymorphic-comparison">The impact of polymorphic comparison</h1><p id="idp12328176">
          We warned you earlier in
          <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a> that using
          polymorphic comparison is both convenient and perilous. Let's
          look at precisely what the difference is at the assembly
          language level now.
        </p><p id="idp12329504">
          First create a comparison function where we've explicitly
          annotated the types, so the compiler knows that only integers
          are being compared.
        </p><div class="rwocode"><pre><code><span class="keyword4">let</span> cmp <span class="keyword2">(</span>a<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">(</span>b<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword1">if</span> a <span class="keyword2">&gt;</span> b <span class="keyword1">then</span> a <span class="keyword1">else</span> b</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/compare_mono.ml">back-end/compare_mono.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12330768">
          Now compile this into assembly and read the resulting
          <code>compare_mono.S</code> file. This file extension
          may be lowercase on some platforms such as Linux.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlopt -inline 20 -nodynlink -S compare_mono.ml
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/asm_from_compare_mono.out">back-end/asm_from_compare_mono.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12332784">
          If you've never seen assembly language before then the
          contents may be rather scary. While you'll need to learn x86
          assembly to fully understand it, we'll try to give you some
          basic instructions to spot patterns in this section. The
          excerpt of the implementation of the <code>cmp</code>
          function can be found below.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="nl">_camlCompare_mono__cmp_1008:</span>
        <span class="na">.cfi_startproc</span>
<span class="nl">.L101:</span>
        <span class="nf">cmpq</span>    <span class="nv">%rbx</span><span class="p">,</span> <span class="nv">%rax</span>
        <span class="nf">jle</span>     <span class="no">.L100</span>
        <span class="nf">ret</span>
        <span class="na">.align</span>  <span class="mi">2</span>
<span class="nl">.L100:</span>
        <span class="nf">movq</span>    <span class="nv">%rbx</span><span class="p">,</span> <span class="nv">%rax</span>
        <span class="nf">ret</span>
        <span class="na">.cfi_endproc</span>
</div></code></pre><div class="rwocodeinfo">Assembly ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/cmp.S">back-end/cmp.S</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12334976">
          The <code>_camlCompare_mono__cmp_1008</code> is an
          assembly label that has been computed from the module name
          (<code>Compare_mono</code>) and the function name
          (<code>cmp_1008</code>). The numeric suffix for the
          function name comes straight from the lambda form (which you
          can inspect using <code>-dlambda</code>, but in this
          case isn't necessary).
        </p><p id="idp12338512">
          The arguments to <code>cmp</code> are passed in the
          <code>%rbx</code> and <code>%rax</code> registers,
          and compared using the <code>jle</code> &quot;jump if
          less than or equal&quot; instruction. This requires both the
          arguments to be immediate integers to work. Now let's see what
          happens if our OCaml code omits the type annotations and is a
          polymorphic comparison instead.
        </p><div class="rwocode"><pre><code><span class="keyword4">let</span> cmp a b <span class="keyword2">=</span>
  <span class="keyword1">if</span> a <span class="keyword2">&gt;</span> b <span class="keyword1">then</span> a <span class="keyword1">else</span> b</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/compare_poly.ml">back-end/compare_poly.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12343136">
          Compiling this code with <code>-S</code> results in a
          significantly more complex assembly output for the same
          function.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="nl">_camlCompare_poly__cmp_1008:</span>
        <span class="na">.cfi_startproc</span>
        <span class="nf">subq</span>    <span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="mi">24</span>
<span class="nl">.L101:</span>
        <span class="nf">movq</span>    <span class="nv">%rax</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
        <span class="nf">movq</span>    <span class="nv">%rbx</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
        <span class="nf">movq</span>    <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>
        <span class="nf">movq</span>    <span class="nv">%rbx</span><span class="p">,</span> <span class="nv">%rsi</span>
        <span class="nf">leaq</span>    <span class="no">_caml_greaterthan</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>
        <span class="nf">call</span>    <span class="no">_caml_c_call</span>
<span class="nl">.L102:</span>
        <span class="nf">leaq</span>    <span class="no">_caml_young_ptr</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%r11</span>
        <span class="nf">movq</span>    <span class="p">(</span><span class="nv">%r11</span><span class="p">),</span> <span class="nv">%r15</span>
        <span class="nf">cmpq</span>    <span class="no">$1</span><span class="p">,</span> <span class="nv">%rax</span>
        <span class="nf">je</span>      <span class="no">.L100</span>
        <span class="nf">movq</span>    <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rax</span>
        <span class="nf">addq</span>    <span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="p">-</span><span class="mi">24</span>
        <span class="nf">ret</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="mi">24</span>
        <span class="na">.align</span>  <span class="mi">2</span>
<span class="nl">.L100:</span>
        <span class="nf">movq</span>    <span class="mi">0</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rax</span>
        <span class="nf">addq</span>    <span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="p">-</span><span class="mi">24</span>
        <span class="nf">ret</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="mi">24</span>
        <span class="na">.cfi_endproc</span>
</div></code></pre><div class="rwocodeinfo">Assembly ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/compare_poly_asm.S">back-end/compare_poly_asm.S</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12345072">
          The <code>.cfi</code> directives are assembler hints
          that contain Call Frame Information that lets the GNU debugger
          provide more sensible backtraces, and have no effect on
          runtime performance. Notice that the rest of the
          implementation is no longer a simple register comparison.
          Instead, the arguments are pushed on the stack (the
          <code>%rsp</code> register) and a C function call is
          invoked by placing a pointer to
          <code>caml_greaterthan</code> in <code>%rax</code>
          and jumping to <code>caml_c_call</code>.
        </p><p id="idp12349536">
          OCaml on x86_64 architectures caches the location of the minor
          heap in the <code>%r15</code> register since it's so
          frequently referenced in OCaml functions. The minor heap
          pointer can also be changed by the C code that's being called
          (e.g. when it allocates OCaml values), and so
          <code>%r15</code> is restored after returning from the
          <code>caml_greaterthan</code> call. Finally the return
          value of the comparison is popped from the stack and returned.
        </p></section><section><h1 id="benchmarking-polymorphic-comparison">Benchmarking polymorphic comparison</h1><p id="idp12353792">
          You don't have to fully understand the intricacies of assembly
          language to see that this polymorphic comparison is much
          heavier than the simple monomorphic integer comparison from
          earlier. Let's confirm this hypothesis again by writing a
          quick <code>Core_bench</code> test with both functions.
        </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Core_bench.Std
</span>
<span class="keyword4">let</span> polymorphic_compare <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> cmp a b <span class="keyword2">=</span> <span class="keyword1">if</span> a <span class="keyword2">&gt;</span> b <span class="keyword1">then</span> a <span class="keyword1">else</span> b <span class="keyword4">in</span>
  <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">to</span> <span class="keyword8">1000</span> <span class="keyword1">do</span>
    ignore<span class="keyword2">(</span>cmp <span class="keyword8">0</span> i<span class="keyword2">)</span>
  <span class="keyword1">done</span>

<span class="keyword4">let</span> monomorphic_compare <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> cmp <span class="keyword2">(</span>a<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">(</span>b<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">=</span>
    <span class="keyword1">if</span> a <span class="keyword2">&gt;</span> b <span class="keyword1">then</span> a <span class="keyword1">else</span> b <span class="keyword4">in</span>
  <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">to</span> <span class="keyword8">1000</span> <span class="keyword1">do</span>
    ignore<span class="keyword2">(</span>cmp <span class="keyword8">0</span> i<span class="keyword2">)</span>
  <span class="keyword1">done</span>

<span class="keyword4">let</span> tests <span class="keyword2">=</span>
  <span class="keyword2">[</span> <span class="keyword7">&quot;Polymorphic comparison&quot;</span>, polymorphic_compare<span class="keyword2">;</span>
    <span class="keyword7">&quot;Monomorphic comparison&quot;</span>, monomorphic_compare <span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">List.</span>map tests ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>name,test<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create ~name test<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span>make_command
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/bench_poly_and_mono.ml">back-end-bench/bench_poly_and_mono.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12355952">
          Running this shows quite a significant runtime difference
          between the two.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg core_bench bench_poly_and_mono.native
</div><div class="highlight"><span class="gp">$</span> ./bench_poly_and_mono.native -ascii
</div><div class="rwocodeout">Estimated testing time 20s (change using -quota SECS).</div><div class="rwocodeout">                                                 </div><div class="rwocodeout">  Name                     Time (ns)   % of max  </div><div class="rwocodeout"> ------------------------ ----------- ---------- </div><div class="rwocodeout">  Polymorphic comparison      13_919     100.00  </div><div class="rwocodeout">  Monomorphic comparison         815       5.86  </div><div class="rwocodeout">                                                 </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/run_bench_poly_and_mono.out">back-end-bench/run_bench_poly_and_mono.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12357200">
          We see that the polymorphic comparison is close to 20 times
          slower! These results shouldn't be taken too seriously as this
          is a very narrow test, which like all such microbenchmarks
          aren't representative of more complex codebases. However, if
          you're building numerical code that runs many iterations in a
          tight inner loop, it's worth manually peering at the produced
          assembly code to see if you can hand-optimize it.
        </p></section></section><section><h1 id="debugging-native-code-binaries">Debugging native code binaries</h1><p id="idp12359504">
        The native code compiler builds executables that can be debugged
        using conventional system debuggers such as GNU
        <span><strong>gdb</strong></span> You need to compile your libraries with
        the <code>-g</code> option to add the debug information to
        the output, just as you need to with C compilers.
      </p><p id="idp12361552">
        Extra debugging information is inserted into the output assembly
        when the library is compiled in debug mode. These include the
        CFI stubs you will have noticed in the profiling output earlier
        (<code>.cfi_start_proc</code> and
        <code>.cfi_end_proc</code> to delimit an OCaml function
        call, for example).
      </p><section><h1 id="understanding-name-mangling">Understanding name mangling</h1><p id="idp12364816">
          So how do you refer to OCaml functions in an interactive
          debugger like <span><strong>gdb</strong></span>? The first thing you need
          to know is how function names compile down to C symbols; a
          procedure generally called <span><em>name mangling</em></span>.
        </p><p id="idp12366560">
          Each OCaml source file is compiled into a native object file
          that must export a unique set of symbols to comply with the C
          binary interface. This means that any OCaml values that may be
          used by another compilation unit need to be mapped into a
          symbol name. This mapping has to account for OCaml language
          features such as nested modules, anonymous functions and
          variable names that shadow each other.
        </p><p id="idp12367440">
          The conversion follows some straightforward rules for named
          variables and functions:
        </p><ul><li><p id="idp12368464">
              The symbol is prefixed by <code>caml</code> and the
              local module name, with dots replaced by underscores.
            </p></li><li><p id="idp12370096">
              This is followed by a double <code>__</code> suffix
              and the variable name.
            </p></li><li><p id="idp12371664">
              The variable name is also suffixed by a
              <code>_</code> and a number. This is the result of
              the lambda compilation that replaces each variable name
              with a unique value within the module. You can determine
              this number by examining the <code>-dlambda</code>
              output from <span><strong>ocamlopt</strong></span>.
            </p></li></ul><p id="idp12374736">
          Anonymous functions are hard to predict without inspecting
          intermediate compiler output. If you need to debug them it's
          usually easier to modify the source code to let-bind the
          anonymous function to a variable name.
        </p></section><section><h1 id="interactive-breakpoints-with-the-gnu-debugger">Interactive breakpoints with the GNU debugger</h1><p id="idp12376736">
          Let's see name mangling in action with some interactive
          debugging using GNU <span><strong>gdb</strong></span>.
        </p><aside class="caution"><h1>
        Beware gdb on MacOS X
        </h1><p id="idp12378608">
          The examples here assume that you are running
          <span><strong>gdb</strong></span> on either Linux or FreeBSD. MacOS X
          10.8 does have <span><strong>gdb</strong></span> installed, but it's a
          rather quirky experience that doesn't reliably interpret the
          debugging information contained in the native binaries. This
          can result in function names showing up as raw symbols such as
          <code>.L101</code> instead of their more human-readable
          form.
        </p><p id="idp12381504">
          For OCaml 4.1, we'd recommend you do native code debugging on
          an alternate platform such as Linux, or manually look at the
          assembly code output to map the symbol names onto their
          precise OCaml functions.
        </p></aside><p id="idp12382288">
          Let's write a mutually recursive function that selects
          alternating values from a list. This isn't tail recursive and
          so our stack size will grow as we single-step through the
          execution.
        </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> <span class="keyword4">rec</span> take <span class="keyword2">=</span>
  <span class="keyword1">function</span>
  <span class="keyword2">|</span><span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
  <span class="keyword2">|</span>hd<span class="keyword2">:</span><span class="keyword2">:</span>tl -<span class="keyword2">&gt;</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">(</span>skip tl<span class="keyword2">)</span>
<span class="keyword4">and</span> skip <span class="keyword2">=</span>
  <span class="keyword1">function</span>
  <span class="keyword2">|</span><span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
  <span class="keyword2">|</span><span class="keyword8">_</span><span class="keyword2">:</span><span class="keyword2">:</span>tl -<span class="keyword2">&gt;</span> take tl

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  take <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">;</span><span class="keyword8">6</span><span class="keyword2">;</span><span class="keyword8">7</span><span class="keyword2">;</span><span class="keyword8">8</span><span class="keyword2">;</span><span class="keyword8">9</span><span class="keyword2">]</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span>string_of_int
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">String.</span>concat ~sep<span class="keyword2">:</span><span class="keyword7">&quot;,&quot;</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/alternate_list.ml">back-end/alternate_list.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12383648">
          Compile and run this with debugging symbols. You should see
          the following output:
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -tag debug alternate_list.native
</div><div class="highlight"><span class="gp">$</span> ./alternate_list.native -ascii
</div><div class="rwocodeout">1,3,5,7,9</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/run_alternate_list.out">back-end-bench/run_alternate_list.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12384896">
          Now we can run this interactively within
          <span><strong>gdb</strong></span>.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> gdb ./alternate_list.native
</div><div class="rwocodeout">GNU gdb (GDB) 7.4.1-debian</div><div class="rwocodeout">Copyright (C) 2012 Free Software Foundation, Inc.</div><div class="rwocodeout">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="rwocodeout">This is free software: you are free to change and redistribute it.</div><div class="rwocodeout">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="rwocodeout">and &quot;show warranty&quot; for details.</div><div class="rwocodeout">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</div><div class="rwocodeout">For bug reporting instructions, please see:</div><div class="rwocodeout">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</div><div class="rwocodeout">Reading symbols from /home/avsm/alternate_list.native...done.</div><div class="rwocodeout">(gdb)</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/gdb_alternate0.out">back-end/gdb_alternate0.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12386768">
          The <span><strong>gdb</strong></span> prompt lets you enter debug
          directives. Let's set the program to break just before the
          first call to <code>take</code>.
        </p><div class="rwocode"><pre><code><div class="rwocodeout">(gdb) break camlAlternate_list__take_69242 </div><div class="rwocodeout">Breakpoint 1 at 0x5658d0: file alternate_list.ml, line 5.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/gdb_alternate1.out">back-end/gdb_alternate1.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12389424">
          We used the C symbol name by following the name mangling rules
          defined earlier. A convenient way to figure out the full name
          is by tab-completion. Just type in a portion of the name and
          press the <code>&lt;tab&gt;</code> key to see a list of
          possible completions.
        </p><p id="idp12390832">
          Once you've set the breakpoint, start the program executing.
        </p><div class="rwocode"><pre><code><div class="rwocodeout">(gdb) run</div><div class="rwocodeout">Starting program: /home/avsm/alternate_list.native</div><div class="rwocodeout">[Thread debugging using libthread_db enabled]</div><div class="rwocodeout">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</div><div class="rwocodeout"> </div><div class="rwocodeout">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</div><div class="rwocodeout">4         function</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/gdb_alternate2.out">back-end/gdb_alternate2.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12392032">
          The binary has run until the first take invocation and
          stopped, waiting for further instructions. GDB has lots of
          features, so let's continue the program and check the
          stacktrace after a couple of recursions.
        </p><div class="rwocode"><pre><code><div class="rwocodeout">(gdb) cont</div><div class="rwocodeout">Continuing.</div><div class="rwocodeout"> </div><div class="rwocodeout">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</div><div class="rwocodeout">4         function</div><div class="rwocodeout">(gdb) cont</div><div class="rwocodeout">Continuing.</div><div class="rwocodeout"> </div><div class="rwocodeout">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</div><div class="rwocodeout">4         function</div><div class="rwocodeout">(gdb) bt</div><div class="rwocodeout">#0  camlAlternate_list__take_69242 () at alternate_list.ml:4</div><div class="rwocodeout">#1  0x00000000005658e7 in camlAlternate_list__take_69242 () at alternate_list.ml:6</div><div class="rwocodeout">#2  0x00000000005658e7 in camlAlternate_list__take_69242 () at alternate_list.ml:6</div><div class="rwocodeout">#3  0x00000000005659f7 in camlAlternate_list__entry () at alternate_list.ml:14</div><div class="rwocodeout">#4  0x0000000000560029 in caml_program ()</div><div class="rwocodeout">#5  0x000000000080984a in caml_start_program ()</div><div class="rwocodeout">#6  0x00000000008099a0 in ?? ()</div><div class="rwocodeout">#7  0x0000000000000000 in ?? ()</div><div class="rwocodeout">(gdb) clear camlAlternate_list__take_69242</div><div class="rwocodeout">Deleted breakpoint 1 </div><div class="rwocodeout">(gdb) cont</div><div class="rwocodeout">Continuing.</div><div class="rwocodeout">1,3,5,7,9</div><div class="rwocodeout">[Inferior 1 (process 3546) exited normally]</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/gdb_alternate3.out">back-end/gdb_alternate3.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12393408">
          The <code>cont</code> command resumes execution after a
          breakpoint has paused it, <code>bt</code> displays a
          stack backtrace, and <code>clear</code> deletes the
          breakpoint so that the application can execute until
          completion. GDB has a host of other features we won't cover
          here, but you can view more guidelines via Mark Shinwell's
          talk on
          <a href="http://www.youtube.com/watch?v=NF2WpWnB-nk&lt;" target="_top">&quot;Real-world
          debugging in OCaml&quot;</a>.
        </p><p id="idp12397232">
          One very useful feature of OCaml native code is that C and
          OCaml both share the same stack. This means that GDB
          backtraces can give you a combined view of what's going on in
          your program <span><em>and</em></span> runtime library. This
          includes any calls to C libraries or even callbacks into OCaml
          from the C layer if you're in an embedded environment.
        </p></section></section><section><h1 id="profiling-native-code">Profiling native code</h1><p id="idp12399728">
        The recording and analysis of where your application spends its
        execution time is known as <span><em>performance
        profiling</em></span>. OCaml native code binaries can be profiled
        just like any other C binary, by using the name mangling
        described earlier to map between OCaml variable names and the
        profiler output.
      </p><p id="idp12400896">
        Most profiling tools benefit from having some instrumentation
        included in the binary. OCaml supports two such tools:
      </p><ul><li><p id="idp12401952">
            GNU <span><strong>gprof</strong></span> to measure execution time and
            call graphs.
          </p></li><li><p id="idp12403520">
            The <a href="https://perf.wiki.kernel.org/" target="_top">Perf</a>
            profiling framework in modern versions of Linux.
          </p></li></ul><p id="idp12404992">
        Note that many other tools that operate on native binaries such
        as Valgrind will work just fine with OCaml as long as the
        program is linked with the <code>-g</code> flag to embed
        debugging symbols.
      </p><section><h1 id="gprof">Gprof</h1><p id="idp12407440">
<span><strong>gprof</strong></span> produces an execution profile of an
          OCaml program by recording a call graph of which functions
          call each other, and recording the time these calls take
          during the program execution.
        </p><p id="idp12408752">
          Getting precise information out of <span><strong>gprof</strong></span>
          requires passing the <code>-p</code> flag to the native
          code compiler when compiling <span><em>and</em></span> linking
          the binary. This generates extra code that records profile
          information to a file called <code>gmon.out</code> when
          the program is executed. This profile information can then be
          examined using <span><strong>gprof</strong></span>.
        </p></section><section><h1 id="perf">Perf</h1><p id="idp12414032">
          Perf is a more modern alternative to <span><strong>gprof</strong></span>
          that doesn't require you to instrument the binary. Instead, it
          uses hardware counters and debug information within the binary
          to record information accurately.
        </p><p id="idp12415376">
          Run Perf on a compiled binary to record information first.
          We'll use our write barrier benchmark from earlier which
          measures memory allocation versus in-place modification.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> perf record -g ./barrier_bench.native
</div><div class="rwocodeout">Estimated testing time 20s (change using -quota SECS).</div><div class="rwocodeout"> </div><div class="rwocodeout">  Name        Time (ns)             Time 95ci   Percentage</div><div class="rwocodeout">  ----        ---------             ---------   ----------</div><div class="rwocodeout">  mutable     7_306_219   7_250_234-7_372_469        96.83</div><div class="rwocodeout">  immutable   7_545_126   7_537_837-7_551_193       100.00</div><div class="rwocodeout"> </div><div class="rwocodeout">[ perf record: Woken up 11 times to write data ]</div><div class="rwocodeout">[ perf record: Captured and wrote 2.722 MB perf.data (~118926 samples) ]</div><div class="rwocodeout">perf record -g ./barrier.native</div><div class="rwocodeout">Estimated testing time 20s (change using -quota SECS).</div><div class="rwocodeout"> </div><div class="rwocodeout">  Name        Time (ns)             Time 95ci   Percentage</div><div class="rwocodeout">  ----        ---------             ---------   ----------</div><div class="rwocodeout">  mutable     7_306_219   7_250_234-7_372_469        96.83</div><div class="rwocodeout">  immutable   7_545_126   7_537_837-7_551_193       100.00</div><div class="rwocodeout"> </div><div class="rwocodeout">[ perf record: Woken up 11 times to write data ]</div><div class="rwocodeout">[ perf record: Captured and wrote 2.722 MB perf.data (~118926 samples) ]</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/perf_record.out">back-end/perf_record.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12416704">
          When this completes, you can interactively explore the
          results.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> perf report -g
</div><div class="rwocodeout">+  48.86%  barrier.native  barrier.native  [.] camlBarrier__test_immutable_69282</div><div class="rwocodeout">+  30.22%  barrier.native  barrier.native  [.] camlBarrier__test_mutable_69279</div><div class="rwocodeout">+  20.22%  barrier.native  barrier.native  [.] caml_modify</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/perf_report.out">back-end/perf_report.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12417920">
          This trace broadly reflects the results of the benchmark
          itself. The mutable benchmark consists of the combination of
          the call to <code>test_mutable</code> and the
          <code>caml_modify</code> write barrier function in the
          runtime. This adds up to slightly over half the execution time
          of the application.
        </p><p id="idp12420048">
          Perf has a growing collection of other commands that let you
          archive these runs and compare them against each other. You
          can read more on the
          <a href="http://perf.wiki.kernel.org" target="_top">homepage</a>.
        </p><section><h1><b>
        Using the frame-pointer to get more accurate traces
        </b></h1><p id="idp12422080">
          Although Perf doesn't require adding in explicit probes to the
          binary, it does need to understand how to unwind function
          calls so that the kernel can accurately record the function
          backtrace for every event.
        </p><p id="idp12422736">
          OCaml stack frames are too complex for Perf to understand
          directly, and so it needs the compiler to fall back to using
          the same conventions as C for function calls. On 64-bit Intel
          systems, this means that a special register known as the
          <span><em>frame pointer</em></span> is used to record function
          call history.
        </p><p id="idp12423920">
          Using the frame pointer in this fashion means a slowdown
          (typically around 3-5%) since it's no longer available for
          general-purpose use. OCaml 4.1 thus makes the frame pointer an
          optional feature that can be used to improve the resolution of
          Perf traces.
        </p><p id="idp12424640">
          OPAM provides a compiler switch that compiles OCaml with the
          frame pointer activated.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> opam switch 4.01.0dev+fp
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/opam_switch.out">back-end/opam_switch.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12425872">
          Using the frame pointer changes the OCaml calling convention,
          but OPAM takes care of recompiling all your libraries with the
          new interface. You can read more about this on the OCamlPro
          <a href="http://www.ocamlpro.com/blog/2012/08/08/profile-native-code.html" target="_top">blog</a>.
        </p></section></section></section><section><h1 id="embedding-native-code-in-c">Embedding native code in C</h1><p id="idp12428848">
        The native code compiler normally links a complete executable,
        but can also output a standalone native object file just as the
        bytecode compiler can. This object file has no further
        dependencies on OCaml except for the runtime library.
      </p><p id="idp12429520">
        The native code runtime is a different library from the bytecode
        one and is installed as <code>libasmrun.a</code> in the
        OCaml standard library directory.
      </p><p id="idp12430800">
        Try this custom linking by using the same source files from the
        bytecode embedding example earlier in this chapter.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlopt -output-obj -o embed_native.o embed_me1.ml embed_me2.ml
</div><div class="highlight"><span class="gp">$</span> gcc -Wall -I <span class="sb">`</span>ocamlc -where<span class="sb">`</span> -o final.native embed_native.o main.c <span class="se">\</span>
</div><div class="rwocodeout">   -L `ocamlc -where` -lasmrun -ltermcap -lm -ldl</div><div class="highlight"><span class="gp">$</span> ./final.native
</div><div class="rwocodeout">Before calling OCaml</div><div class="rwocodeout">hello embedded world 1</div><div class="rwocodeout">hello embedded world 2</div><div class="rwocodeout">After calling OCaml</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/build_embed_native.out">back-end-embed/build_embed_native.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12432080">
        The <code>embed_native.o</code> is a standalone object
        file that has no further references to OCaml code beyond the
        runtime library, just as with the bytecode runtime. Do remember
        that the link order of the libraries is significant on modern
        GNU toolchains (especially as used in Ubuntu 11.10 upwards) that
        resolve symbols from left-to-right in a single pass.
      </p><aside class="tip"><h1>
      Activating the debug runtime
      </h1><p id="idp12434272">
        Despite your best efforts, it is easy to introduce a bug into
        some components such as C bindings that causes heap invariants
        to be violated. OCaml includes a <code>libasmrund.a</code>
        variant of the runtime library that is compiled with extra
        debugging checks that perform extra memory integrity checks
        during every garbage collection cycle. Running these extra
        checks will abort the program nearer the point of corruption and
        help isolate the bug in the C code.
      </p><p id="idp12436208">
        To use the debug library, just link your program with the
        <code>-runtime-variant d</code> flag.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlopt -runtime-variant d -verbose -o hello.native hello.ml
</div><div class="highlight"><span class="gp">$</span> ./hello.native
</div><div class="rwocodeout">### OCaml runtime: debug mode ###</div><div class="rwocodeout">Initial minor heap size: 2048k bytes</div><div class="rwocodeout">Initial major heap size: 992k bytes</div><div class="rwocodeout">Initial space overhead: 80%</div><div class="rwocodeout">Initial max overhead: 500%</div><div class="rwocodeout">Initial heap increment: 992k bytes</div><div class="rwocodeout">Initial allocation policy: 0</div><div class="rwocodeout">Hello OCaml World!</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/run_debug_hello.out">back-end-embed/run_debug_hello.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12438144">
        If you get an error that <code>libasmrund.a</code> is not
        found, then this is probably because you're using OCaml 4.00 and
        not 4.01. It's only installed by default in the very latest
        version, which you should be using via the
        <code>4.01.0</code> OPAM switch.
      </p></aside></section></section><section><h1 id="summarizing-the-file-extensions">Summarizing the file extensions</h1><p id="idp12441728">
      We've seen how the compiler uses intermediate files to store
      various stages of the compilation toolchain. Here's a cheat sheet
      of all them in one place.
    </p><p id="idp12442304">
      Here are the intermediate files generated by
      <span><strong>ocamlc</strong></span>:
    </p><table><thead><tr><th>
              Extension
            </th><th>
              Purpose
            </th></tr></thead><tbody><tr><td>
              .ml
            </td><td>
              Source files for compilation unit module implementations.
            </td></tr><tr><td>
              .mli
            </td><td>
              Source files for compilation unit module interfaces. If
              missing, generated from the <code>.ml</code> file.
            </td></tr><tr><td>
              .cmi
            </td><td>
              Compiled module interface from a corresponding
              <code>.mli</code> source file.
            </td></tr><tr><td>
              .cmo
            </td><td>
              Compiled bytecode object file of the module
              implementation.
            </td></tr><tr><td>
              .cma
            </td><td>
              Library of bytecode object files packed into a single
              file.
            </td></tr><tr><td>
              .o
            </td><td>
              C source files are compiled into native object files by
              the system <code>cc</code>.
            </td></tr><tr><td>
              .cmt
            </td><td>
              Typed abstract syntax tree for module implementations.
            </td></tr><tr><td>
              .cmti
            </td><td>
              Typed abstract syntax tree for module interfaces.
            </td></tr><tr><td>
              .annot
            </td><td>
              Old-style annotation file for displaying typed, superseded
              by <code>cmt</code> files.
            </td></tr></tbody></table><p id="idp12462128">
      The native code compiler generates some additional files.
    </p><table><thead><tr><th>
              Extension
            </th><th>
              Purpose
            </th></tr></thead><tbody><tr><td>
              .o
            </td><td>
              Compiled native object file of the module implementation.
            </td></tr><tr><td>
              .cmx
            </td><td>
              Contains extra information for linking and cross-module
              optimization of the object file.
            </td></tr><tr><td>
              .cmxa and .a
            </td><td>
              Library of <code>cmx</code> and <code>o</code>
              units, stored in the <code>cmxa</code> and
              <code>a</code> files respectively. These files are
              always needed together.
            </td></tr><tr><td>
              .S <span><em>or</em></span> .s
            </td><td>
              Assembly language output if <code>-S</code> is
              specified.
            </td></tr></tbody></table></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="the-compiler-frontend-parsing-and-type-checking.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="installation.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>