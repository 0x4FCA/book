<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 14. Object Subtyping and Inheritance / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha3',
                        page: 'object\u002Dsubtyping\u002Dand\u002Dinheritance.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="object-subtyping-and-inheritance.html" class="here">14. Object Subtyping and Inheritance</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 14. Object Subtyping and Inheritance</h1>
                
                

    <section><h1 id="subtyping">Subtyping</h1><p id="idp9215120">
      Subtyping is a central concept in object-oriented programming. It
      governs when an object with one type <span><em>A</em></span> can be
      used in an expression that expects an object of another type
      <span><em>B</em></span>. When this is true, we say that
      <span><em>A</em></span> is a <span><em>subtype</em></span> of
      <span><em>B</em></span>. Actually, more concretely, subtyping
      determines when the coercion operator <code>e :&gt; t</code>
      can be applied. This coercion works only if the expression
      <code>e</code> has some type <code>s</code> and
      <code>s</code> is a subtype of <code>t</code>.
    </p><p id="idp9221472">
      To explore this, let's define some simple classes for geometric
      shapes. The generic type <code>shape</code> has a method to
      compute the area, and a <code>square</code> is a specific
      kind of shape.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;;;</span>

<span class="k">class</span> <span class="n">square</span> <span class="n">w</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
  <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*.</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9224704">
      A <code>square</code> has a method <code>area</code>
      just like a <code>shape</code>, and an additional method
      <code>width</code>. Still, we expect a
      <code>square</code> to be a <code>shape</code>, and it
      is. The coercion <code>:&gt;</code> must be explicit.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">new_square</span> <span class="n">x</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="n">square</span> <span class="n">x</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">27</span><span class="o">-</span><span class="mi">39</span><span class="o">:</span>
  <span class="k">let</span> <span class="n">new_square</span> <span class="n">x</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="n">square</span> <span class="n">x</span><span class="o">;;</span>
                             <span class="o">^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="n">square</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="n">shape</span>
<span class="nc">The</span> <span class="n">second</span> <span class="k">object</span> <span class="k">type</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">width</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">new_square</span> <span class="n">x</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="n">x</span> <span class="o">:&gt;</span> <span class="n">shape</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">new_square</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9231792">
      What are the rules for subtyping? In general, object subtyping has
      two general forms, called <span><em>width</em></span> and
      <span><em>depth</em></span> subtyping. Width subtyping means that
      an object type <span><em>A</em></span> is a a subtype of
      <span><em>B</em></span>, if <span><em>A</em></span> has all of the
      methods of <span><em>B</em></span>, and possibly more. A
      <code>square</code> is a subtype of <code>shape</code>
      because it implements all of the methods of
      <code>shape</code> (the <code>area</code> method).
    </p><p id="idp9237888">
      The subtyping rules are purely technical, they have no relation to
      object semantics. We can define a class
      <code>rectangle</code> that has all of the methods of a
      <code>square</code>, so it is a subtype of square and can be
      used wherever a <code>square</code> is expected.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">rectangle</span> <span class="n">h</span> <span class="n">w</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">inherit</span> <span class="n">square</span> <span class="n">w</span>
     <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*.</span> <span class="n">self</span><span class="o">#</span><span class="n">height</span>
     <span class="k">method</span> <span class="n">height</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">square_rectangle</span> <span class="n">h</span> <span class="n">w</span> <span class="o">:</span> <span class="n">square</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">rectangle</span> <span class="n">h</span> <span class="n">w</span> <span class="o">:&gt;</span> <span class="n">square</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">square_rectangle</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9242016">
      This may seem absurd, but this concept is expressible in all
      object-oriented languages. The contradiction is semantic -- we
      know that in the real world, not all rectangles are squares; but
      in the programming world, rectangles have all of the features of
      squares (according to our definition), so they can be used just
      like squares. Suffice it to say that it is usually better to avoid
      such apparent contradictions.
    </p><p id="idp9242880">
      Next, let's take a seemingly tiny step forward, and start building
      collections of shapes. It is easy enough to define a
      <code>slist</code> of squares.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">squares</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">SList</span><span class="p">.</span><span class="n">make</span> <span class="bp">()</span> <span class="k">in</span>
     <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">);</span>
     <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">);</span>
     <span class="n">l</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">squares</span> <span class="o">:</span> <span class="n">square</span> <span class="n">slist</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
</pre></div><p id="idp9245392">
      We can also define a function to calculate the total area of a
      list of shapes. There is no reason to restrict this to squares, it
      should work for any list of shapes with type
      <code>shape slist</code>. The problem is that doing so
      raises some serious typing questions -- can a
      <code>square slist</code> be passed to a function that
      expects a <code>shape slist</code>? If we try it, the
      compiler produces a verbose error message.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">total_area</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">slist</span><span class="o">)</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">total</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
     <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
     <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
        <span class="n">total</span> <span class="o">:=</span> <span class="o">!</span><span class="n">total</span> <span class="o">+.</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">#</span><span class="n">area</span><span class="o">;</span>
        <span class="n">it</span><span class="o">#</span><span class="n">next</span>
     <span class="k">done</span><span class="o">;</span>
     <span class="o">!</span><span class="n">total</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">total_area</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">slist</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">total_area</span> <span class="n">squares</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">11</span><span class="o">-</span><span class="mi">18</span><span class="o">:</span>
  <span class="n">total_area</span> <span class="n">squares</span><span class="o">;;</span>
             <span class="o">^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
         <span class="n">square</span> <span class="n">slist</span> <span class="o">=</span>
           <span class="o">&lt;</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">square</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span>
             <span class="n">iterator</span> <span class="o">:</span> <span class="n">square</span> <span class="n">iterator</span> <span class="o">&gt;</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="n">shape</span> <span class="n">slist</span> <span class="o">=</span>
           <span class="o">&lt;</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span>
             <span class="n">iterator</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">iterator</span> <span class="o">&gt;</span>
       <span class="nc">Type</span> <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;</span>
       <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;</span> 
       <span class="nc">The</span> <span class="n">second</span> <span class="k">object</span> <span class="k">type</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">width</span>
</pre></div><p id="idp9250368">
      It might seem tempting to give up at this point, especially
      because the subtyping is not even true -- the type
      <code>square slist</code> is not a subtype of
      <code>shape slist</code>. The problem is with the
      <code>insert</code> method. For
      <code>shape slist</code>, the <code>insert</code>
      method takes an arbitrary <code>shape</code> and inserts it
      into the list. So if we could coerce a
      <code>square slist</code> to a
      <code>shape slist</code>, then it would be possible to
      insert an arbitrary shape into the list, which would be an error.
    </p><section><h1 id="using-more-precise-types-to-address-subtyping-problems">Using more precise types to address subtyping
      problems</h1><p id="idp9258128">
        Still, the <code>total_area</code> function should be
        fine, in principle. It doesn't call <code>insert</code>,
        so it isn't making that error. To make it work, we need to use a
        more precise type that indicates we are not going to be mutating
        the list. We define a type
        <code>readonly_shape_slist</code> and confirm that we can
        coerce the list of squares.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">readonly_shape_slist</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">iterator</span> <span class="o">&gt;;;</span>
<span class="k">type</span> <span class="n">readonly_shape_slist</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">iterator</span> <span class="o">&gt;</span>
<span class="o">#</span> <span class="o">(</span><span class="n">squares</span> <span class="o">:&gt;</span> <span class="n">readonly_shape_slist</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">readonly_shape_slist</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">total_area</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">readonly_shape_slist</span><span class="o">)</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">...;;</span>
<span class="k">val</span> <span class="n">total_area</span> <span class="o">:</span> <span class="n">readonly_shape_slist</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span>   <span class="n">total_area</span> <span class="o">(</span><span class="n">squares</span> <span class="o">:&gt;</span> <span class="n">readonly_shape_slist</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">5</span><span class="o">.</span>
</pre></div><p id="idp9262512">
        Why does this work, why is a <code>square slist</code> a
        subtype of <code>readonly_shape_slist</code>. The
        reasoning is in two steps. First, the easy part is width
        subtyping: we can drop the other methods to see that
        <code>square slist</code> is a subtype of
        <code>&lt; iterator : square iterator &gt;</code>. The
        next step is to use <span><em>depth</em></span> subtyping, which,
        in its general form, says that an object type
        <code>&lt; m : t1 &gt;</code> is a subtype of a type
        <code>&lt; m : t2&gt;</code> iff <code>t1</code> is
        a subtype of <code>t2</code>. In other words, instead of
        reasoning about the number of methods in a type (the width), the
        number of methods is fixed, and we look within the method types
        themselves (the &quot;depth&quot;).
      </p><p id="idp9269872">
        In this particular case, depth subtyping on the
        <code>iterator</code> method requires that
        <code>square iterator</code> be a subtype of
        <code>shape iterator</code>. Expanding the type definition
        for the type <code>iterator</code>, we again invoke depth
        subtyping, and we need to show that the type
        <code>&lt; get : square &gt;</code> is a subtype of
        <code>&lt;get : shape &gt;</code>, which follows because
        <code>square</code> is a subtype of
        <code>shape</code>.
      </p><p id="idp9276240">
        This reasoning may seem fairly long and complicated, but it
        should be pointed out that this typing
        <span><em>works</em></span>, and in the end the type annotations
        are fairly minor. In most typed object-oriented languages, the
        coercion would simply not be possible. For example, in C++, a
        STL type <code>slist&lt;T&gt;</code> is invariant in
        <code>T</code>, it is simply not possible to use
        <code>slist&lt;square&gt;</code> where
        <code>slist&lt;shape&gt;</code> is expected (at least
        safely). The situation is similar in Java, although Java
        supports has an escape hatch that allows the program to fall
        back to dynamic typing. The situation in OCaml is much better;
        it works, it is statically checked, and the annotations are
        pretty simple.
      </p></section><section><h1 id="using-elided-types-to-address-subtyping-problems">Using elided types to address subtyping problems</h1><p id="idp9281904">
        Before we move to the next topic, there is one more thing to
        address. The typing we gave above, using
        <code>readonly_shape_slist</code>, requires that the
        caller perform an explicit coercion before calling the
        <code>total_area</code> function. We would like to give a
        better type that avoids the coercion.
      </p><p id="idp9284016">
        A solution is to use an elided type. Instead of
        <code>shape</code>, we can use the elided type
        <code>&lt; area : float; .. &gt;</code>. In fact, once we
        do this, it also becomes possible to use the
        <code>slist</code> type.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">total_area</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="n">slist</span><span class="o">)</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">...;;</span>
<span class="k">val</span> <span class="n">total_area</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="n">slist</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">total_area</span> <span class="n">squares</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">5</span><span class="o">.</span>
</pre></div><p id="idp9287856">
        This works, and it removes the need for explicit coercions. This
        type is still fairly simple, but it does have the drawback that
        the programmer needs to remember that the types
        <code>&lt; area : float; ..&gt;</code> and
        <code>shape</code> are related.
      </p><p id="idp9289920">
        OCaml supports an abbreviation in this case, but it works only
        for classes, not object types. The type expression
        <code># classname</code> is an abbreviation for an elided
        type containing all of the methods in the named class, and more.
        Since <code>shape</code> is an object type, we can't write
        <code>#shape</code>. However, if a class definition is
        available, this abbreviation can be useful. The following
        definition is exactly equivalent to the preceeding.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">cshape</span> <span class="o">=</span> <span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">cshape</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">total_area</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="o">#</span><span class="n">cshape</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">...;;</span>
<span class="k">val</span> <span class="n">total_area</span> <span class="o">:</span> <span class="o">#</span><span class="n">cshape</span> <span class="n">slist</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">total_area</span> <span class="n">squares</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">5</span><span class="o">.</span>
</pre></div></section><section><h1 id="narrowing">Narrowing</h1><p id="idp9295456">
        Narrowing, also called <span><em>down casting</em></span>, is the
        ability to coerce an object to one of its subtypes. For example,
        if we have a list of shapes <code>shape slist</code>, we
        might know (for some reason) what the actual type of each shape
        is. Perhaps we know that all objects in the list have type
        <code>square</code>. In this case,
        <span><em>narrowing</em></span> would allow the re-casting of the
        object from type <code>shape</code> to type
        <code>square</code>. Many languages support narrowing
        through dynamic type checking. For example, in Java, a coercion
        <code>(Square) x</code> is allowed if the value
        <code>x</code> has type <code>Square</code> or one
        of its subtypes; otherwise the coercion throws an exception.
      </p><p id="idp9302272">
        Narrowing is <span><em>not permitted</em></span> in OCaml.
        Period.
      </p><p id="idp9303152">
        Why? There are two reasonable explanations, one based on a
        design principle, and another technical (the technical reason is
        simple: it is hard to implement).
      </p><p id="idp9303744">
        The design argument is this: narrowing violates abstraction. In
        fact, with a structural typing system like in OCaml, narrowing
        would essentially provide the ability to enumerate the methods
        in an object. To check whether an object <code>obj</code>
        has some method <code>foo : int</code>, one would attempt
        a coercion <code>(obj :&gt; &lt; foo : int &gt;)</code>.
      </p><p id="idp9306656">
        More commonly, narrowing leads to poor object-oriented style.
        Consider the following Java code, which returns the name of a
        shape object.
      </p><pre id="idp9307232">
String GetShapeName(Shape s) {
  if (s instanceof Square) {
    return &quot;Square&quot;;
  } else if (s instanceof Circle) {
    return &quot;Circle&quot;;
  } else {
    return &quot;Other&quot;;
  }
}
</pre><p id="idp9308240">
        Most programmers would consider this code to be
        &quot;wrong.&quot; Instead of performing a case analysis on the
        type of object, it would be better to define a method to return
        the name of the shape. Instead of calling
        <code>GetShapeName(s)</code>, we should call
        <code>s.Name()</code> instead.
      </p><p id="idp9310720">
        However, the situation is not always so obvious. The following
        code checks whether an array of shapes looks like a
        &quot;barbell,&quot; composed to two <code>Circle</code>
        objects separated by a <code>Line</code>, where the
        circles have the same radius.
      </p><pre id="idp9312912">
boolean IsBarBell(Shape[] s) {
  return s.length == 3 &amp;&amp; (s[0] instanceof Circle) &amp;&amp;
    (s[1] instanceof Line) &amp;&amp; (s[2] instanceof Circle) &amp;&amp;
    ((Circle) s[0]).radius() == ((Circle) s[2]).radius();
}
</pre><p id="idp9313808">
        In this case, it is much less clear how to augment the
        <code>Shape</code> class to support this kind of pattern
        analysis. It is also not obvious that object-oriented
        programming is well-suited for this situation. Pattern matching
        seems like a better fit.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">is_bar_bell</span> <span class="o">=</span> <span class="k">function</span>
 <span class="o">|</span> <span class="o">[</span><span class="nc">Circle</span> <span class="n">r1</span><span class="o">;</span> <span class="nc">Line</span> <span class="o">_;</span> <span class="nc">Circle</span> <span class="n">r2</span><span class="o">]</span> <span class="k">when</span> <span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span> <span class="o">-&gt;</span> <span class="bp">true</span>
 <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span><span class="o">;;</span>
</pre></div><p id="idp9316304">
        Regardless, there is a solution if you find yourself in this
        situation, which is to augment the classes with variants. You
        can define a method <code>variant</code> that injects the
        actual object into a variant type.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">variant</span> <span class="o">:</span> <span class="n">repr</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">&gt;</span>
<span class="ow">and</span> <span class="n">circle</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">variant</span> <span class="o">:</span> <span class="n">repr</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="n">radius</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;</span>
<span class="ow">and</span> <span class="n">line</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">variant</span> <span class="o">:</span> <span class="n">repr</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="n">length</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;</span>
<span class="ow">and</span> <span class="n">repr</span> <span class="o">=</span>
 <span class="o">|</span> <span class="nc">Circle</span> <span class="k">of</span> <span class="n">circle</span>
 <span class="o">|</span> <span class="nc">Line</span> <span class="k">of</span> <span class="n">line</span><span class="o">;;</span>
 
<span class="k">let</span> <span class="n">is_bar_bell</span> <span class="o">=</span> <span class="k">function</span>
 <span class="o">|</span> <span class="o">[</span><span class="n">s1</span><span class="o">;</span> <span class="n">s2</span><span class="o">;</span> <span class="n">s3</span><span class="o">]</span> <span class="o">-&gt;</span>
   <span class="o">(</span><span class="k">match</span> <span class="n">s1</span><span class="o">#</span><span class="n">variant</span><span class="o">,</span> <span class="n">s2</span><span class="o">#</span><span class="n">variant</span><span class="o">,</span> <span class="n">s3</span><span class="o">#</span><span class="n">variant</span> <span class="k">with</span>
     <span class="o">|</span> <span class="nc">Circle</span> <span class="n">c1</span><span class="o">,</span> <span class="nc">Line</span> <span class="o">_,</span> <span class="nc">Circle</span> <span class="n">c2</span> <span class="k">when</span> <span class="n">c1</span><span class="o">#</span><span class="n">radius</span> <span class="o">==</span> <span class="n">c2</span><span class="o">#</span><span class="n">radius</span> <span class="o">-&gt;</span> <span class="bp">true</span>
     <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span><span class="o">)</span>
 <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span><span class="o">;;</span>
</pre></div><p id="idp9319488">
        This pattern works, but it has drawbacks. In particular, the
        recursive type definition should make it clear that this pattern
        is essentially equivalent to using variants, and that objects do
        not provide much value here.
      </p></section><section><h1 id="binary-methods">Binary methods</h1><p id="idp9321424">
        A <span><em>binary method</em></span> is a method that takes an
        object of <code>self</code> type. One common example is
        defining a method for equality.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">square</span> <span class="n">w</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> 
    <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">width</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">square</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="k">object</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">method</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">rectangle</span> <span class="n">w</span> <span class="n">h</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
    <span class="k">method</span> <span class="n">height</span> <span class="o">=</span> <span class="n">h</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">height</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">width</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="o">#</span><span class="n">height</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">height</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">...</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">)#</span><span class="n">equals</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">rectangle</span> <span class="mi">5</span> <span class="mi">6</span><span class="o">)#</span><span class="n">equals</span> <span class="o">(</span><span class="k">new</span> <span class="n">rectangle</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9325296">
        This works, but there is a problem lurking here. The method
        <code>equals</code> takes an object of the exact type
        <code>square</code> or <code>rectangle</code>.
        Because of this, we can't define a common base class
        <code>shape</code> that also includes an equality method.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">sq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="o">(</span><span class="n">sq</span> <span class="o">:&gt;</span> <span class="n">shape</span><span class="o">);;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">13</span><span class="o">:</span>
  <span class="o">(</span><span class="n">sq</span> <span class="o">:&gt;</span> <span class="n">shape</span><span class="o">);;</span>
  <span class="o">^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Type</span> <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">square</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span>
       <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">subtype</span> <span class="k">of</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">&gt;</span> 
<span class="nc">Type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">&gt;</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">subtype</span> <span class="k">of</span>
  <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">square</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span> 
</pre></div><p id="idp9330336">
        The problem is that a <code>square</code> expects to be
        compared with a <code>square</code>, not an arbitrary
        shape; similarly for <code>rectangle</code>.
      </p><p id="idp9332976">
        This problem is fundamental. Many languages solve it either with
        narrowing (with dynamic type checking), or by method
        overloading. Since OCaml has neither of these, what can we do?
      </p><p id="idp9333584">
        One proposal we could consider is, since the problematic method
        is equality, why not just drop it from the base type
        <code>shape</code> and use polymorphic equality instead?
        Unfortunately, the builtin equality has very poor behavior when
        applied to objects.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">(</span><span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">end</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">end</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9336000">
        The problem here is that the builtin polymorphic equality
        compares the method implementations, not their return values.
        The method implementations (the function values that implement
        the methods) are different, so the equality comparison is false.
        There are other reasons not to use the builtin polymorphic
        equality, but these false negatives are a showstopper.
      </p><p id="idp9336816">
        If we want to define equality for shapes in general, the
        remaining solution is to use the same approach as we described
        for narrowing. That is, introduce a
        <span><em>representation</em></span> type implemented using
        variants, and implement the comparison based on the
        representation type.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">shape_repr</span> <span class="o">=</span>
 <span class="o">|</span> <span class="nc">Square</span> <span class="k">of</span> <span class="kt">int</span>
 <span class="o">|</span> <span class="nc">Circle</span> <span class="k">of</span> <span class="kt">int</span>
 <span class="o">|</span> <span class="nc">Rectangle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">;;</span>
 
<span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;;;</span>

<span class="k">class</span> <span class="n">square</span> <span class="n">w</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
  <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
  <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">method</span> <span class="n">repr</span> <span class="o">=</span> <span class="nc">Square</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="n">shape</span><span class="o">)</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">repr</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">repr</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9339680">
        The binary method <code>equals</code> is now implemented
        in terms of the concrete type <code>shape_repr</code>. In
        fact, the objects are now isomorphic to the
        <code>shape_repr</code> type. When using this pattern, you
        will not be able to hide the <code>repr</code> method, but
        you can hide the type definition using the module system.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Shapes</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">shape_repr</span>
  <span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">&gt;</span>
  
  <span class="k">class</span> <span class="n">square</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span>
    <span class="k">object</span>
      <span class="k">method</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span>
      <span class="k">method</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span>
      <span class="k">method</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span>
      <span class="k">method</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">shape_repr</span> <span class="o">=</span> <span class="nc">Square</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Circle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Rectangle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
  <span class="o">...</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section></section><section><h1 id="private-methods">Private methods</h1><p id="idp9346192">
      Methods can be declared <span><em>private</em></span>, which means
      that they may be called by subclasses, but they are not visible
      otherwise (similar to a <span><em>protected</em></span> method in
      C++).
    </p><p id="idp9347632">
      To illustrate, let's build a class <code>vector</code> that
      contains an array of integers, resizing the storage array on
      demand. The field <code>values</code> contains the actual
      values, and the <code>get</code>, <code>set</code>,
      and <code>length</code> methods implement the array access.
      For clarity, the resizing operation is implemented as a private
      method <code>ensure_capacity</code> that resizes the array
      if necessary.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">vector</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">val</span> <span class="k">mutable</span> <span class="n">values</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[||]</span>
  
     <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">set</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span>
        <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="n">i</span><span class="o">;</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">x</span>
     <span class="k">method</span> <span class="n">length</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span>
  
     <span class="k">method</span> <span class="k">private</span> <span class="n">ensure_capacity</span> <span class="n">i</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">self</span><span class="o">#</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="k">then</span>
           <span class="k">let</span> <span class="n">new_values</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">in</span>
           <span class="nn">Array</span><span class="p">.</span><span class="n">blit</span> <span class="n">values</span> <span class="mi">0</span> <span class="n">new_values</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span><span class="o">);</span>
           <span class="n">values</span> <span class="o">&lt;-</span> <span class="n">new_values</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">get</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="kt">int</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="mi">10</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span>
  <span class="n">v</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="mi">10</span><span class="o">;;</span>
  <span class="o">^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="n">vector</span>
       <span class="nc">It</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">ensure_capacity</span>
</pre></div><p id="idp9354576">
      To be precise, the method <code>ensure_capacity</code> is
      part of the class type, but it is not part of the object type.
      This means the object <code>v</code> has no method
      <code>ensure_capacity</code>. However, it is available to
      subclasses. We can extend the class, for example, to include a
      method <code>swap</code> that swaps two elements.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">swappable_vector</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">inherit</span> <span class="n">vector</span>

     <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
        <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="o">(</span><span class="n">max</span> <span class="n">i</span> <span class="n">j</span><span class="o">);</span>
        <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">);</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9359424">
      Yet another reason for private methods is to factor the
      implementation and support recursion. Moving along with this
      example, let's build a binary heap, which is a binary tree in heap
      order: where the label of parent elements is smaller than the
      labels of its children. One efficient implementation is to use an
      array to represent the values, where the root is at index 0, and
      the children of a parent node at index <code>i</code> are at
      indexes <code>2 * i</code> and <code>2 * i + 1</code>.
      To insert a node into the tree, we add it as a leaf, and then
      recursively move it up the tree until we restore heap order.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">binary_heap</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">values</span> <span class="o">=</span> <span class="k">new</span> <span class="n">swappable_vector</span>

   <span class="k">method</span> <span class="n">min</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">values</span><span class="o">#</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
         <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;heap is empty&quot;</span><span class="o">);</span>
      <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="mi">0</span>

   <span class="k">method</span> <span class="n">add</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">values</span><span class="o">#</span><span class="n">length</span> <span class="k">in</span>
      <span class="n">values</span><span class="o">#</span><span class="n">set</span> <span class="n">pos</span> <span class="n">x</span><span class="o">;</span>
      <span class="n">self</span><span class="o">#</span><span class="n">move_up</span> <span class="n">pos</span>

   <span class="k">method</span> <span class="k">private</span> <span class="n">move_up</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span>
         <span class="k">let</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="n">parent</span> <span class="k">then</span> <span class="k">begin</span>
               <span class="n">values</span><span class="o">#</span><span class="n">swap</span> <span class="n">i</span> <span class="n">parent</span><span class="o">;</span>
               <span class="n">self</span><span class="o">#</span><span class="n">move_up</span> <span class="n">parent</span>
            <span class="k">end</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9364512">
      The method <code>move_up</code> implements the process of
      restoring heap order as a recursive method (though it would be
      straightforward avoid the recursion and use iteration here).
    </p><p id="idp9365792">
      The key property of private methods is that they are visible to
      subclasses, but not anywhere else. If you want the stronger
      guarantee that a method is <span><em>really</em></span> private,
      not even accessible in subclasses, you can use an explicit typing
      that omits the method. In the following code, the
      <code>move_up</code> method is explicitly omitted from the
      object type, and it can't be invoked in subclasses.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">binary_heap</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">min</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">method</span> <span class="k">private</span> <span class="n">move_up</span> <span class="n">i</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="virtual-classes-and-methods">Virtual classes and methods</h1><p id="idp9370448">
      A <span><em>virtual</em></span> class is a class where some methods
      or fields are declared, but not implemented. This should not be
      confused with the word &quot;virtual&quot; as it is used in C++.
      In C++, a &quot;virtual&quot; method uses dynamic dispatch,
      regular non-virtual methods use static dispatched. In OCaml,
      <span><em>all</em></span> methods use dynamic dispatch, but the
      keyword <span><em>virtual</em></span> means the method or field is
      not implemented.
    </p><p id="idp9373040">
      In the previous section, we defined a class
      <code>swappable_vector</code> that inherits from
      <code>array_vector</code> and adds a <code>swap</code>
      method. In fact, the <code>swap</code> method could be
      defined for any object with <code>get</code> and
      <code>set</code> methods; it doesn't have to be the specific
      class <code>array_vector</code>.
    </p><p id="idp9378592">
      One way to do this is to declare the
      <code>swappable_vector</code> abstractly, declaring the
      methods <code>get</code> and <code>set</code>, but
      leaving the implementation for later. However, the
      <code>swap</code> method can be defined immediately.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="n">abstract_swappable_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="n">i</span> <span class="k">in</span>
      <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="n">i</span> <span class="o">(</span><span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="n">j</span><span class="o">);</span>
      <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="n">j</span> <span class="n">tmp</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9383520">
      At some future time, we may settle on a concrete implementation
      for the vector. We can inherit from the
      <code>abstract_swappable_bvector</code> to get the
      <code>swap</code> method &quot;for free.&quot; Here's one
      implementation using arrays.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">array_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">inherit</span> <span class="n">abstract_swappable_vector</span>

   <span class="k">val</span> <span class="k">mutable</span> <span class="n">values</span> <span class="o">=</span> <span class="o">[||]</span>
   <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
   <span class="k">method</span> <span class="n">set</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span>
      <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="n">i</span><span class="o">;</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">x</span>
   <span class="k">method</span> <span class="n">length</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span>

   <span class="k">method</span> <span class="k">private</span> <span class="n">ensure_capacity</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">self</span><span class="o">#</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="k">then</span>
         <span class="k">let</span> <span class="n">new_values</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">in</span>
            <span class="nn">Array</span><span class="p">.</span><span class="n">blit</span> <span class="n">values</span> <span class="mi">0</span> <span class="n">new_values</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span><span class="o">);</span>
            <span class="n">values</span> <span class="o">&lt;-</span> <span class="n">new_values</span>
<span class="k">end</span>
</pre></div><p id="idp9387712">
      Here's a different implementation using
      <code>HashTbl</code>.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">hash_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">inherit</span> <span class="n">abstract_swappable_vector</span>

   <span class="k">val</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">19</span>

   <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="n">i</span> <span class="k">with</span>
         <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="mi">0</span>

   <span class="k">method</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">table</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9390208">
      One way to view a <code>virtual</code> class is that it is
      like a functor, where the &quot;inputs&quot; are the declared, but
      not defined, virtual methods and fields. The functor application
      is implemented through inheritance, when virtual methods are given
      concrete implementations.
    </p><p id="idp9391968">
      We've been mentioning that fields can be virtual too. Here is
      another implementation of the swapper, this time with direct
      access to the array of values.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="n">abstract_swappable_array_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="k">virtual</span> <span class="n">values</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span>
   <span class="k">method</span> <span class="k">private</span> <span class="k">virtual</span> <span class="n">ensure_capacity</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

   <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
      <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="o">(</span><span class="n">max</span> <span class="n">i</span> <span class="n">j</span><span class="o">);</span>
      <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">);</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9393808">
      This level of dependency on the implementation details is
      possible, but it is hard to justify the use of a virtual class --
      why not just define the <code>swap</code> method as part of
      the concrete class? Virtual classes are better suited for
      situations where there are multiple (useful) implementations of
      the virtual parts. In most cases, this will be public virtual
      methods.
    </p></section><section><h1 id="multiple-inheritance">Multiple inheritance</h1><p id="idp9396528">
      When a class inherits from more than one superclass, it is using
      <span><em>multiple inheritance</em></span>. Multiple inheritance
      extends the variety of ways in which classes can be combined, and
      it can be quite useful, particularly with virtual classes.
      However, it can be tricky to use, particularly when the
      inheritance hierarchy is a graph rather than a tree, so it should
      be used with care.
    </p><section><h1 id="how-names-are-resolved">How names are resolved</h1><p id="idp9398864">
        The main &quot;trickiness&quot; of multiple inheritance is due
        to naming -- what happens when a method or field with some name
        is defined in more than one class?
      </p><p id="idp9399648">
        If there is one thing to remember about inheritance in OCaml, it
        is this: inheritance is like textual inclusion. If there is more
        than one definition for a name, the last definition wins. Let's
        look at some artificial, but illustrative, examples.
      </p><p id="idp9400336">
        First, let's consider what happens when we define a method more
        than once. In the following example, the method
        <code>get</code> is defined twice; the second definition
        &quot;wins,&quot; meaning that it overrides the first one.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m1</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="k">method</span> <span class="n">f</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">get</span>
   <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m1</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">m1</span><span class="o">)#</span><span class="n">f</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9402976">
        Fields have similar behavior, though the compiler produces a
        warning message about the override.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m2</span> <span class="o">=</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m2</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
     <span class="k">method</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">69</span><span class="o">-</span><span class="mi">74</span><span class="o">:</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
         <span class="o">^^^^^</span>
<span class="nc">Warning</span> <span class="mi">13</span><span class="o">:</span> <span class="n">the</span> <span class="n">instance</span> <span class="n">variable</span> <span class="n">x</span> <span class="n">is</span> <span class="n">overridden</span><span class="o">.</span>
<span class="nc">The</span> <span class="n">behaviour</span> <span class="n">changed</span> <span class="k">in</span> <span class="n">ocaml</span> <span class="mi">3</span><span class="o">.</span><span class="mi">10</span> <span class="o">(</span><span class="n">previous</span> <span class="n">behaviour</span> <span class="n">was</span> <span class="n">hiding</span><span class="o">.)</span>
<span class="k">class</span> <span class="n">m2</span> <span class="o">:</span> <span class="k">object</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">m2</span><span class="o">)#</span><span class="n">f</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9404800">
        Of course, it is unlikely that you will define two methods or
        two fields of the same name in the same class. However, the
        rules for inheritance follow the same pattern: the last
        definition wins. In the following definition, the
        <code>inherit</code> declaration comes last, so the method
        definition <code>method get = 2</code> overrides the
        previous definition, always returning 2.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m4</span> <span class="o">=</span> <span class="k">object</span> <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m5</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">x'</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">x'</span>
    <span class="k">inherit</span> <span class="n">m4</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m5</span> <span class="o">:</span> <span class="k">object</span> <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">m5</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m5</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9408544">
        To reiterate, to understand what inheritance means, replace each
        <code>inherit</code> directive with its definition, and
        take the last definition of each method or field. This holds
        even for private methods. However, it does
        <span><em>not</em></span> hold for private methods that are
        &quot;really&quot; private, meaning that they have been hidden
        by a type constraint. In the following definitions, there are
        three definitions of the private method <code>g</code>.
        However, the definition of <code>g</code> in
        <code>m8</code> is not overridden, because it is not part
        of the class type for <code>m8</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m6</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m6</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f1</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m7</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m7</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f2</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m8</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m8</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m9</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">inherit</span> <span class="n">m6</span>
     <span class="k">inherit</span> <span class="n">m7</span>
     <span class="k">inherit</span> <span class="n">m8</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m9</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">f1</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">f2</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">m9</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m9</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">f1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">f3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></section><section><h1 id="mixins">Mixins</h1><p id="idp9417248">
        When should you use multiple inheritance? If you ask multiple
        people, you're likely to get multiple (perhaps heated) answers.
        Some will argue that multiple inheritance is overly complicated;
        others will argue that inheritance is problematic in general,
        and one should use object composition instead. But regardless of
        who you talk to, you will rarely hear that multiple inheritance
        is great and you should use it widely.
      </p><p id="idp9418128">
        In any case, if you're programming with objects, there's one
        general pattern for multiple inheritance that is both useful and
        reasonably simple, the <span><em>mixin</em></span> pattern.
        Generically, a <span><em>mixin</em></span> is just a virtual
        class that implements a feature based on another one. If you
        have a class that implements methods <span><em>A</em></span>, and
        you have a mixin <span><em>M</em></span> that provides methods
        <span><em>B</em></span> from <span><em>A</em></span>, then you can
        inherit from <span><em>M</em></span> -- &quot;mixing&quot; it in
        -- to get features <span><em>B</em></span>.
      </p><p id="idp9422368">
        That's too abstract, so let's give an example based on
        collections. In Section XXX:Objecttypes, we introduced the
        <span><em>iterator</em></span> pattern, where an
        <span><em>iterator</em></span> object is used to enumerate the
        elements of a collection. Lots of containers can have iterators,
        singly-linked lists, dictionaries, vectors, etc.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">vector</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">deque</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">]</span> <span class="n">map</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="o">...</span>
</pre></div><p id="idp9425808">
        The collections are different is some ways, but they share a
        common pattern for iteration that we can re-use. For a simple
        example, let's define a mixin that implements an arithmetic sum
        for a collection of integers.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="k">virtual</span> <span class="n">int_sum_mixin</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="k">virtual</span> <span class="n">iterator</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">iterator</span>
     <span class="k">method</span> <span class="n">sum</span> <span class="o">=</span>
        <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">total</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
        <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
           <span class="n">total</span> <span class="o">:=</span> <span class="o">!</span><span class="n">total</span> <span class="o">+</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
           <span class="n">it</span><span class="o">#</span><span class="n">next</span>
        <span class="k">done</span><span class="o">;</span>
        <span class="o">!</span><span class="n">total</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">int_slist</span> <span class="o">=</span>
  <span class="k">object</span>
     <span class="k">inherit</span> <span class="o">[</span><span class="kt">int</span><span class="o">]</span> <span class="n">slist</span>
     <span class="k">inherit</span> <span class="n">int_sum_mixin</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">int_slist</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">l</span> <span class="o">:</span> <span class="n">int_slist</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="mi">12</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">sum</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">int_deque</span> <span class="o">=</span>
  <span class="k">object</span>
     <span class="k">inherit</span> <span class="o">[</span><span class="kt">int</span><span class="o">]</span> <span class="n">deque</span>
     <span class="k">inherit</span> <span class="n">int_sum_mixin</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9428288">
        In this particular case, the mixin works only for a collection
        of integers, so we can't add the mixin to the polymorphic class
        definition <code>['a] slist</code> itself. However, the
        result of using the mixin is that the integer collection has a
        method <code>sum</code>, and it is done with very little
        of the fuss we would need if we used object composition instead.
      </p><p id="idp9430448">
        The mixin pattern isn't limited to non-polymorphic classes, of
        course. We can use it to implement generic features as well. The
        following mixin defines functional-style iteration in terms of
        the imperative iterator pattern.
      </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">fold_mixin</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
   <span class="k">method</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="o">.</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span>
            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">x</span> <span class="k">in</span>
            <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
            <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
               <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">!</span><span class="n">y</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
               <span class="n">it</span><span class="o">#</span><span class="n">next</span>
            <span class="k">done</span><span class="o">;</span>
            <span class="o">!</span><span class="n">y</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>

<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_with_fold</span> <span class="o">=</span>
<span class="k">object</span>
   <span class="k">inherit</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span>
   <span class="k">inherit</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">fold_mixin</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt03.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="installation.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>