<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 8. Imperative Programming / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha3',
                        page: 'imperative\u002Dprogramming\u002D1.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">3. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">4. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">5. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">6. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">7. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html" class="here">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">9. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 8. Imperative Programming</h1>
                
                

    <p id="idp8326992">
    Most of the code shown so far in this book, and indeed, most OCaml
    code in general, is <span><em>pure</em></span>. Pure code works
    without mutating the program's internal state, performing I/O,
    reading the clock, or in any other way interacting with changeable
    parts of the world. Thus, a pure function behaves like a
    mathematical function, always returning the same results when given
    the same inputs. <span><em>Imperative</em></span> code, on the other
    hand, operates by side-effects that modify a program's internal
    state or interacts with the outside world, and so can have a
    different effect, and return different results, every time they're
    called.
  </p><p id="idp8329152">
    Pure code is the default in OCaml, and for good reason --- it's
    generally easier to reason about, less error prone and more
    composeable. But imperative code is of fundamental importance to any
    practical programming language because real-world tasks require that
    you interact with the outside world, whether by receiving a network
    packet or by writing data to a file. Imperative programming can also
    be important for performance. While pure code is quite efficient in
    OCaml, there are many algorithms that can only be implemented
    efficiently using imperative techniques.
  </p><p id="idp8330160">
    OCaml offers a happy compromise here, making it easy and natural to
    program in a pure style, but also providing great support for
    imperative programming where you need it. This chapter will walk you
    through OCaml's imperative features, and help you use them to their
    fullest.
  </p><section><h1 id="a-simple-dictionary">A simple dictionary</h1><p id="idp8331744">
      We'll walk through the implementation of a simple imperative
      dictionary, <span><em>i.e.</em></span>, a mutable mapping from keys
      to values. Both Core and OCaml's standard library provide multiple
      data structures for implementing such dictionaries, and for most
      real world tasks, you should use one of those. But we'll walk
      through this nonetheless as a way of seeing OCaml's imperative
      constructs in action.
    </p><p id="idp8332960">
      We'll implement our dictionary as a hash table, based on an
      <span><em>open hashing</em></span> scheme, which is to say it will
      be structured as an array of buckets, with each bucket containing
      a list of key/value pairs that have been hashed into that bucket.
      For simplicity's sake, we'll use a fixed-length bucket array,
      though growing the bucket array as more elements are added would
      be necessary for a practical implementation.
    </p><p id="idp8334208">
      First, we'll write down the <code>mli</code> for our
      dictionary.
    </p><div class="highlight"><pre><span class="c">(* file: dictionary.mli *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">length</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">add</span>    <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">find</span>   <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">iter</span>   <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</pre></div><p id="idp8336432">
      The type <code>('a, 'b) t</code> is used to represent a
      dictionary with keys of type <code>'a</code> and data of
      type <code>'b</code>. The <code>mli</code> also
      includes a collection of helper functions. Notice that a number of
      the functions, in particular, ones like <code>add</code>
      that modify the dictionary, return unit. This is typical of
      functions that act by side-effect.
    </p><p id="idp8340288">
      The implementation is shown below. We'll go through the code bit
      by bit, explaining different imperative constructs as they show
      up.
    </p><div class="highlight"><pre><span class="c">(* file: dictionary.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="n">length</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
                    <span class="n">buckets</span><span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="kt">list</span> <span class="kt">array</span><span class="o">;</span>
                  <span class="o">}</span>
</pre></div><p id="idp8341888">
      Our first step is to define the type of a dictionary as a record
      with two fields. The first field, <code>length</code> is
      declared as mutable. In OCaml, records are immutable by default,
      but individual fields are mutable when marked as such. The second
      field, <code>buckets</code>, is immutable, but contains an
      array, which is itself a mutable data structure, as we'll see.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">17</span>
<span class="k">let</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span><span class="o">)</span> <span class="ow">mod</span> <span class="n">num_buckets</span>

<span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="o">{</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">buckets</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">len</span><span class="o">:</span><span class="n">num_buckets</span> <span class="bp">[]</span><span class="o">;</span>
  <span class="o">}</span>

<span class="k">let</span> <span class="n">length</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span>

<span class="k">let</span> <span class="n">find</span> <span class="n">t</span> <span class="n">key</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">find_map</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">hash_bucket</span> <span class="n">key</span><span class="o">)</span>
    <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key'</span><span class="o">,</span><span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">key'</span> <span class="o">=</span> <span class="n">key</span> <span class="k">then</span> <span class="nc">Some</span> <span class="n">data</span> <span class="k">else</span> <span class="nc">None</span><span class="o">)</span>
</pre></div><p id="idp8345392">
      Now we define the function for choosing a hash-bucket based on the
      key. We do this using <code>Hashtbl.hash</code> to compute
      hash values. <code>Hashtbl.hash</code> is a special function
      provided by the OCaml runtime that can compute a hash for almost
      any OCaml value. It's type is <code>'a -&gt; int</code>, so
      it can be applied to a value of any type. (While it can be applied
      to any type, it won't succeed for all values.
      <code>Hashtbl.hash</code> will throw an exception if it
      encounters a value it can't handle, like a function or a value
      from a C libraries that lives outside the OCaml heap.)
    </p><p id="idp8348864">
      There's also code for <code>create</code>, which creates an
      empty dictionary, <code>length</code>, which grabs the
      length from the corresponding record field, and
      <code>find</code>, which looks for a matching key in the
      table using <code>List.find_map</code> on the corresponding
      bucket. (<code>List.find_map</code> takes a list, and a
      function for transforming the list elements to options, returning
      a list of the contents of the returned <code>Some</code>s.)
      In <code>find</code>, you'll notice that we make use of the
      <code>array.(index)</code> syntax for looking up a value in
      an array.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">iter</span> <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span><span class="o">)</span>
  <span class="k">done</span>
</pre></div><p id="idp8355680">
<code>iter</code> is designed to walk over all the entries
      in the dictionary. In particular, <code>iter d ~f</code>
      will call <code>f</code> for each key/value pair in
      dictionary <code>d</code>. Note that <code>f</code> is
      expected to return <code>unit</code>, since it is expected
      to work by side effect rather than by returning a value.
    </p><p id="idp8360016">
      The code for <code>iter</code> uses two forms of iteration:
      a <code>for</code> loop to iterate over the array of
      buckets; and within that loop, and a call to
      <code>List.iter</code> to walk over the list of values in a
      given bucket. <code>for</code> loops are not of fundamental
      importance to the language: instead of using
      <code>for</code>, we could have implemented the outer loop
      using the <code>Array.iter</code>, which in turn could be
      implemented as a recursive function. But <code>for</code> is
      syntactically convenient, and is often more familiar and idiomatic
      when coding imperatively.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">bucket_has_key</span> <span class="n">t</span> <span class="n">i</span> <span class="n">key</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key'</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="n">key'</span> <span class="o">=</span> <span class="n">key</span><span class="o">)</span>

<span class="k">let</span> <span class="n">add</span> <span class="n">t</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">replace</span> <span class="o">=</span> <span class="n">bucket_has_key</span> <span class="n">t</span> <span class="n">i</span> <span class="n">key</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">filtered_bucket</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">replace</span> <span class="k">then</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key'</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="n">key'</span> <span class="o">&lt;&gt;</span> <span class="n">key</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="o">::</span> <span class="n">filtered_bucket</span><span class="o">;</span>
  <span class="k">if</span> <span class="n">not</span> <span class="n">replace</span> <span class="k">then</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">let</span> <span class="n">remove</span> <span class="n">t</span> <span class="n">key</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">not</span> <span class="o">(</span><span class="n">bucket_has_key</span> <span class="n">t</span> <span class="n">i</span> <span class="n">key</span><span class="o">)</span> <span class="k">then</span> <span class="bp">()</span>
  <span class="k">else</span> <span class="o">(</span>
    <span class="k">let</span> <span class="n">filtered_bucket</span> <span class="o">=</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key'</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="n">key'</span> <span class="o">&lt;&gt;</span> <span class="n">key</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="n">t</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">filtered_bucket</span><span class="o">;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="o">)</span>
</pre></div><p id="idp8366960">
      The above code is for adding and removing mappings from the
      dictionary. This section is made more complicated by the fact that
      we need to detect whether we are overwriting or removing an
      existing binding, so we can decide whether
      <code>t.length</code> needs to be changed. The helper
      function <code>bucket_has_key</code> is used for this
      purpose.
    </p><p id="idp8368864">
      We use the <code>&lt;-</code> operator for updating elements
      of an array (<code>array.(i) &lt;- expr</code>) and for
      updating a record field
      (<code>record.field &lt;- expression</code>).
    </p><p id="idp8371120">
      We also use a single semicolon, <code>;</code>, as a
      sequencing operator, to allow us to do two side-effecting
      operations in a row: first, update the bucket, then update the
      count. We could have done this using let bindings:
    </p><p id="idp8372352">
<code>ocaml     let () = t.buckets.(i) &lt;- filtered_bucket in     let () = t.length &lt;- t.length - 1 in</code>
      but <code>;</code> is more idiomatic.
    </p><p id="idp8374224">
      In general, when a sequence expression
      <code>expr1; expr2</code> is evaluated,
      <code>expr1</code> is evaluated first, and then
      <code>expr2</code>. The expression <code>expr1</code>
      must have type <code>unit</code>, and the the value of
      <code>expr2</code> is returned as the value of the entire
      sequence. For example, the sequence
      <code>print_string &quot;hello world&quot;; 1 + 2</code>
      first prints the string
      <code>&quot;hello world&quot;</code>, then returns the
      integer <code>3</code>.
    </p><p id="idp8380432">
      It's also worth noting that <code>;</code> is a
      <span><em>separator</em></span>, not a terminator as it is in C or
      Java. The compiler is somewhat relaxed about parsing a terminating
      semicolon, so it may work for you, but you should not rely on it.
      Here is an example where we're using <code>;</code> as if it
      were a terminator
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">print_string</span> <span class="s2">&quot;Hello world</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="k">in</span> <span class="n">i</span><span class="o">;;</span>
<span class="nc">Hello</span> <span class="n">world</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8383744">
      Also note, the precedence of a <code>match</code> expression
      is very low, so to separate it from the following assignment
      <code>l := Some new_front</code>, we surround the match in a
      <code>begin ... end</code> bracketing (we could also use
      parentheses). If we did not, the final assignment would become
      part of the <code>None -&gt; ...</code> case, which is not
      what we want.
    </p><p id="idp8386848">
      Note also that we do all of the side-effecting operations at the
      very end of each function. This is good practice because it
      minimizes the chance that such operations will be interrupted with
      an exception, leaving the data structure in an inconsistent state.
    </p></section><section><h1 id="primitive-mutable-data">Primitive mutable data</h1><p id="idp8388544">
      We've already encountered two different forms of mutable data:
      records with mutable fields, and arrays. These are two of the
      building blocks of imperative programming in OCaml. We discuss
      those, and a few others, below.
    </p><section><h1 id="array-like-data">Array-like data</h1><p id="idp8390080">
        OCaml supports a number of array-like data structures;
        <span><em>i.e.</em></span>, integer-indexed containers. The
        <code>array</code> type is one example, and the
        <code>Array</code> module comes with a variety of mutable
        operations on arrays, including <code>Array.set</code>,
        which modifies an individual element, and
        <code>Array.blit</code>, which efficiently copies a range
        of values in an array.
      </p><p id="idp8393712">
        Arrays also come with a special syntax for getting an element
        from an array: <code>array.(index)</code>; and for setting
        an element: <code>array.(index) &lt;- expr</code>. Literal
        arrays can be declared using <code>[|</code> and
        <code>|]</code> as delimiters. Thus,
        <code>[| 1; 2; 3 |]</code> is an integer array.
      </p><p id="idp8397328">
        Strings are essentially byte-arrays, with some extra useful
        functions in the <code>String</code> module for dealing
        with textual data in this form. The main reason to use a
        <code>String.t</code> rather than a
        <code>Char.t array</code> (a <code>Char.t</code> is
        an 8-bit character) is that the former is considerably more
        space efficient; an array uses one word --- 8 bytes on a 64-bit
        machine --- to store a single entry, whereas strings use one
        byte per character.
      </p><p id="idp8400688">
        Strings also come with their own syntax for getting and setting
        values: <code>string.[index]</code> and
        <code>string.[index] &lt;- expr</code> respectively, and
        string literals are bounded by quotes.
      </p><p id="idp8402528">
        A bigarray is a handle to a block of memory stored outside of
        the OCaml heap. These are mostly useful for interacting with C
        or Fortran libraries, and are discussed in
        <a href="">???</a>.
        Bigarrays too have their own getting and setting syntax:
        <code>bigarray.{index}</code> and
        <code>bigarray.{index} &lt;- expr</code>.
      </p></section><section><h1 id="mutable-record-and-object-fields-and-ref-cells">Mutable record and object fields and ref cells</h1><p id="idp8405984">
        As we've seen, records are immutable by default, but individual
        record fields can be declared as mutable. These mutable fields
        can be set using the <code>&lt;-</code> operator,
        <span><em>i.e.</em></span>,
        <code>record.field &lt;- expr</code>.
      </p><p id="idp8408192">
        As we'll see in
        <a href="object-oriented-programming.html">Chapter 9, <i>Object Oriented Programming</i></a>, fields
        of an object can similarly be declared as mutable, and can then
        be modified in much the same way as with records.
      </p><section><h1 id="ref-cells">Ref Cells</h1><p id="idp8410112">
          Variables in OCaml are never mutable --- they can refer to
          mutable data, but what the variable points to can't be
          changed. Sometimes, though, you want to do exactly what you
          would do with a mutable variable in another language: define a
          single, mutable value. In OCaml this is typically achieved
          using a <code>ref</code>, which is essentially a
          container with a single, mutable value.
        </p><p id="idp8411600">
          The standard library defines the following operators for
          working with refs.
        </p><ul><li><p id="idp8412624">
<code>ref expr</code> constructs a reference cell
              containing the value defined by the expression
              <code>expr</code>.
            </p></li><li><p id="idp8414768">
<code>!refcell</code> returns the contents of the
              reference cell.
            </p></li><li><p id="idp8416240">
<code>refcell := expr</code> replaces the contents
              of the reference cell.
            </p></li></ul><p id="idp8417600">
          You can see these in action below.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">1</span><span class="o">}</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8418992">
          There's nothing magic about a <code>ref</code>: it's
          really just a record. The <code>ref</code> type and its
          associated operations are defined as follows.
        </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="n">contents</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">}</span>

<span class="k">let</span> <span class="n">ref</span> <span class="n">x</span> <span class="o">=</span> <span class="o">{</span> <span class="n">contents</span> <span class="o">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="k">let</span> <span class="o">(!)</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">contents</span>
<span class="k">let</span> <span class="o">(:=)</span> <span class="n">r</span> <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="n">x</span>
</pre></div></section></section><section><h1 id="foreign-functions">Foreign functions</h1><p id="idp8422976">
        Another source of imperative operations in OCaml is resources
        that come from interfacing with some external library through
        OCaml's foreign function interface (FFI). The FFI opens OCaml up
        to any imperative construct that is exported by a system call, a
        C library, or any other external resource that you connect to.
        Many of these come built in, like access to the
        <code>write</code> system call, or to the
        <code>clock</code>; while others come from user libraries,
        like LAPACK bindings.
      </p><p id="idp8425136">
        More generally, when you wrap a library for use in OCaml, you'll
        often find yourself introducing new imperative operations to the
        language.
      </p></section></section><section><h1 id="for-and-while-loops-1"><code>for</code> and <code>while</code>
    loops</h1><p id="idp8427968">
      OCaml provides support for traditional imperative looping
      constructs, in particular, <code>for</code> and
      <code>while</code> loops, even though neither of them is
      strictly necessary. Anything you can do with such a loop you can
      also do with a recursive function, and you can also write
      higher-order functions like <code>Array.iter</code> that
      cover much of the same ground.
    </p><p id="idp8430560">
      Nonetheless, explicit <code>for</code> and
      <code>while</code> loops are both more idiomatic for
      imperative programming and often more concise.
    </p><p id="idp8432304">
      The <code>for</code> loop is the simpler of the two. Indeed,
      we've already seen the <code>for</code> loop in action ---
      the <code>iter</code> function in
      <code>Dictionary</code> is built using it. Here's a simple
      example of <code>for</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span> <span class="k">done</span><span class="o">;;</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8437008">
      As you can see, the upper and lower bounds are inclusive. We can
      also use <code>downto</code> to iterate in the other
      direction.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span> <span class="k">done</span><span class="o">;;</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8439248">
      A <code>while</code>-loop on the other hand, takes a
      condition and a body, and repeatedly runs the body until the
      condition is false. Here's a simple example of a function for
      reversing an array in-place.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">rev_inplace</span> <span class="n">ar</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">ar</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">in</span>
    <span class="c">(* terminate when the upper and lower indices meet *)</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">j</span> <span class="k">do</span>
      <span class="c">(* swap the two elements *)</span>
      <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.(!</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
      <span class="n">ar</span><span class="o">.(!</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">ar</span><span class="o">.(!</span><span class="n">j</span><span class="o">);</span>
      <span class="n">ar</span><span class="o">.(!</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span><span class="o">;</span>
      <span class="c">(* bump the indices *)</span>
      <span class="n">incr</span> <span class="n">i</span><span class="o">;</span>
      <span class="n">decr</span> <span class="n">j</span>
    <span class="k">done</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">rev_inplace</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">array</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">|];;</span>
<span class="k">val</span> <span class="n">nums</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">|]</span>
<span class="o">#</span> <span class="n">rev_inplace</span> <span class="n">nums</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">nums</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">5</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">1</span><span class="o">|]</span>
</pre></div><p id="idp8442208">
      In the above, we used <code>incr</code> and
      <code>decr</code>, which are functions for incrementing and
      decrementing an <code>int ref</code> by one, respectively.
    </p></section><section><h1 id="doubly-linked-lists">Doubly-linked lists</h1><p id="idp8445552">
      Another common imperative data structure is the doubly-linked
      list. Doubly-linked lists can be traversed in both directions and
      elements can be added and removed from the list in constant time.
      Core defines a doubly-linked list (the module is called
      <code>Doubly_linked</code>) which is a good choice for real
      work, but we'll define our own as an illustration.
    </p><p id="idp8446976">
      Here's the <code>mli</code> of the module we'll build.
    </p><div class="highlight"><pre><span class="c">(* file: dlist.mli *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span>

<span class="c">(** Basic list operations  *)</span>
<span class="k">val</span> <span class="n">create</span>   <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>

<span class="c">(** Navigation using [element]s *)</span>
<span class="k">val</span> <span class="n">first</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">next</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">prev</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>

<span class="c">(** Whole-data-structure iteration *)</span>
<span class="k">val</span> <span class="n">iter</span>    <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">find_el</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>

<span class="c">(** Mutation *)</span>
<span class="k">val</span> <span class="n">insert_first</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span>
<span class="k">val</span> <span class="n">insert_after</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span>
<span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</pre></div><p id="idp8450064">
      Note that there are two types defined here:
      <code>'a t</code>, the type of a list, and
      <code>'a element</code>, the type of an element. Elements
      act as pointers to the interior of a list, and allow us to
      navigate the list and give us a point at which to apply mutating
      operations.
    </p><p id="idp8451984">
      Now let's look at the implementation. We'll start by defining
      <code>'a element</code> and <code>'a t</code>.
    </p><div class="highlight"><pre><span class="c">(* file: dlist.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">=</span>
  <span class="o">{</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">previous</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
  <span class="o">}</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span> <span class="n">ref</span>
</pre></div><p id="idp8454784">
      An <code>'a element</code> is a record containing the value
      to be stored in that node as well as optional (and mutable) fields
      pointing to the previous and next elements. At the beginning of
      the list, the <code>prev</code> field is
      <code>None</code>, and at the end of the list, the
      <code>next</code> field is <code>None</code>.
    </p><p id="idp8458496">
      The type of the list itself, <code>'a t</code>, is an
      optional, mutable reference to an <code>element</code>. This
      reference is <code>None</code> if the list is empty, and
      <code>Some</code> otherwise.
    </p><p id="idp8461376">
      Now we can define a few basic functions that operate on lists and
      elements.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>
<span class="k">let</span> <span class="n">is_empty</span> <span class="n">l</span> <span class="o">=</span> <span class="o">!</span><span class="n">l</span> <span class="o">=</span> <span class="nc">None</span>

<span class="k">let</span> <span class="n">value</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">value</span>

<span class="k">let</span> <span class="n">first</span> <span class="n">l</span> <span class="o">=</span> <span class="o">!</span><span class="n">l</span>
<span class="k">let</span> <span class="n">next</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">next</span>
<span class="k">let</span> <span class="n">prev</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">prev</span>
</pre></div><p id="idp8462896">
      These all follow relatively straight-forwardly from our type
      definitions.
    </p><aside class="note"><h1> 
    Cyclic data structures
    </h1><p id="idp8463904">
      Doubly-linked lists are a cyclic data structure, meaning that it
      is possible to follow a nontrivial sequence of pointers that
      closes in on itself. In general, building cyclic data structures
      requires the use of side-effects. This is done by constructing the
      data elements first, and then adding cycles using assignment
      afterwards.
    </p><p id="idp8464672">
      There is an exception to this, though: you can construct
      fixed-size cyclic data-structures using
      <code>let rec</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">endless_loop</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="n">endless_loop</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">endless_loop</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span>
   <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span>
   <span class="o">...]</span>
</pre></div><p id="idp8466944">
      This approach is quite limited, however. General purpose cyclic
      data structures require mutation.
    </p></aside><section><h1 id="modifying-the-list">Modifying the list</h1><p id="idp8468464">
        Now, we'll start considering operations that mutate the list,
        starting with <code>insert_first</code>, which inserts an
        element at the front of the list.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">insert_first</span> <span class="n">l</span> <span class="n">value</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">new_elt</span> <span class="o">=</span> <span class="o">{</span> <span class="n">prev</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="o">!</span><span class="n">l</span><span class="o">;</span> <span class="n">value</span> <span class="o">}</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="o">!</span><span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">old_first</span> <span class="o">-&gt;</span> <span class="n">old_first</span><span class="o">.</span><span class="n">prev</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">new_elt</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">l</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">new_elt</span><span class="o">;</span>
  <span class="n">new_elt</span>
</pre></div><p id="idp8470800">
<code>insert_first</code> first defines a new element
        <code>new_elt</code>, and then links it into the list,
        finally setting the the list itself to point to
        <code>new_elt</code>. Note that the precedence of a
        <code>match</code> expression is very low, so to separate
        it from the following assignment
        <code>l := Some new_front</code>, we surround the match in
        a <code>begin ... end</code> bracketing (we could also use
        parentheses). If we did not, the final assignment would become
        part of the <code>None -&gt; ...</code> case, which is not
        what we want.
      </p><p id="idp8475920">
        In order to add elements later in the list, we can use
        <code>insert_after</code>, which takes an
        <code>element</code> as an argument, after which it
        inserts a new element.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">insert_after</span> <span class="n">elt</span> <span class="n">value</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">new_elt</span> <span class="o">=</span> <span class="o">{</span> <span class="n">value</span><span class="o">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="nc">Some</span> <span class="n">elt</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="o">}</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">old_next</span> <span class="o">-&gt;</span> <span class="n">old_next</span><span class="o">.</span><span class="n">prev</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">new_elt</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">new_elt</span><span class="o">;</span>
  <span class="n">new_elt</span>
</pre></div><p id="idp8478896">
        Finally, we need a <code>remove</code> function.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">remove</span> <span class="n">l</span> <span class="n">elt</span> <span class="o">=</span>
  <span class="k">let</span> <span class="o">{</span> <span class="n">prev</span><span class="o">;</span> <span class="n">next</span><span class="o">;</span> <span class="o">_</span> <span class="o">}</span> <span class="o">=</span> <span class="n">elt</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="n">prev</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">prev</span> <span class="o">-&gt;</span> <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="n">next</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">next</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="n">next</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">next</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="o">.</span><span class="n">prev</span> <span class="o">&lt;-</span> <span class="n">prev</span><span class="o">;</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">elt</span><span class="o">.</span><span class="n">prev</span> <span class="o">&lt;-</span> <span class="nc">None</span><span class="o">;</span>
  <span class="n">elt</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="nc">None</span>
</pre></div><p id="idp8481184">
        Note that the above code is careful to change the
        <code>prev</code> pointer of the following element, and
        the <code>next</code> pointer of the previous element, if
        they exist. If there's no previous element, then the list
        pointer itself is updated. In any case, the next and previous
        pointers of the element itself are set to
        <code>None</code>.
      </p><p id="idp8483760">
        These functions are more fragile than they may seem. In
        particular, misuse of the interface may lead to corrupted data.
        For example, double-removing an element will cause the main list
        reference to be set to <code>None</code>, thus emptying
        the list. Similar problems arise from removing an element from a
        list it doesn't belong to.
      </p><p id="idp8485168">
        This shouldn't be a big surprise. Complex imperative data
        structures can be quite tricky; considerably trickier than their
        pure equivalents. The issues described above can be dealt with
        by more careful error detection, and such error correction is
        taken care of in modules like Core's
        <code>Doubly_linked</code>. You should use imperative data
        structures from a well-designed library when you can. And when
        you can't, you should make sure that the code you write is
        careful about error detection.
      </p></section><section><h1 id="iteration-functions">Iteration functions</h1><p id="idp8487776">
        When defining containers like lists, dictionaries and trees,
        you'll typically want to define a set of iteration functions,
        like <code>iter</code>, <code>map</code>, and
        <code>fold</code>, which let you concisely express common
        iteration patterns.
      </p><p id="idp8490304">
<code>Dlist</code> has two such iterators:
        <code>iter</code>, the goal of which is to call a
        <code>unit</code> producing function on every element of
        the list, in order; and <code>find_el</code>, which runs a
        provided test function on each values stored in the list,
        returning the first <code>element</code> that passes the
        test. Both <code>iter</code> and
        <code>find_el</code> are implemented using simple
        recursive loops that use <code>next</code> to walk from
        element to element, and <code>value</code> to extract the
        element from a given node.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">iter</span> <span class="n">l</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">value</span> <span class="n">el</span><span class="o">);</span> <span class="n">loop</span> <span class="o">(</span><span class="n">next</span> <span class="n">el</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="o">!</span><span class="n">l</span>

<span class="k">let</span> <span class="n">find_el</span> <span class="n">l</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">elt</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">f</span> <span class="o">(</span><span class="n">value</span> <span class="n">elt</span><span class="o">)</span> <span class="k">then</span> <span class="nc">Some</span> <span class="n">elt</span>
      <span class="k">else</span> <span class="n">loop</span> <span class="o">(</span><span class="n">next</span> <span class="n">elt</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="o">!</span><span class="n">l</span>
</pre></div></section></section><section><h1 id="laziness-and-other-unobservable-effects">Laziness and other unobservable effects</h1><p id="idp8499136">
      There are many instances where you basically want to program in a
      pure style, but you want to make limited use of side-effects to
      improve the performance of your code, without really changing
      anything else. Such side effects are sometimes called
      <span><em>unobservable effects</em></span>, and they are a useful
      way of leveraging OCaml's imperative features while still
      maintaining most of the benefits of pure programming.
    </p><p id="idp8500368">
      One of the simplest unobservable effect is
      <span><em>laziness</em></span>. A lazy value is one that is not
      computed until it is actually needed. In OCaml, lazy values are
      created using the <code>lazy</code> keyword, which can be
      used to prefix any expression, returning a value of type
      <code>'a Lazy.t</code>. The evaluation of that expression is
      delayed until forced with the <code>Lazy.force</code>
      function.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">print_string</span> <span class="s2">&quot;performing lazy computation</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sqrt</span> <span class="mi">16</span><span class="o">.);;</span>
<span class="k">val</span> <span class="n">v</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">lazy_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">lazy</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="n">performing</span> <span class="k">lazy</span> <span class="n">computation</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">4</span><span class="o">.</span>
</pre></div><p id="idp8504528">
      You can see from the print statement that the actual computation
      was performed only once, and only after <code>force</code>
      had been called.
    </p><p id="idp8505664">
      To better understand how laziness works, let's walk through the
      implementation of our own lazy type. We'll start by declaring
      types to represent a lazy value.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">lazy_state</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Delayed</span> <span class="k">of</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Value</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span>
  <span class="o">|</span> <span class="nc">Exn</span> <span class="k">of</span> <span class="n">exn</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">lazy_state</span> <span class="o">=</span> <span class="nc">Delayed</span> <span class="k">of</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">|</span> <span class="nc">Value</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Exn</span> <span class="k">of</span> <span class="n">exn</span>
</pre></div><p id="idp8507456">
      A <code>lazy_state</code> represents the possible states of
      a lazy value. A lazy value is <code>Delayed</code> before it
      has been run, where <code>Delayed</code> holds a function
      for computing the value in question. A lazy value is in the
      <code>Value</code> state when it has been forced and the
      computation ended normally. The <code>Exn</code> case is for
      when the lazy value has been forced, but the computation ended
      with an exception. A lazy value is just a reference to a
      <code>lazy_state</code>.
    </p><p id="idp8512032">
      We can create a lazy value based on a thunk,
      <span><em>i.e.</em></span>, a function that takes a unit argument.
      Wrapping an expression in a thunk is another way to suspend the
      computation of an expression.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">create_lazy</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="nc">Delayed</span> <span class="n">f</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">create_lazy</span> <span class="o">:</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">lazy_state</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">create_lazy</span>
    <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">print_string</span> <span class="s2">&quot;performing lazy computation</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="n">sqrt</span> <span class="mi">16</span><span class="o">.);;</span>
  <span class="k">val</span> <span class="n">v</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">lazy_state</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="nc">Delayed</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;}</span>
</pre></div><p id="idp8514256">
      Now we just need a way to force a lazy value. The following
      function does just that.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">force</span> <span class="n">v</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">!</span><span class="n">v</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Value</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="nc">Exn</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">e</span>
    <span class="o">|</span> <span class="nc">Delayed</span> <span class="n">f</span> <span class="o">-&gt;</span>
      <span class="k">try</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span>
        <span class="n">v</span> <span class="o">:=</span> <span class="nc">Value</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">x</span>
      <span class="k">with</span> <span class="n">exn</span> <span class="o">-&gt;</span>
        <span class="n">v</span> <span class="o">:=</span> <span class="nc">Exn</span> <span class="n">exn</span><span class="o">;</span>
        <span class="k">raise</span> <span class="n">exn</span>
   <span class="o">;;</span>
<span class="k">val</span> <span class="n">force</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">lazy_state</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8516000">
      Which we can use in the same way we used
      <code>Lazy.force</code>:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="n">performing</span> <span class="k">lazy</span> <span class="n">computation</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">4</span><span class="o">.</span>
<span class="o">#</span> <span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">4</span><span class="o">.</span>
</pre></div><p id="idp8517968">
      The main difference between our implementation of laziness and the
      built-in version is syntax. Rather than writing
      <code>create_lazy (fun () -&gt; sqrt 16.)</code>, we can
      just write <code>lazy (sqrt 16.)</code>.
    </p><section><h1 id="memoization">Memoization</h1><p id="idp8520624">
        Another unobservable effect is <span><em>memoization</em></span>.
        A memoized function remembers the result of previous invocations
        of the function so that they can be returned without further
        computation when the same arguments are presented again.
      </p><p id="idp8521616">
        Here's a function that takes as an argument an arbitrary
        single-argument function and returns a memoized version of that
        function. Here we'll use Core's <code>Hashtbl</code>
        module, rather than our toy <code>Dictionary</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">memoize</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="nn">Poly</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="n">x</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">y</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="k">in</span>
        <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add_exn</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">x</span> <span class="o">~</span><span class="n">data</span><span class="o">:</span><span class="n">y</span><span class="o">;</span>
        <span class="n">y</span>
    <span class="o">);;</span>
<span class="k">val</span> <span class="n">memoize</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8524832">
        Note that we use <code>Hashtbl.Poly.create</code> to
        create a hash table using OCaml's built-in polymorphic hash
        function. It's also possible to create a hash-table using a hash
        function specialized to a given type.
      </p><p id="idp8526048">
        Memoization can be useful whenever you have a function that is
        expensive to recompute, and you don't mind caching old values
        indefinitely. But memoization is also useful for efficiently
        implementing some recursive algorithms. One good example is the
        algorithm for computing the <span><em>edit distance</em></span>
        (also called the Levenshtein distance) between two strings. The
        edit distance is the number of single-character changes
        (including letter switches, insertions and deletions) required
        to convert one string to the other. This kind of distance metric
        can be useful for a variety of approximate string matching
        problems, like spell checkers.
      </p><p id="idp8527568">
        Consider the following code for computing the edit distance.
        Understanding the algorithm isn't important here, but you should
        pay attention to the structure of the recursive calls.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">edit_distance</span> <span class="n">s</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span><span class="o">,</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">t</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="o">(</span><span class="n">len_s</span><span class="o">,</span><span class="n">len_t</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">s'</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">drop_suffix</span> <span class="n">s</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">t'</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">drop_suffix</span> <span class="n">t</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">cost_to_drop_both</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.[</span><span class="n">len_s</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.[</span><span class="n">len_t</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
      <span class="k">in</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">reduce_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">min</span>
        <span class="o">[</span> <span class="n">edit_distance</span> <span class="n">s'</span> <span class="n">t</span>  <span class="o">+</span> <span class="mi">1</span>
        <span class="o">;</span> <span class="n">edit_distance</span> <span class="n">s</span>  <span class="n">t'</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="o">;</span> <span class="n">edit_distance</span> <span class="n">s'</span> <span class="n">t'</span> <span class="o">+</span> <span class="n">cost_to_drop_both</span>
        <span class="o">]</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">edit_distance</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;ocaml&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8530208">
        The thing to note is that if you call
        <code>edit_distance &quot;OCaml&quot; &quot;ocaml&quot;</code>,
        then that will in turn dispatch the following calls:
      </p><div class="highlight"><pre><span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocaml&quot;</span>
<span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;ocam&quot;</span>
<span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocam&quot;</span>
</pre></div><p id="idp8532272">
        And these calls will in turn dispatch other calls:
      </p><div class="highlight"><pre><span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocaml&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCa&quot;</span> <span class="s2">&quot;ocaml&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCa&quot;</span> <span class="s2">&quot;ocam&quot;</span>
<span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;oca&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;oca&quot;</span>
<span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCa&quot;</span> <span class="s2">&quot;ocam&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCam&quot;</span> <span class="s2">&quot;oca&quot;</span>
   <span class="n">edit_distance</span> <span class="s2">&quot;OCa&quot;</span> <span class="s2">&quot;oca&quot;</span>
</pre></div><p id="idp8534128">
        As you can see, some of these calls are repeats. For example,
        there are two different calls to
        <code>edit_distance &quot;OCam&quot; &quot;oca&quot;</code>.
        The number of redundant calls grows exponentially with the size
        of the strings, meaning that our implementation of
        <code>edit_distance</code> is brutally slow for large
        strings. We can see this by writing a small timing function.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">time</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="n">now</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">stop</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="n">now</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="n">printf</span> <span class="s2">&quot;Time: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">to_string</span> <span class="o">(</span><span class="nn">Time</span><span class="p">.</span><span class="n">diff</span> <span class="n">stop</span> <span class="n">start</span><span class="o">));</span>
    <span class="n">y</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">time</span> <span class="o">:</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8537280">
        And now we can use this to try out some examples.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">edit_distance</span> <span class="s2">&quot;OCaml&quot;</span> <span class="s2">&quot;ocaml&quot;</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">5</span><span class="o">.</span><span class="mi">11003</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">edit_distance</span> <span class="s2">&quot;OCaml 4.01&quot;</span> <span class="s2">&quot;ocaml 4.01&quot;</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">19</span><span class="o">.</span><span class="mi">3322</span><span class="n">s</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8538896">
        Just those few extra characters made it almost 4000 times
        slower!
      </p><p id="idp8539392">
        Memoization would be a huge help here, but to fix the problem,
        we need to memoize the calls that
        <code>edit_distance</code> makes to itself. To see how to
        do this, let's step away from <code>edit_distance</code>,
        and instead consider a much simpler example: computing the nth
        element of the Fibonacci sequence. The Fibonacci sequence by
        definition starts out with two <code>1</code>'s, with
        every subsequent element being the sum of the previous two. The
        classic recursive definition of Fibonacci is as follows:
      </p><p id="idp8542240">
<code>ocaml # let rec fib i =     if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2);;</code>
        This is, however, exponentially slow, for the same reason that
        <code>edit_distance</code> was slow: we end up making many
        redundant calls to <code>fib</code>. It shows up quite
        dramatically in the performance.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">5</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0100136</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">8</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">10</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0441074</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">89</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">20</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">5</span><span class="o">.</span><span class="mi">17392</span><span class="n">ms</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10946</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">40</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">51</span><span class="o">.</span><span class="mi">4205</span><span class="n">s</span>
</pre></div><p id="idp8546368">
        Here, <code>fib 40</code> takes almost a minute to
        compute, as opposed to five <span><em>milliseconds</em></span>
        for <code>fib 20</code>.
      </p><p id="idp8548464">
        So, how can we use memoization to make this faster? The tricky
        bit is that we need to insert the memoization before the
        recursive calls within <code>fib</code>. We can't just
        define <code>fib</code> in the ordinary way and memoize it
        after the fact and expect any improvement.
      </p><p id="idp8550400">
        The first step is to write <code>fib</code> in a way that
        partially unwinds the recursion. The following definition of
        <code>fib_recur</code> expects as its first argument to be
        passed a function that it can use for making its recursive
        calls.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fib_recur</span> <span class="n">recur</span> <span class="n">i</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">i</span>
    <span class="k">else</span> <span class="n">recur</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">recur</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">fib_recur</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8553472">
        We can now turn this back into an ordinary Fibonacci function by
        tying the recursive knot, as shown below.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">=</span> <span class="n">fib_recur</span> <span class="n">fib</span> <span class="n">i</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">fib</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div><p id="idp8554976">
        And we can even write a polymorphic function that we'll call
        <code>fix</code> that can tie the recursive not for any
        function of this form.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fix</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">f'</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="n">f'</span> <span class="n">x</span> <span class="k">in</span>
    <span class="n">f'</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">fix</span> <span class="o">:</span> <span class="o">((</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">fix</span> <span class="n">fib_recur</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">fib</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div><p id="idp8557440">
        This is a pretty strange piece of code, and it may take a few
        minutes of staring at this to figure out what's going on. Like
        <code>fib_recur</code>, the function <code>f</code>
        passed into <code>fix</code> is a function that isn't
        recursive, but takes as an argument of a function that it will
        call. What <code>fix</code> does is to essentially feed
        <code>f</code> to itself, thus making a true recursive
        function.
      </p><p id="idp8561312">
        This is clever enough, but all we've done so far is find a new
        way to implement the same old slow Fibonacci function. To make
        it faster, we need a function like <code>fix</code> that
        inserts memoization when it ties the recursive knot. Here is
        just such a function.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">memo_fix</span> <span class="n">f</span> <span class="o">=</span>
     <span class="k">let</span> <span class="k">rec</span> <span class="n">f'</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">memoize</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">f'</span><span class="o">)</span> <span class="n">x</span><span class="o">))</span> <span class="k">in</span>
     <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">f'</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">memo_fix</span> <span class="o">:</span> <span class="o">((</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8563920">
        It's not obvious why we need to use laziness here. It seems like
        you should be able to get away with just dropping the the
        <code>lazy</code> and the <code>Lazy.force</code>
        from the above code, as follows.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">memo_fix</span> <span class="n">f</span> <span class="o">=</span>
     <span class="k">let</span> <span class="k">rec</span> <span class="n">f'</span> <span class="o">=</span> <span class="n">memoize</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">f'</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
     <span class="n">f'</span>
  <span class="o">;;</span>
      <span class="nc">Characters</span> <span class="mi">35</span><span class="o">-</span><span class="mi">60</span><span class="o">:</span>
       <span class="k">let</span> <span class="k">rec</span> <span class="n">f'</span> <span class="o">=</span> <span class="n">memoize</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">f'</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
                    <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">kind</span> <span class="k">of</span> <span class="n">expression</span> <span class="n">is</span> <span class="n">not</span> <span class="n">allowed</span> <span class="k">as</span> <span class="n">right</span><span class="o">-</span><span class="n">hand</span> <span class="n">side</span> <span class="k">of</span> <span class="o">`</span><span class="k">let</span> <span class="k">rec'</span>
</pre></div><p id="idp8566992">
        OCaml rejects the definition because OCaml, as a strict
        language, can't safely construct the closure
        <code>(fun x -&gt; f f' x)</code> until
        <code>f'</code> itself is defined, and
        <code>f'</code> can't be defined until
        <code>memoize</code> runs, by which time the closure
        already needs to exist. Generally, OCaml requires that the right
        hand side of a <code>let rec</code> be either a function,
        a <code>lazy</code> value or a variant or record
        constructor.
      </p><p id="idp8571488">
        In any case, using <code>memo_fix</code>, we can now build
        an efficient version of <code>fib</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">memo_fix</span> <span class="n">fib_recur</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">time</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">fib</span> <span class="mi">40</span><span class="o">);;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">0</span><span class="o">.</span><span class="mi">236034</span><span class="n">ms</span>
</pre></div><p id="idp8574256">
        We can even combine this into one compact form that makes this
        look as much as possible like an ordinary function declaration.
        Here, we're essentially using <code>memo_fix</code> as a
        custom form of <code>let rec</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">memo_fix</span> <span class="o">(</span><span class="k">fun</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8577216">
        This very same approach will work for
        <code>edit_distance</code>. The one change we'll need to
        make is that <code>edit_server</code> will now take a pair
        of strings as a single argument, since
        <code>memoize</code> only works sensibly for
        single-argument functions. We can always recover the original
        interface with a wrapper function.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">edit_distance</span> <span class="o">=</span> <span class="n">memo_fix</span> <span class="o">(</span><span class="k">fun</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span><span class="o">,</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">t</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="c">(* if either string is empty, return the length of the</span>
<span class="c">                            other string. *)</span>
    <span class="o">|</span> <span class="o">(</span><span class="n">len_s</span><span class="o">,</span><span class="n">len_t</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">s'</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">drop_suffix</span> <span class="n">s</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">t'</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">drop_suffix</span> <span class="n">t</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">cost_to_drop_both</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.[</span><span class="n">len_s</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.[</span><span class="n">len_t</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
      <span class="k">in</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">reduce_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">min</span>
        <span class="o">[</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="n">s'</span><span class="o">,</span><span class="n">t</span> <span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="o">;</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="n">s</span> <span class="o">,</span><span class="n">t'</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="o">;</span> <span class="n">edit_distance</span> <span class="o">(</span><span class="n">s'</span><span class="o">,</span><span class="n">t'</span><span class="o">)</span> <span class="o">+</span> <span class="n">cost_to_drop_both</span>
        <span class="o">])</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">edit_distance</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp8582144">
        And this new version of <code>edit_distance</code> is
        indeed much more efficient than the one we started with.
      </p><p id="idp8583248">
<code>ocaml # time (fun () -&gt; edit_distance (&quot;OCaml 4.01&quot;,&quot;ocaml 4.01&quot;));; Time: 2.14601ms - : int = 2</code>
        This is about ten thousand times faster than our original
        implementation.
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="functors.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="object-oriented-programming.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>