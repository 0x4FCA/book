<html>

    <head>
    
        <meta charset="utf-8"></meta>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"></meta>
        
        <title>Chapter 17. Data Serialization with S-Expressions / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"></link>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'realworldocaml',
                        repo: 'book',
                        milestone: 'v1',
                        page: 'data\u002Dserialization\u002Dwith\u002Ds\u002Dexpressions.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="maps-and-hash-tables.html">13. Maps and Hash Tables</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html">14. Command-Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">15. Handling JSON Data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-menhir.html">16. Parsing with OCamllex and Menhir</a>
                                            </li>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html" class="here">17. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">18. Concurrent Programming with Async</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="ix01.html">Index</a>
                            
                        </li>
                    
                </ul>
            </nav>
            <header class="header">
                <h1><a href="http://oreil.ly/realworldOCaml"><img src="../../media/img/cover.png" width="120" alt="Real World OCaml, by Yaron Minsky, Anil Madhavapeddy and Jason Hickey"></img></a></h1>
                <p><i>Buy in <a href="http://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/">print</a> and <a href="http://oreil.ly/realworldOCaml">eBook.</a></i></p>
            </header>
        
            <article class="page">
        
                <h1>Chapter 17. Data Serialization with S-Expressions</h1>
                
                

    <p id="idm146289005472">S-expressions are nested parenthetical expressions whose atomic values
  are strings. They were first popularized by the Lisp programming language in
  the 1960s. They have remained one of the simplest and most effective ways to
  encode structured data in a human-readable and editable form.<a name="SERFORMsexp"></a><a name="idm146289003360"></a><a name="idm146289002064"></a></p><p id="idm146289000368">There's a full definition of s-expressions available <a href="http://people.csail.mit.edu/rivest/Sexp.txt" target="_top">online</a>. An example
  s-expression might look like this:</p><div class="rwocode"><pre><code><div class="highlight"><span class="p">(</span><span class="nf">this</span> <span class="p">(</span><span class="nf">is</span> <span class="nv">an</span><span class="p">)</span> <span class="p">(</span><span class="nf">s</span> <span class="nv">expression</span><span class="p">))</span>
</div></code></pre><div class="rwocodeinfo">Scheme ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/basic.scm">sexpr/basic.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288996960">S-expressions play a major role in Core, effectively acting as the
  default serialization format. Indeed, we've encountered s-expressions
  multiple times already, including in <a href="error-handling.html">Chapter 7, <i>Error Handling</i></a>,
  <a href="functors.html">Chapter 9, <i>Functors</i></a>, and <a href="first-class-modules.html">Chapter 10, <i>First-Class Modules</i></a>.</p><p id="idm146288994848">This chapter will go into s-expressions in more depth. In particular,
  we'll discuss:</p><ul><li><p id="idm146288993856">The details of the s-expression format, including how to parse it while generating good
        error messages for debugging malformed inputs</p></li><li><p id="idm146288992944">How to generate s-expressions from arbitrary OCaml types</p></li><li><p id="idm146288992112">How to use custom type annotations to control the exact printing
      behavior for s-expression converters</p></li><li><p id="idm146288991232">How to integrate s-expressions into your interfaces, in particular how to add
        s-expression converters to a module without breaking abstraction boundaries</p></li></ul><p id="idm146288990416">We'll tie this together at the end of the chapter with a simple s-expression formatted
    configuration file for a web server</p><section id="basic-usage"><h1>Basic Usage</h1><p id="idm146288989008">The type used to represent an s-expression is quite
    simple:<a name="idm146288988688"></a></p><div class="rwocode"><pre><code><span class="keyword4">module</span> <span class="keyword6">Sexp </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
  <span class="keyword4">type</span> t <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Atom </span><span class="keyword2">of</span> <span class="keyword3">string</span>
  <span class="keyword2">|</span> <span class="keyword6">List </span><span class="keyword2">of</span> t <span class="keyword3">list</span>
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp.mli">sexpr/sexp.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288984992">An s-expression can be thought of as a tree where each node contains
    a list of its children, and where the leaves of the tree are strings. Core
    provides good support for s-expressions in its <code>Sexp</code> module, including functions for converting
    s-expressions to and from strings. Let's rewrite our example s-expression
    in terms of this type:</p><div class="rwocode"><pre><code># <span class="keyword5">Sexp.List </span><span class="keyword2">[</span>
    <span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;this&quot;</span><span class="keyword2">;</span>
    <span class="keyword5">Sexp.List </span><span class="keyword2">[</span> <span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;is&quot;</span><span class="keyword2">;</span> <span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;an&quot;</span><span class="keyword2">]</span><span class="keyword2">;</span>
    <span class="keyword5">Sexp.List </span><span class="keyword2">[</span> <span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;s&quot;</span><span class="keyword2">;</span> <span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;expression&quot;</span> <span class="keyword2">]</span><span class="keyword2">;</span>
  <span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (this (is an) (s expression))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/print_sexp.topscript">sexpr/print_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288977168">This prints out nicely because Core registers a pretty printer with
    the toplevel. This pretty printer is based on the functions in <code>Sexp</code> for converting s-expressions to and from
    strings:<a name="idm146288976064"></a></p><div class="rwocode"><pre><code># <span class="keyword5">Sexp.</span>to_string <span class="keyword2">(</span><span class="keyword5">Sexp.List </span><span class="keyword2">[</span><span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;1&quot;</span><span class="keyword2">;</span> <span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;2&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;(1 2)&quot;
</div># <span class="keyword5">Sexp.</span>of_string <span class="keyword2">(</span><span class="keyword7">&quot;(1 2 (3 4))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (1 2 (3 4))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_printer.topscript">sexpr/sexp_printer.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288969424">In addition to providing the <code>Sexp</code>
    module, most of the base types in Core support conversion to and from
    s-expressions. For example, we can use the conversion functions defined in
    the respective modules for integers, strings, and exceptions:</p><div class="rwocode"><pre><code># <span class="keyword5">Int.</span>sexp_of_t <span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = 3
</div># <span class="keyword5">String.</span>sexp_of_t <span class="keyword7">&quot;hello&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = hello
</div># <span class="keyword5">Exn.</span>sexp_of_t <span class="keyword2">(</span><span class="keyword6">Invalid_argument </span><span class="keyword7">&quot;foo&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (Invalid_argument foo)
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/to_from_sexp.topscript">sexpr/to_from_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288960752">It's also possible to convert more complex types such as lists or
    arrays that are polymorphic across the types that they can contain:</p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>sexp_of_t<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : ('a -&gt; Sexp.t) -&gt; 'a list -&gt; Sexp.t = &lt;fun&gt;
</div># <span class="keyword5">List.</span>sexp_of_t <span class="keyword5">Int.</span>sexp_of_t <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span> <span class="keyword8">2</span><span class="keyword2">;</span> <span class="keyword8">3</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (1 2 3)
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/to_from_sexp.topscript">sexpr/to_from_sexp.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288954464">Notice that <code>List.sexp_of_t</code> is
    polymorphic and takes as its first argument another conversion function to
    handle the elements of the list to be converted. Core uses this scheme
    more generally for defining sexp converters for polymorphic types.</p><p id="idm146288953184">The functions that go in the other direction, <span><em>i.e.</em></span>, reconstruct an
      OCaml value from an s-expression, use essentially the same trick for handling polymorphic
      types, as shown in the following example. Note that these functions will fail with an
      exception when presented with an s-expression that doesn't match the structure of the OCaml
      type in question.</p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>t_of_sexp<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (Sexp.t -&gt; 'a) -&gt; Sexp.t -&gt; 'a list = &lt;fun&gt;
</div># <span class="keyword5">List.</span>t_of_sexp <span class="keyword5">Int.</span>t_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;(1 2 3)&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3]
</div># <span class="keyword5">List.</span>t_of_sexp <span class="keyword5">Int.</span>t_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;(1 2 three)&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception:
(Sexplib.Conv.Of_sexp_error (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;)
 three).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/to_from_sexp.topscript">sexpr/to_from_sexp.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="note"><h1>More on Top-Level Printing</h1><p id="idm146288942384">The values of the s-expressions that we created were printed
      properly as s-expressions in the toplevel, instead of as the tree of
      <code>Atom</code> and <code>List</code> variants that they're actually made
      of.<a name="idm146288940640"></a></p><p id="idm146288939600">This is due to OCaml's facility for installing custom
      <span><em>top-level printers</em></span> that can rewrite some values
      into more top-level-friendly equivalents. They are generally installed
      as <span><strong>ocamlfind</strong></span> packages ending in
      <code>top</code>:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlfind list | grep top
</div><div class="rwocodeout">compiler-libs.toplevel (version: [distributed with Ocaml])</div><div class="rwocodeout">core.top            (version: 109.47.00)</div><div class="rwocodeout">lwt.simple-top      (version: 2.4.3)</div><div class="rwocodeout">num-top             (version: 1.4)</div><div class="rwocodeout">sexplib.top         (version: 109.47.00)</div><div class="rwocodeout">uri.top             (version: 1.3.11)</div><div class="rwocodeout">utop                (version: 1.8)</div><div class="rwocodeout">utop.camlp4         (version: 1.8)</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/list_top_packages.out">sexpr/list_top_packages.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288929488">The <code>core.top</code> package (which you
      should have loaded by default in your <code>.ocamlinit</code> file) loads in printers for the
      Core extensions already, so you don't need to do anything special to use
      the s-expression printer.</p></aside><section id="generating-s-expressions-from-ocaml-types"><h1>Generating S-Expressions from OCaml Types</h1><p id="idm146288926496">But what if you want a function to convert a brand new type to an
      s-expression? You can of course write it yourself manually. Here's an
      example:<a name="idm146288926080"></a></p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">float</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : int; bar : float; }
</div># <span class="keyword4">let</span> sexp_of_t t <span class="keyword2">=</span>
    <span class="keyword4">let</span> a x <span class="keyword2">=</span> <span class="keyword5">Sexp.Atom </span>x <span class="keyword4">and</span> l x <span class="keyword2">=</span> <span class="keyword5">Sexp.List </span>x <span class="keyword4">in</span>
    l <span class="keyword2">[</span> l <span class="keyword2">[</span>a <span class="keyword7">&quot;foo&quot;</span><span class="keyword2">;</span> <span class="keyword5">Int.</span>sexp_of_t t.foo  <span class="keyword2">]</span><span class="keyword2">;</span>
        l <span class="keyword2">[</span>a <span class="keyword7">&quot;bar&quot;</span><span class="keyword2">;</span> <span class="keyword5">Float.</span>sexp_of_t t.bar<span class="keyword2">]</span><span class="keyword2">;</span> <span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_t <span class="keyword2">{</span> foo <span class="keyword2">=</span> <span class="keyword8">3</span><span class="keyword2">;</span> bar <span class="keyword2">=</span> <span class="keyword8">-5</span>.<span class="keyword8">5</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((foo 3) (bar -5.5))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/manually_making_sexp.topscript">sexpr/manually_making_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288915104">This is somewhat tiresome to write, and it gets more so when you
      consider the parser, i.e., <code>t_of_sexp</code>,
      which is considerably more complex. Writing this kind of parsing and
      printing code by hand is mechanical and error prone, not to mention a
      drag.</p><p id="idm146288913792">Given how mechanical the code is, you could imagine writing a program that inspected the
        type definition and autogenerated the conversion code for you. As it turns out, Sexplib does
        just that. <code>Sexplib</code>, which is included with Core, provides
        both a library for manipulating s-expressions and a <span><em>syntax extension</em></span>
        for generating such conversion functions. With that syntax extension enabled, any type that
        has <code>with sexp</code> as an annotation will trigger the
        generation of the functions we want:<a name="idm146288911328"></a><a name="idm146288910016"></a></p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">float</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : int; bar : float; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># t_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((bar 35) (foo 3))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : t = {foo = 3; bar = 35.}
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/auto_making_sexp.topscript">sexpr/auto_making_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288901568">The syntax extension can be used outside of type declarations as
      well. As discussed in <a href="error-handling.html">Chapter 7, <i>Error Handling</i></a>, <code>with sexp</code> can be attached to the declaration
      of an exception, which will improve the ability of Core to generate a
      useful string representation:</p><div class="rwocode"><pre><code># <span class="keyword1">exception</span> <span class="keyword6">Bad_message </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword3">list</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">exception Bad_message of string list
</div># <span class="keyword5">Exn.</span>to_string <span class="keyword2">(</span><span class="keyword6">Bad_message </span><span class="keyword2">[</span><span class="keyword7">&quot;1&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;2&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;3&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;(\&quot;Bad_message(_)\&quot;)&quot;
</div># <span class="keyword1">exception</span> <span class="keyword6">Good_message </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword3">list</span> <span class="keyword1">with</span> sexp<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">exception Good_message of string list
</div># <span class="keyword5">Exn.</span>to_string <span class="keyword2">(</span><span class="keyword6">Good_message </span><span class="keyword2">[</span><span class="keyword7">&quot;1&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;2&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;3&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;(//toplevel//.Good_message (1 2 3))&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/auto_making_sexp.topscript">sexpr/auto_making_sexp.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288890048">You don't always have to declare a named type to create an
      s-expression converter. The following syntax lets you create one inline,
      as part of a larger expression:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> l <span class="keyword2">=</span> <span class="keyword2">[</span><span class="keyword2">(</span><span class="keyword8">1</span>,<span class="keyword7">&quot;one&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span> <span class="keyword2">(</span><span class="keyword8">2</span>,<span class="keyword7">&quot;two&quot;</span><span class="keyword2">)</span><span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val l : (int * string) list = [(1, &quot;one&quot;); (2, &quot;two&quot;)]
</div># <span class="keyword5">List.</span>iter l ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span>
    <span class="keyword1">&lt;:sexp_of&lt;</span><span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">string</span><span class="keyword1">&gt;&gt;</span> x
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>to_string
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>(1 one)
(2 two)
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/inline_sexp.topscript">sexpr/inline_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288880528">The declaration <code>&lt;:sexp_of&lt;int *
      string&gt;&gt;</code> simply gets expanded to the sexp converter for
      the type <code>int * string</code>. This is useful
      whenever you need a sexp converter for an anonymous type.</p><p id="idm146288878576">The syntax extensions bundled with Core almost all have the same
      basic structure: they autogenerate code based on type definitions,
      implementing functionality that you could in theory have implemented by
      hand, but with far less programmer effort.</p><aside class="note"><h1>Syntax Extensions, Camlp4, and Type_conv</h1><p id="idm146288877232">OCaml doesn't directly support generating code from type
        definitions. Instead, it supplies a powerful syntax extension
        mechanism known as Camlp4, which lets you extend the grammar of the
        language. Camlp4 is well integrated into the OCaml toolchain and can
        be activated within the toplevel and also included in compilation
        using the <code>-pp</code> compiler
        flag.<a name="idm146288875968"></a><a name="idm146288875040"></a></p><p id="idm146288873360">Sexplib is part of a family of syntax extensions, including
        Comparelib, described in <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a>, and
        Fieldslib, described in <a href="records.html">Chapter 5, <i>Records</i></a>, that generate code
        based on type declarations and are all based on a common library
        called Type_conv. This library provides a common language for
        annotating types (e.g., using the <code>with</code> notation) and utilities for working
        with type definitions. If you want to build your own type-driven
        syntax extension, you should consider basing it on
        Type_conv.<a name="idm146288870912"></a><a name="idm146288870000"></a></p></aside></section></section><section id="the-sexp-format"><h1>The Sexp Format</h1><p id="idm146288867280">The textual representation of s-expressions is pretty
    straightforward. An s-expression is written down as a nested parenthetical
    expression, with whitespace-separated strings as the atoms. Quotes are
    used for atoms that contain parentheses or spaces themselves; backslash is
    the escape character; and semicolons are used to introduce single-line
    comments. Thus, the following file, <code>example.scm</code>:<a name="idm146288865968"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="c1">;; example.scm</span>

<span class="p">((</span><span class="nf">foo</span> <span class="mf">3.3</span><span class="p">)</span> <span class="c1">;; This is a comment</span>
 <span class="p">(</span><span class="nf">bar</span> <span class="s">&quot;this is () an \&quot; atom&quot;</span><span class="p">))</span>
</div></code></pre><div class="rwocodeinfo">Scheme ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/example.scm">sexpr/example.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288862016">can be loaded using Sexplib. As you can see, the commented data is
    not part of the resulting s-expression:</p><div class="rwocode"><pre><code># <span class="keyword5">Sexp.</span>load_sexp <span class="keyword7">&quot;example.scm&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((foo 3.3) (bar &quot;this is () an \&quot; atom&quot;))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/example_load.topscript">sexpr/example_load.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288857728">All in, the s-expression format supports three comment
    syntaxes:</p><div><dl><dt><span><code>;</code></span></dt><dd><p id="idm146288855744">Comments out everything to the end of line</p></dd><dt><span><code>#|</code>, </span><span><code>|#</code></span></dt><dd><p id="idm146288853008">Delimiters for commenting out a block</p></dd><dt><span><code>#;</code></span></dt><dd><p id="idm146288851024">Comments out the first complete s-expression that
          follows</p></dd></dl></div><p id="idm146288850176">The following example shows all of these in action:</p><div class="rwocode"><pre><code><div class="highlight"><span class="c1">;; comment_heavy_example.scm</span>
<span class="p">((</span><span class="nf">this</span> <span class="nv">is</span> <span class="nv">included</span><span class="p">)</span>
 <span class="c1">; (this is commented out</span>
 <span class="p">(</span><span class="nf">this</span> <span class="nv">stays</span><span class="p">)</span>
 <span class="o">#</span><span class="c1">; (all of this is commented</span>
     <span class="nv">out</span> <span class="p">(</span><span class="nf">even</span> <span class="nv">though</span> <span class="nv">it</span> <span class="nv">crosses</span> <span class="nv">lines</span><span class="o">.</span><span class="p">))</span>
  <span class="p">(</span><span class="k">and </span><span class="o">#</span><span class="nv">|</span> <span class="nv">block</span> <span class="nv">delimiters</span> <span class="o">#</span><span class="nv">|</span> <span class="nv">which</span> <span class="nv">can</span> <span class="nv">be</span> <span class="nv">nested</span> <span class="nv">|</span><span class="o">#</span>
     <span class="nv">will</span> <span class="nv">comment</span> <span class="nv">out</span>
    <span class="nv">an</span> <span class="nv">arbitrary</span> <span class="nv">multi-line</span> <span class="nv">block</span><span class="p">)))</span> <span class="nv">|</span><span class="o">#</span>
   <span class="nv">now</span> <span class="nv">we</span><span class="ss">'re</span> <span class="nv">done</span>
   <span class="p">))</span>
</div></code></pre><div class="rwocodeinfo">Scheme ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/comment_heavy.scm">sexpr/comment_heavy.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288847472">Again, loading the file as an s-expression drops the
    comments:</p><div class="rwocode"><pre><code># <span class="keyword5">Sexp.</span>load_sexp <span class="keyword7">&quot;comment_heavy.scm&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((this is included) (this stays) (and now we're done))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/example_load.topscript">sexpr/example_load.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288843040">If we introduce an error into our s-expression, by, say, creating a
    file <code>broken_example.scm</code> which is
    <code>example.scm</code>, without open-paren in
    front of <code>bar</code>, we'll get a parse
    error:</p><div class="rwocode"><pre><code># <span class="keyword5">Exn.</span>handle_uncaught ~exit<span class="keyword2">:</span>false <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    ignore <span class="keyword2">(</span><span class="keyword5">Sexp.</span>load_sexp <span class="keyword7">&quot;example_broken.scm&quot;</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Uncaught exception:
  
  (Sexplib.Sexp.Parse_error
   ((location parse) (err_msg &quot;unexpected character: ')'&quot;) (text_line 4)
    (text_char 29) (global_offset 78) (buf_pos 78)))
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/example_load.topscript">sexpr/example_load.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288832544">In the preceding example, we use <code>Exn.handle_uncaught</code> to make sure that the
    exception gets printed out in full detail. You should generally wrap every
    Core program in this handler to get good error messages for any unexpected
    exceptions.</p></section><section id="preserving-invariants"><h1>Preserving Invariants</h1><p id="idm146288830240">The most important functionality provided by Sexplib is the
    autogeneration of converters for new types. We've seen a bit of how this
    works already, but let's walk through a complete example. Here's the
    source for a simple library for representing integer intervals, very
    similar to the one described in <a href="functors.html">Chapter 9, <i>Functors</i></a>:<a name="idm146288829168"></a></p><div class="rwocode"><pre><code><span class="comments">(* Module for representing closed integer intervals *)</span>
<span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="comments">(* Invariant: For any Range (x,y), y &gt;= x *)</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword2">of</span> <span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">int</span>
  <span class="keyword2">|</span> <span class="keyword6">Empty
</span><span class="keyword1">with</span> sexp

<span class="keyword4">let</span> is_empty <span class="keyword2">=</span>
  <span class="keyword1">function</span> 
  <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> true 
  <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword8">_</span> -<span class="keyword2">&gt;</span> false

<span class="keyword4">let</span> create x y <span class="keyword2">=</span>
  <span class="keyword1">if</span> x <span class="keyword2">&gt;</span> y <span class="keyword1">then</span>
    <span class="keyword6">Empty </span>
  <span class="keyword1">else</span> 
    <span class="keyword6">Range </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span>

<span class="keyword4">let</span> contains i x <span class="keyword2">=</span>
  <span class="keyword1">match</span> i <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> false
  <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword2">(</span>low,high<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> x <span class="keyword2">&gt;</span><span class="keyword2">=</span> low <span class="keyword2">&amp;&amp;</span> x <span class="keyword2">&lt;</span><span class="keyword2">=</span> high</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/int_interval.ml">sexpr/int_interval.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288824720">We can now use this module as follows:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> intervals <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">module</span> <span class="keyword6">I </span><span class="keyword2">=</span> <span class="keyword6">Int_interval </span><span class="keyword4">in</span>
  <span class="keyword2">[</span> <span class="keyword5">I.</span>create <span class="keyword8">3</span> <span class="keyword8">4</span><span class="keyword2">;</span>
    <span class="keyword5">I.</span>create <span class="keyword8">5</span> <span class="keyword8">4</span><span class="keyword2">;</span> <span class="comments">(* should be empty *)</span>
    <span class="keyword5">I.</span>create <span class="keyword8">2</span> <span class="keyword8">3</span><span class="keyword2">;</span>
    <span class="keyword5">I.</span>create <span class="keyword8">1</span> <span class="keyword8">6</span><span class="keyword2">;</span>
  <span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  intervals
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>sexp_of_t <span class="keyword5">Int_interval.</span>sexp_of_t
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>to_string_hum
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/test_interval.ml">sexpr/test_interval.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288821760">But we're still missing something: we haven't created an <code>mli</code> signature for <code>Int_interval</code> yet. Note that we need to
    explicitly export the s-expression converters that were created within the
    <code>ml</code> file. For example, here's an
    interface that doesn't export the s-expression functions:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t

<span class="keyword4">val</span> is_empty <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> bool
<span class="keyword4">val</span> create <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> t
<span class="keyword4">val</span> contains <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> bool</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/int_interval_nosexp.mli">sexpr/int_interval_nosexp.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288816992">Building this will give us the following error:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild test_interval_nosexp.native
</div><div class="rwocodeout">File &quot;test_interval_nosexp.ml&quot;, line 14, characters 20-42:</div><div class="rwocodeout">Error: Unbound value Int_interval.sexp_of_t</div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/build_test_interval_nosexp.out">sexpr/build_test_interval_nosexp.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288811584">We could export the types by hand in the signature, by writing the
    signatures for the extra functions generated by Sexplib:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t
<span class="keyword4">val</span> t_of_sexp <span class="keyword2">:</span> <span class="keyword5">Sexp.</span>t -<span class="keyword2">&gt;</span> t
<span class="keyword4">val</span> sexp_of_t <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>t

<span class="keyword4">val</span> is_empty <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> bool
<span class="keyword4">val</span> create <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> t
<span class="keyword4">val</span> contains <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> bool</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/int_interval_manual_sexp.mli">sexpr/int_interval_manual_sexp.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288808464">This isn't an ideal solution, as it makes you repeatedly expose
    these extra functions in every signature you create where you want to
    serialize values. Sexplib solves this by exposing the same syntax
    extension in signature definitions so that we can just use the same
    <code>with</code> shorthand in the <code>mli</code> file. Here's the final version of the
    signature that does just this:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword1">with</span> sexp

<span class="keyword4">val</span> is_empty <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> bool
<span class="keyword4">val</span> create <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> t
<span class="keyword4">val</span> contains <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> bool</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/int_interval.mli">sexpr/int_interval.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288804032">At this point, <code>test_interval.ml</code>
    will compile again, and if we run it, we'll get the following
    output:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild test_interval.native
</div><div class="highlight"><span class="gp">$</span> ./test_interval.native
</div><div class="rwocodeout">((Range 3 4) Empty (Range 2 3) (Range 1 6))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/build_test_interval.out">sexpr/build_test_interval.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288798096">One easy mistake to make when dealing with sexp converters is to
    ignore the fact that those converters can violate the invariants of your
    code. For example, the <code>Int_interval</code>
    module depends for the correctness of the <code>is_empty</code> check on the fact that for any value
    <code>Range (x,y)</code>, <code>y</code> is greater than or equal to <code>x</code>. The <code>create</code>
    function preserves this invariant, but the <code>t_of_sexp</code> function does not.<a name="idm146288792976"></a></p><p id="idm146288791936">We can fix this problem by overriding the autogenerated function and
    writing a custom sexp converter that wraps the autogenerated converter
    with whatever invariant checks are necessary:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword2">of</span> <span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">int</span>
  <span class="keyword2">|</span> <span class="keyword6">Empty
</span><span class="keyword1">with</span> sexp

<span class="keyword4">let</span> create x y <span class="keyword2">=</span>
  <span class="keyword1">if</span> x <span class="keyword2">&gt;</span> y <span class="keyword1">then</span> <span class="keyword6">Empty </span><span class="keyword1">else</span> <span class="keyword6">Range </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span>

<span class="keyword4">let</span> t_of_sexp sexp <span class="keyword2">=</span>
  <span class="keyword4">let</span> t <span class="keyword2">=</span> t_of_sexp sexp <span class="keyword4">in</span>
  <span class="keyword4">begin</span> <span class="keyword1">match</span> t <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span>
    <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword1">if</span> y <span class="keyword2">&lt;</span> x <span class="keyword1">then</span> of_sexp_error <span class="keyword7">&quot;Upper and lower bound of Range swapped&quot;</span> sexp
  <span class="keyword4">end</span><span class="keyword2">;</span>
  t</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_override.ml">sexpr/sexp_override.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288788352">This trick of overriding an existing function definition with a new
    one is perfectly acceptable in OCaml. Since <code>t_of_sexp</code> is defined with an ordinary <code>let</code> rather than a <code>let
    rec</code>, the call to the <code>t_of_sexp</code> goes to the Sexplib-generated version
    of the function, rather than being a recursive call.</p><p id="idm146288785200">Another important aspect of our definition is that we call the
    function <code>of_sexp_error</code> to raise an
    exception when the parsing process fails. This improves the error
    reporting that Sexplib can provide when a conversion fails, as we'll see
    in the next section.</p></section><section id="getting-good-error-messages"><h1>Getting Good Error Messages</h1><p id="idm146288782848">There are two steps to deserializing a type from an s-expression:
    first, converting the bytes in a file to an s-expression; and the second,
    converting that s-expression into the type in question. One problem with
    this is that it can be hard to localize errors to the right place using
    this scheme. Consider the following example:<a name="idm146288782240"></a><a name="idm146288780944"></a><a name="idm146288779616"></a></p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> 
  a<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
  b<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
  c<span class="keyword2">:</span> <span class="keyword3">float</span> option 
<span class="keyword2">}</span> <span class="keyword1">with</span> sexp

<span class="keyword4">let</span> run <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> t <span class="keyword2">=</span>
    <span class="keyword5">Sexp.</span>load_sexp <span class="keyword7">&quot;foo_broken_example.scm&quot;</span>
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> t_of_sexp
  <span class="keyword4">in</span>
  printf <span class="keyword7">&quot;b is: %d\n%!&quot;</span> t.b

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Exn.</span>handle_uncaught ~exit<span class="keyword2">:</span>true run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/read_foo.ml">sexpr/read_foo.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288775664">If you were to run this on a malformatted file, say, this
    one:</p><div class="rwocode"><pre><code><div class="highlight"><span class="p">((</span><span class="nf">a</span> <span class="s">&quot;not-an-integer&quot;</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">b</span> <span class="s">&quot;not-an-integer&quot;</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">c</span> <span class="mf">1.0</span><span class="p">))</span>
</div></code></pre><div class="rwocodeinfo">Scheme ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/foo_broken_example.scm">sexpr/foo_broken_example.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288772928">you'll get the following error:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild read_foo.native
</div><div class="highlight"><span class="gp">$</span> ./read_foo.native foo_example_broken.scm
</div><div class="rwocodeout">Uncaught exception:</div><div class="rwocodeout">  </div><div class="rwocodeout">  (Sexplib.Conv.Of_sexp_error</div><div class="rwocodeout">   (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;) not-an-integer)</div><div class="rwocodeout"> </div><div class="rwocodeout">Raised at file &quot;lib/conv.ml&quot;, line 281, characters 36-72</div><div class="rwocodeout">Called from file &quot;lib/core_int.ml&quot;, line 6, characters 7-14</div><div class="rwocodeout">Called from file &quot;lib/std_internal.ml&quot;, line 115, characters 7-33</div><div class="rwocodeout">Called from file &quot;read_foo.ml&quot;, line 5, characters 2-8</div><div class="rwocodeout">Called from file &quot;read_foo.ml&quot;, line 4, characters 2-40</div><div class="rwocodeout">Called from file &quot;read_foo.ml&quot;, line 11, characters 4-60</div><div class="rwocodeout">Called from file &quot;lib/exn.ml&quot;, line 69, characters 6-10</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/build_read_foo.out">sexpr/build_read_foo.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288760144">If all you have is the error message and the string, it's not
    terribly informative. In particular, you know that the parsing errored out
    on the atom &quot;not-an-integer,&quot; but you don't know which one! In a large
    file, this kind of bad error message can be pure misery.</p><p id="idm146288759472">But there's hope! We can make a small change to the code to improve
    the error message greatly:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> 
  a<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
  b<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
  c<span class="keyword2">:</span> <span class="keyword3">float</span> option 
<span class="keyword2">}</span> <span class="keyword1">with</span> sexp

<span class="keyword4">let</span> run <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> t <span class="keyword2">=</span> <span class="keyword5">Sexp.</span>load_sexp_conv_exn <span class="keyword7">&quot;foo_broken_example.scm&quot;</span> t_of_sexp <span class="keyword4">in</span>
  printf <span class="keyword7">&quot;b is: %d\n%!&quot;</span> t.b

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Exn.</span>handle_uncaught ~exit<span class="keyword2">:</span>true run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/read_foo_better_errors.ml">sexpr/read_foo_better_errors.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288756512">If we run it again, we'll see a much more specific error:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild read_foo_better_errors.native
</div><div class="highlight"><span class="gp">$</span> ./read_foo_better_errors.native foo_example_broken.scm
</div><div class="rwocodeout">Uncaught exception:</div><div class="rwocodeout">  </div><div class="rwocodeout">  (Sexplib.Conv.Of_sexp_error</div><div class="rwocodeout">   (Sexplib.Sexp.Annotated.Conv_exn foo_broken_example.scm:2:5</div><div class="rwocodeout">    (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;))</div><div class="rwocodeout">   not-an-integer)</div><div class="rwocodeout"> </div><div class="rwocodeout">Raised at file &quot;lib/pre_sexp.ml&quot;, line 1145, characters 12-58</div><div class="rwocodeout">Called from file &quot;read_foo_better_errors.ml&quot;, line 10, characters 10-68</div><div class="rwocodeout">Called from file &quot;lib/exn.ml&quot;, line 69, characters 6-10</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/build_read_foo_better_errors.out">sexpr/build_read_foo_better_errors.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288745088">In the preceding error, <code>foo_broken_example.scm:2:5</code> tells us that
    the error occurred in the file <code>&quot;foo_broken_example.scm&quot;</code> on line 2,
    character 5. This is a much better start for figuring out what went wrong.
    The ability to find the precise location of the error depends on the sexp
    converter reporting errors using the function <code>of_sexp_error</code>. This is already done by
    converters generated by Sexplib, but you should make sure to do the same
    when you write custom converters.</p></section><section id="sexp-conversion-directives"><h1>Sexp-Conversion Directives</h1><p id="idm146288741232">Sexplib supports a collection of directives for modifying the
    default behavior of the autogenerated sexp converters. These directives
    allow you to customize the way in which types are represented as
    s-expressions without having to write a custom converter.<a name="idm146288740704"></a></p><p id="idm146288739264">Note that the extra directives aren't part of the standard OCaml
    syntax, but are added via the Sexplib syntax extension. However, since
    Sexplib is used throughout Core and is part of the standard bundle
    activated by <span><strong>corebuild</strong></span>, you can use
    these in your own Core code without any special effort.</p><section id="sexp_opaque"><h1>sexp_opaque</h1><p id="idm146288737024">The most commonly used directive is <code>sexp_opaque</code>, whose purpose is to mark a given
      component of a type as being unconvertible. Anything marked with
      <code>sexp_opaque</code> will be presented as the
      atom <code>&lt;opaque&gt;</code> by the to-sexp
      converter, and will trigger an exception from the from-sexp
      converter.<a name="idm146288734512"></a></p><p id="idm146288733088">Note that the type of a component marked as opaque doesn't need to
      have a sexp converter defined. Here, if we define a type without a sexp
      converter and then try to use another type with a sexp converter, we'll
      error out:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> no_converter <span class="keyword2">=</span> <span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">int</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type no_converter = int * int
</div># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 14-26:
Error: Unbound value no_converter_of_sexp
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288726176">But with <code>sexp_opaque</code>, we can
      embed our opaque <code>no_converter</code> type
      within the other data structure without an error.</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter sexp_opaque<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : no_converter; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288719168">And if we now convert a value of this type to an s-expression,
      we'll see the contents of field <code>a</code>
      marked as opaque:</p><div class="rwocode"><pre><code># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword8">3</span>,<span class="keyword8">4</span><span class="keyword2">)</span><span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;foo&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a &lt;opaque&gt;) (b foo))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288714096">Note that the <code>t_of_sexp</code>
      function for an opaque type is generated, but will fail at runtime if it
      is used:</p><div class="rwocode"><pre><code># t_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((a whatever) (b foo))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception:
(Sexplib.Conv.Of_sexp_error
 (Failure &quot;opaque_of_sexp: cannot convert opaque values&quot;) whatever).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288707712">This is there to allow for s-expression converters to be created
      for types containing <code>sexp_opaque</code>
      values. This is useful because the resulting converters won't
      necessarily fail on all inputs. For example, if you have a record
      containing a <code>no_converter list</code>, the
      <code>t_of_sexp</code> function would still
      succeed when the list is empty:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter sexp_opaque <span class="keyword3">list</span><span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : no_converter list; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># t_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((a ()) (b foo))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : t = {a = []; b = &quot;foo&quot;}
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288697872">If you really only want to generate one direction of converter,
      one can do this by annotating the type with <code>with sexp_of</code> or <code>with
      of_sexp</code> instead of <code>with
      sexp</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter sexp_opaque<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp_of <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : no_converter; b : string; }
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter sexp_opaque<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> of_sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : no_converter; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="sexp_list"><h1>sexp_list</h1><p id="idm146288687136">Sometimes, sexp converters have more parentheses than one would
      ideally like. Consider, for example, the following variant
      type:<a name="idm146288686736"></a></p><div class="rwocode"><pre><code># <span class="keyword4">type</span> compatible_versions <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Specific </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword3">list</span>
  <span class="keyword2">|</span> <span class="keyword6">All </span><span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type compatible_versions = Specific of string list | All
val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;
val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_compatible_versions
  <span class="keyword2">(</span><span class="keyword6">Specific </span><span class="keyword2">[</span><span class="keyword7">&quot;3.12.0&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;3.12.1&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;3.13.0&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (Specific (3.12.0 3.12.1 3.13.0))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_list.topscript">sexpr/sexp_list.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288676208">You might prefer to make the syntax a bit less parenthesis-laden
      by dropping the parentheses around the list. We can replace the <code>string list</code> in the type declaration with
      <code>string sexp_list</code> to give us this
      alternate syntax:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> compatible_versions <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Specific </span><span class="keyword2">of</span> <span class="keyword3">string</span> sexp_list
  <span class="keyword2">|</span> <span class="keyword6">All </span><span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type compatible_versions = Specific of string list | All
val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;
val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_compatible_versions
  <span class="keyword2">(</span><span class="keyword6">Specific </span><span class="keyword2">[</span><span class="keyword7">&quot;3.12.0&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;3.12.1&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;3.13.0&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (Specific 3.12.0 3.12.1 3.13.0)
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_list.topscript">sexpr/sexp_list.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="sexp_option"><h1>sexp_option</h1><p id="idm146288664032">Another common directive is <code>sexp_option</code>, which is used to make a record
      field optional in the s-expression. Normally, optional values are
      represented either as <code>()</code> for <code>None</code>, or as <code>(x)</code> for <code>Some
      x</code>, and a record field containing an option would be rendered
      accordingly. For example:<a name="idm146288660256"></a></p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> <span class="keyword3">int</span> option<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : int option; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> None<span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;hello&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a ()) (b hello))
</div># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> <span class="keyword6">Some </span><span class="keyword8">3</span><span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;hello&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a (3)) (b hello))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_option.topscript">sexpr/sexp_option.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288650064">But what if we want a field to be optional, i.e., we want to allow
      it to be omitted from the record entirely? In that case, we can mark it
      with <code>sexp_option</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> <span class="keyword3">int</span> sexp_option<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : int option; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> <span class="keyword6">Some </span><span class="keyword8">3</span><span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;hello&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a 3) (b hello))
</div># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> None<span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;hello&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((b hello))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_option.topscript">sexpr/sexp_option.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="specifying-defaults"><h1>Specifying Defaults</h1><p id="idm146288638864">The <code>sexp_option</code> declaration is
      really just an example of specifying a default behavior for dealing with
      an unspecified field. In particular, <code>sexp_option</code> fills in absent fields with
      <code>None</code>. But you might want to allow
      other ways of filling in default values.<a name="idm146288636400"></a></p><p id="idm146288634960">Consider the following type, which represents the configuration of
      a very simple web server:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> http_server_config <span class="keyword2">=</span> <span class="keyword2">{</span>
     web_root<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
     port<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
     addr<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
  <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288626480">One could imagine making some of these parameters optional; in
      particular, by default, we might want the web server to bind to port 80,
      and to listen as localhost. We can do this as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> http_server_config <span class="keyword2">=</span> <span class="keyword2">{</span>
     web_root<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
     port<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword1">with</span> default<span class="keyword2">(</span><span class="keyword8">80</span><span class="keyword2">)</span><span class="keyword2">;</span>
     addr<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword1">with</span> default<span class="keyword2">(</span><span class="keyword7">&quot;localhost&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288617776">Now, if we try to convert an s-expression that specifies only the
      <code>web_root</code>, we'll see that the other
      values are filled in with the desired defaults:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> cfg <span class="keyword2">=</span> http_server_config_of_sexp
   <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((web_root /var/www/html))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val cfg : http_server_config =
  {web_root = &quot;/var/www/html&quot;; port = 80; addr = &quot;localhost&quot;}
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288611440">If we convert the configuration back out to an s-expression,
      you'll notice that all of the fields are present, even though they're
      not strictly necessary:</p><div class="rwocode"><pre><code># sexp_of_http_server_config cfg <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((web_root /var/www/html) (port 80) (addr localhost))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288606912">We could make the generated s-expression also drop exported
      values, by using the <code>sexp_drop_default</code> directive:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> http_server_config <span class="keyword2">=</span> <span class="keyword2">{</span>
     web_root<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
     port<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword1">with</span> default<span class="keyword2">(</span><span class="keyword8">80</span><span class="keyword2">)</span>, sexp_drop_default<span class="keyword2">;</span>
     addr<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword1">with</span> default<span class="keyword2">(</span><span class="keyword7">&quot;localhost&quot;</span><span class="keyword2">)</span>, sexp_drop_default<span class="keyword2">;</span>
  <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
</div># <span class="keyword4">let</span> cfg <span class="keyword2">=</span> http_server_config_of_sexp
  <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((web_root /var/www/html))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val cfg : http_server_config =
  {web_root = &quot;/var/www/html&quot;; port = 80; addr = &quot;localhost&quot;}
</div># sexp_of_http_server_config cfg <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((web_root /var/www/html))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288592624">As you can see, the fields that are at their default values are
      simply omitted from the s-expression. On the other hand, if we convert a
      config with other values, then those values will be included in the
      s-expression:</p><div class="rwocode"><pre><code># sexp_of_http_server_config <span class="keyword2">{</span> cfg <span class="keyword1">with</span> port <span class="keyword2">=</span> <span class="keyword8">8080</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((web_root /var/www/html) (port 8080))
</div># sexp_of_http_server_config
  <span class="keyword2">{</span> cfg <span class="keyword1">with</span> port <span class="keyword2">=</span> <span class="keyword8">8080</span><span class="keyword2">;</span> addr <span class="keyword2">=</span> <span class="keyword7">&quot;192.168.0.1&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((web_root /var/www/html) (port 8080) (addr 192.168.0.1))
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146288585488">This can be very useful in designing config file formats that are
      both reasonably terse and easy to generate and maintain. It can also be
      useful for backwards compatibility: if you add a new field to your
      config record, but you make that field optional, then you should still
      be able to parse older version of your config.<a name="idm146288584880"></a><a name="idm146288584272"></a><a name="idm146288582976"></a></p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="parsing-with-ocamllex-and-menhir.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="concurrent-programming-with-async.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>
