<html>

    <head>
    
        <meta charset="utf-8"></meta>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"></meta>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29546208-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
        
        <title>Chapter 22. The Compiler Frontend: Parsing and Type Checking / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"></link>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'realworldocaml',
                        repo: 'book',
                        milestone: 'v1',
                        page: 'the\u002Dcompiler\u002Dfrontend\u002Dparsing\u002Dand\u002Dtype\u002Dchecking.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html">19. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="memory-representation-of-values.html">20. Memory Representation of Values</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">21. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-frontend-parsing-and-type-checking.html" class="here">22. The Compiler Frontend: Parsing and Type
    Checking</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-backend-byte-code-and-native-code.html">23. The Compiler Backend: Bytecode and Native code</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="ix01.html">Index</a>
                            
                        </li>
                    
                </ul>
            </nav>
            <header class="header">
                <h1><a href="http://oreil.ly/realworldOCaml"><img src="../../media/img/coversmall.png" width="120" alt="Real World OCaml, by Yaron Minsky, Anil Madhavapeddy and Jason Hickey"></img></a></h1>
                <p><i>Buy in <a href="http://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/">print</a> and <a href="http://oreil.ly/realworldOCaml">eBook.</a></i></p>
            </header>
        
            <article class="page">
        
                <h1>Chapter 22. The Compiler Frontend: Parsing and Type Checking</h1>
                
                

    <p id="idm181609580480">Compiling source code into executable programs is a fairly complex
  libraries, linkers, and assemblers. It's important to understand how these
  fit together to help with your day-to-day workflow of developing, debugging,
  and deploying applications.<a name="idm181609579968"></a></p><p id="idm181609578528">OCaml has a strong emphasis on static type safety and rejects source
  code that doesn't meet its requirements as early as possible. The compiler
  does this by running the source code through a series of checks and
  transformations. Each stage performs its job (e.g., type checking,
  optimization, or code generation) and discards some information from the
  previous stage. The final native code output is low-level assembly code that
  doesn't know anything about the OCaml modules or objects that the compiler
  started with.<a name="idm181609577728"></a><a name="idm181609576832"></a></p><p id="idm181609575792">You don't have to do all of this manually, of course. The compiler frontends (<code>ocamlc</code> and <code>ocamlopt</code>) are invoked
    via the command line and chain the stages together for you. Sometimes though, you'll need to
    dive into the toolchain to hunt down a bug or investigate a performance problem. This chapter
    explains the compiler pipeline in more depth so you understand how to harness the command-line
    tools effectively.<a name="idm181609573824"></a><a name="idm181609572528"></a></p><p id="idm181609571104">In this chapter, we'll cover the following topics:</p><ul><li><p id="idm181609570144">The compilation pipeline and what each stage represents</p></li><li><p id="idm181609569312">Source preprocessing via Camlp4 and the intermediate forms</p></li><li><p id="idm181609552208">The type-checking process, including module resolution</p></li></ul><p id="idm181609551504">The details of the compilation process into executable code can be found next, in <a href="the-compiler-backend-byte-code-and-native-code.html">Chapter 23, <i>The Compiler Backend: Bytecode and Native code</i></a>.</p><section id="an-overview-of-the-toolchain"><h1>An Overview of the Toolchain</h1><p id="idm181609549568">The OCaml tools accept textual source code as input, using the filename extensions
        <code>.ml</code> and <code>.mli</code> for
      modules and signatures, respectively. We explained the basics of the build process in <a href="files-modules-and-programs.html">Chapter 4, <i>Files, Modules, and Programs</i></a>, so we'll assume you've built a few OCaml programs
      already by this point.<a name="idm181609547200"></a></p><p id="idm181609545776">Each source file represents a <span><em>compilation unit</em></span>
    that is built separately. The compiler generates intermediate files with
    different filename extensions to use as it advances through the
    compilation stages. The linker takes a collection of compiled units and
    produces a standalone executable or library archive that can be reused by
    other applications.<a name="idm181609544736"></a></p><p id="idm181609543696">The overall compilation pipeline looks like this:<a name="idm181609543376"></a></p><div class="rwocode"><pre><code><pre>    Source code
        |
        | parsing and preprocessing
        |
        | camlp4 syntax extensions
        |
        v
    Parsetree (untyped AST)
        |
        | type inference and checking
        v
    Typedtree (type-annotated AST)
        |
        | pattern-matching compilation
        | elimination of modules and classes
        v
     Lambda
      /   \
     /     \ closure conversion, inlining, uncurrying,
    v       \  data representation strategy
 Bytecode    \
    |         +-----+
    |              Cmm
    |ocamlrun       |
    |               | code generation
    |               | assembly &amp; linking
    v               v
 Interpreted    Compiled
</pre></code></pre><div class="rwocodeinfo">Diagram ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/pipeline.ascii">front-end/pipeline.ascii</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><div><div></div></div><p id="idm181609538480">Notice that the pipeline branches toward the end. OCaml has multiple compiler backends
      that reuse the early stages of compilation but produce very different final outputs. The
        <span><em>bytecode</em></span> can be run by a portable interpreter and can even be
      transformed into JavaScript (via <a href="http://ocsigen.org/js_of_ocaml" target="_top">js_of_ocaml</a>) or C source code (via <a href="https://github.com/ocaml-bytes/ocamlcc" target="_top">OCamlCC</a>). The <span><em>native
        code</em></span> compiler generates specialized executable binaries suitable for
      high-performance applications.<a name="idm181609535632"></a><a name="idm181609534304"></a></p><section><h1><b>Obtaining the Compiler Source Code</b></h1><p id="idm181609532176">Although it's not necessary to understand the examples, you may
      find it useful to have a copy of the OCaml source tree checked out while
      you read through this chapter. The source code is available from
      multiple places:</p><ul><li><p id="idm181609531040">Stable releases as <code>zip</code> and <code>tar</code> archives
            from the <a href="http://caml.inria.fr/download.en.html" target="_top">OCaml download
            site</a></p></li><li><p id="idm181609528864">A Subversion anonymous mirror of the main development sources
          available on the <a href="http://caml.inria.fr/ocaml/anonsvn.en.html" target="_top">development
          resources</a> page online</p></li><li><p id="idm181609527296">A Git mirror of the Subversion repository with all the history and development
            branches included, browsable online at <a href="https://github.com/ocaml/ocaml" target="_top">GitHub</a></p></li></ul><p id="idm181609525984">The source tree is split up into subdirectories. The core compiler
      consists of:</p><div><dl><dt><span><code>config/</code></span></dt><dd><p id="idm181609523968">Configuration directives to tailor OCaml for your operating
            system and architecture.</p></dd><dt><span><code>bytecomp/</code> and <code>byterun/</code></span></dt><dd><p id="idm181609521280">Bytecode compiler and runtime, including the garbage collector (GC).</p></dd><dt><span><code>asmcomp/</code> and <code>asmrun/</code></span></dt><dd><p id="idm181609518624">Native-code compiler and runtime. The native runtime symlinks many modules from
              the <code>byterun</code> directory to share code, most notably
              the GC.</p></dd><dt><span><code>parsing/</code></span></dt><dd><p id="idm181609515888">The OCaml lexer, parser, and libraries for manipulating
            them.</p></dd><dt><span><code>typing/</code></span></dt><dd><p id="idm181609513888">The static type checking implementation and type
            definitions.</p></dd><dt><span><code>camlp4/</code></span></dt><dd><p id="idm181609511888">The source code macro preprocessor.</p></dd><dt><span><code>driver/</code></span></dt><dd><p id="idm181609509920">Command-line interfaces for the compiler tools.</p></dd></dl></div><p id="idm181609509104">A number of tools and scripts are also built alongside the core compiler:</p><div><dl><dt><span><code>debugger/</code></span></dt><dd><p id="idm181609507104">The interactive bytecode debugger.</p></dd><dt><span><code>toplevel/</code></span></dt><dd><p id="idm181609505136">Interactive top-level console.</p></dd><dt><span><code>emacs/</code></span></dt><dd><p id="idm181609503184">: A <span><em>caml-mode</em></span> for the Emacs
            editor.</p></dd><dt><span><code>stdlib/</code></span></dt><dd><p id="idm181609500800">The compiler standard library, including the <code>Pervasives</code> module.</p></dd><dt><span><code>ocamlbuild/</code></span></dt><dd><p id="idm181609498176">Build system that automates common OCaml compilation
            modes.</p></dd><dt><span><code>otherlibs/</code></span></dt><dd><p id="idm181609496176">Optional libraries such as the Unix and graphics
            modules.</p></dd><dt><span><code>tools/</code></span></dt><dd><p id="idm181609494176">Command-line utilities such as <code>ocamldep</code> that are installed with the
            compiler.</p></dd><dt><span><code>testsuite/</code></span></dt><dd><p id="idm181609491520">Regression tests for the core compiler.</p></dd></dl></div></section><p id="idm181609490576">We'll go through each of the compilation stages now and explain how they will be useful to
      you during day-to-day OCaml development.</p></section><section id="parsing-source-code"><h1>Parsing Source Code</h1><p id="idm181609488992">When a source file is passed to the OCaml compiler, its first task is to parse the text
      into a more structured abstract syntax tree (AST). The parsing logic is implemented in OCaml
      itself using the techniques described earlier in <a href="parsing-with-ocamllex-and-menhir.html">Chapter 16, <i>Parsing with OCamllex and Menhir</i></a>. The lexer and parser rules can be found in the
        <code>parsing</code> directory in the source distribution.<a name="idm181609487200"></a><a name="SCpras"></a><a name="PARSsource"></a><a name="CPpars"></a></p><section id="syntax-errors"><h1>Syntax Errors</h1><p id="idm181609480624">The OCaml parser's goal is to output a well-formed AST data structure to the next phase
        of compilation, and so it any source code that doesn't match basic syntactic requirements.
        The compiler emits a <span><em>syntax error</em></span> in this situation, with a pointer to
        the filename and line and character number that's as close to the error as
          possible.<a name="idm181609479600"></a><a name="idm181609478304"></a></p><p id="idm181609477280">Here's an example syntax error that we obtain by performing a module assignment as a
        statement instead of as a <code>let</code> binding:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">module</span> <span class="keyword6">MyString </span><span class="keyword2">=</span> String<span class="keyword2">;</span>
  <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/broken_module.ml">front-end/broken_module.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609474112">The code results in a syntax error when compiled:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c broken_module.ml
</div><div class="rwocodeout">File &quot;broken_module.ml&quot;, line 2, characters 2-8:</div><div class="rwocodeout">Error: Syntax error</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_broken_module.out">front-end/build_broken_module.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609469216">The correct version of this source code creates the <code>MyString</code> module correctly via a local open,
      and compiles successfully:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">module</span> <span class="keyword6">MyString </span><span class="keyword2">=</span> <span class="keyword6">String </span><span class="keyword4">in</span>
  <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/fixed_module.ml">front-end/fixed_module.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609465792">The syntax error points to the line and character number of the
      first token that couldn't be parsed. In the broken example, the <code>module</code> keyword isn't a valid token at that
      point in parsing, so the error location information is correct.</p></section><section id="automatically-indenting-source-code"><h1>Automatically Indenting Source Code</h1><p id="idm181609463424">Sadly, syntax errors do get more inaccurate sometimes, depending
      on the nature of your mistake. Try to spot the deliberate error in the
      following function definitions:<a name="idm181609462976"></a></p><div class="rwocode"><pre><code><span class="keyword4">let</span> concat_and_print x y <span class="keyword2">=</span>
  <span class="keyword4">let</span> v <span class="keyword2">=</span> x <span class="keyword2">^</span> y <span class="keyword4">in</span>
  print_endline v<span class="keyword2">;</span>
  v<span class="keyword2">;</span>

<span class="keyword4">let</span> add_and_print x y <span class="keyword2">=</span>
  <span class="keyword4">let</span> v <span class="keyword2">=</span> x <span class="keyword2">+</span> y <span class="keyword4">in</span>
  print_endline <span class="keyword2">(</span>string_of_int v<span class="keyword2">)</span><span class="keyword2">;</span>
  v

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> _x <span class="keyword2">=</span> add_and_print <span class="keyword8">1</span> <span class="keyword8">2</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> _y <span class="keyword2">=</span> concat_and_print <span class="keyword7">&quot;a&quot;</span> <span class="keyword7">&quot;b&quot;</span> <span class="keyword4">in</span>
  <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/follow_on_function.ml">front-end/follow_on_function.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609459088">When you compile this file, you'll get a syntax error
      again:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c follow_on_function.ml
</div><div class="rwocodeout">File &quot;follow_on_function.ml&quot;, line 11, characters 0-3:</div><div class="rwocodeout">Error: Syntax error</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_follow_on_function.out">front-end/build_follow_on_function.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609454176">The line number in the error points to the end of the <code>add_and_print</code> function, but the actual error
      is at the end of the <span><em>first</em></span> function definition.
      There's an extra semicolon at the end of the first definition that
      causes the second definition to become part of the first <code>let</code> binding. This eventually results in a
      parsing error at the very end of the second function.</p><p id="idm181609451728">This class of bug (due to a single errant character) can be hard
      to spot in a large body of code. Luckily, there's a great tool available
      via OPAM called <span><strong>ocp-indent</strong></span> that
      applies structured indenting rules to your source code on a line-by-line
      basis. This not only beautifies your code layout, but it also makes this
      syntax error much easier to locate.<a name="idm181609450656"></a></p><p id="idm181609449216">Let's run our erroneous file through <span><strong>ocp-indent</strong></span> and see how it processes it:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocp-indent follow_on_function.ml
</div><div class="rwocodeout">let concat_and_print x y =</div><div class="rwocodeout">  let v = x ^ y in</div><div class="rwocodeout">  print_endline v;</div><div class="rwocodeout">  v;</div><div class="rwocodeout"> </div><div class="rwocodeout">  let add_and_print x y =</div><div class="rwocodeout">    let v = x + y in</div><div class="rwocodeout">    print_endline (string_of_int v);</div><div class="rwocodeout">    v</div><div class="rwocodeout"> </div><div class="rwocodeout">let () =</div><div class="rwocodeout">  let _x = add_and_print 1 2 in</div><div class="rwocodeout">  let _y = concat_and_print &quot;a&quot; &quot;b&quot; in</div><div class="rwocodeout">  ()</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/indent_follow_on_function.out">front-end/indent_follow_on_function.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609435904">The <code>add_and_print</code> definition has been indented as if
        it were part of the first <code>concat_and_print</code> definition,
        and the errant semicolon is now much easier to spot. We just need to remove that semicolon
        and rerun <span><strong>ocp-indent</strong></span> to verify that the syntax is
        correct:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocp-indent follow_on_function_fixed.ml
</div><div class="rwocodeout">let concat_and_print x y =</div><div class="rwocodeout">  let v = x ^ y in</div><div class="rwocodeout">  print_endline v;</div><div class="rwocodeout">  v</div><div class="rwocodeout"> </div><div class="rwocodeout">let add_and_print x y =</div><div class="rwocodeout">  let v = x + y in</div><div class="rwocodeout">  print_endline (string_of_int v);</div><div class="rwocodeout">  v</div><div class="rwocodeout"> </div><div class="rwocodeout">let () =</div><div class="rwocodeout">  let _x = add_and_print 1 2 in</div><div class="rwocodeout">  let _y = concat_and_print &quot;a&quot; &quot;b&quot; in</div><div class="rwocodeout">  ()</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/indent_follow_on_function_fixed.out">front-end/indent_follow_on_function_fixed.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609421104">The <span><strong>ocp-indent</strong></span>
<a href="https://github.com/OCamlPro/ocp-indent" target="_top">home page</a> documents how to
        integrate it with your favorite editor. All the Core libraries are formatted using it to
        ensure consistency, and it's a good idea to do this before publishing your own source code
        online.</p></section><section id="generating-documentation-from-interfaces"><h1>Generating Documentation from Interfaces</h1><p id="idm181609418064">Whitespace and source code comments are removed during parsing and
      aren't significant in determining the semantics of the program. However,
      other tools in the OCaml distribution can interpret comments for their
      own ends.<a name="idm181609417568"></a><a name="idm181609416272"></a><a name="idm181609414960"></a></p><p id="idm181609413904">The <span><strong>ocamldoc</strong></span> tool uses specially formatted comments
        in the source code to generate documentation bundles. These comments are combined with the
        function definitions and signatures, and output as structured documentation in a variety of
        formats. It can generate HTML pages, LaTeX and PDF documents, UNIX manual pages, and even
        module dependency graphs that can be viewed using <a href="http://www.graphviz.org" target="_top">Graphviz</a>.</p><p id="idm181609411808">Here's a sample of some source code that's been annotated with
      <span><strong>ocamldoc</strong></span> comments:</p><div class="rwocode"><pre><code><span class="comments">(** example.ml: The first special comment of the file is the comment 
    associated with the whole module. *)</span>

<span class="comments">(** Comment for exception My_exception. *)</span>
<span class="keyword1">exception</span> <span class="keyword6">My_exception </span><span class="keyword2">of</span> <span class="keyword2">(</span><span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">*</span> <span class="keyword3">int</span>

<span class="comments">(** Comment for type [weather]  *)</span>
<span class="keyword4">type</span> weather <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Rain </span><span class="keyword2">of</span> <span class="keyword3">int</span> <span class="comments">(** The comment for construtor Rain *)</span>
  <span class="keyword2">|</span> <span class="keyword6">Sun </span>        <span class="comments">(** The comment for constructor Sun *)</span>

<span class="comments">(** Find the current weather for a country
    @author Anil Madhavapeddy
    @param location The country to get the weather for.
*)</span>
<span class="keyword4">let</span> what_is_the_weather_in location <span class="keyword2">=</span>
  <span class="keyword1">match</span> location <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">`Cambridge </span> -<span class="keyword2">&gt;</span> <span class="keyword6">Rain </span><span class="keyword8">100</span>
  <span class="keyword2">|</span> <span class="keyword6">`New_york </span>  -<span class="keyword2">&gt;</span> <span class="keyword6">Rain </span><span class="keyword8">20</span>
  <span class="keyword2">|</span> <span class="keyword6">`California </span>-<span class="keyword2">&gt;</span> Sun</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/doc.ml">front-end/doc.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609408304">The <span><strong>ocamldoc</strong></span> comments are
      distinguished by beginning with the double asterisk. There are
      formatting conventions for the contents of the comment to mark metadata.
      For instance, the <code>@tag</code> fields mark
      specific properties such as the author of that section of code.</p><p id="idm181609406528">Try compiling the HTML documentation and UNIX man pages by running
      <span><strong>ocamldoc</strong></span> over the source file:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> mkdir -p html man/man3
</div><div class="highlight"><span class="gp">$</span> ocamldoc -html -d html doc.ml
</div><div class="highlight"><span class="gp">$</span> ocamldoc -man -d man/man3 doc.ml
</div><div class="highlight"><span class="gp">$</span> man -M man Doc
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_ocamldoc.out">front-end/build_ocamldoc.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609398832">You should now have HTML files inside the <code>html/</code> directory and also
        be able to view the UNIX manual pages held in <code>man/man3</code>. There are quite
        a few comment formats and options to control the output for the various backends. Refer to
        the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual029.html" target="_top">OCaml
          manual</a> for the complete list.<a name="idm181609396768"></a><a name="idm181609395856"></a><a name="idm181609394544"></a><a name="idm181609393648"></a><a name="idm181609392336"></a><a name="idm181609391424"></a><a name="idm181609390528"></a><a name="idm181609389920"></a><a name="idm181609389312"></a></p><aside class="tip"><h1>Using Custom ocamldoc Generators</h1><p id="idm181609387888">The default HTML output stylesheets from <span><strong>ocamldoc</strong></span> are pretty spartan and distinctly
        Web 1.0. The tool supports plugging in custom documentation
        generators, and there are several available that provide prettier or
        more detailed output:</p><ul><li><p id="idm181609386080"><a href="http://argot.x9c.fr/" target="_top">Argot</a> is an
            enhanced HTML generator that supports code folding and searching
            by name or type definition.</p></li><li><p id="idm181609384656"><a href="https://gitorious.org/ocamldoc-generators/ocamldoc-generators" target="_top">ocamldoc generators</a> add support for Bibtex references within comments and
              generating literate documentation that embeds the code alongside the comments.</p></li><li><p id="idm181609383152">JSON output is available via a custom <a href="https://github.com/xen-org/ocamldoc-json" target="_top">generator</a>
            in Xen.</p></li></ul></aside></section></section><section id="preprocessing-source-code"><h1>Preprocessing Source Code</h1><p id="idm181609380448">One powerful feature in OCaml is a facility to extend the standard-language grammar
      without having to modify the compiler. You can roughly think of it as a type-safe version of
      the <code>cpp</code> preprocessor used in C/C++ to control conditional
      compilation directives.<a name="idm181609379264"></a><a name="SCpreproc"></a><a name="CPpreproc"></a></p><p id="idm181609374704">The OCaml distribution includes a system called Camlp4 for writing extensible parsers.
      This provides some OCaml libraries that are used to define grammars, as well as dynamically
      loadable syntax extensions of such grammars. Camlp4 modules register new language keywords and
      later transform these keywords (or indeed, any portion of the input program) into conventional
      OCaml code that can be understood by the rest of the compiler.<a name="SEcamlp"></a><a name="idm181609372192"></a><a name="idm181609370880"></a><a name="idm181609369968"></a><a name="idm181609369056"></a><a name="idm181609367760"></a><a name="idm181609366864"></a><a name="idm181609365552"></a><a name="camlp"></a></p><p id="idm181609363344">We've already seen several Core libraries that use Camlp4:</p><div><dl><dt><span><code>Fieldslib</code></span></dt><dd><p id="idm181609361360">Generates first-class values that represent fields of a
          record</p></dd><dt><span><code>Sexplib</code></span></dt><dd><p id="idm181609359360">To convert types to textual s-expressions</p></dd><dt><span><code>Bin_prot</code></span></dt><dd><p id="idm181609357392">For efficient binary conversion and parsing</p></dd></dl></div><p id="idm181609356576">These libraries all extend the language in quite a minimal way by
    adding a <code>with</code> keyword to type
    declarations to signify that extra code should be generated from that
    declaration. For example, here's a trivial use of Sexplib and
    Fieldslib:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Sexplib.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span>
  foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
  bar<span class="keyword2">:</span> <span class="keyword3">string</span>
<span class="keyword2">}</span> <span class="keyword1">with</span> sexp, fields</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/type_conv_example.ml">front-end/type_conv_example.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609353008">Compiling this code will normally give you a syntax error if you do so without Camlp4,
      since the <code>with</code> keyword isn't normally allowed after a type
      definition:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlfind ocamlc -c type_conv_example.ml
</div><div class="rwocodeout">File &quot;type_conv_example.ml&quot;, line 6, characters 2-6:</div><div class="rwocodeout">Error: Syntax error</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_type_conv_without_camlp4.out">front-end/build_type_conv_without_camlp4.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609347328">Now add in the syntax extension packages for Fieldslib and Sexplib,
    and everything will compile again:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlfind ocamlc -c -syntax camlp4o -package sexplib.syntax <span class="se">\</span>
</div><div class="rwocodeout">    -package fieldslib.syntax type_conv_example.ml</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_type_conv_with_camlp4.out">front-end/build_type_conv_with_camlp4.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609342992">We've specified a couple of additional flags here. The <code>-syntax</code> flag directs <span><strong>ocamlfind</strong></span> to add the <code>-pp</code> flag to the compiler command line. This flag
    instructs the compiler to run the preprocessor during its parsing
    phase.</p><p id="idm181609340480">The <code>-package</code> flag imports other
    OCaml libraries. The <code>.syntax</code> suffix in
    the package name is a convention that indicates these libraries are
    preprocessors that should be run during parsing. The syntax extension
    modules are dynamically loaded into the <span><strong>camlp4o</strong></span> command, which rewrites the input source
    code into conventional OCaml code that has no trace of the new keywords.
    The compiler then compiles this transformed code with no knowledge of the
    preprocessor's actions.</p><p id="idm181609337664">Both Fieldslib and Sexplib need this new <code>with</code> keyword,
      but they both can't register the same extension. Instead, a library called Type_conv provides
      the common extension framework for them to use. Type_conv registers the <code>with</code> grammar extension to Camlp4, and the OCamlfind packaging
      ensures that it's loaded before Fieldslib or Sexplib.</p><p id="idm181609335632">The two extensions generate boilerplate OCaml code based on the type definition at
      compilation time. This avoids the performance hit of doing the code generation dynamically and
      also doesn't require a just-in-time (JIT) runtime that can be a source of unpredictable
      dynamic behavior. Instead, all the extra code is simply generated at compilation time via
      Camlp4, and type information can be discarded from the runtime image.<a name="idm181609334912"></a></p><p id="idm181609333632">The syntax extensions accept an input AST and output a modified one.
    If you're not familiar with the Camlp4 module in question, how do you
    figure out what changes it's made to your code? The obvious way is to read
    the documentation that accompanies the extension. Another approach is to
    use the toplevel to explore the extension's behavior or run Camlp4
    manually yourself to see the transformation in action. We'll show you how
    to do both of these now.</p><section id="using-camlp4-interactively"><h1>Using Camlp4 Interactively</h1><p id="idm181609331840">The <span><strong>utop</strong></span> toplevel can run the
      phrases that you type through <span><strong>camlp4</strong></span>
      automatically. You should have at least these lines in your <code>~/.ocamlinit</code> file in your home directory (see
        <a href="http://realworldocaml.org/install" target="_top">this Real World OCaml page</a> for more information):</p><div class="rwocode"><pre><code># <span class="keyword7">#use</span> <span class="keyword7">&quot;topfind&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require &quot;package&quot;;;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates &quot;p,q,...&quot;;;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
 </div># <span class="keyword7">#camlp4o</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/camlp4_toplevel.topscript">front-end/camlp4_toplevel.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609317104">The first directive loads the <span><strong>ocamlfind</strong></span> top-level interface that lets you
      require <span><strong>ocamlfind</strong></span> packages (including
      all their dependent packages). The second directive instructs the
      toplevel to filter all phrases via Camlp4. You can now run <span><strong>utop</strong></span> and load the syntax extensions in. We'll
      use the <code>comparelib</code> syntax extension
      for our experiments.</p><p id="idm181609313792">OCaml provides a built-in polymorphic comparison operator that inspects the runtime
        representation of two values to see if they're equal. As we noted in <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a>, the polymorphic comparison is less efficient than
        defining explicit comparison functions between values. However, it quickly becomes tedious
        to manually define comparison functions for complex type definitions.<a name="idm181609312608"></a><a name="idm181609311056"></a></p><p id="idm181609310016">Let's see how <code>comparelib</code> solves
      this problem by running it in <span><strong>utop</strong></span>:</p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;comparelib.syntax&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span> bar <span class="keyword2">:</span> t <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : string; bar : t; }
</div># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> t <span class="keyword2">}</span> <span class="keyword1">with</span> compare <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : string; bar : t; }
val compare : t -&gt; t -&gt; int = &lt;fun&gt;
val compare_t : t -&gt; t -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/camlp4_toplevel.topscript">front-end/camlp4_toplevel.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181670357744">The first definition of <code>t</code> is a standard OCaml phrase
        and results in the expected output. The second one includes the <code>with compare</code> directive. This is intercepted by <code>comparelib</code> and transformed into the original type definition with two new
        functions also <span>included</span>.</p></section><section id="running-camlp4-from-the-command-line"><h1>Running Camlp4 from the Command Line</h1><p id="idm181609301184">The toplevel is a quick way to examine the signatures generated from the extensions, but
        how can we see what these new functions actually do? We can't do this from <span><strong>utop</strong></span> directly, since it embeds the Camlp4 invocation as an
        automated part of its operation.<a name="idm181609300016"></a></p><p id="idm181609298576">Let's turn to the command line to obtain the result of the
      <code>comparelib</code> transformation instead.
      Create a file that contains the type declaration from earlier:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> 
  foo<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span> 
  bar<span class="keyword2">:</span> t
<span class="keyword2">}</span> <span class="keyword1">with</span> compare</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/comparelib_test.ml">front-end/comparelib_test.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609295104">We need to run the Camlp4 binary with the library paths to
      Comparelib and Type_conv. Let's use a small shell script to wrap this
      invocation:</p><div class="rwocode"><pre><code><div class="highlight"><span class="c">#!/bin/sh</span>

<span class="nv">OCAMLFIND</span><span class="o">=</span><span class="s2">&quot;ocamlfind query -predicates syntax,preprocessor -r&quot;</span>
<span class="nv">INCLUDE</span><span class="o">=</span><span class="sb">`</span><span class="nv">$OCAMLFIND</span> -i-format comparelib.syntax<span class="sb">`</span>
<span class="nv">ARCHIVES</span><span class="o">=</span><span class="sb">`</span><span class="nv">$OCAMLFIND</span> -a-format comparelib.syntax<span class="sb">`</span>
camlp4o -printer o <span class="nv">$INCLUDE</span> <span class="nv">$ARCHIVES</span> <span class="nv">$1</span>
</div></code></pre><div class="rwocodeinfo">Shell script ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/camlp4_dump.cmd">front-end/camlp4_dump.cmd</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609292128">The script uses the <span><strong>ocamlfind</strong></span>
      package manager to list the include and library paths needed by <code>comparelib</code>. It then invokes the <span><strong>camlp4o</strong></span> preprocessor with these paths and
      outputs the resulting AST to the standard output:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> sh camlp4_dump.cmd comparelib_test.ml
</div><div class="rwocodeout">type t = { foo : string; bar : t }</div><div class="rwocodeout"> </div><div class="rwocodeout">let _ = fun (_ : t) -&gt; ()</div><div class="rwocodeout">  </div><div class="rwocodeout">let rec compare : t -&gt; t -&gt; int =</div><div class="rwocodeout">  fun a__001_ b__002_ -&gt;</div><div class="rwocodeout">    if Pervasives.( == ) a__001_ b__002_</div><div class="rwocodeout">    then 0</div><div class="rwocodeout">    else</div><div class="rwocodeout">      (let ret =</div><div class="rwocodeout">         (Pervasives.compare : string -&gt; string -&gt; int) a__001_.foo</div><div class="rwocodeout">           b__002_.foo</div><div class="rwocodeout">       in</div><div class="rwocodeout">         if Pervasives.( &lt;&gt; ) ret 0</div><div class="rwocodeout">         then ret</div><div class="rwocodeout">         else compare a__001_.bar b__002_.bar)</div><div class="rwocodeout">  </div><div class="rwocodeout">let _ = compare</div><div class="rwocodeout">  </div><div class="rwocodeout">let compare_t = compare</div><div class="rwocodeout">  </div><div class="rwocodeout">let _ = compare_t</div><div class="rwocodeout">  </div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/process_comparelib_test.out">front-end/process_comparelib_test.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609270800">The output contains the original type definition accompanied by
      some automatically generated code that implements an explicit comparison
      function for each field in the record. If you're using the extension in
      your compiler command line, this generated code is then compiled as if
      you had typed it in yourself.</p><p id="idm181609270080">Note that although the generated code uses <code>Pervasives.compare</code>, it is also annotated with
      a <code>string</code> type. This lets the compiler
      use a specialized string comparison function and not actually call the
      runtime polymorphic comparison function. This has implications for
      correctness, too: recall from <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a>
      that <code>comparelib</code> provides reliable
      comparison functions that work for values that are logically the same
      but that have differing internal representations (e.g., <code>Int.Set.t</code>).<a name="idm181609266240"></a><a name="idm181609265344"></a><a name="idm181609264032"></a></p><aside class="note"><h1>A Style Note: Wildcards in let Bindings</h1><p id="idm181609261664">You may have noticed the <code>let _ =
        fun</code> construct in the autogenerated code above. The
        underscore in a <code>let</code> binding is just
        the same as a wildcard underscore in a pattern match, and tells the
        compiler to accept any return value and discard it immediately.</p><p id="idm181609259712">This is fine for mechanically generated code from Type_conv but
        should be avoided in code that you write by hand. If it's a
        unit-returning expression, then write a <code>unit</code> binding explicitly instead. This will
        cause a type error if the expression changes type in the future (e.g.,
        due to code refactoring):</p><div class="rwocode"><pre><code><pre>let () = &lt;expr&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/let_unit.syntax">front-end/let_unit.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609256320">If the expression has a different type, then write it
        explicitly:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword8">_</span><span class="keyword2">:</span>some_type<span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword2">&lt;</span>expr<span class="keyword2">&gt;</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> ignore <span class="keyword2">(</span><span class="keyword2">&lt;</span>expr<span class="keyword2">&gt;</span> <span class="keyword2">:</span> some_type<span class="keyword2">)</span>
<span class="keyword2">)</span><span class="comments">(* if the expression returns a unit Deferred.t *)</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> don't_wait_for <span class="keyword2">(</span><span class="keyword2">&lt;</span>expr<span class="keyword2">&gt;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/let_notunit.ml">front-end/let_notunit.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609253152">The last one is used to ignore Async expressions that should run
        in the background rather than blocking in the current thread.</p><p id="idm181609252624">One other important reason for using wildcard matches is to bind
        a variable name to something that you want to use in future code but
        don't want to use right away. This would normally generate an &quot;unused
        value&quot; compiler warning. These warnings are suppressed for any
        variable name that's prepended with an underscore:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> fn x y <span class="keyword2">=</span>
  <span class="keyword4">let</span> _z <span class="keyword2">=</span> x <span class="keyword2">+</span> y <span class="keyword4">in</span>
  <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/unused_var.ml">front-end/unused_var.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609249728">Although you don't use <code>_z</code> in
        your code, this will never generate an unused variable warning.</p></aside></section><section id="preprocessing-module-signatures"><h1>Preprocessing Module Signatures</h1><p id="idm181609247392">Another useful feature of <code>type_conv</code> is that it can
        generate module signatures, too. Copy the earlier type definition into a <code>comparelib_test.mli</code> that's got exactly the same <span>content</span>:<a name="idm181609245024"></a><a name="idm181609243712"></a></p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> 
  foo<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span> 
  bar<span class="keyword2">:</span> t
<span class="keyword2">}</span> <span class="keyword1">with</span> compare</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/comparelib_test.mli">front-end/comparelib_test.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609240000">If you rerun the Camlp4 dumper script now, you'll see that
      different code is produced for signature files:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> sh camlp4_dump.cmd comparelib_test.mli
</div><div class="rwocodeout">type t = { foo : string; bar : t }</div><div class="rwocodeout"> </div><div class="rwocodeout">val compare : t -&gt; t -&gt; int</div><div class="rwocodeout">  </div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/process_comparelib_interface.out">front-end/process_comparelib_interface.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609233104">The external signature generated by <code>comparelib</code> is much simpler than the actual
      code. Running Camlp4 directly on the original source code lets you see
      these all these transformations precisely.<a name="idm181609232000"></a><a name="idm181609230720"></a><a name="idm181609229824"></a><a name="idm181609228912"></a><a name="idm181609227984"></a></p><aside class="caution"><h1>Don't Overdo the Syntax Extensions</h1><p id="idm181609225600">Syntax extensions are a powerful extension mechanism that can
        completely alter your source code's layout and style. Core includes a
        very conservative set of extensions that take care to minimize the
        syntax changes. There are a number of third-party libraries that are
        much more ambitious—some introduce whitespace-sensitive indentation,
        while others build entirely new embedded languages using OCaml as a
        host language, and yet others introduce conditional compilation for
        macros or optional logging.</p><p id="idm181609225216">While it's tempting to compress all your boilerplate code into Camlp4 extensions, it
          can make your source code much harder for other people to quickly read and understand.
          Core mainly focuses on type-driven code generation using the <code>type_conv</code> extension and doesn't fundamentally change the OCaml syntax.</p><p id="idm181609223840">Another thing to consider before deploying your own syntax
        extension is compatibility with other extensions. Two separate
        extensions can create a grammar clash that leads to odd syntax errors
        and hard-to-reproduce bugs. That's why most of Core's syntax
        extensions go through <code>type_conv</code>,
        which acts as a single point for extending the grammar via the
        <code>with</code> keyword.</p></aside></section><section id="further-reading-on-camlp4"><h1>Further Reading on Camlp4</h1><p id="idm181609220592">We've deliberately only shown you how to use Camlp4 extensions
      here, and not how to build your own. The full details of building new
      extensions are fairly daunting and could be the subject of an entirely
      new book.<a name="idm181609220096"></a><a name="idm181609218784"></a></p><p id="idm181609217344">The best resources to get started are:<a name="idm181609217040"></a><a name="idm181609216432"></a><a name="idm181609215824"></a><a name="idm181609215216"></a></p><ul><li><p id="idm181609213968">A series of <a href="http://ambassadortothecomputers.blogspot.co.uk/p/reading-camlp4.html" target="_top">blog
          posts</a> by Jake Donham describe the internals of Camlp4 and
          its syntax extension mechanism</p></li><li><p id="idm181609212368">The online <a href="http://brion.inria.fr/gallium/index.php/Camlp4" target="_top">Camlp4
          wiki</a></p></li><li><p id="idm181609211024">Using OPAM to install existing Camlp4 extensions and
          inspecting their source code</p></li></ul></section></section><section id="static-type-checking"><h1>Static Type Checking</h1><p id="idm181609209104">After obtaining a valid abstract syntax tree, the compiler has to
    verify that the code obeys the rules of the OCaml type system. Code that
    is syntactically correct but misuses values is rejected with an
    explanation of the problem.</p><p id="idm181609208464">Although type checking is done in a single pass in OCaml, it
    actually consists of three distinct steps that happen
    simultaneously:<a name="idm181609208064"></a><a name="idm181609206752"></a><a name="idm181609205440"></a><a name="idm181609203888"></a><a name="idm181609202336"></a><a name="CPstatictype"></a></p><div><dl><dt><span>automatic type inference</span></dt><dd><p id="idm181609197904">An algorithm that calculates types for a module without
          requiring manual type annotations</p></dd><dt><span>module system</span></dt><dd><p id="idm181609196240">Combines software components with explicit knowledge of their
          type signatures</p></dd><dt><span>explicit subtyping</span></dt><dd><p id="idm181609194576">Checks for objects and polymorphic variants</p></dd></dl></div><p id="idm181609193760">Automatic type inference lets you write succinct code for a
    particular task and have the compiler ensure that your use of variables is
    locally consistent.</p><p id="idm181609193200">Type inference doesn't scale to very large codebases that depend on separate compilation
      of files. A small change in one module may ripple through thousands of other files and
      libraries and require all of them to be recompiled. The module system solves this by providing
      the facility to combine and manipulate explicit type signatures for modules within a large
      project, and also to reuse them via functors and first-class modules.<a name="idm181609192480"></a><a name="idm181609191184"></a></p><p id="idm181609189760">Subtyping in OCaml objects is always an explicit operation (via the
    <code>:&gt;</code> operator). This means that it
    doesn't complicate the core type inference engine and can be tested as a
    separate concern.</p><section id="displaying-inferred-types-from-the-compiler"><h1>Displaying Inferred Types from the Compiler</h1><p id="idm181609187552">We've already seen how you can explore type inference directly
      from the toplevel. It's also possible to generate type signatures for an
      entire file by asking the compiler to do the work for you. Create a file
      with a single type definition and value:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword6">Foo </span><span class="keyword2">|</span> <span class="keyword6">Bar
</span><span class="keyword4">let</span> v <span class="keyword2">=</span> Foo</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/typedef.ml">front-end/typedef.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609184400">Now run the compiler with the <code>-i</code> flag to infer the type signature for that
      file. This runs the type checker but doesn't compile the code any
      further after displaying the interface to the standard output:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -i typedef.ml
</div><div class="rwocodeout">type t = Foo | Bar</div><div class="rwocodeout">val v : t</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/infer_typedef.out">front-end/infer_typedef.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609178736">The output is the default signature for the module that represents the input file. It's
        often useful to redirect this output to an <code>mli</code> file to
        give you a starting signature to edit the external interface without having to type it all
        in by hand.</p><p id="idm181609177456">The compiler stores a compiled version of the interface as a
      <code>cmi</code> file. This interface is either
      obtained from compiling an <code>mli</code>
      signature file for a module, or by the inferred type if there is only an
      <code>ml</code> implementation present.</p><p id="idm181609174880">The compiler makes sure that your <code>ml</code> and <code>mli</code>
      files have compatible signatures. The type checker throws an immediate
      error if this isn't the case:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> <span class="nb">echo type </span><span class="nv">t</span> <span class="o">=</span> Foo &gt; test.ml
</div><div class="highlight"><span class="gp">$</span> <span class="nb">echo type </span><span class="nv">t</span> <span class="o">=</span> Bar &gt; test.mli
</div><div class="highlight"><span class="gp">$</span> ocamlc -c test.mli test.ml
</div><div class="rwocodeout">File &quot;test.ml&quot;, line 1:</div><div class="rwocodeout">Error: The implementation test.ml does not match the interface test.cmi:</div><div class="rwocodeout">       Type declarations do not match:</div><div class="rwocodeout">         type t = Foo</div><div class="rwocodeout">       is not included in</div><div class="rwocodeout">         type t = Bar</div><div class="rwocodeout">       File &quot;test.ml&quot;, line 1, characters 5-12: Actual declaration</div><div class="rwocodeout">       Fields number 1 have different names, Foo and Bar.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/conflicting_interfaces.out">front-end/conflicting_interfaces.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="note"><h1>Which Comes First: The ml or the mli?</h1><p id="idm181609161296">There are two schools of thought on which order OCaml code
        should be written in. It's very easy to begin writing code by starting
        with an <code>ml</code> file and using the type
        inference to guide you as you build up your functions. The <code>mli</code> file can then be generated as described,
        and the exported functions documented.<a name="idm181609159440"></a><a name="idm181609157728"></a><a name="idm181609156832"></a><a name="idm181609155536"></a><a name="idm181609154640"></a></p><p id="idm181609153216">If you're writing code that spans multiple files, it's sometimes easier to start by
          writing all the <code>mli</code> signatures and checking that they
          type-check against one another. Once the signatures are in place, you can write the
          implementations with the confidence that they'll all glue together correctly, with no
          cyclic dependencies among the modules.</p><p id="idm181609151808">As with any such stylistic debate, you should experiment with which system works best
          for you. Everyone agrees on one thing though: no matter in what order you write them,
          production code should always explicitly define an <code>mli</code>
          file for every <code>ml</code> file in the project. It's also
          perfectly fine to have an <code>mli</code> file without a
          corresponding <code>ml</code> file if you're only declaring
          signatures (such as module types).</p><p id="idm181609148432">Signature files provide a place to write succinct documentation
        and to abstract internal details that shouldn't be exported.
        Maintaining separate signature files also speeds up incremental
        compilation in larger code bases, since recompiling a <code>mli</code> signature is much faster than a full
        compilation of the implementation to native code.</p></aside></section><section id="type-inference-1"><h1>Type Inference</h1><p id="idm181609145888">Type inference is the process of determining the appropriate types
      for expressions based on their use. It's a feature that's partially
      present in many other languages such as Haskell and Scala, but OCaml
      embeds it as a fundamental feature throughout the core
      language.<a name="idm181609145328"></a><a name="idm181609144416"></a></p><p id="idm181609142976">OCaml type inference is based on the Hindley-Milner algorithm,
      which is notable for its ability to infer the most general type for an
      expression without requiring any explicit type annotations. The
      algorithm can deduce multiple types for an expression and has the notion
      of a <span><em>principal type</em></span> that is the most general choice
      from the possible inferences. Manual type annotations can specialize the
      type explicitly, but the automatic inference selects the most general
      type unless told otherwise.</p><p id="idm181609141664">OCaml does have some language extensions that strain the limits of
      principal type inference, but by and large, most programs you write will
      never <span><em>require</em></span> annotations (although they sometimes
      help the compiler produce better error messages).</p><section id="adding-type-annotations-to-find-errors"><h1>Adding type annotations to find errors</h1><p id="idm181609139664">It's often said that the hardest part of writing OCaml code is
        getting past the type checker—but once the code does compile, it works
        correctly the first time! This is an exaggeration of course, but it
        can certainly feel true when moving from a dynamically typed language.
        The OCaml static type system protects you from certain classes of bugs
        such as memory errors and abstraction violations by rejecting your
        program at compilation time rather than by generating an error at
        runtime. Learning how to navigate the type checker's compile-time
        feedback is key to building robust libraries and applications that
        take full advantage of these static checks.<a name="idm181609138480"></a><a name="idm181609137168"></a><a name="idm181609136256"></a><a name="idm181609134944"></a><a name="idm181609134032"></a></p><p id="idm181609132992">There are a couple of tricks to make it easier to quickly locate
        type errors in your code. The first is to introduce manual type
        annotations to narrow down the source of your error more accurately.
        These annotations shouldn't actually change your types and can be
        removed once your code is correct. However, they act as anchors to
        locate errors while you're still writing your code.</p><p id="idm181609132176">Manual type annotations are particularly useful if you use lots
        of polymorphic variants or objects. Type inference with row
        polymorphism can generate some very large signatures, and errors tend
        to propagate more widely than if you are using more explicitly typed
        variants or classes.<a name="idm181609131600"></a><a name="idm181609130272"></a></p><p id="idm181609129232">For instance, consider this broken example that expresses some
        simple algebraic operations over integers:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword4">rec</span> algebra <span class="keyword2">=</span>
  <span class="keyword1">function</span>
  <span class="keyword2">|</span> <span class="keyword6">`Add </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> <span class="keyword2">+</span> <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Sub </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> - <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Mul </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> <span class="keyword2">*</span> <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Num </span>x     -<span class="keyword2">&gt;</span> x

<span class="keyword4">let</span> <span class="keyword8">_</span> <span class="keyword2">=</span>
  algebra <span class="keyword2">(</span>
    <span class="keyword6">`Add </span><span class="keyword2">(</span>
      <span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">0</span><span class="keyword2">)</span>,
      <span class="keyword2">(</span><span class="keyword6">`Sub </span><span class="keyword2">(</span>
          <span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">1</span><span class="keyword2">)</span>,
          <span class="keyword2">(</span><span class="keyword6">`Mul </span><span class="keyword2">(</span>
              <span class="keyword2">(</span><span class="keyword6">`Nu </span><span class="keyword8">3</span><span class="keyword2">)</span>,<span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">2</span><span class="keyword2">)</span>
            <span class="keyword2">)</span><span class="keyword2">)</span>
        <span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/broken_poly.ml">front-end/broken_poly.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609126368">There's a single character typo in the code so that it uses
        <code>Nu</code> instead of <code>Num</code>. The resulting type error is
        impressive:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c broken_poly.ml
</div><div class="rwocodeout">File &quot;broken_poly.ml&quot;, line 9, characters 10-154:</div><div class="rwocodeout">Error: This expression has type</div><div class="rwocodeout">         [&gt; `Add of</div><div class="rwocodeout">              ([&lt; `Add of 'a * 'a</div><div class="rwocodeout">                | `Mul of 'a * 'a</div><div class="rwocodeout">                | `Num of int</div><div class="rwocodeout">                | `Sub of 'a * 'a</div><div class="rwocodeout">                &gt; `Num ]</div><div class="rwocodeout">               as 'a) *</div><div class="rwocodeout">              [&gt; `Sub of 'a * [&gt; `Mul of [&gt; `Nu of int ] * [&gt; `Num of int ] ] ] ]</div><div class="rwocodeout">       but an expression was expected of type 'a</div><div class="rwocodeout">       The second variant type does not allow tag(s) `Nu</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_broken_poly.out">front-end/build_broken_poly.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609112640">The type error is perfectly accurate, but rather verbose and
        with a line number that doesn't point to the exact location of the
        incorrect variant name. The best the compiler can do is to point you
        in the general direction of the <code>algebra</code> function application.</p><p id="idm181609111328">This is because the type checker doesn't have enough information
        to match the inferred type of the <code>algebra</code> definition to its application a few
        lines down. It calculates types for both expressions separately, and
        when they don't match up, outputs the difference as best it
        can.</p><p id="idm181609109984">Let's see what happens with an explicit type annotation to help
        the compiler out:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">[</span>
  <span class="keyword2">|</span> <span class="keyword6">`Add </span><span class="keyword2">of</span> t <span class="keyword2">*</span> t
  <span class="keyword2">|</span> <span class="keyword6">`Sub </span><span class="keyword2">of</span> t <span class="keyword2">*</span> t
  <span class="keyword2">|</span> <span class="keyword6">`Mul </span><span class="keyword2">of</span> t <span class="keyword2">*</span> t
  <span class="keyword2">|</span> <span class="keyword6">`Num </span><span class="keyword2">of</span> <span class="keyword3">int</span>
<span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword4">rec</span> algebra <span class="keyword2">(</span>x<span class="keyword2">:</span>t<span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword1">match</span> x <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">`Add </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> <span class="keyword2">+</span> <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Sub </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> - <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Mul </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> <span class="keyword2">*</span> <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Num </span>x     -<span class="keyword2">&gt;</span> x

<span class="keyword4">let</span> <span class="keyword8">_</span> <span class="keyword2">=</span>
  algebra <span class="keyword2">(</span>
    <span class="keyword6">`Add </span><span class="keyword2">(</span>
      <span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">0</span><span class="keyword2">)</span>,
      <span class="keyword2">(</span><span class="keyword6">`Sub </span><span class="keyword2">(</span>
          <span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">1</span><span class="keyword2">)</span>,
          <span class="keyword2">(</span><span class="keyword6">`Mul </span><span class="keyword2">(</span>
              <span class="keyword2">(</span><span class="keyword6">`Nu </span><span class="keyword8">3</span><span class="keyword2">)</span>,<span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">2</span><span class="keyword2">)</span>
            <span class="keyword2">)</span><span class="keyword2">)</span>
        <span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/broken_poly_with_annot.ml">front-end/broken_poly_with_annot.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609107152">This code contains exactly the same error as before, but we've
        added a closed type definition of the polymorphic variants, and a type
        annotation to the <code>algebra</code>
        definition. The compiler error we get is much more useful now:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -i broken_poly_with_annot.ml
</div><div class="rwocodeout">File &quot;broken_poly_with_annot.ml&quot;, line 22, characters 14-21:</div><div class="rwocodeout">Error: This expression has type [&gt; `Nu of int ]</div><div class="rwocodeout">       but an expression was expected of type t</div><div class="rwocodeout">       The second variant type does not allow tag(s) `Nu</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_broken_poly_with_annot.out">front-end/build_broken_poly_with_annot.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609099280">This error points directly to the correct line number that
        contains the typo. Once you fix the problem, you can remove the manual
        annotations if you prefer more succinct code. You can also leave the
        annotations there, of course, to help with future refactoring and
        debugging.</p></section><section id="enforcing-principal-typing"><h1>Enforcing principal typing</h1><p id="idm181609097520">The compiler also has a stricter <span><em>principal type checking</em></span> mode
          that is activated via the <span><code>-principal</code></span> flag. This warns about risky uses of type information
          to ensure that the type inference has one principal result. A type is considered risky if
          the success or failure of type inference depends on the order in which subexpressions are
            typed.<a name="idm181609095456"></a><a name="idm181609094144"></a><a name="idm181609093248"></a></p><p id="idm181609092208">The principality check only affects a few language
        features:</p><ul><li><p id="idm181609091232">Polymorphic methods for objects</p></li><li><p id="idm181609090432">Permuting the order of labeled arguments in a function from
            their type definition</p></li><li><p id="idm181609089568">Discarding optional labeled arguments</p></li><li><p id="idm181609088752">Generalized algebraic data types (GADTs) present from OCaml 4.0 onward</p></li><li><p id="idm181609087904">Automatic disambiguation of record field and constructor
            names (since OCaml 4.1)</p></li></ul><p id="idm181609087168">Here's an example of principality warnings when used with record
        disambiguation.</p><div class="rwocode"><pre><code><span class="keyword4">type</span> s <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> unit <span class="keyword2">}</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword2">}</span>

<span class="keyword4">let</span> f x <span class="keyword2">=</span>
  x.bar<span class="keyword2">;</span>
  x.foo</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/non_principal.ml">front-end/non_principal.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609084384">Inferring the signature with <code>-principal</code> will show you a new
        warning:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -i -principal non_principal.ml
</div><div class="rwocodeout">File &quot;non_principal.ml&quot;, line 6, characters 4-7:</div><div class="rwocodeout">Warning 18: this type-based field disambiguation is not principal.</div><div class="rwocodeout">type s = { foo : int; bar : unit; }</div><div class="rwocodeout">type t = { foo : int; }</div><div class="rwocodeout">val f : s -&gt; int</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_non_principal.out">front-end/build_non_principal.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609076768">This example isn't principal, since the inferred type for
        <code>x.foo</code> is guided by the inferred
        type of <code>x.bar</code>, whereas principal
        typing requires that each subexpression's type can be calculated
        independently. If the <code>x.bar</code> use is
        removed from the definition of <code>f</code>,
        its argument would be of type <code>t</code> and
        not <code>type s</code>.</p><p id="idm181609072208">You can fix this either by permuting the order of the type
        declarations, or by adding an explicit type annotation:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> s <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> unit <span class="keyword2">}</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword2">}</span>

<span class="keyword4">let</span> f <span class="keyword2">(</span>x<span class="keyword2">:</span>s<span class="keyword2">)</span> <span class="keyword2">=</span>
  x.bar<span class="keyword2">;</span>
  x.foo</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/principal.ml">front-end/principal.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609069408">There is now no ambiguity about the inferred types, since we've
        explicitly given the argument a type, and the order of inference of
        the subexpressions no longer matters.</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -i -principal principal.ml
</div><div class="rwocodeout">type s = { foo : int; bar : unit; }</div><div class="rwocodeout">type t = { foo : int; }</div><div class="rwocodeout">val f : s -&gt; int</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_principal.out">front-end/build_principal.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609063712">The <span><strong>ocamlbuild</strong></span> equivalent is to add the tag
            <code>principal</code> to your build. The
            <span><em>corebuild</em></span> wrapper script actually adds this by default, but it does
          no harm to explicitly repeat it:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -tag principal principal.cmi non_principal.cmi
</div><div class="rwocodeout">File &quot;non_principal.ml&quot;, line 6, characters 4-7:</div><div class="rwocodeout">Warning 18: this type-based field disambiguation is not principal.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/principal/build_principal.out">principal/build_principal.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609056912">Ideally, all code should systematically use <code>-principal</code>. It reduces variance in type inference and enforces the notion of
          a single known type. However, there are drawbacks to this mode: type inference is slower,
          and the <code>cmi</code> files become larger. This is generally only
          a problem if you extensively use objects, which usually have larger type signatures to
          cover all their methods.</p><p id="idm181609054832">If compiling in principal mode works, it is guaranteed that the
        program will pass type checking in nonprincipal mode, too. For this
        reason, the <span><strong>corebuild</strong></span> wrapper
        script activates principal mode by default, preferring stricter type
        inference over a small loss in compilation speed and extra disk space
        usage.</p><p id="idm181609053440">Bear in mind that the <code>cmi</code> files generated in
          principal mode differ from the default mode. Try to ensure that you compile your whole
          project with it activated. Getting the files mixed up won't let you violate type safety,
          but it can result in the type checker failing unexpectedly very occasionally. In this
          case, just recompile with a clean source tree.</p></section></section><section id="modules-and-separate-compilation"><h1>Modules and Separate Compilation</h1><p id="idm181609050800">The OCaml module system enables smaller components to be reused
      effectively in large projects while still retaining all the benefits of
      static type safety. We covered the basics of using modules earlier in
      <a href="files-modules-and-programs.html">Chapter 4, <i>Files, Modules, and Programs</i></a>. The module language that
      operates over these signatures also extends to functors and first-class
      modules, described in <a href="functors.html">Chapter 9, <i>Functors</i></a> and <a href="first-class-modules.html">Chapter 10, <i>First-Class Modules</i></a>, respectively.<a name="idm181609048608"></a></p><p id="idm181609047168">This section discusses how the compiler implements them in more
      detail. Modules are essential for larger projects that consist of many
      source files (also known as <span><em>compilation units</em></span>).
      It's impractical to recompile every single source file when changing
      just one or two files, and the module system minimizes such
      recompilation while still encouraging code reuse.<a name="idm181609046112"></a></p><section id="the-mapping-between-files-and-modules"><h1>The mapping between files and modules</h1><p id="idm181609044112">Individual compilation units provide a convenient way to break
        up a big module hierarchy into a collection of files. The relationship
        between files and modules can be explained directly in terms of the
        module system.<a name="idm181609043600"></a></p><p id="idm181609042160">Create a file called <code>alice.ml</code>
        with the following contents:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> friends <span class="keyword2">=</span> <span class="keyword2">[</span> <span class="keyword5">Bob.</span>name <span class="keyword2">]</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/alice.ml">front-end/alice.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609038832">and a corresponding signature file:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> friends <span class="keyword2">:</span> <span class="keyword5">Bob.</span>t <span class="keyword3">list</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/alice.mli">front-end/alice.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609036176">These two files are exactly analogous to including the following
        code directly in another module that references <code>Alice</code>:</p><div class="rwocode"><pre><code><span class="keyword4">module</span> <span class="keyword6">Alice </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
  <span class="keyword4">val</span> friends <span class="keyword2">:</span> <span class="keyword5">Bob.</span>t <span class="keyword3">list</span>
<span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>
  <span class="keyword4">let</span> friends <span class="keyword2">=</span> <span class="keyword2">[</span> <span class="keyword5">Bob.</span>name <span class="keyword2">]</span>
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/alice_combined.ml">front-end/alice_combined.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="defining-a-module-search-path"><h1>Defining a module search path</h1><p id="idm181609031664">In the preceding example, <code>Alice</code> also has a reference to another module
        <code>Bob</code>. For the overall type of
        <code>Alice</code> to be valid, the compiler
        also needs to check that the <code>Bob</code>
        module contains at least a <code>Bob.name</code>
        value and defines a <code>Bob.t</code>
        type.<a name="idm181609027280"></a></p><p id="idm181609025840">The type checker resolves such module references into concrete
        structures and signatures in order to unify types across module
        boundaries. It does this by searching a list of directories for a
        compiled interface file matching that module's name. For example, it
        will look for <code>alice.cmi</code> and
        <code>bob.cmi</code> on the search path and use
        the first ones it encounters as the interfaces for <code>Alice</code> and <code>Bob</code>.</p><p id="idm181609022464">The module search path is set by adding <code>-I</code> flags to the compiler command line with
        the directory containing the <code>cmi</code>
        files as the argument. Manually specifying these flags gets complex
        when you have lots of libraries, and is the reason why the OCamlfind
        frontend to the compiler exists. OCamlfind automates the process of
        turning third-party package names and build descriptions into
        command-line flags that are passed to the compiler command
        line.</p><p id="idm181609020320">By default, only the current directory and the OCaml standard
        library will be searched for <code>cmi</code>
        files. The <code>Pervasives</code> module from
        the standard library will also be opened by default in every
        compilation unit. The standard library location is obtained by running
        <code>ocamlc -where</code> and can be overridden
        by setting the <code>CAMLLIB</code> environment
        variable. Needless to say, don't override the default path unless you
        have a good reason to (such as setting up a cross-compilation
        environment).<a name="idm181609016960"></a><a name="idm181609016064"></a><a name="idm181609014768"></a></p><section><h1><b>Inspecting Compilation Units with ocamlobjinfo</b></h1><p id="idm181609012656">For separate compilation to be sound, we need to ensure that
          all the <code>cmi</code> files used to
          type-check a module are the same across compilation runs. If they
          vary, this raises the possibility of two modules checking different
          type signatures for a common module with the same name. This in turn
          lets the program completely violate the static type system and can
          lead to memory corruption and crashes.</p><p id="idm181609011184">OCaml guards against this by recording a MD5 checksum in every
          <code>cmi</code>. Let's examine our earlier
          <code>typedef.ml</code> more closely:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c typedef.ml
</div><div class="highlight"><span class="gp">$</span> ocamlobjinfo typedef.cmi
</div><div class="rwocodeout">File typedef.cmi</div><div class="rwocodeout">Unit name: Typedef</div><div class="rwocodeout">Interfaces imported:</div><div class="rwocodeout">	bd274dc132ce5c3d8b6774d19cd373a6	Typedef</div><div class="rwocodeout">	36b5bc8227dc9914c6d9fd9bdcfadb45	Pervasives</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/typedef_objinfo.out">front-end/typedef_objinfo.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181609001824"><code>ocamlobjinfo</code> examines the
          compiled interface and displays what other compilation units it
          depends on. In this case, we don't use any external modules other
          than <code>Pervasives</code>. Every module
          depends on <code>Pervasives</code> by default,
          unless you use the <code>-nopervasives</code>
          flag (this is an advanced use case, and you shouldn't normally need
          it).</p><p id="idm181608998624">The long alphanumeric identifier beside each module name is a
          hash calculated from all the types and values exported from that
          compilation unit. It's used during type-checking and linking to
          ensure that all of the compilation units have been compiled
          consistently against one another. A difference in the hashes means
          that a compilation unit with the same module name may have
          conflicting type signatures in different modules. The compiler will
          reject such programs with an error similar to this:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c foo.ml
</div><div class="rwocodeout">File &quot;foo.ml&quot;, line 1, characters 0-1:</div><div class="rwocodeout">Error: The files /home/build/bar.cmi</div><div class="rwocodeout">       and /usr/lib/ocaml/map.cmi make inconsistent assumptions</div><div class="rwocodeout">       over interface Map</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/inconsistent_compilation_units.out">front-end/inconsistent_compilation_units.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608991856">This hash check is very conservative, but ensures that
          separate compilation remains type-safe all the way up to the final
          link phase. Your build system should ensure that you never see the
          preceding error messages, but if you do run into it, just clean out
          your intermediate files and recompile from scratch.</p></section></section></section><section id="packing-modules-together"><h1>Packing Modules Together</h1><p id="idm181608989808">The module-to-file mapping described so far rigidly enforces a 1:1
      mapping between a top-level module and a file. It's often convenient to
      split larger modules into separate files to make editing easier, but
      still compile them all into a single OCaml module.<a name="idm181608989264"></a></p><p id="idm181608987824">The <code>-pack</code> compiler option
      accepts a list of compiled object files (<code>.cmo</code> in bytecode and <code>.cmx</code> for native code) and their associated
      <code>.cmi</code> compiled interfaces, and
      combines them into a single module that contains them as submodules of
      the output. Packing thus generates an entirely new <code>.cmo</code> (or <code>.cmx</code> file) and <code>.cmi</code> that includes the input modules.</p><p id="idm181608982528">Packing for native code introduces an additional requirement: the
      modules that are intended to be packed must be compiled with the
      <code>-for-pack</code> argument that specifies the
      eventual name of the pack. The easiest way to handle packing is to let
      <span><strong>ocamlbuild</strong></span> figure out the
      command-line arguments for you, so let's try that out next with a simple
      example.</p><p id="idm181608980480">First, create a couple of toy modules called <code>A.ml</code> and <code>B.ml</code> that contain a single value. You will
      also need a <code>_tags</code> file that adds the
      <code>-for-pack</code> option for the <code>cmx</code> files (but careful to exclude the pack
      target itself). Finally, the <code>X.mlpack</code>
      file contains the list of modules that are intended to be packed under
      module <code>X</code>. There are special rules in
      <span><strong>ocamlbuild</strong></span> that tell it how to map
      <code>%.mlpack</code> files to the packed <code>%.cmx</code> or <code>%.cmo</code> equivalent:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> cat A.ml
</div><div class="rwocodeout">let v = &quot;hello&quot;</div><div class="highlight"><span class="gp">$</span> cat B.ml
</div><div class="rwocodeout">let w = 42</div><div class="highlight"><span class="gp">$</span> cat _tags
</div><div class="rwocodeout">&lt;*.cmx&gt; and not &quot;X.cmx&quot;: for-pack(X)</div><div class="highlight"><span class="gp">$</span> cat X.mlpack
</div><div class="rwocodeout">A</div><div class="rwocodeout">B</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/packing/show_files.out">packing/show_files.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608962816">You can now run <span><em>corebuild</em></span> to build the <code>X.cmx</code> file directly, but let's create a new module to link against <code>X</code> to complete the example:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> v <span class="keyword2">=</span> <span class="keyword5">X.</span><span class="keyword5">A.</span>v
<span class="keyword4">let</span> w <span class="keyword2">=</span> <span class="keyword5">X.</span><span class="keyword5">B.</span>w</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/packing/test.ml">packing/test.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608958400">You can now compile this test module and see that its inferred
      interface is the result of using the packed contents of <code>X</code>. We further verify this by examining the
      imported interfaces in <code>Test</code> and
      confirming that neither <code>A</code> nor
      <code>B</code> are mentioned in there and that
      only the packed <code>X</code> module is
      used:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild test.inferred.mli test.cmi
</div><div class="highlight"><span class="gp">$</span> cat _build/test.inferred.mli
</div><div class="rwocodeout">val v : string</div><div class="rwocodeout">val w : int</div><div class="highlight"><span class="gp">$</span> ocamlobjinfo _build/test.cmi
</div><div class="rwocodeout">File _build/test.cmi</div><div class="rwocodeout">Unit name: Test</div><div class="rwocodeout">Interfaces imported:</div><div class="rwocodeout">	906fc1b74451f0c24ceaa085e0f26e5f	Test</div><div class="rwocodeout">	36b5bc8227dc9914c6d9fd9bdcfadb45	Pervasives</div><div class="rwocodeout">	25f4b4e10ec64c56b2987f5900045fec	X</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/packing/build_test.out">packing/build_test.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="warning"><h1>Packing and Search Paths</h1><p id="idm181608943184">One very common build error that happens with packing is
        confusion resulting from building the packed <code>cmi</code> in the same directory as the submodules.
        When you add this directory to your module search path, the submodules
        are also visible. If you forget to include the top-level prefix (e.g.,
        <code>X.A</code>) and instead use a submodule
        directly (<code>A</code>), then this will
        compile and link fine.</p><p id="idm181608940464">However, the types of <code>A</code> and <code>X.A</code> are <span><em>not</em></span> automatically equivalent so
          the type checker will complain if you attempt to mix and match the packed and unpacked
          versions of the library.</p><p id="idm181608938208">This mostly only happens with unit tests, since they are built at the same time as the
          library. You can avoid it by being aware of the need to open the packed module from the
          test, or only using the library after it has been installed (and hence not exposing the
          intermediate compiled modules).</p></aside></section><section id="shorter-module-paths-in-type-errors"><h1>Shorter Module Paths in Type Errors</h1><p id="idm181608936272">Core uses the OCaml module system quite extensively to provide a complete replacement
        standard library. It collects these modules into a single <code>Std</code> module, which provides a single module that needs to be opened to import
        the replacement modules and functions.<a name="idm181608935072"></a></p><p id="idm181608933632">There's one downside to this approach: type errors suddenly get
      much more verbose. We can see this if you run the vanilla OCaml toplevel
      (not <span><strong>utop</strong></span>).</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocaml
</div><div class="rwocodeout"># List.map print_endline &quot;&quot; ;;</div><div class="rwocodeout">Error: This expression has type string but an expression was expected of type</div><div class="rwocodeout">         string list</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/short_paths_1.out">front-end/short_paths_1.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608927344">This type error without <code>Core.Std</code> has a straightforward type error.
      When we switch to Core, though, it gets more verbose:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocaml
</div><div class="rwocodeout"># open Core.Std ;;</div><div class="rwocodeout"># List.map ~f:print_endline &quot;&quot; ;;</div><div class="rwocodeout">Error: This expression has type string but an expression was expected of type</div><div class="rwocodeout">         'a Core.Std.List.t = 'a list</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/short_paths_2.out">front-end/short_paths_2.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608920400">The default <code>List</code> module in
      OCaml is overridden by <code>Core.Std.List</code>.
      The compiler does its best to show the type equivalence, but at the cost
      of a more verbose error message.</p><p id="idm181608918544">The compiler can remedy this via a so-called short paths
      heuristic. This causes the compiler to search all the type aliases for
      the shortest module path and use that as the preferred output type. The
      option is activated by passing <code>-short-paths</code> to the compiler, and works on the
      toplevel, too.<a name="idm181608917328"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocaml -short-paths
</div><div class="rwocodeout"># open Core.Std;;</div><div class="rwocodeout"># List.map ~f:print_endline &quot;foo&quot;;;</div><div class="rwocodeout">Error: This expression has type string but an expression was expected of type</div><div class="rwocodeout">         'a list</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/short_paths_3.out">front-end/short_paths_3.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608910496">The <span><strong>utop</strong></span> enhanced toplevel activates short paths by
        default, which is why we have not had to do this before in our interactive examples.
        However, the compiler doesn't default to the short path heuristic, since there are some
        situations where the type aliasing information is useful to know, and it would be lost in
        the error if the shortest module path is always picked.</p><p id="idm181608909456">You'll need to choose for yourself if you prefer short paths or
      the default behavior in your own projects, and pass the <code>-short-paths</code> flag to the compiler if you need
      it.<a name="idm181608907584"></a></p></section></section><section id="the-typed-syntax-tree"><h1>The Typed Syntax Tree</h1><p id="idm181608905664">When the type checking process has successfully completed, it is
    combined with the AST to form a <span><em>typed abstract syntax
    tree</em></span>. This contains precise location information for every
    token in the input file, and decorates each token with concrete type
    information.<a name="idm181608904720"></a><a name="idm181608903824"></a><a name="idm181608902928"></a><a name="idm181608901632"></a><a name="idm181608900336"></a><a name="typesyntree"></a><a name="CPtypsyn"></a></p><p id="idm181608896576">The compiler can output this as compiled <code>cmt</code> and <code>cmti</code>
    files that contain the typed AST for the implementation and signatures of
    a compilation unit. This is activated by passing the <code>-bin-annot</code> flag to the compiler.</p><p id="idm181608894048">The <code>cmt</code> files are particularly
    useful for IDE tools to match up OCaml source code at a specific location
    to the inferred or external types.</p><section id="using-ocp-index-for-auto-completion"><h1>Using ocp-index for Autocompletion</h1><p id="idm181608891920">One such command-line tool to display autocompletion information
      in your editor is <span><strong>ocp-index</strong></span>. Install
      it via OPAM as follows:<a name="idm181608890880"></a><a name="idm181608889984"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> opam install ocp-index
</div><div class="highlight"><span class="gp">$</span> ocp-index
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/install_ocp_index.out">front-end/install_ocp_index.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608884720">Let's refer back to our Ncurses binding example from the beginning
      of <a href="foreign-function-interface.html">Chapter 19, <i>Foreign Function Interface</i></a>. This module defined
      bindings for the Ncurses library. First, compile the interfaces with
      <span><code>-bin-annot</code></span> so that we can obtain the
        <code>cmt</code> and <code>cmti</code> files, and then run <span><strong>ocp-index</strong></span> in completion mode:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign -tag bin_annot ncurses.cmi
</div><div class="highlight"><span class="gp">$</span> ocp-index <span class="nb">complete</span> -I . Ncur
</div><div class="rwocodeout">Ncurses module</div><div class="highlight"><span class="gp">$</span> ocp-index <span class="nb">complete</span> -I . Ncurses.a
</div><div class="rwocodeout">Ncurses.addstr val string -&gt; unit</div><div class="highlight"><span class="gp">$</span> ocp-index <span class="nb">complete</span> -I . Ncurses.
</div><div class="rwocodeout">Ncurses.window val Ncurses.window Ctypes.typ</div><div class="rwocodeout">Ncurses.wrefresh val Ncurses.window -&gt; unit</div><div class="rwocodeout">Ncurses.initscr val unit -&gt; Ncurses.window</div><div class="rwocodeout">Ncurses.endwin val unit -&gt; unit</div><div class="rwocodeout">Ncurses.refresh val unit -&gt; unit</div><div class="rwocodeout">Ncurses.newwin val int -&gt; int -&gt; int -&gt; int -&gt; Ncurses.window</div><div class="rwocodeout">Ncurses.mvwaddch val Ncurses.window -&gt; int -&gt; int -&gt; char -&gt; unit</div><div class="rwocodeout">Ncurses.mvwaddstr val Ncurses.window -&gt; int -&gt; int -&gt; string -&gt; unit</div><div class="rwocodeout">Ncurses.addstr val string -&gt; unit</div><div class="rwocodeout">Ncurses.box val Ncurses.window -&gt; char -&gt; char -&gt; unit</div><div class="rwocodeout">Ncurses.cbreak val unit -&gt; int</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ocp-index/index_ncurses.out">ocp-index/index_ncurses.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608864864">You need to pass <span><strong>ocp-index</strong></span> a set of directories to
        search for <code>cmt</code> files in, and a fragment of text to
        autocomplete. As you can imagine, autocompletion is invaluable on larger codebases. See the
          <a href="https://github.com/ocamlpro/ocp-index" target="_top"><span><em>ocp-index</em></span></a>
        home page for more information on how to integrate it with your favorite editor.</p></section><section id="examining-the-typed-syntax-tree-directly"><h1>Examining the Typed Syntax Tree Directly</h1><p id="idm181608861072">The compiler has a couple of advanced flags that can dump the raw
      output of the internal AST representation. You can't depend on these
      flags to give the same output across compiler revisions, but they are a
      useful learning tool.<a name="idm181608860560"></a></p><p id="idm181608859536">We'll use our toy <code>typedef.ml</code>
      again:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword6">Foo </span><span class="keyword2">|</span> <span class="keyword6">Bar
</span><span class="keyword4">let</span> v <span class="keyword2">=</span> Foo</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/typedef.ml">front-end/typedef.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608856240">Let's first look at the untyped syntax tree that's generated from
      the parsing phase:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dparsetree typedef.ml 2&gt;&amp;1
</div><div class="rwocodeout">[</div><div class="rwocodeout">  structure_item (typedef.ml[1,0+0]..[1,0+18])</div><div class="rwocodeout">    Pstr_type</div><div class="rwocodeout">    [</div><div class="rwocodeout">      &quot;t&quot; (typedef.ml[1,0+5]..[1,0+6])</div><div class="rwocodeout">        type_declaration (typedef.ml[1,0+5]..[1,0+18])</div><div class="rwocodeout">          ptype_params =</div><div class="rwocodeout">            []</div><div class="rwocodeout">          ptype_cstrs =</div><div class="rwocodeout">            []</div><div class="rwocodeout">          ptype_kind =</div><div class="rwocodeout">            Ptype_variant</div><div class="rwocodeout">              [</div><div class="rwocodeout">                (typedef.ml[1,0+9]..[1,0+12])</div><div class="rwocodeout">                  &quot;Foo&quot; (typedef.ml[1,0+9]..[1,0+12])</div><div class="rwocodeout">                  []</div><div class="rwocodeout">                  None</div><div class="rwocodeout">                (typedef.ml[1,0+15]..[1,0+18])</div><div class="rwocodeout">                  &quot;Bar&quot; (typedef.ml[1,0+15]..[1,0+18])</div><div class="rwocodeout">                  []</div><div class="rwocodeout">                  None</div><div class="rwocodeout">              ]</div><div class="rwocodeout">          ptype_private = Public</div><div class="rwocodeout">          ptype_manifest =</div><div class="rwocodeout">            None</div><div class="rwocodeout">    ]</div><div class="rwocodeout">  structure_item (typedef.ml[2,19+0]..[2,19+11])</div><div class="rwocodeout">    Pstr_value Nonrec</div><div class="rwocodeout">    [</div><div class="rwocodeout">      &lt;def&gt;</div><div class="rwocodeout">        pattern (typedef.ml[2,19+4]..[2,19+5])</div><div class="rwocodeout">          Ppat_var &quot;v&quot; (typedef.ml[2,19+4]..[2,19+5])</div><div class="rwocodeout">        expression (typedef.ml[2,19+8]..[2,19+11])</div><div class="rwocodeout">          Pexp_construct &quot;Foo&quot; (typedef.ml[2,19+8]..[2,19+11])</div><div class="rwocodeout">          None</div><div class="rwocodeout">          false</div><div class="rwocodeout">    ]</div><div class="rwocodeout">]</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/parsetree_typedef.out">front-end/parsetree_typedef.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608826960">This is rather a lot of output for a simple two-line program, but
      it shows just how much structure the OCaml parser generates even from a
      small source file.</p><p id="idm181608826400">Each portion of the AST is decorated with the precise location information (including
        the filename and character location of the token). This code hasn't been type checked yet,
        so the raw tokens are all included.</p><p id="idm181608825776">The typed AST that is normally output as a compiled <code>cmt</code> file can be displayed in a more
      developer-readable form via the <code>-dtypedtree</code> option:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dtypedtree typedef.ml 2&gt;&amp;1
</div><div class="rwocodeout">[</div><div class="rwocodeout">  structure_item (typedef.ml[1,0+0]..typedef.ml[1,0+18])</div><div class="rwocodeout">    Pstr_type</div><div class="rwocodeout">    [</div><div class="rwocodeout">      t/1008</div><div class="rwocodeout">        type_declaration (typedef.ml[1,0+5]..typedef.ml[1,0+18])</div><div class="rwocodeout">          ptype_params =</div><div class="rwocodeout">            []</div><div class="rwocodeout">          ptype_cstrs =</div><div class="rwocodeout">            []</div><div class="rwocodeout">          ptype_kind =</div><div class="rwocodeout">            Ptype_variant</div><div class="rwocodeout">              [</div><div class="rwocodeout">                &quot;Foo/1009&quot;</div><div class="rwocodeout">                  []</div><div class="rwocodeout">                &quot;Bar/1010&quot;</div><div class="rwocodeout">                  []</div><div class="rwocodeout">              ]</div><div class="rwocodeout">          ptype_private = Public</div><div class="rwocodeout">          ptype_manifest =</div><div class="rwocodeout">            None</div><div class="rwocodeout">    ]</div><div class="rwocodeout">  structure_item (typedef.ml[2,19+0]..typedef.ml[2,19+11])</div><div class="rwocodeout">    Pstr_value Nonrec</div><div class="rwocodeout">    [</div><div class="rwocodeout">      &lt;def&gt;</div><div class="rwocodeout">        pattern (typedef.ml[2,19+4]..typedef.ml[2,19+5])</div><div class="rwocodeout">          Ppat_var &quot;v/1011&quot;</div><div class="rwocodeout">        expression (typedef.ml[2,19+8]..typedef.ml[2,19+11])</div><div class="rwocodeout">          Pexp_construct &quot;Foo&quot;</div><div class="rwocodeout">          []</div><div class="rwocodeout">          false</div><div class="rwocodeout">    ]</div><div class="rwocodeout">]</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/typedtree_typedef.out">front-end/typedtree_typedef.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181608797968">The typed AST is more explicit than the untyped syntax tree. For
      instance, the type declaration has been given a unique name (<code>t/1008</code>), as has the <code>v</code> value (<code>v/1011</code>).<a name="idm181608795632"></a><a name="idm181608795024"></a></p><p id="idm181608794288">You'll rarely need to look at this raw output from the compiler unless you're building
        IDE tools such as <span><strong>ocp-index</strong></span>, or are hacking on extensions
        to the core compiler itself. However, it's useful to know that this intermediate form exists
        before we delve further into the code generation process next, in <a href="the-compiler-backend-byte-code-and-native-code.html">Chapter 23, <i>The Compiler Backend: Bytecode and Native code</i></a>.</p><p id="idm181608792400">There are several new integrated tools emerging that combine these typed AST files with common editors such as Emacs or Vim.  The best of these is <a href="https://github.com/def-lkb/merlin" target="_top">Merlin</a>, which adds value and module autocompletion, displays inferred types and can build and display errors directly from within your editor.  There are instructions available on its homepage for configuring Merlin with your favorite editor.</p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="understanding-the-garbage-collector.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="the-compiler-backend-byte-code-and-native-code.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>
