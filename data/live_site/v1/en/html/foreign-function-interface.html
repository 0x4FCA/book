<html>

    <head>
    
        <meta charset="utf-8"></meta>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"></meta>
        
        <title>Chapter 19. Foreign Function Interface / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"></link>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'realworldocaml',
                        repo: 'book',
                        milestone: 'v1',
                        page: 'foreign\u002Dfunction\u002Dinterface.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <i>Available in <a href="http://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/">print</a> and <a href="http://oreil.ly/realworldOCaml">eBook!</a></i>
                <h1><a href="http://oreil.ly/realworldOCaml"><img src="../../media/img/cover-cut.png" width="245" alt="Real World OCaml, by Yaron Minsky, Anil Madhavapeddy and Jason Hickey"></img></a></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html" class="here">19. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="memory-representation-of-values.html">20. Memory Representation of Values</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">21. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-frontend-parsing-and-type-checking.html">22. The Compiler Frontend: Parsing and Type
    Checking</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-backend-byte-code-and-native-code.html">23. The Compiler Backend: Bytecode and Native code</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="ix01.html">Index</a>
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 19. Foreign Function Interface</h1>
                
                

    <p id="idm449007426400">OCaml has several options available to interact with non-OCaml code. The compiler can link
    with external system libraries via C code and also can produce standalone native object files
    that can be embedded within other non-OCaml applications.<a name="idm449007425888"></a><a name="idm449007424576"></a><a name="INTERffi"></a></p><p id="idm449007421552">The mechanism by which code in one programming language can invoke routines in a different
    programming language is called a <span><em>foreign function interface</em></span>. This chapter
    will:</p><ul><li><p id="idm449007420064">Show how to call routines in C libraries directly from your OCaml
      code</p></li><li><p id="idm449007419216">Teach you how to build higher-level abstractions in OCaml from the
      low-level C bindings</p></li><li><p id="idm449007418352">Work through some full examples for binding a terminal interface
      and UNIX date/time functions</p></li></ul><p id="idm449007417600">The simplest foreign function interface in OCaml doesn't even require
  you to write any C code at all! The Ctypes library lets you define the C
  interface in pure OCaml, and the library then takes care of loading the C
  symbols and invoking the foreign function call.<a name="idm449007417072"></a><a name="idm449007416176"></a><a name="idm449007415264"></a></p><p id="idm449007413840">Let's dive straight into a realistic example to show you how the
  library looks. We'll create a binding to the Ncurses terminal toolkit, as
  it's widely available on most systems and doesn't have any complex
  dependencies.</p><aside class="note"><h1>Installing the Ctypes Library</h1><p id="idm449007412544">You'll need to install the <a href="https://github.com/atgreen/libffi" target="_top"><code>libffi</code></a> library as a prerequisite to
    using Ctypes. It's a fairly popular library and should be available in
    your OS package manager.</p><p id="idm449007410944">A special note for Mac users: the version of <code>libffi</code> installed by default in Mac OS X 10.8 is
    too old for some of the features that Ctypes needs. Use Homebrew to
    <code>brew install libffi</code> to get the latest
    version before installing the OCaml library.</p><p id="idm449007409008">Once that's done, Ctypes is available via OPAM as usual:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> brew install libffi     <span class="c"># for MacOS X users</span>
</div><div class="highlight"><span class="gp">$</span> opam install ctypes
</div><div class="highlight"><span class="gp">$</span> utop
</div><div class="rwocodeout"># require &quot;ctypes.foreign&quot; ;;</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/install.out">ffi/install.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007402512">You'll also need the Ncurses library for the first example. This comes preinstalled on
      many operating systems such as Mac OS X, and Debian Linux provides it as the <code>libncurses5-dev</code> package.</p></aside><section id="example-a-terminal-interface"><h1>Example: A Terminal Interface</h1><p id="idm449007400240">Ncurses is a library to help build terminal-independent text
    interfaces in a reasonably efficient way. It's used in console mail
    clients like Mutt and Pine, and console web browsers such as
    Lynx.<a name="FFItermint"></a></p><p id="idm449007398064">The full C interface is quite large and is explained in the online
    <a href="http://www.gnu.org/software/ncurses/" target="_top">documentation</a>.
    We'll just use the small excerpt, since we just want to demonstrate Ctypes
    in action:<a name="idm449007396960"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_win_st</span> <span class="n">WINDOW</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chtype</span><span class="p">;</span>

<span class="n">WINDOW</span> <span class="o">*</span><span class="nf">initscr</span>   <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">WINDOW</span> <span class="o">*</span><span class="nf">newwin</span>    <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span>    <span class="nf">endwin</span>    <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>    <span class="nf">refresh</span>   <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>    <span class="nf">wrefresh</span>  <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>    <span class="nf">addstr</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>     <span class="nf">mvwaddch</span>  <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">chtype</span><span class="p">);</span>
<span class="kt">void</span>    <span class="nf">mvwaddstr</span> <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>    <span class="nf">box</span> <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">,</span> <span class="n">chtype</span><span class="p">,</span> <span class="n">chtype</span><span class="p">);</span>
<span class="kt">int</span>     <span class="nf">cbreak</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.h">ffi/ncurses.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007392944">The Ncurses functions either operate on the current pseudoterminal
    or on a window that has been created via <code>newwin</code>. The <code>WINDOW</code> structure holds the internal library
    state and is considered abstract outside of Ncurses. Ncurses clients just
    need to store the pointer somewhere and pass it back to Ncurses library
    calls, which in turn dereference its contents.</p><p id="idm449007390880">Note that there are over 200 library calls in Ncurses, so we're only
    binding a select few for this example. The <code>initscr</code> and <code>newwin</code> create <code>WINDOW</code> pointers for the global and subwindows,
    respectively. The <code>mvwaddrstr</code> takes a
    window, x/y offsets, and a string and writes to the screen at that
    location. The terminal is only updated after <code>refresh</code> or <code>wrefresh</code> are called.</p><p id="idm449007386256">Ctypes provides an OCaml interface that lets you map these C
    functions to equivalent OCaml functions. The library takes care of
    converting OCaml function calls and arguments into the C calling
    convention, invoking the foreign call within the C library and finally
    returning the result as an OCaml value.</p><p id="idm449007385552">Let's begin by defining the basic values we need, starting with the
    <code>WINDOW</code> state pointer:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword6">Ctypes
</span>
<span class="keyword4">type</span> window <span class="keyword2">=</span> unit ptr
<span class="keyword4">let</span> window <span class="keyword2">:</span> window typ <span class="keyword2">=</span> ptr void</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.ml">ffi/ncurses.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007382160">We don't know the internal representation of the window pointer, so we treat it as a C
      void pointer. We'll improve on this later on in the chapter, but it's good enough for now. The
      second statement defines an OCaml value that represents the <code>WINDOW</code> C pointer. This value is used later in the Ctypes function
      definitions:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword6">Foreign
</span>
<span class="keyword4">let</span> initscr <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;initscr&quot;</span> <span class="keyword2">(</span>void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning window<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.ml">ffi/ncurses.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007378272">That's all we need to invoke our first function call to <code>initscr</code> to initialize the terminal. The <code>foreign</code> function accepts two parameters:</p><ul><li><p id="idm449007376000">The C function call name, which is looked up using the <code>dlsym</code> POSIX function.</p></li><li><p id="idm449007374496">A value that defines the complete set of C function arguments
        and its return type. The <code>@-&gt;</code>
        operator adds an argument to the C parameter list, and <code>returning</code> terminates the parameter list with
        the return type.</p></li></ul><p id="idm449007372336">The remainder of the Ncurses binding simply expands on these
    definitions:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> newwin <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;newwin&quot;</span> 
    <span class="keyword2">(</span><span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning window<span class="keyword2">)</span>

<span class="keyword4">let</span> endwin <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;endwin&quot;</span> <span class="keyword2">(</span>void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> refresh <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;refresh&quot;</span> <span class="keyword2">(</span>void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> wrefresh <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;wrefresh&quot;</span> <span class="keyword2">(</span>window <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> addstr <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;addstr&quot;</span> <span class="keyword2">(</span><span class="keyword3">string</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> mvwaddch <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;mvwaddch&quot;</span>
    <span class="keyword2">(</span>window <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> char <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> mvwaddstr <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;mvwaddstr&quot;</span>
    <span class="keyword2">(</span>window <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">string</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> box <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;box&quot;</span> <span class="keyword2">(</span>window <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> char <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> char <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> cbreak <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;cbreak&quot;</span> <span class="keyword2">(</span>void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">int</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.ml">ffi/ncurses.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007369392">These definitions are all straightforward mappings from the C
    declarations in the Ncurses header file. Note that the <code>string</code> and <code>int</code> values here are nothing to do with OCaml
    type declarations; instead, they are values that come from opening the
    <code>Ctypes</code> module at the top of the
    file.</p><p id="idm449007366192">Most of the parameters in the Ncurses example represent fairly
    simple scalar C types, except for <code>window</code> (a pointer to the library state) and
    <code>string</code>, which maps from OCaml strings
    that have a specific length onto C character buffers whose length is
    defined by a terminating null character that immediately follows the
    string data.</p><p id="idm449007364160">The module signature for <code>ncurses.mli</code> looks much like a normal OCaml
    signature. You can infer it directly from the <code>ncurses.ml</code> by running a special build
    target:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign ncurses.inferred.mli
</div><div class="highlight"><span class="gp">$</span> cp _build/ncurses.inferred.mli .
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/infer_ncurses.out">ffi/infer_ncurses.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007358032">The <code>inferred.mli</code> target instructs the compiler to
      generate the default signature for a module file and places it in the <code>_build</code> directory as a normal output. You should normally copy it out into your
      source directory and customize it to improve its safety for external callers by making some of
      its internals more abstract.</p><p id="idm449007356016">Here's the customized interface that we can safely use from other
    libraries:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> window
<span class="keyword4">val</span> window <span class="keyword2">:</span> window <span class="keyword5">Ctypes.</span>typ
<span class="keyword4">val</span> initscr <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> window
<span class="keyword4">val</span> endwin <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> refresh <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> wrefresh <span class="keyword2">:</span> window -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> newwin <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> window
<span class="keyword4">val</span> mvwaddch <span class="keyword2">:</span> window -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> char -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> addstr <span class="keyword2">:</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> mvwaddstr <span class="keyword2">:</span> window -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> box <span class="keyword2">:</span> window -<span class="keyword2">&gt;</span> char -<span class="keyword2">&gt;</span> char -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> cbreak <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> <span class="keyword3">int</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.mli">ffi/ncurses.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007353136">The <code>window</code> type is left abstract
    in the signature to ensure that window pointers can only be constructed
    via the <code>Ncurses.initscr</code> function. This
    prevents void pointers obtained from other sources from being mistakenly
    passed to an Ncurses library call.</p><p id="idm449007350704">Now compile a &quot;hello world&quot; terminal drawing program to tie this all
    together:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword6">Ncurses
</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> main_window <span class="keyword2">=</span> initscr <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  ignore<span class="keyword2">(</span>cbreak <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword4">let</span> small_window <span class="keyword2">=</span> newwin <span class="keyword8">10</span> <span class="keyword8">10</span> <span class="keyword8">5</span> <span class="keyword8">5</span> <span class="keyword4">in</span>
  mvwaddstr main_window <span class="keyword8">1</span> <span class="keyword8">2</span> <span class="keyword7">&quot;Hello&quot;</span><span class="keyword2">;</span>
  mvwaddstr small_window <span class="keyword8">2</span> <span class="keyword8">2</span> <span class="keyword7">&quot;World&quot;</span><span class="keyword2">;</span>
  box small_window '\<span class="keyword8">000</span>' '\<span class="keyword8">000</span>'<span class="keyword2">;</span>
  refresh <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword5">Unix.</span>sleep <span class="keyword8">1</span><span class="keyword2">;</span>
  wrefresh small_window<span class="keyword2">;</span>
  <span class="keyword5">Unix.</span>sleep <span class="keyword8">5</span><span class="keyword2">;</span>
  endwin <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/hello.ml">ffi/hello.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007347760">The <code>hello</code> executable is compiled
    by linking with the <code>ctypes.foreign</code>
    OCamlfind package:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign -lflags -cclib,-lncurses hello.native 
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/build_hello.out">ffi/build_hello.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007342720">Running <code>./hello.native</code> should now
    display a Hello World in your terminal!<a name="idm449007341744"></a></p><aside class="note"><h1>On Build Directives for Ctypes</h1><p id="idm449007339632">The preceding command line includes some important extra link
      directives. The <code>-lflags</code> instructs
      <span><strong>ocamlbuild</strong></span> to pass the next
      comma-separated set of arguments through to the <span><strong>ocaml</strong></span> command when linking a binary. OCaml in
      turn uses <code>-cclib</code> to pass directives
      through to the system compiler (normally <span><strong>gcc</strong></span> or <span><strong>clang</strong></span>). We first need to link to the <code>ncurses</code> C library to make the symbols
      available to Ctypes, and <span><code>-cclib,</code></span><code>-lncurses</code> does that.</p><p id="idm449007332976">On some distributions such as Ubuntu 11.10 upwards, you'll also need to add <code>-cclib,-Xlinker,-cclib, and --no-as-needed</code> to the <span><code>-lflags</code></span> directive.
          <code>-Xlinker</code> is interpreted by the compiler as a directive
        for the system linker <span><strong>ld</strong></span>, to which it passes <code>--no-as-needed</code>. <span>Several</span>
        modern OS distributions (such as Ubuntu 11.10 onwards) configure the system linker to only
        link in libraries that directly contain symbols used by the program. However, when we use
        Ctypes, those symbols are not referenced until runtime, which results an exception due to
        the library not being available.</p><p id="idm449007327776">The <code>--no-as-needed</code> flag
      disables this behavior and ensures all the specified libraries are
      linked despite not being directly used. The flag unfortunately doesn't
      work everywhere (notably, Mac OS X should <span><em>not</em></span> have
      this passed to it).</p></aside><p id="idm449007325984">Ctypes wouldn't be very useful if it were limited to only defining
    simple C types, of course. It provides full support for C pointer
    arithmetic, pointer conversions, and reading and writing through pointers,
    using OCaml functions as function pointers to C code, as well as struct
    and union definitions.</p><p id="idm449007325280">We'll go over some of these features in more detail for the
    remainder of the chapter by using some POSIX date functions as running
    examples.<a name="idm449007324864"></a></p></section><section id="basic-scalar-c-types"><h1>Basic Scalar C Types</h1><p id="idm449007323072">First, let's look at how to define basic scalar C types. Every C
    type is represented by an OCaml equivalent via the single type
    definition:<a name="idm449007322656"></a><a name="idm449007321760"></a></p><div class="rwocode"><pre><code><span class="keyword4">type</span> 'a typ</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007318080"><code>Ctypes.typ</code> is the type of values
    that represents C types to OCaml. There are two types associated with each
    instance of <code>typ</code>:</p><ul><li><p id="idm449007315888">The C type used to store and pass values to the foreign
        library.</p></li><li><p id="idm449007315040">The corresponding OCaml type. The <code>'a</code> type parameter contains the OCaml type
        such that a value of type <code>t typ</code> is
        used to read and write OCaml values of type <code>t</code>.</p></li></ul><p id="idm449007312320">There are various other uses of <code>typ</code> values within Ctypes, such as:</p><ul><li><p id="idm449007310720">Constructing function types for binding native functions</p></li><li><p id="idm449007309888">Constructing pointers for reading and writing locations in
        C-managed storage</p></li><li><p id="idm449007309024">Describing component fields of structures, unions, and
        arrays</p></li></ul><p id="idm449007308304">Here are the definitions for most of the standard C99 scalar types,
    including some platform-dependent ones<a name="idm449007307936"></a>:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> void      <span class="keyword2">:</span> unit typ
<span class="keyword4">val</span> char      <span class="keyword2">:</span> char typ
<span class="keyword4">val</span> schar     <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> short     <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> <span class="keyword3">int</span>       <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> long      <span class="keyword2">:</span> long typ
<span class="keyword4">val</span> llong     <span class="keyword2">:</span> llong typ
<span class="keyword4">val</span> nativeint <span class="keyword2">:</span> nativeint typ

<span class="keyword4">val</span> int8_t    <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> int16_t   <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> int32_t   <span class="keyword2">:</span> int32 typ
<span class="keyword4">val</span> int64_t   <span class="keyword2">:</span> int64 typ
<span class="keyword4">val</span> uchar     <span class="keyword2">:</span> uchar typ
<span class="keyword4">val</span> uchar     <span class="keyword2">:</span> uchar typ
<span class="keyword4">val</span> uint8_t   <span class="keyword2">:</span> uint8 typ
<span class="keyword4">val</span> uint16_t  <span class="keyword2">:</span> uint16 typ
<span class="keyword4">val</span> uint32_t  <span class="keyword2">:</span> uint32 typ
<span class="keyword4">val</span> uint64_t  <span class="keyword2">:</span> uint64 typ
<span class="keyword4">val</span> size_t    <span class="keyword2">:</span> size_t typ
<span class="keyword4">val</span> ushort    <span class="keyword2">:</span> ushort typ
<span class="keyword4">val</span> uint      <span class="keyword2">:</span> uint typ
<span class="keyword4">val</span> ulong     <span class="keyword2">:</span> ulong typ
<span class="keyword4">val</span> ullong    <span class="keyword2">:</span> ullong typ

<span class="keyword4">val</span> <span class="keyword3">float</span>     <span class="keyword2">:</span> <span class="keyword3">float</span> typ
<span class="keyword4">val</span> double    <span class="keyword2">:</span> <span class="keyword3">float</span> typ

<span class="keyword4">val</span> complex32 <span class="keyword2">:</span> <span class="keyword5">Complex.</span>t typ
<span class="keyword4">val</span> complex64 <span class="keyword2">:</span> <span class="keyword5">Complex.</span>t typ</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007303712">These values are all of type <code>'a
    typ</code>, where the value name (e.g., <code>void</code>) tells you the C type and the <code>'a</code> component (e.g., <code>unit</code>) is the OCaml representation of that C
    type. Most of the mappings are straightforward, but some of them need a
    bit more explanation:</p><ul><li><p id="idm449007300000">Void values appear in OCaml as the <code>unit</code> type. Using <code>void</code> in an argument or result type
        specification produces an OCaml function that accepts or returns
        <code>unit</code>. Dereferencing a pointer to <code>void</code> is an error, as in C, and will raise
        the <code>IncompleteType</code>
        exception.</p></li><li><p id="idm449007295952">The C <code>size_t</code> type is an alias
        for one of the unsigned integer types. The actual size and alignment
        requirements for <code>size_t</code> varies
        between platforms. Ctypes provides an OCaml <code>size_t</code> type that is aliased to the
        appropriate integer type.</p></li><li><p id="idm449007292992">OCaml only supports double-precision floating-point numbers, and
        so the C <code>float</code> and <code>double</code> types both map onto the OCaml
        <code>float</code> type, and the C <code>float complex</code> and <code>double complex</code> types both map onto the OCaml
        double-precision <code>Complex.t</code>
        type.</p></li></ul></section><section id="pointers-and-arrays"><h1>Pointers and Arrays</h1><p id="idm449007287168">Pointers are at the heart of C, so they are necessarily part of
    Ctypes, which provides support for pointer arithmetic, pointer
    conversions, reading and writing through pointers, and passing and
    returning pointers to and from functions.<a name="idm449007286656"></a><a name="idm449007285760"></a><a name="idm449007284464"></a><a name="idm449007283152"></a></p><p id="idm449007281680">We've already seen a simple use of pointers in the Ncurses example.
    Let's start a new example by binding the following POSIX functions:</p><div class="rwocode"><pre><code><div class="highlight"><span class="kt">time_t</span> <span class="nf">time</span><span class="p">(</span><span class="kt">time_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">difftime</span><span class="p">(</span><span class="kt">time_t</span><span class="p">,</span> <span class="kt">time_t</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">ctime</span><span class="p">(</span><span class="k">const</span> <span class="kt">time_t</span> <span class="o">*</span><span class="n">timep</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix_headers.h">ffi/posix_headers.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007278896">The <code>time</code> function returns the
    current calendar time and is a simple start. The first step is to open
    some of the Ctypes modules:</p><div><dl><dt><span><code>Ctypes</code></span></dt><dd><p id="idm449007276176">The <code>Ctypes</code> module provides
          functions for describing C types in OCaml.</p></dd><dt><span><code>PosixTypes</code></span></dt><dd><p id="idm449007273520">The <code>PosixTypes</code> module
          includes some extra POSIX-specific types (such as <code>time_t</code>).</p></dd><dt><span><code>Foreign</code></span></dt><dd><p id="idm449007270224">The <code>Foreign</code> module exposes
          the <code>foreign</code> function that makes
          it possible to invoke C functions.</p></dd></dl></div><p id="idm449007268048">We can now create a binding to <code>time</code> directly from the toplevel.</p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;ctypes.foreign&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword7">#require</span> <span class="keyword7">&quot;ctypes.top&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>No such package: ctypes.top
 </div># <span class="keyword1">open</span> <span class="keyword6">Ctypes </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">PosixTypes </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">Foreign </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword4">let</span> time <span class="keyword2">=</span> foreign <span class="keyword7">&quot;time&quot;</span> <span class="keyword2">(</span>ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning time_t<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val time : time_t ptr -&gt; time_t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007257312">The <code>foreign</code> function is the main
    link between OCaml and C. It takes two arguments: the name of the C
    function to bind, and a value describing the type of the bound function.
    In the <code>time</code> binding, the function type
    specifies one argument of type <code>ptr
    time_t</code> and a return type of <code>time_t</code>.</p><p id="idm449007254144">We can now call <code>time</code> immediately
    in the same toplevel. The argument is actually optional, so we'll just
    pass a null pointer that has been coerced into becoming a null pointer to
    <code>time_t</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> cur_time <span class="keyword2">=</span> time <span class="keyword2">(</span>from_voidp time_t null<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val cur_time : time_t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007248352">Since we're going to call <code>time</code> a
    few times, let's create a wrapper function that passes the null pointer
    through:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> time' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> time <span class="keyword2">(</span>from_voidp time_t null<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val time' : unit -&gt; time_t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007243248">Since <code>time_t</code> is an abstract type,
    we can't actually do anything useful with it directly. We need to bind a
    second function to do anything useful with the return values from <code>time</code>. We'll move on to <code>difftime</code>; the second C function in our prototype
    list:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> difftime <span class="keyword2">=</span>
    foreign <span class="keyword7">&quot;difftime&quot;</span> <span class="keyword2">(</span>time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning double<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val difftime : time_t -&gt; time_t -&gt; float = &lt;fun&gt;
</div># <span class="keyword4">let</span> t1 <span class="keyword2">=</span>
    time' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword5">Unix.</span>sleep <span class="keyword8">2</span><span class="keyword2">;</span>
    <span class="keyword4">let</span> t2 <span class="keyword2">=</span> time' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span> 
    difftime t2 t1 <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : float = 2.
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007231696">The binding to <code>difftime</code> above is
    sufficient to compare two <code>time_t</code>
    values.</p><section id="allocating-typed-memory-for-pointers"><h1>Allocating Typed Memory for Pointers</h1><p id="idm449007228992">Let's look at a slightly less trivial example where we pass a
      nonnull pointer to a function. Continuing with the theme from earlier,
      we'll bind to the <code>ctime</code> function,
      which converts a <code>time_t</code> value to a
      human-readable string:<a name="idm449007227184"></a><a name="idm449007225872"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> ctime <span class="keyword2">=</span> foreign <span class="keyword7">&quot;ctime&quot;</span> <span class="keyword2">(</span>ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">string</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ctime : time_t ptr -&gt; string = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007220368">The binding is continued in the toplevel to add to our growing
      collection. However, we can't just pass the result of <code>time</code> to <code>ctime</code>:</p><div class="rwocode"><pre><code># ctime <span class="keyword2">(</span>time' <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 7-15:
Error: This expression has type time_t but an expression was expected of type
         time_t ptr
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007213392">This is because <code>ctime</code> needs a
      pointer to the <code>time_t</code> rather than
      passing it by value. We thus need to allocate some memory for the
      <code>time_t</code> and obtain its memory
      address:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> t_ptr <span class="keyword2">=</span> allocate time_t <span class="keyword2">(</span>time' <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val t_ptr : time_t ptr = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007206960">The <code>allocate</code> function takes the
      type of the memory to be allocated and the initial value and it returns
      a suitably typed pointer. We can now call <code>ctime</code> passing the pointer as an
      argument:</p><div class="rwocode"><pre><code># ctime t_ptr <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;Tue Nov  5 08:51:55 2013\n&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="using-views-to-map-complex-values"><h1>Using Views to Map Complex Values</h1><p id="idm449007200096">While scalar types typically have a 1:1 representation, other C
      types require extra work to convert them into OCaml. Views create new C
      type descriptions that have special behavior when used to read or write
      C values.<a name="idm449007199600"></a><a name="idm449007198288"></a></p><p id="idm449007196848">We've already used one view in the definition of <code>ctime</code> earlier. The <code>string</code> view wraps the C type <code>char *</code> (written in OCaml as <code>ptr char</code>) and converts between the C and OCaml
      string representations each time the value is written or read.</p><p id="idm449007193648">Here is the type signature of the <code>Ctypes.view</code> function:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> view <span class="keyword2">:</span>
  read<span class="keyword2">:</span><span class="keyword2">(</span>'a -<span class="keyword2">&gt;</span> 'b<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
  write<span class="keyword2">:</span><span class="keyword2">(</span>'b -<span class="keyword2">&gt;</span> 'a<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
  'a typ -<span class="keyword2">&gt;</span> 'b typ</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007190016">Ctypes has some internal low-level conversion functions that map
      between an OCaml <code>string</code> and a C
      character buffer by copying the contents into the respective data
      structure. They have the following type signature:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> string_of_char_ptr <span class="keyword2">:</span> char ptr -<span class="keyword2">&gt;</span> <span class="keyword3">string</span>
<span class="keyword4">val</span> char_ptr_of_string <span class="keyword2">:</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> char ptr</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007186080">Given these functions, the definition of the <code>Ctypes.string</code> value that uses views is quite
      simple:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword3">string</span> <span class="keyword2">=</span> 
  view <span class="keyword2">(</span>char ptr<span class="keyword2">)</span>
    ~read<span class="keyword2">:</span>string_of_char_ptr 
    ~write<span class="keyword2">:</span>char_ptr_of_string</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes_impl.ml">ctypes/ctypes_impl.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007182864">The type of this <code>string</code>
      function is a normal <code>typ</code> with no
      external sign of the use of the view function:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> <span class="keyword3">string</span>    <span class="keyword2">:</span> <span class="keyword3">string</span>.typ</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="note"><h1>OCaml Strings Versus C Character Buffers</h1><p id="idm449007174720">Although OCaml strings may look like C character buffers from an
        interface perspective, they're very different in terms of their memory
        representations.</p><p id="idm449007174160">OCaml strings are stored in the OCaml heap with a header that
        explicitly defines their length. C buffers are also fixed-length, but
        by convention, a C string is terminated by a null (a <code>\0</code> byte) character. The C string functions
        calculate their length by scanning the buffer until the first null
        character is encountered.</p><p id="idm449007172784">This means that you need to be careful that OCaml strings that
        you pass to C functions don't contain any null values, since the first
        occurrence of a null character will be treated as the end of the C
        string. Ctypes also defaults to a <span><em>copying</em></span>
        interface for strings, which means that you shouldn't use them when
        you want the library to mutate the buffer in-place. In that situation,
        use the Ctypes <code>Bigarray</code> support to
        pass memory by reference instead.</p></aside></section></section><section id="structs-and-unions"><h1>Structs and Unions</h1><p id="idm449007169520">The C constructs <code>struct</code> and
    <code>union</code> make it possible to build new
    types from existing types. Ctypes contains counterparts that work
    similarly.<a name="idm449007167808"></a><a name="idm449007166496"></a><a name="idm449007165168"></a></p><section id="defining-a-structure"><h1>Defining a Structure</h1><p id="idm449007162768">Let's improve the timer function that we wrote earlier. The POSIX
      function <code>gettimeofday</code> retrieves the
      time with microsecond resolution. The signature of <code>gettimeofday</code> is as follows, including the
      structure definitions:</p><div class="rwocode"><pre><code><div class="highlight"><span class="k">struct</span> <span class="n">timeval</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="n">tv_sec</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">tv_usec</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">gettimeofday</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tv</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/timeval_headers.h">ffi/timeval_headers.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007158592">Using Ctypes, we can describe this type as follows in our
      toplevel, continuing on from the previous definitions:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> timeval <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type timeval
</div># <span class="keyword4">let</span> timeval <span class="keyword2">:</span> timeval structure typ <span class="keyword2">=</span> structure <span class="keyword7">&quot;timeval&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val timeval : timeval structure typ = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007152352">The first command defines a new OCaml type <code>timeval</code> that we'll use to instantiate the
      OCaml version of the struct. This is a <span><em>phantom type</em></span>
      that exists only to distinguish the underlying C type from other pointer
      types. The particular <code>timeval</code>
      structure now has a distinct type from other structures we define
      elsewhere, which helps to avoid getting them mixed up.</p><p id="idm449007149888">The second command calls <code>structure</code> to create a fresh structure type. At
      this point, the structure type is incomplete: we can add fields but
      cannot yet use it in <code>foreign</code> calls or
      use it to create values.</p></section><section id="adding-fields-to-structures"><h1>Adding Fields to Structures</h1><p id="idm449007146944">The <code>timeval</code> structure
      definition still doesn't have any fields, so we need to add those
      next:<a name="idm449007145936"></a><a name="idm449007144624"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> tv_sec  <span class="keyword2">=</span> field timeval <span class="keyword7">&quot;tv_sec&quot;</span> long <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 14-19:
Error: Unbound value field
</div># <span class="keyword4">let</span> tv_usec <span class="keyword2">=</span> field timeval <span class="keyword7">&quot;tv_usec&quot;</span> long <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 14-19:
Error: Unbound value field
</div># seal timeval <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception: Ctypes_raw.Ffi_internal_error(&quot;FFI_BAD_TYPEDEF&quot;).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007134864">The <code>field</code> function appends a
      field to the structure, as shown with <code>tv_sec</code> and <code>tv_usec</code>. Structure fields are typed accessors
      that are associated with a particular structure, and they correspond to
      the labels in C.</p><p id="idm449007132304">Every field addition mutates the structure variable and records a
      new size (the exact value of which depends on the type of the field that
      was just added). Once we <code>seal</code> the
      structure, we will be able to create values using it, but adding fields
      to a sealed structure is an error.</p></section><section id="incomplete-structure-definitions"><h1>Incomplete Structure Definitions</h1><p id="idm449007129872">Since <code>gettimeofday</code> needs a
      <code>struct timezone</code> pointer for its
      second argument, we also need to define a second structure
      type:<a name="idm449007128208"></a></p><div class="rwocode"><pre><code># <span class="keyword4">type</span> timezone <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type timezone
</div># <span class="keyword4">let</span> timezone <span class="keyword2">:</span> timezone structure typ <span class="keyword2">=</span> structure <span class="keyword7">&quot;timezone&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val timezone : timezone structure typ = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 10) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007120976">We don't ever need to create <code>struct
      timezone</code> values, so we can leave this struct as incomplete
      without adding any fields or sealing it. If you ever try to use it in a
      situation where its concrete size needs to be known, the library will
      raise an <code>IncompleteType</code>
      exception.</p><p id="idm449007119008">We're finally ready to bind to <code>gettimeofday</code> now:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> gettimeofday <span class="keyword2">=</span> foreign <span class="keyword7">&quot;gettimeofday&quot;</span>
    <span class="keyword2">(</span>ptr timeval <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> ptr timezone <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning_checking_errno <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val gettimeofday : timeval structure ptr -&gt; timezone structure ptr -&gt; int =
  &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 11) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007112480">There's one other new feature here: the <code>returning_checking_errno</code> function behaves like
      <code>returning</code>, except that it checks
      whether the bound C function modifies the C error flag. Changes to
      <code>errno</code> are mapped into OCaml
      exceptions and raise a <code>Unix.Unix_error</code> exception just as the standard
      library functions do.</p><p id="idm449007109248">As before, we can create a wrapper to make <code>gettimeofday</code> easier to use. The functions
      <code>make</code>, <code>addr</code>, and <code>getf</code> create a structure value, retrieve the
      address of a structure value, and retrieve the value of a field from a
      structure:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> gettimeofday' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> tv <span class="keyword2">=</span> make timeval <span class="keyword4">in</span>
  ignore<span class="keyword2">(</span>gettimeofday <span class="keyword2">(</span>addr tv<span class="keyword2">)</span> <span class="keyword2">(</span>from_voidp timezone null<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword4">let</span> secs <span class="keyword2">=</span> <span class="keyword5">Signed.</span><span class="keyword5">Long.</span><span class="keyword2">(</span>to_int <span class="keyword2">(</span>getf tv tv_sec<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> usecs <span class="keyword2">=</span> <span class="keyword5">Signed.</span><span class="keyword5">Long.</span><span class="keyword2">(</span>to_int <span class="keyword2">(</span>getf tv tv_usec<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword5">Pervasives.</span><span class="keyword2">(</span><span class="keyword3">float</span> secs <span class="keyword2">+</span>. <span class="keyword3">float</span> usecs /. <span class="keyword8">1000000</span>.<span class="keyword8">0</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 153-159:
Error: Unbound value tv_sec
</div># gettimeofday' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters -1-13:
Error: Unbound value gettimeofday'
Did you mean gettimeofday?
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 12) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007096896">You need to be a little careful not to get all the open modules
      mixed up here. Both <code>Pervasives</code> and
      <code>Ctypes</code> define different <code>float</code> functions. The <code>Ctypes</code> module we opened up earlier overrides
      the <code>Pervasives</code> definition. As seen
      previously though, you just need to locally open <code>Pervasives</code> again to bring the usual <code>float</code> function back in scope.</p><section id="recap-a-time-printing-command"><h1>Recap: A time-printing command</h1><p id="idm449007090720">We built up a lot of bindings in the previous section, so let's
        recap them with a complete example that ties it together with a
        command-line frontend:<a name="idm449007090288"></a></p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword6">Ctypes
</span><span class="keyword1">open</span> <span class="keyword6">PosixTypes
</span><span class="keyword1">open</span> <span class="keyword6">Foreign
</span>
<span class="keyword4">let</span> time     <span class="keyword2">=</span> foreign <span class="keyword7">&quot;time&quot;</span> <span class="keyword2">(</span>ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning time_t<span class="keyword2">)</span>
<span class="keyword4">let</span> difftime <span class="keyword2">=</span> foreign <span class="keyword7">&quot;difftime&quot;</span> <span class="keyword2">(</span>time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning double<span class="keyword2">)</span>
<span class="keyword4">let</span> ctime    <span class="keyword2">=</span> foreign <span class="keyword7">&quot;ctime&quot;</span> <span class="keyword2">(</span>ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">string</span><span class="keyword2">)</span>

<span class="keyword4">type</span> timeval
<span class="keyword4">let</span> timeval <span class="keyword2">:</span> timeval structure typ <span class="keyword2">=</span> structure <span class="keyword7">&quot;timeval&quot;</span>
<span class="keyword4">let</span> tv_sec   <span class="keyword2">=</span> timeval <span class="keyword2">*</span><span class="keyword2">:</span><span class="keyword2">*</span> long
<span class="keyword4">let</span> tv_usec  <span class="keyword2">=</span> timeval <span class="keyword2">*</span><span class="keyword2">:</span><span class="keyword2">*</span> long
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span>       <span class="keyword2">=</span> seal timeval

<span class="keyword4">type</span> timezone
<span class="keyword4">let</span> timezone <span class="keyword2">:</span> timezone structure typ <span class="keyword2">=</span> structure <span class="keyword7">&quot;timezone&quot;</span>

<span class="keyword4">let</span> gettimeofday <span class="keyword2">=</span> foreign <span class="keyword7">&quot;gettimeofday&quot;</span>
    <span class="keyword2">(</span>ptr timeval <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> ptr timezone <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning_checking_errno <span class="keyword3">int</span><span class="keyword2">)</span>

<span class="keyword4">let</span> time' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> time <span class="keyword2">(</span>from_voidp time_t null<span class="keyword2">)</span>

<span class="keyword4">let</span> gettimeofday' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> tv <span class="keyword2">=</span> make timeval <span class="keyword4">in</span>
  ignore<span class="keyword2">(</span>gettimeofday <span class="keyword2">(</span>addr tv<span class="keyword2">)</span> <span class="keyword2">(</span>from_voidp timezone null<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword4">let</span> secs <span class="keyword2">=</span> <span class="keyword5">Signed.</span><span class="keyword5">Long.</span><span class="keyword2">(</span>to_int <span class="keyword2">(</span>getf tv tv_sec<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> usecs <span class="keyword2">=</span> <span class="keyword5">Signed.</span><span class="keyword5">Long.</span><span class="keyword2">(</span>to_int <span class="keyword2">(</span>getf tv tv_usec<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword5">Pervasives.</span><span class="keyword2">(</span><span class="keyword3">float</span> secs <span class="keyword2">+</span>. <span class="keyword3">float</span> usecs /. <span class="keyword8">1_000_000</span>.<span class="keyword2">)</span>

<span class="keyword4">let</span> float_time <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> printf <span class="keyword7">&quot;%f%!\n&quot;</span> <span class="keyword2">(</span>gettimeofday' <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>

<span class="keyword4">let</span> ascii_time <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> t_ptr <span class="keyword2">=</span> allocate time_t <span class="keyword2">(</span>time' <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  printf <span class="keyword7">&quot;%s%!&quot;</span> <span class="keyword2">(</span>ctime t_ptr<span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Command </span><span class="keyword4">in</span>
  basic ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Display the current time in various formats&quot;</span>
    <span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> flag <span class="keyword7">&quot;-a&quot;</span> no_arg ~doc<span class="keyword2">:</span><span class="keyword7">&quot; Human-readable output format&quot;</span><span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> human -<span class="keyword2">&gt;</span> <span class="keyword1">if</span> human <span class="keyword1">then</span> ascii_time <span class="keyword1">else</span> float_time<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/datetime.ml">ffi/datetime.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007086320">This can be compiled and run in the usual way:<a name="idm449007086064"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign datetime.native
</div><div class="highlight"><span class="gp">$</span> ./datetime.native
</div><div class="rwocodeout">1383603807.642986</div><div class="highlight"><span class="gp">$</span> ./datetime.native -a
</div><div class="rwocodeout">Mon Nov  4 17:23:27 2013</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/build_datetime.out">ffi/build_datetime.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1><b>Why Do We Need to Use returning?</b></h1><p id="idm449007077680">The alert reader may be curious about why all these function
          definitions have to be terminated by <code>returning</code>:</p><div class="rwocode"><pre><code><span class="comments">(* correct types *)</span>
<span class="keyword4">val</span> time<span class="keyword2">:</span> ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning time_t
<span class="keyword4">val</span> difftime<span class="keyword2">:</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning double</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_frag.ml">ffi/return_frag.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007074208">The <code>returning</code> function may
          appear superfluous here. Why couldn't we simply give the types as
          follows?</p><div class="rwocode"><pre><code><span class="comments">(* incorrect types *)</span>
<span class="keyword4">val</span> time<span class="keyword2">:</span> ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t
<span class="keyword4">val</span> difftime<span class="keyword2">:</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> double</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_frag.ml">ffi/return_frag.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007070496">The reason involves higher types and two differences between
          the way that functions are treated in OCaml and C. Functions are
          first-class values in OCaml, but not in C. For example, in C it is
          possible to return a function pointer from a function, but not to
          return an actual function.</p><p id="idm449007069776">Secondly, OCaml functions are typically defined in a curried
          style. The signature of a two-argument function is written as
          follows:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> curried <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_frag.ml">ffi/return_frag.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007066944">but this really means:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> curried <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_frag.ml">ffi/return_frag.ml</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007064128">and the arguments can be supplied one at a time to create a
          closure. In contrast, C functions receive their arguments all at
          once. The equivalent C function type is the following:</p><div class="rwocode"><pre><code><div class="highlight"><span class="kt">int</span> <span class="nf">uncurried_C</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_c_frag.h">ffi/return_c_frag.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007061376">and the arguments must always be supplied together:</p><div class="rwocode"><pre><code><div class="highlight"><span class="n">uncurried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_c_frag.c">ffi/return_c_frag.c</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007058736">A C function that's written in curried style looks very
          different:</p><div class="rwocode"><pre><code><div class="highlight"><span class="cm">/* A function that accepts an int, and returns a function</span>
<span class="cm">   pointer that accepts a second int and returns an int. */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="kt">function_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">function_t</span> <span class="o">*</span><span class="nf">curried_C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* supply both arguments */</span>
<span class="n">curried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">);</span>

<span class="cm">/* supply one argument at a time */</span>
<span class="kt">function_t</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">curried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_c_uncurried.c">ffi/return_c_uncurried.c</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007055792">The OCaml type of <code>uncurried_C</code> when bound by Ctypes is
          <code>int -&gt; int -&gt; int</code>: a
          two-argument function. The OCaml type of <code>curried_C</code> when bound by <code>ctypes</code> is <code>int
          -&gt; (int -&gt; int)</code>: a one-argument function that
          returns a one-argument function.</p><p id="idm449007051872">In OCaml, of course, these types are absolutely equivalent.
          Since the OCaml types are the same but the C semantics are quite
          different, we need some kind of marker to distinguish the cases.
          This is the purpose of <code>returning</code>
          in function definitions.</p></section></section></section><section id="defining-arrays"><h1>Defining Arrays</h1><p id="idm449007049280">Arrays in C are contiguous blocks of the same type of value. Any
      of the basic types defined previously can be allocated as blocks via the
      <code>Array</code> module:<a name="idm449007048208"></a><a name="idm449007046912"></a></p><div class="rwocode"><pre><code><span class="keyword4">module</span> <span class="keyword6">Array </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
  <span class="keyword4">type</span> 'a t <span class="keyword2">=</span> 'a <span class="keyword3">array</span>

  <span class="keyword4">val</span> get <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> 'a
  <span class="keyword4">val</span> set <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> unit
  <span class="keyword4">val</span> of_list <span class="keyword2">:</span> 'a typ -<span class="keyword2">&gt;</span> 'a <span class="keyword3">list</span> -<span class="keyword2">&gt;</span> 'a t
  <span class="keyword4">val</span> to_list <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a <span class="keyword3">list</span>
  <span class="keyword4">val</span> length <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span>
  <span class="keyword4">val</span> start <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a ptr
  <span class="keyword4">val</span> from_ptr <span class="keyword2">:</span> 'a ptr -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> 'a t
  <span class="keyword4">val</span> make <span class="keyword2">:</span> 'a typ -<span class="keyword2">&gt;</span> ?initial<span class="keyword2">:</span>'a -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> 'a t
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007043056">The array functions are similar to those in the standard library
      <code>Array</code> module except that they operate
      on arrays stored using the flat C representation rather than the OCaml
      representation described in <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a>.</p><p id="idm449007040624">As with standard OCaml arrays, the conversion between arrays and
      lists requires copying the values, which can be expensive for large data
      structures. Notice that you can also convert an array into a <code>ptr</code> pointer to the head of the underlying
      buffer, which can be useful if you need to pass the pointer and size
      arguments separately to a C function.</p><p id="idm449007039248">Unions in C are named structures that can be mapped onto the same
      underlying memory. They are also fully supported in Ctypes, but we won't
      go into more detail here.<a name="idm449007038800"></a><a name="idm449007037520"></a></p><section><h1><b>Pointer Operators for Dereferencing and Arithmetic</b></h1><p id="idm449007035136">Ctypes defines a number of operators that let you manipulate
        pointers and arrays just as you would in C. The Ctypes equivalents do
        have the benefit of being more strongly typed, of course (see <a href="foreign-function-interface.html#Table19sub1">Table 19.1, “Operators for manipulating pointers and arrays”</a>).</p><div id="Table19sub1"><p><b>Table 19.1. Operators for manipulating pointers and arrays</b></p><div><table summary="Operators for manipulating pointers and arrays"><thead><tr><th>Operator</th><th>Purpose</th></tr></thead><tbody><tr><td><code>!@ p</code></td><td>Dereference the pointer <code>p</code>.</td></tr><tr><td><code>p &lt;-@ v</code></td><td>Write the value <code>v</code> to
                the address <code>p</code>.</td></tr><tr><td><code>p +@ n</code></td><td>If <code>p</code> points to an
                array element, then compute the address of the <code>n</code>th next element.</td></tr><tr><td><code>p -@ n</code></td><td>If <code>p</code> points to an
                array element, then compute the address of the <code>n</code>th previous element.</td></tr></tbody></table></div></div><br><p id="idm449007018576">There are also other useful nonoperator functions available (see the Ctypes
          documentation), such as pointer differencing and comparison.</p></br></section></section></section><section id="passing-functions-to-c"><h1>Passing Functions to C</h1><p id="idm449007016720">It's also straightforward to pass OCaml function values to C. The C standard library
      function <code>qsort</code> sorts arrays of elements using a comparison
      function passed in as a function pointer. The signature for <code>qsort</code> is:<a name="idm449007014944"></a><a name="idm449007013648"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="kt">void</span> <span class="nf">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
           <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">compar</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort.h">ffi/qsort.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007009904">C programmers often use <code>typedef</code>
    to make type definitions involving function pointers easier to read. Using
    a typedef, the type of <code>qsort</code> looks a
    little more palatable:</p><div class="rwocode"><pre><code><div class="highlight"><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="kt">compare_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">compare_t</span> <span class="o">*</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort_typedef.h">ffi/qsort_typedef.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449007005760">This also happens to be a close mapping to the corresponding Ctypes
    definition. Since type descriptions are regular values, we can just use
    <code>let</code> in place of <code>typedef</code> and end up with working OCaml bindings
    to <code>qsort</code>:</p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;ctypes.foreign&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">Ctypes </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">PosixTypes </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">Foreign </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword4">let</span> compare_t <span class="keyword2">=</span> ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">int</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val compare_t : (unit ptr -&gt; unit ptr -&gt; int) fn = &lt;abstr&gt;
</div># <span class="keyword4">let</span> qsort <span class="keyword2">=</span> foreign <span class="keyword7">&quot;qsort&quot;</span>
   <span class="keyword2">(</span>ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> size_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> size_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span>
    funptr compare_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val qsort :
  unit ptr -&gt; size_t -&gt; size_t -&gt; (unit ptr -&gt; unit ptr -&gt; int) -&gt; unit =
  &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort.topscript">ffi/qsort.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449006990096">We only use <code>compare_t</code> once (in the <code>qsort</code> definition), so you can choose to inline it in the OCaml
      code if you prefer. As the type shows, the resulting <code>qsort</code>
      value is a higher-order function, since the fourth argument is itself a function. As before,
      let's define a wrapper function to make <code>qsort</code> easier to
      use. The second and third arguments to <code>qsort</code> specify the
      length (number of elements) of the array and the element size.</p><p id="idm449006986064">Arrays created using Ctypes have a richer runtime structure than C
    arrays, so we don't need to pass size information around. Furthermore, we
    can use OCaml polymorphism in place of the unsafe <code>void ptr</code> type.</p><section id="example-a-command-line-quicksort"><h1>Example: A Command-Line Quicksort</h1><p id="idm449006983856">The following is a command-line tool that uses the <code>qsort</code> binding to sort all of the integers
      supplied on the standard input:<a name="idm449006982816"></a></p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword6">Ctypes
</span><span class="keyword1">open</span> <span class="keyword6">PosixTypes
</span><span class="keyword1">open</span> <span class="keyword6">Foreign
</span>
<span class="keyword4">let</span> compare_t <span class="keyword2">=</span> ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">int</span>

<span class="keyword4">let</span> qsort <span class="keyword2">=</span> foreign <span class="keyword7">&quot;qsort&quot;</span>
    <span class="keyword2">(</span>ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> size_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> size_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> funptr compare_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> 
       returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> qsort' cmp arr <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword5">Unsigned.Size_t </span><span class="keyword4">in</span>
  <span class="keyword4">let</span> ty <span class="keyword2">=</span> <span class="keyword5">Array.</span>element_type arr <span class="keyword4">in</span>
  <span class="keyword4">let</span> len <span class="keyword2">=</span> of_int <span class="keyword2">(</span><span class="keyword5">Array.</span>length arr<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> elsize <span class="keyword2">=</span> of_int <span class="keyword2">(</span>sizeof ty<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> start <span class="keyword2">=</span> to_voidp <span class="keyword2">(</span><span class="keyword5">Array.</span>start arr<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> compare l r <span class="keyword2">=</span> cmp <span class="keyword2">(</span><span class="keyword2">!</span><span class="keyword2">@</span> <span class="keyword2">(</span>from_voidp ty l<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword2">!</span><span class="keyword2">@</span> <span class="keyword2">(</span>from_voidp ty r<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  qsort start len elsize compare<span class="keyword2">;</span>
  arr

<span class="keyword4">let</span> sort_stdin <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">In_channel.</span>input_lines stdin
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span>int_of_string
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Array.</span>of_list <span class="keyword3">int</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> qsort' <span class="keyword5">Int.</span>compare
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Array.</span>to_list
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> a -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;%d\n&quot;</span> a<span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Sort integers on standard input&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span>empty sort_stdin
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort.ml">ffi/qsort.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449006979360">Compile it in the usual way with <span><em>corebuild</em></span> and test it against some
        input data, and also build the inferred interface so we can examine it more closely:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign qsort.native
</div><div class="highlight"><span class="gp">$</span> cat input.txt
</div><div class="rwocodeout">5</div><div class="rwocodeout">3</div><div class="rwocodeout">2</div><div class="rwocodeout">1</div><div class="rwocodeout">4</div><div class="highlight"><span class="gp">$</span> ./qsort.native &lt; input.txt
</div><div class="rwocodeout">1</div><div class="rwocodeout">2</div><div class="rwocodeout">3</div><div class="rwocodeout">4</div><div class="rwocodeout">5</div><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign qsort.inferred.mli
</div><div class="highlight"><span class="gp">$</span> cp _build/qsort.inferred.mli qsort.mli
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/build_qsort.out">ffi/build_qsort.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449006964640">The inferred interface shows us the types of the raw <code>qsort</code> binding and also the <code>qsort'</code> wrapper function:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> compare_t <span class="keyword2">:</span> <span class="keyword2">(</span>unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span> unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword5">Ctypes.</span>fn
<span class="keyword4">val</span> qsort <span class="keyword2">:</span>
  unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span>
  <span class="keyword5">PosixTypes.</span>size_t -<span class="keyword2">&gt;</span>
  <span class="keyword5">PosixTypes.</span>size_t -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span> unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> qsort' <span class="keyword2">:</span> <span class="keyword2">(</span>'a -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> 'a <span class="keyword5">Ctypes.</span><span class="keyword3">array</span> -<span class="keyword2">&gt;</span> 'a <span class="keyword5">Ctypes.</span><span class="keyword3">array</span>
<span class="keyword4">val</span> sort_stdin <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> unit</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort.mli">ffi/qsort.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449006959904">The <code>qsort'</code> wrapper function has
      a much more canonical OCaml interface than the raw binding. It accepts a
      comparator function and a Ctypes array, and returns the same Ctypes
      array. It's not strictly required that it returns the array, since it
      modifies it in-place, but it makes it easier to chain the function using
      the <code>|&gt;</code> operator (as <code>sort_stdin</code> does in the example).</p><p id="idm449006957184">Using <code>qsort'</code> to sort arrays is
      straightforward. Our example code reads the standard input as a list,
      converts it to a C array, passes it through qsort, and outputs the
      result to the standard output. Again, remember to not confuse the
      <code>Ctypes.Array</code> module with the <code>Core.Std.Array</code> module: the former is in scope
      since we opened <code>Ctypes</code> at the start
      of the file.<a name="idm449006953952"></a><a name="idm449006952384"></a><a name="idm449006951072"></a></p><section><h1><b>Lifetime of Allocated Ctypes</b></h1><p id="idm449006948944">Values allocated via Ctypes (i.e., using <code>allocate</code>,
            <code>Array.make</code>, and so on) will not be garbage-collected
          as long as they are reachable from OCaml values. The system memory they occupy is freed
          when they do become unreachable, via a finalizer function registered with the garbage
          collector (GC).</p><p id="idm449006946944">The definition of reachability for Ctypes values is a little
        different from conventional OCaml values, though. The allocation
        functions return an OCaml-managed pointer to the value, and as long as
        some derivative pointer is still reachable by the GC, the value won't
        be collected.</p><p id="idm449006946240">&quot;Derivative&quot; means a pointer that's computed from the original
        pointer via arithmetic, so a reachable reference to an array element
        or a structure field protects the whole object from collection.</p><p id="idm449006945632">A corollary of the preceding rule is that pointers written into the C heap don't have
          any effect on reachability. For example, if you have a C-managed array of pointers to
          structs, then you'll need some additional way of keeping the structs themselves around to
          protect them from collection. You could achieve this via a global array of values on the
          OCaml side that would keep them live until they're no longer needed.</p><p id="idm449006944784">Functions passed to C have similar considerations regarding lifetime. On the OCaml
          side, functions created at runtime may be collected when they become unreachable. As we've
          seen, OCaml functions passed to C are converted to function pointers, and function
          pointers written into the C heap have no effect on the reachability of the OCaml functions
          they reference. With <code>qsort</code> things are straightforward,
          since the comparison function is only used during the call to <code>qsort</code> itself. However, other C libraries may store function pointers in
          global variables or elsewhere, in which case you'll need to take care that the OCaml
          functions you pass to them aren't prematurely garbage-collected.</p></section></section></section><section id="learning-more-about-c-bindings"><h1>Learning More About C Bindings</h1><p id="idm449006941280">The Ctypes <a href="http://github.com/ocamllabs/ocaml-ctypes" target="_top">distribution</a>
    contains a number of larger-scale examples, including:<a name="idm449006940272"></a></p><ul><li><p id="idm449006938304">Bindings to the POSIX <code>fts</code>
        API, which demonstrates C callbacks more comprehensively</p></li><li><p id="idm449006936800">A more complete Ncurses binding than the example we opened the
        chapter with</p></li><li><p id="idm449006935936">A comprehensive test suite that covers the complete library, and
        can provide useful snippets for your own bindings</p></li></ul><p id="idm449006935168">This chapter hasn't really needed you to understand the innards of OCaml at all. Ctypes
      does its best to make function bindings easy, but the rest of this part will also fill you in
      about interactions with OCaml memory layout in <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a> and automatic memory management in <a href="understanding-the-garbage-collector.html">Chapter 21, <i>Understanding the Garbage Collector</i></a>.</p><p id="idm449006917184">Ctypes gives OCaml programs access to the C representation of
    values, shielding you from the details of the OCaml value representation,
    and introduces an abstraction layer that hides the details of foreign
    calls. While this covers a wide variety of situations, it's sometimes
    necessary to look behind the abstraction to obtain finer control over the
    details of the interaction between the two languages.</p><p id="idm449006916368">You can find more information about the C interface in several
    places:</p><ul><li><p id="idm449006915392">The standard OCaml foreign function interface allows you to glue OCaml and C together
          from the other side of the boundary, by writing C functions that operate on the OCaml
          representation of values. You can find details of the standard interface in the <a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual033.html" target="_top">OCaml
            manual</a> and in the book <a href="http://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf" target="_top"><span><em>Developing
              Applications with Objective Caml</em></span></a>.</p></li><li><p id="idm449006912736">Florent Monnier maintains an excellent online <a href="http://www.linux-nantes.org/~fmonnier/ocaml/ocaml-wrapping-c.html" target="_top">OCaml</a>
        that provides examples of how to call OCaml functions from C. This
        covers a wide variety of OCaml data types and also more complex
        callbacks between C and OCaml.</p></li><li><p id="idm449006911024"><a href="http://www.swig.org" target="_top">SWIG</a> is a tool that
        connects programs written in C/C++ to a variety of higher-level
        programming languages, including OCaml. The SWIG manual has examples
        of converting library specifications into OCaml bindings.</p></li></ul><section id="struct-memory-layout"><h1>Struct Memory Layout</h1><p id="idm449006908688">The C language gives implementations a certain amount of freedom
      in choosing how to lay out structs in memory. There may be padding
      between members and at the end of the struct, in order to satisfy the
      memory alignment requirements of the host platform. Ctypes uses
      platform-appropriate size and alignment information to replicate the
      struct layout process. OCaml and C will have consistent views about the
      layout of the struct as long as you declare the fields of a struct in
      the same order and with the same types as the C library you're binding
      to.<a name="idm449006907824"></a><a name="idm449006906512"></a></p><p id="idm449006905056">However, this approach can lead to difficulties when the fields of
      a struct aren't fully specified in the interface of a library. The
      interface may list the fields of a structure without specifying their
      order, or make certain fields available only on certain platforms, or
      insert undocumented fields into struct definitions for performance
      reasons. For example, the <code>struct
      timeval</code> definition used in this chapter accurately describes
      the layout of the struct on common platforms, but implementations on
      some more unusual architectures include additional padding members that
      will lead to strange behavior in the examples.</p><p id="idm449006903344">The Cstubs subpackage of Ctypes addresses this issue. Rather than
      simply assuming that struct definitions given by the user accurately
      reflect the actual definitions of structs used in C libraries, Cstubs
      generates code that uses the C library headers to discover the layout of
      the struct. The good news is that the code that you write doesn't need
      to change much. Cstubs provides alternative implementations of the
      <code>field</code> and <code>seal</code> functions that you've already used to
      describe <code>struct timeval</code>; instead of
      computing member offsets and sizes appropriate for the platform, these
      implementations obtain them directly from C.</p><p id="idm449006900352">The details of using Cstubs are available in the online <a href="https://ocamllabs.github.io/ocaml-ctypes" target="_top">documentation</a>,
      along with instructions on integration with <span><strong>autoconf</strong></span> platform portability
      instructions.<a name="idm449006898608"></a></p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt03.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="memory-representation-of-values.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>
