<html>

    <head>
    
        <meta charset="utf-8"></meta>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"></meta>
        
        <title>Chapter 4. Files, Modules, and Programs / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"></link>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'realworldocaml',
                        repo: 'book',
                        milestone: 'v1',
                        page: 'files\u002Dmodules\u002Dand\u002Dprograms.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html" class="here">4. Files, Modules, and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">10. First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="objects.html">11. Objects</a>
                                            </li>
                                        
                                            <li>
                                                <a href="classes.html">12. Classes</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="ix01.html">Index</a>
                            
                        </li>
                    
                </ul>
            </nav>
            <header class="header">
                <h1><a href="http://oreil.ly/realworldOCaml"><img src="../../media/img/cover.png" width="120" alt="Real World OCaml, by Yaron Minsky, Anil Madhavapeddy and Jason Hickey"></img></a></h1>
                <p><i>Buy in <a href="http://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/">print</a> and <a href="http://oreil.ly/realworldOCaml">eBook.</a></i></p>
            </header>
        
            <article class="page">
        
                <h1>Chapter 4. Files, Modules, and Programs</h1>
                
                

    <p id="idm146296018496">We've so far experienced OCaml largely through the toplevel. As you move from exercises to
    real-world programs, you'll need to leave the toplevel behind and start building programs from
    files. Files are more than just a convenient way to store and manage your code; in OCaml, they
    also correspond to modules, which act as boundaries that divide your program into conceptual
    units.</p><p id="idm146296017712">In this chapter, we'll show you how to build an OCaml program from a
  collection of files, as well as the basics of working with modules and
  module signatures.</p><section id="single-file-programs"><h1>Single-File Programs</h1><p id="idm146296016224">We'll start with an example: a utility that reads lines from <code>stdin</code> and computes a frequency count of the lines. At the end, the 10 lines with
      the highest frequency counts are written out. We'll start with a simple implementation, which
      we'll save as the file <span><em>freq.ml</em></span>.<a name="FILEsnglprog"></a><a name="Psingfil"></a></p><p id="idm146296011424">This implementation will use two functions from the <code>List.Assoc</code> module, which provides utility
    functions for interacting with association lists, i.e., lists of key/value
    pairs. In particular, we use the function <code>List.Assoc.find</code>, which looks up a key in an
    association list; and <code>List.Assoc.add</code>,
    which adds a new binding to an association list, as shown here:<a name="idm146296008880"></a><a name="idm146296007568"></a><a name="idm146296006256"></a><a name="idm146296004944"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> assoc <span class="keyword2">=</span> <span class="keyword2">[</span><span class="keyword2">(</span><span class="keyword7">&quot;one&quot;</span>, <span class="keyword8">1</span><span class="keyword2">)</span><span class="keyword2">;</span> <span class="keyword2">(</span><span class="keyword7">&quot;two&quot;</span>,<span class="keyword8">2</span><span class="keyword2">)</span><span class="keyword2">;</span> <span class="keyword2">(</span><span class="keyword7">&quot;three&quot;</span>,<span class="keyword8">3</span><span class="keyword2">)</span><span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val assoc : (string * int) list = [(&quot;one&quot;, 1); (&quot;two&quot;, 2); (&quot;three&quot;, 3)]
</div># <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>find assoc <span class="keyword7">&quot;two&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int option = Some 2
</div># <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>add assoc <span class="keyword7">&quot;four&quot;</span> <span class="keyword8">4</span> <span class="comments">(* add a new key *)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (string, int) List.Assoc.t =
[(&quot;four&quot;, 4); (&quot;one&quot;, 1); (&quot;two&quot;, 2); (&quot;three&quot;, 3)]
</div># <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>add assoc <span class="keyword7">&quot;two&quot;</span>  <span class="keyword8">4</span> <span class="comments">(* overwrite an existing key *)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (string, int) List.Assoc.t = [(&quot;two&quot;, 4); (&quot;one&quot;, 1); (&quot;three&quot;, 3)]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/intro.topscript">files-modules-and-programs/intro.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295993440">Note that <code>List.Assoc.add</code> doesn't
    modify the original list, but instead allocates a new list with the
    requisite key/value pair added.</p><p id="idm146295992272">Now we can write <code>freq.ml</code>:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> build_counts <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">In_channel.</span>fold_lines stdin ~init<span class="keyword2">:</span><span class="keyword2">[</span><span class="keyword2">]</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> counts line -<span class="keyword2">&gt;</span>
    <span class="keyword4">let</span> count <span class="keyword2">=</span>
      <span class="keyword1">match</span> <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>find counts line <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
      <span class="keyword2">|</span> <span class="keyword6">Some </span>x -<span class="keyword2">&gt;</span> x
    <span class="keyword4">in</span>
    <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>add counts line <span class="keyword2">(</span>count <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span>
  <span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  build_counts <span class="keyword2">(</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>sort ~cmp<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword8">_</span>,x<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword8">_</span>,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Int.</span>descending x y<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword1">fun</span> l -<span class="keyword2">&gt;</span> <span class="keyword5">List.</span>take l <span class="keyword8">10</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>line,count<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;%3d: %s\n&quot;</span> count line<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq/freq.ml">files-modules-and-programs-freq/freq.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295988112">The function <code>build_counts</code> reads
    in lines from <code>stdin</code>, constructing from
    those lines an association list with the frequencies of each line. It does
    this by invoking <code>In_channel.fold_lines</code>
    (similar to the function <code>List.fold</code>
    described in <a href="lists-and-patterns.html">Chapter 3, <i>Lists and Patterns</i></a>), which reads through
    the lines one by one, calling the provided <code>fold</code>
    function for each line to update the accumulator. That accumulator is
    initialized to the empty list.</p><p id="idm146295983920">With <code>build_counts</code> defined, we
    then call the function to build the association list, sort that list by
    frequency in descending order, grab the first 10 elements off the list,
    and then iterate over those 10 elements and print them to the screen.
    These operations are tied together using the <code>|&gt;</code> operator described in <a href="variables-and-functions.html">Chapter 2, <i>Variables and Functions</i></a>.<a name="idm146295981520"></a><a name="idm146295980608"></a></p><aside class="note"><h1>Where Is the Main Function?</h1><p id="idm146295978672">Unlike C, programs in OCaml do not have a unique <code>main</code> function. When an OCaml program is
      evaluated, all the statements in the implementation files are evaluated
      in the order in which they were linked together. These implementation
      files can contain arbitrary expressions, not just function definitions.
      In this example, the declaration starting with <code>let () =</code> plays the role of the <code>main</code> function, kicking off the processing. But
      really the entire file is evaluated at startup, and so in some sense the
      full codebase is one big <code>main</code>
      function.</p><p id="idm146295975104">The idiom of writing <code>let () =</code>
      may seem a bit odd, but it has a purpose. The <code>let</code>
      binding here is a pattern-match to a value of type <code>unit</code>, which is there to ensure that the
      expression on the righthand side returns <code>unit</code>, as is common for functions that operate
      primarily by side effect.</p></aside><p id="idm146295971952">If we weren't using Core or any other external libraries, we could
    build the executable like this:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc freq.ml -o freq.byte
</div><div class="rwocodeout">File &quot;freq.ml&quot;, line 1, characters 0-13:</div><div class="rwocodeout">Error: Unbound module Core</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq/simple_build_fail.out">files-modules-and-programs-freq/simple_build_fail.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295967008">But as you can see, it fails because it can't find Core. We need a
    somewhat more complex invocation to get Core linked in:<a name="idm146295966624"></a><a name="idm146295965328"></a><a name="idm146295964032"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq.byte
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq/simple_build.out">files-modules-and-programs-freq/simple_build.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295959280">This uses <span><strong>ocamlfind</strong></span>, a tool which
    itself invokes other parts of the OCaml toolchain (in this case, <span><strong>ocamlc</strong></span>) with the appropriate flags to link in
    particular libraries and packages. Here, <code>-package
    core</code> is asking <span><strong>ocamlfind</strong></span> to
    link in the Core library; <code>-linkpkg</code> asks
    ocamlfind to link in the packages as is necessary for building an
    executable, while <code>-thread</code> turns on threading support (which
    is required for Core).<a name="idm146295954480"></a><a name="idm146295953168"></a></p><p id="idm146295951904">While this works well enough for a one-file project, more
    complicated projects require a tool to orchestrate the build. One good
    tool for this task is <span><strong>ocamlbuild</strong></span>, which
    is shipped with the OCaml compiler. We'll talk more about <span><strong>ocamlbuild</strong></span> in <a href="the-compiler-frontend-parsing-and-type-checking.html">Chapter 22, <i>The Compiler Frontend: Parsing and <span>Type
    Checking</span></i></a>, but for now,
    we'll just use a simple wrapper around <span><strong>ocamlbuild</strong></span> called <span><strong>corebuild</strong></span> that sets build parameters
    appropriately for building against Core and its related
    libraries:<a name="idm146295948112"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild freq.byte
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-obuild/build.out">files-modules-and-programs-freq-obuild/build.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295943840">If we'd invoked <span><strong>corebuild</strong></span> with a
    target of <code>freq.native</code> instead of
    <code>freq.byte</code>, we would have gotten native
    code instead.</p><p id="idm146295941392">We can run the resulting executable from the command line. The
    following line extracts strings from the <span><strong>ocamlopt</strong></span> binary, reporting the most frequently
    occurring ones. Note that the specific results will vary from platform to
    platform, since the binary itself will differ between platforms:<a name="idm146295940192"></a><a name="idm146295938896"></a><a name="idm146295937328"></a><a name="idm146295935760"></a><a name="idm146295934464"></a><a name="idm146295933168"></a><a name="idm146295931856"></a><a name="idm146295931248"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> strings <span class="sb">`</span>which ocamlopt<span class="sb">`</span> | ./freq.byte
</div><div class="rwocodeout"> 14: movq</div><div class="rwocodeout"> 10: cmpq</div><div class="rwocodeout">  9: &quot;, &amp;</div><div class="rwocodeout">  7: .globl</div><div class="rwocodeout">  6: addq</div><div class="rwocodeout">  6: leaq</div><div class="rwocodeout">  6: &quot;, (</div><div class="rwocodeout">  6: +pci_expr =</div><div class="rwocodeout">  6: -pci_params =</div><div class="rwocodeout">  6: .pci_virt = %a</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-obuild/test.out">files-modules-and-programs-freq-obuild/test.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="note"><h1>Bytecode Versus Native Code</h1><p id="idm146295920240">OCaml ships with two compilers: the <span><strong>ocamlc</strong></span> bytecode compiler and the <span><strong>ocamlopt</strong></span> native-code compiler. Programs
      compiled with <span><strong>ocamlc</strong></span> are interpreted
      by a virtual machine, while programs compiled with <span><strong>ocamlopt</strong></span> are compiled to native machine code
      to be run on a specific operating system and processor architecture.
      With <span><strong>ocamlbuild</strong></span>, targets ending with
      <code>.byte</code> are build as bytecode
      executables, and those ending with <code>.native</code> are built as native code.</p><p id="idm146295914880">Aside from performance, executables generated by the two compilers
      have nearly identical behavior. There are a few things to be aware of.
      First, the bytecode compiler can be used on more architectures, and has
      some tools that are not available for native code. For example, the
      OCaml debugger only works with bytecode (although <span><strong>gdb</strong></span>, the GNU Debugger, works with OCaml
      native-code applications). The bytecode compiler is also quicker than
      the native-code compiler. In addition, in order to run a bytecode
      executable, you typically need to have OCaml installed on the system in
      question. That's not strictly required, though, since you can build a
      bytecode executable with an embedded runtime, using the <code>-custom</code> compiler flag.</p><p id="idm146295912432">As a general matter, production executables should usually be
      built using the native-code compiler, but it sometimes makes sense to
      use bytecode for development builds. And, of course, bytecode makes
      sense when targeting a platform not supported by the native-code
      compiler. We'll cover both compilers in more detail in <a href="the-compiler-backend-byte-code-and-native-code.html">Chapter 23, <i>The Compiler Backend: Bytecode and Native code</i></a>.</p></aside></section><section id="multi-file-programs-and-modules"><h1>Multifile Programs and Modules</h1><p id="idm146295909984">Source files in OCaml are tied into the module system, with each
    file compiling down into a module whose name is derived from the name of
    the file. We've encountered modules before, such as when we used functions
    like <code>find</code> and <code>add</code> from the <code>List.Assoc</code> module. At its simplest, you can
    think of a module as a collection of definitions that are stored within a
    namespace.<a name="idm146295907424"></a><a name="idm146295906128"></a><a name="idm146295904816"></a></p><p id="idm146295903376">Let's consider how we can use modules to refactor the implementation
    of <code>freq.ml</code>. Remember that the variable
    <code>counts</code> contains an association list
    representing the counts of the lines seen so far. But updating an
    association list takes time linear in the length of the list, meaning that
    the time complexity of processing a file is quadratic in the number of
    distinct lines in the file.</p><p id="idm146295901296">We can fix this problem by replacing association lists with a more
    efficient data structure. To do that, we'll first factor out the key
    functionality into a separate module with an explicit interface. We can
    consider alternative (and more efficient) implementations once we have a
    clear interface to program against.</p><p id="idm146295900576">We'll start by creating a file, <code>counter.ml</code>, that contains the logic for
    maintaining the association list used to represent the frequency counts.
    The key function, called <code>touch</code>, bumps
    the frequency count of a given line by one:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> touch t s <span class="keyword2">=</span>
  <span class="keyword4">let</span> count <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>find t s <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> <span class="keyword6">Some </span>x -<span class="keyword2">&gt;</span> x
  <span class="keyword4">in</span>
  <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>add t s <span class="keyword2">(</span>count <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-counter/counter.ml">files-modules-and-programs-freq-with-counter/counter.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295896272">The file <span><em>counter.ml</em></span> will be compiled into a
    module named <code>Counter</code>, where the name of
    the module is derived automatically from the filename. The module name is
    capitalized even if the file is not. Indeed, module names are always
    capitalized.<a name="idm146295894896"></a></p><p id="idm146295893472">We can now rewrite <code>freq.ml</code> to use
    <code>Counter</code>. Note that the resulting code
    can still be built with <span><strong>ocamlbuild</strong></span>,
    which will discover dependencies and realize that <code>counter.ml</code> needs to be compiled:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> build_counts <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">In_channel.</span>fold_lines stdin ~init<span class="keyword2">:</span><span class="keyword2">[</span><span class="keyword2">]</span> ~f<span class="keyword2">:</span><span class="keyword5">Counter.</span>touch

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  build_counts <span class="keyword2">(</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>sort ~cmp<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword8">_</span>,x<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword8">_</span>,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Int.</span>descending x y<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword1">fun</span> l -<span class="keyword2">&gt;</span> <span class="keyword5">List.</span>take l <span class="keyword8">10</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>line,count<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;%3d: %s\n&quot;</span> count line<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-counter/freq.ml">files-modules-and-programs-freq-with-counter/freq.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="signatures-and-abstract-types"><h1>Signatures and Abstract Types</h1><p id="idm146295886464">While we've pushed some of the logic to the <code>Counter</code> module, the code in <code>freq.ml</code> can still depend on the details of the
    implementation of <code>Counter</code>. Indeed, if
    you look at the definition of <code>build_counts</code>, you'll see that it depends on the
    fact that the empty set of frequency counts is represented as an empty
    list. We'd like to prevent this kind of dependency, so we can change the
    implementation of <code>Counter</code> without
    needing to change client code like that in <code>freq.ml</code>.<a name="idm146295881888"></a><a name="idm146295880992"></a><a name="idm146295879696"></a><a name="idm146295878400"></a><a name="idm146295877072"></a></p><p id="idm146295875632">The implementation details of a module can be hidden by attaching an
    <span><em>interface</em></span>. (Note that in the context of OCaml, the
    terms <span><em>interface</em></span>, <span><em>signature</em></span>, and
    <span><em>module type</em></span> are all used interchangeably.) A module
    defined by a file <code>filename.ml</code> can be
    constrained by a signature placed in a file called <code>filename.mli</code>.<a name="idm146295872208"></a></p><p id="idm146295870784">For <code>counter.mli</code>, we'll start by
    writing down an interface that describes what's currently available in
    <code>counter.ml</code>, without hiding anything.
    <code>val</code> declarations are used to specify
    values in a signature. The syntax of a <code>val</code> declaration is as follows:</p><div class="rwocode"><pre><code><pre>val &lt;identifier&gt; : &lt;type&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/val.syntax">files-modules-and-programs/val.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295865568">Using this syntax, we can write the signature of <code>counter.ml</code> as follows:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="comments">(** Bump the frequency count for the given string. *)</span>
<span class="keyword4">val</span> touch <span class="keyword2">:</span> <span class="keyword2">(</span><span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword3">list</span> -<span class="keyword2">&gt;</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword3">list</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-sig/counter.mli">files-modules-and-programs-freq-with-sig/counter.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295861936">Note that <span><strong>ocamlbuild</strong></span> will detect
    the presence of the <code>mli</code> file
    automatically and include it in the build.</p><aside class="note"><h1>Autogenerating mli Files</h1><p id="idm146295859488">If you don't want to construct an <code>mli</code> entirely
      by hand, you can ask OCaml to autogenerate one for you from the source,
      which you can then adjust to fit your needs. Here's how you can do that
      using <span><em>corebuild</em></span>:<a name="idm146295858208"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild counter.inferred.mli
</div><div class="highlight"><span class="gp">$</span> cat _build/counter.inferred.mli
</div><div class="rwocodeout">val touch :</div><div class="rwocodeout">  ('a, int) Core.Std.List.Assoc.t -&gt; 'a -&gt; ('a, int) Core.Std.List.Assoc.t</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-counter/infer_mli.out">files-modules-and-programs-freq-with-counter/infer_mli.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295850880">The generated code is basically equivalent to the <code>mli</code> that we wrote by hand but is a bit uglier
      and more verbose and, of course, has no comments. In general,
      autogenerated <code>mli</code>s are only useful as
      a starting point. In OCaml, the <code>mli</code>
      is the key place where you present and document your interface, and
      there's no replacement for careful human editing and
      organization.</p></aside><p id="idm146295848176">To hide the fact that frequency counts are represented as
    association lists, we'll need to make the type of frequency counts
    <span><em>abstract</em></span>. A type is abstract if its name is exposed
    in the interface, but its definition is not. Here's an abstract interface
    for <code>Counter</code>:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="comments">(** A collection of string frequency counts *)</span>
<span class="keyword4">type</span> t

<span class="comments">(** The empty set of frequency counts  *)</span>
<span class="keyword4">val</span> empty <span class="keyword2">:</span> t

<span class="comments">(** Bump the frequency count for the given string. *)</span>
<span class="keyword4">val</span> touch <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> t

<span class="comments">(** Converts the set of frequency counts to an association list.  A string shows
    up at most once, and the counts are &gt;= 1. *)</span>
<span class="keyword4">val</span> to_list <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword3">list</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-sig-abstract/counter.mli">files-modules-and-programs-freq-with-sig-abstract/counter.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295843664">Note that we needed to add <code>empty</code>
    and <code>to_list</code> to <code>Counter</code>, since otherwise there would be no way
    to create a <code>Counter.t</code> or get data out
    of one.</p><p id="idm146295840640">We also used this opportunity to document the module. The <code>mli</code> file is the place where you specify your module's interface, and as such is a
      natural place to put documentation. We started our comments with a double asterisk to cause
      them to be picked up by the <span><strong>ocamldoc</strong></span> tool when generating
      API documentation. We'll discuss <span><strong>ocamldoc</strong></span> more in <a href="the-compiler-frontend-parsing-and-type-checking.html">Chapter 22, <i>The Compiler Frontend: Parsing and <span>Type
    Checking</span></i></a>.</p><p id="idm146295837456">Here's a rewrite of <code>counter.ml</code> to
    match the new <code>counter.mli</code>:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword3">list</span>

<span class="keyword4">let</span> empty <span class="keyword2">=</span> <span class="keyword2">[</span><span class="keyword2">]</span>

<span class="keyword4">let</span> to_list x <span class="keyword2">=</span> x

<span class="keyword4">let</span> touch t s <span class="keyword2">=</span>
  <span class="keyword4">let</span> count <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>find t s <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> <span class="keyword6">Some </span>x -<span class="keyword2">&gt;</span> x
  <span class="keyword4">in</span>
  <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>add t s <span class="keyword2">(</span>count <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-sig-abstract/counter.ml">files-modules-and-programs-freq-with-sig-abstract/counter.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295833136">If we now try to compile <code>freq.ml</code>,
    we'll get the following error:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild freq.byte
</div><div class="rwocodeout">File &quot;freq.ml&quot;, line 4, characters 42-55:</div><div class="rwocodeout">Error: This expression has type Counter.t -&gt; string -&gt; Counter.t</div><div class="rwocodeout">       but an expression was expected of type 'a list -&gt; string -&gt; 'a list</div><div class="rwocodeout">       Type Counter.t is not compatible with type 'a list </div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-sig-abstract/build.out">files-modules-and-programs-freq-with-sig-abstract/build.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295825648">This is because <code>freq.ml</code> depends
    on the fact that frequency counts are represented as association lists, a
    fact that we've just hidden. We just need to fix <code>build_counts</code> to use <code>Counter.empty</code> instead of <code>[]</code> and <code>Counter.to_list</code> to get the association list out
    at the end for processing and printing. The resulting implementation is
    shown below:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> build_counts <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">In_channel.</span>fold_lines stdin ~init<span class="keyword2">:</span><span class="keyword5">Counter.</span>empty ~f<span class="keyword2">:</span><span class="keyword5">Counter.</span>touch

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  build_counts <span class="keyword2">(</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Counter.</span>to_list
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>sort ~cmp<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword8">_</span>,x<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword8">_</span>,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Int.</span>descending x y<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword1">fun</span> counts -<span class="keyword2">&gt;</span> <span class="keyword5">List.</span>take counts <span class="keyword8">10</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>line,count<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;%3d: %s\n&quot;</span> count line<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-sig-abstract-fixed/freq.ml">files-modules-and-programs-freq-with-sig-abstract-fixed/freq.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295819344">Now we can turn to optimizing the implementation of <code>Counter</code>. Here's an alternate and far more
    efficient implementation, based on the <code>Map</code> data structure in Core:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">int</span> <span class="keyword5">String.</span><span class="keyword5">Map.</span>t

<span class="keyword4">let</span> empty <span class="keyword2">=</span> <span class="keyword5">String.</span><span class="keyword5">Map.</span>empty

<span class="keyword4">let</span> to_list t <span class="keyword2">=</span> <span class="keyword5">Map.</span>to_alist t

<span class="keyword4">let</span> touch t s <span class="keyword2">=</span>
  <span class="keyword4">let</span> count <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword5">Map.</span>find t s <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> <span class="keyword6">Some </span>x -<span class="keyword2">&gt;</span> x
  <span class="keyword4">in</span>
  <span class="keyword5">Map.</span>add t ~key<span class="keyword2">:</span>s ~data<span class="keyword2">:</span><span class="keyword2">(</span>count <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-fast/counter.ml">files-modules-and-programs-freq-fast/counter.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295814272">Note that in the preceding example we use <code>String.Map</code> in some places and simply <code>Map</code> in others. This has to do with the fact that
    for some operations, like creating a <code>Map.t</code>, you need access to type-specialized
    information, and for others, like looking something up in <code>Map.t</code>, you don't. This is covered in more detail
    in <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a>.</p></section><section id="concrete-types-in-signatures"><h1>Concrete Types in Signatures</h1><p id="idm146295809440">In our frequency-count example, the module <code>Counter</code> had an abstract type <code>Counter.t</code> for representing a collection of
    frequency counts. Sometimes, you'll want to make a type in your interface
    <span><em>concrete</em></span>, by including the type definition in the
    interface.<a name="idm146295807232"></a><a name="idm146295806336"></a></p><p id="idm146295804912">For example, imagine we wanted to add a function to <code>Counter</code> for returning the line with the median
    frequency count. If the number of lines is even, then there is no precise
    median, and the function would return the lines before and after the
    median instead. We'll use a custom type to represent the fact that there
    are two possible return values. Here's a possible implementation:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> median <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Median </span><span class="keyword2">of</span> <span class="keyword3">string</span>
              <span class="keyword2">|</span> <span class="keyword6">Before_and_after </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword3">string</span>

<span class="keyword4">let</span> median t <span class="keyword2">=</span>
  <span class="keyword4">let</span> sorted_strings <span class="keyword2">=</span> <span class="keyword5">List.</span>sort <span class="keyword2">(</span><span class="keyword5">Map.</span>to_alist t<span class="keyword2">)</span>
                         ~cmp<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword8">_</span>,x<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword8">_</span>,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Int.</span>descending x y<span class="keyword2">)</span>
  <span class="keyword4">in</span>
  <span class="keyword4">let</span> len <span class="keyword2">=</span> <span class="keyword5">List.</span>length sorted_strings <span class="keyword4">in</span>
  <span class="keyword1">if</span> len <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">then</span> failwith <span class="keyword7">&quot;median: empty frequency count&quot;</span><span class="keyword2">;</span>
  <span class="keyword4">let</span> nth n <span class="keyword2">=</span> fst <span class="keyword2">(</span><span class="keyword5">List.</span>nth_exn sorted_strings n<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword1">if</span> len <span class="keyword2">mod</span> <span class="keyword8">2</span> <span class="keyword2">=</span> <span class="keyword8">1</span>
  <span class="keyword1">then</span> <span class="keyword6">Median </span><span class="keyword2">(</span>nth <span class="keyword2">(</span>len/<span class="keyword8">2</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword1">else</span> <span class="keyword6">Before_and_after </span><span class="keyword2">(</span>nth <span class="keyword2">(</span>len/<span class="keyword8">2</span> - <span class="keyword8">1</span><span class="keyword2">)</span>, nth <span class="keyword2">(</span>len/<span class="keyword8">2</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-median/counter.ml">files-modules-and-programs-freq-median/counter.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295801024">In the preceding implementation, we use <code>failwith</code> to throw an exception for the case of
    the empty list. We'll discuss exceptions more in <a href="error-handling.html">Chapter 7, <i>Error Handling</i></a>. Note also that the function <code>fst</code> simply returns the first element of any
    two-tuple.</p><p id="idm146295798688">Now, to expose this usefully in the interface, we need to expose
    both the function and the type <code>median</code>
    with its definition. Note that values (of which functions are an example)
    and types have distinct namespaces, so there's no name clash here. Adding
    the following two lines added to <code>counter.mli</code> does the trick:</p><div class="rwocode"><pre><code><span class="comments">(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)</span>
<span class="keyword4">type</span> median <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Median </span><span class="keyword2">of</span> <span class="keyword3">string</span>
              <span class="keyword2">|</span> <span class="keyword6">Before_and_after </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword3">string</span>

<span class="keyword4">val</span> median <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> median</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-median/counter.mli">files-modules-and-programs-freq-median/counter.mli</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295794512">The decision of whether a given type should be abstract or concrete
    is an important one. Abstract types give you more control over how values
    are created and accessed, and make it easier to enforce invariants beyond
    what is enforced by the type itself; concrete types let you expose more
    detail and structure to client code in a lightweight way. The right choice
    depends very much on the context.</p></section><section id="nested-modules"><h1>Nested Modules</h1><p id="idm146295791696">Up until now, we've only considered modules that correspond to
    files, like <code>counter.ml</code>. But modules
    (and module signatures) can be nested inside other modules. As a simple
    example, consider a program that needs to deal with multiple identifiers
    like usernames and hostnames. If you just represent these as strings, then
    it becomes easy to confuse one with the other.<a name="idm146295790416"></a><a name="idm146295789104"></a><a name="idm146295788208"></a></p><p id="idm146295786784">A better approach is to mint new abstract types for each identifier,
    where those types are under the covers just implemented as strings. That
    way, the type system will prevent you from confusing a username with a
    hostname, and if you do need to convert, you can do so using explicit
    conversions to and from the string type.</p><p id="idm146295786048">Here's how you might create such an abstract type, within a
    submodule:<a name="idm146295785712"></a></p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">module</span> <span class="keyword6">Username </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
  <span class="keyword4">type</span> t
  <span class="keyword4">val</span> of_string <span class="keyword2">:</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> t
  <span class="keyword4">val</span> to_string <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">string</span>
<span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>
  <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">string</span>
  <span class="keyword4">let</span> of_string x <span class="keyword2">=</span> x
  <span class="keyword4">let</span> to_string x <span class="keyword2">=</span> x
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/abstract_username.ml">files-modules-and-programs/abstract_username.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295781744">Note that the <code>to_string</code> and
    <code>of_string</code> functions above are
    implemented simply as the identity function, which means they have no
    runtime effect. They are there purely as part of the discipline that they
    enforce on the code through the type system.</p><p id="idm146295779904">The basic structure of a module declaration like this is:</p><div class="rwocode"><pre><code><pre>module &lt;name&gt; : &lt;signature&gt; = &lt;implementation&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/module.syntax">files-modules-and-programs/module.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295776256">We could have written this slightly differently, by giving the
    signature its own top-level <code>module type</code>
    declaration, making it possible to create multiple distinct types with the
    same underlying implementation in a lightweight way:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">ID </span><span class="keyword2">=</span> <span class="keyword4">sig</span>
  <span class="keyword4">type</span> t
  <span class="keyword4">val</span> of_string <span class="keyword2">:</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> t
  <span class="keyword4">val</span> to_string <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">string</span>
<span class="keyword4">end</span>

<span class="keyword4">module</span> <span class="keyword6">String_id </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
  <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">string</span>
  <span class="keyword4">let</span> of_string x <span class="keyword2">=</span> x
  <span class="keyword4">let</span> to_string x <span class="keyword2">=</span> x
<span class="keyword4">end</span>

<span class="keyword4">module</span> <span class="keyword6">Username </span><span class="keyword2">:</span> <span class="keyword6">ID </span><span class="keyword2">=</span> <span class="keyword6">String_id
</span><span class="keyword4">module</span> <span class="keyword6">Hostname </span><span class="keyword2">:</span> <span class="keyword6">ID </span><span class="keyword2">=</span> <span class="keyword6">String_id
</span>
<span class="keyword4">type</span> session_info <span class="keyword2">=</span> <span class="keyword2">{</span> user<span class="keyword2">:</span> <span class="keyword5">Username.</span>t<span class="keyword2">;</span>
                      host<span class="keyword2">:</span> <span class="keyword5">Hostname.</span>t<span class="keyword2">;</span>
                      when_started<span class="keyword2">:</span> <span class="keyword5">Time.</span>t<span class="keyword2">;</span>
                    <span class="keyword2">}</span>

<span class="keyword4">let</span> sessions_have_same_user s1 s2 <span class="keyword2">=</span>
  s1.user <span class="keyword2">=</span> s2.host</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/session_info.ml">files-modules-and-programs/session_info.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295772544">The preceding code has a bug: it compares the username in one
    session to the host in the other session, when it should be comparing the
    usernames in both cases. Because of how we defined our types, however, the
    compiler will flag this bug for us:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild session_info.native
</div><div class="rwocodeout">File &quot;session_info.ml&quot;, line 24, characters 12-19:</div><div class="rwocodeout">Error: This expression has type Hostname.t</div><div class="rwocodeout">       but an expression was expected of type Username.t</div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/build_session_info.out">files-modules-and-programs/build_session_info.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295766144">This is a trivial example, but confusing different kinds of
    identifiers is a very real source of bugs, and the approach of minting
    abstract types for different classes of identifiers is an effective way of
    avoiding such issues.</p></section><section id="opening-modules"><h1>Opening Modules</h1><p id="idm146295764496">Most of the time, you refer to values and types within a module by
    using the module name as an explicit qualifier. For example, you write
    <code>List.map</code> to refer to the <code>map</code> function in the <code>List</code> module. Sometimes, though, you want to be
    able to refer to the contents of a module without this explicit
    qualification. That's what the <code>open</code>
    statement is for.<a name="idm146295761440"></a><a name="idm146295760128"></a></p><p id="idm146295758704">We've encountered <code>open</code> already,
    specifically where we've written <code>open
    Core.Std</code> to get access to the standard definitions in the Core
    library. In general, opening a module adds the contents of that module to
    the environment that the compiler looks at to find the definition of
    various identifiers. Here's an example:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">M </span><span class="keyword2">=</span> <span class="keyword4">struct</span> <span class="keyword4">let</span> foo <span class="keyword2">=</span> <span class="keyword8">3</span> <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module M : sig val foo : int end
</div># foo<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters -1-3:
Error: Unbound value foo
</div># <span class="keyword1">open</span> M<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># foo<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 3
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295747520"><code>open</code> is essential when you want
    to modify your environment for a standard library like Core, but it's
    generally good style to keep the opening of modules to a minimum. Opening
    a module is basically a trade-off between terseness and explicitness—the
    more modules you open, the fewer module qualifications you need, and the
    harder it is to look at an identifier and figure out where it comes
    from.</p><p id="idm146295746624">Here's some general advice on how to deal with
    <code>open</code>s:<a name="idm146295745056"></a></p><ul><li><p id="idm146295743520">Opening modules at the toplevel of a module should be done quite
        sparingly, and generally only with modules that have been specifically
        designed to be opened, like <code>Core.Std</code> or <code>Option.Monad_infix</code>.</p></li><li><p id="idm146295741248">If you do need to do an open, it's better to do a
        <span><em>local open</em></span>. There are two syntaxes for local
        opens. For example, you can write:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> average x y <span class="keyword2">=</span>
    <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Int64 </span><span class="keyword4">in</span>
    x <span class="keyword2">+</span> y / of_int <span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295735024">Here, <code>of_int</code> and the infix
        operators are the ones from the <code>Int64</code> module.</p><p id="idm146295733264">There's another, even more lightweight syntax for local
        <code>open</code>s, which is particularly useful for small
        expressions:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> average x y <span class="keyword2">=</span>
    <span class="keyword5">Int64.</span><span class="keyword2">(</span>x <span class="keyword2">+</span> y / of_int <span class="keyword8">2</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></li><li><p id="idm146295727344">An alternative to local <code>open</code>s that makes your
        code terser without giving up on explicitness is to locally rebind the
        name of a module. So, when using the <code>Counter.median</code> type, instead of
        writing:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> print_median m <span class="keyword2">=</span>
  <span class="keyword1">match</span> m <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword5">Counter.Median </span><span class="keyword3">string</span> -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;True median:\n   %s\n&quot;</span> <span class="keyword3">string</span>
  <span class="keyword2">|</span> <span class="keyword5">Counter.Before_and_after </span><span class="keyword2">(</span>before, after<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    printf <span class="keyword7">&quot;Before and after median:\n   %s\n   %s\n&quot;</span> before after</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-median/use_median_1.ml">files-modules-and-programs-freq-median/use_median_1.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295722704">you could write:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> print_median m <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">module</span> <span class="keyword6">C </span><span class="keyword2">=</span> <span class="keyword6">Counter </span><span class="keyword4">in</span>
  <span class="keyword1">match</span> m <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword5">C.Median </span><span class="keyword3">string</span> -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;True median:\n   %s\n&quot;</span> <span class="keyword3">string</span>
  <span class="keyword2">|</span> <span class="keyword5">C.Before_and_after </span><span class="keyword2">(</span>before, after<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    printf <span class="keyword7">&quot;Before and after median:\n   %s\n   %s\n&quot;</span> before after</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-median/use_median_2.ml">files-modules-and-programs-freq-median/use_median_2.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295719328">Because the module name <code>C</code>
        only exists for a short scope, it's easy to read and remember what
        <code>C</code> stands for. Rebinding modules to
        very short names at the top level of your module is usually a
        mistake.</p></li></ul></section><section id="including-modules"><h1>Including Modules</h1><p id="idm146295716224">While opening a module affects the environment used to search for identifiers,
        <span><em>including</em></span> a module is a way of actually adding new identifiers to a
      module proper. Consider the following simple module for representing a range of integer
        values:<a name="idm146295715488"></a><a name="idm146295714192"></a></p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Interval </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Interval </span><span class="keyword2">of</span> <span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">int</span>
             <span class="keyword2">|</span> <span class="keyword6">Empty
</span>
    <span class="keyword4">let</span> create low high <span class="keyword2">=</span>
      <span class="keyword1">if</span> high <span class="keyword2">&lt;</span> low <span class="keyword1">then</span> <span class="keyword6">Empty </span><span class="keyword1">else</span> <span class="keyword6">Interval </span><span class="keyword2">(</span>low,high<span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Interval :
  sig type t = Interval of int * int | Empty val create : int -&gt; int -&gt; t end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295704112">We can use the <code>include</code> directive
    to create a new, extended version of the <code>Interval</code> module:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Extended_interval </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">include</span> <span class="keyword6">Interval
</span>
    <span class="keyword4">let</span> contains t x <span class="keyword2">=</span>
      <span class="keyword1">match</span> t <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> false
      <span class="keyword2">|</span> <span class="keyword6">Interval </span><span class="keyword2">(</span>low,high<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> x <span class="keyword2">&gt;</span><span class="keyword2">=</span> low <span class="keyword2">&amp;&amp;</span> x <span class="keyword2">&lt;</span><span class="keyword2">=</span> high
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Extended_interval :
  sig
    type t = Interval.t = Interval of int * int | Empty
    val create : int -&gt; int -&gt; t
    val contains : t -&gt; int -&gt; bool
  end
</div># <span class="keyword5">Extended_interval.</span>contains <span class="keyword2">(</span><span class="keyword5">Extended_interval.</span>create <span class="keyword8">3</span> <span class="keyword8">10</span><span class="keyword2">)</span> <span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = true
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295688848">The difference between <code>include</code>
    and <code>open</code> is that we've done more than
    change how identifiers are searched for: we've changed what's in the
    module. If we'd used <code>open</code>, we'd have
    gotten a quite different result:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Extended_interval </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword1">open</span> <span class="keyword6">Interval
</span>
    <span class="keyword4">let</span> contains t x <span class="keyword2">=</span>
      <span class="keyword1">match</span> t <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> false
      <span class="keyword2">|</span> <span class="keyword6">Interval </span><span class="keyword2">(</span>low,high<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> x <span class="keyword2">&gt;</span><span class="keyword2">=</span> low <span class="keyword2">&amp;&amp;</span> x <span class="keyword2">&lt;</span><span class="keyword2">=</span> high
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Extended_interval :
  sig val contains : Extended_interval.t -&gt; int -&gt; bool end
</div># <span class="keyword5">Extended_interval.</span>contains <span class="keyword2">(</span><span class="keyword5">Extended_interval.</span>create <span class="keyword8">3</span> <span class="keyword8">10</span><span class="keyword2">)</span> <span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 28-52:
Error: Unbound value Extended_interval.create
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295674688">To consider a more realistic example, imagine you wanted to build an
    extended version of the <code>List</code> module,
    where you've added some functionality not present in the module as
    distributed in Core. <code>include</code> allows us
    to do just that:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="comments">(* The new function we're going to add *)</span>
<span class="keyword4">let</span> <span class="keyword4">rec</span> intersperse <span class="keyword3">list</span> el <span class="keyword2">=</span>
  <span class="keyword1">match</span> <span class="keyword3">list</span> <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> <span class="keyword2">|</span> <span class="keyword2">[</span> <span class="keyword8">_</span> <span class="keyword2">]</span>   -<span class="keyword2">&gt;</span> <span class="keyword3">list</span>
  <span class="keyword2">|</span> x <span class="keyword2">:</span><span class="keyword2">:</span> y <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> x <span class="keyword2">:</span><span class="keyword2">:</span> el <span class="keyword2">:</span><span class="keyword2">:</span> intersperse <span class="keyword2">(</span>y<span class="keyword2">:</span><span class="keyword2">:</span>tl<span class="keyword2">)</span> el

<span class="comments">(* The remainder of the list module *)</span>
<span class="keyword4">include</span> List</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/ext_list.ml">files-modules-and-programs/ext_list.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295670304">Now, how do we write an interface for this new module? It turns out
    that <code>include</code> works on signatures as
    well, so we can pull essentially the same trick to write our <code>mli</code>. The only issues is that we need to get our
    hands on the signature for the <code>List</code>
    module. This can be done using <code>module type
    of</code>, which computes a signature from a module:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="comments">(* Include the interface of the list module from Core *)</span>
<span class="keyword4">include</span> <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword2">of</span> List<span class="keyword2">)</span>

<span class="comments">(* Signature of function we're adding *)</span>
<span class="keyword4">val</span> intersperse <span class="keyword2">:</span> 'a <span class="keyword3">list</span> -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> 'a <span class="keyword3">list</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/ext_list.mli">files-modules-and-programs/ext_list.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295664256">Note that the order of declarations in the <code>mli</code> does not need to match the order of
    declarations in the <code>ml</code>. The order of
    declarations in the <code>ml</code> mostly matters
    insofar as it affects which values are shadowed. If we wanted to replace a
    function in <code>List</code> with a new function of
    the same name, the declaration of that function in the <code>ml</code> would have to come after the <code>include List</code> declaration.</p><p id="idm146295659680">We can now use <code>Ext_list</code> as a
    replacement for <code>List</code>. If we want to use
    <code>Ext_list</code> in preference to <code>List</code> in our project, we can create a file of
    common definitions:</p><div class="rwocode"><pre><code><span class="keyword4">module</span> <span class="keyword6">List </span><span class="keyword2">=</span> Ext_list</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs/common.ml">files-modules-and-programs/common.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295654304">And if we then put <code>open Common</code>
    after <code>open Core.Std</code> at the top of each
    file in our project, then references to <code>List</code> will automatically go to <code>Ext_list</code> instead.</p></section><section id="common-errors-with-modules"><h1>Common Errors with Modules</h1><p id="idm146295650128">When OCaml compiles a program with an <code>ml</code> and an <code>mli</code>, it will complain if it detects a mismatch
    between the two. Here are some of the common errors you'll run
    into.</p><section id="type-mismatches"><h1>Type Mismatches</h1><p id="idm146295647408">The simplest kind of error is where the type specified in the signature does not match
        the type in the implementation of the module. As an example, if we replace the <code>val</code> declaration in <code>counter.mli</code> by swapping the types of the first two arguments:<a name="idm146295645792"></a><a name="idm146295644480"></a><a name="idm146295643584"></a></p><div class="rwocode"><pre><code><span class="comments">(** Bump the frequency count for the given string. *)</span>
<span class="keyword4">val</span> touch <span class="keyword2">:</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> t -<span class="keyword2">&gt;</span> t</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-sig-mismatch/counter.mli">files-modules-and-programs-freq-with-sig-mismatch/counter.mli</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295639520">and we try to compile, we'll get the following error:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild freq.byte
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-sig-mismatch/build.out">files-modules-and-programs-freq-with-sig-mismatch/build.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="missing-definitions"><h1>Missing Definitions</h1><p id="idm146295630880">We might decide that we want a new function in <code>Counter</code> for pulling out the frequency count of
      a given string. We can update the <code>mli</code>
      by adding the following line:<a name="idm146295629168"></a><a name="idm146295627856"></a></p><div class="rwocode"><pre><code><span class="keyword4">val</span> count <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-missing-def/counter.mli">files-modules-and-programs-freq-with-missing-def/counter.mli</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295607712">Now, if we try to compile without actually adding the
      implementation, we'll get this error:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild freq.byte
</div><div class="rwocodeout">File &quot;counter.ml&quot;, line 1:</div><div class="rwocodeout">Error: The implementation counter.ml</div><div class="rwocodeout">       does not match the interface counter.cmi:</div><div class="rwocodeout">       The field `count' is required but not provided</div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-missing-def/build.out">files-modules-and-programs-freq-with-missing-def/build.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295600736">A missing type definition will lead to a similar error.</p></section><section id="type-definition-mismatches"><h1>Type Definition Mismatches</h1><p id="idm146295599232">Type definitions that show up in an <code>mli</code> need to match up with corresponding
      definitions in the <code>ml</code>. Consider again
      the example of the type <code>median</code>. The
      order of the declaration of variants matters to the OCaml compiler, so
      the definition of <code>median</code> in the
      implementation listing those options in a different order:<a name="idm146295596096"></a><a name="idm146295595184"></a><a name="idm146295593856"></a></p><div class="rwocode"><pre><code><span class="comments">(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)</span>
<span class="keyword4">type</span> median <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Before_and_after </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword3">string</span>
              <span class="keyword2">|</span> <span class="keyword6">Median </span><span class="keyword2">of</span> <span class="keyword3">string</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-type-mismatch/counter.mli">files-modules-and-programs-freq-with-type-mismatch/counter.mli</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295589760">will lead to a compilation error:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild freq.byte
</div><div class="rwocodeout">File &quot;counter.ml&quot;, line 1:</div><div class="rwocodeout">Error: The implementation counter.ml</div><div class="rwocodeout">       does not match the interface counter.cmi:</div><div class="rwocodeout">       Type declarations do not match:</div><div class="rwocodeout">         type median = Median of string | Before_and_after of string * string</div><div class="rwocodeout">       is not included in</div><div class="rwocodeout">         type median = Before_and_after of string * string | Median of string</div><div class="rwocodeout">       File &quot;counter.ml&quot;, line 18, characters 5-84: Actual declaration</div><div class="rwocodeout">       Fields number 1 have different names, Median and Before_and_after.</div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-with-type-mismatch/build.out">files-modules-and-programs-freq-with-type-mismatch/build.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295579376">Order is similarly important to other type declarations, including
      the order in which record fields are declared and the order of arguments
      (including labeled and optional arguments) to a function.</p></section><section id="cyclic-dependencies"><h1>Cyclic Dependencies</h1><p id="idm146295577712">In most cases, OCaml doesn't allow cyclic dependencies, i.e., a
      collection of definitions that all refer to one another. If you want to
      create such definitions, you typically have to mark them specially. For
      example, when defining a set of mutually recursive values (like the
      definition of <code>is_even</code> and <code>is_odd</code> in <a href="variables-and-functions.html#recursive-functions">the section called “Recursive Functions”</a>), you need to define them using
      <code>let rec</code> rather than ordinary <code>let</code>.<a name="idm146295573968"></a><a name="idm146295573056"></a><a name="idm146295572144"></a><a name="idm146295570832"></a></p><p id="idm146295569392">The same is true at the module level. By default, cyclic
      dependencies between modules are not allowed, and cyclic dependencies
      among files are never allowed. Recursive modules are possible but are a
      rare case, and we won't discuss them further here.</p><p id="idm146295568736">The simplest example of a forbidden circular reference is a module
      referring to its own module name. So, if we tried to add a reference to
      <code>Counter</code> from within <code>counter.ml</code>:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> singleton l <span class="keyword2">=</span> <span class="keyword5">Counter.</span>touch <span class="keyword5">Counter.</span>empty</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-cyclic1/counter.ml">files-modules-and-programs-freq-cyclic1/counter.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295564480">we'll see this error when we try to build:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild freq.byte
</div><div class="rwocodeout">File &quot;counter.ml&quot;, line 18, characters 18-31:</div><div class="rwocodeout">Error: Unbound module Counter</div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-cyclic1/build.out">files-modules-and-programs-freq-cyclic1/build.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295558944">The problem manifests in a different way if we create cyclic
      references between files. We could create such a situation by adding a
      reference to <code>Freq</code> from <code>counter.ml</code>, e.g., by adding the following
      line:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> _build_counts <span class="keyword2">=</span> <span class="keyword5">Freq.</span>build_counts</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-cyclic2/counter.ml">files-modules-and-programs-freq-cyclic2/counter.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146295554640">In this case, <span><strong>ocamlbuild</strong></span> (which
      is invoked by the <span><strong>corebuild</strong></span> script)
      will notice the error and complain explicitly about the cycle:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild freq.byte
</div><div class="rwocodeout">Circular dependencies: &quot;freq.cmo&quot; already seen in</div><div class="rwocodeout">  [ &quot;counter.cmo&quot;; &quot;freq.cmo&quot; ]</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-cyclic2/build.out">files-modules-and-programs-freq-cyclic2/build.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section></section><section id="idm146295547488"><h1>Designing with Modules</h1><p id="idm146295546816">The module system is a key part of how an OCaml program is structured. As such, we'll
      close this chapter with some advice on how to think about designing that structure
      effectively.</p><section id="idm146295546224"><h1>Expose Concrete Types Rarely</h1><p id="idm146295545552">When designing an <code>mli</code>, one choice that you need to make is whether to
        expose the concrete definition of your types or leave them abstract. Most of the time,
        abstraction is the right choice, for two reasons: it enhances the flexibility of your
        design, and it makes it possible to enforce invariants on the use of your module.</p><p id="idm146295544416">Abstraction enhances flexibility by restricting how users can interact with your types,
        thus reducing the ways in which users can depend on the details of your implementation. If
        you expose types explicitly, then users can depend on any and every detail of the types you
        choose. If they're abstract, then only the specific operations you want to expose are
        available. This means that you can freely change the implementation without affecting
        clients, as long as you preserve the semantics of those operations.</p><p id="idm146295543472">In a similar way, abstraction allows you to enforce invariants on your types. If your
        types are exposed, then users of the module can create new instances of that type (or if
        mutable, modify existing instances) in any way allowed by the underlying type. That may
        violate a desired invariant <span><em>i.e.</em></span>, a property about your type that is
        always supposed to be true. Abstract types allow you to protect invariants by making sure
        that you only expose functions that preserves your invariants. </p><p id="idm146295542160">Despite these benefits, there is a trade-off here. In particular, exposing types
        concretely makes it possible to use pattern-matching with those types, which as we saw in
        <span><a href="lists-and-patterns.html">Chapter 3, <i>Lists and Patterns</i></a> </span>is a powerful and important tool. You should generally only
        expose the concrete implementation of your types when there's significant value in the
        ability to pattern match, and when the invariants that you care about are already enforced
        by the data type itself.</p></section><section id="idm146295540160"><h1>Design for the Call Site</h1><p id="idm146295539488">When writing an interface, you should think not just about how easy it is to understand
        the interface for someone who reads your carefully documented <code>mli</code> file,
        but more importantly, you want the call to be as obvious as possible for someone who is
        reading it at the call site.</p><p id="idm146295538416">The reason for this is that most of the time, people interacting with your API will be
        doing so by reading and modifying code that uses the API, not by reading the interface
        definition. By making your API as obvious as possible from that perspective, you simplify
        the lives of your users.</p><p id="idm146295537712">There are many ways of improving readability at the call site. One example is labeled
        arguments (discussed in <a href="variables-and-functions.html#labeled-arguments">the section called “Labeled Arguments”</a>), which act as documentation
        that is available at the call site. </p><p id="idm146295536608">You can also improve readability simply by choosing good names for your functions,
        variant tags and record fields. Good names aren't always long, to be clear. If you wanted to
        write an anonymous function for doubling a number: <code>(fun x -&gt; x * 2)</code>, a
        short variable name like <code>x</code> is best. A good rule of thumb is that names
        that have a small scope should be short, whereas names that have a large scope, like the
        name of a function in an a module interface, should be longer and more explicit.</p><p id="idm146295534864">There is of course a tradeoff here, in that making your APIs more explicit tends to make
        them more verbose as well. Another useful rule of thumb is that more rarely used names
        should be longer and more explicit, since the cost of concision and the benefit of
        explicitness become more important the more often a name is used.</p></section><section id="idm146295534000"><h1>Create Uniform Interfaces</h1><p id="idm146295533328">Designing the interface of a module is a task that should not be thought of in
        isolation. The interfaces that appear in your codebase should play together harmoniously.
        Part of achieving that is standardizing aspects of those interfaces.</p><p id="idm146295532688">Core itself is a library that works hard to create uniform interfaces. Here are some of
        the guidelines that are used in Core.</p><ul><li><p id="idm146295531648"><span><em>A module for (almost) every type.</em></span> You should mint a module for
            almost every type in your program, and the primary type of a given module should be
            called <code>t</code>.</p></li><li><p id="idm146295530160"><span><em>Put <code>t</code> first</em></span>. If you have a module <code>M</code>
            whose primary type is <code>M.t</code>, the functions in <code>M</code> that
            take a value of <code>M.t</code> should take it as their first argument.</p></li><li><p id="idm146295527216">Functions that routinely throw an exception should end in <code>_exn</code>. Otherwise,
            errors should be signaled by returning an <code>option</code> or an
          <code>Or_error.t</code> (both of which are discussed in <a href="error-handling.html">Chapter 7, <i>Error Handling</i></a> ).</p></li></ul><p id="idm146295524752">There are also standards in Core about what the type signature for specific functions
        should be. For example, the signature for <code>map</code> is always essentially the
        same, no matter what the underlying type it is applied to. This kind of function-by-function
        API uniformity is achieved through the use of <span><em>signature includes</em></span>, which
        allow for different modules to share components of their interface. This approach is
        described in <a href="functors.html#using-multiple-interfaces">the section called “Using Multiple Interfaces”</a>. </p><p id="idm146295522592">Core's standards may or may not fit your projects, but you can improve the usability of
        your codebase by finding some consistent set of standards to apply.</p></section><section id="idm146295521904"><h1>Interfaces before implementations</h1><p id="idm146295521216">OCaml's concise and flexible type language enables a type-oriented
        approach to software design.  Such an approach involves thinking
        through and writing out the types you're going to use before embarking
        on the implementation itself.</p><p id="idm146295520560">This is a good approach both when working in the core language, where you would write
        your type definitions before writing the logic of your computations, as well as at the
        module level, where you would write a first draft of your <code>mli</code> before
        working on the <code>ml</code>.</p><p id="idm146295519120">Of course, the design process goes in both directions. You'll often find yourself going
        back and modifying your types in response to things you learn by working on the
        implementation. But types and signatures provide a lightweight tool for constructing a
        skeleton of your design in a way that helps clarify your goals and intent, before you spend
        a lot of time and effort fleshing it out.</p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="lists-and-patterns.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="records.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>
