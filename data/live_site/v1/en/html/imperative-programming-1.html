<html>

    <head>
    
        <meta charset="utf-8"></meta>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"></meta>
        
        <title>Chapter 8. Imperative Programming / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"></link>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'realworldocaml',
                        repo: 'book',
                        milestone: 'v1',
                        page: 'imperative\u002Dprogramming\u002D1.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">4. Files, Modules, and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html" class="here">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">10. First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="objects.html">11. Objects</a>
                                            </li>
                                        
                                            <li>
                                                <a href="classes.html">12. Classes</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="ix01.html">Index</a>
                            
                        </li>
                    
                </ul>
            </nav>
            <header class="header">
                <h1><a href="http://oreil.ly/realworldOCaml"><img src="../../media/img/cover.png" width="120" alt="Real World OCaml, by Yaron Minsky, Anil Madhavapeddy and Jason Hickey"></img></a></h1>
                <p><i>Buy in <a href="http://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/">print</a> and <a href="http://oreil.ly/realworldOCaml">eBook.</a></i></p>
            </header>
        
            <article class="page">
        
                <h1>Chapter 8. Imperative Programming</h1>
                
                

    <p id="idm146293883152">Most of the code shown so far in this book, and indeed, most OCaml
  code in general, is <span><em>pure</em></span>. Pure code works without
  mutating the program's internal state, performing I/O, reading the clock, or
  in any other way interacting with changeable parts of the world. Thus, a
  pure function behaves like a mathematical function, always returning the
  same results when given the same inputs, and never affecting the world
  except insofar as it returns the value of its computation.
  <span><em>Imperative</em></span> code, on the other hand, operates by side
  effects that modify a program's internal state or interact with the outside
  world. An imperative function has a new effect, and potentially returns
  different results, every time it's called.<a name="idm146293881360"></a><a name="idm146293880048"></a><a name="idm146293879152"></a><a name="PROGimper"></a></p><p id="idm146293876160">Pure code is the default in OCaml, and for good reason—it's generally
  easier to reason about, less error prone and more composable. But imperative
  code is of fundamental importance to any practical programming language,
  because real-world tasks require that you interact with the outside world,
  which is by its nature imperative. Imperative programming can also be
  important for performance. While pure code is quite efficient in OCaml,
  there are many algorithms that can only be implemented efficiently using
  imperative techniques.</p><p id="idm146293874992">OCaml offers a happy compromise here, making it easy and natural to
  program in a pure style, but also providing great support for imperative
  programming. This chapter will walk you through OCaml's imperative features,
  and help you use them to their fullest.</p><section id="example-imperative-dictionaries"><h1>Example: Imperative Dictionaries</h1><p id="idm146293873392">We'll start with the implementation of a simple imperative
    dictionary, i.e., a mutable mapping from keys to values. This is really
    for illustration purposes; both Core and the standard library provide
    imperative dictionaries, and for most real-world tasks, you should use one
    of those implementations. There's more advice on using Core's
    implementation in particular in <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a>.<a name="DICTimper"></a><a name="idm146293871072"></a><a name="IPimpdict"></a></p><p id="idm146293868048">The dictionary we'll describe now, like those in Core and the
    standard library, will be implemented as a hash table. In particular,
    we'll use an <span><em>open hashing</em></span> scheme, where the hash
    table will be an array of buckets, each bucket containing a list of
    key/value pairs that have been hashed into that bucket.<a name="idm146293867072"></a></p><p id="idm146293866048">Here's the interface we'll match, provided as an <code>mli</code>. The type <code>('a, 'b)
    t</code> represents a dictionary with keys of type <code>'a</code> and data of type <code>'b</code>:</p><div class="rwocode"><pre><code><span class="comments">(* file: dictionary.mli *)</span>
<span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> <span class="keyword2">(</span>'a, 'b<span class="keyword2">)</span> t

<span class="keyword4">val</span> create <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>'a, 'b<span class="keyword2">)</span> t
<span class="keyword4">val</span> length <span class="keyword2">:</span> <span class="keyword2">(</span>'a, 'b<span class="keyword2">)</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span>
<span class="keyword4">val</span> add    <span class="keyword2">:</span> <span class="keyword2">(</span>'a, 'b<span class="keyword2">)</span> t -<span class="keyword2">&gt;</span> key<span class="keyword2">:</span>'a -<span class="keyword2">&gt;</span> data<span class="keyword2">:</span>'b -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> find   <span class="keyword2">:</span> <span class="keyword2">(</span>'a, 'b<span class="keyword2">)</span> t -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> 'b option
<span class="keyword4">val</span> iter   <span class="keyword2">:</span> <span class="keyword2">(</span>'a, 'b<span class="keyword2">)</span> t -<span class="keyword2">&gt;</span> f<span class="keyword2">:</span><span class="keyword2">(</span>key<span class="keyword2">:</span>'a -<span class="keyword2">&gt;</span> data<span class="keyword2">:</span>'b -<span class="keyword2">&gt;</span> unit<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> remove <span class="keyword2">:</span> <span class="keyword2">(</span>'a, 'b<span class="keyword2">)</span> t -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> unit</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dictionary.mli">imperative-programming/dictionary.mli</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293860112">The <code>mli</code> also includes a
    collection of helper functions whose purpose and behavior should be
    largely inferrable from their names and type signatures. Notice that a
    number of the functions, in particular, ones like <code>add</code> that modify the dictionary, return
    <code>unit</code>. This is typical of functions that act by side
    effect.</p><p id="idm146293857792">We'll now walk through the implementation (contained in the
    corresponding <code>ml</code> file) piece by piece,
    explaining different imperative constructs as they come up.</p><p id="idm146293856624">Our first step is to define the type of a dictionary as a record
    with two fields:</p><div class="rwocode"><pre><code><span class="comments">(* file: dictionary.ml *)</span>
<span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> <span class="keyword2">(</span>'a, 'b<span class="keyword2">)</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> <span class="keyword1">mutable</span> length<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
                    buckets<span class="keyword2">:</span> <span class="keyword2">(</span>'a <span class="keyword2">*</span> 'b<span class="keyword2">)</span> <span class="keyword3">list</span> <span class="keyword3">array</span><span class="keyword2">;</span>
                  <span class="keyword2">}</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dictionary.ml">imperative-programming/dictionary.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293853792">The first field, <code>length</code>, is
    declared as mutable. In OCaml, records are immutable by default, but
    individual fields are mutable when marked as such. The second field,
    <code>buckets</code>, is immutable but contains an
    array, which is itself a mutable data structure.<a name="idm146293851968"></a></p><p id="idm146293850544">Now we'll start putting together the basic functions for
    manipulating a dictionary:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> num_buckets <span class="keyword2">=</span> <span class="keyword8">17</span>

<span class="keyword4">let</span> hash_bucket key <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword5">Hashtbl.</span>hash key<span class="keyword2">)</span> <span class="keyword2">mod</span> num_buckets

<span class="keyword4">let</span> create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword2">{</span> length <span class="keyword2">=</span> <span class="keyword8">0</span><span class="keyword2">;</span>
    buckets <span class="keyword2">=</span> <span class="keyword5">Array.</span>create ~len<span class="keyword2">:</span>num_buckets <span class="keyword2">[</span><span class="keyword2">]</span><span class="keyword2">;</span>
  <span class="keyword2">}</span>

<span class="keyword4">let</span> length t <span class="keyword2">=</span> t.length

<span class="keyword4">let</span> find t key <span class="keyword2">=</span>
  <span class="keyword5">List.</span>find_map t.buckets.<span class="keyword2">(</span>hash_bucket key<span class="keyword2">)</span>
    ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>key',data<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword1">if</span> key' <span class="keyword2">=</span> key <span class="keyword1">then</span> <span class="keyword6">Some </span>data <span class="keyword1">else</span> None<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dictionary.ml">imperative-programming/dictionary.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293847712">Note that <code>num_buckets</code> is a
    constant, which means our bucket array is of fixed length. A practical
    implementation would need to be able to grow the array as the number of
    elements in the dictionary increases, but we'll omit this to simplify the
    presentation.</p><p id="idm146293845856">The function <code>hash_bucket</code> is used
    throughout the rest of the module to choose the position in the array that
    a given key should be stored at. It is implemented on top of <code>Hashtbl.hash</code>, which is a hash function provided
    by the OCaml runtime that can be applied to values of any type. Thus, its
    own type is polymorphic: <code>'a -&gt;
    int</code>.</p><p id="idm146293843184">The other functions defined above are fairly straightforward:</p><div><dl><dt><span><code>create</code></span></dt><dd><p id="idm146293841216">Creates an empty dictionary.</p></dd><dt><span><code>length</code></span></dt><dd><p id="idm146293839264">Grabs the length from the corresponding record field, thus
          returning the number of entries stored in the dictionary.</p></dd><dt><span><code>find</code></span></dt><dd><p id="idm146293837216">Looks for a matching key in the table and returns the
          corresponding value if found as an option.</p></dd></dl></div><p id="idm146293836336">Another important piece of imperative syntax shows up in <code>find</code>: we write <code>array.(index)</code> to grab a value from an array.
    <code>find</code> also uses <code>List.find_map</code>, which you can see the type of by
    typing it into the toplevel:</p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>find_map<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a list -&gt; f:('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/examples.topscript">imperative-programming/examples.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293829152"><code>List.find_map</code> iterates over the
    elements of the list, calling <code>f</code> on each
    one until a <code>Some</code> is returned by
    <code>f</code>, at which point that value is
    returned. If <code>f</code> returns <code>None</code> on all values, then <code>None</code> is returned.</p><p id="idm146293824256">Now let's look at the implementation of <code>iter</code>:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> iter t ~f <span class="keyword2">=</span>
  <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">to</span> <span class="keyword5">Array.</span>length t.buckets - <span class="keyword8">1</span> <span class="keyword1">do</span>
    <span class="keyword5">List.</span>iter t.buckets.<span class="keyword2">(</span>i<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>key, data<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> f ~key ~data<span class="keyword2">)</span>
  <span class="keyword1">done</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dictionary.ml">imperative-programming/dictionary.ml</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293820496"><code>iter</code> is designed to walk over all
    the entries in the dictionary. In particular, <code>iter t ~f</code> will call <code>f</code> for each key/value pair in dictionary <code>t</code>. Note that <code>f</code> must return <code>unit</code>, since it is expected to work by side
    effect rather than by returning a value, and the overall <code>iter</code> function returns <code>unit</code> as well.</p><p id="idm146293814928">The code for <code>iter</code> uses two forms of iteration: a
        <code>for</code> loop to walk over the array of buckets; and within
      that loop a call to <code>List.iter</code> to walk over the values in a
      given bucket. We could have done the outer loop with a recursive function instead of a
        <code>for</code> loop, but <code>for</code>
      loops are syntactically convenient, and are more familiar and idiomatic in imperative
      contexts.</p><p id="idm146293810976">The following code is for adding and removing mappings from the
    dictionary:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> bucket_has_key t i key <span class="keyword2">=</span>
  <span class="keyword5">List.</span>exists t.buckets.<span class="keyword2">(</span>i<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>key',<span class="keyword8">_</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> key' <span class="keyword2">=</span> key<span class="keyword2">)</span>

<span class="keyword4">let</span> add t ~key ~data <span class="keyword2">=</span>
  <span class="keyword4">let</span> i <span class="keyword2">=</span> hash_bucket key <span class="keyword4">in</span>
  <span class="keyword4">let</span> replace <span class="keyword2">=</span> bucket_has_key t i key <span class="keyword4">in</span>
  <span class="keyword4">let</span> filtered_bucket <span class="keyword2">=</span>
    <span class="keyword1">if</span> replace <span class="keyword1">then</span>
      <span class="keyword5">List.</span>filter t.buckets.<span class="keyword2">(</span>i<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>key',<span class="keyword8">_</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> key' <span class="keyword2">&lt;</span><span class="keyword2">&gt;</span> key<span class="keyword2">)</span>
    <span class="keyword1">else</span>
      t.buckets.<span class="keyword2">(</span>i<span class="keyword2">)</span>
  <span class="keyword4">in</span>
  t.buckets.<span class="keyword2">(</span>i<span class="keyword2">)</span> <span class="keyword2">&lt;</span>- <span class="keyword2">(</span>key, data<span class="keyword2">)</span> <span class="keyword2">:</span><span class="keyword2">:</span> filtered_bucket<span class="keyword2">;</span>
  <span class="keyword1">if</span> not replace <span class="keyword1">then</span> t.length <span class="keyword2">&lt;</span>- t.length <span class="keyword2">+</span> <span class="keyword8">1</span>

<span class="keyword4">let</span> remove t key <span class="keyword2">=</span>
  <span class="keyword4">let</span> i <span class="keyword2">=</span> hash_bucket key <span class="keyword4">in</span>
  <span class="keyword1">if</span> bucket_has_key t i key <span class="keyword1">then</span> <span class="keyword2">(</span>
    <span class="keyword4">let</span> filtered_bucket <span class="keyword2">=</span>
      <span class="keyword5">List.</span>filter t.buckets.<span class="keyword2">(</span>i<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>key',<span class="keyword8">_</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> key' <span class="keyword2">&lt;</span><span class="keyword2">&gt;</span> key<span class="keyword2">)</span>
    <span class="keyword4">in</span>
    t.buckets.<span class="keyword2">(</span>i<span class="keyword2">)</span> <span class="keyword2">&lt;</span>- filtered_bucket<span class="keyword2">;</span>
    t.length <span class="keyword2">&lt;</span>- t.length - <span class="keyword8">1</span>
  <span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dictionary.ml">imperative-programming/dictionary.ml</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293807200">This preceding code is made more complicated by the fact that we
    need to detect whether we are overwriting or removing an existing binding,
    so we can decide whether <code>t.length</code> needs
    to be changed. The helper function <code>bucket_has_key</code> is used for this purpose.</p><p id="idm146293805360">Another piece of syntax shows up in both <code>add</code> and <code>remove</code>: the use of the <code>&lt;-</code> operator to update elements of an array
    (<code>array.(i) &lt;- expr</code>) and for updating
    a record field (<code>record.field &lt;-
    expression</code>).</p><p id="idm146293801632">We also use <code>;</code>, the sequencing
    operator, to express a sequence of imperative actions. We could have done
    the same using <code>let</code> bindings:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> t.buckets.<span class="keyword2">(</span>i<span class="keyword2">)</span> <span class="keyword2">&lt;</span>- <span class="keyword2">(</span>key, data<span class="keyword2">)</span> <span class="keyword2">:</span><span class="keyword2">:</span> filtered_bucket <span class="keyword4">in</span>
  <span class="keyword1">if</span> not replace <span class="keyword1">then</span> t.length <span class="keyword2">&lt;</span>- t.length <span class="keyword2">+</span> <span class="keyword8">1</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dictionary2.ml">imperative-programming/dictionary2.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293797424">but <code>;</code> is more concise and
    idiomatic. More generally,</p><div class="rwocode"><pre><code><pre>&lt;expr1&gt;;
&lt;expr2&gt;;
...
&lt;exprN&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/semicolon.syntax">imperative-programming/semicolon.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293794400">is equivalent to</p><div class="rwocode"><pre><code><pre>let () = &lt;expr1&gt; in
let () = &lt;expr2&gt; in
...
&lt;exprN&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/let-unit.syntax">imperative-programming/let-unit.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293791904">When a sequence expression <code>expr1;
    expr2</code> is evaluated, <code>expr1</code> is
    evaluated first, and then <code>expr2</code>. The
    expression <code>expr1</code> should have type
    <code>unit</code> (though this is a warning rather
    than a hard restriction. The <code>-strict-sequence</code> compiler flag makes this a hard
    restriction, which is generally a good idea), and the value of <code>expr2</code> is returned as the value of the entire
    sequence. For example, the sequence <code>print_string
    &quot;hello world&quot;; 1 + 2</code> first prints the string <code>&quot;hello world&quot;</code>, then returns the integer <code>3</code>.</p><p id="idm146293784608">Note also that we do all of the side-effecting operations at the
    very end of each function. This is good practice because it minimizes the
    chance that such operations will be interrupted with an exception, leaving
    the data structure in an inconsistent state.<a name="idm146293784080"></a><a name="idm146293783472"></a></p></section><section id="primitive-mutable-data"><h1>Primitive Mutable Data</h1><p id="idm146293781680">Now that we've looked at a complete example, let's take a more
    systematic look at imperative programming in OCaml. We encountered two
    different forms of mutable data above: records with mutable fields and
    arrays. We'll now discuss these in more detail, along with the other
    primitive forms of mutable data that are available in OCaml.<a name="idm146293781072"></a><a name="idm146293780176"></a><a name="idm146293778864"></a><a name="idm146293777968"></a><a name="idm146293776656"></a></p><section id="array-like-data"><h1>Array-Like Data</h1><p id="idm146293774304">OCaml supports a number of array-like data structures; i.e.,
      mutable integer-indexed containers that provide constant-time access to
      their elements. We'll discuss several of them in this section.</p><section id="ordinary-arrays"><h1>Ordinary arrays</h1><p id="idm146293772816">The <code>array</code> type is used for
        general-purpose polymorphic arrays. The <code>Array</code> module has a variety of utility
        functions for interacting with arrays, including a number of mutating
        operations. These include <code>Array.set</code>, for setting an individual
        element, and <code>Array.blit</code>, for
        efficiently copying values from one range of indices to
        another.<a name="idm146293769584"></a><a name="idm146293768272"></a><a name="idm146293766960"></a><a name="idm146293765664"></a></p><p id="idm146293764240">Arrays also come with special syntax for retrieving an element
        from an array:</p><div class="rwocode"><pre><code><pre>&lt;array_expr&gt;.(&lt;index_expr&gt;)
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/array-get.syntax">imperative-programming/array-get.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293760832">and for setting an element in an array:</p><div class="rwocode"><pre><code><pre>&lt;array_expr&gt;.(&lt;index_expr&gt;) &lt;- &lt;value_expr&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/array-set.syntax">imperative-programming/array-set.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293757184">Out-of-bounds accesses for arrays (and indeed for all the
        array-like data structures) will lead to an exception being
        thrown.</p><p id="idm146293756656">Array literals are written using <code>[|</code> and <code>|]</code>
        as delimiters. Thus, <code>[| 1; 2; 3 |]</code>
        is a literal integer array.</p></section><section id="strings"><h1>Strings</h1><p id="idm146293753232">Strings are essentially byte arrays which are often used for
        textual data. The main advantage of using a <code>string</code> in place of a <code>Char.t array</code> (a <code>Char.t</code> is an 8-bit character) is that the
        former is considerably more space-efficient; an array uses one word—8
        bytes on a 64-bit machine—to store a single entry, whereas strings use
        1 byte per character.<a name="idm146293750320"></a><a name="idm146293749424"></a></p><p id="idm146293747984">Strings also come with their own syntax for getting and setting
        values:</p><div class="rwocode"><pre><code><pre>&lt;string_expr&gt;.[&lt;index_expr&gt;]
&lt;string_expr&gt;.[&lt;index_expr&gt;] &lt;- &lt;char_expr&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/string.syntax">imperative-programming/string.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293743552">And string literals are bounded by quotes. There's also a module
        <code>String</code> where you'll find useful
        functions for working with strings.</p></section><section id="bigarrays"><h1>Bigarrays</h1><p id="idm146293741360">A <code>Bigarray.t</code> is a handle to a
        block of memory stored outside of the OCaml heap. These are mostly
        useful for interacting with C or Fortran libraries, and are discussed
        in <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a>. Bigarrays too
        have their own getting and setting syntax:<a name="idm146293739680"></a></p><div class="rwocode"><pre><code><pre>&lt;bigarray_expr&gt;.{&lt;index_expr&gt;}
&lt;bigarray_expr&gt;.{&lt;index_expr&gt;} &lt;- &lt;value_expr&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/bigarray.syntax">imperative-programming/bigarray.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section></section><section id="mutable-record-and-object-fields-and-ref-cells"><h1>Mutable Record and Object Fields and Ref Cells</h1><p id="idm146293733344">As we've seen, records are immutable by default, but individual
      record fields can be declared as mutable. These mutable fields can be
      set using the <code>&lt;-</code> operator, i.e.,
      <code>record.field &lt;- expr</code>.<a name="idm146293731584"></a></p><p id="idm146293730176">As we'll see in <a href="objects.html">Chapter 11, <i>Objects</i></a>, fields of an object
      can similarly be declared as mutable, and can then be modified in much
      the same way as record fields.<a name="idm146293729248"></a></p><section id="ref-cells"><h1>Ref cells</h1><p id="idm146293726880">Variables in OCaml are never mutable—they can refer to mutable
        data, but what the variable points to can't be changed. Sometimes,
        though, you want to do exactly what you would do with a mutable
        variable in another language: define a single, mutable value. In OCaml
        this is typically achieved using a <code>ref</code>, which is essentially a container with a
        single mutable polymorphic field.<a name="idm146293725184"></a></p><p id="idm146293724160">The definition for the <code>ref</code> type is as
        follows:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> 'a ref <span class="keyword2">=</span> <span class="keyword2">{</span> <span class="keyword1">mutable</span> contents <span class="keyword2">:</span> 'a <span class="keyword2">}</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type 'a ref = { mutable contents : 'a; }
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/ref.topscript">imperative-programming/ref.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293719424">The standard library defines the following operators for working
        with <code>ref</code>s.</p><div><dl><dt><span><code>ref expr</code></span></dt><dd><p id="idm146293717008">Constructs a reference cell containing the value defined
              by the expression <code>expr</code>.</p></dd><dt><span><code>!refcell</code></span></dt><dd><p id="idm146293714352">Returns the contents of the reference cell.</p></dd><dt><span><code>refcell := expr</code></span></dt><dd><p id="idm146293712384">Replaces the contents of the reference cell.</p></dd></dl></div><p id="idm146293711568">You can see these in action:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> x <span class="keyword2">=</span> ref <span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val x : int ref = {contents = 1}
</div>#   <span class="keyword2">!</span>x<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 1
</div>#   x <span class="keyword2">:</span><span class="keyword2">=</span> <span class="keyword2">!</span>x <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div>#   <span class="keyword2">!</span>x<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 2
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/ref.topscript">imperative-programming/ref.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293701904">The preceding are just ordinary OCaml functions, which could be
        defined as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> ref x <span class="keyword2">=</span> <span class="keyword2">{</span> contents <span class="keyword2">=</span> x <span class="keyword2">}</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ref : 'a -&gt; 'a ref = &lt;fun&gt;
</div>#   <span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">!</span><span class="keyword2">)</span> r <span class="keyword2">=</span> r.contents<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;
</div>#   <span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">:</span><span class="keyword2">=</span><span class="keyword2">)</span> r x <span class="keyword2">=</span> r.contents <span class="keyword2">&lt;</span>- x<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/ref.topscript">imperative-programming/ref.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section></section><section id="foreign-functions"><h1>Foreign Functions</h1><p id="idm146293692640">Another source of imperative operations in OCaml is resources that come from interfacing
        with external libraries through OCaml's foreign function interface (FFI). The FFI opens
        OCaml up to imperative constructs that are exported by system calls or other external
        libraries. Many of these come built in, like access to the <code>write</code> system call or to the <code>clock</code>, while
        others come from user libraries, like LAPACK bindings. OCaml's FFI is discussed in more
        detail in <a href="foreign-function-interface.html">Chapter 19, <i>Foreign Function Interface</i></a>.<a name="idm146293690080"></a><a name="idm146293688768"></a><a name="idm146293687440"></a><a name="idm146293686544"></a><a name="idm146293685200"></a></p></section></section><section id="for-and-while-loops-1"><h1>for and while Loops</h1><p id="idm146293682560">OCaml provides support for traditional imperative looping
    constructs, in particular, <code>for</code> and
    <code>while</code> loops. Neither of these
    constructs is strictly necessary, since they can be simulated with
    recursive functions. Nonetheless, explicit <code>for</code> and <code>while</code>
    loops are both more concise and more idiomatic when programming
    imperatively.<a name="idm146293679408"></a><a name="idm146293678496"></a><a name="idm146293677600"></a></p><p id="idm146293676576">The <code>for</code> loop is the simpler of
    the two. Indeed, we've already seen the <code>for</code> loop in action—the <code>iter</code> function in <code>Dictionary</code> is built using it. Here's a simple
    example of <code>for</code>:</p><div class="rwocode"><pre><code># <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">to</span> <span class="keyword8">3</span> <span class="keyword1">do</span> printf <span class="keyword7">&quot;i = %d\n&quot;</span> i <span class="keyword1">done</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>i = 0
i = 1
i = 2
i = 3
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/for.topscript">imperative-programming/for.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293666352">As you can see, the upper and lower bounds are inclusive. We can
    also use <code>downto</code> to iterate in the other
    direction:</p><div class="rwocode"><pre><code># <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">3</span> <span class="keyword1">downto</span> <span class="keyword8">0</span> <span class="keyword1">do</span> printf <span class="keyword7">&quot;i = %d\n&quot;</span> i <span class="keyword1">done</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>i = 3
i = 2
i = 1
i = 0
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/for.topscript">imperative-programming/for.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293658720">Note that the loop variable of a <code>for</code> loop, <code>i</code>
    in this case, is immutable in the scope of the loop and is also local to
    the loop, i.e., it can't be referenced outside of the loop.</p><p id="idm146293656880">OCaml also supports <code>while</code> loops,
    which include a condition and a body. The loop first evaluates the
    condition, and then, if it evaluates to true, evaluates the body and
    starts the loop again. Here's a simple example of a function for reversing
    an array in place:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> rev_inplace ar <span class="keyword2">=</span>
    <span class="keyword4">let</span> i <span class="keyword2">=</span> ref <span class="keyword8">0</span> <span class="keyword4">in</span>
    <span class="keyword4">let</span> j <span class="keyword2">=</span> ref <span class="keyword2">(</span><span class="keyword5">Array.</span>length ar - <span class="keyword8">1</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="comments">(* terminate when the upper and lower indices meet *)</span>
    <span class="keyword1">while</span> <span class="keyword2">!</span>i <span class="keyword2">&lt;</span> <span class="keyword2">!</span>j <span class="keyword1">do</span>
      <span class="comments">(* swap the two elements *)</span>
      <span class="keyword4">let</span> tmp <span class="keyword2">=</span> ar.<span class="keyword2">(</span><span class="keyword2">!</span>i<span class="keyword2">)</span> <span class="keyword4">in</span>
      ar.<span class="keyword2">(</span><span class="keyword2">!</span>i<span class="keyword2">)</span> <span class="keyword2">&lt;</span>- ar.<span class="keyword2">(</span><span class="keyword2">!</span>j<span class="keyword2">)</span><span class="keyword2">;</span>
      ar.<span class="keyword2">(</span><span class="keyword2">!</span>j<span class="keyword2">)</span> <span class="keyword2">&lt;</span>- tmp<span class="keyword2">;</span>
      <span class="comments">(* bump the indices *)</span>
      incr i<span class="keyword2">;</span>
      decr j
    <span class="keyword1">done</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val rev_inplace : 'a array -&gt; unit = &lt;fun&gt;
</div># <span class="keyword4">let</span> nums <span class="keyword2">=</span> <span class="keyword2">[|</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">|]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val nums : int array = [|1; 2; 3; 4; 5|]
</div># rev_inplace nums<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># nums<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int array = [|5; 4; 3; 2; 1|]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/for.topscript">imperative-programming/for.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293637680">In the preceding example, we used <code>incr</code> and <code>decr</code>, which are built-in functions for
    incrementing and decrementing an <code>int
    ref</code> by one, respectively.</p></section><section id="example-doubly-linked-lists"><h1>Example: Doubly Linked Lists</h1><p id="idm146293634144">Another common imperative data structure is the doubly linked list.
    Doubly linked lists can be traversed in both directions, and elements can
    be added and removed from the list in constant time. Core defines a doubly
    linked list (the module is called <code>Doubly_linked</code>), but we'll define our own linked
    list library as an illustration.<a name="idm146293632896"></a><a name="idm146293631584"></a><a name="IPdoublink"></a></p><p id="idm146293628976">Here's the <code>mli</code> of the module
    we'll build:</p><div class="rwocode"><pre><code><span class="comments">(* file: dlist.mli *)</span>
<span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> 'a t
<span class="keyword4">type</span> 'a element

<span class="comments">(** Basic list operations  *)</span>
<span class="keyword4">val</span> create   <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> 'a t
<span class="keyword4">val</span> is_empty <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> bool

<span class="comments">(** Navigation using [element]s *)</span>
<span class="keyword4">val</span> first <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a element option
<span class="keyword4">val</span> next  <span class="keyword2">:</span> 'a element -<span class="keyword2">&gt;</span> 'a element option
<span class="keyword4">val</span> prev  <span class="keyword2">:</span> 'a element -<span class="keyword2">&gt;</span> 'a element option
<span class="keyword4">val</span> value <span class="keyword2">:</span> 'a element -<span class="keyword2">&gt;</span> 'a

<span class="comments">(** Whole-data-structure iteration *)</span>
<span class="keyword4">val</span> iter    <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> f<span class="keyword2">:</span><span class="keyword2">(</span>'a -<span class="keyword2">&gt;</span> unit<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> find_el <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> f<span class="keyword2">:</span><span class="keyword2">(</span>'a -<span class="keyword2">&gt;</span> bool<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> 'a element option

<span class="comments">(** Mutation *)</span>
<span class="keyword4">val</span> insert_first <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> 'a element
<span class="keyword4">val</span> insert_after <span class="keyword2">:</span> 'a element -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> 'a element
<span class="keyword4">val</span> remove <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a element -<span class="keyword2">&gt;</span> unit</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dlist.mli">imperative-programming/dlist.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293625472">Note that there are two types defined here: <code>'a t</code>, the type of a list; and <code>'a element</code>, the type of an element. Elements act
    as pointers to the interior of a list and allow us to navigate the list
    and give us a point at which to apply mutating operations.</p><p id="idm146293623536">Now let's look at the implementation. We'll start by defining
    <code>'a element</code> and <code>'a t</code>:</p><div class="rwocode"><pre><code><span class="comments">(* file: dlist.ml *)</span>
<span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> 'a element <span class="keyword2">=</span>
  <span class="keyword2">{</span> value <span class="keyword2">:</span> 'a<span class="keyword2">;</span>
    <span class="keyword1">mutable</span> next <span class="keyword2">:</span> 'a element option<span class="keyword2">;</span>
    <span class="keyword1">mutable</span> prev <span class="keyword2">:</span> 'a element option
  <span class="keyword2">}</span>

<span class="keyword4">type</span> 'a t <span class="keyword2">=</span> 'a element option ref</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293619232">An <code>'a element</code> is a record
    containing the value to be stored in that node as well as optional (and
    mutable) fields pointing to the previous and next elements. At the
    beginning of the list, the <code>prev</code> field
    is <code>None</code>, and at the end of the list,
    the <code>next</code> field is <code>None</code>.</p><p id="idm146293615344">The type of the list itself, <code>'a
    t</code>, is a mutable reference to an optional <code>element</code>. This reference is <code>None</code> if the list is empty, and <code>Some</code> otherwise.</p><p id="idm146293612240">Now we can define a few basic functions that operate on lists and
    elements:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> ref <span class="keyword6">None
</span><span class="keyword4">let</span> is_empty t <span class="keyword2">=</span> <span class="keyword2">!</span>t <span class="keyword2">=</span> <span class="keyword6">None
</span>
<span class="keyword4">let</span> value elt <span class="keyword2">=</span> elt.value

<span class="keyword4">let</span> first t <span class="keyword2">=</span> <span class="keyword2">!</span>t
<span class="keyword4">let</span> next elt <span class="keyword2">=</span> elt.next
<span class="keyword4">let</span> prev elt <span class="keyword2">=</span> elt.prev</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293609264">These all follow relatively straightforwardly from our type
    definitions.</p><aside class="note"><h1>Cyclic Data Structures</h1><p id="idm146293608128">Doubly linked lists are a cyclic data structure, meaning that it
      is possible to follow a nontrivial sequence of pointers that closes in
      on itself. In general, building cyclic data structures requires the use
      of side effects. This is done by constructing the data elements first,
      and then adding cycles using assignment afterward.<a name="idm146293607504"></a><a name="idm146293606608"></a><a name="idm146293605312"></a></p><p id="idm146293604272">There is an exception to this, though: you can construct
      fixed-size cyclic data structures using <code>let
      rec</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> endless_loop <span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword8">2</span> <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword8">3</span> <span class="keyword2">:</span><span class="keyword2">:</span> endless_loop<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val endless_loop : int list =
  [1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;
   ...]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/examples.topscript">imperative-programming/examples.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293597824">This approach is quite limited, however. General-purpose cyclic
      data structures require mutation.</p></aside><section id="modifying-the-list"><h1>Modifying the List</h1><p id="idm146293596272">Now, we'll start considering operations that mutate the list,
      starting with <code>insert_first</code>, which
      inserts an element at the front of the list:<a name="idm146293595216"></a></p><div class="rwocode"><pre><code><span class="keyword4">let</span> insert_first t value <span class="keyword2">=</span>
  <span class="keyword4">let</span> new_elt <span class="keyword2">=</span> <span class="keyword2">{</span> prev <span class="keyword2">=</span> None<span class="keyword2">;</span> next <span class="keyword2">=</span> <span class="keyword2">!</span>t<span class="keyword2">;</span> value <span class="keyword2">}</span> <span class="keyword4">in</span>
  <span class="keyword4">begin</span> <span class="keyword1">match</span> <span class="keyword2">!</span>t <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Some </span>old_first -<span class="keyword2">&gt;</span> old_first.prev <span class="keyword2">&lt;</span>- <span class="keyword6">Some </span>new_elt
  <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span>
  t <span class="keyword2">:</span><span class="keyword2">=</span> <span class="keyword6">Some </span>new_elt<span class="keyword2">;</span>
  new_elt</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293625712"><code>insert_first</code> first defines a
      new element <code>new_elt</code>, and then links
      it into the list, finally setting the list itself to point to <code>new_elt</code>. Note that the precedence of a
      <code>match</code> expression is very low, so to
      separate it from the following assignment (<code>t :=
      Some new_elt</code>), we surround the match with <code>begin ... end</code>. We could have used parentheses
      for the same purpose. Without some kind of bracketing, the final
      assignment would incorrectly become part of the <code>None</code> case.<a name="idm146293586288"></a></p><p id="idm146293584864">We can use <code>insert_after</code> to
      insert elements later in the list. <code>insert_after</code> takes as arguments both an
      <code>element</code> after which to insert the new
      node and a value to insert:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> insert_after elt value <span class="keyword2">=</span>
  <span class="keyword4">let</span> new_elt <span class="keyword2">=</span> <span class="keyword2">{</span> value<span class="keyword2">;</span> prev <span class="keyword2">=</span> <span class="keyword6">Some </span>elt<span class="keyword2">;</span> next <span class="keyword2">=</span> elt.next <span class="keyword2">}</span> <span class="keyword4">in</span>
  <span class="keyword4">begin</span> <span class="keyword1">match</span> elt.next <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Some </span>old_next -<span class="keyword2">&gt;</span> old_next.prev <span class="keyword2">&lt;</span>- <span class="keyword6">Some </span>new_elt
  <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span>
  elt.next <span class="keyword2">&lt;</span>- <span class="keyword6">Some </span>new_elt<span class="keyword2">;</span>
  new_elt</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293579584">Finally, we need a <code>remove</code>
      function:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> remove t elt <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword2">{</span> prev<span class="keyword2">;</span> next<span class="keyword2">;</span> <span class="keyword8">_</span> <span class="keyword2">}</span> <span class="keyword2">=</span> elt <span class="keyword4">in</span>
  <span class="keyword4">begin</span> <span class="keyword1">match</span> prev <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Some </span>prev -<span class="keyword2">&gt;</span> prev.next <span class="keyword2">&lt;</span>- next
  <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> t <span class="keyword2">:</span><span class="keyword2">=</span> next
  <span class="keyword4">end</span><span class="keyword2">;</span>
  <span class="keyword4">begin</span> <span class="keyword1">match</span> next <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Some </span>next -<span class="keyword2">&gt;</span> next.prev <span class="keyword2">&lt;</span>- prev<span class="keyword2">;</span>
  <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span>
  elt.prev <span class="keyword2">&lt;</span>- None<span class="keyword2">;</span>
  elt.next <span class="keyword2">&lt;</span>- None</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293575584">Note that the preceding code is careful to change the <code>prev</code> pointer of the following element and the
      <code>next</code> pointer of the previous element,
      if they exist. If there's no previous element, then the list pointer
      itself is updated. In any case, the next and previous pointers of the
      element itself are set to <code>None</code>.</p><p id="idm146293573040">These functions are more fragile than they may seem. In
      particular, misuse of the interface may lead to corrupted data. For
      example, double-removing an element will cause the main list reference
      to be set to <code>None</code>, thus emptying the
      list. Similar problems arise from removing an element from a list it
      doesn't belong to.</p><p id="idm146293571648">This shouldn't be a big surprise. Complex imperative data
      structures can be quite tricky, considerably trickier than their pure
      equivalents. The issues described previously can be dealt with by more
      careful error detection, and such error correction is taken care of in
      modules like Core's <code>Doubly_linked</code>.
      You should use imperative data structures from a well-designed library
      when you can. And when you can't, you should make sure to put great care
      into your error handling.<a name="idm146293570432"></a><a name="idm146293569120"></a><a name="idm146293568208"></a></p></section><section id="iteration-functions"><h1>Iteration Functions</h1><p id="idm146293565456">When defining containers like lists, dictionaries, and trees,
      you'll typically want to define a set of iteration functions like
      <code>iter</code>, <code>map</code>, and <code>fold</code>, which let you concisely express common
      iteration patterns.<a name="idm146293563056"></a><a name="idm146293561744"></a></p><p id="idm146293560704"><code>Dlist</code> has two such iterators:
      <code>iter</code>, the goal of which is to call a
      <code>unit</code>-producing function on every
      element of the list, in order; and <code>find_el</code>, which runs a provided test function
      on each values stored in the list, returning the first <code>element</code> that passes the test. Both <code>iter</code> and <code>find_el</code> are implemented using simple recursive
      loops that use <code>next</code> to walk from
      element to element and <code>value</code> to
      extract the element from a given node:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> iter t ~f <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">rec</span> loop <span class="keyword2">=</span> <span class="keyword1">function</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span>
    <span class="keyword2">|</span> <span class="keyword6">Some </span>el -<span class="keyword2">&gt;</span> f <span class="keyword2">(</span>value el<span class="keyword2">)</span><span class="keyword2">;</span> loop <span class="keyword2">(</span>next el<span class="keyword2">)</span>
  <span class="keyword4">in</span>
  loop <span class="keyword2">!</span>t

<span class="keyword4">let</span> find_el t ~f <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">rec</span> loop <span class="keyword2">=</span> <span class="keyword1">function</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword6">None
</span>    <span class="keyword2">|</span> <span class="keyword6">Some </span>elt -<span class="keyword2">&gt;</span>
      <span class="keyword1">if</span> f <span class="keyword2">(</span>value elt<span class="keyword2">)</span> <span class="keyword1">then</span> <span class="keyword6">Some </span>elt
      <span class="keyword1">else</span> loop <span class="keyword2">(</span>next elt<span class="keyword2">)</span>
  <span class="keyword4">in</span>
  loop <span class="keyword2">!</span>t</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293551232">This completes our implementation, but there's still considerably
      more work to be done to make a really usable doubly linked list. As
      mentioned earlier, you're probably better off using something like
      Core's <code>Doubly_linked</code> module that has
      a more complete interface and has more of the tricky corner cases worked
      out. Nonetheless, this example should serve to demonstrate some of the
      techniques you can use to build nontrivial imperative data structure in
      OCaml, as well as some of the pitfalls.<a name="idm146293549824"></a></p></section></section><section id="laziness-and-other-benign-effects"><h1>Laziness and Other Benign Effects</h1><p id="idm146293547904">There are many instances where you basically want to program in a
    pure style, but you want to make limited use of side effects to improve
    the performance of your code. Such side effects are sometimes called
    <span><em>benign effects</em></span>, and they are a useful way of
    leveraging OCaml's imperative features while still maintaining most of the
    benefits of pure programming.<a name="idm146293546880"></a><a name="idm146293545984"></a><a name="idm146293545088"></a><a name="idm146293544192"></a><a name="idm146293542896"></a></p><p id="idm146293541440">One of the simplest benign effects is <span><em>laziness</em></span>.
    A lazy value is one that is not computed until it is actually needed. In
    OCaml, lazy values are created using the <code>lazy</code> keyword, which can be used to convert any
    expression of type <code>s</code> into a lazy value
    of type <code>s Lazy.t</code>. The evaluation of
    that expression is delayed until forced with <code>Lazy.force</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> v <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span>print_string <span class="keyword7">&quot;performing lazy computation\n&quot;</span><span class="keyword2">;</span> sqrt <span class="keyword8">16</span>.<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val v : float lazy_t = &lt;lazy&gt;
</div># <span class="keyword5">Lazy.</span>force v<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>performing lazy computation
- : float = 4.
</div># <span class="keyword5">Lazy.</span>force v<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : float = 4.
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293529664">You can see from the <code>print</code> statement that the
    actual computation was performed only once, and only after <code>force</code> had been called.</p><p id="idm146293511824">To better understand how laziness works, let's walk through the
    implementation of our own lazy type. We'll start by declaring types to
    represent a lazy value:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> 'a lazy_state <span class="keyword2">=</span>
    <span class="keyword2">|</span> <span class="keyword6">Delayed </span><span class="keyword2">of</span> <span class="keyword2">(</span>unit -<span class="keyword2">&gt;</span> 'a<span class="keyword2">)</span>
    <span class="keyword2">|</span> <span class="keyword6">Value </span><span class="keyword2">of</span> 'a
    <span class="keyword2">|</span> <span class="keyword6">Exn </span><span class="keyword2">of</span> exn
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type 'a lazy_state = Delayed of (unit -&gt; 'a) | Value of 'a | Exn of exn
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293504608">A <code>lazy_state</code> represents the
    possible states of a lazy value. A lazy value is <code>Delayed</code> before it has been run, where <code>Delayed</code> holds a function for computing the value
    in question. A lazy value is in the <code>Value</code> state when it has been forced and the
    computation ended normally. The <code>Exn</code>
    case is for when the lazy value has been forced, but the computation ended
    with an exception. A lazy value is simply a <code>ref</code> containing a <code>lazy_state</code>, where the <code>ref</code> makes it possible to change from being in
    the <code>Delayed</code> state to being in the
    <code>Value</code> or <code>Exn</code> states.</p><p id="idm146293496656">We can create a lazy value from a thunk, i.e., a function that takes
    a unit argument. Wrapping an expression in a thunk is another way to
    suspend the computation of an expression:<a name="idm146293496208"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> create_lazy f <span class="keyword2">=</span> ref <span class="keyword2">(</span><span class="keyword6">Delayed </span>f<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val create_lazy : (unit -&gt; 'a) -&gt; 'a lazy_state ref = &lt;fun&gt;
</div># <span class="keyword4">let</span> v <span class="keyword2">=</span> create_lazy
    <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> print_string <span class="keyword7">&quot;performing lazy computation\n&quot;</span><span class="keyword2">;</span> sqrt <span class="keyword8">16</span>.<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val v : float lazy_state ref = {contents = Delayed &lt;fun&gt;}
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293488400">Now we just need a way to force a lazy value. The following function
    does just that:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> force v <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword2">!</span>v <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Value </span>x -<span class="keyword2">&gt;</span> x
    <span class="keyword2">|</span> <span class="keyword6">Exn </span>e -<span class="keyword2">&gt;</span> <span class="keyword1">raise</span> e
    <span class="keyword2">|</span> <span class="keyword6">Delayed </span>f -<span class="keyword2">&gt;</span>
      <span class="keyword1">try</span>
        <span class="keyword4">let</span> x <span class="keyword2">=</span> f <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
        v <span class="keyword2">:</span><span class="keyword2">=</span> <span class="keyword6">Value </span>x<span class="keyword2">;</span>
        x
      <span class="keyword1">with</span> exn -<span class="keyword2">&gt;</span>
        v <span class="keyword2">:</span><span class="keyword2">=</span> <span class="keyword6">Exn </span>exn<span class="keyword2">;</span>
        <span class="keyword1">raise</span> exn
     <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val force : 'a lazy_state ref -&gt; 'a = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293476176">Which we can use in the same way we used <code>Lazy.force</code>:</p><div class="rwocode"><pre><code># force v<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>performing lazy computation
- : float = 4.
</div># force v<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : float = 4.
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293468832">The main user-visible difference between our implementation of
    laziness and the built-in version is syntax. Rather than writing <code>create_lazy (fun () -&gt; sqrt 16.)</code>, we can
    (with the built-in <code>lazy</code>) just write
    <code>lazy (sqrt 16.)</code>.</p><section id="memoization-and-dynamic-programming"><h1>Memoization and Dynamic Programming</h1><p id="idm146293465312">Another benign effect is <span><em>memoization</em></span>. A
      memoized function remembers the result of previous invocations of the
      function so that they can be returned without further computation when
      the same arguments are presented again.<a name="idm146293464416"></a><a name="BEmem"></a></p><p id="idm146293461456">Here's a function that takes as an argument an arbitrary
      single-argument function and returns a memoized version of that
      function. Here we'll use Core's <code>Hashtbl</code> module, rather than our toy <code>Dictionary</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> memoize f <span class="keyword2">=</span>
    <span class="keyword4">let</span> table <span class="keyword2">=</span> <span class="keyword5">Hashtbl.</span><span class="keyword5">Poly.</span>create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span>
      <span class="keyword1">match</span> <span class="keyword5">Hashtbl.</span>find table x <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">Some </span>y -<span class="keyword2">&gt;</span> y
      <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span>
        <span class="keyword4">let</span> y <span class="keyword2">=</span> f x <span class="keyword4">in</span>
        <span class="keyword5">Hashtbl.</span>add_exn table ~key<span class="keyword2">:</span>x ~data<span class="keyword2">:</span>y<span class="keyword2">;</span>
        y
    <span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val memoize : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293449616">The preceding code is a bit tricky. <code>memoize</code> takes as its argument a function
      <code>f</code> and then allocates a hash table
      (called <code>table</code>) and returns a new
      function as the memoized version of <code>f</code>. When called, this new function looks in
      <code>table</code> first, and if it fails to find
      a value, calls <code>f</code> and stashes the
      result in <code>table</code>. Note that <code>table</code> doesn't go out of scope as long as the
      function returned by <code>memoize</code> is in
      scope.<a name="idm146293443216"></a></p><p id="idm146293441776">Memoization can be useful whenever you have a function that is
      expensive to recompute and you don't mind caching old values
      indefinitely. One important caution: a memoized function by its nature
      leaks memory. As long as you hold on to the memoized function, you're
      holding every result it has returned thus far.</p><p id="idm146293441056">Memoization is also useful for efficiently implementing some recursive algorithms. One
        good example is the algorithm for computing the <span><em>edit distance</em></span> (also
        called the Levenshtein distance) between two strings. The edit distance is the number of
        single-character changes (including letter switches, insertions, and deletions) required to
          <span>convert</span> one string to the other. This kind of
        distance metric can be useful for a variety of approximate string-matching problems, like
          spellcheckers.<a name="idm146293439216"></a><a name="idm146293438320"></a><a name="idm146293437408"></a></p><p id="idm146293436384">Consider the following code for computing the edit distance.
      Understanding the algorithm isn't important here, but you should pay
      attention to the structure of the recursive calls:<a name="idm146293435920"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> edit_distance s t <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword5">String.</span>length s, <span class="keyword5">String.</span>length t <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">(</span><span class="keyword8">0</span>,x<span class="keyword2">)</span> <span class="keyword2">|</span> <span class="keyword2">(</span>x,<span class="keyword8">0</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> x
    <span class="keyword2">|</span> <span class="keyword2">(</span>len_s,len_t<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword4">let</span> s' <span class="keyword2">=</span> <span class="keyword5">String.</span>drop_suffix s <span class="keyword8">1</span> <span class="keyword4">in</span>
      <span class="keyword4">let</span> t' <span class="keyword2">=</span> <span class="keyword5">String.</span>drop_suffix t <span class="keyword8">1</span> <span class="keyword4">in</span>
      <span class="keyword4">let</span> cost_to_drop_both <span class="keyword2">=</span>
        <span class="keyword1">if</span> s.<span class="keyword2">[</span>len_s - <span class="keyword8">1</span><span class="keyword2">]</span> <span class="keyword2">=</span> t.<span class="keyword2">[</span>len_t - <span class="keyword8">1</span><span class="keyword2">]</span> <span class="keyword1">then</span> <span class="keyword8">0</span> <span class="keyword1">else</span> <span class="keyword8">1</span>
      <span class="keyword4">in</span>
      <span class="keyword5">List.</span>reduce_exn ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>min
        <span class="keyword2">[</span> edit_distance s' t  <span class="keyword2">+</span> <span class="keyword8">1</span>
        <span class="keyword2">;</span> edit_distance s  t' <span class="keyword2">+</span> <span class="keyword8">1</span>
        <span class="keyword2">;</span> edit_distance s' t' <span class="keyword2">+</span> cost_to_drop_both
        <span class="keyword2">]</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val edit_distance : string -&gt; string -&gt; int = &lt;fun&gt;
</div># edit_distance <span class="keyword7">&quot;OCaml&quot;</span> <span class="keyword7">&quot;ocaml&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 2
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293419440">The thing to note is that if you call <code>edit_distance &quot;OCaml&quot; &quot;ocaml&quot;</code>, then that will
      in turn dispatch the following calls:</p><div class="rwocode"><pre><code><pre>edit_distance &quot;OCam&quot; &quot;ocaml&quot;
edit_distance &quot;OCaml&quot; &quot;ocam&quot;
edit_distance &quot;OCam&quot; &quot;ocam&quot;
</pre></code></pre><div class="rwocodeinfo">Diagram ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/edit_distance.ascii">imperative-programming/edit_distance.ascii</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><div><div></div></div><p id="idm146293414816">And these calls will in turn dispatch other calls:</p><div class="rwocode"><pre><code><pre>edit_distance &quot;OCam&quot; &quot;ocaml&quot;
   edit_distance &quot;OCa&quot; &quot;ocaml&quot;
   edit_distance &quot;OCam&quot; &quot;ocam&quot;
   edit_distance &quot;OCa&quot; &quot;ocam&quot;
edit_distance &quot;OCaml&quot; &quot;ocam&quot;
   edit_distance &quot;OCam&quot; &quot;ocam&quot;
   edit_distance &quot;OCaml&quot; &quot;oca&quot;
   edit_distance &quot;OCam&quot; &quot;oca&quot;
edit_distance &quot;OCam&quot; &quot;ocam&quot;
   edit_distance &quot;OCa&quot; &quot;ocam&quot;
   edit_distance &quot;OCam&quot; &quot;oca&quot;
   edit_distance &quot;OCa&quot; &quot;oca&quot;
</pre></code></pre><div class="rwocodeinfo">Diagram ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/edit_distance2.ascii">imperative-programming/edit_distance2.ascii</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><div><div></div></div><p id="idm146293410896">As you can see, some of these calls are repeats. For example,
      there are two different calls to <code>edit_distance
      &quot;OCam&quot; &quot;oca&quot;</code>. The number of redundant calls grows
      exponentially with the size of the strings, meaning that our
      implementation of <code>edit_distance</code> is
      brutally slow for large strings. We can see this by writing a small
      timing function:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> time f <span class="keyword2">=</span>
    <span class="keyword4">let</span> start <span class="keyword2">=</span> <span class="keyword5">Time.</span>now <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword4">let</span> x <span class="keyword2">=</span> f <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword4">let</span> stop <span class="keyword2">=</span> <span class="keyword5">Time.</span>now <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    printf <span class="keyword7">&quot;Time: %s\n&quot;</span> <span class="keyword2">(</span><span class="keyword5">Time.</span><span class="keyword5">Span.</span>to_string <span class="keyword2">(</span><span class="keyword5">Time.</span>diff stop start<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
    x <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val time : (unit -&gt; 'a) -&gt; 'a = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293401584">And now we can use this to try out some examples:</p><div class="rwocode"><pre><code># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> edit_distance <span class="keyword7">&quot;OCaml&quot;</span> <span class="keyword7">&quot;ocaml&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 0.698805ms
- : int = 2
</div># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> edit_distance <span class="keyword7">&quot;OCaml 4.01&quot;</span> <span class="keyword7">&quot;ocaml 4.01&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 1.78467s
- : int = 2
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293393936">Just those few extra characters made it thousands of times
      slower!</p><p id="idm146293393472">Memoization would be a huge help here, but to fix the problem, we
      need to memoize the calls that <code>edit_distance</code> makes to itself. This technique
      is sometimes referred to as <span><em>dynamic programming</em></span>. To
      see how to do this, let's step away from <code>edit_distance</code> and instead consider a much
      simpler example: computing the <span><em>n</em></span>th element of the
      Fibonacci sequence. The Fibonacci sequence by definition starts out with
      two <code>1</code>s, with every subsequent element
      being the sum of the previous two. The classic recursive definition of
      Fibonacci is as follows:<a name="idm146293389952"></a><a name="idm146293388640"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> fib i <span class="keyword2">=</span>
    <span class="keyword1">if</span> i <span class="keyword2">&lt;</span><span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword1">then</span> <span class="keyword8">1</span> <span class="keyword1">else</span> fib <span class="keyword2">(</span>i - <span class="keyword8">1</span><span class="keyword2">)</span> <span class="keyword2">+</span> fib <span class="keyword2">(</span>i - <span class="keyword8">2</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fib : int -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293382880">This is, however, exponentially slow, for the same reason that
      <code>edit_distance</code> was slow: we end up
      making many redundant calls to <code>fib</code>.
      It shows up quite dramatically in the performance:</p><div class="rwocode"><pre><code># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> fib <span class="keyword8">20</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 0.379086ms
- : int = 10946
</div># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> fib <span class="keyword8">40</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 4.61983s
- : int = 165580141
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293374080">As you can see, <code>fib 40</code> takes
      thousands of times longer to compute than <code>fib
      20</code>.</p><p id="idm146293372320">So, how can we use memoization to make this faster? The tricky bit
      is that we need to insert the memoization before the recursive calls
      within <code>fib</code>. We can't just define
      <code>fib</code> in the ordinary way and memoize
      it after the fact and expect the first call to <code>fib</code> to be improved:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> fib <span class="keyword2">=</span> memoize fib<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fib : int -&gt; int = &lt;fun&gt;
</div># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> fib <span class="keyword8">40</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 4.90749s
- : int = 165580141
</div># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> fib <span class="keyword8">40</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 0.00286102ms
- : int = 165580141
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293360912">In order to make <code>fib</code> fast, our
      first step will be to rewrite <code>fib</code> in
      a way that unwinds the recursion. The following version expects as its
      first argument a function (called <code>fib</code>) that will be called in lieu of the usual
      recursive call:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> fib_norec fib i <span class="keyword2">=</span>
    <span class="keyword1">if</span> i <span class="keyword2">&lt;</span><span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword1">then</span> i
    <span class="keyword1">else</span> fib <span class="keyword2">(</span>i - <span class="keyword8">1</span><span class="keyword2">)</span> <span class="keyword2">+</span> fib <span class="keyword2">(</span>i - <span class="keyword8">2</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fib_norec : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293352976">We can now turn this back into an ordinary Fibonacci function by
      tying the recursive knot:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> fib i <span class="keyword2">=</span> fib_norec fib i<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fib : int -&gt; int = &lt;fun&gt;
</div># fib <span class="keyword8">20</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 6765
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293346848">We can even write a polymorphic function that we'll call <code>make_rec</code> that can tie the recursive knot for
      any function of this form:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> make_rec f_norec <span class="keyword2">=</span>
    <span class="keyword4">let</span> <span class="keyword4">rec</span> f x <span class="keyword2">=</span> f_norec f x <span class="keyword4">in</span>
    f
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val make_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
</div># <span class="keyword4">let</span> fib <span class="keyword2">=</span> make_rec fib_norec<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fib : int -&gt; int = &lt;fun&gt;
</div># fib <span class="keyword8">20</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 6765
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293336144">This is a pretty strange piece of code, and it may take a few moments of thought to
        figure out what's going on. Like <code>fib_norec</code>, the function
          <code>f_norec</code> passed into <code>make_rec</code> is a function that isn't recursive but takes as an argument a function
        that it will call. What <code>make_rec</code> does is to essentially
        feed <code>f_norec</code> to itself, thus making it a true recursive
        function.</p><p id="idm146293332160">This is clever enough, but all we've really done is find a new way
      to implement the same old slow Fibonacci function. To make it faster, we
      need a variant of <code>make_rec</code> that
      inserts memoization when it ties the recursive knot. We'll call that
      function <code>memo_rec</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> memo_rec f_norec x <span class="keyword2">=</span>
    <span class="keyword4">let</span> fref <span class="keyword2">=</span> ref <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> <span class="keyword1">assert</span> false<span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword4">let</span> f <span class="keyword2">=</span> memoize <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> f_norec <span class="keyword2">!</span>fref x<span class="keyword2">)</span> <span class="keyword4">in</span>
    fref <span class="keyword2">:</span><span class="keyword2">=</span> f<span class="keyword2">;</span>
    f x
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293322848">Note that <code>memo_rec</code> has the same
      signature as <code>make_rec</code>.</p><p id="idm146293321200">We're using the reference here as a way of tying the recursive
      knot without using a <code>let rec</code>, which
      for reasons we'll describe later wouldn't work here.</p><p id="idm146293320000">Using <code>memo_rec</code>, we can now
      build an efficient version of <code>fib</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> fib <span class="keyword2">=</span> memo_rec fib_norec<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fib : int -&gt; int = &lt;fun&gt;
</div># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> fib <span class="keyword8">40</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 0.0371933ms
- : int = 102334155
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293311888">And as you can see, the exponential time complexity is now
      gone.</p><p id="idm146293311424">The memory behavior here is important. If you look back at the
      definition of <code>memo_rec</code>, you'll see
      that the call <code>memo_rec fib_norec</code> does
      not trigger a call to <code>memoize</code>. Only
      when <code>fib</code> is called and thereby the
      final argument to <code>memo_rec</code> is
      presented does <code>memoize</code> get called.
      The result of that call falls out of scope when the <code>fib</code> call returns, and so calling <code>memo_rec</code> on a function does not create a
      memory leak—the memoization table is collected after the computation
      completes.</p><p id="idm146293305184">We can use <code>memo_rec</code> as part of
      a single declaration that makes this look like it's little more than a
      special form of <code>let rec</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> fib <span class="keyword2">=</span> memo_rec <span class="keyword2">(</span><span class="keyword1">fun</span> fib i -<span class="keyword2">&gt;</span>
    <span class="keyword1">if</span> i <span class="keyword2">&lt;</span><span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword1">then</span> <span class="keyword8">1</span> <span class="keyword1">else</span> fib <span class="keyword2">(</span>i - <span class="keyword8">1</span><span class="keyword2">)</span> <span class="keyword2">+</span> fib <span class="keyword2">(</span>i - <span class="keyword8">2</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fib : int -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293298656">Memoization is overkill for implementing Fibonacci, and indeed,
      the <code>fib</code> defined above is not
      especially efficient, allocating space linear in the number passed in to
      <code>fib</code>. It's easy enough to write a
      Fibonacci function that takes a constant amount of space.</p><p id="idm146293296768">But memoization is a good approach for optimizing <code>edit_distance</code>, and we can apply the same
      approach we used on <code>fib</code> here. We will
      need to change <code>edit_distance</code> to take
      a pair of strings as a single argument, since <code>memo_rec</code> only works on single-argument
      functions. (We can always recover the original interface with a wrapper
      function.) With just that change and the addition of the <code>memo_rec</code> call, we can get a memoized version
      of <code>edit_distance</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> edit_distance <span class="keyword2">=</span> memo_rec <span class="keyword2">(</span><span class="keyword1">fun</span> edit_distance <span class="keyword2">(</span>s,t<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    <span class="keyword1">match</span> <span class="keyword5">String.</span>length s, <span class="keyword5">String.</span>length t <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">(</span><span class="keyword8">0</span>,x<span class="keyword2">)</span> <span class="keyword2">|</span> <span class="keyword2">(</span>x,<span class="keyword8">0</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> x
    <span class="keyword2">|</span> <span class="keyword2">(</span>len_s,len_t<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword4">let</span> s' <span class="keyword2">=</span> <span class="keyword5">String.</span>drop_suffix s <span class="keyword8">1</span> <span class="keyword4">in</span>
      <span class="keyword4">let</span> t' <span class="keyword2">=</span> <span class="keyword5">String.</span>drop_suffix t <span class="keyword8">1</span> <span class="keyword4">in</span>
      <span class="keyword4">let</span> cost_to_drop_both <span class="keyword2">=</span>
        <span class="keyword1">if</span> s.<span class="keyword2">[</span>len_s - <span class="keyword8">1</span><span class="keyword2">]</span> <span class="keyword2">=</span> t.<span class="keyword2">[</span>len_t - <span class="keyword8">1</span><span class="keyword2">]</span> <span class="keyword1">then</span> <span class="keyword8">0</span> <span class="keyword1">else</span> <span class="keyword8">1</span>
      <span class="keyword4">in</span>
      <span class="keyword5">List.</span>reduce_exn ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>min
        <span class="keyword2">[</span> edit_distance <span class="keyword2">(</span>s',t <span class="keyword2">)</span> <span class="keyword2">+</span> <span class="keyword8">1</span>
        <span class="keyword2">;</span> edit_distance <span class="keyword2">(</span>s ,t'<span class="keyword2">)</span> <span class="keyword2">+</span> <span class="keyword8">1</span>
        <span class="keyword2">;</span> edit_distance <span class="keyword2">(</span>s',t'<span class="keyword2">)</span> <span class="keyword2">+</span> cost_to_drop_both
        <span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val edit_distance : string * string -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293279344">This new version of <code>edit_distance</code> is much more efficient than the
      one we started with; the following call is many thousands of times
      faster than it was without memoization:</p><div class="rwocode"><pre><code># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> edit_distance <span class="keyword2">(</span><span class="keyword7">&quot;OCaml 4.01&quot;</span>,<span class="keyword7">&quot;ocaml 4.01&quot;</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 0.344038ms
- : int = 2
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="note"><h1>Limitations of let rec</h1><p id="idm146293272592">You might wonder why we didn't tie the recursive knot in
        <code>memo_rec</code> using <code>let rec</code>, as we did for <code>make_rec</code> earlier. Here's code that tries to
        do just that:<a name="idm146293270224"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> memo_rec f_norec <span class="keyword2">=</span>
    <span class="keyword4">let</span> <span class="keyword4">rec</span> f <span class="keyword2">=</span> memoize <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> f_norec f x<span class="keyword2">)</span> <span class="keyword4">in</span>
    f
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 39-69:
Error: This kind of expression is not allowed as right-hand side of `let rec'
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/letrec.topscript">imperative-programming/letrec.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293262544">OCaml rejects the definition because OCaml, as a strict
        language, has limits on what it can put on the righthand side of a
        <code>let rec</code>. In particular, imagine how
        the following code snippet would be compiled:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword4">rec</span> x <span class="keyword2">=</span> x <span class="keyword2">+</span> <span class="keyword8">1</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/let_rec.ml">imperative-programming/let_rec.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293259040">Note that <code>x</code> is an ordinary
        value, not a function. As such, it's not clear how this definition
        should be handled by the compiler. You could imagine it compiling down
        to an infinite loop, but <code>x</code> is of
        type <code>int</code>, and there's no <code>int</code> that corresponds to an infinite loop. As
        such, this construct is effectively impossible to compile.</p><p id="idm146293255760">To avoid such impossible cases, the compiler only allows three
        possible constructs to show up on the righthand side of a <code>let rec</code>: a function definition, a
        constructor, or the lazy keyword. This excludes some reasonable
        things, like our definition of <code>memo_rec</code>, but it also blocks things that
        don't make sense, like our definition of <code>x</code>.</p><p id="idm146293253088">It's worth noting that these restrictions don't show up in a
        lazy language like Haskell. Indeed, we can make something like our
        definition of <code>x</code> work if we use
        OCaml's laziness:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> x <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span><span class="keyword5">Lazy.</span>force x <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val x : int lazy_t = &lt;lazy&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/letrec.topscript">imperative-programming/letrec.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293247936">Of course, actually trying to compute this will fail. OCaml's
        <code>lazy</code> throws an exception when a
        lazy value tries to force itself as part of its own evaluation.</p><div class="rwocode"><pre><code># <span class="keyword5">Lazy.</span>force x<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception: Lazy.Undefined.
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/letrec.topscript">imperative-programming/letrec.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293242848">But we can also create useful recursive definitions with
        <code>lazy</code>. In particular, we can use
        laziness to make our definition of <code>memo_rec</code> work without explicit
        mutation:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> lazy_memo_rec f_norec x <span class="keyword2">=</span>
    <span class="keyword4">let</span> <span class="keyword4">rec</span> f <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span>memoize <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> f_norec <span class="keyword2">(</span><span class="keyword5">Lazy.</span>force f<span class="keyword2">)</span> x<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword2">(</span><span class="keyword5">Lazy.</span>force f<span class="keyword2">)</span> x
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val lazy_memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
</div># time <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> lazy_memo_rec fib_norec <span class="keyword8">40</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>Time: 0.041008ms
- : int = 102334155
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/letrec.topscript">imperative-programming/letrec.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293232384">Laziness is more constrained than explicit mutation, and so in
        some cases can lead to code whose behavior is easier to think
        about.<a name="idm146293231968"></a></p></aside></section></section><section id="input-and-output"><h1>Input and Output</h1><p id="idm146293229936">Imperative programming is about more than modifying in-memory data
    structures. Any function that doesn't boil down to a deterministic
    transformation from its arguments to its return value is imperative in
    nature. That includes not only things that mutate your program's data, but
    also operations that interact with the world outside of your program. An
    important example of this kind of interaction is I/O, i.e., operations for
    reading or writing data to things like files, terminal input and output,
    and network sockets.<a name="idm146293229120"></a><a name="IPinpout"></a></p><p id="idm146293226112">There are multiple I/O libraries in OCaml. In this section we'll discuss OCaml's buffered
      I/O library that can be used through the <code>In_channel</code> and
        <code>Out_channel</code> modules in Core. Other I/O primitives are
      also available through the <code>Unix</code> module in Core as well as
        <code>Async</code>, the asynchronous I/O library that is covered in
        <a href="concurrent-programming-with-async.html">Chapter 18, <i>Concurrent Programming with Async</i></a>. Most of the functionality in Core's
        <code>In_channel</code> and <code>Out_channel</code> (and in Core's <code>Unix</code> module)
      derives from the standard library, but we'll use Core's interfaces here.</p><section id="terminal-io"><h1>Terminal I/O</h1><p id="idm146293219280">OCaml's buffered I/O library is organized around two types:
      <code>in_channel</code>, for channels you read
      from, and <code>out_channel</code>, for channels
      you write to. The <code>In_channel</code> and
      <code>Out_channel</code> modules only have direct
      support for channels corresponding to files and terminals; other kinds
      of channels can be created through the <code>Unix</code> module.<a name="idm146293215456"></a><a name="idm146293214128"></a><a name="idm146293212800"></a></p><p id="idm146293211760">We'll start our discussion of I/O by focusing on the terminal.
      Following the UNIX model, communication with the terminal is organized
      around three channels, which correspond to the three standard file
      descriptors in Unix:</p><div><dl><dt><span><code>In_channel.stdin</code></span></dt><dd><p id="idm146293209584">The &quot;standard input&quot; channel. By default, input comes from
            the terminal, which handles keyboard input.</p></dd><dt><span><code>Out_channel.stdout</code></span></dt><dd><p id="idm146293207520">The &quot;standard output&quot; channel. By default, output written to
            <code>stdout</code> appears on the user
            terminal.</p></dd><dt><span><code>Out_channel.stderr</code></span></dt><dd><p id="idm146293204816">The &quot;standard error&quot; channel. This is similar to <code>stdout</code> but is intended for error
            messages.</p></dd></dl></div><p id="idm146293203280">The values <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> are useful enough that they are also
      available in the global namespace directly, without having to go through
      the <code>In_channel</code> and <code>Out_channel</code> modules.</p><p id="idm146293199504">Let's see this in action in a simple interactive application. The
      following program, <code>time_converter</code>,
      prompts the user for a time zone, and then prints out the current time
      in that time zone. Here, we use Core's <code>Zone</code> module for looking up a time zone, and
      the <code>Time</code> module for computing the
      current time and printing it out in the time zone in question:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Out_channel.</span>output_string stdout <span class="keyword7">&quot;Pick a timezone: &quot;</span><span class="keyword2">;</span>
  <span class="keyword5">Out_channel.</span>flush stdout<span class="keyword2">;</span>
  <span class="keyword1">match</span> <span class="keyword5">In_channel.</span>input_line stdin <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> failwith <span class="keyword7">&quot;No timezone provided&quot;</span>
  <span class="keyword2">|</span> <span class="keyword6">Some </span>zone_string -<span class="keyword2">&gt;</span>
    <span class="keyword4">let</span> zone <span class="keyword2">=</span> <span class="keyword5">Zone.</span>find_exn zone_string <span class="keyword4">in</span>
    <span class="keyword4">let</span> time_string <span class="keyword2">=</span> <span class="keyword5">Time.</span>to_string_abs <span class="keyword2">(</span><span class="keyword5">Time.</span>now <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> ~zone <span class="keyword4">in</span>
    <span class="keyword5">Out_channel.</span>output_string stdout
      <span class="keyword2">(</span><span class="keyword5">String.</span>concat
         <span class="keyword2">[</span><span class="keyword7">&quot;The time in &quot;</span><span class="keyword2">;</span><span class="keyword5">Zone.</span>to_string zone<span class="keyword2">;</span><span class="keyword7">&quot; is &quot;</span><span class="keyword2">;</span>time_string<span class="keyword2">;</span><span class="keyword7">&quot;.\n&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">;</span>
    <span class="keyword5">Out_channel.</span>flush stdout</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/time_converter.ml">imperative-programming/time_converter.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293194432">We can build this program using <span><strong>corebuild</strong></span> and run it. You'll see that it
      prompts you for input, as follows:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild time_converter.byte
</div><div class="highlight"><span class="gp">$</span> ./time_converter.byte
</div><div class="rwocodeout">Pick a timezone:</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/time_converter.out">imperative-programming/time_converter.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293188352">You can then type in the name of a time zone and hit Return, and
      it will print out the current time in the time zone in question:</p><div class="rwocode"><pre><code><div class="rwocodeout">Pick a timezone: Europe/London</div><div class="rwocodeout">The time in Europe/London is 2013-08-15 00:03:10.666220+01:00.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/time_converter2.out">imperative-programming/time_converter2.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293184512">We called <code>Out_channel.flush</code> on
      <code>stdout</code> because <code>out_channel</code>s are buffered, which is to say
      that OCaml doesn't immediately do a write every time you call <code>output_string</code>. Instead, writes are buffered
      until either enough has been written to trigger the flushing of the
      buffers, or until a flush is explicitly requested. This greatly
      increases the efficiency of the writing process by reducing the number
      of system calls.</p><p id="idm146293181104">Note that <code>In_channel.input_line</code>
      returns a <code>string option</code>, with
      <code>None</code> indicating that the input stream
      has ended (i.e., an end-of-file condition). <code>Out_channel.output_string</code> is used to print the
      final output, and <code>Out_channel.flush</code>
      is called to flush that output to the screen. The final flush is not
      technically required, since the program ends after that instruction, at
      which point all remaining output will be flushed anyway, but the
      explicit flush is nonetheless good practice.</p></section><section id="formatted-output-with-printf"><h1>Formatted Output with printf</h1><p id="idm146293175920">Generating output with functions like <code>Out_channel.output_string</code> is simple and easy
      to understand, but can be a bit verbose. OCaml also supports formatted
      output using the <code>printf</code> function,
      which is modeled after <code>printf</code> in the
      C standard library. <code>printf</code> takes a
      <span><em>format string</em></span> that describes what to print and how
      to format it, as well as arguments to be printed, as determined by the
      formatting directives embedded in the format string. So, for example, we
      can write:<a name="idm146293172176"></a><a name="idm146293170880"></a><a name="idm146293169984"></a><a name="idm146293169088"></a></p><div class="rwocode"><pre><code># printf <span class="keyword7">&quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;</span>
    <span class="keyword8">3</span> <span class="keyword8">4</span>.<span class="keyword8">5</span> <span class="keyword7">&quot;five&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>3 is an integer, 4.5 is a float, &quot;five&quot; is a string
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293162368">Unlike C's <code>printf</code>, the <code>printf</code> in OCaml is type-safe. In particular,
      if we provide an argument whose type doesn't match what's presented in
      the format string, we'll get a type error:</p><div class="rwocode"><pre><code># printf <span class="keyword7">&quot;An integer: %i\n&quot;</span> <span class="keyword8">4</span>.<span class="keyword8">5</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 26-29:
Error: This expression has type float but an expression was expected of type
         int
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1><b>Understanding Format Strings</b></h1><p id="idm146293154576">The format strings used by <code>printf</code> turn out to be quite different from
        ordinary strings. This difference ties to the fact that OCaml format
        strings, unlike their equivalent in C, are type-safe. In particular,
        the compiler checks that the types referred to by the format string
        match the types of the rest of the arguments passed to <code>printf</code>.</p><p id="idm146293152544">To check this, OCaml needs to analyze the contents of the format
        string at compile time, which means the format string needs to be
        available as a string literal at compile time. Indeed, if you try to
        pass an ordinary string to <code>printf</code>,
        the compiler will complain:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> fmt <span class="keyword2">=</span> <span class="keyword7">&quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fmt : string = &quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;
</div>#   printf fmt <span class="keyword8">3</span> <span class="keyword8">4</span>.<span class="keyword8">5</span> <span class="keyword7">&quot;five&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 9-12:
Error: This expression has type string but an expression was expected of type
         ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit) format =
           ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit, unit, unit, unit)
           format6
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293142592">If OCaml infers that a given string literal is a format string,
        then it parses it at compile time as such, choosing its type in
        accordance with the formatting directives it finds. Thus, if we add a
        type annotation indicating that the string we're defining is actually
        a format string, it will be interpreted as such:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> fmt <span class="keyword2">:</span> <span class="keyword2">(</span>'a, 'b, 'c<span class="keyword2">)</span> format <span class="keyword2">=</span>
    <span class="keyword7">&quot;%i is an integer, %F is a float, \&quot;%s\&quot; is a string\n&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val fmt : (int -&gt; float -&gt; string -&gt; 'c, 'b, 'c) format = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293136832">And accordingly, we can pass it to <code>printf</code>:</p><div class="rwocode"><pre><code># printf fmt <span class="keyword8">3</span> <span class="keyword8">4</span>.<span class="keyword8">5</span> <span class="keyword7">&quot;five&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>3 is an integer, 4.5 is a float, &quot;five&quot; is a string
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293131488">If this looks different from everything else you've seen so far,
        that's because it is. This is really a special case in the type
        system. Most of the time, you don't need to worry about this special
        handling of format strings—you can just use <code>printf</code> and not worry about the details. But
        it's useful to keep the broad outlines of the story in the back of
        your head.</p></section><p id="idm146293129648">Now let's see how we can rewrite our time conversion program to be
      a little more concise using <code>printf</code>:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  printf <span class="keyword7">&quot;Pick a timezone: %!&quot;</span><span class="keyword2">;</span>
  <span class="keyword1">match</span> <span class="keyword5">In_channel.</span>input_line stdin <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> failwith <span class="keyword7">&quot;No timezone provided&quot;</span>
  <span class="keyword2">|</span> <span class="keyword6">Some </span>zone_string -<span class="keyword2">&gt;</span>
    <span class="keyword4">let</span> zone <span class="keyword2">=</span> <span class="keyword5">Time.</span><span class="keyword5">Zone.</span>find_exn zone_string <span class="keyword4">in</span>
    <span class="keyword4">let</span> time_string <span class="keyword2">=</span> <span class="keyword5">Time.</span>to_string_abs <span class="keyword2">(</span><span class="keyword5">Time.</span>now <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> ~zone <span class="keyword4">in</span>
    printf <span class="keyword7">&quot;The time in %s is %s.\n%!&quot;</span> <span class="keyword2">(</span><span class="keyword5">Time.</span><span class="keyword5">Zone.</span>to_string zone<span class="keyword2">)</span> time_string</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/time_converter2.ml">imperative-programming/time_converter2.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293125152">In the preceding example, we've used only two formatting
      directives: <code>%s</code>, for including a
      string, and <code>%!</code> which causes <code>printf</code> to flush the channel.</p><p id="idm146293122784"><code>printf</code>'s formatting directives
      offer a significant amount of control, allowing you to specify things
      like:<a name="idm146293121888"></a><a name="idm146293120960"></a><a name="idm146293120032"></a><a name="idm146293119104"></a></p><ul><li><p id="idm146293117536">Alignment and padding</p></li><li><p id="idm146293116736">Escaping rules for strings</p></li><li><p id="idm146293115936">Whether numbers should be formatted in decimal, hex, or
          binary</p></li><li><p id="idm146293115088">Precision of float conversions</p></li></ul><p id="idm146293114416">There are also <code>printf</code>-style
      functions that target outputs other than <code>stdout</code>, including:<a name="idm146293112784"></a><a name="idm146293111872"></a><a name="idm146293110960"></a></p><ul><li><p id="idm146293109408"><code>eprintf</code>, which prints to
          <code>stderr</code></p></li><li><p id="idm146293107584"><code>fprintf</code>, which prints to an
          arbitrary <code>out_channel</code></p></li><li><p id="idm146293105744"><code>sprintf</code>, which returns a
          formatted string</p></li></ul><p id="idm146293104544">All of this, and a good deal more, is described in the API
      documentation for the <code>Printf</code> module
      in the OCaml Manual.</p></section><section id="file-io"><h1>File I/O</h1><p id="idm146293102352">Another common use of <code>in_channel</code>s and <code>out_channel</code>s is for working with files. Here
      are a couple of functions—one that creates a file full of numbers, and
      the other that reads in such a file and returns the sum of those
      numbers:<a name="idm146293126304"></a><a name="idm146293099216"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> create_number_file filename numbers <span class="keyword2">=</span>
    <span class="keyword4">let</span> outc <span class="keyword2">=</span> <span class="keyword5">Out_channel.</span>create filename <span class="keyword4">in</span>
    <span class="keyword5">List.</span>iter numbers ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> fprintf outc <span class="keyword7">&quot;%d\n&quot;</span> x<span class="keyword2">)</span><span class="keyword2">;</span>
    <span class="keyword5">Out_channel.</span>close outc
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val create_number_file : string -&gt; int list -&gt; unit = &lt;fun&gt;
</div># <span class="keyword4">let</span> sum_file filename <span class="keyword2">=</span>
     <span class="keyword4">let</span> file <span class="keyword2">=</span> <span class="keyword5">In_channel.</span>create filename <span class="keyword4">in</span>
     <span class="keyword4">let</span> numbers <span class="keyword2">=</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>of_string <span class="keyword2">(</span><span class="keyword5">In_channel.</span>input_lines file<span class="keyword2">)</span> <span class="keyword4">in</span>
     <span class="keyword4">let</span> sum <span class="keyword2">=</span> <span class="keyword5">List.</span>fold ~init<span class="keyword2">:</span><span class="keyword8">0</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword2">+</span><span class="keyword2">)</span> numbers <span class="keyword4">in</span>
     <span class="keyword5">In_channel.</span>close file<span class="keyword2">;</span>
     sum
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sum_file : string -&gt; int = &lt;fun&gt;
</div># create_number_file <span class="keyword7">&quot;numbers.txt&quot;</span> <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># sum_file <span class="keyword7">&quot;numbers.txt&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 15
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/file.topscript">imperative-programming/file.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293081776">For both of these functions, we followed the same basic sequence:
      we first create the channel, then use the channel, and finally close the
      channel. The closing of the channel is important, since without it, we
      won't release resources associated with the file back to the operating
      system.</p><p id="idm146293081072">One problem with the preceding code is that if it throws an
      exception in the middle of its work, it won't actually close the file.
      If we try to read a file that doesn't actually contain numbers, we'll
      see such an error:</p><div class="rwocode"><pre><code># sum_file <span class="keyword7">&quot;/etc/hosts&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception: (Failure &quot;Int.of_string: \&quot;##\&quot;&quot;).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/file.topscript">imperative-programming/file.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293076496">And if we do this over and over in a loop, we'll eventually run
      out of file descriptors:</p><div class="rwocode"><pre><code># <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword1">to</span> <span class="keyword8">10000</span> <span class="keyword1">do</span> <span class="keyword1">try</span> ignore <span class="keyword2">(</span>sum_file <span class="keyword7">&quot;/etc/hosts&quot;</span><span class="keyword2">)</span> <span class="keyword1">with</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword1">done</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># sum_file <span class="keyword7">&quot;numbers.txt&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception: (Sys_error &quot;numbers.txt: Too many open files&quot;).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/file.topscript">imperative-programming/file.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293070096">And now, you'll need to restart your toplevel if you want to open
      any more files!</p><p id="idm146293069616">To avoid this, we need to make sure that our code cleans up after
      itself. We can do this using the <code>protect</code> function described in <a href="error-handling.html">Chapter 7, <i>Error Handling</i></a>, as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> sum_file filename <span class="keyword2">=</span>
    <span class="keyword4">let</span> file <span class="keyword2">=</span> <span class="keyword5">In_channel.</span>create filename <span class="keyword4">in</span>
    protect ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
        <span class="keyword4">let</span> numbers <span class="keyword2">=</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>of_string <span class="keyword2">(</span><span class="keyword5">In_channel.</span>input_lines file<span class="keyword2">)</span> <span class="keyword4">in</span>
        <span class="keyword5">List.</span>fold ~init<span class="keyword2">:</span><span class="keyword8">0</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword2">+</span><span class="keyword2">)</span> numbers<span class="keyword2">)</span>
      ~finally<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">In_channel.</span>close file<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sum_file : string -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/file2.topscript">imperative-programming/file2.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293059968">And now, the file descriptor leak is gone:</p><div class="rwocode"><pre><code># <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword1">to</span> <span class="keyword8">10000</span> <span class="keyword1">do</span> <span class="keyword1">try</span> ignore <span class="keyword2">(</span>sum_file <span class="keyword7">&quot;/etc/hosts&quot;</span><span class="keyword2">)</span> <span class="keyword1">with</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword1">done</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># sum_file <span class="keyword7">&quot;numbers.txt&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 15
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/file2.topscript">imperative-programming/file2.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293053696">This is really an example of a more general issue with imperative
      programming. When programming imperatively, you need to be quite careful
      to make sure that exceptions don't leave you in an awkward state.</p><p id="idm146293053088"><code>In_channel</code> has functions that
      automate the handling of some of these details. For example, <code>In_channel.with_file</code> takes a filename and a
      function for processing data from an <code>in_channel</code> and takes care of the bookkeeping
      associated with opening and closing the file. We can rewrite <code>sum_file</code> using this function, as shown
      here:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> sum_file filename <span class="keyword2">=</span>
    <span class="keyword5">In_channel.</span>with_file filename ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> file -<span class="keyword2">&gt;</span>
      <span class="keyword4">let</span> numbers <span class="keyword2">=</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>of_string <span class="keyword2">(</span><span class="keyword5">In_channel.</span>input_lines file<span class="keyword2">)</span> <span class="keyword4">in</span>
      <span class="keyword5">List.</span>fold ~init<span class="keyword2">:</span><span class="keyword8">0</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword2">+</span><span class="keyword2">)</span> numbers<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sum_file : string -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/file2.topscript">imperative-programming/file2.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293043280">Another misfeature of our implementation of <code>sum_file</code> is that we read the entire file into
      memory before processing it. For a large file, it's more efficient to
      process a line at a time. You can use the <code>In_channel.fold_lines</code> function to do just
      that:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> sum_file filename <span class="keyword2">=</span>
    <span class="keyword5">In_channel.</span>with_file filename ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> file -<span class="keyword2">&gt;</span>
      <span class="keyword5">In_channel.</span>fold_lines file ~init<span class="keyword2">:</span><span class="keyword8">0</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> sum line -<span class="keyword2">&gt;</span>
        sum <span class="keyword2">+</span> <span class="keyword5">Int.</span>of_string line<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sum_file : string -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/file2.topscript">imperative-programming/file2.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293034592">This is just a taste of the functionality of <code>In_channel</code> and <code>Out_channel</code>. To get a fuller understanding,
      you should review the API documentation for those modules.<a name="idm146293032880"></a></p></section></section><section id="order-of-evaluation"><h1>Order of Evaluation</h1><p id="idm146293030992">The order in which expressions are evaluated is an important part of the definition of a
      programming language, and it is particularly important when programming imperatively. Most
      programming languages you're likely to have encountered are <span><em>strict</em></span>, and
      OCaml is, too. In a strict language, when you bind an identifier to the result of some
      expression, the expression is evaluated before the variable is bound. Similarly, if you call a
      function on a set of arguments, those arguments are evaluated before they are passed to the
        function.<a name="idm146293029760"></a><a name="idm146293028848"></a><a name="idm146293027920"></a><a name="idm146293027008"></a><a name="idm146293026096"></a></p><p id="idm146293024640">Consider the following simple example. Here, we have a collection of
    angles, and we want to determine if any of them have a negative <code>sin</code>. The following snippet of code would answer
    that question:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> x <span class="keyword2">=</span> sin <span class="keyword8">120</span>. <span class="keyword4">in</span>
  <span class="keyword4">let</span> y <span class="keyword2">=</span> sin <span class="keyword8">75</span>.  <span class="keyword4">in</span>
  <span class="keyword4">let</span> z <span class="keyword2">=</span> sin <span class="keyword8">128</span>. <span class="keyword4">in</span>
  <span class="keyword5">List.</span>exists ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> x <span class="keyword2">&lt;</span> <span class="keyword8">0</span>.<span class="keyword2">)</span> <span class="keyword2">[</span>x<span class="keyword2">;</span>y<span class="keyword2">;</span>z<span class="keyword2">]</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = true
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/order.topscript">imperative-programming/order.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293016864">In some sense, we don't really need to compute the <code>sin 128.</code> because <code>sin
    75.</code> is negative, so we could know the answer before even
    computing <code>sin 128.</code>.</p><p id="idm146293014400">It doesn't have to be this way. Using the <code>lazy</code> keyword, we can write the original
    computation so that <code>sin 128.</code> won't ever
    be computed:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span>sin <span class="keyword8">120</span>.<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> y <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span>sin <span class="keyword8">75</span>.<span class="keyword2">)</span>  <span class="keyword4">in</span>
  <span class="keyword4">let</span> z <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span>sin <span class="keyword8">128</span>.<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword5">List.</span>exists ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> <span class="keyword5">Lazy.</span>force x <span class="keyword2">&lt;</span> <span class="keyword8">0</span>.<span class="keyword2">)</span> <span class="keyword2">[</span>x<span class="keyword2">;</span>y<span class="keyword2">;</span>z<span class="keyword2">]</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = true
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/order.topscript">imperative-programming/order.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146293006064">We can confirm that fact by a few well-placed <code>printf</code>s:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span>printf <span class="keyword7">&quot;1\n&quot;</span><span class="keyword2">;</span> sin <span class="keyword8">120</span>.<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> y <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span>printf <span class="keyword7">&quot;2\n&quot;</span><span class="keyword2">;</span> sin <span class="keyword8">75</span>.<span class="keyword2">)</span>  <span class="keyword4">in</span>
  <span class="keyword4">let</span> z <span class="keyword2">=</span> <span class="keyword1">lazy</span> <span class="keyword2">(</span>printf <span class="keyword7">&quot;3\n&quot;</span><span class="keyword2">;</span> sin <span class="keyword8">128</span>.<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword5">List.</span>exists ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> <span class="keyword5">Lazy.</span>force x <span class="keyword2">&lt;</span> <span class="keyword8">0</span>.<span class="keyword2">)</span> <span class="keyword2">[</span>x<span class="keyword2">;</span>y<span class="keyword2">;</span>z<span class="keyword2">]</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>1
2
- : bool = true
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/order.topscript">imperative-programming/order.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292997168">OCaml is strict by default for a good reason: lazy evaluation and
    imperative programming generally don't mix well because laziness makes it
    harder to reason about when a given side effect is going to occur.
    Understanding the order of side effects is essential to reasoning about
    the behavior of an imperative program.</p><p id="idm146292996448">In a strict language, we know that expressions that are bound by a
    sequence of <code>let</code> bindings will be evaluated in the order
    that they're defined. But what about the evaluation order within a single
    expression? Officially, the answer is that evaluation order within an
    expression is undefined. In practice, OCaml has only one compiler, and
    that behavior is a kind of de facto standard. Unfortunately, the
    evaluation order in this case is often the opposite of what one might
    expect.</p><p id="idm146292995152">Consider the following example:</p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>exists ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> x <span class="keyword2">&lt;</span> <span class="keyword8">0</span>.<span class="keyword2">)</span>
  <span class="keyword2">[</span> <span class="keyword2">(</span>printf <span class="keyword7">&quot;1\n&quot;</span><span class="keyword2">;</span> sin <span class="keyword8">120</span>.<span class="keyword2">)</span><span class="keyword2">;</span>
    <span class="keyword2">(</span>printf <span class="keyword7">&quot;2\n&quot;</span><span class="keyword2">;</span> sin <span class="keyword8">75</span>.<span class="keyword2">)</span><span class="keyword2">;</span>
    <span class="keyword2">(</span>printf <span class="keyword7">&quot;3\n&quot;</span><span class="keyword2">;</span> sin <span class="keyword8">128</span>.<span class="keyword2">)</span><span class="keyword2">;</span> <span class="keyword2">]</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br></br>3
2
1
- : bool = true
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/order.topscript">imperative-programming/order.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292986368">Here, you can see that the subexpression that came last was actually
    evaluated first! This is generally the case for many different kinds of
    expressions. If you want to make sure of the evaluation order of different
    subexpressions, you should express them as a series of <code>let</code> bindings.</p></section><section id="side-effects-and-weak-polymorphism"><h1>Side Effects and Weak Polymorphism</h1><p id="idm146292983968">Consider the following simple, imperative function:<a name="idm146292983648"></a><a name="idm146292982336"></a><a name="idm146292981424"></a><a name="IPsideweak"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> remember <span class="keyword2">=</span>
    <span class="keyword4">let</span> cache <span class="keyword2">=</span> ref <span class="keyword6">None </span><span class="keyword4">in</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span>
       <span class="keyword1">match</span> <span class="keyword2">!</span>cache <span class="keyword1">with</span>
       <span class="keyword2">|</span> <span class="keyword6">Some </span>y -<span class="keyword2">&gt;</span> y
       <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> cache <span class="keyword2">:</span><span class="keyword2">=</span> <span class="keyword6">Some </span>x<span class="keyword2">;</span> x<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val remember : '_a -&gt; '_a = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/weak.topscript">imperative-programming/weak.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292970880"><code>remember</code> simply caches the first
    value that's passed to it, returning that value on every call. That's
    because <code>cache</code> is created and
    initialized once and is shared across invocations of <code>remember</code>.</p><p id="idm146292968512"><code>remember</code> is not a terribly useful
    function, but it raises an interesting question: what is its type?</p><p id="idm146292967504">On its first call, <code>remember</code>
    returns the same value it's passed, which means its input type and return
    type should match. Accordingly, <code>remember</code> should have type <code>t -&gt; t</code> for some type <code>t</code>. There's nothing about <code>remember</code> that ties the choice of <code>t</code> to any particular type, so you might expect
    OCaml to generalize, replacing <code>t</code> with a
    polymorphic type variable. It's this kind of generalization that gives us
    polymorphic types in the first place. The identity function, as an
    example, gets a polymorphic type in this way:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> identity x <span class="keyword2">=</span> x<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val identity : 'a -&gt; 'a = &lt;fun&gt;
</div># identity <span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 3
</div># identity <span class="keyword7">&quot;five&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;five&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/weak.topscript">imperative-programming/weak.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292954640">As you can see, the polymorphic type of <code>identity</code> lets it operate on values with
    different types.</p><p id="idm146292953504">This is not what happens with <code>remember</code>, though. As you
      can see from the above examples, the type that OCaml infers for <code>remember</code> looks almost, but not quite, like the type of the identity function.
      Here it is again:</p><div class="rwocode"><pre><code><span class="keyword4">val</span> remember <span class="keyword2">:</span> '_a -<span class="keyword2">&gt;</span> '_a <span class="keyword2">=</span> <span class="keyword2">&lt;</span><span class="keyword1">fun</span><span class="keyword2">&gt;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/remember_type.ml">imperative-programming/remember_type.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292949328">The underscore in the type variable <code>'_a</code> tells us that the variable is only
    <span><em>weakly polymorphic</em></span>, which is to say that it can be
    used with any <span><em>single</em></span> type. That makes sense because,
    unlike <code>identity</code>, <code>remember</code> always returns the value it was passed
    on its first invocation, which means its return value must always have the
    same type.<a name="idm146292946032"></a></p><p id="idm146292945008">OCaml will convert a weakly polymorphic variable to a concrete type
    as soon as it gets a clue as to what concrete type it is to be used
    as:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> remember_three <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> remember <span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val remember_three : unit -&gt; int = &lt;fun&gt;
</div># remember<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int -&gt; int = &lt;fun&gt;
</div># remember <span class="keyword7">&quot;avocado&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 9-18:
Error: This expression has type string but an expression was expected of type
         int
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/weak.topscript">imperative-programming/weak.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292935552">Note that the type of <code>remember</code>
    was settled by the definition of <code>remember_three</code>, even though <code>remember_three</code> was never called!</p><section id="the-value-restriction"><h1>The Value Restriction</h1><p id="idm146292932192">So, when does the compiler infer weakly polymorphic types? As
      we've seen, we need weakly polymorphic types when a value of unknown
      type is stored in a persistent mutable cell. Because the type system
      isn't precise enough to determine all cases where this might happen,
      OCaml uses a rough rule to flag cases that don't introduce any
      persistent mutable cells, and to only infer polymorphic types in those
      cases. This rule is called <span><em>the value
      restriction</em></span>.<a name="idm146292930464"></a></p><p id="idm146292929536">The core of the value restriction is the observation that some
      kinds of expressions, which we'll refer to as <span><em>simple
      values</em></span>, by their nature can't introduce persistent mutable
      cells, including:</p><ul><li><p id="idm146292928016">Constants (i.e., things like integer and floating-point
          literals)</p></li><li><p id="idm146292927168">Constructors that only contain other simple values</p></li><li><p id="idm146292926336">Function declarations, i.e., expressions that begin with
          <code>fun</code> or <code>function</code>, or the equivalent let binding,
          <code>let f x = ...</code></p></li><li><p id="idm146292923648"><code>let</code> bindings of the form
          <code>let</code> <span><em><code>var</code></em></span> <code>=</code> <span><em><code>expr1</code></em></span> <code>in</code> <span><em><code>expr2</code></em></span>, where both
          <span><em><code>expr1</code></em></span> and
          <span><em><code>expr2</code></em></span> are
          simple values</p></li></ul><p id="idm146292916688">Thus, the following expression is a simple value, and as a result,
      the types of values contained within it are allowed to be
      polymorphic:</p><div class="rwocode"><pre><code># <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> <span class="keyword2">[</span>x<span class="keyword2">;</span>x<span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292912144">But, if we write down an expression that isn't a simple value by
      the preceding definition, we'll get different results. For example,
      consider what happens if we try to memoize the function defined
      previously.</p><div class="rwocode"><pre><code># memoize <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> <span class="keyword2">[</span>x<span class="keyword2">;</span>x<span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : '_a -&gt; '_a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292907536">The memoized version of the function does in fact need to be
      restricted to a single type because it uses mutable state behind the
      scenes to cache values returned by previous invocations of the function.
      But OCaml would make the same determination even if the function in
      question did no such thing. Consider this example:</p><div class="rwocode"><pre><code># identity <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> <span class="keyword2">[</span>x<span class="keyword2">;</span>x<span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : '_a -&gt; '_a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292902816">It would be safe to infer a fully polymorphic variable here, but
      because OCaml's type system doesn't distinguish between pure and impure
      functions, it can't separate those two cases.</p><p id="idm146292902224">The value restriction doesn't require that there is no mutable
      state, only that there is no <span><em>persistent</em></span> mutable
      state that could share values between uses of the same function. Thus, a
      function that produces a fresh reference every time it's called can have
      a fully polymorphic type:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> f <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> ref None<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val f : unit -&gt; 'a option ref = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292897120">But a function that has a mutable cache that persists across
      calls, like <code>memoize</code>, can only be weakly
      polymorphic.</p></section><section id="partial-application-and-the-value-restriction"><h1>Partial Application and the Value Restriction</h1><p id="idm146292895136">Most of the time, when the value restriction kicks in, it's for a
      good reason, i.e., it's because the value in question can actually only
      safely be used with a single type. But sometimes, the value restriction
      kicks in when you don't want it. The most common such case is partially
      applied functions. A partially applied function, like any function
      application, is not a simple value, and as such, functions created by
      partial application are sometimes less general than you might
      expect.<a name="idm146292894336"></a></p><p id="idm146292893328">Consider the <code>List.init</code>
      function, which is used for creating lists where each element is created
      by calling a function on the index of that element:</p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>init<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int -&gt; f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;
</div># <span class="keyword5">List.</span>init <span class="keyword8">10</span> ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>to_string<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string list = [&quot;0&quot;; &quot;1&quot;; &quot;2&quot;; &quot;3&quot;; &quot;4&quot;; &quot;5&quot;; &quot;6&quot;; &quot;7&quot;; &quot;8&quot;; &quot;9&quot;]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292886352">Imagine we wanted to create a specialized version of <code>List.init</code> that always created lists of length
      10. We could do that using partial application, as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> list_init_10 <span class="keyword2">=</span> <span class="keyword5">List.</span>init <span class="keyword8">10</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val list_init_10 : f:(int -&gt; '_a) -&gt; '_a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292881152">As you can see, we now infer a weakly polymorphic type for the
      resulting function. That's because there's nothing that guarantees that
      <code>List.init</code> isn't creating a persistent
      <code>ref</code> somewhere inside of it that would
      be shared across multiple calls to <code>list_init_10</code>. We can eliminate this
      possibility, and at the same time get the compiler to infer a
      polymorphic type, by avoiding partial application:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> list_init_10 ~f <span class="keyword2">=</span> <span class="keyword5">List.</span>init <span class="keyword8">10</span> ~f<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val list_init_10 : f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292874448">This transformation is referred to as <span><em>eta
      expansion</em></span> and is often useful to resolve problems that arise
      from the value restriction.</p></section><section id="relaxing-the-value-restriction"><h1>Relaxing the Value Restriction</h1><p id="idm146292872480">OCaml is actually a little better at inferring polymorphic types
      than was suggested previously. The value restriction as we described it
      is basically a syntactic check: you can do a few operations that count
      as simple values, and anything that's a simple value can be
      generalized.</p><p id="idm146292871776">But OCaml actually has a relaxed version of the value restriction that can make use of
        type information to allow polymorphic types for things that are not simple values.</p><p id="idm146292871200">For example, we saw that a function application, even a simple
      application of the identity function, is not a simple value and thus can
      turn a polymorphic value into a weakly polymorphic one:</p><div class="rwocode"><pre><code># identity <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> <span class="keyword2">[</span>x<span class="keyword2">;</span>x<span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : '_a -&gt; '_a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292866576">But that's not always the case. When the type of the returned
      value is immutable, then OCaml can typically infer a fully polymorphic
      type:</p><div class="rwocode"><pre><code># identity <span class="keyword2">[</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a list = []
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292862176">On the other hand, if the returned type is potentially mutable,
      then the result will be weakly polymorphic:</p><div class="rwocode"><pre><code># <span class="keyword2">[|</span><span class="keyword2">|]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a array = [||]
</div># identity <span class="keyword2">[|</span><span class="keyword2">|]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : '_a array = [||]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 10) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292855952">A more important example of this comes up when defining abstract
      data types. Consider the following simple data structure for an
      immutable list type that supports constant-time concatenation:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Concat_list </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> 'a t
    <span class="keyword4">val</span> empty <span class="keyword2">:</span> 'a t
    <span class="keyword4">val</span> singleton <span class="keyword2">:</span> 'a -<span class="keyword2">&gt;</span> 'a t
    <span class="keyword4">val</span> concat  <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a t -<span class="keyword2">&gt;</span> 'a t  <span class="comments">(* constant time *)</span>
    <span class="keyword4">val</span> to_list <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a <span class="keyword3">list</span>       <span class="comments">(* linear time   *)</span>
  <span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>

    <span class="keyword4">type</span> 'a t <span class="keyword2">=</span> <span class="keyword6">Empty </span><span class="keyword2">|</span> <span class="keyword6">Singleton </span><span class="keyword2">of</span> 'a <span class="keyword2">|</span> <span class="keyword6">Concat </span><span class="keyword2">of</span> 'a t <span class="keyword2">*</span> 'a t

    <span class="keyword4">let</span> empty <span class="keyword2">=</span> <span class="keyword6">Empty
</span>    <span class="keyword4">let</span> singleton x <span class="keyword2">=</span> <span class="keyword6">Singleton </span>x
    <span class="keyword4">let</span> concat x y <span class="keyword2">=</span> <span class="keyword6">Concat </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span>

    <span class="keyword4">let</span> <span class="keyword4">rec</span> to_list_with_tail t tail <span class="keyword2">=</span>
      <span class="keyword1">match</span> t <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> tail
      <span class="keyword2">|</span> <span class="keyword6">Singleton </span>x -<span class="keyword2">&gt;</span> x <span class="keyword2">:</span><span class="keyword2">:</span> tail
      <span class="keyword2">|</span> <span class="keyword6">Concat </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> to_list_with_tail x <span class="keyword2">(</span>to_list_with_tail y tail<span class="keyword2">)</span>

    <span class="keyword4">let</span> to_list t <span class="keyword2">=</span>
      to_list_with_tail t <span class="keyword2">[</span><span class="keyword2">]</span>

  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Concat_list :
  sig
    type 'a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat : 'a t -&gt; 'a t -&gt; 'a t
    val to_list : 'a t -&gt; 'a list
  end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 11) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292831936">The details of the implementation don't matter so much, but it's
      important to note that a <code>Concat_list.t</code> is unquestionably an immutable
      value. However, when it comes to the value restriction, OCaml treats it
      as if it were mutable:</p><div class="rwocode"><pre><code># <span class="keyword5">Concat_list.</span>empty<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Concat_list.t = &lt;abstr&gt;
</div># identity <span class="keyword5">Concat_list.</span>empty<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : '_a Concat_list.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 12) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292824848">The issue here is that the signature, by virtue of being abstract,
      has obscured the fact that <code>Concat_list.t</code> is in fact an immutable data
      type. We can resolve this in one of two ways: either by making the type
      concrete (i.e., exposing the implementation in the <code>mli</code>), which is often not desirable; or by
      marking the type variable in question as <span><em>covariant</em></span>.
      We'll learn more about covariance and contravariance in <a href="objects.html">Chapter 11, <i>Objects</i></a>, but for now, you can think of it as an annotation
      that can be put in the interface of a pure data structure.<a name="idm146292821840"></a></p><p id="idm146292820416">In particular, if we replace <code>type 'a
      t</code> in the interface with <code>type +'a
      t</code>, that will make it explicit in the interface that the data
      structure doesn't contain any persistent references to values of type
      <code>'a</code>, at which point, OCaml can infer
      polymorphic types for expressions of this type that are not simple
      values:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Concat_list </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> 'a t
    <span class="keyword4">val</span> empty <span class="keyword2">:</span> 'a t
    <span class="keyword4">val</span> singleton <span class="keyword2">:</span> 'a -<span class="keyword2">&gt;</span> 'a t
    <span class="keyword4">val</span> concat  <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a t -<span class="keyword2">&gt;</span> 'a t  <span class="comments">(* constant time *)</span>
    <span class="keyword4">val</span> to_list <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a <span class="keyword3">list</span>       <span class="comments">(* linear time   *)</span>
  <span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>

    <span class="keyword4">type</span> 'a t <span class="keyword2">=</span> <span class="keyword6">Empty </span><span class="keyword2">|</span> <span class="keyword6">Singleton </span><span class="keyword2">of</span> 'a <span class="keyword2">|</span> <span class="keyword6">Concat </span><span class="keyword2">of</span> 'a t <span class="keyword2">*</span> 'a t

    ...

  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> module Concat_list :
  sig
    type 'a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat : 'a t -&gt; 'a t -&gt; 'a t
    val to_list : 'a t -&gt; 'a list
  end</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction-13.rawscript">imperative-programming/value_restriction-13.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm146292813840">Now, we can apply the identity function to <code>Concat_list.empty</code> without without losing any
      polymorphism:</p><div class="rwocode"><pre><code># identity <span class="keyword5">Concat_list.</span>empty<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a Concat_list.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</a> , continued (part 14) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section></section><section id="summary"><h1>Summary</h1><p id="idm146292807040">This chapter has covered quite a lot of ground, including:<a name="idm146292806720"></a></p><ul><li><p id="idm146292804800">Discussing the building blocks of mutable data structures as
        well as the basic imperative constructs like <code>for</code> loops, <code>while</code> loops, and the sequencing operator
        <code>;</code></p></li><li><p id="idm146292802080">Walking through the implementation of a couple of classic
        imperative data structures</p></li><li><p id="idm146292801216">Discussing so-called benign effects like memoization and
        laziness</p></li><li><p id="idm146292800368">Covering OCaml's API for blocking I/O</p></li><li><p id="idm146292799552">Discussing how language-level issues like order of evaluation
        and weak polymorphism interact with OCaml's imperative features</p></li></ul><p id="idm146292798768">The scope and sophistication of the material here is an indication
    of the importance of OCaml's imperative features. The fact that OCaml
    defaults to immutability shouldn't obscure the fact that imperative
    programming is a fundamental part of building any serious application, and
    that if you want to be an effective OCaml programmer, you need to
    understand OCaml's approach to imperative programming.<a name="idm146292798080"></a></p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="error-handling.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="functors.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>
