<html>

    <head>
    
        <meta charset="utf-8"></meta>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29546208-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
        
        <title>Chapter 10. First-Class Modules / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"></link>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'realworldocaml',
                        repo: 'book',
                        milestone: 'v1',
                        page: 'first\u002Dclass\u002Dmodules.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">4. Files, Modules, and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html" class="here">10. First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="objects.html">11. Objects</a>
                                            </li>
                                        
                                            <li>
                                                <a href="classes.html">12. Classes</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="ix01.html">Index</a>
                            
                        </li>
                    
                </ul>
            </nav>
            <header class="header">
                <h1><a href="http://oreil.ly/realworldOCaml"><img src="../../media/img/coversmall.png" width="120" alt="Real World OCaml, by Yaron Minsky, Anil Madhavapeddy and Jason Hickey"></img></a></h1>
                <p><i>Buy in <a href="http://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/">print</a> and <a href="http://oreil.ly/realworldOCaml">eBook.</a></i></p>
            </header>
        
            <article class="page">
        
                <h1>Chapter 10. First-Class Modules</h1>
                
                

    <p id="idm181615251792">You can think of OCaml as being broken up into two parts: a core
  language that is concerned with values and types, and a module language that
  is concerned with modules and module signatures. These sublanguages are
  stratified, in that modules can contain types and values, but ordinary
  values can't contain modules or module types. That means you can't do things
  like define a variable whose value is a module, or a function that takes a
  module as an argument.<a name="MODfirst"></a></p><p id="idm181615249376">OCaml provides a way around this stratification in the form of
  <span><em>first-class modules</em></span>. First-class modules are ordinary
  values that can be created from and converted back to regular
  modules.<a name="FCMwork"></a></p><p id="idm181615246832">First-class modules are a sophisticated technique, and you'll need to get comfortable with
        some advanced aspects of the language to use them effectively. But it's worth learning,
        because letting modules into the core language is quite powerful, increasing the range of
        what you can express and making it easier to build flexible and modular <span>systems</span>.</p><section id="working-with-first-class-modules"><h1>Working with First-Class Modules</h1><p id="idm181615244112">We'll start out by covering the basic mechanics of first-class
    modules by working through some toy examples. We'll get to more realistic
    examples in the next section.</p><p id="idm181615243552">In that light, consider the following signature of a module with a
    single integer variable:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">X_int </span><span class="keyword2">=</span> <span class="keyword4">sig</span> <span class="keyword4">val</span> x <span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module type X_int = sig val x : int end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615239296">We can also create a module that matches this signature:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Three </span><span class="keyword2">:</span> <span class="keyword6">X_int </span><span class="keyword2">=</span> <span class="keyword4">struct</span> <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword8">3</span> <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Three : X_int
</div># <span class="keyword5">Three.</span>x<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 3
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615233168">A first-class module is created by packaging up a module with a
    signature that it satisfies. This is done using the <code>module</code> keyword, using the following
    syntax:<a name="idm181615232096"></a></p><div class="rwocode"><pre><code><pre>(module &lt;Module&gt; : &lt;Module_type&gt;)
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/pack.syntax">fcm/pack.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615229024">So, we can convert <code>Three</code> into a
    first-class module as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> three <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">Three </span><span class="keyword2">:</span> X_int<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val three : (module X_int) = &lt;module&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615224000">The module type doesn't need to be part of the construction of a
    first-class module if it can be inferred. Thus, we can write:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Four </span><span class="keyword2">=</span> <span class="keyword4">struct</span> <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword8">4</span> <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Four : sig val x : int end
</div># <span class="keyword4">let</span> numbers <span class="keyword2">=</span> <span class="keyword2">[</span> three<span class="keyword2">;</span> <span class="keyword2">(</span><span class="keyword4">module</span> Four<span class="keyword2">)</span> <span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val numbers : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615217664">We can also create a first-class module from an anonymous
    module:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> numbers <span class="keyword2">=</span> <span class="keyword2">[</span>three<span class="keyword2">;</span> <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">struct</span> <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword8">4</span> <span class="keyword4">end</span><span class="keyword2">)</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val numbers : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615213232">In order to access the contents of a first-class module, you need to
    unpack it into an ordinary module. This can be done using the <code>val</code> keyword, using this syntax:</p><div class="rwocode"><pre><code><pre>(val &lt;first_class_module&gt; : &lt;Module_type&gt;)
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/unpack.syntax">fcm/unpack.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615209024">And here's an example:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">New_three </span><span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword4">val</span> three <span class="keyword2">:</span> X_int<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module New_three : X_int
</div># <span class="keyword5">New_three.</span>x<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 3
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1><b>Equality of First-Class Module Types</b></h1><p id="idm181615200672">The type of the first-class module, e.g., <code>(module X_int)</code>, is based on the fully
      qualified name of the signature that was used to construct it. A
      first-class module based on a signature with a different name, even if
      it is substantively the same signature, will result in a distinct
      type:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">Y_int </span><span class="keyword2">=</span> X_int<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module type Y_int = X_int
</div># <span class="keyword4">let</span> five <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">struct</span> <span class="keyword4">let</span> x <span class="keyword2">=</span> <span class="keyword8">5</span> <span class="keyword4">end</span> <span class="keyword2">:</span> Y_int<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val five : (module Y_int) = &lt;module&gt;
</div># <span class="keyword2">[</span>three<span class="keyword2">;</span> five<span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 8-12:
Error: This expression has type (module Y_int)
       but an expression was expected of type (module X_int)
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615190432">Even though their types as first-class modules are distinct, the
      underlying module types are compatible (indeed, identical), so we can
      unify the types by unpacking and repacking the module:</p><div class="rwocode"><pre><code># <span class="keyword2">[</span>three<span class="keyword2">;</span> <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword2">(</span><span class="keyword4">val</span> five<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615185888">The way in which type equality for first-class modules is determined can be confusing.
                One common and problematic case is that of creating an alias of a module type
                defined elsewhere. This is often done to improve readability and can happen both
                through an explicit declaration of a module type or implicitly through an <code>include</code> declaration. In both cases, this has the
                unintended side effect of making first-class modules built off the alias
                incompatible with those built off the original module type. To deal with this, we
                should be disciplined in how we refer to signatures when constructing first-class
                    <span>modules</span>.</p></section><p id="idm181615182960">We can also write ordinary functions which consume and create
    first-class modules. The following shows the definition of two functions:
    <code>to_int</code>, which converts a <code>(module X_int)</code> into an <code>int</code>; and <code>plus</code>, which returns the sum of two <code>(module X_int)</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> to_int m <span class="keyword2">=</span>
    <span class="keyword4">let</span> <span class="keyword4">module</span> <span class="keyword6">M </span><span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword4">val</span> m <span class="keyword2">:</span> X_int<span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword5">M.</span>x
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val to_int : (module X_int) -&gt; int = &lt;fun&gt;
</div># <span class="keyword4">let</span> plus m1 m2 <span class="keyword2">=</span>
    <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">struct</span>
       <span class="keyword4">let</span> x <span class="keyword2">=</span> to_int m1 <span class="keyword2">+</span> to_int m2
     <span class="keyword4">end</span> <span class="keyword2">:</span> X_int<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val plus : (module X_int) -&gt; (module X_int) -&gt; (module X_int) = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615168688">With these functions in hand, we can now work with values of type <code>(module X_int)</code> in a more natural style, taking advantage of the concision
            and simplicity of the core <span>language</span>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> six <span class="keyword2">=</span> plus three three<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val six : (module X_int) = &lt;module&gt;
</div># to_int <span class="keyword2">(</span><span class="keyword5">List.</span>fold ~init<span class="keyword2">:</span>six ~f<span class="keyword2">:</span>plus <span class="keyword2">[</span>three<span class="keyword2">;</span>three<span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 12
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615161152">There are some useful syntactic shortcuts when dealing with
    first-class modules. One notable one is that you can do the conversion to
    an ordinary module within a pattern match. Thus, we can rewrite the
    <code>to_int</code> function as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> to_int <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">M </span><span class="keyword2">:</span> X_int<span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">M.</span>x <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val to_int : (module X_int) -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 10) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615155936">First-class modules can contain types and functions in addition to
    simple values like <code>int</code>. Here's an
    interface that contains a type and a corresponding <code>bump</code> operation that takes a value of the type
    and produces a new one:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">Bumpable </span><span class="keyword2">=</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> t
    <span class="keyword4">val</span> bump <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> t
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module type Bumpable = sig type t val bump : t -&gt; t end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 11) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615148048">We can create multiple instances of this module with different
    underlying types:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Int_bumper </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">int</span>
    <span class="keyword4">let</span> bump n <span class="keyword2">=</span> n <span class="keyword2">+</span> <span class="keyword8">1</span>
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Int_bumper : sig type t = int val bump : t -&gt; t end
</div># <span class="keyword4">module</span> <span class="keyword6">Float_bumper </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
     <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">float</span>
     <span class="keyword4">let</span> bump n <span class="keyword2">=</span> n <span class="keyword2">+</span>. <span class="keyword8">1</span>.
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Float_bumper : sig type t = float val bump : t -&gt; t end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 12) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615137824">And we can convert these to first-class modules:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> int_bumper <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">Int_bumper </span><span class="keyword2">:</span> Bumpable<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val int_bumper : (module Bumpable) = &lt;module&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 13) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615133424">But you can't do much with <code>int_bumper</code>, since <code>int_bumper</code> is fully abstract, so that we can no longer
            recover the fact that the type in question is <code>int</code>. </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword4">module</span> Bumpable<span class="keyword2">)</span> <span class="keyword2">=</span> int_bumper <span class="keyword4">in</span> <span class="keyword5">Bumpable.</span>bump <span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 52-53:
Error: This expression has type int but an expression was expected of type
         Bumpable.t
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 14) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615125696">To make <code>int_bumper</code> usable, we
    need to expose the type, which we can do as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> int_bumper <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">Int_bumper </span><span class="keyword2">:</span> <span class="keyword6">Bumpable </span><span class="keyword1">with</span> <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">int</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val int_bumper : (module Bumpable with type t = int) = &lt;module&gt;
</div># <span class="keyword4">let</span> float_bumper <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">Float_bumper </span><span class="keyword2">:</span> <span class="keyword6">Bumpable </span><span class="keyword1">with</span> <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">float</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val float_bumper : (module Bumpable with type t = float) = &lt;module&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 15) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615118576">The sharing constraints we've added above make the resulting
    first-class modules <span>polymorphic</span> in
    the type <code>t</code>. As a result, we can now use
    these values on values of the matching type:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword4">module</span> Bumpable<span class="keyword2">)</span> <span class="keyword2">=</span> int_bumper <span class="keyword4">in</span> <span class="keyword5">Bumpable.</span>bump <span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 4
</div># <span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword4">module</span> Bumpable<span class="keyword2">)</span> <span class="keyword2">=</span> float_bumper <span class="keyword4">in</span> <span class="keyword5">Bumpable.</span>bump <span class="keyword8">3</span>.<span class="keyword8">5</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : float = 4.5
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 16) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615111056">We can also write functions that use such first-class modules
    polymorphically. The following function takes two arguments: a <code>Bumpable</code> module and a list of elements of the
    same type as the type <code>t</code> of the
    module:<a name="idm181615109280"></a><a name="idm181615107968"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> bump_list
       <span class="keyword2">(</span><span class="keyword4">type</span> a<span class="keyword2">)</span>
       <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">B </span><span class="keyword2">:</span> <span class="keyword6">Bumpable </span><span class="keyword1">with</span> <span class="keyword4">type</span> t <span class="keyword2">=</span> a<span class="keyword2">)</span>
       <span class="keyword2">(</span>l<span class="keyword2">:</span> a <span class="keyword3">list</span><span class="keyword2">)</span>
    <span class="keyword2">=</span>
    <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span><span class="keyword5">B.</span>bump l
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val bump_list : (module Bumpable with type t = 'a) -&gt; 'a list -&gt; 'a list =
  &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 17) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615097968">Here, we used a feature of OCaml that hasn't come up before: a <span><em>locally abstract
                type</em></span>. For any function, you can declare a pseudoparameter of the form
                <code>(type a)</code> for any type name <code>a</code> which introduces a fresh type. This type acts like an
            abstract type within the context of the function. In the example above, the locally
            abstract type was used as part of a sharing constraint that ties the type <code>B.t</code> with the type of the elements of the list passed
                in.<a name="idm181615094912"></a><a name="idm181615093600"></a><a name="idm181615092704"></a></p><p id="idm181615091664">The resulting function is polymorphic in both the type of the list
    element and the type <code>Bumpable.t</code>. We can
    see this function in action:</p><div class="rwocode"><pre><code># bump_list int_bumper <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [2; 3; 4]
</div># bump_list float_bumper <span class="keyword2">[</span><span class="keyword8">1</span>.<span class="keyword8">5</span><span class="keyword2">;</span><span class="keyword8">2</span>.<span class="keyword8">5</span><span class="keyword2">;</span><span class="keyword8">3</span>.<span class="keyword8">5</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : float list = [2.5; 3.5; 4.5]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 18) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615084768">Polymorphic first-class modules are important because they allow you
    to connect the types associated with a first-class module to the types of
    other values you're working with.</p><aside class="note"><h1>More on Locally Abstract Types</h1><p id="idm181615083520">One of the key properties of locally abstract types is that
      they're dealt with as abstract types in the function they're defined
      within, but are polymorphic from the outside. Consider the following
      example:<a name="idm181615083024"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> wrap_in_list <span class="keyword2">(</span><span class="keyword4">type</span> a<span class="keyword2">)</span> <span class="keyword2">(</span>x<span class="keyword2">:</span>a<span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword2">[</span>x<span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val wrap_in_list : 'a -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 19) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615077360">This compiles successfully because the type <code>a</code> is used in a way that is compatible with it
      being abstract, but the type of the function that is inferred is
      polymorphic.</p><p id="idm181615076160">If, on the other hand, we try to use the type <code>a</code> as equivalent to some concrete type, say,
      <code>int</code>, then the compiler will
      complain:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> wrap_int_in_list <span class="keyword2">(</span><span class="keyword4">type</span> a<span class="keyword2">)</span> <span class="keyword2">(</span>x<span class="keyword2">:</span>a<span class="keyword2">)</span> <span class="keyword2">=</span> x <span class="keyword2">+</span> x<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 38-39:
Error: This expression has type a but an expression was expected of type int
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 20) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615069776">One common use of locally abstract types is to create a new type
      that can be used in constructing a module. Here's an example of doing
      this to create a new first-class module:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">Comparable </span><span class="keyword2">=</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> t
    <span class="keyword4">val</span> compare <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span>
  <span class="keyword4">end</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module type Comparable = sig type t val compare : t -&gt; t -&gt; int end
</div># <span class="keyword4">let</span> create_comparable <span class="keyword2">(</span><span class="keyword4">type</span> a<span class="keyword2">)</span> compare <span class="keyword2">=</span>
    <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">struct</span>
       <span class="keyword4">type</span> t <span class="keyword2">=</span> a
       <span class="keyword4">let</span> compare <span class="keyword2">=</span> compare
     <span class="keyword4">end</span> <span class="keyword2">:</span> <span class="keyword6">Comparable </span><span class="keyword1">with</span> <span class="keyword4">type</span> t <span class="keyword2">=</span> a<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val create_comparable :
  ('a -&gt; 'a -&gt; int) -&gt; (module Comparable with type t = 'a) = &lt;fun&gt;
</div># create_comparable <span class="keyword5">Int.</span>compare<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (module Comparable with type t = int) = &lt;module&gt;
</div># create_comparable <span class="keyword5">Float.</span>compare<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (module Comparable with type t = float) = &lt;module&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/main.topscript">fcm/main.topscript</a> , continued (part 21) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615053520">Here, what we effectively do is capture a polymorphic type and
      export it as a concrete type within a module.</p><p id="idm181615053008">This technique is useful beyond first-class modules. For example,
      we can use the same approach to construct a local module to be fed to a
      functor.<a name="idm181615052592"></a></p></aside></section><section id="example-a-query-handling-framework"><h1>Example: A Query-Handling Framework</h1><p id="idm181615050704">Now let's look at first-class modules in the context of a more complete and realistic
            example. In particular, consider the following signature for a module that implements a
            system for responding to user-generated queries.<a name="idm181615050192"></a><a name="FCMquery"></a></p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">Query_handler </span><span class="keyword2">=</span> <span class="keyword4">sig</span>

    <span class="comments">(** Configuration for a query handler.  Note that this can be
        converted to and from an s-expression *)</span>
    <span class="keyword4">type</span> config <span class="keyword1">with</span> sexp

    <span class="comments">(** The name of the query-handling service *)</span>
    <span class="keyword4">val</span> name <span class="keyword2">:</span> <span class="keyword3">string</span>

    <span class="comments">(** The state of the query handler *)</span>
    <span class="keyword4">type</span> t

    <span class="comments">(** Creates a new query handler from a config *)</span>
    <span class="keyword4">val</span> create <span class="keyword2">:</span> config -<span class="keyword2">&gt;</span> t

    <span class="comments">(** Evaluate a given query, where both input and output are
        s-expressions *)</span>
    <span class="keyword4">val</span> eval <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>t -<span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>t <span class="keyword5">Or_error.</span>t
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module type Query_handler =
  sig
    type config
    val name : string
    type t
    val create : config -&gt; t
    val eval : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t
    val config_of_sexp : Sexp.t -&gt; config
    val sexp_of_config : config -&gt; Sexp.t
  end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615027040">Here, we used s-expressions as the format for queries and responses, as well as the
            configuration for the query handler. S-expressions are a simple, flexible, and
            human-readable serialization format commonly used in Core. For now, it's enough to think
            of them as balanced parenthetical expressions whose atomic values are strings, e.g.,
                <code>(this (is an) (s expression))</code>.<a name="idm181615025728"></a></p><p id="idm181615024048">In addition, we use the Sexplib syntax extension which extends OCaml
    by adding the <code>with sexp</code> declaration.
    When attached to a type in a signature, <code>with
    sexp</code> adds declarations of s-expression converters, for
    example:<a name="idm181615022288"></a></p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">M </span><span class="keyword2">=</span> <span class="keyword4">sig</span> <span class="keyword4">type</span> t <span class="keyword1">with</span> sexp <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module type M =
  sig type t val t_of_sexp : Sexp.t -&gt; t val sexp_of_t : t -&gt; Sexp.t end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615016640">In a module, <code>with sexp</code> adds the
    implementation of those functions. Thus, we can write:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> u <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">float</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type u = { a : int; b : float; }
val u_of_sexp : Sexp.t -&gt; u = &lt;fun&gt;
val sexp_of_u : u -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_u <span class="keyword2">{</span>a<span class="keyword2">=</span><span class="keyword8">3</span><span class="keyword2">;</span>b<span class="keyword2">=</span><span class="keyword8">7</span>.<span class="keyword2">}</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a 3) (b 7))
</div># u_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((a 43) (b 3.4))&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : u = {a = 43; b = 3.4}
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181615006640">This is all described in more detail in <a href="data-serialization-with-s-expressions.html">Chapter 17, <i>Data Serialization with S-Expressions</i></a>.</p><section id="implementing-a-query-handler"><h1>Implementing a Query Handler</h1><p id="idm181615004752">Let's look at some examples of query handlers that satisfy the
      <code>Query_handler</code> interface. The first
      example is a handler that produces unique integer IDs. It works by
      keeping an internal counter which it bumps every time it produces a new
      value. The input to the query in this case is just the trivial
      s-expression <code>()</code>, otherwise known as
      <code>Sexp.unit</code>:<a name="idm181615002208"></a></p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Unique </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">type</span> config <span class="keyword2">=</span> <span class="keyword3">int</span> <span class="keyword1">with</span> sexp
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> <span class="keyword1">mutable</span> next_id<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword2">}</span>

    <span class="keyword4">let</span> name <span class="keyword2">=</span> <span class="keyword7">&quot;unique&quot;</span>
    <span class="keyword4">let</span> create start_at <span class="keyword2">=</span> <span class="keyword2">{</span> next_id <span class="keyword2">=</span> start_at <span class="keyword2">}</span>

    <span class="keyword4">let</span> eval t sexp <span class="keyword2">=</span>
      <span class="keyword1">match</span> <span class="keyword5">Or_error.</span>try_with <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> unit_of_sexp sexp<span class="keyword2">)</span> <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">Error </span><span class="keyword8">_</span> <span class="keyword1">as</span> err -<span class="keyword2">&gt;</span> err
      <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
        <span class="keyword4">let</span> response <span class="keyword2">=</span> <span class="keyword6">Ok </span><span class="keyword2">(</span><span class="keyword5">Int.</span>sexp_of_t t.next_id<span class="keyword2">)</span> <span class="keyword4">in</span>
        t.next_id <span class="keyword2">&lt;</span>- t.next_id <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">;</span>
        response
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Unique :
  sig
    type config = int
    val config_of_sexp : Sexp.t -&gt; config
    val sexp_of_config : config -&gt; Sexp.t
    type t = { mutable next_id : config; }
    val name : string
    val create : config -&gt; t
    val eval : t -&gt; Sexp.t -&gt; (Sexp.t, Error.t) Result.t
  end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614981648">We can use this module to create an instance of the <code>Unique</code> query handler and interact with it
      directly:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> unique <span class="keyword2">=</span> <span class="keyword5">Unique.</span>create <span class="keyword8">0</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val unique : Unique.t = {Unique.next_id = 0}
</div># <span class="keyword5">Unique.</span>eval unique <span class="keyword5">Sexp.</span>unit<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (Sexp.t, Error.t) Result.t = Ok 0
</div># <span class="keyword5">Unique.</span>eval unique <span class="keyword5">Sexp.</span>unit<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (Sexp.t, Error.t) Result.t = Ok 1
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614972976">Here's another example: a query handler that does directory
      listings. Here, the config is the default directory that relative paths
      are interpreted within:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">List_dir </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">type</span> config <span class="keyword2">=</span> <span class="keyword3">string</span> <span class="keyword1">with</span> sexp
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> cwd<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span>

    <span class="comments">(** [is_abs p] Returns true if [p] is an absolute path  *)</span>
    <span class="keyword4">let</span> is_abs p <span class="keyword2">=</span>
      <span class="keyword5">String.</span>length p <span class="keyword2">&gt;</span> <span class="keyword8">0</span> <span class="keyword2">&amp;&amp;</span> p.<span class="keyword2">[</span><span class="keyword8">0</span><span class="keyword2">]</span> <span class="keyword2">=</span> '/'

    <span class="keyword4">let</span> name <span class="keyword2">=</span> <span class="keyword7">&quot;ls&quot;</span>
    <span class="keyword4">let</span> create cwd <span class="keyword2">=</span> <span class="keyword2">{</span> cwd <span class="keyword2">}</span>

    <span class="keyword4">let</span> eval t sexp <span class="keyword2">=</span>
      <span class="keyword1">match</span> <span class="keyword5">Or_error.</span>try_with <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> string_of_sexp sexp<span class="keyword2">)</span> <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">Error </span><span class="keyword8">_</span> <span class="keyword1">as</span> err -<span class="keyword2">&gt;</span> err
      <span class="keyword2">|</span> <span class="keyword6">Ok </span>dir -<span class="keyword2">&gt;</span>
        <span class="keyword4">let</span> dir <span class="keyword2">=</span>
          <span class="keyword1">if</span> is_abs dir <span class="keyword1">then</span> dir
          <span class="keyword1">else</span> <span class="keyword5">Filename.</span>concat t.cwd dir
        <span class="keyword4">in</span>
        <span class="keyword6">Ok </span><span class="keyword2">(</span><span class="keyword5">Array.</span>sexp_of_t <span class="keyword5">String.</span>sexp_of_t <span class="keyword2">(</span><span class="keyword5">Sys.</span>readdir dir<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module List_dir :
  sig
    type config = string
    val config_of_sexp : Sexp.t -&gt; config
    val sexp_of_config : config -&gt; Sexp.t
    type t = { cwd : config; }
    val is_abs : config -&gt; bool
    val name : config
    val create : config -&gt; t
    val eval : t -&gt; Sexp.t -&gt; (Sexp.t, Error.t) Result.t
  end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614948816">Again, we can create an instance of this query handler and
      interact with it directly:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> list_dir <span class="keyword2">=</span> <span class="keyword5">List_dir.</span>create <span class="keyword7">&quot;/var&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val list_dir : List_dir.t = {List_dir.cwd = &quot;/var&quot;}
</div># <span class="keyword5">List_dir.</span>eval list_dir <span class="keyword2">(</span>sexp_of_string <span class="keyword7">&quot;.&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (Sexp.t, Error.t) Result.t =
Ok
 (agentx at audit backups db empty folders jabberd lib log mail msgs netboot
  networkd root rpc run rwho spool tmp vm yp)
</div># <span class="keyword5">List_dir.</span>eval list_dir <span class="keyword2">(</span>sexp_of_string <span class="keyword7">&quot;yp&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (Sexp.t, Error.t) Result.t = Ok (binding binding~orig)
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="dispatching-to-multiple-query-handlers"><h1>Dispatching to Multiple Query Handlers</h1><p id="idm181614938944">Now, what if we want to dispatch queries to any of an arbitrary
      collection of handlers? Ideally, we'd just like to pass in the handlers
      as a simple data structure like a list. This is awkward to do with
      modules and functors alone, but it's quite natural with first-class
      modules. The first thing we'll need to do is create a signature that
      combines a <code>Query_handler</code> module with
      an instantiated query handler:<a name="idm181614937600"></a></p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">Query_handler_instance </span><span class="keyword2">=</span> <span class="keyword4">sig</span>
    <span class="keyword4">module</span> <span class="keyword6">Query_handler </span><span class="keyword2">:</span> <span class="keyword6">Query_handler
</span>    <span class="keyword4">val</span> this <span class="keyword2">:</span> <span class="keyword5">Query_handler.</span>t
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module type Query_handler_instance =
  sig module Query_handler : Query_handler val this : Query_handler.t end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614929552">With this signature, we can create a first-class module that
      encompasses both an instance of the query and the matching operations
      for working with that query.</p><p id="idm181614928992">We can create an instance as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> unique_instance <span class="keyword2">=</span>
    <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">struct</span>
       <span class="keyword4">module</span> <span class="keyword6">Query_handler </span><span class="keyword2">=</span> <span class="keyword6">Unique
</span>       <span class="keyword4">let</span> this <span class="keyword2">=</span> <span class="keyword5">Unique.</span>create <span class="keyword8">0</span>
     <span class="keyword4">end</span> <span class="keyword2">:</span> Query_handler_instance<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val unique_instance : (module Query_handler_instance) = &lt;module&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614921824">Constructing instances in this way is a little verbose, but we can
      write a function that eliminates most of this boilerplate. Note that we
      are again making use of a locally abstract type:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> build_instance
        <span class="keyword2">(</span><span class="keyword4">type</span> a<span class="keyword2">)</span>
        <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">Q </span><span class="keyword2">:</span> <span class="keyword6">Query_handler </span><span class="keyword1">with</span> <span class="keyword4">type</span> config <span class="keyword2">=</span> a<span class="keyword2">)</span>
        config
    <span class="keyword2">=</span>
    <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">struct</span>
       <span class="keyword4">module</span> <span class="keyword6">Query_handler </span><span class="keyword2">=</span> <span class="keyword6">Q
</span>       <span class="keyword4">let</span> this <span class="keyword2">=</span> <span class="keyword5">Q.</span>create config
     <span class="keyword4">end</span> <span class="keyword2">:</span> Query_handler_instance<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val build_instance :
  (module Query_handler with type config = 'a) -&gt;
  'a -&gt; (module Query_handler_instance) = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614909920">Using <code>build_instance</code>,
      constructing a new instance becomes a one-liner:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> unique_instance <span class="keyword2">=</span> build_instance <span class="keyword2">(</span><span class="keyword4">module</span> Unique<span class="keyword2">)</span> <span class="keyword8">0</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val unique_instance : (module Query_handler_instance) = &lt;module&gt;
</div># <span class="keyword4">let</span> list_dir_instance <span class="keyword2">=</span> build_instance <span class="keyword2">(</span><span class="keyword4">module</span> List_dir<span class="keyword2">)</span>  <span class="keyword7">&quot;/var&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val list_dir_instance : (module Query_handler_instance) = &lt;module&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 10) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614902832">We can now write code that lets you dispatch queries to one of a
      list of query handler instances. We assume that the shape of the query
      is as follows:</p><div class="rwocode"><pre><code><div class="highlight"><span class="p">(</span><span class="nf">query-name</span> <span class="nv">query</span><span class="p">)</span>
</div></code></pre><div class="rwocodeinfo">Scheme ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query-syntax.scm">fcm/query-syntax.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614899664">where <span><em><code>query-name</code></em></span> is the name used to
      determine which query handler to dispatch the query to, and
      <span><em><code>query</code></em></span> is the
      body of the query.</p><p id="idm181614897584">The first thing we'll need is a function that takes a list of
      query handler instances and constructs a dispatch table from it:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> build_dispatch_table handlers <span class="keyword2">=</span>
    <span class="keyword4">let</span> table <span class="keyword2">=</span> <span class="keyword5">String.</span><span class="keyword5">Table.</span>create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword5">List.</span>iter handlers
      ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">I </span><span class="keyword2">:</span> Query_handler_instance<span class="keyword2">)</span> <span class="keyword1">as</span> instance<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
        <span class="keyword5">Hashtbl.</span>replace table ~key<span class="keyword2">:</span><span class="keyword5">I.</span><span class="keyword5">Query_handler.</span>name ~data<span class="keyword2">:</span>instance<span class="keyword2">)</span><span class="keyword2">;</span>
    table
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val build_dispatch_table :
  (module Query_handler_instance) list -&gt;
  (module Query_handler_instance) String.Table.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 11) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614887536">Now, we need a function that dispatches to a handler using a
      dispatch table:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> dispatch dispatch_table name_and_query <span class="keyword2">=</span>
    <span class="keyword1">match</span> name_and_query <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword5">Sexp.List </span><span class="keyword2">[</span><span class="keyword5">Sexp.Atom </span>name<span class="keyword2">;</span> query<span class="keyword2">]</span> -<span class="keyword2">&gt;</span>
      <span class="keyword4">begin</span> <span class="keyword1">match</span> <span class="keyword5">Hashtbl.</span>find dispatch_table name <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span>
        <span class="keyword5">Or_error.</span>error <span class="keyword7">&quot;Could not find matching handler&quot;</span>
          name <span class="keyword5">String.</span>sexp_of_t
      <span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">I </span><span class="keyword2">:</span> Query_handler_instance<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
        <span class="keyword5">I.</span><span class="keyword5">Query_handler.</span>eval <span class="keyword5">I.</span>this query
      <span class="keyword4">end</span>
    <span class="keyword2">|</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span>
      <span class="keyword5">Or_error.</span>error_string <span class="keyword7">&quot;malformed query&quot;</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val dispatch :
  (string, (module Query_handler_instance)) Hashtbl.t -&gt;
  Sexp.t -&gt; Sexp.t Or_error.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 12) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614873584">This function interacts with an instance by unpacking it into a
      module <code>I</code> and then using the query
      handler instance (<code>I.this</code>) in concert
      with the associated module (<code>I.Query_handler</code>).<a name="idm181614871312"></a></p><p id="idm181614870304">The bundling together of the module and the value is in many ways
      reminiscent of object-oriented languages. One key difference, is that
      first-class modules allow you to package up more than just functions or
      methods. As we've seen, you can also include types and even modules.
      We've only used it in a small way here, but this extra power allows you
      to build more sophisticated components that involve multiple
      interdependent types and values.</p><p id="idm181614869920">Now let's turn this into a complete, running example by adding a
      command-line interface:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> cli dispatch_table <span class="keyword2">=</span>
    printf <span class="keyword7">&quot;&gt;&gt;&gt; %!&quot;</span><span class="keyword2">;</span>
    <span class="keyword4">let</span> result <span class="keyword2">=</span>
      <span class="keyword1">match</span> <span class="keyword5">In_channel.</span>input_line stdin <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword6">`Stop
</span>      <span class="keyword2">|</span> <span class="keyword6">Some </span>line -<span class="keyword2">&gt;</span>
        <span class="keyword1">match</span> <span class="keyword5">Or_error.</span>try_with <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>of_string line<span class="keyword2">)</span> <span class="keyword1">with</span>
        <span class="keyword2">|</span> <span class="keyword6">Error </span>e -<span class="keyword2">&gt;</span> <span class="keyword6">`Continue </span><span class="keyword2">(</span><span class="keyword5">Error.</span>to_string_hum e<span class="keyword2">)</span>
        <span class="keyword2">|</span> <span class="keyword6">Ok </span><span class="keyword2">(</span><span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;quit&quot;</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword6">`Stop
</span>        <span class="keyword2">|</span> <span class="keyword6">Ok </span>query -<span class="keyword2">&gt;</span>
          <span class="keyword4">begin</span> <span class="keyword1">match</span> dispatch dispatch_table query <span class="keyword1">with</span>
          <span class="keyword2">|</span> <span class="keyword6">Error </span>e -<span class="keyword2">&gt;</span> <span class="keyword6">`Continue </span><span class="keyword2">(</span><span class="keyword5">Error.</span>to_string_hum e<span class="keyword2">)</span>
          <span class="keyword2">|</span> <span class="keyword6">Ok </span>s    -<span class="keyword2">&gt;</span> <span class="keyword6">`Continue </span><span class="keyword2">(</span><span class="keyword5">Sexp.</span>to_string_hum s<span class="keyword2">)</span>
          <span class="keyword4">end</span><span class="keyword2">;</span>
    <span class="keyword4">in</span>
    <span class="keyword1">match</span> result <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">`Stop </span>-<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span>
    <span class="keyword2">|</span> <span class="keyword6">`Continue </span>msg -<span class="keyword2">&gt;</span>
      printf <span class="keyword7">&quot;%s\n%!&quot;</span> msg<span class="keyword2">;</span>
      cli dispatch_table
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val cli : (string, (module Query_handler_instance)) Hashtbl.t -&gt; unit = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 13) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614850720">We can most effectively run this command-line interface from a
      standalone program, which we can do by putting the above code in a file
      along with following command to launch the interface:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  cli <span class="keyword2">(</span>build_dispatch_table <span class="keyword2">[</span>unique_instance<span class="keyword2">;</span> list_dir_instance<span class="keyword2">]</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.ml">fcm/query_handler.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614847712">Here's an example of a session with this program:</p><div class="rwocode"><pre><code><div class="rwocodeout">$ ./query_handler.byte 
&gt;&gt;&gt; (unique ())
0
&gt;&gt;&gt; (unique ())
1
&gt;&gt;&gt; (ls .)
(agentx at audit backups db empty folders jabberd lib log mail msgs named
 netboot pgsql_socket_alt root rpc run rwho spool tmp vm yp)
&gt;&gt;&gt; (ls vm)
(sleepimage swapfile0 swapfile1 swapfile2 swapfile3 swapfile4 swapfile5
 swapfile6)</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_example.rawscript">fcm/query_example.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="loading-and-unloading-query-handlers"><h1>Loading and Unloading Query Handlers</h1><p id="idm181614842832">One of the advantages of first-class modules is that they afford a
      great deal of dynamism and flexibility. For example, it's a fairly
      simple matter to change our design to allow query handlers to be loaded
      and unloaded at runtime.<a name="idm181614842320"></a></p><p id="idm181614840880">We'll do this by creating a query handler whose job is to control
      the set of active query handlers. The module in question will be called
      <code>Loader</code>, and its configuration is a
      list of known <code>Query_handler</code> modules.
      Here are the basic types:</p><div class="rwocode"><pre><code><span class="keyword4">module</span> <span class="keyword6">Loader </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
  <span class="keyword4">type</span> config <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword4">module</span> Query_handler<span class="keyword2">)</span> <span class="keyword3">list</span> sexp_opaque
  <span class="keyword1">with</span> sexp

  <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> known  <span class="keyword2">:</span> <span class="keyword2">(</span><span class="keyword4">module</span> Query_handler<span class="keyword2">)</span>          <span class="keyword5">String.</span><span class="keyword5">Table.</span>t
           <span class="keyword2">;</span> active <span class="keyword2">:</span> <span class="keyword2">(</span><span class="keyword4">module</span> Query_handler_instance<span class="keyword2">)</span> <span class="keyword5">String.</span><span class="keyword5">Table.</span>t
           <span class="keyword2">}</span>

  <span class="keyword4">let</span> name <span class="keyword2">=</span> <span class="keyword7">&quot;loader&quot;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler_core.ml">fcm/query_handler_core.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614836320">Note that a <code>Loader.t</code> has two
      tables: one containing the known query handler modules, and one
      containing the active query handler instances. The <code>Loader.t</code> will be responsible for creating new
      instances and adding them to the table, as well as for removing
      instances, all in response to user queries.</p><p id="idm181614834480">Next, we'll need a function for creating a <code>Loader.t</code>. This function requires the list of
      known query handler modules. Note that the table of active modules
      starts out as empty:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> create known_list <span class="keyword2">=</span>
    <span class="keyword4">let</span> active <span class="keyword2">=</span> <span class="keyword5">String.</span><span class="keyword5">Table.</span>create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword4">let</span> known  <span class="keyword2">=</span> <span class="keyword5">String.</span><span class="keyword5">Table.</span>create <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword5">List.</span>iter known_list
      ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">Q </span><span class="keyword2">:</span> Query_handler<span class="keyword2">)</span> <span class="keyword1">as</span> q<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
        <span class="keyword5">Hashtbl.</span>replace known ~key<span class="keyword2">:</span><span class="keyword5">Q.</span>name ~data<span class="keyword2">:</span>q<span class="keyword2">)</span><span class="keyword2">;</span>
    <span class="keyword2">{</span> known<span class="keyword2">;</span> active <span class="keyword2">}</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler_core.ml">fcm/query_handler_core.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614830336">Now we'll start writing out the functions for manipulating the
      table of active query handlers. We'll start with the function for
      loading an instance. Note that it takes as an argument both the name of
      the query handler and the configuration for instantiating that handler
      in the form of an s-expression. These are used for creating a
      first-class module of type <code>(module
      Query_handler_instance)</code>, which is then added to the active
      table:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> load t handler_name config <span class="keyword2">=</span>
    <span class="keyword1">if</span> <span class="keyword5">Hashtbl.</span>mem t.active handler_name <span class="keyword1">then</span>
      <span class="keyword5">Or_error.</span>error <span class="keyword7">&quot;Can't re-register an active handler&quot;</span>
        handler_name <span class="keyword5">String.</span>sexp_of_t
    <span class="keyword1">else</span>
      <span class="keyword1">match</span> <span class="keyword5">Hashtbl.</span>find t.known handler_name <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span>
        <span class="keyword5">Or_error.</span>error <span class="keyword7">&quot;Unknown handler&quot;</span> handler_name <span class="keyword5">String.</span>sexp_of_t
      <span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword6">Q </span><span class="keyword2">:</span> Query_handler<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
        <span class="keyword4">let</span> instance <span class="keyword2">=</span>
          <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">struct</span>
             <span class="keyword4">module</span> <span class="keyword6">Query_handler </span><span class="keyword2">=</span> <span class="keyword6">Q
</span>             <span class="keyword4">let</span> this <span class="keyword2">=</span> <span class="keyword5">Q.</span>create <span class="keyword2">(</span><span class="keyword5">Q.</span>config_of_sexp config<span class="keyword2">)</span>
           <span class="keyword4">end</span> <span class="keyword2">:</span> Query_handler_instance<span class="keyword2">)</span>
        <span class="keyword4">in</span>
        <span class="keyword5">Hashtbl.</span>replace t.active ~key<span class="keyword2">:</span>handler_name ~data<span class="keyword2">:</span>instance<span class="keyword2">;</span>
        <span class="keyword6">Ok </span><span class="keyword5">Sexp.</span>unit</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler_core.ml">fcm/query_handler_core.ml</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614826464">Since the <code>load</code> function will
      refuse to <code>load</code> an already active
      handler, we also need the ability to unload a handler. Note that the
      handler explicitly refuses to unload itself:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> unload t handler_name <span class="keyword2">=</span>
    <span class="keyword1">if</span> not <span class="keyword2">(</span><span class="keyword5">Hashtbl.</span>mem t.active handler_name<span class="keyword2">)</span> <span class="keyword1">then</span>
      <span class="keyword5">Or_error.</span>error <span class="keyword7">&quot;Handler not active&quot;</span> handler_name <span class="keyword5">String.</span>sexp_of_t
    <span class="keyword1">else</span> <span class="keyword1">if</span> handler_name <span class="keyword2">=</span> name <span class="keyword1">then</span>
      <span class="keyword5">Or_error.</span>error_string <span class="keyword7">&quot;It's unwise to unload yourself&quot;</span>
    <span class="keyword1">else</span> <span class="keyword2">(</span>
      <span class="keyword5">Hashtbl.</span>remove t.active handler_name<span class="keyword2">;</span>
      <span class="keyword6">Ok </span><span class="keyword5">Sexp.</span>unit
    <span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler_core.ml">fcm/query_handler_core.ml</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614821904">Finally, we need to implement the <code>eval</code> function,
                which will determine the query <span>interface</span>
                presented to the user. We'll do this by creating a variant type, and using the
                s-expression converter generated for that type to parse the query from the
                user:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> request <span class="keyword2">=</span>
    <span class="keyword2">|</span> <span class="keyword6">Load </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword5">Sexp.</span>t
    <span class="keyword2">|</span> <span class="keyword6">Unload </span><span class="keyword2">of</span> <span class="keyword3">string</span>
    <span class="keyword2">|</span> <span class="keyword6">Known_services
</span>    <span class="keyword2">|</span> <span class="keyword6">Active_services
</span>  <span class="keyword1">with</span> sexp</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler_core.ml">fcm/query_handler_core.ml</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614817424">The <code>eval</code> function itself is fairly straightforward, dispatching to
                the appropriate functions to respond to each type of query. Note that we write
                    <code>&lt;:sexp_of&lt;string list&gt;&gt;</code> to
                autogenerate a function for converting a list of strings to an s-expression, as
                described in <a href="data-serialization-with-s-expressions.html">Chapter 17, <i>Data Serialization with S-Expressions</i></a>.</p><p id="idm181614815232">This function ends the definition of the <code>Loader</code> module:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> eval t sexp <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword5">Or_error.</span>try_with <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> request_of_sexp sexp<span class="keyword2">)</span> <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Error </span><span class="keyword8">_</span> <span class="keyword1">as</span> err -<span class="keyword2">&gt;</span> err
    <span class="keyword2">|</span> <span class="keyword6">Ok </span>resp -<span class="keyword2">&gt;</span>
      <span class="keyword1">match</span> resp <span class="keyword1">with</span>
      <span class="keyword2">|</span> <span class="keyword6">Load </span><span class="keyword2">(</span>name,config<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> load   t name config
      <span class="keyword2">|</span> <span class="keyword6">Unload </span>name        -<span class="keyword2">&gt;</span> unload t name
      <span class="keyword2">|</span> <span class="keyword6">Known_services </span>-<span class="keyword2">&gt;</span>
        <span class="keyword6">Ok </span><span class="keyword2">(</span><span class="keyword1">&lt;:sexp_of&lt;</span><span class="keyword3">string</span> <span class="keyword3">list</span><span class="keyword1">&gt;&gt;</span> <span class="keyword2">(</span><span class="keyword5">Hashtbl.</span>keys t.known<span class="keyword2">)</span><span class="keyword2">)</span>
      <span class="keyword2">|</span> <span class="keyword6">Active_services </span>-<span class="keyword2">&gt;</span>
        <span class="keyword6">Ok </span><span class="keyword2">(</span><span class="keyword1">&lt;:sexp_of&lt;</span><span class="keyword3">string</span> <span class="keyword3">list</span><span class="keyword1">&gt;&gt;</span> <span class="keyword2">(</span><span class="keyword5">Hashtbl.</span>keys t.active<span class="keyword2">)</span><span class="keyword2">)</span>
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler_core.ml">fcm/query_handler_core.ml</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614811776">Finally, we can put this all together with the command-line
      interface. We first create an instance of the loader query handler and
      then add that instance to the loader's active table. We can then just
      launch the command-line interface, passing it the active table:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> loader <span class="keyword2">=</span> <span class="keyword5">Loader.</span>create <span class="keyword2">[</span><span class="keyword2">(</span><span class="keyword4">module</span> Unique<span class="keyword2">)</span><span class="keyword2">;</span> <span class="keyword2">(</span><span class="keyword4">module</span> List_dir<span class="keyword2">)</span><span class="keyword2">]</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> loader_instance <span class="keyword2">=</span>
    <span class="keyword2">(</span><span class="keyword4">module</span> <span class="keyword4">struct</span>
       <span class="keyword4">module</span> <span class="keyword6">Query_handler </span><span class="keyword2">=</span> <span class="keyword6">Loader
</span>       <span class="keyword4">let</span> this <span class="keyword2">=</span> loader
     <span class="keyword4">end</span> <span class="keyword2">:</span> Query_handler_instance<span class="keyword2">)</span>
  <span class="keyword4">in</span>
  <span class="keyword5">Hashtbl.</span>replace loader.<span class="keyword5">Loader.</span>active
    ~key<span class="keyword2">:</span><span class="keyword5">Loader.</span>name ~data<span class="keyword2">:</span>loader_instance<span class="keyword2">;</span>
  cli loader.<span class="keyword5">Loader.</span>active</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler_loader.ml">fcm/query_handler_loader.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614791600">Now build this into a command-line interface to experiment with it:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild query_handler_loader.byte
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/build_query_handler_loader.out">fcm/build_query_handler_loader.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614787888">The resulting command-line interface behaves much as you'd expect,
      starting out with no query handlers available but giving you the ability
      to load and unload them. Here's an example of it in action. As you can
      see, we start out with <code>loader</code> itself
      as the only active handler:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./query_handler_loader.byte
</div><div class="rwocodeout">&gt;&gt;&gt; (loader known_services)</div><div class="rwocodeout">(ls unique)</div><div class="rwocodeout">&gt;&gt;&gt; (loader active_services)</div><div class="rwocodeout">(loader)</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/loader_cli1.out">fcm/loader_cli1.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614780816">Any attempt to use an inactive query handler will fail:</p><div class="rwocode"><pre><code><div class="rwocodeout">&gt;&gt;&gt; (ls .)</div><div class="rwocodeout">Could not find matching handler: ls</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/loader_cli2.out">fcm/loader_cli2.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614777104">But, we can load the <code>ls</code> handler
      with a config of our choice, at which point it will be available for
      use. And once we unload it, it will be unavailable yet again and could
      be reloaded with a different config:</p><div class="rwocode"><pre><code><div class="rwocodeout">&gt;&gt;&gt; (loader (load ls /var))</div><div class="rwocodeout">()</div><div class="rwocodeout">&gt;&gt;&gt; (ls /var)</div><div class="rwocodeout">(agentx at audit backups db empty folders jabberd lib log mail msgs named</div><div class="rwocodeout"> netboot pgsql_socket_alt root rpc run rwho spool tmp vm yp)</div><div class="rwocodeout">&gt;&gt;&gt; (loader (unload ls))</div><div class="rwocodeout">()</div><div class="rwocodeout">&gt;&gt;&gt; (ls /var)</div><div class="rwocodeout">Could not find matching handler: ls</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/loader_cli3.out">fcm/loader_cli3.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614767888">Notably, the loader can't be loaded (since it's not on the list of
      known handlers) and can't be unloaded either:</p><div class="rwocode"><pre><code><div class="rwocodeout">&gt;&gt;&gt; (loader (unload loader))</div><div class="rwocodeout">It's unwise to unload yourself</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/loader_cli4.out">fcm/loader_cli4.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614764096">Although we won't describe the details here, we can push this dynamism yet further
                using OCaml's dynamic linking facilities, which allow you to compile and link in new
                code to a running program. This can be automated using libraries like
                    <code>ocaml_plugin</code>, which can be installed via OPAM, and which
                automates much of the workflow around setting up dynamic linking. <a name="idm181614763008"></a> </p></section></section><section id="living-without-first-class-modules"><h1>Living Without First-Class Modules</h1><p id="idm181614760928">It's worth noting that most designs that can be done with
    first-class modules can be simulated without them, with some level of
    awkwardness. For example, we could rewrite our query handler example
    without first-class modules using the following types:<a name="idm181614760400"></a></p><div class="rwocode"><pre><code># <span class="keyword4">type</span> query_handler_instance <span class="keyword2">=</span> <span class="keyword2">{</span> name <span class="keyword2">:</span> <span class="keyword3">string</span>
                                <span class="keyword2">;</span> eval <span class="keyword2">:</span> <span class="keyword5">Sexp.</span>t -<span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>t <span class="keyword5">Or_error.</span>t
                                <span class="keyword2">}</span>
  <span class="keyword4">type</span> query_handler <span class="keyword2">=</span> <span class="keyword5">Sexp.</span>t -<span class="keyword2">&gt;</span> query_handler_instance
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type query_handler_instance = {
  name : string;
  eval : Sexp.t -&gt; Sexp.t Or_error.t;
}
type query_handler = Sexp.t -&gt; query_handler_instance
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 14) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614749616">The idea here is that we hide the true types of the objects in
    question behind the functions stored in the closure. Thus, we could put
    the <code>Unique</code> query handler into this
    framework as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> unique_handler config_sexp <span class="keyword2">=</span>
    <span class="keyword4">let</span> config <span class="keyword2">=</span> <span class="keyword5">Unique.</span>config_of_sexp config_sexp <span class="keyword4">in</span>
    <span class="keyword4">let</span> unique <span class="keyword2">=</span> <span class="keyword5">Unique.</span>create config <span class="keyword4">in</span>
    <span class="keyword2">{</span> name <span class="keyword2">=</span> <span class="keyword5">Unique.</span>name
    <span class="keyword2">;</span> eval <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword1">fun</span> config -<span class="keyword2">&gt;</span> <span class="keyword5">Unique.</span>eval unique config<span class="keyword2">)</span>
    <span class="keyword2">}</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val unique_handler : Sexp.t -&gt; query_handler_instance = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/fcm/query_handler.topscript">fcm/query_handler.topscript</a> , continued (part 15) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm181614740432">For an example on this scale, the preceding approach is completely
    reasonable, and first-class modules are not really necessary. But the more
    functionality you need to hide away behind a set of closures, and the more
    complicated the relationships between the different types in question, the
    more awkward this approach becomes, and the better it is to use
    first-class modules.<a name="idm181614739776"></a></p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="functors.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="objects.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>
