<html>

    <head>
    
        <meta charset="utf-8"></meta>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"></meta>
        
        <title>Chapter 23. The Compiler Backend: Bytecode and Native code / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"></link>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'realworldocaml',
                        repo: 'book',
                        milestone: 'v1',
                        page: 'the\u002Dcompiler\u002Dbackend\u002Dbyte\u002Dcode\u002Dand\u002Dnative\u002Dcode.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <i>Available in <a href="http://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/">print</a> and <a href="http://oreil.ly/realworldOCaml">eBook!</a></i>
                <h1><a href="http://oreil.ly/realworldOCaml"><img src="../../media/img/cover-cut.png" width="245" alt="Real World OCaml, by Yaron Minsky, Anil Madhavapeddy and Jason Hickey"></img></a></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html">19. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="memory-representation-of-values.html">20. Memory Representation of Values</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">21. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-frontend-parsing-and-type-checking.html">22. The Compiler Frontend: Parsing and Type
    Checking</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-backend-byte-code-and-native-code.html" class="here">23. The Compiler Backend: Bytecode and Native code</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="ix01.html">Index</a>
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 23. The Compiler Backend: Bytecode and Native code</h1>
                
                

    <p id="idm449005500704">Once OCaml has passed the type checking stage, it can stop emitting
  syntax and type errors and begin the process of compiling the well-formed
  modules into executable code.</p><p id="idm449005500144">In this chapter, we'll cover the following topics:</p><ul><li><p id="idm449005499184">The untyped intermediate lambda code where pattern matching is
      optimized</p></li><li><p id="idm449005498336">The bytecode <span><strong>ocamlc</strong></span> compiler
      and <span><strong>ocamlrun</strong></span> interpreter</p></li><li><p id="idm449005496224">The native code <span><strong>ocamlopt</strong></span> code
      generator, and debugging and profiling native code</p></li></ul><section id="the-untyped-lambda-form"><h1>The Untyped Lambda Form</h1><p id="idm449005493920">The first code generation phase eliminates all the static type
    information into a simpler intermediate <span><em>lambda form</em></span>.
    The lambda form discards higher-level constructs such as modules and
    objects and replaces them with simpler values such as records and function
    pointers. Pattern matches are also analyzed and compiled into highly
    optimized automata.<a name="idm449005492896"></a><a name="CPuntype"></a></p><p id="idm449005489888">The lambda form is the key stage that discards the OCaml type information and maps the
      source code to the runtime memory model described in <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a>. This stage also performs some optimizations,
      most notably converting pattern-match statements into more optimized but low-level
      statements.</p><section id="pattern-matching-optimization"><h1>Pattern Matching Optimization</h1><p id="idm449005487744">The compiler dumps the lambda form in an s-expression syntax if you add the <span><code>-dlambda</code></span> directive to the
        command line. Let's use this to learn more about how the OCaml pattern-matching engine works
        by building three different pattern matches and comparing their lambda forms.<a name="idm449005486192"></a><a name="idm449005484848"></a></p><p id="idm449005483392">Let's start by creating a straightforward exhaustive pattern match
      using four normal variants:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Alice </span><span class="keyword2">|</span> <span class="keyword6">Bob </span><span class="keyword2">|</span> <span class="keyword6">Charlie </span><span class="keyword2">|</span> <span class="keyword6">David
</span>
<span class="keyword4">let</span> test v <span class="keyword2">=</span>
  <span class="keyword1">match</span> v <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
  <span class="keyword2">|</span> <span class="keyword6">Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span>
  <span class="keyword2">|</span> <span class="keyword6">Charlie </span>-<span class="keyword2">&gt;</span> <span class="keyword8">102</span>
  <span class="keyword2">|</span> <span class="keyword6">David </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">103</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/pattern_monomorphic_large.ml">back-end/pattern_monomorphic_large.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005480416">The lambda output for this code looks like this:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dlambda -c pattern_monomorphic_large.ml 2&gt;&amp;1
</div><div class="rwocodeout">(setglobal Pattern_monomorphic_large!</div><div class="rwocodeout">  (let</div><div class="rwocodeout">    (test/1013</div><div class="rwocodeout">       (function v/1014</div><div class="rwocodeout">         (switch* v/1014</div><div class="rwocodeout">          case int 0: 100</div><div class="rwocodeout">          case int 1: 101</div><div class="rwocodeout">          case int 2: 102</div><div class="rwocodeout">          case int 3: 103)))</div><div class="rwocodeout">    (makeblock 0 test/1013)))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/lambda_for_pattern_monomorphic_large.out">back-end/lambda_for_pattern_monomorphic_large.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005470256">It's not important to understand every detail of this internal
      form, and it is explicitly undocumented since it can change across
      compiler revisions. Despite these caveats, some interesting points
      emerge from reading it:</p><ul><li><p id="idm449005469120">There are no mention of modules or types any more. Global
          values are created via <code>setglobal</code>,
          and OCaml values are constructed by <code>makeblock</code>. The blocks are the runtime
          values you should remember from <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a>.</p></li><li><p id="idm449005466384">The pattern match has turned into a switch case that jumps to the right case
            depending on the header tag of <code>v</code>. Recall that
            variants without parameters are stored in memory as integers in the order which they
            appear. The pattern-matching engine knows this and has transformed the pattern into an
            efficient jump table.</p></li><li><p id="idm449005464608">Values are addressed by a unique name that distinguishes shadowed values by
            appending a number (e.g., <code>v/1014</code>). The type safety
            checks in the earlier phase ensure that these low-level accesses never violate runtime
            memory safety, so this layer doesn't do any dynamic checks. Unwise use of unsafe
            features such as the <code>Obj.magic</code> module can still
            easily induce crashes at this level.</p></li></ul><p id="idm449005462224">The compiler computes a jump table in order to handle all four
      cases. If we drop the number of variants to just two, then there's no
      need for the complexity of computing this table:</p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Alice </span><span class="keyword2">|</span> <span class="keyword6">Bob </span>

<span class="keyword4">let</span> test v <span class="keyword2">=</span>
  <span class="keyword1">match</span> v <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
  <span class="keyword2">|</span> <span class="keyword6">Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/pattern_monomorphic_small.ml">back-end/pattern_monomorphic_small.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005459200">The lambda output for this code is now quite different:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dlambda -c pattern_monomorphic_small.ml 2&gt;&amp;1
</div><div class="rwocodeout">(setglobal Pattern_monomorphic_small!</div><div class="rwocodeout">  (let (test/1011 (function v/1012 (if (!= v/1012 0) 101 100)))</div><div class="rwocodeout">    (makeblock 0 test/1011)))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/lambda_for_pattern_monomorphic_small.out">back-end/lambda_for_pattern_monomorphic_small.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005453616">The compiler emits simpler conditional jumps rather than setting
      up a jump table, since it statically determines that the range of
      possible variants is small enough. Finally, let's look at the same code,
      but with polymorphic variants instead of normal variants:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> test v <span class="keyword2">=</span>
  <span class="keyword1">match</span> v <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">`Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
  <span class="keyword2">|</span> <span class="keyword6">`Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span>
  <span class="keyword2">|</span> <span class="keyword6">`Charlie </span>-<span class="keyword2">&gt;</span> <span class="keyword8">102</span>
  <span class="keyword2">|</span> <span class="keyword6">`David </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">103</span>
  <span class="keyword2">|</span> <span class="keyword6">`Eve </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">104</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/pattern_polymorphic.ml">back-end/pattern_polymorphic.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005450368">The lambda form for this also shows up the runtime representation
      of polymorphic variants:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dlambda -c pattern_polymorphic.ml 2&gt;&amp;1
</div><div class="rwocodeout">(setglobal Pattern_polymorphic!</div><div class="rwocodeout">  (let</div><div class="rwocodeout">    (test/1008</div><div class="rwocodeout">       (function v/1009</div><div class="rwocodeout">         (if (!= v/1009 3306965)</div><div class="rwocodeout">           (if (&gt;= v/1009 482771474) (if (&gt;= v/1009 884917024) 100 102)</div><div class="rwocodeout">             (if (&gt;= v/1009 3457716) 104 103))</div><div class="rwocodeout">           101)))</div><div class="rwocodeout">    (makeblock 0 test/1008)))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/lambda_for_pattern_polymorphic.out">back-end/lambda_for_pattern_polymorphic.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005440688">We mentioned in <a href="variants.html">Chapter 6, <i>Variants</i></a> that pattern matching over polymorphic
        variants is slightly less efficient, and it should be clearer why this is the case now.
        Polymorphic variants have a runtime value that's calculated by hashing the variant name, and
        so the compiler can't use a jump table as it does for normal variants. Instead, it creates a
        decision tree that compares the hash values against the input variable in as few comparisons
        as possible.<a name="idm449005439440"></a></p><aside class="note"><h1>Learning More About Pattern Matching Compilation</h1><p id="idm449005437280">Pattern matching is an important part of OCaml programming.
        You'll often encounter deeply nested pattern matches over complex data
        structures in real code. A good paper that describes the fundamental
        algorithms implemented in OCaml is <a href="http://dl.acm.org/citation.cfm?id=507641" target="_top">&quot;Optimizing pattern
        matching&quot;</a> by Fabrice Le Fessant and Luc Maranget.</p><p id="idm449005435920">The paper describes the backtracking algorithm used in classical pattern matching
          compilation, and also several OCaml-specific optimizations, such as the use of
          exhaustiveness information and control flow optimizations via static exceptions.</p><p id="idm449005435264">It's not essential that you understand all of this just to use
        pattern matching, of course, but it'll give you insight as to why
        pattern matching is such a lightweight language construct to use in
        OCaml code.</p></aside></section><section id="benchmarking-pattern-matching"><h1>Benchmarking Pattern Matching</h1><p id="idm449005433456">Let's benchmark these three pattern-matching techniques to quantify their runtime costs
        more accurately. The <code>Core_bench</code> module runs the tests
        thousands of times and also calculates statistical variance of the results. You'll need to
          <code>opam install core_bench</code> to get the library:<a name="idm449005431600"></a><a name="idm449005430288"></a></p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Core_bench.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">Alice </span><span class="keyword2">|</span> <span class="keyword6">Bob </span>
<span class="keyword4">type</span> s <span class="keyword2">=</span> <span class="keyword2">|</span> <span class="keyword6">A </span><span class="keyword2">|</span> <span class="keyword6">B </span><span class="keyword2">|</span> <span class="keyword6">C </span><span class="keyword2">|</span> <span class="keyword6">D </span><span class="keyword2">|</span> <span class="keyword6">E
</span>
<span class="keyword4">let</span> polymorphic_pattern <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> test v <span class="keyword2">=</span>
    <span class="keyword1">match</span> v <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">`Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
    <span class="keyword2">|</span> <span class="keyword6">`Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span>
    <span class="keyword2">|</span> <span class="keyword6">`Charlie </span>-<span class="keyword2">&gt;</span> <span class="keyword8">102</span>
    <span class="keyword2">|</span> <span class="keyword6">`David </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">103</span>
    <span class="keyword2">|</span> <span class="keyword6">`Eve </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">104</span>
  <span class="keyword4">in</span>
  <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> v -<span class="keyword2">&gt;</span> ignore<span class="keyword2">(</span>test v<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">[</span>`Alice<span class="keyword2">;</span> `Bob<span class="keyword2">;</span> `Charlie<span class="keyword2">;</span> `David<span class="keyword2">]</span>

<span class="keyword4">let</span> monomorphic_pattern_small <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> test v <span class="keyword2">=</span>
    <span class="keyword1">match</span> v <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Alice </span>  -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
    <span class="keyword2">|</span> <span class="keyword6">Bob </span>    -<span class="keyword2">&gt;</span> <span class="keyword8">101</span> <span class="keyword4">in</span>
  <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> v -<span class="keyword2">&gt;</span> ignore<span class="keyword2">(</span>test v<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">[</span> Alice<span class="keyword2">;</span> <span class="keyword6">Bob </span><span class="keyword2">]</span>

<span class="keyword4">let</span> monomorphic_pattern_large <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> test v <span class="keyword2">=</span>
    <span class="keyword1">match</span> v <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">A </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">100</span>
    <span class="keyword2">|</span> <span class="keyword6">B </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">101</span>
    <span class="keyword2">|</span> <span class="keyword6">C </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">102</span>
    <span class="keyword2">|</span> <span class="keyword6">D </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">103</span>
    <span class="keyword2">|</span> <span class="keyword6">E </span>      -<span class="keyword2">&gt;</span> <span class="keyword8">104</span>
  <span class="keyword4">in</span>
  <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> v -<span class="keyword2">&gt;</span> ignore<span class="keyword2">(</span>test v<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">[</span> A<span class="keyword2">;</span> B<span class="keyword2">;</span> C<span class="keyword2">;</span> <span class="keyword6">D </span><span class="keyword2">]</span>

<span class="keyword4">let</span> tests <span class="keyword2">=</span> <span class="keyword2">[</span>
  <span class="keyword7">&quot;Polymorphic pattern&quot;</span>, polymorphic_pattern<span class="keyword2">;</span>
  <span class="keyword7">&quot;Monomorphic larger pattern&quot;</span>, monomorphic_pattern_large<span class="keyword2">;</span>
  <span class="keyword7">&quot;Monomorphic small pattern&quot;</span>, monomorphic_pattern_small<span class="keyword2">;</span>
<span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">List.</span>map tests ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>name,test<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create ~name test<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span>make_command
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/bench_patterns.ml">back-end-bench/bench_patterns.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005426448">Building and executing this example will run for around 30 seconds
      by default, and you'll see the results summarized in a neat
      table:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg core_bench bench_patterns.native
</div><div class="highlight"><span class="gp">$</span> ./bench_patterns.native -ascii
</div><div class="rwocodeout">Estimated testing time 30s (change using -quota SECS).</div><div class="rwocodeout">                                                    </div><div class="rwocodeout">  Name                         Time/Run   % of max  </div><div class="rwocodeout"> ---------------------------- ---------- ---------- </div><div class="rwocodeout">  Polymorphic pattern               104     100.00  </div><div class="rwocodeout">  Monomorphic larger pattern      95.28      91.29  </div><div class="rwocodeout">  Monomorphic small pattern       53.56      51.32  </div><div class="rwocodeout">                                                    </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/run_bench_patterns.out">back-end-bench/run_bench_patterns.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005416256">These results confirm the performance hypothesis that we obtained earlier by inspecting
        the lambda code. The shortest running time comes from the small conditional pattern match,
        and polymorphic variant pattern matching is the slowest. There isn't a hugely significant
        difference in these examples, but you can use the same techniques to peer into the innards
        of your own source code and narrow down any performance hotspots.</p><p id="idm449005415408">The lambda form is primarily a stepping stone to the bytecode
      executable format that we'll cover next. It's often easier to look at
      the textual output from this stage than to wade through the native
      assembly code from compiled executables.<a name="idm449005414880"></a></p></section></section><section id="generating-portable-bytecode"><h1>Generating Portable Bytecode</h1><p id="idm449005412960">After the lambda form has been generated, we are very close to
    having executable code. The OCaml toolchain branches into two separate
    compilers at this point. We'll describe the bytecode compiler first, which
    consists of two pieces:<a name="idm449005412448"></a><a name="idm449005411152"></a><a name="idm449005409856"></a><a name="CPportbyte"></a></p><div><dl><dt><span><span><strong>ocamlc</strong></span></span></dt><dd><p id="idm449005405312">Compiles files into a bytecode that is a close mapping to the
          lambda form</p></dd><dt><span><span><strong>ocamlrun</strong></span></span></dt><dd><p id="idm449005403296">A portable interpreter that executes the bytecode</p></dd></dl></div><p id="idm449005402464">The big advantage of using bytecode is simplicity, portability, and compilation speed. The
      mapping from the lambda form to bytecode is straightforward, and this results in predictable
      (but slow) execution speed.</p><p id="idm449005401856">The bytecode interpreter implements a stack-based virtual machine. The OCaml stack and an
      associated accumulator store values that consist of:<a name="idm449005401440"></a><a name="idm449005400112"></a><a name="idm449005399200"></a><a name="idm449005398304"></a><a name="idm449005397408"></a></p><div><dl><dt><span>long</span></dt><dd><p id="idm449005394800">Values that correspond to an OCaml <code>int</code> type</p></dd><dt><span>block</span></dt><dd><p id="idm449005392560">Values that contain the block header and a memory address with
          the data fields that contain further OCaml values indexed by an
          integer</p></dd><dt><span>code offset</span></dt><dd><p id="idm449005390848">Values that are relative to the starting code address</p></dd></dl></div><p id="idm449005390016">The interpreter virtual machine only has seven registers in total: the program counter,
      stack pointer, accumulator, exception and argument pointers, and environment and global data.
      You can display the bytecode instructions in textual form via <code>-dinstr</code>. Try this on one of our earlier pattern-matching examples:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dinstr pattern_monomorphic_small.ml 2&gt;&amp;1
</div><div class="rwocodeout">	branch L2</div><div class="rwocodeout">L1:	acc 0</div><div class="rwocodeout">	push</div><div class="rwocodeout">	const 0</div><div class="rwocodeout">	neqint</div><div class="rwocodeout">	branchifnot L3</div><div class="rwocodeout">	const 101</div><div class="rwocodeout">	return 1</div><div class="rwocodeout">L3:	const 100</div><div class="rwocodeout">	return 1</div><div class="rwocodeout">L2:	closure L1, 0</div><div class="rwocodeout">	push</div><div class="rwocodeout">	acc 0</div><div class="rwocodeout">	makeblock 1, 0</div><div class="rwocodeout">	pop 1</div><div class="rwocodeout">	setglobal Pattern_monomorphic_small!</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/instr_for_pattern_monomorphic_small.out">back-end/instr_for_pattern_monomorphic_small.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005374736">The preceding bytecode has been simplified from the lambda form into
    a set of simple instructions that are executed serially by the
    interpreter.</p><p id="idm449005374192">There are around 140 instructions in total, but most are just minor
    variants of commonly encountered operations (e.g., function application at
    a specific arity). You can find full details <a href="http://cadmium.x9c.fr/distrib/caml-instructions.pdf" target="_top">online</a>.<a name="idm449005373040"></a></p><aside class="note"><h1>Where Did the Bytecode Instruction Set Come From?</h1><p id="idm449005370880">The bytecode interpreter is much slower than compiled native code,
      but is still remarkably performant for an interpreter without a JIT
      compiler. Its efficiency can be traced back to Xavier Leroy's
      ground-breaking work in 1990, <a href="http://hal.inria.fr/docs/00/07/00/49/PS/RT-0117.ps" target="_top">&quot;The ZINC
      experiment: An Economical Implementation of the ML
      Language&quot;.</a></p><p id="idm449005369600">This paper laid the theoretical basis for the implementation of an instruction set for a
        strictly evaluated functional language such as OCaml. The bytecode interpreter in modern
        OCaml is still based on the ZINC model. The native code compiler uses a different model
        since it uses CPU registers for function calls instead of always passing arguments on the
        stack, as the bytecode interpreter does.</p><p id="idm449005368784">Understanding the reasoning behind the different implementations
      of the bytecode interpreter and the native compiler is a very useful
      exercise for any budding language hacker.</p></aside><section id="compiling-and-linking-bytecode"><h1>Compiling and Linking Bytecode</h1><p id="idm449005367152">The <span><strong>ocamlc</strong></span> command compiles
      individual <code>ml</code> files into bytecode
      files that have a <code>cmo</code> extension. The
      compiled bytecode files are matched with the associated <code>cmi</code> interface, which contains the type
      signature exported to other compilation units.<a name="idm449005364064"></a></p><p id="idm449005362608">A typical OCaml library consists of multiple source files, and
      hence multiple <code>cmo</code> files that all
      need to be passed as command-line arguments to use the library from
      other code. The compiler can combine these multiple files into a more
      convenient single archive file by using the <code>-a</code> flag. Bytecode archives are denoted by the
      <code>cma</code> extension.</p><p id="idm449005359920">The individual objects in the library are linked as regular
      <code>cmo</code> files in the order specified when
      the library file was built. If an object file within the library isn't
      referenced elsewhere in the program, then it isn't included in the final
      binary unless the <code>-linkall</code> flag
      forces its inclusion. This behavior is analogous to how C handles object
      files and archives (<code>.o</code> and <code>.a</code>, respectively).</p><p id="idm449005356496">The bytecode files are then linked together with the OCaml
      standard library to produce an executable program. The order in which
      <code>.cmo</code> arguments are presented on the
      command line defines the order in which compilation units are
      initialized at runtime. Remember that OCaml has no single <code>main</code> function like C, so this link order is
      more important than in C programs.</p></section><section id="executing-bytecode"><h1>Executing Bytecode</h1><p id="idm449005353360">The bytecode runtime comprises three parts: the bytecode interpreter, GC, and a set of C
        functions that implement the primitive operations. The bytecode contains instructions to
        call these C functions when required.</p><p id="idm449005352736">The OCaml linker produces bytecode that targets the standard OCaml
      runtime by default, and so needs to know about any C functions that are
      referenced from other libraries that aren't loaded by default.</p><p id="idm449005352128">Information about these extra libraries can be specified while
      linking a bytecode archive:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -a -o mylib.cma a.cmo b.cmo -dllib -lmylib
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/link_dllib.out">back-end-embed/link_dllib.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005348368">The <code>dllib</code> flag embeds the
      arguments in the archive file. Any subsequent packages linking this
      archive will also include the extra C linking directive. This in turn
      lets the interpreter dynamically load the external library symbols when
      it executes the bytecode.</p><p id="idm449005347040">You can also generate a complete standalone executable that
      bundles the <span><strong>ocamlrun</strong></span> interpreter with
      the bytecode in a single binary. This is known as a <span><em>custom
      runtime</em></span> mode and is built as follows:<a name="idm449005345536"></a></p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -a -o mylib.cma -custom a.cmo b.cmo -cclib -lmylib
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/link_custom.out">back-end-embed/link_custom.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005341232">OCamlbuild takes care of many of these details with its built-in rules. The <code>%.byte</code> rule that you've been using throughout the book builds a
        bytecode executable, and adding the <code>custom</code> tag will
        bundle the interpreter with it, too.<a name="idm449005339440"></a></p><p id="idm449005338416">The custom mode is the most similar mode to native code
      compilation, as both generate standalone executables. There are quite a
      few other options available for compiling bytecode (notably with shared
      libraries or building custom runtimes). Full details can be found in the
      <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual022.html" target="_top">OCaml</a>.</p></section><section id="embedding-ocaml-bytecode-in-c"><h1>Embedding OCaml Bytecode in C</h1><p id="idm449005335984">A consequence of using the bytecode compiler is that the final link phase must be
        performed by <span><strong>ocamlc</strong></span>. However, you might sometimes want to
        embed your OCaml code inside an existing C application. OCaml also supports this mode of
        operation via the <span><code>-output-obj</code></span>
          directive.<a name="idm449005333760"></a></p><p id="idm449005332736">This mode causes <span><strong>ocamlc</strong></span> to output an object file
        containing the bytecode for the OCaml part of the program, as well as a <code>caml_startup</code> function. All of the OCaml modules are linked into
        this object file as bytecode, just as they would be for an executable.</p><p id="idm449005330784">This object file can then be linked with C code using the standard C compiler, needing
        only the bytecode runtime library (which is installed as <code>libcamlrun.a</code>). Creating an executable just requires you to link the runtime
        library with the bytecode object file. Here's an example to show how it all fits
        together.</p><p id="idm449005329424">Create two OCaml source files that contain a single print
      line:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> print_endline <span class="keyword7">&quot;hello embedded world 1&quot;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/embed_me1.ml">back-end-embed/embed_me1.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> print_endline <span class="keyword7">&quot;hello embedded world 2&quot;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/embed_me2.ml">back-end-embed/embed_me2.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005324448">Next, create a C file to be your main entry point:</p><div class="rwocode"><pre><code><div class="highlight"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;caml/alloc.h&gt;</span>
<span class="cp">#include &lt;caml/mlvalues.h&gt;</span>
<span class="cp">#include &lt;caml/memory.h&gt;</span>
<span class="cp">#include &lt;caml/callback.h&gt;</span>

<span class="kt">int</span> 
<span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Before calling OCaml</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
  <span class="n">caml_startup</span> <span class="p">(</span><span class="n">argv</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;After calling OCaml</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/main.c">back-end-embed/main.c</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005320912">Now compile the OCaml files into a standalone object file:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> rm -f embed_out.c
</div><div class="highlight"><span class="gp">$</span> ocamlc -output-obj -o embed_out.o embed_me1.ml embed_me2.ml
</div><div class="rwocodeout">clang: warning: argument unused during compilation: '-fno-defer-pop'</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/build_embed.out">back-end-embed/build_embed.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005316288">After this point, you no longer need the OCaml compiler, as
      <code>embed_out.o</code> has all of the OCaml code
      compiled and linked into a single object file. Compile an output binary
      using <span><strong>gcc</strong></span> to test this out:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> gcc -fPIC -Wall -I<span class="sb">`</span>ocamlc -where<span class="sb">`</span> -L<span class="sb">`</span>ocamlc -where<span class="sb">`</span> -ltermcap -lm -ldl <span class="se">\</span>
</div><div class="rwocodeout">  -o finalbc.native main.c embed_out.o -lcamlrun</div><div class="highlight"><span class="gp">$</span> ./finalbc.native
</div><div class="rwocodeout">Before calling OCaml</div><div class="rwocodeout">hello embedded world 1</div><div class="rwocodeout">hello embedded world 2</div><div class="rwocodeout">After calling OCaml</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/build_embed_binary.out">back-end-embed/build_embed_binary.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005306784">You can inspect the commands that <span><strong>ocamlc</strong></span> is invoking by adding <code>-verbose</code> to the command line to help figure
      out the GCC command line if you get stuck. You can even obtain the C
      source code to the <code>-output-obj</code> result
      by specifying a <code>.c</code> output file
      extension instead of the <code>.o</code> we used
      earlier:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -output-obj -o embed_out.c embed_me1.ml embed_me2.ml
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/build_embed_c.out">back-end-embed/build_embed_c.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005299600">Embedding OCaml code like this lets you write OCaml that
      interfaces with any environment that works with a C compiler. You can
      even cross back from the C code into OCaml by using the <code>Callback</code> module to register named entry points
      in the OCaml code. This is explained in detail in the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual033.html#toc149" target="_top">interfacing
      with C</a> section of the OCaml manual.<a name="idm449005297632"></a></p></section></section><section id="compiling-fast-native-code"><h1>Compiling Fast Native Code</h1><p id="idm449005295712">The native code compiler is ultimately the tool that most production
    OCaml code goes through. It compiles the lambda form into fast native code
    executables, with cross-module inlining and additional optimization passes
    that the bytecode interpreter doesn't perform. Care is taken to ensure
    compatibility with the bytecode runtime, so the same code should run
    identically when compiled with either toolchain.<a name="idm449005295024"></a><a name="idm449005294128"></a><a name="idm449005292832"></a><a name="idm449005291936"></a><a name="idm449005290640"></a><a name="idm449005289744"></a><a name="idm449005288448"></a><a name="idm449005287152"></a><a name="CPfast"></a></p><p id="idm449005284144">The <span><strong>ocamlopt</strong></span> command is the
    frontend to the native code compiler and has a very similar interface to
    <span><strong>ocamlc</strong></span>. It also accepts <code>ml</code> and <code>mli</code>
    files, but compiles them to:</p><ul><li><p id="idm449005280496">A <code>.o</code> file containing native
        object code</p></li><li><p id="idm449005279056">A <code>.cmx</code> file containing extra
        information for linking and cross-module optimization</p></li><li><p id="idm449005277552">A <code>.cmi</code> compiled interface
        file that is the same as the bytecode compiler</p></li></ul><p id="idm449005276192">When the compiler links modules together into an executable, it uses
    the contents of the <code>cmx</code> files to
    perform cross-module inlining across compilation units. This can be a
    significant speedup for standard library functions that are frequently
    used outside of their module.</p><p id="idm449005274880">Collections of <code>.cmx</code> and <code>.o</code> files can also be be linked into a <code>.cmxa</code> archive by passing the <code>-a</code> flag to the compiler. However, unlike the
    bytecode version, you must keep the individual <code>cmx</code> files in the compiler search path so that
    they are available for cross-module inlining. If you don't do this, the
    compilation will still succeed, but you will have missed out on an
    important optimization and have slower binaries.</p><section id="inspecting-assembly-output"><h1>Inspecting Assembly Output</h1><p id="idm449005269952">The native code compiler generates assembly language that is then
      passed to the system assembler for compiling into object files. You can
      get <span><strong>ocamlopt</strong></span> to output the assembly
      by passing the <code>-S</code> flag to the
      compiler command line.<a name="idm449005268336"></a></p><p id="idm449005266880">The assembly code is highly architecture-specific, so the following discussion assumes
        an Intel or AMD 64-bit platform. We've generated the example code using <code>-inline 20</code> and <code>-nodynlink</code>
        since it's best to generate assembly code with the full optimizations that the compiler
        supports. Even though these optimizations make the code a bit harder to read, it will give
        you a more accurate picture of what executes on the CPU. Don't forget that you can use the
        lambda code from earlier to get a slightly higher-level picture of the code if you get lost
        in the more verbose assembly.</p><section id="the-impact-of-polymorphic-comparison"><h1>The impact of polymorphic comparison</h1><p id="idm449005263616">We warned you in <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a> that using polymorphic
          comparison is both convenient and perilous. Let's look at precisely what the difference is
          at the assembly language level now.<a name="idm449005262640"></a></p><p id="idm449005261600">First let's create a comparison function where we've explicitly annotated the types,
          so the compiler knows that only integers are being compared:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> cmp <span class="keyword2">(</span>a<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">(</span>b<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword1">if</span> a <span class="keyword2">&gt;</span> b <span class="keyword1">then</span> a <span class="keyword1">else</span> b</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/compare_mono.ml">back-end/compare_mono.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005258720">Now compile this into assembly and read the resulting <code>compare_mono.S</code> file. This file extension may
        be lowercase on some platforms such as Linux:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlopt -inline 20 -nodynlink -S compare_mono.ml
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/asm_from_compare_mono.out">back-end/asm_from_compare_mono.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005254272">If you've never seen assembly language before, then the contents
        may be rather scary. While you'll need to learn x86 assembly to fully
        understand it, we'll try to give you some basic instructions to spot
        patterns in this section. The excerpt of the implementation of the
        <code>cmp</code> function can be found
        below:</p><div class="rwocode"><pre><code><div class="highlight"><span class="nl">_camlCompare_mono__cmp_1008:</span>
        <span class="na">.cfi_startproc</span>
<span class="nl">.L101:</span>
        <span class="nf">cmpq</span>    <span class="nv">%rbx</span><span class="p">,</span> <span class="nv">%rax</span>
        <span class="nf">jle</span>     <span class="no">.L100</span>
        <span class="nf">ret</span>
        <span class="na">.align</span>  <span class="mi">2</span>
<span class="nl">.L100:</span>
        <span class="nf">movq</span>    <span class="nv">%rbx</span><span class="p">,</span> <span class="nv">%rax</span>
        <span class="nf">ret</span>
        <span class="na">.cfi_endproc</span>
</div></code></pre><div class="rwocodeinfo">Assembly ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/cmp.S">back-end/cmp.S</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005250544">The <code>_camlCompare_mono__cmp_1008</code> is an assembly
        label that has been computed from the module name (<code>Compare_mono</code>) and the function name
        (<code>cmp_1008</code>). The numeric suffix for
        the function name comes straight from the lambda form (which you can
        inspect using <code>-dlambda</code>, but in this
        case isn't necessary).</p><p id="idm449005247264">The arguments to <code>cmp</code> are
        passed in the <code>%rbx</code> and <code>%rax</code> registers, and compared using the
        <code>jle</code> &quot;jump if less than or equal&quot;
        instruction. This requires both the arguments to be immediate integers
        to work. Now let's see what happens if our OCaml code omits the type
        annotations and is a polymorphic comparison instead:</p><div class="rwocode"><pre><code><span class="keyword4">let</span> cmp a b <span class="keyword2">=</span>
  <span class="keyword1">if</span> a <span class="keyword2">&gt;</span> b <span class="keyword1">then</span> a <span class="keyword1">else</span> b</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/compare_poly.ml">back-end/compare_poly.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005241648">Compiling this code with <code>-S</code>
        results in a significantly more complex assembly output for the same
        function:</p><div class="rwocode"><pre><code><div class="highlight"><span class="nl">_camlCompare_poly__cmp_1008:</span>
        <span class="na">.cfi_startproc</span>
        <span class="nf">subq</span>    <span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="mi">24</span>
<span class="nl">.L101:</span>
        <span class="nf">movq</span>    <span class="nv">%rax</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
        <span class="nf">movq</span>    <span class="nv">%rbx</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
        <span class="nf">movq</span>    <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>
        <span class="nf">movq</span>    <span class="nv">%rbx</span><span class="p">,</span> <span class="nv">%rsi</span>
        <span class="nf">leaq</span>    <span class="no">_caml_greaterthan</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>
        <span class="nf">call</span>    <span class="no">_caml_c_call</span>
<span class="nl">.L102:</span>
        <span class="nf">leaq</span>    <span class="no">_caml_young_ptr</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%r11</span>
        <span class="nf">movq</span>    <span class="p">(</span><span class="nv">%r11</span><span class="p">),</span> <span class="nv">%r15</span>
        <span class="nf">cmpq</span>    <span class="no">$1</span><span class="p">,</span> <span class="nv">%rax</span>
        <span class="nf">je</span>      <span class="no">.L100</span>
        <span class="nf">movq</span>    <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rax</span>
        <span class="nf">addq</span>    <span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="p">-</span><span class="mi">24</span>
        <span class="nf">ret</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="mi">24</span>
        <span class="na">.align</span>  <span class="mi">2</span>
<span class="nl">.L100:</span>
        <span class="nf">movq</span>    <span class="mi">0</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rax</span>
        <span class="nf">addq</span>    <span class="no">$24</span><span class="p">,</span> <span class="nv">%rsp</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="p">-</span><span class="mi">24</span>
        <span class="nf">ret</span>
        <span class="na">.cfi_adjust_cfa_offset</span>  <span class="mi">24</span>
        <span class="na">.cfi_endproc</span>
</div></code></pre><div class="rwocodeinfo">Assembly ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/compare_poly_asm.S">back-end/compare_poly_asm.S</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005237584">The <code>.cfi</code> directives are assembler hints that
          contain Call Frame Information that lets the debugger provide more sensible backtraces,
          and they have no effect on runtime performance. Notice that the rest of the implementation
          is no longer a simple register comparison. Instead, the arguments are pushed on the stack
          (the <code>%rsp</code> register), and a C function call is invoked
          by placing a pointer to <code>caml_greaterthan</code> in <code>%rax</code> and jumping to <code>caml_c_call</code>.<a name="idm449005233616"></a></p><p id="idm449005232592">OCaml on x86_64 architectures caches the location of the minor
        heap in the <code>%r15</code> register since
        it's so frequently referenced in OCaml functions. The minor heap
        pointer can also be changed by the C code that's being called (e.g.,
        when it allocates OCaml values), and so <code>%r15</code> is restored after returning from the
        <code>caml_greaterthan</code> call. Finally, the
        return value of the comparison is popped from the stack and
        returned.</p></section><section id="benchmarking-polymorphic-comparison"><h1>Benchmarking polymorphic comparison</h1><p id="idm449005228704">You don't have to fully understand the intricacies of assembly
        language to see that this polymorphic comparison is much heavier than
        the simple monomorphic integer comparison from earlier. Let's confirm
        this hypothesis again by writing a quick <code>Core_bench</code> test with both functions:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Core_bench.Std
</span>
<span class="keyword4">let</span> polymorphic_compare <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> cmp a b <span class="keyword2">=</span> <span class="keyword1">if</span> a <span class="keyword2">&gt;</span> b <span class="keyword1">then</span> a <span class="keyword1">else</span> b <span class="keyword4">in</span>
  <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">to</span> <span class="keyword8">1000</span> <span class="keyword1">do</span>
    ignore<span class="keyword2">(</span>cmp <span class="keyword8">0</span> i<span class="keyword2">)</span>
  <span class="keyword1">done</span>

<span class="keyword4">let</span> monomorphic_compare <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> cmp <span class="keyword2">(</span>a<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">(</span>b<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">=</span>
    <span class="keyword1">if</span> a <span class="keyword2">&gt;</span> b <span class="keyword1">then</span> a <span class="keyword1">else</span> b <span class="keyword4">in</span>
  <span class="keyword1">for</span> i <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">to</span> <span class="keyword8">1000</span> <span class="keyword1">do</span>
    ignore<span class="keyword2">(</span>cmp <span class="keyword8">0</span> i<span class="keyword2">)</span>
  <span class="keyword1">done</span>

<span class="keyword4">let</span> tests <span class="keyword2">=</span>
  <span class="keyword2">[</span> <span class="keyword7">&quot;Polymorphic comparison&quot;</span>, polymorphic_compare<span class="keyword2">;</span>
    <span class="keyword7">&quot;Monomorphic comparison&quot;</span>, monomorphic_compare <span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">List.</span>map tests ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>name,test<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create ~name test<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span>make_command
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/bench_poly_and_mono.ml">back-end-bench/bench_poly_and_mono.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005224272">Running this shows quite a significant runtime difference
        between the two:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg core_bench bench_poly_and_mono.native
</div><div class="highlight"><span class="gp">$</span> ./bench_poly_and_mono.native -ascii
</div><div class="rwocodeout">Estimated testing time 20s (change using -quota SECS).</div><div class="rwocodeout">                                                </div><div class="rwocodeout">  Name                     Time/Run   % of max  </div><div class="rwocodeout"> ------------------------ ---------- ---------- </div><div class="rwocodeout">  Polymorphic comparison     40_882     100.00  </div><div class="rwocodeout">  Monomorphic comparison      2_837       6.94  </div><div class="rwocodeout">                                                </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/run_bench_poly_and_mono.out">back-end-bench/run_bench_poly_and_mono.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005214880">We see that the polymorphic comparison is close to 20 times slower! These results
          shouldn't be taken too seriously, as this is a very narrow test that, like all such
          microbenchmarks, isn't representative of more complex codebases. However, if you're
          building numerical code that runs many iterations in a tight inner loop, it's worth
          manually peering at the produced assembly code to see if you can hand-optimize it.</p></section></section><section id="debugging-native-code-binaries"><h1>Debugging Native Code Binaries</h1><p id="idm449005212848">The native code compiler builds executables that can be debugged using conventional
        system debuggers such as GNU <span><strong>gdb</strong></span>. You need to compile
        your libraries with the <code>-g</code> option to add the debug
        information to the output, just as you need to with C compilers.<a name="idm449005211040"></a><a name="idm449005209728"></a></p><p id="idm449005208272">Extra debugging information is inserted into the output assembly
      when the library is compiled in debug mode. These include the CFI stubs
      you will have noticed in the profiling output earlier (<code>.cfi_start_proc</code> and <code>.cfi_end_proc</code> to delimit an OCaml function
      call, for example).</p><section id="understanding-name-mangling"><h1>Understanding name mangling</h1><p id="idm449005205392">So how do you refer to OCaml functions in an interactive debugger like <span><strong>gdb</strong></span>? The first thing you need to know is how OCaml function
          names compile down to symbol names in the compiled object files, a procedure generally
          called <span><em>name mangling</em></span>.<a name="idm449005204032"></a><a name="idm449005203136"></a><a name="idm449005201824"></a><a name="idm449005200512"></a></p><p id="idm449005199488">Each OCaml source file is compiled into a native object file that must export a unique
          set of symbols to comply with the C binary interface. This means that any OCaml values
          that may be used by another compilation unit need to be mapped onto a symbol name. This
          mapping has to account for OCaml language features such as nested modules, anonymous
          functions, and variable names that shadow one another.</p><p id="idm449005198656">The conversion follows some straightforward rules for named
        variables and functions:</p><ul><li><p id="idm449005197664">The symbol is prefixed by <code>caml</code> and the local module name, with
            dots replaced by underscores.</p></li><li><p id="idm449005196144">This is followed by a double <code>__</code> suffix and the variable name.</p></li><li><p id="idm449005194688">The variable name is also suffixed by a <code>_</code> and a
              number. This is the result of the lambda compilation, which replaces each variable
              name with a unique value within the module. You can determine this number by examining
              the <code>-dlambda</code> output from <span><strong>ocamlopt</strong></span>.</p></li></ul><p id="idm449005191856">Anonymous functions are hard to predict without inspecting
        intermediate compiler output. If you need to debug them, it's usually
        easier to modify the source code to let-bind the anonymous function to
        a variable name.</p></section><section id="interactive-breakpoints-with-the-gnu-debugger"><h1>Interactive breakpoints with the GNU debugger</h1><p id="idm449005190128">Let's see name mangling in action with some interactive
        debugging using GNU <span><strong>gdb</strong></span>.<a name="idm449005189152"></a></p><aside class="caution"><h1>Beware gdb on Mac OS X</h1><p id="idm449005187456">The examples here assume that you are running <span><strong>gdb</strong></span> on either Linux or FreeBSD. Mac OS X
          10.8 does have <span><strong>gdb</strong></span> installed, but
          it's a rather quirky experience that doesn't reliably interpret the
          debugging information contained in the native binaries. This can
          result in function names showing up as raw symbols such as <code>.L101</code> instead of their more human-readable
          form.</p><p id="idm449005184768">For OCaml 4.1, we'd recommend you do native code debugging on
          an alternate platform such as Linux, or manually look at the
          assembly code output to map the symbol names onto their precise
          OCaml functions.</p><p id="idm449005184144">MacOS 10.9 removes <span><strong>gdb</strong></span> entirely and uses the lldb debugger from
            the LLVM project by default. Many of the guidelines here still apply since the debug
            information embedded in the binary output can be interpreted by lldb (or any other
            DWARF-aware debugger), but the command-line interfaces to lldb is different from
              <span><strong>gdb</strong></span>. Refer to the lldb manual for more information.</p></aside><p id="idm449005182416">Let's write a mutually recursive function that selects alternating values from a list.
          This isn't tail-recursive, so our stack size will grow as we single-step through the
          execution:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> <span class="keyword4">rec</span> take <span class="keyword2">=</span>
  <span class="keyword1">function</span>
  <span class="keyword2">|</span><span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
  <span class="keyword2">|</span>hd<span class="keyword2">:</span><span class="keyword2">:</span>tl -<span class="keyword2">&gt;</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">(</span>skip tl<span class="keyword2">)</span>
<span class="keyword4">and</span> skip <span class="keyword2">=</span>
  <span class="keyword1">function</span>
  <span class="keyword2">|</span><span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
  <span class="keyword2">|</span><span class="keyword8">_</span><span class="keyword2">:</span><span class="keyword2">:</span>tl -<span class="keyword2">&gt;</span> take tl

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  take <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">;</span><span class="keyword8">6</span><span class="keyword2">;</span><span class="keyword8">7</span><span class="keyword2">;</span><span class="keyword8">8</span><span class="keyword2">;</span><span class="keyword8">9</span><span class="keyword2">]</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span>string_of_int
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">String.</span>concat ~sep<span class="keyword2">:</span><span class="keyword7">&quot;,&quot;</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/alternate_list.ml">back-end/alternate_list.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005179136">Compile and run this with debugging symbols. You should see the
        following output:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -tag debug alternate_list.native
</div><div class="highlight"><span class="gp">$</span> ./alternate_list.native -ascii
</div><div class="rwocodeout">1,3,5,7,9</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-bench/run_alternate_list.out">back-end-bench/run_alternate_list.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005173808">Now we can run this interactively within <span><strong>gdb</strong></span>:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> gdb ./alternate_list.native
</div><div class="rwocodeout">GNU gdb (GDB) 7.4.1-debian</div><div class="rwocodeout">Copyright (C) 2012 Free Software Foundation, Inc.</div><div class="rwocodeout">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="rwocodeout">This is free software: you are free to change and redistribute it.</div><div class="rwocodeout">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="rwocodeout">and &quot;show warranty&quot; for details.</div><div class="rwocodeout">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</div><div class="rwocodeout">For bug reporting instructions, please see:</div><div class="rwocodeout">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</div><div class="rwocodeout">Reading symbols from /home/avsm/alternate_list.native...done.</div><div class="rwocodeout">(gdb)</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/gdb_alternate0.out">back-end/gdb_alternate0.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005162240">The <span><strong>gdb</strong></span> prompt lets you enter
        debug directives. Let's set the program to break just before the first
        call to <code>take</code>:</p><div class="rwocode"><pre><code><div class="rwocodeout">(gdb) break camlAlternate_list__take_69242 </div><div class="rwocodeout">Breakpoint 1 at 0x5658d0: file alternate_list.ml, line 5.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/gdb_alternate1.out">back-end/gdb_alternate1.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005157136">We used the C symbol name by following the name mangling rules defined earlier. A
          convenient way to figure out the full name is by tab completion. Just type in a portion of
          the name and press the &lt;tab&gt; key to see a list of possible completions.</p><p id="idm449005156080">Once you've set the breakpoint, start the program
        executing:</p><div class="rwocode"><pre><code><div class="rwocodeout">(gdb) run</div><div class="rwocodeout">Starting program: /home/avsm/alternate_list.native</div><div class="rwocodeout">[Thread debugging using libthread_db enabled]</div><div class="rwocodeout">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</div><div class="rwocodeout"> </div><div class="rwocodeout">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</div><div class="rwocodeout">4         function</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/gdb_alternate2.out">back-end/gdb_alternate2.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005148976">The binary has run until the first take invocation and stopped,
        waiting for further instructions. GDB has lots of features, so let's
        continue the program and check the stacktrace after a couple of
        recursions:</p><div class="rwocode"><pre><code><div class="rwocodeout">(gdb) cont</div><div class="rwocodeout">Continuing.</div><div class="rwocodeout"> </div><div class="rwocodeout">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</div><div class="rwocodeout">4         function</div><div class="rwocodeout">(gdb) cont</div><div class="rwocodeout">Continuing.</div><div class="rwocodeout"> </div><div class="rwocodeout">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</div><div class="rwocodeout">4         function</div><div class="rwocodeout">(gdb) bt</div><div class="rwocodeout">#0  camlAlternate_list__take_69242 () at alternate_list.ml:4</div><div class="rwocodeout">#1  0x00000000005658e7 in camlAlternate_list__take_69242 () at alternate_list.ml:6</div><div class="rwocodeout">#2  0x00000000005658e7 in camlAlternate_list__take_69242 () at alternate_list.ml:6</div><div class="rwocodeout">#3  0x00000000005659f7 in camlAlternate_list__entry () at alternate_list.ml:14</div><div class="rwocodeout">#4  0x0000000000560029 in caml_program ()</div><div class="rwocodeout">#5  0x000000000080984a in caml_start_program ()</div><div class="rwocodeout">#6  0x00000000008099a0 in ?? ()</div><div class="rwocodeout">#7  0x0000000000000000 in ?? ()</div><div class="rwocodeout">(gdb) clear camlAlternate_list__take_69242</div><div class="rwocodeout">Deleted breakpoint 1 </div><div class="rwocodeout">(gdb) cont</div><div class="rwocodeout">Continuing.</div><div class="rwocodeout">1,3,5,7,9</div><div class="rwocodeout">[Inferior 1 (process 3546) exited normally]</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/gdb_alternate3.out">back-end/gdb_alternate3.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005129824">The <code>cont</code> command resumes execution after a
          breakpoint has paused it, <code>bt</code> displays a stack
          backtrace, and <code>clear</code> deletes the breakpoint so the
          application can execute until completion. GDB has a host of other features we won't cover
          here, but you can view more guidelines via Mark Shinwell's talk on <a href="http://www.youtube.com/watch?v=NF2WpWnB-nk&lt;" target="_top">&quot;Real-world debugging in
            OCaml.&quot;</a></p><p id="idm449005126704">One very useful feature of OCaml native code is that C and OCaml share the same stack.
          This means that GDB backtraces can give you a combined view of what's going on in your
          program <span><em>and</em></span> runtime library. This includes any calls to C libraries
          or even callbacks into OCaml from the C layer if you're in an environment which embeds the
          OCaml runtime as a library.</p></section></section><section id="profiling-native-code"><h1>Profiling Native Code</h1><p id="idm449005124336">The recording and analysis of where your application spends its
      execution time is known as <span><em>performance profiling</em></span>.
      OCaml native code binaries can be profiled just like any other C binary,
      by using the name mangling described earlier to map between OCaml
      variable names and the profiler output.<a name="idm449005123456"></a><a name="idm449005122560"></a><a name="idm449005121648"></a></p><p id="idm449005120192">Most profiling tools benefit from having some instrumentation
      included in the binary. OCaml supports two such tools:</p><ul><li><p id="idm449005119168">GNU <span><strong>gprof</strong></span>, to measure execution time and call
            graphs</p></li><li><p id="idm449005117680">The <a href="https://perf.wiki.kernel.org/" target="_top">Perf</a>
          profiling framework in modern versions of Linux</p></li></ul><p id="idm449005116304">Note that many other tools that operate on native binaries, such as Valgrind, will work
        just fine with OCaml as long as the program is linked with the <code>-g</code> flag to embed debugging symbols.</p><section id="gprof"><h1>Gprof</h1><p id="idm449005114192"><span><strong>gprof</strong></span> produces an execution
        profile of an OCaml program by recording a call graph of which
        functions call one another, and recording the time these calls take
        during the program execution.<a name="idm449005113216"></a></p><p id="idm449005112176">Getting precise information out of <span><strong>gprof</strong></span> requires passing the <code>-p</code> flag to the native code compiler when
        compiling <span><em>and</em></span> linking the binary. This generates
        extra code that records profile information to a file called <code>gmon.out</code> when the program is executed. This
        profile information can then be examined using <span><strong>gprof</strong></span>.</p></section><section id="perf"><h1>Perf</h1><p id="idm449005107488">Perf is a more modern alternative to <span><strong>gprof</strong></span> that doesn't require you to instrument
        the binary. Instead, it uses hardware counters and debug information
        within the binary to record information accurately.</p><p id="idm449005106224">Run Perf on a compiled binary to record information first. We'll use our write barrier
          benchmark from earlier, which measures memory allocation versus in-place
          modification:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> perf record -g ./barrier_bench.native
</div><div class="rwocodeout">Estimated testing time 20s (change using -quota SECS).</div><div class="rwocodeout"> </div><div class="rwocodeout">  Name        Time (ns)             Time 95ci   Percentage</div><div class="rwocodeout">  ----        ---------             ---------   ----------</div><div class="rwocodeout">  mutable     7_306_219   7_250_234-7_372_469        96.83</div><div class="rwocodeout">  immutable   7_545_126   7_537_837-7_551_193       100.00</div><div class="rwocodeout"> </div><div class="rwocodeout">[ perf record: Woken up 11 times to write data ]</div><div class="rwocodeout">[ perf record: Captured and wrote 2.722 MB perf.data (~118926 samples) ]</div><div class="rwocodeout">perf record -g ./barrier.native</div><div class="rwocodeout">Estimated testing time 20s (change using -quota SECS).</div><div class="rwocodeout"> </div><div class="rwocodeout">  Name        Time (ns)             Time 95ci   Percentage</div><div class="rwocodeout">  ----        ---------             ---------   ----------</div><div class="rwocodeout">  mutable     7_306_219   7_250_234-7_372_469        96.83</div><div class="rwocodeout">  immutable   7_545_126   7_537_837-7_551_193       100.00</div><div class="rwocodeout"> </div><div class="rwocodeout">[ perf record: Woken up 11 times to write data ]</div><div class="rwocodeout">[ perf record: Captured and wrote 2.722 MB perf.data (~118926 samples) ]</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/perf_record.out">back-end/perf_record.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005089696">When this completes, you can interactively explore the
        results:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> perf report -g
</div><div class="rwocodeout">+  48.86%  barrier.native  barrier.native  [.] camlBarrier__test_immutable_69282</div><div class="rwocodeout">+  30.22%  barrier.native  barrier.native  [.] camlBarrier__test_mutable_69279</div><div class="rwocodeout">+  20.22%  barrier.native  barrier.native  [.] caml_modify</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/perf_report.out">back-end/perf_report.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005084032">This trace broadly reflects the results of the benchmark itself.
        The mutable benchmark consists of the combination of the call to
        <code>test_mutable</code> and the <code>caml_modify</code> write barrier function in the
        runtime. This adds up to slightly over half the execution time of the
        application.</p><p id="idm449005082048">Perf has a growing collection of other commands that let you archive these runs and
          compare them against each other. You can read more on the <a href="http://perf.wiki.kernel.org" target="_top">home page</a>.<a name="idm449005080976"></a></p><section><h1><b>Using the Frame Pointer to Get More Accurate Traces</b></h1><p id="idm449005079248">Although Perf doesn't require adding in explicit probes to the
          binary, it does need to understand how to unwind function calls so
          that the kernel can accurately record the function backtrace for
          every event.</p><p id="idm449005078624">OCaml stack frames are too complex for Perf to understand
          directly, and so it needs the compiler to fall back to using the
          same conventions as C for function calls. On 64-bit Intel systems,
          this means that a special register known as the <span><em>frame
          pointer</em></span> is used to record function call history.</p><p id="idm449005077504">Using the frame pointer in this fashion means a slowdown
          (typically around 3-5%) since it's no longer available for
          general-purpose use. OCaml 4.1 thus makes the frame pointer an
          optional feature that can be used to improve the resolution of Perf
          traces.</p><p id="idm449005076816">OPAM provides a compiler switch that compiles OCaml with the
          frame pointer activated:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> opam switch 4.01.0dev+fp
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end/opam_switch.out">back-end/opam_switch.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005073104">Using the frame pointer changes the OCaml calling convention,
          but OPAM takes care of recompiling all your libraries with the new
          interface. You can read more about this on the OCamlPro <a href="http://www.ocamlpro.com/blog/2012/08/08/profile-native-code.html" target="_top">blog</a>.</p></section></section></section><section id="embedding-native-code-in-c"><h1>Embedding Native Code in C</h1><p id="idm449005070496">The native code compiler normally links a complete executable, but
      can also output a standalone native object file just as the bytecode
      compiler can. This object file has no further dependencies on OCaml
      except for the runtime library.<a name="idm449005069984"></a><a name="idm449005069072"></a></p><p id="idm449005067616">The native code runtime is a different library from the bytecode one, and is installed
        as <code>libasmrun.a</code> in the OCaml standard library
        directory.</p><p id="idm449005066416">Try this custom linking by using the same source files from the
      bytecode embedding example earlier in this chapter:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlopt -output-obj -o embed_native.o embed_me1.ml embed_me2.ml
</div><div class="highlight"><span class="gp">$</span> gcc -Wall -I <span class="sb">`</span>ocamlc -where<span class="sb">`</span> -o final.native embed_native.o main.c <span class="se">\</span>
</div><div class="rwocodeout">   -L `ocamlc -where` -lasmrun -ltermcap -lm -ldl</div><div class="highlight"><span class="gp">$</span> ./final.native
</div><div class="rwocodeout">Before calling OCaml</div><div class="rwocodeout">hello embedded world 1</div><div class="rwocodeout">hello embedded world 2</div><div class="rwocodeout">After calling OCaml</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/build_embed_native.out">back-end-embed/build_embed_native.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005057104">The <code>embed_native.o</code> is a standalone object file that
        has no further references to OCaml code beyond the runtime library, just as with the
        bytecode runtime. Do remember that the link order of the libraries is significant in modern
        GNU toolchains (especially as used in Ubuntu 11.10 and later) that resolve symbols from left
        to right in a single pass.<a name="idm449005055824"></a></p><aside class="tip"><h1>Activating the Debug Runtime</h1><p id="idm449005053712">Despite your best efforts, it is easy to introduce a bug into some components, such as
          C bindings, that causes heap invariants to be violated. OCaml includes a <code>libasmrund.a</code> variant of the runtime library which is compiled
          with extra debugging checks that perform extra memory integrity checks during every
          garbage collection cycle. Running these extra checks will abort the program nearer the
          point of corruption and help isolate the bug in the C code.</p><p id="idm449005052192">To use the debug library, just link your program with the
        <code>-runtime-variant d</code> flag:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlopt -runtime-variant d -verbose -o hello.native hello.ml
</div><div class="highlight"><span class="gp">$</span> ./hello.native
</div><div class="rwocodeout">### OCaml runtime: debug mode ###</div><div class="rwocodeout">Initial minor heap size: 2048k bytes</div><div class="rwocodeout">Initial major heap size: 992k bytes</div><div class="rwocodeout">Initial space overhead: 80%</div><div class="rwocodeout">Initial max overhead: 500%</div><div class="rwocodeout">Initial heap increment: 992k bytes</div><div class="rwocodeout">Initial allocation policy: 0</div><div class="rwocodeout">Hello OCaml World!</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/back-end-embed/run_debug_hello.out">back-end-embed/run_debug_hello.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm449005041472">If you get an error that <code>libasmrund.a</code> is not found,
          it's probably because you're using OCaml 4.00 and not 4.01. It's only installed by default
          in the very latest version, which you should be using via the <code>4.01.0</code> OPAM switch.<a name="idm449005039696"></a></p></aside></section></section><section id="summarizing-the-file-extensions"><h1>Summarizing the File Extensions</h1><p id="idm449005037648">We've seen how the compiler uses intermediate files to store various
    stages of the compilation toolchain. Here's a cheat sheet of all them in
    one place.<a name="idm449005037216"></a><a name="idm449005035904"></a></p><p id="idm449005034464"> <a href="the-compiler-backend-byte-code-and-native-code.html#Table2301">Table 23.1, “Intermediate files generated by the OCaml compiler toolchain”</a> shows the intermediate files generated by <span><strong>ocamlc</strong></span>.</p><div id="Table2301"><p><b>Table 23.1. Intermediate files generated by the OCaml compiler toolchain</b></p><div><table summary="Intermediate files generated by the OCaml compiler toolchain"><thead><tr><th>Extension</th><th>Purpose</th></tr></thead><tbody><tr><td><code>.ml</code></td><td>Source files for compilation unit module
            implementations.</td></tr><tr><td><code>.mli</code></td><td>Source files for compilation unit module interfaces. If
            missing, generated from the <code>.ml</code>
            file.</td></tr><tr><td><code>.cmi</code></td><td>Compiled module interface from a corresponding <code>.mli</code> source file.</td></tr><tr><td><code>.cmo</code></td><td>Compiled bytecode object file of the module
            implementation.</td></tr><tr><td><code>.cma</code></td><td>Library of bytecode object files packed into a single
            file.</td></tr><tr><td><code>.o</code></td><td>C source files are compiled into native object files by the
            system <code>cc</code>.</td></tr><tr><td><code>.cmt</code></td><td>Typed abstract syntax tree for module
            implementations.</td></tr><tr><td><code>.cmti</code></td><td>Typed abstract syntax tree for module interfaces.</td></tr><tr><td><code>.annot</code></td><td>Old-style annotation file for displaying <code>typed</code>, superseded by
                <code>cmt</code> files.</td></tr></tbody></table></div></div><br><p id="idm449005013040">The native code compiler generates some additional files (see <a href="the-compiler-backend-byte-code-and-native-code.html#Table2302">Table 23.2, “Intermediate outputs produced by the native code OCaml toolchain”</a>).<a name="idm449005012224"></a></p><div id="Table2302"><p><b>Table 23.2. Intermediate outputs produced by the native code OCaml toolchain</b></p><div><table summary="Intermediate outputs produced by the native code OCaml toolchain"><thead><tr><th>Extension</th><th>Purpose</th></tr></thead><tbody><tr><td><code>.o</code></td><td>Compiled native object file of the module
            implementation.</td></tr><tr><td><code>.cmx</code></td><td>Contains extra information for linking and cross-module
            optimization of the object file.</td></tr><tr><td><code>.cmxa and .a</code></td><td>Library of <code>cmx</code> and
            <code>o</code> units, stored in the <code>cmxa</code> and <code>a</code> files respectively. These files are
            always needed together.</td></tr><tr><td><code>.S </code><span><em>or</em></span>
<code>.s</code></td><td>Assembly language output if <code>-S</code> is specified.</td></tr></tbody></table></div></div><br></br></br></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="the-compiler-frontend-parsing-and-type-checking.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="ix01.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>
