<html>

    <head>
    
        <meta charset="utf-8"></meta>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"></meta>
        
        <title>Chapter 13. Maps and Hash Tables / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"></link>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'realworldocaml',
                        repo: 'book',
                        milestone: 'v1',
                        page: 'maps\u002Dand\u002Dhash\u002Dtables.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="maps-and-hash-tables.html" class="here">13. Maps and Hash Tables</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html">14. Command-Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">15. Handling JSON Data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-menhir.html">16. Parsing with OCamllex and Menhir</a>
                                            </li>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html">17. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">18. Concurrent Programming with Async</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="ix01.html">Index</a>
                            
                        </li>
                    
                </ul>
            </nav>
            <header class="header">
                <h1><a href="http://oreil.ly/realworldOCaml"><img src="../../media/img/coversmall.png" width="120" alt="Real World OCaml, by Yaron Minsky, Anil Madhavapeddy and Jason Hickey"></img></a></h1>
                <p><i>Buy in <a href="http://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/">print</a> and <a href="http://oreil.ly/realworldOCaml">eBook.</a></i></p>
            </header>
        
            <article class="page">
        
                <h1>Chapter 13. Maps and Hash Tables</h1>
                
                

    <p id="idm322810063392">Lots of programming problems require dealing with data organized as
  key/value pairs. Maybe the simplest way of representing such data in OCaml
  is an <span><em>association list</em></span>, which is simply a list of pairs
  of keys and values. For example, you could represent a mapping between the
  10 digits and their English names as follows:<a name="idm322810062400"></a><a name="idm322810061504"></a><a name="idm322810060208"></a><a name="idm322810058896"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> digit_alist <span class="keyword2">=</span>
    <span class="keyword2">[</span> <span class="keyword8">0</span>, <span class="keyword7">&quot;zero&quot;</span><span class="keyword2">;</span> <span class="keyword8">1</span>, <span class="keyword7">&quot;one&quot;</span><span class="keyword2">;</span> <span class="keyword8">2</span>, <span class="keyword7">&quot;two&quot;</span>  <span class="keyword2">;</span> <span class="keyword8">3</span>, <span class="keyword7">&quot;three&quot;</span><span class="keyword2">;</span> <span class="keyword8">4</span>, <span class="keyword7">&quot;four&quot;</span>
    <span class="keyword2">;</span> <span class="keyword8">5</span>, <span class="keyword7">&quot;five&quot;</span><span class="keyword2">;</span> <span class="keyword8">6</span>, <span class="keyword7">&quot;six&quot;</span><span class="keyword2">;</span> <span class="keyword8">7</span>, <span class="keyword7">&quot;seven&quot;</span><span class="keyword2">;</span> <span class="keyword8">8</span>, <span class="keyword7">&quot;eight&quot;</span><span class="keyword2">;</span> <span class="keyword8">9</span>, <span class="keyword7">&quot;nine&quot;</span> <span class="keyword2">]</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val digit_alist : (int * string) list =
  [(0, &quot;zero&quot;); (1, &quot;one&quot;); (2, &quot;two&quot;); (3, &quot;three&quot;); (4, &quot;four&quot;);
   (5, &quot;five&quot;); (6, &quot;six&quot;); (7, &quot;seven&quot;); (8, &quot;eight&quot;); (9, &quot;nine&quot;)]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322810050512">We can use functions from the <code>List.Assoc</code> module to
    manipulate this data:</p><div class="rwocode"><pre><code># <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>find digit_alist <span class="keyword8">6</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string option = Some &quot;six&quot;
</div># <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>find digit_alist <span class="keyword8">22</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string option = None
</div># <span class="keyword5">List.</span><span class="keyword5">Assoc.</span>add digit_alist <span class="keyword8">0</span> <span class="keyword7">&quot;zilch&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (int, string) List.Assoc.t =
[(0, &quot;zilch&quot;); (1, &quot;one&quot;); (2, &quot;two&quot;); (3, &quot;three&quot;); (4, &quot;four&quot;);
 (5, &quot;five&quot;); (6, &quot;six&quot;); (7, &quot;seven&quot;); (8, &quot;eight&quot;); (9, &quot;nine&quot;)]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322810040432">Association lists are simple and easy to use, but their performance is
  not ideal, since almost every nontrivial operation on an association list
  requires a linear-time scan of the list.</p><p id="idm322810039856">In this chapter, we'll talk about two more efficient alternatives to
  association lists: <span><em>maps</em></span> and <span><em>hash
  tables</em></span>. A map is an immutable tree-based data structure where
  most operations take time logarithmic in the size of the map, whereas a hash
  table is a mutable data structure where most operations have constant time
  complexity. We'll describe both of these data structures in detail and
  provide some advice as to how to choose between them.<a name="idm322810038336"></a><a name="idm322810037040"></a></p><section id="maps"><h1>Maps</h1><p id="idm322810034720">Let's consider an example of how one might use a map in practice. In
    <a href="files-modules-and-programs.html">Chapter 4, <i>Files, Modules, and Programs</i></a>, we showed a module <code>Counter</code> for keeping frequency counts on a set of
    strings. Here's the interface:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="comments">(** A collection of string frequency counts *)</span>
<span class="keyword4">type</span> t

<span class="comments">(** The empty set of frequency counts  *)</span>
<span class="keyword4">val</span> empty <span class="keyword2">:</span> t

<span class="comments">(** Bump the frequency count for the given string. *)</span>
<span class="keyword4">val</span> touch <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> t

<span class="comments">(* Converts the set of frequency counts to an association list.  Every strings
   in the list will show up at most once, and the integers will be at least
   1. *)</span>
<span class="keyword4">val</span> to_list <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword3">string</span> <span class="keyword2">*</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword3">list</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-fast/counter.mli">files-modules-and-programs-freq-fast/counter.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322810030560">The intended behavior here is straightforward. <code>Counter.empty</code> represents an empty collection of
    frequency counts; <code>touch</code> increments the
    frequency count of the specified string by 1; and <code>to_list</code> returns the list of nonzero
    frequencies.</p><p id="idm322810027184">Here's the implementation:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">int</span> <span class="keyword5">String.</span><span class="keyword5">Map.</span>t

<span class="keyword4">let</span> empty <span class="keyword2">=</span> <span class="keyword5">String.</span><span class="keyword5">Map.</span>empty

<span class="keyword4">let</span> to_list t <span class="keyword2">=</span> <span class="keyword5">Map.</span>to_alist t

<span class="keyword4">let</span> touch t s <span class="keyword2">=</span>
  <span class="keyword4">let</span> count <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword5">Map.</span>find t s <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> <span class="keyword6">Some </span>x -<span class="keyword2">&gt;</span> x
  <span class="keyword4">in</span>
  <span class="keyword5">Map.</span>add t ~key<span class="keyword2">:</span>s ~data<span class="keyword2">:</span><span class="keyword2">(</span>count <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/files-modules-and-programs-freq-fast/counter.ml">files-modules-and-programs-freq-fast/counter.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322810024144">Note that in some places the preceding code refers to <code>String.Map.t</code>, and in others <code>Map.t</code>. This has to do with the fact that maps
    are implemented as ordered binary trees, and as such, need a way of
    comparing keys.</p><p id="idm322810022320">To deal with this, a map, once created, stores the necessary
    comparison function within the data structure. Thus, operations like
    <code>Map.find</code> or <code>Map.add</code> that access the contents of a map or
    create a new map from an existing one, do so by using the comparison
    function embedded within the map.</p><p id="idm322810020336">But in order to get a map in the first place, you need to get your
    hands on the comparison function somehow. For this reason, modules like
    <code>String</code> contain a <code>Map</code> submodule that has values like <code>String.Map.empty</code> and <code>String.Map.of_alist</code> that are specialized to
    strings, and thus have access to a string comparison function. Such a
    <code>Map</code> submodule is included in every
    module that satisfies the <code>Comparable.S</code>
    interface from Core.</p><section id="creating-maps-with-comparators"><h1>Creating Maps with Comparators</h1><p id="idm322810014736">The specialized <code>Map</code> submodule
      is convenient, but it's not the only way of creating a <code>Map.t</code>. The information required to compare
      values of a given type is wrapped up in a value called a
      <span><em>comparator</em></span> that can be used to create maps using
      the <code>Map</code> module directly:<a name="idm322810011872"></a><a name="idm322810010960"></a><a name="idm322810009648"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> digit_map <span class="keyword2">=</span> <span class="keyword5">Map.</span>of_alist_exn digit_alist
                     ~comparator<span class="keyword2">:</span><span class="keyword5">Int.</span>comparator<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val digit_map : (int, string, Int.comparator) Map.t = &lt;abstr&gt;
</div># <span class="keyword5">Map.</span>find digit_map <span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string option = Some &quot;three&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322810001808">The preceding code uses <code>Map.of_alist_exn</code>, which creates a map from an
      association list, throwing an exception if there are duplicate keys in
      the list.</p><p id="idm322810000608">The comparator is only required for operations that create maps
      from scratch. Operations that update an existing map simply inherit the
      comparator of the map they start with:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> zilch_map <span class="keyword2">=</span> <span class="keyword5">Map.</span>add digit_map ~key<span class="keyword2">:</span><span class="keyword8">0</span> ~data<span class="keyword2">:</span><span class="keyword7">&quot;zilch&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val zilch_map : (int, string, Int.comparator) Map.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809996016">The type <code>Map.t</code> has three type
      parameters: one for the key, one for the value, and one to identify the
      comparator. Indeed, the type <code>'a
      Int.Map.t</code> is just a type alias for <code>(int,'a,Int.comparator) Map.t</code>.</p><p id="idm322809993488">Including the comparator in the type is important because
      operations that work on multiple maps at the same time often require
      that the maps share their comparison function. Consider, for example,
      <code>Map.symmetric_diff</code>, which computes a
      summary of the differences between two maps:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> left <span class="keyword2">=</span> <span class="keyword5">String.</span><span class="keyword5">Map.</span>of_alist_exn <span class="keyword2">[</span><span class="keyword7">&quot;foo&quot;</span>,<span class="keyword8">1</span><span class="keyword2">;</span> <span class="keyword7">&quot;bar&quot;</span>,<span class="keyword8">3</span><span class="keyword2">;</span> <span class="keyword7">&quot;snoo&quot;</span>, <span class="keyword8">0</span><span class="keyword2">]</span>
  <span class="keyword4">let</span> right <span class="keyword2">=</span> <span class="keyword5">String.</span><span class="keyword5">Map.</span>of_alist_exn <span class="keyword2">[</span><span class="keyword7">&quot;foo&quot;</span>,<span class="keyword8">0</span><span class="keyword2">;</span> <span class="keyword7">&quot;snoo&quot;</span>, <span class="keyword8">0</span><span class="keyword2">]</span>
  <span class="keyword4">let</span> diff <span class="keyword2">=</span> <span class="keyword5">Map.</span>symmetric_diff ~data_equal<span class="keyword2">:</span><span class="keyword5">Int.</span>equal left right
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val left : int String.Map.t = &lt;abstr&gt;
val right : int String.Map.t = &lt;abstr&gt;
val diff :
  (string * [ `Left of int | `Right of int | `Unequal of int * int ]) list =
  [(&quot;foo&quot;, `Unequal (1, 0)); (&quot;bar&quot;, `Left 3)]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809983456">The type of <code>Map.symmetric_diff</code>,
      which follows, requires that the two maps it compares have the same
      comparator type. Each comparator has a fresh abstract type, so the type
      of a comparator identifies the comparator uniquely:</p><div class="rwocode"><pre><code># <span class="keyword5">Map.</span>symmetric_diff<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : ('k, 'v, 'cmp) Map.t -&gt;
    ('k, 'v, 'cmp) Map.t -&gt;
    data_equal:('v -&gt; 'v -&gt; bool) -&gt;
    ('k * [ `Left of 'v | `Right of 'v | `Unequal of 'v * 'v ]) list
= &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809975536">This constraint is important because the algorithm that <code>Map.symmetric_diff</code> uses depends for its
      correctness on the fact that both maps have the same comparator.</p><p id="idm322809974368">We can create a new comparator using the <code>Comparator.Make</code> functor, which takes as its
      input a module containing the type of the object to be compared, sexp
      converter functions, and a comparison function. The sexp converters are
      included in the comparator to make it possible for users of the
      comparator to generate better error messages. Here's an
      example:<a name="idm322809973088"></a></p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Reverse </span><span class="keyword2">=</span> <span class="keyword5">Comparator.</span>Make<span class="keyword2">(</span><span class="keyword4">struct</span>
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword3">string</span>
    <span class="keyword4">let</span> sexp_of_t <span class="keyword2">=</span> <span class="keyword5">String.</span>sexp_of_t
    <span class="keyword4">let</span> t_of_sexp <span class="keyword2">=</span> <span class="keyword5">String.</span>t_of_sexp
    <span class="keyword4">let</span> compare x y <span class="keyword2">=</span> <span class="keyword5">String.</span>compare y x
  <span class="keyword4">end</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Reverse :
  sig
    type t = string
    val compare : t -&gt; t -&gt; int
    val t_of_sexp : Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
    type comparator
    val comparator : (t, comparator) Comparator.t_
  end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809959104">As you can see in the following code, both <code>Reverse.comparator</code> and <code>String.comparator</code> can be used to create maps
      with a key type of <code>string</code>:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> alist <span class="keyword2">=</span> <span class="keyword2">[</span><span class="keyword7">&quot;foo&quot;</span>, <span class="keyword8">0</span><span class="keyword2">;</span> <span class="keyword7">&quot;snoo&quot;</span>, <span class="keyword8">3</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val alist : (string * int) list = [(&quot;foo&quot;, 0); (&quot;snoo&quot;, 3)]
</div># <span class="keyword4">let</span> ord_map <span class="keyword2">=</span> <span class="keyword5">Map.</span>of_alist_exn ~comparator<span class="keyword2">:</span><span class="keyword5">String.</span>comparator alist<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ord_map : (string, int, String.comparator) Map.t = &lt;abstr&gt;
</div># <span class="keyword4">let</span> rev_map <span class="keyword2">=</span> <span class="keyword5">Map.</span>of_alist_exn ~comparator<span class="keyword2">:</span><span class="keyword5">Reverse.</span>comparator alist<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val rev_map : (string, int, Reverse.comparator) Map.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809948720"><code>Map.min_elt</code> returns the key and
      value for the smallest key in the map, which lets us see that these two
      maps do indeed use different comparison functions:</p><div class="rwocode"><pre><code># <span class="keyword5">Map.</span>min_elt ord_map<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (string * int) option = Some (&quot;foo&quot;, 0)
</div># <span class="keyword5">Map.</span>min_elt rev_map<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (string * int) option = Some (&quot;snoo&quot;, 3)
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809941920">Accordingly, if we try to use <code>Map.symmetric_diff</code> on these two maps, we'll
      get a compile-time error:</p><div class="rwocode"><pre><code># <span class="keyword5">Map.</span>symmetric_diff ord_map rev_map<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 27-34:
Error: This expression has type (string, int, Reverse.comparator) Map.t
       but an expression was expected of type
         (string, int, String.comparator) Map.t
       Type Reverse.comparator is not compatible with type String.comparator 
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 10) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="trees"><h1>Trees</h1><p id="idm322809933136">As we've discussed, maps carry within them the comparator that
      they were created with. Sometimes, often for space efficiency reasons,
      you want a version of the map data structure that doesn't include the
      comparator. You can get such a representation with <code>Map.to_tree</code>, which returns just the tree
      underlying the map, without the comparator:<a name="idm322809931872"></a><a name="idm322809930576"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> ord_tree <span class="keyword2">=</span> <span class="keyword5">Map.</span>to_tree ord_map<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ord_tree : (string, int, String.comparator) Map.Tree.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 11) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809925056">Even though a <code>Map.Tree.t</code>
      doesn't physically include a comparator, it does include the comparator
      in its type. This is what is known as a <span><em>phantom
      type</em></span>, because it reflects something about the logic of the
      value in question, even though it doesn't correspond to any values
      directly represented in the underlying physical structure of the
      value.</p><p id="idm322809923248">Since the comparator isn't included in the tree, we need to
      provide the comparator explicitly when we, say, search for a key, as
      shown below:</p><div class="rwocode"><pre><code># <span class="keyword5">Map.</span><span class="keyword5">Tree.</span>find ~comparator<span class="keyword2">:</span><span class="keyword5">String.</span>comparator ord_tree <span class="keyword7">&quot;snoo&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int option = Some 3
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 12) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809918816">The algorithm of <code>Map.Tree.find</code>
      depends on the fact that it's using the same comparator when looking up
      a value as you were when you stored it. That's the invariant that the
      phantom type is there to enforce. As you can see in the following
      example, using the wrong comparator will lead to a type error:</p><div class="rwocode"><pre><code># <span class="keyword5">Map.</span><span class="keyword5">Tree.</span>find ~comparator<span class="keyword2">:</span><span class="keyword5">Reverse.</span>comparator ord_tree <span class="keyword7">&quot;snoo&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 45-53:
Error: This expression has type (string, int, String.comparator) Map.Tree.t
       but an expression was expected of type
         (string, int, Reverse.comparator) Map.Tree.t
       Type String.comparator is not compatible with type Reverse.comparator 
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 13) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section id="the-polymorphic-comparator"><h1>The Polymorphic Comparator</h1><p id="idm322809909680">We don't need to generate specialized comparators for every type
      we want to build a map on. We can instead use a comparator based on
      OCaml's built-in polymorphic comparison function, which was discussed in
      <a href="lists-and-patterns.html">Chapter 3, <i>Lists and Patterns</i></a>. This comparator is found in the
      <code>Comparator.Poly</code> module, allowing us
      to write:<a name="idm322809907936"></a><a name="idm322809906624"></a><a name="idm322809905712"></a></p><div class="rwocode"><pre><code># <span class="keyword5">Map.</span>of_alist_exn ~comparator<span class="keyword2">:</span><span class="keyword5">Comparator.</span><span class="keyword5">Poly.</span>comparator digit_alist<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (int, string, Comparator.Poly.comparator) Map.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 14) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809900560">Or, equivalently:</p><div class="rwocode"><pre><code># <span class="keyword5">Map.</span><span class="keyword5">Poly.</span>of_alist_exn digit_alist<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (int, string) Map.Poly.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 15) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809896128">Note that maps based on the polymorphic comparator are not
      equivalent to those based on the type-specific comparators from the
      point of view of the type system. Thus, the compiler rejects the
      following:</p><div class="rwocode"><pre><code># <span class="keyword5">Map.</span>symmetric_diff <span class="keyword2">(</span><span class="keyword5">Map.</span><span class="keyword5">Poly.</span>singleton <span class="keyword8">3</span> <span class="keyword7">&quot;three&quot;</span><span class="keyword2">)</span>
                     <span class="keyword2">(</span><span class="keyword5">Int.</span><span class="keyword5">Map.</span>singleton  <span class="keyword8">3</span> <span class="keyword7">&quot;four&quot;</span> <span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 72-99:
Error: This expression has type
         string Int.Map.t = (int, string, Int.comparator) Map.t
       but an expression was expected of type
         (int, string, Comparator.Poly.comparator) Map.t
       Type Int.comparator is not compatible with type
         Comparator.Poly.comparator 
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 16) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809886912">This is rejected for good reason: there's no guarantee that the
      comparator associated with a given type will order things in the same
      way that polymorphic compare does.</p><section><h1><b>The Perils of Polymorphic Compare</b></h1><p id="idm322809885648">Polymorphic compare is highly convenient, but it has serious
        downsides as well and should be used with care. In particular,
        polymorphic compare has a fixed algorithm for comparing values of any
        type, and that algorithm can sometimes yield surprising
        results.</p><p id="idm322809884960">To understand what's wrong with polymorphic compare, you need to
        understand a bit about how it works. Polymorphic compare is
        <span><em>structural</em></span>, in that it operates directly on the
        runtime representation of OCaml values, walking the structure of the
        values in question without regard for their type.</p><p id="idm322809883856">This is convenient because it provides a comparison function that works for most OCaml
          values and largely behaves as you would expect. For example, on <code>int</code>s and <code>float</code>s, it acts as you would
          expect a numeric comparison function to act. For simple containers like strings and lists
          and arrays, it operates as a lexicographic comparison. And except for functions and values
          from outside of the OCaml heap, it works on almost every OCaml type.</p><p id="idm322809881712">But sometimes, a structural comparison is not what you want.
        Sets are a great example of this. Consider the following two
        sets:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword2">(</span>s1,s2<span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword5">Int.</span><span class="keyword5">Set.</span>of_list <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">]</span>,
                 <span class="keyword5">Int.</span><span class="keyword5">Set.</span>of_list <span class="keyword2">[</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">1</span><span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val s1 : Int.Set.t = &lt;abstr&gt;
val s2 : Int.Set.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 18) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809875856">Logically, these two sets should be equal, and that's the result
        that you get if you call <code>Set.equal</code>
        on them:</p><div class="rwocode"><pre><code># <span class="keyword5">Set.</span>equal s1 s2<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = true
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 19) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809870816">But because the elements were added in different orders, the
        layout of the trees underlying the sets will be different. As such, a
        structural comparison function will conclude that they're
        different.</p><p id="idm322809870208">Let's see what happens if we use polymorphic compare to test for
        equality by way of the <code>=</code> operator.
        Comparing the maps directly will fail at runtime because the
        comparators stored within the sets contain function values:</p><div class="rwocode"><pre><code># s1 <span class="keyword2">=</span> s2<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception: (Invalid_argument &quot;equal: functional value&quot;).
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 20) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809864992">We can, however, use the function <code>Set.to_tree</code> to expose the underlying tree
        without the attached comparator:</p><div class="rwocode"><pre><code># <span class="keyword5">Set.</span>to_tree s1 <span class="keyword2">=</span> <span class="keyword5">Set.</span>to_tree s2<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = false
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 21) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809859904">This can cause real and quite subtle bugs. If, for example, you
        use a map whose keys contain sets, then the map built with the
        polymorphic comparator will behave incorrectly, separating out keys
        that should be aggregated together. Even worse, it will work sometimes
        and fail others; since if the sets are built in a consistent order,
        then they will work as expected, but once the order changes, the
        behavior will change.</p></section></section><section id="sets"><h1>Sets</h1><p id="idm322809857888">Sometimes, instead of keeping track of a set of key/value pairs,
      you just want a data type for keeping track of a set of keys. You could
      build this on top of a map by representing a set of values by a map
      whose data type is <code>unit</code>. But a more
      idiomatic (and efficient) solution is to use Core's set type, which is
      similar in design and spirit to the map type, while having an API better
      tuned to working with sets and a lower memory footprint. Here's a simple
      example:<a name="idm322809856464"></a></p><div class="rwocode"><pre><code># <span class="keyword4">let</span> dedup ~comparator l <span class="keyword2">=</span>
    <span class="keyword5">List.</span>fold l ~init<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword5">Set.</span>empty ~comparator<span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword5">Set.</span>add
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Set.</span>to_list
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val dedup :
  comparator:('a, 'b) Core_kernel.Comparator.t_ -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
</div># dedup ~comparator<span class="keyword2">:</span><span class="keyword5">Int.</span>comparator <span class="keyword2">[</span><span class="keyword8">8</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">7</span><span class="keyword2">;</span><span class="keyword8">8</span><span class="keyword2">;</span><span class="keyword8">10</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [2; 3; 7; 8; 10]
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 17) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809846944">In addition to the operators you would expect to have for maps,
      sets support the traditional set operations, including union,
      intersection, and set difference. And, as with maps, we can create sets
      based on type-specific comparators or on the polymorphic
      comparator.</p></section><section id="satisfying-the-comparable.s-interface"><h1>Satisfying the Comparable.S Interface</h1><p id="idm322809845168">Core's <code>Comparable.S</code> interface
      includes a lot of useful functionality, including support for working
      with maps and sets. In particular, <code>Comparable.S</code> requires the presence of the
      <code>Map</code> and <code>Set</code> submodules, as well as a
      comparator.<a name="idm322809842112"></a><a name="idm322809840816"></a><a name="idm322809839504"></a><a name="idm322809838192"></a></p><p id="idm322809836752"><code>Comparable.S</code> is satisfied by
      most of the types in Core, but the question arises of how to satisfy the
      comparable interface for a new type that you design. Certainly
      implementing all of the required functionality from scratch would be an
      absurd amount of work.</p><p id="idm322809835584">The module <code>Comparable</code> contains
      a number of functors to help you automate this task. The simplest one of
      these is <code>Comparable.Make</code>, which takes
      as an input any module that satisfies the following interface:</p><div class="rwocode"><pre><code><span class="keyword4">module</span> <span class="keyword4">type</span> <span class="keyword6">Comparable </span><span class="keyword2">=</span> <span class="keyword4">sig</span>
  <span class="keyword4">type</span> t
  <span class="keyword4">val</span> sexp_of_t <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>t
  <span class="keyword4">val</span> t_of_sexp <span class="keyword2">:</span> <span class="keyword5">Sexp.</span>t -<span class="keyword2">&gt;</span> t
  <span class="keyword4">val</span> compare <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span>
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/comparable.ml">maps-and-hash-tables/comparable.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809831168">In other words, it expects a type with a comparison function, as
      well as functions for converting to and from
      <span><em>s-expressions</em></span>. S-expressions are a serialization
      format used commonly in Core and are required here to enable better
      error messages. We'll discuss s-expressions more in <a href="data-serialization-with-s-expressions.html">Chapter 17, <i>Data Serialization with S-Expressions</i></a>, but in the meantime,
      we'll use the <code>with sexp</code> declaration
      that comes from the Sexplib syntax extension. This declaration kicks off
      the automatic generation of s-expression conversion functions for the
      marked type.</p><p id="idm322809828736">The following example shows how this all fits together, following
      the same basic pattern for using functors described in <a href="functors.html#extending-modules">the section called “Extending Modules”</a>:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Foo_and_bar </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword5">Int.</span><span class="keyword5">Set.</span>t<span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span>
    <span class="keyword4">include</span> <span class="keyword5">Comparable.S </span><span class="keyword1">with</span> <span class="keyword4">type</span> t <span class="keyword2">:</span><span class="keyword2">=</span> t
  <span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">module</span> <span class="keyword6">T </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
      <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword5">Int.</span><span class="keyword5">Set.</span>t<span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp
      <span class="keyword4">let</span> compare t1 t2 <span class="keyword2">=</span>
        <span class="keyword4">let</span> c <span class="keyword2">=</span> <span class="keyword5">Int.</span><span class="keyword5">Set.</span>compare t1.foo t2.foo <span class="keyword4">in</span>
        <span class="keyword1">if</span> c <span class="keyword2">&lt;</span><span class="keyword2">&gt;</span> <span class="keyword8">0</span> <span class="keyword1">then</span> c <span class="keyword1">else</span> <span class="keyword5">String.</span>compare t1.bar t2.bar
    <span class="keyword4">end</span>
    <span class="keyword4">include</span> <span class="keyword6">T
</span>    <span class="keyword4">include</span> <span class="keyword5">Comparable.</span>Make<span class="keyword2">(</span>T<span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Foo_and_bar :
sig
  type t = { foo : Int.Set.t; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

    ...

end</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main-22.rawscript">maps-and-hash-tables/main-22.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809823248">We don't include the full response from the toplevel because it is
      quite lengthy, but <code>Foo_and_bar</code> does
      satisfy <code>Comparable.S</code>.</p><p id="idm322809821552">In the preceding code we wrote the comparison function by hand,
      but this isn't strictly necessary. Core ships with a syntax extension
      called <code>comparelib</code>, which will create
      a comparison function from a type definition. Using it, we can rewrite
      the previous example as follows:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Foo_and_bar </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword5">Int.</span><span class="keyword5">Set.</span>t<span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span>
    <span class="keyword4">include</span> <span class="keyword5">Comparable.S </span><span class="keyword1">with</span> <span class="keyword4">type</span> t <span class="keyword2">:</span><span class="keyword2">=</span> t
  <span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">module</span> <span class="keyword6">T </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
      <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword5">Int.</span><span class="keyword5">Set.</span>t<span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp, compare
    <span class="keyword4">end</span>
    <span class="keyword4">include</span> <span class="keyword6">T
</span>    <span class="keyword4">include</span> <span class="keyword5">Comparable.</span>Make<span class="keyword2">(</span>T<span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Foo_and_bar :
sig
  type t = { foo : Int.Set.t; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

  ...

end</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main-23.rawscript">maps-and-hash-tables/main-23.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809816304">The comparison function created by <code>comparelib</code> for a given type will call out to
      the comparison functions for its component types. As a result, the
      <code>foo</code> field will be compared using
      <code>Int.Set.compare</code>. This is different,
      and saner than the structural comparison done by polymorphic
      compare.</p><p id="idm322809813760">If you want your comparison function to behave in a specific way,
      you should still write your own comparison function by hand; but if all
      you want is a total order suitable for creating maps and sets with, then
      <code>comparelib</code> is a good way to
      go.</p><p id="idm322809812464">You can also satisfy the <code>Comparable.S</code> interface using polymorphic
      compare:</p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Foo_and_bar </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span>
    <span class="keyword4">include</span> <span class="keyword5">Comparable.S </span><span class="keyword1">with</span> <span class="keyword4">type</span> t <span class="keyword2">:</span><span class="keyword2">=</span> t
  <span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">module</span> <span class="keyword6">T </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
      <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp
    <span class="keyword4">end</span>
    <span class="keyword4">include</span> <span class="keyword6">T
</span>    <span class="keyword4">include</span> <span class="keyword5">Comparable.</span>Poly<span class="keyword2">(</span>T<span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Foo_and_bar :
sig
  type t = { foo : int; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

  ...

end
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main-24.rawscript">maps-and-hash-tables/main-24.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809807440">That said, for reasons we discussed earlier, polymorphic compare
      should be used sparingly.</p><section><h1><b>=, ==, and phys_equal</b></h1><p id="idm322809806304">If you come from a C/C++ background, you'll probably reflexively
          use <code>==</code> to test two values for
          equality. In OCaml, the <code>==</code> operator
          tests for <span><em>physical</em></span> equality, while the <code>=</code> operator tests for
          <span><em>structural</em></span> equality.</p><p id="idm322809803088">The physical equality test will match if two data structures have
          precisely the same pointer in memory. Two data structures that have
          identical contents but are constructed separately will not match using
          <code>==</code>.</p><p id="idm322809801840">The <code>=</code> structural equality
          operator recursively inspects each field in the two values and tests
          them individually for equality. Crucially, if your data structure is
          cyclical (that is, a value recursively points back to another field
          within the same structure), the <code>=</code>
          operator will never terminate, and your program will hang! You therefore
          must use the physical equality operator or write a custom comparison
          function when comparing cyclic values.</p><p id="idm322809799664">It's quite easy to mix up the use of <code>=</code> and <code>==</code>,
          so Core disables the <code>==</code> operator and
          provides the more explicit <code>phys_equal</code>
          function instead. You'll see a type error if you use <code>==</code> anywhere in code that opens <code>Core.Std</code>:</p><div class="rwocode"><pre><code># <span class="keyword1">open</span> <span class="keyword5">Core.Std </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword8">1</span> <span class="keyword2">=</span><span class="keyword2">=</span> <span class="keyword8">2</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters -1-1:
Error: This expression has type int but an expression was expected of type
         [ `Consider_using_phys_equal ]
</div># phys_equal <span class="keyword8">1</span> <span class="keyword8">2</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = false
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/core_phys_equal.topscript">maps-and-hash-tables/core_phys_equal.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809787120">If you feel like hanging your OCaml interpreter, you can verify
          what happens with recursive values and structural equality for
          yourself:</p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t1 <span class="keyword2">=</span> <span class="keyword2">{</span> foo1<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">;</span> bar1<span class="keyword2">:</span>t2 <span class="keyword2">}</span> <span class="keyword4">and</span> t2 <span class="keyword2">=</span> <span class="keyword2">{</span> foo2<span class="keyword2">:</span><span class="keyword3">int</span><span class="keyword2">;</span> bar2<span class="keyword2">:</span>t1 <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t1 = { foo1 : int; bar1 : t2; }
and t2 = { foo2 : int; bar2 : t1; }</div># <span class="keyword4">let</span> <span class="keyword4">rec</span> v1 <span class="keyword2">=</span> <span class="keyword2">{</span> foo1<span class="keyword2">=</span><span class="keyword8">1</span><span class="keyword2">;</span> bar1<span class="keyword2">=</span>v2 <span class="keyword2">}</span> <span class="keyword4">and</span> v2 <span class="keyword2">=</span> <span class="keyword2">{</span> foo2<span class="keyword2">=</span><span class="keyword8">2</span><span class="keyword2">;</span> bar2<span class="keyword2">=</span>v1 <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">&lt;lots of text&gt;</div># v1 <span class="keyword2">=</span><span class="keyword2">=</span> v1<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = true</div># phys_equal v1 v1<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = true</div># v1 <span class="keyword2">=</span> v1 <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">&lt;press ^Z and kill the process now&gt;</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/phys_equal.rawscript">maps-and-hash-tables/phys_equal.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section></section></section><section id="hash-tables"><h1>Hash Tables</h1><p id="idm322809776800">Hash tables are the imperative cousin of maps. We walked over a
    basic hash table implementation in <a href="imperative-programming-1.html">Chapter 8, <i>Imperative Programming</i></a>, so in this section we'll mostly
    discuss the pragmatics of Core's <code>Hashtbl</code> module. We'll cover this material more
    briefly than we did with maps because many of the concepts are
    shared.<a name="idm322809775072"></a></p><p id="idm322809773648">Hash tables differ from maps in a few key ways. First, hash tables
    are mutable, meaning that adding a key/value pair to a hash table modifies
    the table, rather than creating a new table with the binding added.
    Second, hash tables generally have better time-complexity than maps,
    providing constant-time lookup and modifications, as opposed to
    logarithmic for maps. And finally, just as maps depend on having a
    comparison function for creating the ordered binary tree that underlies a
    map, hash tables depend on having a <span><em>hash function</em></span>,
    i.e., a function for converting a key to an integer.<a name="idm322809772896"></a><a name="idm322809771632"></a><a name="idm322809770736"></a></p><aside class="warning"><h1>Time Complexity of Hash Tables</h1><p id="idm322809768384">The statement that hash tables provide constant-time access hides some complexities.
        First of all, any hash table implementation, OCaml's included, needs to resize the table
        when it gets too full. A resize requires allocating a new backing array for the hash table
        and copying over all entries, and so it is quite an expensive operation. That means adding a
        new element to the table is only <span><em>amortized</em></span> constant, which is to say,
        it's constant on average over a long sequence of operations, but some of the individual
        operations can be quite expensive.</p><p id="idm322809766992">Another hidden cost of hash tables has to do with the hash function you use. If you end
        up with a pathologically bad hash function that hashes all of your data to the same number,
        then all of your insertions will hash to the same underlying bucket, meaning you no longer
        get constant-time access at all. Core's hash table implementation uses binary trees for the
        hash-buckets, so this case only leads to logarithmic time, rather than linear for a
        traditional hash table.</p><p id="idm322809766096">The logarithmic behavior of Core's hash tables in the presence of hash collisions also
        helps protect against some denial-of-service attacks. One well-known type of attack is to
        send queries to a service with carefully chosen keys to cause many collisions. This, in
        combination with the linear behavior of most hashtables, can cause the service to become
        unresponsive due to high CPU load. Core's hash tables would be much less susceptible to such
        an attack because the amount of degradation would be far less.<a name="idm322809765280"></a><a name="idm322809747664"></a></p></aside><p id="idm322809746496">When creating a hash table, we need to provide a value of type
    <span><em>hashable</em></span>, which includes among other things the
    function for hashing the key type. This is analogous to the comparator
    used for creating maps:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> table <span class="keyword2">=</span> <span class="keyword5">Hashtbl.</span>create ~hashable<span class="keyword2">:</span><span class="keyword5">String.</span>hashable <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val table : (string, '_a) Hashtbl.t = &lt;abstr&gt;
</div># <span class="keyword5">Hashtbl.</span>replace table ~key<span class="keyword2">:</span><span class="keyword7">&quot;three&quot;</span> ~data<span class="keyword2">:</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div># <span class="keyword5">Hashtbl.</span>find table <span class="keyword7">&quot;three&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int option = Some 3
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 25) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809737920">The <code>hashable</code> value is included as
    part of the <code>Hashable.S</code> interface, which
    is satisfied by most types in Core. The <code>Hashable.S</code> interface also includes a <code>Table</code> submodule which provides more convenient
    creation functions:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> table <span class="keyword2">=</span> <span class="keyword5">String.</span><span class="keyword5">Table.</span>create <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val table : '_a String.Table.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 26) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809730720">There is also a polymorphic <code>hashable</code> value, corresponding to the polymorphic
    hash function provided by the OCaml runtime, for cases where you don't
    have a hash function for your specific type:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> table <span class="keyword2">=</span> <span class="keyword5">Hashtbl.</span>create ~hashable<span class="keyword2">:</span><span class="keyword5">Hashtbl.</span><span class="keyword5">Poly.</span>hashable <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 27) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809725504">Or, equivalently:</p><div class="rwocode"><pre><code># <span class="keyword4">let</span> table <span class="keyword2">=</span> <span class="keyword5">Hashtbl.</span><span class="keyword5">Poly.</span>create <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 28) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809721120">Note that, unlike the comparators used with maps and sets, hashables
    don't show up in the type of a <code>Hashtbl.t</code>. That's because hash tables don't have
    operations that operate on multiple hash tables that depend on those
    tables having the same hash function, in the way that <code>Map.symmetric_diff</code> and <code>Set.union</code> depend on their arguments using the
    same comparison function.<a name="idm322809718544"></a></p><aside class="warning"><h1>Collisions with the Polymorphic Hash Function</h1><p id="idm322809716224">OCaml's polymorphic hash function works by walking over the data
      structure it’s given using a breadth-first traversal that is bounded in
      the number of nodes it’s willing to traverse. By default, that bound is
      set at 10 &quot;meaningful&quot; nodes.<a name="idm322809715344"></a></p><p id="idm322809714000">The bound on the traversal means that the hash function may ignore part of the data
        structure, and this can lead to pathological <span>cases</span>
        where every value you store has the same hash value. We'll demonstrate this below, using the
        function <code>List.range</code> to allocate lists of integers of
        different length:</p><div class="rwocode"><pre><code># <span class="keyword5">Caml.</span><span class="keyword5">Hashtbl.</span>hash <span class="keyword2">(</span><span class="keyword5">List.</span>range <span class="keyword8">0</span> <span class="keyword8">9</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 209331808
</div># <span class="keyword5">Caml.</span><span class="keyword5">Hashtbl.</span>hash <span class="keyword2">(</span><span class="keyword5">List.</span>range <span class="keyword8">0</span> <span class="keyword8">10</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 182325193
</div># <span class="keyword5">Caml.</span><span class="keyword5">Hashtbl.</span>hash <span class="keyword2">(</span><span class="keyword5">List.</span>range <span class="keyword8">0</span> <span class="keyword8">11</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 182325193
</div># <span class="keyword5">Caml.</span><span class="keyword5">Hashtbl.</span>hash <span class="keyword2">(</span><span class="keyword5">List.</span>range <span class="keyword8">0</span> <span class="keyword8">100</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 182325193
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</a> , continued (part 29) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809702592">As you can see, the hash function stops after the first 10
      elements. The same can happen with any large data structure, including
      records and arrays. When building hash functions over large custom data
      structures, it is generally a good idea to write one's own hash
      function.</p></aside><section id="satisfying-the-hashable.s-interface"><h1>Satisfying the Hashable.S Interface</h1><p id="idm322809700816">Most types in Core satisfy the <code>Hashable.S</code> interface, but as with the <code>Comparable.S</code> interface, the question remains
      of how one should satisfy this interface when writing a new module.
      Again, the answer is to use a functor to build the necessary
      functionality; in this case, <code>Hashable.Make</code>. Note that we use OCaml's
      <code>lxor</code> operator for doing the &quot;logical&quot;
      (i.e., bitwise) exclusive Or of the hashes from the component
      values:<a name="idm322809697536"></a><a name="idm322809696640"></a><a name="idm322809695344"></a><a name="idm322809694432"></a></p><div class="rwocode"><pre><code># <span class="keyword4">module</span> <span class="keyword6">Foo_and_bar </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
    <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span>
    <span class="keyword4">include</span> <span class="keyword5">Hashable.S </span><span class="keyword1">with</span> <span class="keyword4">type</span> t <span class="keyword2">:</span><span class="keyword2">=</span> t
  <span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>
    <span class="keyword4">module</span> <span class="keyword6">T </span><span class="keyword2">=</span> <span class="keyword4">struct</span>
      <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp, compare
      <span class="keyword4">let</span> hash t <span class="keyword2">=</span>
        <span class="keyword2">(</span><span class="keyword5">Int.</span>hash t.foo<span class="keyword2">)</span> <span class="keyword2">lxor</span> <span class="keyword2">(</span><span class="keyword5">String.</span>hash t.bar<span class="keyword2">)</span>
    <span class="keyword4">end</span>
    <span class="keyword4">include</span> <span class="keyword6">T
</span>    <span class="keyword4">include</span> <span class="keyword5">Hashable.</span>Make<span class="keyword2">(</span>T<span class="keyword2">)</span>
  <span class="keyword4">end</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">module Foo_and_bar :
sig
  type t = { foo : int; bar : string; }
  module Hashable : sig type t = t end
  val hash : t -&gt; int
  val compare : t -&gt; t -&gt; int
  val hashable : t Pooled_hashtbl.Hashable.t

  ...

end</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/main-30.rawscript">maps-and-hash-tables/main-30.rawscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809689200">Note that in order to satisfy hashable, one also needs to provide
      a comparison function. That's because Core's hash tables use an ordered
      binary tree data structure for the hash-buckets, so that performance of
      the table degrades gracefully in the case of pathologically bad choice
      of hash function.</p><p id="idm322809688480">There is currently no analogue of <code>comparelib</code> for autogeneration of hash
      functions, so you do need to either write the hash function by hand, or
      use the built-in polymorphic hash function, <code>Hashtbl.hash</code>.</p></section></section><section id="choosing-between-maps-and-hash-tables"><h1>Choosing Between Maps and Hash Tables</h1><p id="idm322809685392">Maps and hash tables overlap enough in functionality that it's not
    always clear when to choose one or the other. Maps, by virtue of being
    immutable, are generally the default choice in OCaml. OCaml also has good
    support for imperative programming, though, and when programming in an
    imperative idiom, hash tables are often the more natural choice.<a name="idm322809684768"></a><a name="idm322809683232"></a></p><p id="idm322809681568">Programming idioms aside, there are significant performance differences between maps and
      hash tables. For code that is dominated by updates and lookups, hash tables are a clear
      performance win, and the win is clearer the larger the amount of data.</p><p id="idm322809680912">The best way of answering a performance question is by running a
    benchmark, so let's do just that. The following benchmark uses the
    <code>core_bench</code> library, and it compares
    maps and hash tables under a very simple workload. Here, we're keeping
    track of a set of 1,000 different integer keys and cycling over the keys
    and updating the values they contain. Note that we use the <code>Map.change</code> and <code>Hashtbl.change</code> functions to update the
    respective data structures:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Core_bench.Std
</span>
<span class="keyword4">let</span> map_iter ~num_keys ~iterations <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">rec</span> loop i map <span class="keyword2">=</span>
    <span class="keyword1">if</span> i <span class="keyword2">&lt;</span><span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">then</span> <span class="keyword2">(</span><span class="keyword2">)</span>
    <span class="keyword1">else</span> loop <span class="keyword2">(</span>i - <span class="keyword8">1</span><span class="keyword2">)</span>
           <span class="keyword2">(</span><span class="keyword5">Map.</span>change map <span class="keyword2">(</span>i <span class="keyword2">mod</span> num_keys<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword1">fun</span> current -<span class="keyword2">&gt;</span>
              <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword8">1</span> <span class="keyword2">+</span> <span class="keyword5">Option.</span>value ~default<span class="keyword2">:</span><span class="keyword8">0</span> current<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword4">in</span>
  loop iterations <span class="keyword5">Int.</span><span class="keyword5">Map.</span>empty

<span class="keyword4">let</span> table_iter ~num_keys ~iterations <span class="keyword2">=</span>
  <span class="keyword4">let</span> table <span class="keyword2">=</span> <span class="keyword5">Int.</span><span class="keyword5">Table.</span>create ~size<span class="keyword2">:</span>num_keys <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> <span class="keyword4">rec</span> loop i <span class="keyword2">=</span>
    <span class="keyword1">if</span> i <span class="keyword2">&lt;</span><span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">then</span> <span class="keyword2">(</span><span class="keyword2">)</span>
    <span class="keyword1">else</span> <span class="keyword2">(</span>
      <span class="keyword5">Hashtbl.</span>change table <span class="keyword2">(</span>i <span class="keyword2">mod</span> num_keys<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword1">fun</span> current -<span class="keyword2">&gt;</span>
        <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword8">1</span> <span class="keyword2">+</span> <span class="keyword5">Option.</span>value ~default<span class="keyword2">:</span><span class="keyword8">0</span> current<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
      loop <span class="keyword2">(</span>i - <span class="keyword8">1</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
  <span class="keyword4">in</span>
  loop iterations

<span class="keyword4">let</span> tests ~num_keys ~iterations <span class="keyword2">=</span>
  <span class="keyword4">let</span> test name f <span class="keyword2">=</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create f ~name <span class="keyword4">in</span>
  <span class="keyword2">[</span> test <span class="keyword7">&quot;map&quot;</span>   <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> map_iter   ~num_keys ~iterations<span class="keyword2">)</span>
  <span class="keyword2">;</span> test <span class="keyword7">&quot;table&quot;</span> <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> table_iter ~num_keys ~iterations<span class="keyword2">)</span>
  <span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  tests ~num_keys<span class="keyword2">:</span><span class="keyword8">1000</span> ~iterations<span class="keyword2">:</span><span class="keyword8">100_000</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span>make_command
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/map_vs_hash.ml">maps-and-hash-tables/map_vs_hash.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809675584">The results show the hash table version to be around four times
    faster than the map version:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg core_bench map_vs_hash.native
</div><div class="highlight"><span class="gp">$</span> ./map_vs_hash.native -ascii -clear-columns name <span class="nb">time </span>speedup
</div><div class="rwocodeout">Estimated testing time 20s (change using -quota SECS).</div><div class="rwocodeout">                                </div><div class="rwocodeout">  Name      Time/Run   Speedup  </div><div class="rwocodeout"> ------- ------------ --------- </div><div class="rwocodeout">  map     20_234_582      1.00  </div><div class="rwocodeout">  table    4_429_771      4.57  </div><div class="rwocodeout">                                </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/run_map_vs_hash.out">maps-and-hash-tables/run_map_vs_hash.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809666256">We can make the speedup smaller or larger depending on the details
    of the test; for example, it will vary with the number of distinct keys.
    But overall, for code that is heavy on sequences of querying and updating
    a set of key/value pairs, hash tables will significantly outperform
    maps.</p><p id="idm322809665568">Hash tables are not always the faster choice, though. In particular,
    maps are often more performant in situations where you need to keep
    multiple related versions of the data structure in memory at once. That's
    because maps are immutable, and so operations like <code>Map.add</code> that modify a map do so by creating a
    new map, leaving the original undisturbed. Moreover, the new and old maps
    share most of their physical structure, so multiple versions can be kept
    around efficiently.</p><p id="idm322809664256">Here's a benchmark that demonstrates this. In it, we create a list
    of maps (or hash tables) that are built up by iteratively applying small
    updates, keeping these copies around. In the map case, this is done by
    using <code>Map.change</code> to update the map. In
    the hash table implementation, the updates are done using <code>Hashtbl.change</code>, but we also need to call
    <code>Hashtbl.copy</code> to take snapshots of the
    table:</p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword5">Core_bench.Std
</span>
<span class="keyword4">let</span> create_maps ~num_keys ~iterations <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">rec</span> loop i map <span class="keyword2">=</span>
    <span class="keyword1">if</span> i <span class="keyword2">&lt;</span><span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">then</span> <span class="keyword2">[</span><span class="keyword2">]</span>
    <span class="keyword1">else</span>
      <span class="keyword4">let</span> new_map <span class="keyword2">=</span>
        <span class="keyword5">Map.</span>change map <span class="keyword2">(</span>i <span class="keyword2">mod</span> num_keys<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword1">fun</span> current -<span class="keyword2">&gt;</span>
          <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword8">1</span> <span class="keyword2">+</span> <span class="keyword5">Option.</span>value ~default<span class="keyword2">:</span><span class="keyword8">0</span> current<span class="keyword2">)</span><span class="keyword2">)</span>
      <span class="keyword4">in</span>
      new_map <span class="keyword2">:</span><span class="keyword2">:</span> loop <span class="keyword2">(</span>i - <span class="keyword8">1</span><span class="keyword2">)</span> new_map
  <span class="keyword4">in</span>
  loop iterations <span class="keyword5">Int.</span><span class="keyword5">Map.</span>empty

<span class="keyword4">let</span> create_tables ~num_keys ~iterations <span class="keyword2">=</span>
  <span class="keyword4">let</span> table <span class="keyword2">=</span> <span class="keyword5">Int.</span><span class="keyword5">Table.</span>create ~size<span class="keyword2">:</span>num_keys <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> <span class="keyword4">rec</span> loop i <span class="keyword2">=</span>
    <span class="keyword1">if</span> i <span class="keyword2">&lt;</span><span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">then</span> <span class="keyword2">[</span><span class="keyword2">]</span>
    <span class="keyword1">else</span> <span class="keyword2">(</span>
      <span class="keyword5">Hashtbl.</span>change table <span class="keyword2">(</span>i <span class="keyword2">mod</span> num_keys<span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword1">fun</span> current -<span class="keyword2">&gt;</span>
        <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword8">1</span> <span class="keyword2">+</span> <span class="keyword5">Option.</span>value ~default<span class="keyword2">:</span><span class="keyword8">0</span> current<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
      <span class="keyword4">let</span> new_table <span class="keyword2">=</span> <span class="keyword5">Hashtbl.</span>copy table <span class="keyword4">in</span>
      new_table <span class="keyword2">:</span><span class="keyword2">:</span> loop <span class="keyword2">(</span>i - <span class="keyword8">1</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
  <span class="keyword4">in</span>
  loop iterations

<span class="keyword4">let</span> tests ~num_keys ~iterations <span class="keyword2">=</span>
  <span class="keyword4">let</span> test name f <span class="keyword2">=</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create f ~name <span class="keyword4">in</span>
  <span class="keyword2">[</span> test <span class="keyword7">&quot;map&quot;</span>   <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> ignore <span class="keyword2">(</span>create_maps   ~num_keys ~iterations<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">;</span> test <span class="keyword7">&quot;table&quot;</span> <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> ignore <span class="keyword2">(</span>create_tables ~num_keys ~iterations<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  tests ~num_keys<span class="keyword2">:</span><span class="keyword8">50</span> ~iterations<span class="keyword2">:</span><span class="keyword8">1000</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span>make_command
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/map_vs_hash2.ml">maps-and-hash-tables/map_vs_hash2.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809658992">Unsurprisingly, maps perform far better than hash tables on this
    benchmark, in this case by more than a factor of 10:</p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg core_bench map_vs_hash2.native
</div><div class="highlight"><span class="gp">$</span> ./map_vs_hash2.native -ascii -clear-columns name <span class="nb">time </span>speedup
</div><div class="rwocodeout">Estimated testing time 20s (change using -quota SECS).</div><div class="rwocodeout">                               </div><div class="rwocodeout">  Name     Time/Run   Speedup  </div><div class="rwocodeout"> ------- ----------- --------- </div><div class="rwocodeout">  map       147_208     11.28  </div><div class="rwocodeout">  table   1_660_635      1.00  </div><div class="rwocodeout">                               </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/maps-and-hash-tables/run_map_vs_hash2.out">maps-and-hash-tables/run_map_vs_hash2.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idm322809649680">These numbers can be made more extreme by increasing the size of the
    tables or the length of the list.</p><p id="idm322809649184">As you can see, the relative performance of trees and maps depends a
    great deal on the details of how they're used, and so whether to choose
    one data structure or the other will depend on the details of the
    application.<a name="idm322809648688"></a><a name="idm322809647776"></a><a name="idm322809646864"></a><a name="idm322809645952"></a><a name="idm322809645040"></a><a name="idm322809644128"></a></p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt02.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="command-line-parsing.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>
