Thanks for the detailed feedback!  It's particularly nice to get
feedback from someone who doesn't already know the language.

>  This deserves a little more explanation:
>  
>   if test x then x else y;
>  
>  The interpretor must determine that "test" is a function because it
>  sees "test x". But the interpretor places no restrictions on the
>  number of arguments "test" takes.  In fact, the same generic 'a
>  type is assigned to all three arguments.

This is definitely tricky territory.  I don't think that what you said
about the interpreter not putting constraints on the number of
arguments that `test` takes is right.  Here's the inferred type:

    val first_if_true : ('a -> bool) -> 'a -> 'a -> 'a = <fun>

The type of the `test` arguments is `('a -> bool)`, which means that
test has to be a one-argument function whose return value is `bool`.
And, the type `'a` it takes has to be the same as the type of the
other two arguments, `x` and `y`.

Does it make more sense with this explanation?  Is there something I
can do to clarify the text?

This isn't quite related to your question, but looking at the example
makes me wonder if it would be clarifying to add some extra
parenthesization, even if it isn't strictly necessary.  i.e., instead
of writing

    # let first_if_true test x y =
        if test x then x else y;;

should I write this?

    # let first_if_true test x y =
        if (test x) then x else y;;

> I would expect the interpreter to treat test differently
>  from x and y. You should also talk about the definition of the
>  function passed as "test" to first_if_true. A function must be
>  defined to take a single argument if the programmer wants to pass
>  it as "test".
>
>  The long_string example would be easier to understand if you replaced
>  "bar" with meaningful output, such as "This string is long".

Nice idea.  I'll do that.

>  Define "pattern-matching syntax". It's not what we're used to from
>  regular expressions. Apparently, when you assign a variable to a
>  tuple, the elements of the variable are extracted into the variables
>  specified in the tuple.

I agree it's not like regular expressions, but the same thing does
show up in a simple form in python:

    >>> def foo():
    ...     return (1,2)
    ... 
    >>> (x,y) = foo ()
    >>> x
    1
    >>> y
    2

Is there some terminology there worth stealing?  Do you know what this
is called in python-land?

>  Regarding the "distance" function: it's a fine early example, but the
>  reader unused to OCaml syntax has to read it three or four times to
>  understand it. I would add a couple sentences of explanation: the
>  function starts with two "let" expressions that extract the two floats
>  within each point passed. Then it executes the geometric formula (the
>  square of the hypotenuse) to find the distance.
>
>  I would prefer to see the match expression in the section that
>  introduces pattern-matching. The "distance" example of
>  pattern-matching leads naturally into match, I think. Now, you don't
>  have many data structures yet to play with, because you've introduced
>  the reader just to the basic data types and to tuples. But I think
>  there are still nice things you could do with match.

I'm somewhat attached to the idea of introducing each new
datastructure and at the same time introducing the pattern-matching
syntax that goes with it, but I agree that it's a bit hard to follow.
I tried to add a bit more explanation.  When you get a chance, take a
look and tell me if it reads better now.

>  It might also be easier for the reader to see tuples, lists, and
>  records side by side; a subsection about data structures. This would
>  separate out the simple tasks of creating and extracting data from
>  data structures. There are other, more complicated topics that you mix
>  in with these; perhaps they should come later.

There's definitely going to be a section with more detailed coverage
of these data structures later.  This is meant to be just a first taste.

>  I have trouble with the Options section. This plural term (options)
>  starts out confusing, because the section seems to be about creating a
>  variable or other placeholder that could have no value. I'd like the
>  title to reflect that. I also don't conceive of "option" as a type
>  like int or float. Its role has to be explained better.

Yeah, option presents some conceptual difficulties.  An option isn't a
type like an int or a float, but it is very much like a list or a
tuple: it is a type that can contain other types.  Indeed, you can
think of an option as a specialized list that can contain only zero or
one elements.

Is changing the title really the right solution?  I do think that
tuples, options and lists are quite parallel, and the language
reflects that now.  I'm not sure that breaking that is a good idea.

>  The language defines None and Some as keywords, and that has to be
>  explained. You've had if/then/else expressions earlier, so what is
>  different about the expression with None in it? And why do you need to
>  say Some when you just want to return x/y? I suppose that's where the
>  concept of an option as its own type come in.

This is another tricky point.  `None` and `Some` are not actually
keywords: they do happen to be defined by the standard library, but
you could define new ones if you wanted, e.g.:

   type 'a my_option = | Just of 'a
                       | Nothing
   
is a type that's a lot like the option type, and could be used in
basically the same way.  It just happens not to be the standard.  I
was hoping to punt on explaining this in detail until the section that
explicitly covers variant types (which is what both `option` and
`my_option` are examples of.)

So, I guess I'm a little non-plussed.  I'm not sure what to do to
improve this section, but I'll read it over again and think.

>  Looking at your first two examples, I see two good situations for
>  using None, and I would just say that to start the section. Sometimes
>  you want to return the equivalent of a C-language NULL from a
>  function, as you show in your first example. And sometimes you want to
>  let the caller omit an argument and supply a default within the
>  function, as you show in your second example.
>  
>  "...if you have a function that takes an argument of type string, it's
>  guaranteed to actually get a well-defined value of type string when it
>  is invoked." Only if the programmer invokes it correctly. 
>  Who is guaranteeing that a string is present? This doesn't seem to
>  me a lot different from Java or C, where prototypes ensure that a
>  program has to pass arguments of the type expected by the function
>  in order to compile. NULL can be explicitly passed, but the
>  programmer presumably knows what he or she is doing. In OCaml,
>  maybe you can't invoke the function with a null pointer, but you
>  can produce an exception by passing the wrong thing.

No, I believe my claim really is right.  The type-system prevents you
from calling a function unless you have an actual concrete string in
your hand.  If you violate this rule, your program won't compile.  It
certainly won't lead to a run-time exception.  The difference between
exceptions and type-errors is harder to see when playing around in the
top-level, but when building a big program, the difference is big:
it's the difference between something that is caught when you compile,
versus something that might be caught after you're in production.

Do you think I should make that point more explicitly here?

>  I think this construct requires more explanation:
>  
>   hd :: tl
>  
>  I'm assuming this is like (car l) and (cdr l) in Lisp. You need to
>  explain that the :: splits a list into to variable, one containing the
>  value at the head of the list (in the proper type) and the other
>  containing the rest of the list.

Sounds like I breezed past that too quickly.  I'll try to make it a
little clearer.

>  I don't believe you explained the dot syntax for referring to a member
>  variable or invoking a function on an object. That would require a bit
>  of discussion about objects and methods--hopefully very little,
>  because I think it's fair to expect readers to know those concepts
>  from other languages.

Maybe this does require more discussion.  The dot-notation is actually
not used for objects (objects are an esoteric topic in OCaml, and left
to the last chapters of the book).  It's used for two things:

- accessing a definition from a module, e.g., `List.sort`
- accessing a record field, e.g., `vec.x`

I'll try to put some clarifying language in.

>  Explain that the map method assigns names to arguments, and
>  particularly assigns the name f to the function passed.
>  
>  "Thus, we could have written..." You switched the expressions in this
>  sentence.

Fided.

>  Why use "vec" to refer to a point? Usually a vector is represented by
>  a distance and angle.

Technically, vectors can be expressed in both polar and rectalinear
coordinates, but your point is well taken.  point would be clearer.
Fixed.

>  In "x = 3.; y = -4." do the decimal points have to be included? Would
>  an exception be generated if you passed integers?

Not an exception, but a type error.  3 is an integer literal, 3. is a
floating-point literal.

Do you think I should discuss this more explicitly?

>  "The | character separates the different cases of the variant..." The
>  character also precedes the first case, but I guess that's obvious
>  from the example and doesn't have to be said.
>  
>  This is a lambda:
>  
>   (fun shape -> is_inside_shape vec shape)
>  
>  So you have to explain what you're doing here: creating an unnamed
>  function on the fly to pass to for_all.

That was just a mistake.  I shouldn't have silently introduced
lambdas.  I just switched it to be a named (but locally defined)
function.  Tell me if that seems clearer -- it could still require
explanation.
