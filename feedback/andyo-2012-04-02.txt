Some very quick responses.  I'll do a point-by-point later.

> The meta-advice that comes out of my reading of this chapter is this:
> slow down and take apart the examples more. Help the reader understand
> how each line, each definition fits in.

Sounds sensible.  I'll reread the chapter, with that in mind.

> There are a few typos I didn't bother to point out because a
> copy-editor or proofreader can fix them later.
>
> A note on formatting: we don't have to use <> characters to enclose
> placeholders. We use a slanted font instead. In DocBook, the tag is
> <replaceable>. I don't know what Markdown offers, but italic is
> probably OK.

Yeah, I understand that this is provisional.  I don't have a good way
of fixing this in our markdown source right now, but I imagine we'll
add a little post-processor that does the right thing.

> This reads like jargon based on internal interpreter/compiler
> behavior: "Every variable binding has a scope, which is the portion of
> the code that considers the given variable binding during its
> evaluation." How about this instead: "Every variable binding has a
> scope, which is the portion of the code that recognizes it."
>
> "The scope of a top-level let binding is everything that follows it in
> that module." This seems to refer to a let statement in a file. I
> think you want to distinguish here between a file and a session, so
> you should make that clear.

I've tried to simplify the language here.  As to your point about
modules, we haven't really introduced modules yet, so I'm going to
make the notion of a top-level session primary, mentioning the module
case in passing.  

> The following is too academic, not a useful example:
>
>       let <identifier> = <expr1> in <expr2>
> and:  let x = 3 + 1 in x * 2
>
> In books like this from O'Reilly, we want to see small and simple
> examples that demonstrate the purpose of using a construct.

I was worried about this when I wrote it.  The problem is, we have so
little of the language at our disposal that it's hard to put together
compelling examples.  I'll see what if I can come up with something.

> "Note that nested bindings can shadow, or hide, previous bindings." In
> other words, the original variable with its original value is still in
> scope after the nested scope ends. You say that a bit later, but it's
> worth saying here.

I rewrote this whole section.  I'd appreciate your feedback on the new
writeup.  I'm hoping it conveys the same information in a somewhat
less clinical and confusing form.

> In the currying example:
>
>   let dist_from_3 = abs_diff 3
>
> Draw the reader's attention explicitly to the way you have buried
> abs_diff along with an argument into another function. You could also
> say that dist_from_3 calls abs_diff with one of its two values already
> filled in.

I rewrote the section to try to make it clearer.  Tell me what you
think!

> This is too long and too abstract: "Labeled arguments also make it
> possible to place the arguments to a function in different orders,
> which is useful for functions like List.map where you often want to
> partially apply List.map with just the function, and at the same time
> mapping over a large function is easier to read if the function is the
> last argument." I suggest you end the first sentence after "orders".
> Then say, "For instance, if you apply List.map..." and give an actual
> example.

I've added a couple of examples.  Tell me what you think.

> Your "divide" example is a bit too hard to understand and requires a
> little more explanation. You should point out that apply_to_tuple sets
> up certain expectations about the order of the arguments, which the
> divide call violates.

I've tried to clean this up by having more helpful notes along the
way.  Tell me what you think.

> This doesn't looke right, like there's an extra word or missing word:
> "In principle, it seems like the type first argument of foo..." This
> passage is hard to understand in general. You seem to be saying that
> there are problems with argument types are inferred, which are not
> present when the types are specified. But when you fix the foo
> example, you specify just one value, the return value. Why does that
> fix things? Also, when you introduced optional arguments in the concat
> example, the question mark appeared where I expected it on the first
> appearance of sep (before the equal sign) but the foo example has the
> question marks after the equal sign, which I don't understand.
>
> "The behavior of substituting in a default value is so common that it
> has its own syntax." This should be moved up a bit to follow the
> definition of concat.
>
> "One subtle aspect of optional arguments is the question of OCaml..."
> I think a "when" is missing in there.
>
> Section: "Erasure of optional arguments": I can't understand the
> scenario that you use to set up the question. The example defines
> concat (although you don't provide a default for the sep argument,
> which I thought was a necessity) and then runs concat, but there's no
> output from concat. Is the last line an error message? We need an
> explanation of the situations where OCaml is "waiting" for an argument
> to be defined. That is not a situation I'm familiar with in other
> languages that allow optional arguments. It seems to be a matter of
> the order of passing arguments, but the whole issue is very unclear.
>
> I see a simpler explanation to the prepend_foo example. (I think you
> should just start with this example.) The definition of prepend_foo
> omits the first argument (sep). Because the second argument is
> specified without the first argument, the compiler goes ahead and
> assigns the default to the first argument. There is no way to go in
> later and specify the first argument. What I'm saying boils down to
> what you said but is much more intuitive, I think. In fact, I dislike
> the term "erased" altogether, because I assume a default is assigned;
> there's no erasure.
>
> The section "When to use optional arguments" is useful and should
> probably come earlier, maybe even before "How are optional arguments
> inferred?"
>
> Section "Computing the widths": The code here is substantially more
> complex than earlier code. It offers an opportunity to teach readers
> how to read OCaml code. Any programming language becomes easier to
> scan with the eye as a programmer gets more comfortable with the
> language. The first few functions are painful to untrained readers. I
> think for this example, I would ask the reader to start by figuring
> out what to_lengths, ~init, and ~f do. You have to tell readers
> yourself what map2_exn does. The next question, which I often have to
> puzzle out when looking at a functional language (or others, really)
> is when each function runs. How often, and in what order? Which runs
> once, and which runs once per list element?
>
> I can't quite figure out the render_separator function either. The
> outermost action is the final one that puts the | vertical characters
> on either side. This action plugs in the "pieces" strings, and
> "pieces" is defined earlier to take the widths list. Thus, there's an
> implied loop over "pieces". I would like you to step through this
> sequence.
>
> Section: "Performance of String.concat and ^": I suggest making this a
> sidebar. It interrupts the natural sequence, which is to go from the
> definition of render_separator to the paragraph starting
> "We can write a very similar piece of code for..." So you should
> probably also insert a new heading about rendering the data.
>
> "Thus, the column functions creates": should be "create", but you're
> really talking about two different functions, column and
> column_render. But where is code for "extracting the text for that
> column associated with a given row"? column_render doesn't do this,
> does it? I can't find out what column_render does. The "header"
> defined first is not used in the "rows" definition shown next,
> although both are used later in the final "render" line. So how is
> "header" used in "rows"?
>
> I don't know what the to_string function does when passed a row.  In
> fact, I haven't seen a row data type defined anywhere. If a row is
> just a list of columns, which in turn is a list of strings, I think
> that has to be explained. (We did, however, see how a column is
> defined.) Furthermore, there's a complicated List.map which acts on
> each column, but I don't understand where to_string row fits into the
> function.
>
> On Mon, Apr 9, 2012 at 9:38 AM, Andy Oram <andyo@oreilly.com> wrote:
> Sorry this took so long. I think I did a pretty thorough read. Comments attached.

> Andy
> 
