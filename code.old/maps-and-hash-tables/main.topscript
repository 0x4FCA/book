let x = 0;;
#part 1
let digit_alist =
    [ 0, "zero"; 1, "one"; 2, "two"  ; 3, "three"; 4, "four"
    ; 5, "five"; 6, "six"; 7, "seven"; 8, "eight"; 9, "nine" ]
  ;;
#part 2
List.Assoc.find digit_alist 6;;
List.Assoc.find digit_alist 22;;
List.Assoc.add digit_alist 0 "zilch";;
#part 3
let digit_map = Map.of_alist_exn digit_alist
                     ~comparator:Int.comparator;;
Map.find digit_map 3;;
#part 4
let zilch_map = Map.add digit_map ~key:0 ~data:"zilch";;
#part 5
let left = String.Map.of_alist_exn ["foo",1; "bar",3; "snoo", 0]
  let right = String.Map.of_alist_exn ["foo",0; "snoo", 0]
  let diff = Map.symmetric_diff ~data_equal:Int.equal left right
  ;;
#part 6
Map.symmetric_diff;;
#part 7
module Reverse = Comparator.Make(struct
    type t = string
    let sexp_of_t = String.sexp_of_t
    let t_of_sexp = String.t_of_sexp
    let compare x y = String.compare y x
  end);;
#part 8
let alist = ["foo", 0; "snoo", 3];;
let ord_map = Map.of_alist_exn ~comparator:String.comparator alist;;
let rev_map = Map.of_alist_exn ~comparator:Reverse.comparator alist;;
#part 9
Map.min_elt ord_map;;
Map.min_elt rev_map;;
#part 10
Map.symmetric_diff ord_map rev_map;;
#part 11
let ord_tree = Map.to_tree ord_map;;
#part 12
Map.Tree.find ~comparator:String.comparator ord_tree "snoo";;
#part 13
Map.Tree.find ~comparator:Reverse.comparator ord_tree "snoo";;
#part 14
Map.of_alist_exn ~comparator:Comparator.Poly.comparator digit_alist;;
#part 15
Map.Poly.of_alist_exn digit_alist;;
#part 16
Map.symmetric_diff (Map.Poly.singleton 3 "three")
                     (Int.Map.singleton  3 "four" ) ;;
#part 17
let dedup ~comparator l =
    List.fold l ~init:(Set.empty ~comparator) ~f:Set.add
    |> Set.to_list
  ;;
dedup ~comparator:Int.comparator [8;3;2;3;7;8;10];;
#part 18
let (s1,s2) = (Int.Set.of_list [1;2],
                 Int.Set.of_list [2;1]);;
#part 19
Set.equal s1 s2;;
#part 20
s1 = s2;;
#part 21
Set.to_tree s1 = Set.to_tree s2;;
#part 22
module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp
      let compare t1 t2 =
        let c = Int.Set.compare t1.foo t2.foo in
        if c <> 0 then c else String.compare t1.bar t2.bar
    end
    include T
    include Comparable.Make(T)
  end;;
#part 23
module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp, compare
    end
    include T
    include Comparable.Make(T)
  end;;
#part 24
module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp
    end
    include T
    include Comparable.Poly(T)
  end;;
#part 25
let table = Hashtbl.create ~hashable:String.hashable ();;
Hashtbl.replace table ~key:"three" ~data:3;;
Hashtbl.find table "three";;
#part 26
let table = String.Table.create ();;
#part 27
let table = Hashtbl.create ~hashable:Hashtbl.Poly.hashable ();;
#part 28
let table = Hashtbl.Poly.create ();;
#part 29
Caml.Hashtbl.hash (List.range 0 9);;
Caml.Hashtbl.hash (List.range 0 10);;
Caml.Hashtbl.hash (List.range 0 11);;
Caml.Hashtbl.hash (List.range 0 100);;
#part 30
module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Hashable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp, compare
      let hash t =
        (Int.hash t.foo) lxor (String.hash t.bar)
    end
    include T
    include Hashable.Make(T)
  end;;
#part 31
#part 32
#part 33
#part 34
#part 35
#part 36
#part 37
#part 38
#part 39
#part 40
#part 41
#part 42
#part 43
#part 44
#part 45
#part 46
#part 47
#part 48
#part 49
#part 50
#part 51
#part 52
#part 53
#part 54
#part 55
#part 56
#part 57
#part 58
#part 59
#part 60
#part 61
#part 62
#part 63
#part 64
#part 65
#part 66
#part 67
#part 68
#part 69
#part 70
#part 71
#part 72
#part 73
#part 74
#part 75
#part 76
#part 77
#part 78
#part 79
#part 80
#part 81
#part 82
#part 83
#part 84
#part 85
#part 86
#part 87
#part 88
#part 89
#part 90
#part 91
#part 92
#part 93
#part 94
#part 95
#part 96
#part 97
#part 98
#part 99
#part 100
