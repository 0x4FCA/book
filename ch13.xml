<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="maps-and-hash-tables">
  <title>Maps and Hash Tables</title>

  <para>Lots of programming problems require dealing with data organized as
  key/value pairs. Maybe the simplest way of representing such data in OCaml
  is an <emphasis>association list</emphasis>, which is simply a list of pairs
  of keys and values. For example, you could represent a mapping between the
  10 digits and their English names as follows:<indexterm class="singular">
      <primary>key/value pairs</primary>
    </indexterm><indexterm class="singular">
      <primary>data structures</primary>

      <secondary>key/value pairs</secondary>
    </indexterm><indexterm class="singular">
      <primary>lists</primary>

      <secondary>association lists</secondary>
    </indexterm><indexterm class="singular">
      <primary>association lists</primary>
    </indexterm></para>

  <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
  (part 1)</para>

  <programlisting format="linespecific" language="ocaml"><prompt
      moreinfo="none"># </prompt><userinput moreinfo="none">let digit_alist =</userinput>
<userinput moreinfo="none">    [ 0, "zero"; 1, "one"; 2, "two"  ; 3, "three"; 4, "four"</userinput>
<userinput moreinfo="none">    ; 5, "five"; 6, "six"; 7, "seven"; 8, "eight"; 9, "nine" ]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val digit_alist : (int * string) list =</computeroutput>
<computeroutput moreinfo="none">  [(0, "zero"); (1, "one"); (2, "two"); (3, "three"); (4, "four");</computeroutput>
<computeroutput moreinfo="none">   (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]</computeroutput></programlisting>

  <para>We can use functions from the <literal
  moreinfo="none">List.Assoc</literal> module to manipulate such an
  association list:</para>

  <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
  (part 2)</para>

  <programlisting format="linespecific" language="ocaml"><prompt
      moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.find digit_alist 6;;</userinput>
<computeroutput moreinfo="none">- : string option = Some "six"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.find digit_alist 22;;</userinput>
<computeroutput moreinfo="none">- : string option = None</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.add digit_alist 0 "zilch";;</userinput>
<computeroutput moreinfo="none">- : (int, string) List.Assoc.t =</computeroutput>
<computeroutput moreinfo="none">[(0, "zilch"); (1, "one"); (2, "two"); (3, "three"); (4, "four");</computeroutput>
<computeroutput moreinfo="none"> (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]</computeroutput></programlisting>

  <para>Association lists are simple and easy to use, but their performance is
  not ideal, since almost every nontrivial operation on an association list
  requires a linear-time scan of the list.</para>

  <para>In this chapter, we'll talk about two more efficient alternatives to
  association lists: <emphasis>maps</emphasis> and <emphasis>hash
  tables</emphasis>. A map is an immutable tree-based data structure where
  most operations take time logarithmic in the size of the map, whereas a hash
  table is a mutable data structure where most operations have constant time
  complexity. We'll describe both of these data structures in detail and
  provide some advice as to how to choose between them.<indexterm
      class="singular">
      <primary>hash tables</primary>

      <secondary>basics of</secondary>
    </indexterm><indexterm class="singular">
      <primary>maps</primary>

      <secondary>basics of</secondary>
    </indexterm></para>

  <sect1 id="maps">
    <title>Maps</title>

    <para>Let's consider an example of how one might use a map in practice. In
    <xref linkend="files-modules-and-programs"/>, we showed a module <literal
    moreinfo="none">Counter</literal> for keeping frequency counts on a set of
    strings. Here's the interface:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-fast/counter.mli">files-modules-and-programs-freq-fast/counter.mli</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(* Converts the set of frequency counts to an association list.  Every strings
   in the list will show up at most once, and the integers will be at least
   1. *)
val to_list : t -&gt; (string * int) list</programlisting>

    <para>The intended behavior here is straightforward. <literal
    moreinfo="none">Counter.empty</literal> represents an empty collection of
    frequency counts; <literal moreinfo="none">touch</literal> increments the
    frequency count of the specified string by 1; and <literal
    moreinfo="none">to_list</literal> returns the list of nonzero
    frequencies.</para>

    <para>Here's the implementation:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-fast/counter.ml">files-modules-and-programs-freq-fast/counter.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = int String.Map.t

let empty = String.Map.empty

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t ~key:s ~data:(count + 1)</programlisting>

    <para>Note that in some places the preceding code refers to <literal
    moreinfo="none">String.Map.t</literal>, and in others <literal
    moreinfo="none">Map.t</literal>. This has to do with the fact that maps
    are implemented as ordered binary trees, and as such, need a way of
    comparing keys.</para>

    <para>To deal with this, a map, once created, stores the necessary
    comparison function within the data structure. Thus, operations like
    <literal moreinfo="none">Map.find</literal> or <literal
    moreinfo="none">Map.add</literal> that access the contents of a map or
    create a new map from an existing one, do so by using the comparison
    function embedded within the map.</para>

    <para>But in order to get a map in the first place, you need to get your
    hands on the comparison function somehow. For this reason, modules like
    <literal moreinfo="none">String</literal> contain a <literal
    moreinfo="none">Map</literal> submodule that has values like <literal
    moreinfo="none">String.Map.empty</literal> and <literal
    moreinfo="none">String.Map.of_alist</literal> that are specialized to
    strings, and thus have access to a string comparison function. Such a
    <literal moreinfo="none">Map</literal> submodule is included in every
    module that satisfies the <literal moreinfo="none">Comparable.S</literal>
    interface from Core.</para>

    <sect2 id="creating-maps-with-comparators">
      <title>Creating Maps with Comparators</title>

      <para>The specialized <literal moreinfo="none">Map</literal> submodule
      is convenient, but it's not the only way of creating a <literal
      moreinfo="none">Map.t</literal>. The information required to compare
      values of a given type is wrapped up in a value called a
      <emphasis>comparator</emphasis> that can be used to create maps using
      the <literal moreinfo="none">Map</literal> module directly:<indexterm
          class="singular">
          <primary>comparators</primary>

          <secondary>creating maps with</secondary>
        </indexterm><indexterm class="singular">
          <primary>Map module</primary>

          <secondary>Map.of_alist_exn</secondary>
        </indexterm><indexterm class="singular">
          <primary>maps</primary>

          <secondary>creating with comparators</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let digit_map = Map.of_alist_exn digit_alist</userinput>
<userinput moreinfo="none">                     ~comparator:Int.comparator;;</userinput>
<computeroutput moreinfo="none">val digit_map : (int, string, Int.comparator) Map.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.find digit_map 3;;</userinput>
<computeroutput moreinfo="none">- : string option = Some "three"</computeroutput></programlisting>

      <para>The preceding code uses <literal
      moreinfo="none">Map.of_alist_exn</literal>, which creates a map from an
      association list, throwing an exception if there are duplicate keys in
      the list.</para>

      <para>The comparator is only required for operations that create maps
      from scratch. Operations that update an existing map simply inherit the
      comparator of the map they start with:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let zilch_map = Map.add digit_map ~key:0 ~data:"zilch";;</userinput>
<computeroutput moreinfo="none">val zilch_map : (int, string, Int.comparator) Map.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>The type <literal moreinfo="none">Map.t</literal> has three type
      parameters: one for the key, one for the value, and one to identify the
      comparator. Indeed, the type <literal moreinfo="none">'a
      Int.Map.t</literal> is just a type alias for <literal
      moreinfo="none">(int,'a,Int.comparator) Map.t</literal></para>

      <para>Including the comparator in the type is important because
      operations that work on multiple maps at the same time often require
      that the maps share their comparison function. Consider, for example,
      <literal moreinfo="none">Map.symmetric_diff</literal>, which computes a
      summary of the differences between two maps:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let left = String.Map.of_alist_exn ["foo",1; "bar",3; "snoo", 0]</userinput>
<userinput moreinfo="none">  let right = String.Map.of_alist_exn ["foo",0; "snoo", 0]</userinput>
<userinput moreinfo="none">  let diff = Map.symmetric_diff ~data_equal:Int.equal left right</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val left : int String.Map.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val right : int String.Map.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val diff :</computeroutput>
<computeroutput moreinfo="none">  (string * [ `Left of int | `Right of int | `Unequal of int * int ]) list =</computeroutput>
<computeroutput moreinfo="none">  [("foo", `Unequal (1, 0)); ("bar", `Left 3)]</computeroutput></programlisting>

      <para>The type of <literal moreinfo="none">Map.symmetric_diff</literal>,
      which follows, requires that the two maps it compares have the same
      comparator type. Each comparator has a fresh abstract type, so the type
      of a comparator identifies the comparator uniquely:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Map.symmetric_diff;;</userinput>
<computeroutput moreinfo="none">- : ('k, 'v, 'cmp) Map.t -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('k, 'v, 'cmp) Map.t -&gt;</computeroutput>
<computeroutput moreinfo="none">    data_equal:('v -&gt; 'v -&gt; bool) -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('k * [ `Left of 'v | `Right of 'v | `Unequal of 'v * 'v ]) list</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

      <para>This constraint is important because the algorithm that <literal
      moreinfo="none">Map.symmetric_diff</literal> uses depends for its
      correctness on the fact that both maps have the same comparator.</para>

      <para>We can create a new comparator using the <literal
      moreinfo="none">Comparator.Make</literal> functor, which takes as its
      input a module containing the type of the object to be compared,
      sexp-converter functions, and a comparison function. The sexp converters
      are included in the comparator to make it possible for users of the
      comparator to generate better error messages. Here's an
      example:<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp converter</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module Reverse = Comparator.Make(struct</userinput>
<userinput moreinfo="none">    type t = string</userinput>
<userinput moreinfo="none">    let sexp_of_t = String.sexp_of_t</userinput>
<userinput moreinfo="none">    let t_of_sexp = String.t_of_sexp</userinput>
<userinput moreinfo="none">    let compare x y = String.compare y x</userinput>
<userinput moreinfo="none">  end);;</userinput>
<computeroutput moreinfo="none">module Reverse :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = string</computeroutput>
<computeroutput moreinfo="none">    val compare : t -&gt; t -&gt; int</computeroutput>
<computeroutput moreinfo="none">    val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">    type comparator</computeroutput>
<computeroutput moreinfo="none">    val comparator : (t, comparator) Comparator.t_</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>As you can see in the following code, both <literal
      moreinfo="none">Reverse.comparator</literal> and <literal
      moreinfo="none">String.comparator</literal> can be used to create maps
      with a key type of <literal moreinfo="none">string</literal>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let alist = ["foo", 0; "snoo", 3];;</userinput>
<computeroutput moreinfo="none">val alist : (string * int) list = [("foo", 0); ("snoo", 3)]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ord_map = Map.of_alist_exn ~comparator:String.comparator alist;;</userinput>
<computeroutput moreinfo="none">val ord_map : (string, int, String.comparator) Map.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rev_map = Map.of_alist_exn ~comparator:Reverse.comparator alist;;</userinput>
<computeroutput moreinfo="none">val rev_map : (string, int, Reverse.comparator) Map.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para><literal moreinfo="none">Map.min_elt</literal> returns the key and
      value for the smallest key in the map, which lets us see that these two
      maps do indeed use different comparison functions:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Map.min_elt ord_map;;</userinput>
<computeroutput moreinfo="none">- : (string * int) option = Some ("foo", 0)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.min_elt rev_map;;</userinput>
<computeroutput moreinfo="none">- : (string * int) option = Some ("snoo", 3)</computeroutput></programlisting>

      <para>Accordingly, if we try to use <literal
      moreinfo="none">Map.symmetric_diff</literal> on these two maps, we'll
      get a compile-timer error:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Map.symmetric_diff ord_map rev_map;;</userinput>
<computeroutput moreinfo="none">Characters 27-34:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type (string, int, Reverse.comparator) Map.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (string, int, String.comparator) Map.t</computeroutput>
<computeroutput moreinfo="none">       Type Reverse.comparator is not compatible with type String.comparator </computeroutput></programlisting>
    </sect2>

    <sect2 id="trees">
      <title>Trees</title>

      <para>As we've discussed, maps carry within them the comparator that
      they were created with. Sometimes, often for space efficiency reasons,
      you want a version of the map data structure that doesn't include the
      comparator. You can get such a representation with <literal
      moreinfo="none">Map.to_tree</literal>, which returns just the tree
      underlying the map, without the comparator:<indexterm class="singular">
          <primary>Map module</primary>

          <secondary>Map.to_tree</secondary>
        </indexterm><indexterm class="singular">
          <primary>maps</primary>

          <secondary>tree structure</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let ord_tree = Map.to_tree ord_map;;</userinput>
<computeroutput moreinfo="none">val ord_tree : (string, int, String.comparator) Map.Tree.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>Even though a <literal moreinfo="none">Map.Tree.t</literal>
      doesn't physically include a comparator, it does include the comparator
      in its type. This is what is known as a <emphasis>phantom
      type</emphasis>, because it reflects something about the logic of the
      value in question, even though it doesn't correspond to any values
      directly represented in the underlying physical structure of the
      value.</para>

      <para>Since the comparator isn't included in the tree, we need to
      provide the comparator explicitly when we, say, search for a key, as
      shown below:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Map.Tree.find ~comparator:String.comparator ord_tree "snoo";;</userinput>
<computeroutput moreinfo="none">- : int option = Some 3</computeroutput></programlisting>

      <para>The algorithm of <literal moreinfo="none">Map.Tree.find</literal>
      depends on the fact that it's using the same comparator when looking a
      value up as you were when you stored it. That's the invariant that the
      phantom type is there to enforce. As you can see in the following
      example, using the wrong comparator will lead to a type error:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Map.Tree.find ~comparator:Reverse.comparator ord_tree "snoo";;</userinput>
<computeroutput moreinfo="none">Characters 45-53:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type (string, int, String.comparator) Map.Tree.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (string, int, Reverse.comparator) Map.Tree.t</computeroutput>
<computeroutput moreinfo="none">       Type String.comparator is not compatible with type Reverse.comparator </computeroutput></programlisting>
    </sect2>

    <sect2 id="the-polymorphic-comparator">
      <title>The Polymorphic Comparator</title>

      <para>We don't need to generate specialized comparators for every type
      we want to build a map on. We can instead use a comparator based on
      OCaml's built-in polymorphic comparison function, which was discussed in
      <xref linkend="lists-and-patterns"/>. This comparator is found in the
      <literal moreinfo="none">Comparator.Poly</literal> module, allowing us
      to write:<indexterm class="singular">
          <primary>maps</primary>

          <secondary>polymorphic comparison in</secondary>
        </indexterm><indexterm class="singular">
          <primary>Comparator.Poly module</primary>
        </indexterm><indexterm class="singular">
          <primary>polymorphic comparisons</primary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 14)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Map.of_alist_exn ~comparator:Comparator.Poly.comparator digit_alist;;</userinput>
<computeroutput moreinfo="none">- : (int, string, Comparator.Poly.comparator) Map.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>Or, equivalently:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 15)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Map.Poly.of_alist_exn digit_alist;;</userinput>
<computeroutput moreinfo="none">- : (int, string) Map.Poly.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>Note that maps based on the polymorphic comparator are not
      equivalent to those based on the type-specific comparators from the
      point of view of the type system. Thus, the compiler rejects the
      following:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 16)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Map.symmetric_diff (Map.Poly.singleton 3 "three")</userinput>
<userinput moreinfo="none">                     (Int.Map.singleton  3 "four" ) ;;</userinput>
<computeroutput moreinfo="none">Characters 72-99:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type</computeroutput>
<computeroutput moreinfo="none">         string Int.Map.t = (int, string, Int.comparator) Map.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (int, string, Comparator.Poly.comparator) Map.t</computeroutput>
<computeroutput moreinfo="none">       Type Int.comparator is not compatible with type</computeroutput>
<computeroutput moreinfo="none">         Comparator.Poly.comparator </computeroutput></programlisting>

      <para>This is rejected for good reason: there's no guarantee that the
      comparator associated with a given type will order things in the same
      way that polymorphic compare does.</para>

      <sidebar>
        <title>The Perils of Polymorphic Compare</title>

        <para>Polymorphic compare is highly convenient, but it has serious
        downsides as well and should be used with care. In particular,
        polymorphic compare has a fixed algorithm for comparing values of any
        type, and that algorithm can sometimes yield surprising
        results.</para>

        <para>To understand what's wrong with polymorphic compare, you need to
        understand a bit about how it works. Polymorphic compare is
        <emphasis>structural</emphasis>, in that it operates directly on the
        runtime-representation of OCaml values, walking the structure of the
        values in question without regard for their type.</para>

        <para>This is convenient because it provides a comparison function
        that works for most OCaml values and largely behaves as you would
        expect. For example, on <literal moreinfo="none">int</literal>s and
        <literal moreinfo="none">float</literal>s, it acts as you would expect
        a numeric comparison function to act. For simple containers like
        strings and lists and arrays, it operates as a lexicographic
        comparison. And except for closures and values from outside of the
        OCaml heap, it works on almost every OCaml type.</para>

        <para>But sometimes, a structural comparison is not what you want.
        Sets are a great example of this. Consider the following two
        sets:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
        (part 18)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let (s1,s2) = (Int.Set.of_list [1;2],</userinput>
<userinput moreinfo="none">                 Int.Set.of_list [2;1]);;</userinput>
<computeroutput moreinfo="none">val s1 : Int.Set.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val s2 : Int.Set.t = &lt;abstr&gt;</computeroutput></programlisting>

        <para>Logically, these two sets should be equal, and that's the result
        that you get if you call <literal moreinfo="none">Set.equal</literal>
        on them:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
        (part 19)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">Set.equal s1 s2;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

        <para>But because the elements were added in different orders, the
        layout of the trees underlying the sets will be different. As such, a
        structural comparison function will conclude that they're
        different.</para>

        <para>Let's see what happens if we use polymorphic compare to test for
        equality by way of the <literal moreinfo="none">=</literal> operator.
        Comparing the maps directly will fail at runtime because the
        comparators stored within the sets contain function values:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
        (part 20)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">s1 = s2;;</userinput>
<computeroutput moreinfo="none">Exception: (Invalid_argument "equal: functional value").</computeroutput></programlisting>

        <para>We can, however, use the function <literal
        moreinfo="none">Set.to_tree</literal> to expose the underlying tree
        without the attached comparator:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
        (part 21)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">Set.to_tree s1 = Set.to_tree s2;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

        <para>This can cause real and quite subtle bugs. If, for example, you
        use a map whose keys contain sets, then the map built with the
        polymorphic comparator will behave incorrectly, separating out keys
        that should be aggregated together. Even worse, it will work sometimes
        and fail others; since if the sets are built in a consistent order,
        then they will work as expected, but once the order changes, the
        behavior will change.</para>
      </sidebar>
    </sect2>

    <sect2 id="sets">
      <title>Sets</title>

      <para>Sometimes, instead of keeping track of a set of key/value pairs,
      you just want a data-type for keeping track of a set of keys. You could
      build this on top of a map by representing a set of values by a map
      whose data type is <literal moreinfo="none">unit</literal>. But a more
      idiomatic (and efficient) solution is to use Core's set type, which is
      similar in design and spirit to the map type, while having an API better
      tuned to working with sets and a lower memory footprint. Here's a simple
      example:<indexterm class="singular">
          <primary>set types</primary>
        </indexterm><indexterm class="singular">
          <primary>maps</primary>

          <secondary>set type for</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 17)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let dedup ~comparator l =</userinput>
<userinput moreinfo="none">    List.fold l ~init:(Set.empty ~comparator) ~f:Set.add</userinput>
<userinput moreinfo="none">    |&gt; Set.to_list</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val dedup :</computeroutput>
<computeroutput moreinfo="none">  comparator:('a, 'b) Core_kernel.Comparator.t_ -&gt; 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">dedup ~comparator:Int.comparator [8;3;2;3;7;8;10];;</userinput>
<computeroutput moreinfo="none">- : int list = [2; 3; 7; 8; 10]</computeroutput></programlisting>

      <para>In addition to the operators you would expect to have for maps,
      sets support the traditional set operations, including union,
      intersection, and set difference. And, as with maps, we can create sets
      based on type-specific comparators or on the polymorphic
      comparator.</para>
    </sect2>

    <sect2 id="satisfying-the-comparable.s-interface">
      <title>Satisfying the <literal moreinfo="none">Comparable.S</literal>
      Interface</title>

      <para>Core's <literal moreinfo="none">Comparable.S</literal> interface
      includes a lot of useful functionality, including support for working
      with maps and sets. In particular, <literal
      moreinfo="none">Comparable.S</literal> requires the presence of the
      <literal moreinfo="none">Map</literal> and <literal
      moreinfo="none">Set</literal> submodules, as well as a
      comparator.<indexterm class="singular">
          <primary>interfaces</primary>

          <secondary>Comparable.S</secondary>
        </indexterm><indexterm class="singular">
          <primary>Comparable module</primary>

          <secondary>Comparable.Make</secondary>
        </indexterm><indexterm class="singular">
          <primary>Comparable module</primary>

          <secondary>Comparable.S</secondary>
        </indexterm><indexterm class="singular">
          <primary>maps</primary>

          <secondary>comparable.S interface</secondary>
        </indexterm></para>

      <para><literal moreinfo="none">Comparable.S</literal> is satisfied by
      most of the types in Core, but the question arises of how to satisfy the
      comparable interface for a new type that you design. Certainly
      implementing all of the required functionality from scratch would be an
      absurd amount of work.</para>

      <para>The module <literal moreinfo="none">Comparable</literal> contains
      a number of functors to help you automate this task. The simplest one of
      these is <literal moreinfo="none">Comparable.Make</literal>, which takes
      as an input any module that satisfies the following interface:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/comparable.ml">maps-and-hash-tables/comparable.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">module type Comparable = sig
  type t
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
  val compare : t -&gt; t -&gt; int
end</programlisting>

      <para>In other words, it expects a type with a comparison function, as
      well as functions for converting to and from
      <emphasis>s-expressions</emphasis>. S-expressions are a serialization
      format used commonly in Core and are required here to enable better
      error messages. We'll discuss s-expressions more in <xref
      linkend="data-serialization-with-s-expressions"/>, but in the meantime,
      we'll use the <literal moreinfo="none">with sexp</literal> declaration
      that comes from the Sexplib syntax extension. This declaration kicks off
      the automatic generation of s-expression conversion functions for the
      marked type.</para>

      <para>The following example shows how this all fits together, following
      the same basic pattern for using functors described in <xref
      linkend="extending-modules"/>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main-22.rawscript">maps-and-hash-tables/main-22.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp
      let compare t1 t2 =
        let c = Int.Set.compare t1.foo t2.foo in
        if c &lt;&gt; 0 then c else String.compare t1.bar t2.bar
    end
    include T
    include Comparable.Make(T)
  end;;</userinput>
<computeroutput moreinfo="none">module Foo_and_bar :
sig
  type t = { foo : Int.Set.t; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

    ...

end</computeroutput></programlisting>

      <para>We don't include the full response from the toplevel because it is
      quite lengthy, but <literal moreinfo="none">Foo_and_bar</literal> does
      satisfy <literal moreinfo="none">Comparable.S</literal>.</para>

      <para>In the precdeding code we wrote the comparison function by hand,
      but this isn't strictly necessary. Core ships with a syntax extension
      called <literal moreinfo="none">comparelib</literal>, which will create
      a comparison function from a type definition. Using it, we can rewrite
      the above example as follows:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main-23.rawscript">maps-and-hash-tables/main-23.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp, compare
    end
    include T
    include Comparable.Make(T)
  end;;</userinput>
<computeroutput moreinfo="none">module Foo_and_bar :
sig
  type t = { foo : Int.Set.t; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

  ...

end</computeroutput></programlisting>

      <para>The comparison function created by <literal
      moreinfo="none">comparelib</literal> for a given type will call out to
      the comparison functions for its component types. As a result, the
      <literal moreinfo="none">foo</literal> field will be compared using
      <literal moreinfo="none">Int.Set.compare</literal>. This is different,
      and saner than the structural comparison done by polymorphic
      compare.</para>

      <para>If you want your comparison function to behave in a specific way,
      you should still write your own comparison function by hand; but if all
      you want is a total order suitable for creating maps and sets with, then
      <literal moreinfo="none">comparelib</literal> is a good way to
      go.</para>

      <para>You can also satisfy the <literal
      moreinfo="none">Comparable.S</literal> interface using polymorphic
      compare:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main-24.rawscript">maps-and-hash-tables/main-24.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp
    end
    include T
    include Comparable.Poly(T)
  end;;</userinput>
<computeroutput moreinfo="none">module Foo_and_bar :
sig
  type t = { foo : int; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

  ...

end
</computeroutput></programlisting>

      <para>That said, for reasons we discussed earlier, polymorphic compare
      should be used sparingly.</para>
    </sect2>
  </sect1>

  <sect1 id="hash-tables">
    <title>Hash Tables</title>

    <para>Hash tables are the imperative cousin of maps. We walked over a
    basic hash table implementation in <xref
    linkend="imperative-programming-1"/>, so in this section we'll mostly
    discuss the pragmatics of Core's <literal
    moreinfo="none">Hashtbl</literal> module. We'll cover this material more
    briefly than we did with maps because many of the concepts are
    shared.<indexterm class="singular">
        <primary>hash tables</primary>

        <secondary>basics of</secondary>
      </indexterm></para>

    <para>Hash tables differ from maps in a few key ways. First, hash tables
    are mutable, meaning that adding a key/value pair to a hash table modifies
    the table, rather than creating a new table with the binding added.
    Second, hash tables generally have better time-complexity than maps,
    providing constant time lookup and modifications as opposed to logarithmic
    for maps. And finally, just as maps depend on having a comparison function
    for creating the ordered binary tree that underlies a map, hash tables
    depend on having a <emphasis>hash function</emphasis>, i.e., a function
    for converting a key to an integer.<indexterm class="singular">
        <primary>functions</primary>

        <secondary>hash functions</secondary>
      </indexterm><indexterm class="singular">
        <primary>Hashtbl module</primary>
      </indexterm><indexterm class="singular">
        <primary>hash tables</primary>

        <secondary>time complexity of</secondary>
      </indexterm></para>

    <warning>
      <title>Time Complexity of Hash Tables</title>

      <para>The statement that hash tables provide constant-time access hides
      some complexities. First of all, any hash table implementation, OCaml's
      included, needs to resize the table when it gets too full. A resize
      requires allocating a new backing array for the hash table and copying
      over all entries, and so it is quite an expensive operation. That means
      adding a new element to the table is only <emphasis>amortized</emphasis>
      constant, which is to say, it's constant on average over a long sequence
      of additions, but some of the individual additions can be quite
      expensive.</para>

      <para>Another hidden cost of hash tables has to do with the hash
      function you use. If you end up with a pathologically bad hash function
      that hashes all of your data to the same number, then all of your
      insertions will hash to the same underlying bucket, meaning you no
      longer get constant-time access at all. Core's hash table implementation
      uses binary trees for the hash-buckets, so this case only leads to
      logarithmic time, rather than quadratic for a traditional hash
      table.</para>

      <para>The logarithmic behavior of Core's hash tables in the presence of
      hash collisions also helps protect against some denial-of-service
      attacks. One well-known type of attack is to send queries to a service
      with carefully chosen keys to cause many collisions. This, in
      combination with the quadratic behavior of hash tables, can cause the
      service to become unresponsive due to high CPU load. Core's hash tables
      would be much less susceptible to such an attack because the amount of
      degradation would be far less.<indexterm class="singular">
          <primary>denial-of-service attacks</primary>

          <secondary>avoiding with hash tables</secondary>
        </indexterm></para>
    </warning>

    <para>When creating a hash table, we need to provide a value of type
    <emphasis>hashable</emphasis>, which includes among other things the
    function for hashing the key type. This is analogous to the comparator
    used for creating maps:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
    (part 25)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let table = Hashtbl.create ~hashable:String.hashable ();;</userinput>
<computeroutput moreinfo="none">val table : (string, '_a) Hashtbl.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Hashtbl.replace table ~key:"three" ~data:3;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Hashtbl.find table "three";;</userinput>
<computeroutput moreinfo="none">- : int option = Some 3</computeroutput></programlisting>

    <para>The <literal moreinfo="none">hashable</literal> value is included as
    part of the <literal moreinfo="none">Hashable.S</literal> interface, which
    is satisfied by most types in Core. The <literal
    moreinfo="none">Hashable.S</literal> interface also includes a <literal
    moreinfo="none">Table</literal> submodule which provides more convenient
    creation functions:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
    (part 26)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let table = String.Table.create ();;</userinput>
<computeroutput moreinfo="none">val table : '_a String.Table.t = &lt;abstr&gt;</computeroutput></programlisting>

    <para>There is also a polymorphic <literal
    moreinfo="none">hashable</literal> value, corresponding to the polymorphic
    hash function provided by the OCaml runtime, for cases where you don't
    have a hash function for your specific type:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
    (part 27)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let table = Hashtbl.create ~hashable:Hashtbl.Poly.hashable ();;</userinput>
<computeroutput moreinfo="none">val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;</computeroutput></programlisting>

    <para>Or, equivalently:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
    (part 28)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let table = Hashtbl.Poly.create ();;</userinput>
<computeroutput moreinfo="none">val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;</computeroutput></programlisting>

    <para>Note that, unlike the comparators used with maps and sets, hashables
    don't show up in the type of a <literal
    moreinfo="none">Hashtbl.t</literal>. That's because hash tables don't have
    operations that operate on multiple hash tables that depend on those
    tables having the same hash function, in the way that <literal
    moreinfo="none">Map.symmetric_diff</literal> and <literal
    moreinfo="none">Set.union</literal> depend on their arguments using the
    same comparison function.<indexterm class="singular">
        <primary>polymorphism</primary>

        <secondary sortas="hash functions">in hash functions</secondary>
      </indexterm></para>

    <warning>
      <title>Collisions with the Polymorphic Hash Function</title>

      <para>OCaml's polymorphic hash function works by walking over the
      data-structure its given using a breadth-first traversal that is bounded
      in the number of nodes its willing to traverse. By default, that bound
      is set at 10 "meaningful" nodes.<indexterm class="singular">
          <primary>hash tables</primary>

          <secondary>polymorphic hash function</secondary>
        </indexterm></para>

      <para>The bound on the traversal, means that the hash function may
      ignore part of the data structure, and this can lead to pathological
      cases where every value you store has the same hash value. By default,
      OCaml's hash function will stop after it has found 10 nodes it can
      extract data from. We'll demonstrate this below, using the function
      <literal moreinfo="none">List.range</literal> to allocate lists of
      integers of different length:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main.topscript">maps-and-hash-tables/main.topscript</ulink>
      (part 29)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Caml.Hashtbl.hash (List.range 0 9);;</userinput>
<computeroutput moreinfo="none">- : int = 209331808</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Caml.Hashtbl.hash (List.range 0 10);;</userinput>
<computeroutput moreinfo="none">- : int = 182325193</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Caml.Hashtbl.hash (List.range 0 11);;</userinput>
<computeroutput moreinfo="none">- : int = 182325193</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Caml.Hashtbl.hash (List.range 0 100);;</userinput>
<computeroutput moreinfo="none">- : int = 182325193</computeroutput></programlisting>

      <para>As you can see, the hash function stops after the first 10
      elements. The same can happen with any large data structure, including
      records and arrays. When building hash functions over large custom
      data-structures, it is generally a good idea to write one's own hash
      function.</para>
    </warning>

    <sect2 id="satisfying-the-hashable.s-interface">
      <title>Satisfying the <literal moreinfo="none">Hashable.S</literal>
      Interface</title>

      <para>Most types in Core satisfy the <literal
      moreinfo="none">Hashable.S</literal> interface, but as with the <literal
      moreinfo="none">Comparable.S</literal> interface, the question remains
      of how one should satisfy this interface when writing a new module.
      Again, the answer is to use a functor to build the necessary
      functionality; in this case, <literal
      moreinfo="none">Hashable.Make</literal>. Note that we use OCaml's
      <literal moreinfo="none">lxor</literal> operator for doing the "logical"
      (i.e., bit-wise) exclusive-or of the hashes from the component
      values:<indexterm class="singular">
          <primary>Hashable.Make</primary>
        </indexterm><indexterm class="singular">
          <primary>interfaces</primary>

          <secondary>Hashable.S</secondary>
        </indexterm><indexterm class="singular">
          <primary>Hashable.S interface</primary>
        </indexterm><indexterm class="singular">
          <primary>hash tables</primary>

          <secondary>satisfying Hashable.S interface</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/main-30.rawscript">maps-and-hash-tables/main-30.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Hashable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp, compare
      let hash t =
        (Int.hash t.foo) lxor (String.hash t.bar)
    end
    include T
    include Hashable.Make(T)
  end;;</userinput>
<computeroutput moreinfo="none">module Foo_and_bar :
sig
  type t = { foo : int; bar : string; }
  module Hashable : sig type t = t end
  val hash : t -&gt; int
  val compare : t -&gt; t -&gt; int
  val hashable : t Pooled_hashtbl.Hashable.t

  ...

end</computeroutput></programlisting>

      <para>Note that in order to satisfy hashable, one also needs to provide
      a comparison function. That's because Core's hash tables use an ordered
      binary tree data structure for the hash-buckets so that performance of
      the table degrades gracefully in the case of pathologically bad choice
      of hash function.</para>

      <para>There is currently no analogue of <literal
      moreinfo="none">comparelib</literal> for autogeneration of hash
      functions, so you do need to either write the hash function by hand, or
      use the built-in polymorphic hash function, <literal
      moreinfo="none">Hashtbl.hash</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="choosing-between-maps-and-hash-tables">
    <title>Choosing Between Maps and Hash Tables</title>

    <para>Maps and hash tables overlap enough in functionality that it's not
    always clear when to choose one or the other. Maps, by virtue of being
    immutable, are generally the default choice in OCaml. OCaml also has good
    support for imperative programming, though, and when programming in an
    imperative idiom, hash tables are often the more natural choice.<indexterm
        class="singular">
        <primary>maps</primary>

        <secondary sortas="hashtables">vs. hashtables</secondary>
      </indexterm><indexterm class="singular">
        <primary>hash tables</primary>

        <secondary sortas="maps">vs. maps</secondary>
      </indexterm></para>

    <para>Programming idioms aside, there are significant performance
    differences between maps and hash tables. For code that is dominated by
    updates and lookups, hash tables are a clear performance win, and the win
    is clearer the larger the size of the tables.</para>

    <para>The best way of answering a performance question is by running a
    benchmark, so let's do just that. The following benchmark uses the
    <literal moreinfo="none">core_bench</literal> library, and it compares
    maps and hash tables under a very simple workload. Here, we're keeping
    track of a set of 1,000 different integer keys and cycling over the keys
    and updating the values they contain. Note that we use the <literal
    moreinfo="none">Map.change</literal> and <literal
    moreinfo="none">Hashtbl.change</literal> functions to update the
    respective data structures:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/map_vs_hash.ml">maps-and-hash-tables/map_vs_hash.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Core_bench.Std

let map_iter ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0 then ()
    else loop (i - 1)
           (Map.change map (i mod num_keys) (fun current -&gt;
              Some (1 + Option.value ~default:0 current)))
  in
  loop iterations Int.Map.empty

let table_iter ~num_keys ~iterations =
  let table = Int.Table.create ~size:num_keys () in
  let rec loop i =
    if i &lt;= 0 then ()
    else (
      Hashtbl.change table (i mod num_keys) (fun current -&gt;
        Some (1 + Option.value ~default:0 current));
      loop (i - 1)
    )
  in
  loop iterations

let tests ~num_keys ~iterations =
  let test name f = Bench.Test.create f ~name in
  [ test "map"   (fun () -&gt; map_iter   ~num_keys ~iterations)
  ; test "table" (fun () -&gt; table_iter ~num_keys ~iterations)
  ]

let () =
  tests ~num_keys:1000 ~iterations:100_000
  |&gt; Bench.make_command
  |&gt; Command.run</programlisting>

    <para>The results show the hash table version to be around four times
    faster than the map version:</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/run_map_vs_hash.out">maps-and-hash-tables/run_map_vs_hash.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench map_vs_hash.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./map_vs_hash.native -ascii -clear-columns name time speedup</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                </computeroutput>
<computeroutput moreinfo="none">  Name     Time (ns)   Speedup  </computeroutput>
<computeroutput moreinfo="none"> ------- ------------ --------- </computeroutput>
<computeroutput moreinfo="none">  map     31_698_313      1.00  </computeroutput>
<computeroutput moreinfo="none">  table    7_202_631      4.40  </computeroutput>
<computeroutput moreinfo="none">                                </computeroutput></programlisting>

    <para>We can make the speedup smaller or larger depending on the details
    of the test; for example, it will vary with the number of distinct keys.
    But overall, for code that is heavy on sequences of querying and updating
    a set of key/value pairs, hash tables will significantly outperform
    maps.</para>

    <para>Hash tables are not always the faster choice, though. In particular,
    maps are often more performant in situations where you need to keep
    multiple related versions of the data structure in memory at once. That's
    because maps are immutable, and so operations like <literal
    moreinfo="none">Map.add</literal> that modify a map do so by creating a
    new map, leaving the original undisturbed. Moreover, the new and old map
    share most of their physical structure, so multiple versions can be kept
    around efficiently.</para>

    <para>Here's a benchmark that demonstrates this. In it, we create a list
    of maps (or hash tables) that are built up by iteratively applying small
    updates, keeping these copies around. In the map case, this is done by
    using <literal moreinfo="none">Map.change</literal> to update the map. In
    the hash table implementation, the updates are done using <literal
    moreinfo="none">Hashtbl.change</literal>, but we also need to call
    <literal moreinfo="none">Hashtbl.copy</literal> to take snapshots of the
    table:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/map_vs_hash2.ml">maps-and-hash-tables/map_vs_hash2.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Core_bench.Std

let create_maps ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0 then []
    else
      let new_map =
        Map.change map (i mod num_keys) (fun current -&gt;
          Some (1 + Option.value ~default:0 current))
      in
      new_map :: loop (i - 1) new_map
  in
  loop iterations Int.Map.empty

let create_tables ~num_keys ~iterations =
  let table = Int.Table.create ~size:num_keys () in
  let rec loop i =
    if i &lt;= 0 then []
    else (
      Hashtbl.change table (i mod num_keys) (fun current -&gt;
        Some (1 + Option.value ~default:0 current));
      let new_table = Hashtbl.copy table in
      new_table :: loop (i - 1)
    )
  in
  loop iterations

let tests ~num_keys ~iterations =
  let test name f = Bench.Test.create f ~name in
  [ test "map"   (fun () -&gt; ignore (create_maps   ~num_keys ~iterations))
  ; test "table" (fun () -&gt; ignore (create_tables ~num_keys ~iterations))
  ]

let () =
  tests ~num_keys:50 ~iterations:1000
  |&gt; Bench.make_command
  |&gt; Command.run</programlisting>

    <para>Unsurprisingly, maps perform far better than hash tables on this
    benchmark, in this case by more than a factor of 10:</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/run_map_vs_hash2.out">maps-and-hash-tables/run_map_vs_hash2.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench map_vs_hash2.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./map_vs_hash2.native -ascii -clear-columns name time speedup</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                               </computeroutput>
<computeroutput moreinfo="none">  Name    Time (ns)   Speedup  </computeroutput>
<computeroutput moreinfo="none"> ------- ----------- --------- </computeroutput>
<computeroutput moreinfo="none">  map       218_581     12.03  </computeroutput>
<computeroutput moreinfo="none">  table   2_628_423      1.00  </computeroutput>
<computeroutput moreinfo="none">                               </computeroutput></programlisting>

    <para>These numbers can be made more extreme by increasing the size of the
    tables or the length of the list.</para>

    <para>As you can see, the relative performance of trees and maps depends a
    great deal on the details of how they're used, and so whether to choose
    one data structure or the other will depend on the details of the
    application.<indexterm class="singular">
        <primary>phys_equal function</primary>
      </indexterm><indexterm class="singular">
        <primary>equal equal (= =) operator</primary>
      </indexterm><indexterm class="singular">
        <primary>equal (=) operator</primary>
      </indexterm><indexterm class="singular">
        <primary>structural equality</primary>
      </indexterm><indexterm class="singular">
        <primary>physical equality</primary>
      </indexterm><indexterm class="singular">
        <primary>equaltiy, tests of</primary>
      </indexterm></para>

    <sidebar>
      <title><literal moreinfo="none">=</literal>, <literal
      moreinfo="none">==</literal>, and <literal
      moreinfo="none">phys_equal</literal></title>

      <para>If you come from a C/C++ background, you'll probably reflexively
      use <literal moreinfo="none">==</literal> to test two values for
      equality. In OCaml, the <literal moreinfo="none">==</literal> operator
      tests for <emphasis>physical</emphasis> equality, while the <literal
      moreinfo="none">=</literal> operator tests for
      <emphasis>structural</emphasis> equality.</para>

      <para>The physical equality test will match if two data structures have
      precisely the same pointer in memory. Two data structures that have
      identical contents but are constructed separately will not match using
      <literal moreinfo="none">==</literal>.</para>

      <para>The <literal moreinfo="none">=</literal> structural equality
      operator recursively inspects each field in the two values and tests
      them individually for equality. Crucially, if your data structure is
      cyclical (that is, a value recursively points back to another field
      within the same structure), the <literal moreinfo="none">=</literal>
      operator will never terminate, and your program will hang! You therefore
      must use the physical equality operator or write a custom comparison
      function when comparing cyclic values.</para>

      <para>It's quite easy to mix up the use of <literal
      moreinfo="none">=</literal> and <literal moreinfo="none">==</literal>,
      so Core disables the <literal moreinfo="none">==</literal> operator and
      provides the more explicit <literal moreinfo="none">phys_equal</literal>
      function instead. You'll see a type error if you use <literal
      moreinfo="none">==</literal> anywhere in code that opens <literal
      moreinfo="none">Core.Std</literal>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/core_phys_equal.topscript">maps-and-hash-tables/core_phys_equal.topscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">open Core.Std ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">1 == 2 ;;</userinput>
<computeroutput moreinfo="none">Characters -1-1:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         [ `Consider_using_phys_equal ]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">phys_equal 1 2 ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

      <para>If you feel like hanging your OCaml interpreter, you can verify
      what happens with recursive values and structural equality for
      yourself:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/maps-and-hash-tables/phys_equal.rawscript">maps-and-hash-tables/phys_equal.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># type t1 = { foo1:int; bar1:t2 } and t2 = { foo2:int; bar2:t1 } ;;</userinput>
<computeroutput moreinfo="none">type t1 = { foo1 : int; bar1 : t2; }
and t2 = { foo2 : int; bar2 : t1; }</computeroutput>
<userinput moreinfo="none"># let rec v1 = { foo1=1; bar1=v2 } and v2 = { foo2=2; bar2=v1 } ;;</userinput>
<computeroutput moreinfo="none">&lt;lots of text&gt;</computeroutput>
<userinput moreinfo="none"># v1 == v1;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<userinput moreinfo="none"># phys_equal v1 v1;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<userinput moreinfo="none"># v1 = v1 ;;</userinput>
<computeroutput moreinfo="none">&lt;press ^Z and kill the process now&gt;</computeroutput></programlisting>
    </sidebar>
  </sect1>
</chapter>
