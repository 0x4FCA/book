<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="files-modules-and-programs">
  <title>Files, Modules, and Programs</title>

  <para>We've so far experienced OCaml largely through the toplevel. As you
  move from exercises to real-world programs, you'll need to leave the
  toplevel behind and start building programs from files. Files are more than
  just a convenient way to store and manage your code; in OCaml, they also act
  as boundaries that divide your program into conceptual units.</para>

  <para>In this chapter, we'll show you how to build an OCaml program from a
  collection of files, as well as the basics of working with modules and
  module signatures.</para>

  <sect1 id="single-file-programs">
    <title>Single File Programs</title>

    <para>We'll start with an example: a utility that reads lines from
    <literal moreinfo="none">stdin</literal> and computes a frequency count of
    the lines that have been read in. At the end, the 10 lines with the
    highest frequency counts are written out. We'll start with a simple
    implementation, which we'll save as the file
    <emphasis>freq.ml</emphasis>.<indexterm class="startofrange"
        id="FILEsnglprog">
        <primary>files</primary>

        <secondary>single-file programs</secondary>
      </indexterm><indexterm class="startofrange" id="Psingfil">
        <primary>programs</primary>

        <secondary>single-file programs</secondary>
      </indexterm></para>

    <para>This implementation will use two functions from the <literal
    moreinfo="none">List.Assoc</literal> module, which provides utility
    functions for interacting with association lists, i.e., lists of key/value
    pairs. In particular, we use the function <literal
    moreinfo="none">List.Assoc.find</literal>, which looks up a key in an
    association list; and <literal moreinfo="none">List.Assoc.add</literal>,
    which adds a new binding to an association list, as shown below:<indexterm
        class="singular">
        <primary>List.Assoc module</primary>

        <secondary>List.Assoc.add</secondary>
      </indexterm><indexterm class="singular">
        <primary>List.Assoc module</primary>

        <secondary>List.Assoc.find</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>adding new bindings in</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>finding key associations in</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/intro.topscript">files-modules-and-programs/intro.topscript</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let assoc = [("one", 1); ("two",2); ("three",3)] ;;</userinput>
<computeroutput moreinfo="none">val assoc : (string * int) list = [("one", 1); ("two", 2); ("three", 3)]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.find assoc "two" ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.add assoc "four" 4 (* add a new key *) ;;</userinput>
<computeroutput moreinfo="none">- : (string, int) List.Assoc.t =</computeroutput>
<computeroutput moreinfo="none">[("four", 4); ("one", 1); ("two", 2); ("three", 3)]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.add assoc "two"  4 (* overwrite an existing key *) ;;</userinput>
<computeroutput moreinfo="none">- : (string, int) List.Assoc.t = [("two", 4); ("one", 1); ("three", 3)]</computeroutput></programlisting>

    <para>Note that <literal moreinfo="none">List.Assoc.add</literal> doesn't
    modify the original list, but instead allocates a new list with the
    requisite key/value pair added.</para>

    <para>Now we can write down <literal
    moreinfo="none">freq.ml</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq/freq.ml">files-modules-and-programs-freq/freq.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:[] ~f:(fun counts line -&gt;
    let count =
      match List.Assoc.find counts line with
      | None -&gt; 0
      | Some x -&gt; x
    in
    List.Assoc.add counts line (count + 1)
  )

let () =
  build_counts ()
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun l -&gt; List.take l 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</programlisting>

    <para>The function <literal moreinfo="none">build_counts</literal> reads
    in lines from <literal moreinfo="none">stdin</literal>, constructing from
    those lines an association list with the frequencies of each line. It does
    this by invoking <literal moreinfo="none">In_channel.fold_lines</literal>
    (similar to the function <literal moreinfo="none">List.fold</literal>
    described in <xref linkend="lists-and-patterns"/>), which reads through
    the lines one by one, calling the provided fold function for each line to
    update the accumulator. That accumulator is initialized to the empty
    list.</para>

    <para>With <literal moreinfo="none">build_counts</literal> defined, we
    then call the function to build the association list, sort that list by
    frequency in descending order, grab the first 10 elements off the list,
    and then iterate over those 10 elements and print them to the screen.
    These operations are tied together using the <literal
    moreinfo="none">|&gt;</literal> operator described in <xref
    linkend="variables-and-functions"/>:<indexterm class="singular">
        <primary>let ( ) declaration</primary>
      </indexterm><indexterm class="singular">
        <primary>main function</primary>
      </indexterm></para>

    <note>
      <title>Where Is the Main Function?</title>

      <para>Unlike C, programs in OCaml do not have a unique <literal
      moreinfo="none">main</literal> function. When an OCaml program is
      evaluated, all the statements in the implementation files are evaluated
      in the order in which they were linked together. These implementation
      files can contain arbitrary expressions, not just function definitions.
      In this example, the declaration starting with <literal
      moreinfo="none">let () =</literal> plays the role of the <literal
      moreinfo="none">main</literal> function, kicking off the processing. But
      really the entire file is evaluated at startup, and so in some sense the
      full codebase is one big <literal moreinfo="none">main</literal>
      function.</para>

      <para>The idiom of writing <literal moreinfo="none">let () =</literal>
      may seem a bit odd, but it has a purpose. The let binding here is a
      pattern-match to a value of type <literal
      moreinfo="none">unit</literal>, which is there to ensure that the
      expression on the righthand side returns <literal
      moreinfo="none">unit</literal>, as is common for functions that operate
      primarily by side effect.</para>
    </note>

    <para>If we weren't using Core or any other external libraries, we could
    build the executable like this:</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq/simple_build_fail.out">files-modules-and-programs-freq/simple_build_fail.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc freq.ml -o freq.byte</userinput>
<computeroutput moreinfo="none">File "freq.ml", line 1, characters 0-13:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound module Core</computeroutput></programlisting>

    <para>But as you can see, it fails because it can't find Core. We need a
    somewhat more complex invocation to get Core linked in:<indexterm
        class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlc</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlfind</secondary>
      </indexterm><indexterm class="singular">
        <primary>Core standard library</primary>

        <secondary>finding with ocamlfind</secondary>
      </indexterm></para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq/simple_build.out">files-modules-and-programs-freq/simple_build.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq.byte</userinput>
</programlisting>

    <para>This uses <command moreinfo="none">ocamlfind</command>, a tool which
    itself invokes other parts of the OCaml toolchain (in this case, <command
    moreinfo="none">ocamlc</command>) with the appropriate flags to link in
    particular libraries and packages. Here, <literal moreinfo="none">-package
    core</literal> is asking <command moreinfo="none">ocamlfind</command> to
    link in the Core library, <literal moreinfo="none">-linkpkg</literal> asks
    ocamlfind to link in the packages as is necessary for building an
    executable, while <literal moreinfo="none">-thread</literal> turns on
    threading support, which is required for Core.<indexterm class="singular">
        <primary>threads</primary>

        <secondary>turning on with -thread</secondary>
      </indexterm><indexterm class="singular">
        <primary sortas="linkpkg">-linkpkg</primary>
      </indexterm></para>

    <para>While this works well enough for a one-file project, more
    complicated projects require a tool to orchestrate the build. One good
    tool for this task is <command moreinfo="none">ocamlbuild</command>, which
    is shipped with the OCaml compiler. We'll talk more about <command
    moreinfo="none">ocamlbuild</command> in <xref
    linkend="the-compiler-frontend-parsing-and-type-checking"/>, but for now,
    we'll just use a simple wrapper around <command
    moreinfo="none">ocamlbuild</command> called <command
    moreinfo="none">corebuild</command> that sets build parameters
    appropriately for building against Core and its related
    libraries:<indexterm class="singular">
        <primary>corebuild</primary>
      </indexterm></para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-obuild/build.out">files-modules-and-programs-freq-obuild/build.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
</programlisting>

    <para>If we'd invoked <command moreinfo="none">corebuild</command> with a
    target of <literal moreinfo="none">freq.native</literal> instead of
    <literal moreinfo="none">freq.byte</literal>, we would have gotten native
    code instead.</para>

    <para>We can run the resulting executable from the command line. The
    following line extracts strings from the <command
    moreinfo="none">ocamlopt</command> binary, reporting the most frequently
    occurring ones. Note that the specific results will vary from platform to
    platform, since the binary itself will differ between platforms:<indexterm
        class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlbuild</secondary>
      </indexterm><indexterm class="singular">
        <primary>native-code compiler</primary>

        <secondary sortas="bytecode">vs. bytecode compiler</secondary>
      </indexterm><indexterm class="singular">
        <primary>bytecode compiler</primary>

        <secondary sortas="native-code">vs. native-code compiler</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlopt</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlc</secondary>
      </indexterm><indexterm class="singular">
        <primary>code compilers</primary>

        <secondary>bytecode vs. native code</secondary>
      </indexterm><indexterm class="endofrange"
    startref="FILEsnglprog"/><indexterm class="endofrange"
    startref="Psingfil"/></para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-obuild/test.out">files-modules-and-programs-freq-obuild/test.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">strings `which ocamlopt` | ./freq.byte</userinput>
<computeroutput moreinfo="none">  6: +pci_expr =</computeroutput>
<computeroutput moreinfo="none">  6: -pci_params =</computeroutput>
<computeroutput moreinfo="none">  6: .pci_virt = %a</computeroutput>
<computeroutput moreinfo="none">  4: #lsr</computeroutput>
<computeroutput moreinfo="none">  4: #lsl</computeroutput>
<computeroutput moreinfo="none">  4: $lxor</computeroutput>
<computeroutput moreinfo="none">  4: #lor</computeroutput>
<computeroutput moreinfo="none">  4: $land</computeroutput>
<computeroutput moreinfo="none">  4: #mod</computeroutput>
<computeroutput moreinfo="none">  3: 6	.section .rdata,"dr"</computeroutput></programlisting>

    <note>
      <title>Bytecode Versus Native Code</title>

      <para>OCaml ships with two compilers: the <command
      moreinfo="none">ocamlc</command> bytecode compiler and the <command
      moreinfo="none">ocamlopt</command> native-code compiler. Programs
      compiled with <command moreinfo="none">ocamlc</command> are interpreted
      by a virtual machine, while programs compiled with <command
      moreinfo="none">ocamlopt</command> are compiled to native machine code
      to be run on a specific operating system and processor architecture.
      With <command moreinfo="none">ocamlbuild</command>, targets ending with
      <literal moreinfo="none">.byte</literal> are build as bytecode
      executables, and those ending with <literal
      moreinfo="none">.native</literal> are built as native code.</para>

      <para>Aside from performance, executables generated by the two compilers
      have nearly identical behavior. There are a few things to be aware of.
      First, the bytecode compiler can be used on more architectures, and has
      some tools that are not available for native code. For example, the
      OCaml debugger only works with bytecode (although <command
      moreinfo="none">gdb</command>, the GNU Debugger, works with OCaml
      native-code applications). The bytecode compiler is also quicker than
      the native-code compiler. In addition, in order to run a bytecode
      executable, you typically need to have OCaml installed on the system in
      question. That's not strictly required, though, since you can build a
      bytecode executable with an embedded runtime, using the <literal
      moreinfo="none">-custom</literal> compiler flag.</para>

      <para>As a general matter, production executables should usually be
      built using the native-code compiler, but it sometimes makes sense to
      use bytecode for development builds. And, of course, bytecode makes
      sense when targeting a platform not supported by the native-code
      compiler. We'll cover both compilers in more detail in <xref
      linkend="the-compiler-backend-byte-code-and-native-code"/>.</para>
    </note>
  </sect1>

  <sect1 id="multi-file-programs-and-modules">
    <title>Multifile Programs and Modules</title>

    <para>Source files in OCaml are tied into the module system, with each
    file compiling down into a module whose name is derived from the name of
    the file. We've encountered modules before, for example, when we used
    functions like <literal moreinfo="none">find</literal> and <literal
    moreinfo="none">add</literal> from the <literal
    moreinfo="none">List.Assoc</literal> module. At its simplest, you can
    think of a module as a collection of definitions that are stored within a
    namespace.<indexterm class="singular">
        <primary>modules</primary>

        <secondary>basics of</secondary>
      </indexterm><indexterm class="singular">
        <primary>files</primary>

        <secondary>multi-file programs</secondary>
      </indexterm><indexterm class="singular">
        <primary>programs</primary>

        <secondary>multi-file programs</secondary>
      </indexterm></para>

    <para>Let's consider how we can use modules to refactor the implementation
    of <literal moreinfo="none">freq.ml</literal>. Remember that the variable
    <literal moreinfo="none">counts</literal> contains an association list
    representing the counts of the lines seen so far. But updating an
    association list takes time linear in the length of the list, meaning that
    the time complexity of processing a file is quadratic in the number of
    distinct lines in the file.</para>

    <para>We can fix this problem by replacing association lists with a more
    efficient data structure. To do that, we'll first factor out the key
    functionality into a separate module with an explicit interface. We can
    consider alternative (and more efficient) implementations once we have a
    clear interface to program against.</para>

    <para>We'll start by creating a file, <literal
    moreinfo="none">counter.ml</literal>, that contains the logic for
    maintaining the association list used to represent the frequency counts.
    The key function, called <literal moreinfo="none">touch</literal>, bumps
    the frequency count of a given line by one:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-counter/counter.ml">files-modules-and-programs-freq-with-counter/counter.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)</programlisting>

    <para>The file <emphasis>counter.ml</emphasis> will be compiled into a
    module named <literal moreinfo="none">Counter</literal>, where the name of
    the module is derived automatically from the filename. The module name is
    capitalized even if the file is not. Indeed, module names are always
    capitalized.<indexterm class="singular">
        <primary>modules</primary>

        <secondary>naming of</secondary>
      </indexterm></para>

    <para>We can now rewrite <literal moreinfo="none">freq.ml</literal> to use
    <literal moreinfo="none">Counter</literal>. Note that the resulting code
    can still be built with <command moreinfo="none">ocamlbuild</command>,
    which will discover dependencies and realize that <literal
    moreinfo="none">counter.ml</literal> needs to be compiled:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-counter/freq.ml">files-modules-and-programs-freq-with-counter/freq.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:[] ~f:Counter.touch

let () =
  build_counts ()
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun l -&gt; List.take l 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</programlisting>
  </sect1>

  <sect1 id="signatures-and-abstract-types">
    <title>Signatures and Abstract Types</title>

    <para>While we've pushed some of the logic to the <literal
    moreinfo="none">Counter</literal> module, the code in <literal
    moreinfo="none">freq.ml</literal> can still depend on the details of the
    implementation of <literal moreinfo="none">Counter</literal>. Indeed, if
    you look at the definition of <literal
    moreinfo="none">build_counts</literal>, you'll see that it depends on the
    fact that the empty set of frequency counts is represented as an empty
    list. We'd like to prevent this kind of dependency, so we can change the
    implementation of <literal moreinfo="none">Counter</literal> without
    needing to change client code like that in <literal
    moreinfo="none">freq.ml</literal>.<indexterm class="singular">
        <primary>abstract types</primary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary>module type</secondary>
      </indexterm><indexterm class="singular">
        <primary>signatures</primary>

        <secondary>abstract types</secondary>
      </indexterm><indexterm class="singular">
        <primary>interfaces</primary>

        <secondary>hiding implementation details with</secondary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary>hiding implementation details</secondary>
      </indexterm></para>

    <para>The implementation details of a module can be hidden by attaching an
    <emphasis>interface</emphasis>. (Note that in the context of OCaml, the
    terms <emphasis>interface</emphasis>, <emphasis>signature</emphasis>, and
    <emphasis>module type</emphasis> are all used interchangeably.) A module
    defined by a file <literal moreinfo="none">filename.ml</literal> can be
    constrained by a signature placed in a file called <literal
    moreinfo="none">filename.mli</literal>.<indexterm class="singular">
        <primary>interfaces</primary>

        <secondary>synonyms for</secondary>
      </indexterm></para>

    <para>For <literal moreinfo="none">counter.mli</literal>, we'll start by
    writing down an interface that describes what's currently available in
    <literal moreinfo="none">counter.ml</literal>, without hiding anything.
    <literal moreinfo="none">val</literal> declarations are used to specify
    values in a signature. The syntax of a <literal
    moreinfo="none">val</literal> declaration is as follows:</para>

    <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/val.syntax">files-modules-and-programs/val.syntax</ulink></para>

    <programlisting format="linespecific" language="">val &lt;identifier&gt; : &lt;type&gt;</programlisting>

    <para>Using this syntax, we can write the signature of <literal
    moreinfo="none">counter.ml</literal> as follows:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-sig/counter.mli">files-modules-and-programs-freq-with-sig/counter.mli</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(** Bump the frequency count for the given string. *)
val touch : (string * int) list -&gt; string -&gt; (string * int) list</programlisting>

    <para>Note that <command moreinfo="none">ocamlbuild</command> will detect
    the presence of the <literal moreinfo="none">mli</literal> file
    automatically and include it in the build.</para>

    <note>
      <title>Autogenerating <literal moreinfo="none">mli</literal>
      Files</title>

      <para>If you don't want to construct an <literal>mli</literal> entirely
      by hand, you can ask OCaml to autogenerate one for you from the source,
      which you can then adjust to fit your needs. Here's how you can do that
      using <literal moreinfo="none">corebuild</literal>:<indexterm
          class="singular">
          <primary>mili files</primary>
        </indexterm><indexterm class="singular">
          <primary>files</primary>

          <secondary>mli files</secondary>
        </indexterm></para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-counter/infer_mli.out">files-modules-and-programs-freq-with-counter/infer_mli.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild counter.inferred.mli</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat _build/counter.inferred.mli</userinput>
<computeroutput moreinfo="none">val touch :</computeroutput>
<computeroutput moreinfo="none">  ('a, int) Core.Std.List.Assoc.t -&gt; 'a -&gt; ('a, int) Core.Std.List.Assoc.t</computeroutput></programlisting>

      <para>The generated code is basically equivalent to the <literal
      moreinfo="none">mli</literal> that we wrote by hand but is a bit uglier
      and more verbose and, of course, has no comments. In general,
      autogenerated <literal moreinfo="none">mli</literal>'s are only useful
      as a starting point. In OCaml, the <literal
      moreinfo="none">mli</literal> is the key place where you present and
      document your interface, and there's no replacement for careful human
      editing and organization.</para>
    </note>

    <para>To hide the fact that frequency counts are represented as
    association lists, we'll need to make the type of frequency counts
    <emphasis>abstract</emphasis>. A type is abstract if its name is exposed
    in the interface, but its definition is not. Here's an abstract interface
    for <literal moreinfo="none">Counter</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-sig-abstract/counter.mli">files-modules-and-programs-freq-with-sig-abstract/counter.mli</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(** Converts the set of frequency counts to an association list.  A string shows
    up at most once, and the counts are &gt;= 1. *)
val to_list : t -&gt; (string * int) list</programlisting>

    <para>Note that we needed to add <literal moreinfo="none">empty</literal>
    and <literal moreinfo="none">to_list</literal> to <literal
    moreinfo="none">Counter</literal>, since otherwise, there would be no way
    to create a <literal moreinfo="none">Counter.t</literal> or get data out
    of one.</para>

    <para>We also used this opportunity to document the module. The <literal
    moreinfo="none">mli</literal> file is the place where you specify your
    module's interface, and as such is a natural place to put documentation.
    We also started our comments with a double asterisk to cause them to be
    picked up by the <command moreinfo="none">ocamldoc</command> tool when
    generating API documentation. We'll discuss <command
    moreinfo="none">ocamldoc</command> more in <xref
    linkend="the-compiler-frontend-parsing-and-type-checking"/>.</para>

    <para>Here's a rewrite of <literal moreinfo="none">counter.ml</literal> to
    match the new <literal moreinfo="none">counter.mli</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-sig-abstract/counter.ml">files-modules-and-programs-freq-with-sig-abstract/counter.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = (string * int) list

let empty = []

let to_list x = x

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)</programlisting>

    <para>If we now try to compile <literal moreinfo="none">freq.ml</literal>,
    we'll get the following error:</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-sig-abstract/build.out">files-modules-and-programs-freq-with-sig-abstract/build.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "freq.ml", line 4, characters 42-55:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type Counter.t -&gt; string -&gt; Counter.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type 'a list -&gt; string -&gt; 'a list</computeroutput>
<computeroutput moreinfo="none">       Type Counter.t is not compatible with type 'a list </computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

    <para>This is because <literal moreinfo="none">freq.ml</literal> depends
    on the fact that frequency counts are represented as association lists, a
    fact that we've just hidden. We just need to fix <literal
    moreinfo="none">build_counts</literal> to use <literal
    moreinfo="none">Counter.empty</literal> instead of <literal
    moreinfo="none">[]</literal> and <literal
    moreinfo="none">Counter.to_list</literal> to get the association list out
    at the end for processing and printing. The resulting implementation is
    shown below:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-sig-abstract-fixed/freq.ml">files-modules-and-programs-freq-with-sig-abstract-fixed/freq.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:Counter.empty ~f:Counter.touch

let () =
  build_counts ()
  |&gt; Counter.to_list
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun counts -&gt; List.take counts 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</programlisting>

    <para>Now we can turn to optimizing the implementation of <literal
    moreinfo="none">Counter</literal>. Here's an alternate and far more
    efficient implementation, based on the <literal
    moreinfo="none">Map</literal> datastructure in Core:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-fast/counter.ml">files-modules-and-programs-freq-fast/counter.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = int String.Map.t

let empty = String.Map.empty

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t ~key:s ~data:(count + 1)</programlisting>

    <para>Note that in the preceding example we use <literal
    moreinfo="none">String.Map</literal> in some places and simply <literal
    moreinfo="none">Map</literal> in others. This has to do with the fact that
    for some operations, like creating a <literal
    moreinfo="none">Map.t</literal>, you need access to type-specialized
    information, and for others, like looking something up in <literal
    moreinfo="none">Map.t</literal>, you don't. This is covered in more detail
    in <xref linkend="maps-and-hash-tables"/>.</para>
  </sect1>

  <sect1 id="concrete-types-in-signatures">
    <title>Concrete Types in Signatures</title>

    <para>In our frequency-count example, the module <literal
    moreinfo="none">Counter</literal> had an abstract type <literal
    moreinfo="none">Counter.t</literal> for representing a collection of
    frequency counts. Sometimes, you'll want to make a type in your interface
    <emphasis>concrete</emphasis>, by including the type definition in the
    interface.<indexterm class="singular">
        <primary>concrete types</primary>
      </indexterm><indexterm class="singular">
        <primary>signatures</primary>

        <secondary>concrete types</secondary>
      </indexterm></para>

    <para>For example, imagine we wanted to add a function to <literal
    moreinfo="none">Counter</literal> for returning the line with the median
    frequency count. If the number of lines is even, then there is no precise
    median, and the function would return the lines before and after the
    median instead. We'll use a custom type to represent the fact that there
    are two possible return values. Here's a possible implementation:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-median/counter.ml">files-modules-and-programs-freq-median/counter.ml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">type median = | Median of string
              | Before_and_after of string * string

let median t =
  let sorted_strings = List.sort (Map.to_alist t)
                         ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  in
  let len = List.length sorted_strings in
  if len = 0 then failwith "median: empty frequency count";
  let nth n = fst (List.nth_exn sorted_strings n) in
  if len mod 2 = 1
  then Median (nth (len/2))
  else Before_and_after (nth (len/2 - 1), nth (len/2));;</programlisting>

    <para>In the preceding implementation, we use <literal
    moreinfo="none">failwith</literal> to throw an exception for the case of
    the empty list. We'll discuss exceptions more in <xref
    linkend="error-handling"/>. Note also that the function <literal
    moreinfo="none">fst</literal> simply returns the first element of any
    two-tuple.</para>

    <para>Now, to expose this usefully in the interface, we need to expose
    both the function and the type <literal moreinfo="none">median</literal>
    with its definition. Note that values (of which functions are an example)
    and types have distinct namespaces, so there's no name clash here. Adding
    the following two lines added to <literal
    moreinfo="none">counter.mli</literal> does the trick:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-median/counter.mli">files-modules-and-programs-freq-median/counter.mli</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Median of string
              | Before_and_after of string * string

val median : t -&gt; median</programlisting>

    <para>The decision of whether a given type should be abstract or concrete
    is an important one. Abstract types give you more control over how values
    are created and accessed, and make it easier to enforce invariants beyond
    what is enforced by the type itself; concrete types let you expose more
    detail and structure to client code in a lightweight way. The right choice
    depends very much on the context.</para>
  </sect1>

  <sect1 id="nested-modules">
    <title>Nested Modules</title>

    <para>Up until now, we've only considered modules that correspond to
    files, like <literal moreinfo="none">counter.ml</literal>. But modules
    (and module signatures) can be nested inside other modules. As a simple
    example, consider a program that needs to deal with multiple identifiers
    like usernames and hostnames. If you just represent these as strings, then
    it becomes easy to confuse one with the other.<indexterm class="singular">
        <primary>identifiers</primary>

        <secondary>dealing with multiple</secondary>
      </indexterm><indexterm class="singular">
        <primary>nested modules</primary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary>nested modules</secondary>
      </indexterm></para>

    <para>A better approach is to mint new abstract types for each identifier,
    where those types are under the covers just implemented as strings. That
    way, the type system will prevent you from confusing a username with a
    hostname, and if you do need to convert, you can do so using explicit
    conversions to and from the string type.</para>

    <para>Here's how you might create such an abstract type, within a
    submodule:<indexterm class="singular">
        <primary>abstract types</primary>
      </indexterm></para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/abstract_username.ml">files-modules-and-programs/abstract_username.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

module Username : sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end = struct
  type t = string
  let of_string x = x
  let to_string x = x
end</programlisting>

    <para>Note that the <literal moreinfo="none">to_string</literal> and
    <literal moreinfo="none">of_string</literal> functions above are
    implemented simply as the identity function, which means they have no
    runtime effect. They are there purely as part of the discipline that they
    enforce on the code through the type system.</para>

    <para>The basic structure of a module declaration like this is:</para>

    <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/module.syntax">files-modules-and-programs/module.syntax</ulink></para>

    <programlisting format="linespecific" language="">module &lt;name&gt; : &lt;signature&gt; = &lt;implementation&gt;</programlisting>

    <para>We could have written this slightly differently, by giving the
    signature its own top-level <literal moreinfo="none">module type</literal>
    declaration, making it possible to create multiple distinct types with the
    same underlying implementation in a lightweight way:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/session_info.ml">files-modules-and-programs/session_info.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

module type ID = sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end

module String_id = struct
  type t = string
  let of_string x = x
  let to_string x = x
end

module Username : ID = String_id
module Hostname : ID = String_id

type session_info = { user: Username.t;
                      host: Hostname.t;
                      when_started: Time.t;
                    }

let sessions_have_same_user s1 s2 =
  s1.user = s2.host</programlisting>

    <para>The preceding code has a bug: it compares the username in one
    session to the host in the other session, when it should be comparing the
    usernames in both cases. Because of how we defined our types, however, the
    compiler will flag this bug for us:</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/build_session_info.out">files-modules-and-programs/build_session_info.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild session_info.native</userinput>
<computeroutput moreinfo="none">File "session_info.ml", line 24, characters 12-19:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type Hostname.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type Username.t</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

    <para>This is a trivial example, but confusing different kinds of
    identifiers is a very real source of bugs, and the approach of minting
    abstract types for different classes of identifiers is an effective way of
    avoiding such issues.</para>
  </sect1>

  <sect1 id="opening-modules">
    <title>Opening Modules</title>

    <para>Most of the time, you refer to values and types within a module by
    using the module name as an explicit qualifier. e.g., you write <literal
    moreinfo="none">List.map</literal> to refer to the <literal
    moreinfo="none">map</literal> function in the <literal
    moreinfo="none">List</literal> module. Sometimes, though, you want to be
    able to refer to the contents of a module without this explicit
    qualification. That's what the <literal moreinfo="none">open</literal>
    statement is for.<indexterm class="singular">
        <primary>identifiers</primary>

        <secondary>open modules and</secondary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary>opening</secondary>
      </indexterm></para>

    <para>We've encountered <literal moreinfo="none">open</literal> already,
    specifically where we've written <literal moreinfo="none">open
    Core.Std</literal> to get access to the standard definitions in the Core
    library. In general, opening a module adds the contents of that module to
    the environment that the compiler looks at to find the definition of
    various identifiers. Here's an example:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module M = struct let foo = 3 end;;</userinput>
<computeroutput moreinfo="none">module M : sig val foo : int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">foo;;</userinput>
<computeroutput moreinfo="none">Characters -1-3:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value foo</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open M;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">foo;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>

    <para><literal moreinfo="none">open</literal> is essential when you want
    to modify your environment for a standard library like Core, but it's
    generally good style to keep opening of modules to a minimum. Opening a
    module is basically a tradeoff between terseness and explicitness—the more
    modules you open, the fewer module qualifications you need, and the harder
    it is to look at an identifier and figure out where it comes from.</para>

    <para>Here's some general advice on how to deal with opens:<indexterm
        class="singular">
        <primary>local opens</primary>
      </indexterm></para>

    <itemizedlist>
      <listitem>
        <para>Opening modules at the toplevel of a module should be done quite
        sparingly, and generally only with modules that have been specifically
        designed to be opened, like <literal
        moreinfo="none">Core.Std</literal> or <literal
        moreinfo="none">Option.Monad_infix</literal>.</para>
      </listitem>

      <listitem>
        <para>If you do need to do an open, it's better to do a
        <emphasis>local open</emphasis>. There are two syntaxes for local
        opens. For example, you can write:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let average x y =</userinput>
<userinput moreinfo="none">    let open Int64 in</userinput>
<userinput moreinfo="none">    x + y / of_int 2;;</userinput>
<computeroutput moreinfo="none">val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;</computeroutput></programlisting>

        <para>Here, <literal moreinfo="none">of_int</literal> and the infix
        operators are the ones from the <literal
        moreinfo="none">Int64</literal> module.</para>

        <para>There's another even more lightweight syntax for local opens,
        which is particularly useful for small expressions:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let average x y =</userinput>
<userinput moreinfo="none">    Int64.(x + y / of_int 2);;</userinput>
<computeroutput moreinfo="none">val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;</computeroutput></programlisting>
      </listitem>

      <listitem>
        <para>An alternative to local opens that makes your code terser
        without giving up on explicitness is to locally rebind the name of a
        module. So, when using the <literal
        moreinfo="none">Counter.median</literal> type, instead of
        writing:</para>

        <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-median/use_median_1.ml">files-modules-and-programs-freq-median/use_median_1.ml</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml">let print_median m =
  match m with
  | Counter.Median string -&gt; printf "True median:\n   %s\n" string
  | Counter.Before_and_after (before, after) -&gt;
    printf "Before and after median:\n   %s\n   %s\n" before after</programlisting>

        <para>you could write:</para>

        <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-median/use_median_2.ml">files-modules-and-programs-freq-median/use_median_2.ml</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml">let print_median m =
  let module C = Counter in
  match m with
  | C.Median string -&gt; printf "True median:\n   %s\n" string
  | C.Before_and_after (before, after) -&gt;
    printf "Before and after median:\n   %s\n   %s\n" before after</programlisting>

        <para>Because the module name <literal moreinfo="none">C</literal>
        only exists for a short scope, it's easy to read and remember what
        <literal moreinfo="none">C</literal> stands for. Rebinding modules to
        very short names at the toplevel of your module is usually a
        mistake.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="including-modules">
    <title>Including Modules</title>

    <para>While opening a module affects the environment used to search for
    identifiers, <emphasis>including</emphasis> a module is a way of actually
    adding new identifiers to a module proper. Consider the following simple
    module for representing a range of intervals:<indexterm class="singular">
        <primary>modules</primary>

        <secondary>including</secondary>
      </indexterm><indexterm class="singular">
        <primary>identifiers</primary>

        <secondary>adding to modules</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Interval = struct</userinput>
<userinput moreinfo="none">    type t = | Interval of int * int</userinput>
<userinput moreinfo="none">             | Empty</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let create low high =</userinput>
<userinput moreinfo="none">      if high &lt; low then Empty else Interval (low,high)</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Interval :</computeroutput>
<computeroutput moreinfo="none">  sig type t = Interval of int * int | Empty val create : int -&gt; int -&gt; t end</computeroutput></programlisting>

    <para>We can use the <literal moreinfo="none">include</literal> directive
    to create a new, extended version of the <literal
    moreinfo="none">Interval</literal> module:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Extended_interval = struct</userinput>
<userinput moreinfo="none">    include Interval</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let contains t x =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; false</userinput>
<userinput moreinfo="none">      | Interval (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Extended_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Interval.t = Interval of int * int | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Extended_interval.contains (Extended_interval.create 3 10) 4;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>The difference between <literal moreinfo="none">include</literal>
    and <literal moreinfo="none">open</literal> is that we've done more than
    change how identifiers are searched for: we've changed what's in the
    module. If we'd used <literal moreinfo="none">open</literal>, we'd have
    gotten a quite different result:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/main.topscript">files-modules-and-programs/main.topscript</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Extended_interval = struct</userinput>
<userinput moreinfo="none">    open Interval</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let contains t x =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; false</userinput>
<userinput moreinfo="none">      | Interval (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Extended_interval :</computeroutput>
<computeroutput moreinfo="none">  sig val contains : Extended_interval.t -&gt; int -&gt; bool end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Extended_interval.contains (Extended_interval.create 3 10) 4;;</userinput>
<computeroutput moreinfo="none">Characters 28-52:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value Extended_interval.create</computeroutput></programlisting>

    <para>To consider a more realistic example, imagine you wanted to build an
    extended version of the <literal moreinfo="none">List</literal> module,
    where you've added some functionality not present in the module as
    distributed in Core. <literal moreinfo="none">include</literal> allows us
    to do just that:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/ext_list.ml">files-modules-and-programs/ext_list.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(* The new function we're going to add *)
let rec intersperse list el =
  match list with
  | [] | [ _ ]   -&gt; list
  | x :: y :: tl -&gt; x :: el :: intersperse (y::tl) el

(* The remainder of the list module *)
include List</programlisting>

    <para>Now, how do we write an interface for this new module? It turns out
    that <literal moreinfo="none">include</literal> works on signatures as
    well, so we can pull essentially the same trick to write our <literal
    moreinfo="none">mli</literal>. The only issues is that we need to get our
    hands on the signature for the <literal moreinfo="none">List</literal>
    module. This can be done using <literal moreinfo="none">module type
    of</literal>, which computes a signature from a module:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/ext_list.mli">files-modules-and-programs/ext_list.mli</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(* Include the interface of the list module from Core *)
include (module type of List)

(* Signature of function we're adding *)
val intersperse : 'a list -&gt; 'a -&gt; 'a list</programlisting>

    <para>Note that the order of declarations in the <literal
    moreinfo="none">mli</literal> does not need to match the order of
    declarations in the <literal moreinfo="none">ml</literal>. The order of
    declarations in the <literal moreinfo="none">ml</literal> mostly matters
    insofar as it affects which values are shadowed. If we wanted to replace a
    function in <literal moreinfo="none">List</literal> with a new function of
    the same name, the declaration of that function in the <literal
    moreinfo="none">ml</literal> would have to come after the <literal
    moreinfo="none">include List</literal> declaration.</para>

    <para>We can now use <literal moreinfo="none">Ext_list</literal> as a
    replacement for <literal moreinfo="none">List</literal>. If we want to use
    <literal moreinfo="none">Ext_list</literal> in preference to <literal
    moreinfo="none">List</literal> in our project, we can create a file of
    common definitions:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs/common.ml">files-modules-and-programs/common.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">module List = Ext_list</programlisting>

    <para>And if we then put <literal moreinfo="none">open Common</literal>
    after <literal moreinfo="none">open Core.Std</literal> at the top of each
    file in our project, then references to <literal
    moreinfo="none">List</literal> will automatically go to <literal
    moreinfo="none">Ext_list</literal> instead.</para>
  </sect1>

  <sect1 id="common-errors-with-modules">
    <title>Common Errors with Modules</title>

    <para>When OCaml compiles a program with an <literal
    moreinfo="none">ml</literal> and an <literal
    moreinfo="none">mli</literal>, it will complain if it detects a mismatch
    between the two. Here are some of the common errors you'll run
    into.</para>

    <sect2 id="type-mismatches">
      <title>Type Mismatches</title>

      <para>The simplest kind of error is where the type specified in the
      signature does not match up with the type in the implementation of the
      module. As an example, if we replace the <literal
      moreinfo="none">val</literal> declaration in <literal
      moreinfo="none">counter.mli</literal> by swapping the types of the first
      two arguments:<indexterm class="singular">
          <primary>errors</primary>

          <secondary>module type mismatches</secondary>
        </indexterm><indexterm class="singular">
          <primary>type mismatches</primary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>

          <secondary>type mismatches in</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-sig-mismatch/counter.mli">files-modules-and-programs-freq-with-sig-mismatch/counter.mli</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">(** Bump the frequency count for the given string. *)
val touch : string -&gt; t -&gt; t</programlisting>

      <para>and we try to compile, we'll get the following error:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-sig-mismatch/build.out">files-modules-and-programs-freq-with-sig-mismatch/build.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "freq.ml", line 4, characters 53-66:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string -&gt; Counter.t -&gt; Counter.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         Counter.t -&gt; string -&gt; Counter.t</computeroutput>
<computeroutput moreinfo="none">       Type string is not compatible with type Counter.t </computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>
    </sect2>

    <sect2 id="missing-definitions">
      <title>Missing Definitions</title>

      <para>We might decide that we want a new function in <literal
      moreinfo="none">Counter</literal> for pulling out the frequency count of
      a given string. We can update the <literal moreinfo="none">mli</literal>
      by adding the following line:<indexterm class="singular">
          <primary>errors</primary>

          <secondary>missing module definitions</secondary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>

          <secondary>missing definitions in</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-missing-def/counter.mli">files-modules-and-programs-freq-with-missing-def/counter.mli</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">val count : t -&gt; string -&gt; int</programlisting>

      <para>Now, if we try to compile without actually adding the
      implementation, we'll get this error:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-missing-def/build.out">files-modules-and-programs-freq-with-missing-def/build.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "counter.ml", line 1:</computeroutput>
<computeroutput moreinfo="none">Error: The implementation counter.ml</computeroutput>
<computeroutput moreinfo="none">       does not match the interface counter.cmi:</computeroutput>
<computeroutput moreinfo="none">       The field `count' is required but not provided</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>A missing type definition will lead to a similar error.</para>
    </sect2>

    <sect2 id="type-definition-mismatches">
      <title>Type Definition Mismatches</title>

      <para>Type definitions that show up in an <literal
      moreinfo="none">mli</literal> need to match up with corresponding
      definitions in the <literal moreinfo="none">ml</literal>. Consider again
      the example of the type <literal moreinfo="none">median</literal>. The
      order of the declaration of variants matters to the OCaml compiler, so
      the definition of <literal moreinfo="none">median</literal> in the
      implementation listing those options in a different order:<indexterm
          class="singular">
          <primary>type definition mismatches</primary>
        </indexterm><indexterm class="singular">
          <primary>errors</primary>

          <secondary>module type definition mismatches</secondary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>

          <secondary>type definition mismatches</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-type-mismatch/counter.mli">files-modules-and-programs-freq-with-type-mismatch/counter.mli</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Before_and_after of string * string
              | Median of string</programlisting>

      <para>will lead to a compilation error:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-with-type-mismatch/build.out">files-modules-and-programs-freq-with-type-mismatch/build.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "counter.ml", line 1:</computeroutput>
<computeroutput moreinfo="none">Error: The implementation counter.ml</computeroutput>
<computeroutput moreinfo="none">       does not match the interface counter.cmi:</computeroutput>
<computeroutput moreinfo="none">       Type declarations do not match:</computeroutput>
<computeroutput moreinfo="none">         type median = Median of string | Before_and_after of string * string</computeroutput>
<computeroutput moreinfo="none">       is not included in</computeroutput>
<computeroutput moreinfo="none">         type median = Before_and_after of string * string | Median of string</computeroutput>
<computeroutput moreinfo="none">       File "counter.ml", line 18, characters 5-84: Actual declaration</computeroutput>
<computeroutput moreinfo="none">       Fields number 1 have different names, Median and Before_and_after.</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>Order is similarly important to other type declarations, including
      the order in which record fields are declared and the order of arguments
      (including labeled and optional arguments) to a function.</para>
    </sect2>

    <sect2 id="cyclic-dependencies">
      <title>Cyclic Dependencies</title>

      <para>In most cases, OCaml doesn't allow cyclic dependencies, i.e., a
      collection of definitions that all refer to one another. If you want to
      create such definitions, you typically have to mark them specially. For
      example, when defining a set of mutually recursive values (like the
      definition of <literal moreinfo="none">is_even</literal> and <literal
      moreinfo="none">is_odd</literal> in <xref
      linkend="recursive-functions"/>), you need to define them using <literal
      moreinfo="none">let rec</literal> rather than ordinary <literal
      moreinfo="none">let</literal>.<indexterm class="singular">
          <primary>dependencies, cyclic</primary>
        </indexterm><indexterm class="singular">
          <primary>cyclic dependencies</primary>
        </indexterm><indexterm class="singular">
          <primary>errors</primary>

          <secondary>cyclic dependencies</secondary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>

          <secondary>cyclic dependencies</secondary>
        </indexterm></para>

      <para>The same is true at the module level. By default, cyclic
      dependencies between modules are not allowed, and cyclic dependencies
      among files are never allowed. Recursive modules are possible but are a
      rare case, and we won't discuss them further here.</para>

      <para>The simplest example of a forbidden circular reference is a module
      referring to its own module name. So, if we tried to add a reference to
      <literal moreinfo="none">Counter</literal> from within <literal
      moreinfo="none">counter.ml</literal>:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-cyclic1/counter.ml">files-modules-and-programs-freq-cyclic1/counter.ml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let singleton l = Counter.touch Counter.empty</programlisting>

      <para>we'll see this error when we try to build:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-cyclic1/build.out">files-modules-and-programs-freq-cyclic1/build.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "counter.ml", line 18, characters 18-31:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound module Counter</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>The problem manifests in a different way if we create cyclic
      references between files. We could create such a situation by adding a
      reference to <literal moreinfo="none">Freq</literal> from <literal
      moreinfo="none">counter.ml</literal>, e.g., by adding the following
      line:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-cyclic2/counter.ml">files-modules-and-programs-freq-cyclic2/counter.ml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let _build_counts = Freq.build_counts</programlisting>

      <para>In this case, <command moreinfo="none">ocamlbuild</command> (which
      is invoked by the <command moreinfo="none">corebuild</command> script)
      will notice the error and complain explicitly about the cycle:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/files-modules-and-programs-freq-cyclic2/build.out">files-modules-and-programs-freq-cyclic2/build.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">Circular dependencies: "freq.cmo" already seen in</computeroutput>
<computeroutput moreinfo="none">  [ "counter.cmo"; "freq.cmo" ]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>
    </sect2>
  </sect1>
</chapter>
