<section xmlns="http://www.w3.org/1999/xhtml" id="first-class-modules" data-type="chapter"><h1>First-Class Modules</h1><p>You can think of OCaml as being broken up into two parts: a core
  language that is concerned with values and types, and a module language that
  is concerned with modules and module signatures. These sublanguages are
  stratified, in that modules can contain types and values, but ordinary
  values can't contain modules or module types. That means you can't do things
  like define a variable whose value is a module, or a function that takes a
  module as an argument.<a data-type="indexterm" id="MODfirst" data-primary="modules" data-secondary="first-class modules"/></p><p>OCaml provides a way around this stratification in the form of
  <em>first-class modules</em>. First-class modules are ordinary
  values that can be created from and converted back to regular
  modules.<a data-type="indexterm" id="FCMwork" data-primary="first-class modules" data-secondary="working with"/></p><p>First-class modules are a sophisticated technique, and you'll need to get comfortable with
        some advanced aspects of the language to use them effectively. But it's worth learning,
        because letting modules into the core language is quite powerful, increasing the range of
        what you can express and making it easier to build flexible and modular <span class="keep-together">systems</span>.</p><section id="working-with-first-class-modules" data-type="sect1"><h1>Working with First-Class Modules</h1><p>We'll start out by covering the basic mechanics of first-class
    modules by working through some toy examples. We'll get to more realistic
    examples in the next section.</p><p>In that light, consider the following signature of a module with a
    single integer variable:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module type X_int = sig val x : int end;;</code></strong>
<code class="computeroutput">module type X_int = sig val x : int end</code></pre><p>We can also create a module that matches this signature:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module Three : X_int = struct let x = 3 end;;</code></strong>
<code class="computeroutput">module Three : X_int</code>
<code class="prompt"># </code><strong><code>Three.x;;</code></strong>
<code class="computeroutput">- : int = 3</code></pre><p>A first-class module is created by packaging up a module with a
    signature that it satisfies. This is done using the <code>module</code> keyword, using the following
    syntax:<a data-type="indexterm" data-primary="module keyword"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/pack.syntax" class="orm:hideurl:ital"><em class="hyperlink">Syntax</em></a></p><pre data-type="programlisting">(module &lt;Module&gt; : &lt;Module_type&gt;)</pre><p>So, we can convert <code>Three</code> into a
    first-class module as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let three = (module Three : X_int);;</code></strong>
<code class="computeroutput">val three : (module X_int) = &lt;module&gt;</code></pre><p>The module type doesn't need to be part of the construction of a
    first-class module if it can be inferred. Thus, we can write:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module Four = struct let x = 4 end;;</code></strong>
<code class="computeroutput">module Four : sig val x : int end</code>
<code class="prompt"># </code><strong><code>let numbers = [ three; (module Four) ];;</code></strong>
<code class="computeroutput">val numbers : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]</code></pre><p>We can also create a first-class module from an anonymous
    module:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let numbers = [three; (module struct let x = 4 end)];;</code></strong>
<code class="computeroutput">val numbers : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]</code></pre><p>In order to access the contents of a first-class module, you need to
    unpack it into an ordinary module. This can be done using the <code>val</code> keyword, using this syntax:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/unpack.syntax" class="orm:hideurl:ital"><em class="hyperlink">Syntax</em></a></p><pre data-type="programlisting" data-code-language="ocaml">(val <em>&lt;first_class_module&gt;</em> : <em>&lt;Module_type&gt;</em>)</pre><p>And here's an example:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 5)<a data-type="indexterm" data-primary="first-class modules" data-secondary="type equality in"/></p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module New_three = (val three : X_int) ;;</code></strong>
<code class="computeroutput">module New_three : X_int</code>
<code class="prompt"># </code><strong><code>New_three.x;;</code></strong>
<code class="computeroutput">- : int = 3</code></pre><?hard-pagebreak?><aside data-type="sidebar"><h5>Equality of First-Class Module Types</h5><p>The type of the first-class module, e.g., <code>(module X_int)</code>, is based on the fully
      qualified name of the signature that was used to construct it. A
      first-class module based on a signature with a different name, even if
      it is substantively the same signature, will result in a distinct
      type:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 6)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module type Y_int = X_int;;</code></strong>
<code class="computeroutput">module type Y_int = X_int</code>
<code class="prompt"># </code><strong><code>let five = (module struct let x = 5 end : Y_int);;</code></strong>
<code class="computeroutput">val five : (module Y_int) = &lt;module&gt;</code>
<code class="prompt"># </code><strong><code>[three; five];;</code></strong>
<code class="computeroutput">Characters 8-12:</code>
<code class="computeroutput">Error: This expression has type (module Y_int)</code>
<code class="computeroutput">       but an expression was expected of type (module X_int)</code></pre><p>Even though their types as first-class modules are distinct, the
      underlying module types are compatible (indeed, identical), so we can
      unify the types by unpacking and repacking the module:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 7)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>[three; (module (val five))];;</code></strong>
<code class="computeroutput">- : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]</code></pre><p>The way in which type equality for first-class modules is determined can be confusing.
                One common and problematic case is that of creating an alias of a module type
                defined elsewhere. This is often done to improve readability and can happen both
                through an explicit declaration of a module type or implicitly through an <code>include</code> declaration. In both cases, this has the
                unintended side effect of making first-class modules built off the alias
                incompatible with those built off the original module type. To deal with this, we
                should be disciplined in how we refer to signatures when constructing first-class
                    <span class="keep-together">modules</span>.</p></aside><p>We can also write ordinary functions which consume and create
    first-class modules. The following shows the definition of two functions:
    <code>to_int</code>, which converts a <code>(module X_int)</code> into an <code>int</code>; and <code>plus</code>, which returns the sum of two <code>(module X_int)</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 8)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let to_int m =</code></strong>
<strong><code>    let module M = (val m : X_int) in</code></strong>
<strong><code>    M.x</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val to_int : (module X_int) -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>let plus m1 m2 =</code></strong>
<strong><code>    (module struct</code></strong>
<strong><code>       let x = to_int m1 + to_int m2</code></strong>
<strong><code>     end : X_int)</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val plus : (module X_int) -&gt; (module X_int) -&gt; (module X_int) = &lt;fun&gt;</code></pre><p>With these functions in hand, we can now work with values of type <code>(module X_int)</code> in a more natural style, taking advantage of the concision
            and simplicity of the core <span class="keep-together">language</span>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 9)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let six = plus three three;;</code></strong>
<code class="computeroutput">val six : (module X_int) = &lt;module&gt;</code>
<code class="prompt"># </code><strong><code>to_int (List.fold ~init:six ~f:plus [three;three]);;</code></strong>
<code class="computeroutput">- : int = 12</code></pre><p>There are some useful syntactic shortcuts when dealing with
    first-class modules. One notable one is that you can do the conversion to
    an ordinary module within a pattern match. Thus, we can rewrite the
    <code>to_int</code> function as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 10)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let to_int (module M : X_int) = M.x ;;</code></strong>
<code class="computeroutput">val to_int : (module X_int) -&gt; int = &lt;fun&gt;</code></pre><p>First-class modules can contain types and functions in addition to
    simple values like <code>int</code>. Here's an
    interface that contains a type and a corresponding <code>bump</code> operation that takes a value of the type
    and produces a new one:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 11)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module type Bumpable = sig</code></strong>
<strong><code>    type t</code></strong>
<strong><code>    val bump : t -&gt; t</code></strong>
<strong><code>  end;;</code></strong>
<code class="computeroutput">module type Bumpable = sig type t val bump : t -&gt; t end</code></pre><p>We can create multiple instances of this module with different
    underlying types:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 12)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module Int_bumper = struct</code></strong>
<strong><code>    type t = int</code></strong>
<strong><code>    let bump n = n + 1</code></strong>
<strong><code>  end;;</code></strong>
<code class="computeroutput">module Int_bumper : sig type t = int val bump : t -&gt; t end</code>
<code class="prompt"># </code><strong><code>module Float_bumper = struct</code></strong>
<strong><code>     type t = float</code></strong>
<strong><code>     let bump n = n +. 1.</code></strong>
<strong><code>  end;;</code></strong>
<code class="computeroutput">module Float_bumper : sig type t = float val bump : t -&gt; t end</code></pre><p>And we can convert these to first-class modules:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 13)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let int_bumper = (module Int_bumper : Bumpable);;</code></strong>
<code class="computeroutput">val int_bumper : (module Bumpable) = &lt;module&gt;</code></pre><p>But you can't do much with <code>int_bumper</code>, since <code>int_bumper</code> is fully abstract, so that we can no longer
            recover the fact that the type in question is <code>int</code>. </p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 14)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let (module Bumpable) = int_bumper in Bumpable.bump 3;;</code></strong>
<code class="computeroutput">Characters 52-53:</code>
<code class="computeroutput">Error: This expression has type int but an expression was expected of type</code>
<code class="computeroutput">         Bumpable.t</code></pre><p>To make <code>int_bumper</code> usable, we
    need to expose the type, which we can do as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 15)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let int_bumper = (module Int_bumper : Bumpable with type t = int);;</code></strong>
<code class="computeroutput">val int_bumper : (module Bumpable with type t = int) = &lt;module&gt;</code>
<code class="prompt"># </code><strong><code>let float_bumper = (module Float_bumper : Bumpable with type t = float);;</code></strong>
<code class="computeroutput">val float_bumper : (module Bumpable with type t = float) = &lt;module&gt;</code></pre><p>The sharing constraints we've added above make the resulting
    first-class modules <span class="keep-together">polymorphic</span> in
    the type <code>t</code>. As a result, we can now use
    these values on values of the matching type:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 16)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let (module Bumpable) = int_bumper in Bumpable.bump 3;;</code></strong>
<code class="computeroutput">- : int = 4</code>
<code class="prompt"># </code><strong><code>let (module Bumpable) = float_bumper in Bumpable.bump 3.5;;</code></strong>
<code class="computeroutput">- : float = 4.5</code></pre><p>We can also write functions that use such first-class modules
    polymorphically. The following function takes two arguments: a <code>Bumpable</code> module and a list of elements of the
    same type as the type <code>t</code> of the
    module:<a data-type="indexterm" data-primary="polymorphism" data-secondary="in first-class modules"/><a data-type="indexterm" data-primary="first-class modules" data-secondary="polymorphism in"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 17)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let bump_list</code></strong>
<strong><code>       (type a)</code></strong>
<strong><code>       (module B : Bumpable with type t = a)</code></strong>
<strong><code>       (l: a list)</code></strong>
<strong><code>    =</code></strong>
<strong><code>    List.map ~f:B.bump l</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val bump_list : (module Bumpable with type t = 'a) -&gt; 'a list -&gt; 'a list =</code>
<code class="computeroutput">  &lt;fun&gt;</code></pre><p>Here, we used a feature of OCaml that hasn't come up before: a <em>locally abstract
                type</em>. For any function, you can declare a pseudoparameter of the form
                <code>(type a)</code> for any type name <code>a</code> which introduces a fresh type. This type acts like an
            abstract type within the context of the function. In the example above, the locally
            abstract type was used as part of a sharing constraint that ties the type <code>B.t</code> with the type of the elements of the list passed
                in.<a data-type="indexterm" data-primary="datatypes" data-secondary="locally abstract types"/><a data-type="indexterm" data-primary="abstract types"/><a data-type="indexterm" data-primary="locally abstract types"/></p><p>The resulting function is polymorphic in both the type of the list
    element and the type <code>Bumpable.t</code>. We can
    see this function in action:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 18)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>bump_list int_bumper [1;2;3];;</code></strong>
<code class="computeroutput">- : int list = [2; 3; 4]</code>
<code class="prompt"># </code><strong><code>bump_list float_bumper [1.5;2.5;3.5];;</code></strong>
<code class="computeroutput">- : float list = [2.5; 3.5; 4.5]</code></pre><p>Polymorphic first-class modules are important because they allow you
    to connect the types associated with a first-class module to the types of
    other values you're working with.</p><div data-type="note"><h1>More on Locally Abstract Types</h1><p>One of the key properties of locally abstract types is that
      they're dealt with as abstract types in the function they're defined
      within, but are polymorphic from the outside. Consider the following
      example:<a data-type="indexterm" data-primary="polymorphism" data-secondary="in locally abstract types"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 19)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let wrap_in_list (type a) (x:a) = [x];;</code></strong>
<code class="computeroutput">val wrap_in_list : 'a -&gt; 'a list = &lt;fun&gt;</code></pre><p>This compiles successfully because the type <code>a</code> is used in a way that is compatible with it
      being abstract, but the type of the function that is inferred is
      polymorphic.</p><p>If, on the other hand, we try to use the type <code>a</code> as equivalent to some concrete type, say,
      <code>int</code>, then the compiler will
      complain:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 20)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let double_int (type a) (x:a) = x + x;;</code></strong>
<code class="computeroutput">Characters 38-39:</code>
<code class="computeroutput">Error: This expression has type a but an expression was expected of type int</code></pre><p>One common use of locally abstract types is to create a new type
      that can be used in constructing a module. Here's an example of doing
      this to create a new first-class module:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 21)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module type Comparable = sig</code></strong>
<strong><code>    type t</code></strong>
<strong><code>    val compare : t -&gt; t -&gt; int</code></strong>
<strong><code>  end ;;</code></strong>
<code class="computeroutput">module type Comparable = sig type t val compare : t -&gt; t -&gt; int end</code>
<code class="prompt"># </code><strong><code>let create_comparable (type a) compare =</code></strong>
<strong><code>    (module struct</code></strong>
<strong><code>       type t = a</code></strong>
<strong><code>       let compare = compare</code></strong>
<strong><code>     end : Comparable with type t = a)</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val create_comparable :</code>
<code class="computeroutput">  ('a -&gt; 'a -&gt; int) -&gt; (module Comparable with type t = 'a) = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>create_comparable Int.compare;;</code></strong>
<code class="computeroutput">- : (module Comparable with type t = int) = &lt;module&gt;</code>
<code class="prompt"># </code><strong><code>create_comparable Float.compare;;</code></strong>
<code class="computeroutput">- : (module Comparable with type t = float) = &lt;module&gt;</code></pre><p>Here, what we effectively do is capture a polymorphic type and
      export it as a concrete type within a module.</p><p>This technique is useful beyond first-class modules. For example,
      we can use the same approach to construct a local module to be fed to a
      functor.<a data-type="indexterm" data-startref="FCMwork"/></p></div></section><section id="example-a-query-handling-framework" data-type="sect1"><h1>Example: A Query-Handling Framework</h1><p>Now let's look at first-class modules in the context of a more complete and realistic
            example. In particular, consider the following signature for a module that implements a
            system for responding to user-generated queries.<a data-type="indexterm" data-primary="query-handlers" data-secondary="and first-class modules"/><a data-type="indexterm" id="FCMquery" data-primary="first-class modules" data-secondary="query-handling framework"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module type Query_handler = sig</code></strong>
<strong><code/></strong>
<strong><code>    (** Configuration for a query handler.  Note that this can be
         converted to and from an s-expression *)</code></strong>
<strong><code>    type config with sexp</code></strong>
<strong><code/></strong>
<strong><code>    (** The name of the query-handling service *)</code></strong>
<strong><code>    val name : string</code></strong>
<strong><code/></strong>
<strong><code>    (** The state of the query handler *)</code></strong>
<strong><code>    type t</code></strong>
<strong><code/></strong>
<strong><code>    (** Creates a new query handler from a config *)</code></strong>
<strong><code>    val create : config -&gt; t</code></strong>
<strong><code/></strong>
<strong><code>    (** Evaluate a given query, where both input and output are
         s-expressions *)</code></strong>
<strong><code>    val eval : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t</code></strong>
<strong><code>  end;;</code></strong>
<code class="computeroutput">module type Query_handler =</code>
<code class="computeroutput">  sig</code>
<code class="computeroutput">    type config</code>
<code class="computeroutput">    val name : string</code>
<code class="computeroutput">    type t</code>
<code class="computeroutput">    val create : config -&gt; t</code>
<code class="computeroutput">    val eval : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t</code>
<code class="computeroutput">    val config_of_sexp : Sexp.t -&gt; config</code>
<code class="computeroutput">    val sexp_of_config : config -&gt; Sexp.t</code>
<code class="computeroutput">  end</code></pre><p>Here, we used s-expressions as the format for queries and responses, as well as the
            configuration for the query handler. S-expressions are a simple, flexible, and
            human-readable serialization format commonly used in Core. For now, it's enough to think
            of them as balanced parenthetical expressions whose atomic values are strings, e.g.,
                <code>(this (is an) (s expression))</code>.<a data-type="indexterm" data-primary="s-expressions" data-secondary="in queries and responses"/></p><p>In addition, we use the Sexplib syntax extension which extends OCaml
    by adding the <code>with sexp</code> declaration.
    When attached to a type in a signature, <code>with
    sexp</code> adds declarations of s-expression converters, for
    example:<a data-type="indexterm" data-primary="sexp declaration"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module type M = sig type t with sexp end;;</code></strong>
<code class="computeroutput">module type M =</code>
<code class="computeroutput">  sig type t val t_of_sexp : Sexp.t -&gt; t val sexp_of_t : t -&gt; Sexp.t end</code></pre><p>In a module, <code>with sexp</code> adds the
    implementation of those functions. Thus, we can write:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>type u = { a: int; b: float } with sexp;;</code></strong>
<code class="computeroutput">type u = { a : int; b : float; }</code>
<code class="computeroutput">val u_of_sexp : Sexp.t -&gt; u = &lt;fun&gt;</code>
<code class="computeroutput">val sexp_of_u : u -&gt; Sexp.t = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>sexp_of_u {a=3;b=7.};;</code></strong>
<code class="computeroutput">- : Sexp.t = ((a 3) (b 7))</code>
<code class="prompt"># </code><strong><code>u_of_sexp (Sexp.of_string "((a 43) (b 3.4))");;</code></strong>
<code class="computeroutput">- : u = {a = 43; b = 3.4}</code></pre><p>This is all described in more detail in <a href="#data-serialization-with-s-expressions" data-type="xref"/>.</p><section id="implementing-a-query-handler" data-type="sect2"><h2>Implementing a Query Handler</h2><p>Let's look at some examples of query handlers that satisfy the
      <code>Query_handler</code> interface. The first
      example is a handler that produces unique integer IDs. It works by
      keeping an internal counter which it bumps every time it produces a new
      value. The input to the query in this case is just the trivial
      s-expression <code>()</code>, otherwise known as
      <code>Sexp.unit</code>:<a data-type="indexterm" data-primary="query-handlers" data-secondary="implementation of"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module Unique = struct</code></strong>
<strong><code>    type config = int with sexp</code></strong>
<strong><code>    type t = { mutable next_id: int }</code></strong>
<strong><code/></strong>
<strong><code>    let name = "unique"</code></strong>
<strong><code>    let create start_at = { next_id = start_at }</code></strong>
<strong><code/></strong>
<strong><code>    let eval t sexp =</code></strong>
<strong><code>      match Or_error.try_with (fun () -&gt; unit_of_sexp sexp) with</code></strong>
<strong><code>      | Error _ as err -&gt; err</code></strong>
<strong><code>      | Ok () -&gt;</code></strong>
<strong><code>        let response = Ok (Int.sexp_of_t t.next_id) in</code></strong>
<strong><code>        t.next_id &lt;- t.next_id + 1;</code></strong>
<strong><code>        response</code></strong>
<strong><code>  end;;</code></strong>
<code class="computeroutput">module Unique :</code>
<code class="computeroutput">  sig</code>
<code class="computeroutput">    type config = int</code>
<code class="computeroutput">    val config_of_sexp : Sexp.t -&gt; config</code>
<code class="computeroutput">    val sexp_of_config : config -&gt; Sexp.t</code>
<code class="computeroutput">    type t = { mutable next_id : config; }</code>
<code class="computeroutput">    val name : string</code>
<code class="computeroutput">    val create : config -&gt; t</code>
<code class="computeroutput">    val eval : t -&gt; Sexp.t -&gt; (Sexp.t, Error.t) Result.t</code>
<code class="computeroutput">  end</code></pre><p>We can use this module to create an instance of the <code>Unique</code> query handler and interact with it
      directly:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let unique = Unique.create 0;;</code></strong>
<code class="computeroutput">val unique : Unique.t = {Unique.next_id = 0}</code>
<code class="prompt"># </code><strong><code>Unique.eval unique Sexp.unit;;</code></strong>
<code class="computeroutput">- : (Sexp.t, Error.t) Result.t = Ok 0</code>
<code class="prompt"># </code><strong><code>Unique.eval unique Sexp.unit;;</code></strong>
<code class="computeroutput">- : (Sexp.t, Error.t) Result.t = Ok 1</code></pre><p>Here's another example: a query handler that does directory
      listings. Here, the config is the default directory that relative paths
      are interpreted within:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 5)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module List_dir = struct</code></strong>
<strong><code>    type config = string with sexp</code></strong>
<strong><code>    type t = { cwd: string }</code></strong>
<strong><code/></strong>
<strong><code>    (** [is_abs p] Returns true if [p] is an absolute path  *)</code></strong>
<strong><code>    let is_abs p =</code></strong>
<strong><code>      String.length p &gt; 0 &amp;&amp; p.[0] = '/'</code></strong>
<strong><code/></strong>
<strong><code>    let name = "ls"</code></strong>
<strong><code>    let create cwd = { cwd }</code></strong>
<strong><code/></strong>
<strong><code>    let eval t sexp =</code></strong>
<strong><code>      match Or_error.try_with (fun () -&gt; string_of_sexp sexp) with</code></strong>
<strong><code>      | Error _ as err -&gt; err</code></strong>
<strong><code>      | Ok dir -&gt;</code></strong>
<strong><code>        let dir =</code></strong>
<strong><code>          if is_abs dir then dir</code></strong>
<strong><code>          else Filename.concat t.cwd dir</code></strong>
<strong><code>        in</code></strong>
<strong><code>        Ok (Array.sexp_of_t String.sexp_of_t (Sys.readdir dir))</code></strong>
<strong><code>  end;;</code></strong>
<code class="computeroutput">module List_dir :</code>
<code class="computeroutput">  sig</code>
<code class="computeroutput">    type config = string</code>
<code class="computeroutput">    val config_of_sexp : Sexp.t -&gt; config</code>
<code class="computeroutput">    val sexp_of_config : config -&gt; Sexp.t</code>
<code class="computeroutput">    type t = { cwd : config; }</code>
<code class="computeroutput">    val is_abs : config -&gt; bool</code>
<code class="computeroutput">    val name : config</code>
<code class="computeroutput">    val create : config -&gt; t</code>
<code class="computeroutput">    val eval : t -&gt; Sexp.t -&gt; (Sexp.t, Error.t) Result.t</code>
<code class="computeroutput">  end</code></pre><p>Again, we can create an instance of this query handler and
      interact with it directly:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 6)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let list_dir = List_dir.create "/var";;</code></strong>
<code class="computeroutput">val list_dir : List_dir.t = {List_dir.cwd = "/var"}</code>
<code class="prompt"># </code><strong><code>List_dir.eval list_dir (sexp_of_string ".");;</code></strong>
<code class="computeroutput">- : (Sexp.t, Error.t) Result.t =</code>
<code class="computeroutput">Ok (lib mail cache www spool run log lock opt local backups tmp)</code>
<code class="prompt"># </code><strong><code>List_dir.eval list_dir (sexp_of_string "yp");;</code></strong>
<code class="computeroutput">Exception: (Sys_error "/var/yp: No such file or directory").</code></pre></section><section id="dispatching-to-multiple-query-handlers" data-type="sect2"><h2>Dispatching to Multiple Query Handlers</h2><p>Now, what if we want to dispatch queries to any of an arbitrary
      collection of handlers? Ideally, we'd just like to pass in the handlers
      as a simple data structure like a list. This is awkward to do with
      modules and functors alone, but it's quite natural with first-class
      modules. The first thing we'll need to do is create a signature that
      combines a <code>Query_handler</code> module with
      an instantiated query handler:<a data-type="indexterm" data-primary="query-handlers" data-secondary="dispatching to multiple"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 7)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module type Query_handler_instance = sig</code></strong>
<strong><code>    module Query_handler : Query_handler</code></strong>
<strong><code>    val this : Query_handler.t</code></strong>
<strong><code>  end;;</code></strong>
<code class="computeroutput">module type Query_handler_instance =</code>
<code class="computeroutput">  sig module Query_handler : Query_handler val this : Query_handler.t end</code></pre><p>With this signature, we can create a first-class module that
      encompasses both an instance of the query and the matching operations
      for working with that query.</p><p>We can create an instance as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 8)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let unique_instance =</code></strong>
<strong><code>    (module struct</code></strong>
<strong><code>       module Query_handler = Unique</code></strong>
<strong><code>       let this = Unique.create 0</code></strong>
<strong><code>     end : Query_handler_instance);;</code></strong>
<code class="computeroutput">val unique_instance : (module Query_handler_instance) = &lt;module&gt;</code></pre><p>Constructing instances in this way is a little verbose, but we can
      write a function that eliminates most of this boilerplate. Note that we
      are again making use of a locally abstract type:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 9)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let build_instance</code></strong>
<strong><code>        (type a)</code></strong>
<strong><code>        (module Q : Query_handler with type config = a)</code></strong>
<strong><code>        config</code></strong>
<strong><code>    =</code></strong>
<strong><code>    (module struct</code></strong>
<strong><code>       module Query_handler = Q</code></strong>
<strong><code>       let this = Q.create config</code></strong>
<strong><code>     end : Query_handler_instance)</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val build_instance :</code>
<code class="computeroutput">  (module Query_handler with type config = 'a) -&gt;</code>
<code class="computeroutput">  'a -&gt; (module Query_handler_instance) = &lt;fun&gt;</code></pre><p>Using <code>build_instance</code>,
      constructing a new instance becomes a one-liner:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 10)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let unique_instance = build_instance (module Unique) 0;;</code></strong>
<code class="computeroutput">val unique_instance : (module Query_handler_instance) = &lt;module&gt;</code>
<code class="prompt"># </code><strong><code>let list_dir_instance = build_instance (module List_dir)  "/var";;</code></strong>
<code class="computeroutput">val list_dir_instance : (module Query_handler_instance) = &lt;module&gt;</code></pre><p>We can now write code that lets you dispatch queries to one of a
      list of query handler instances. We assume that the shape of the query
      is as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query-syntax" class="orm:hideurl:ital"><em class="hyperlink">Scheme</em></a></p><pre data-type="programlisting" data-code-language="scheme">(<em>query-name query</em>)</pre><p>where <em><code>query-name</code></em> is the name used to
      determine which query handler to dispatch the query to, and
      <em><code>query</code></em> is the
      body of the query.</p><p>The first thing we'll need is a function that takes a list of
      query handler instances and constructs a dispatch table from it:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 11)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let build_dispatch_table handlers =</code></strong>
<strong><code>    let table = String.Table.create () in</code></strong>
<strong><code>    List.iter handlers</code></strong>
<strong><code>      ~f:(fun ((module I : Query_handler_instance) as instance) -&gt;</code></strong>
<strong><code>        Hashtbl.replace table ~key:I.Query_handler.name ~data:instance);</code></strong>
<strong><code>    table</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val build_dispatch_table :</code>
<code class="computeroutput">  (module Query_handler_instance) list -&gt;</code>
<code class="computeroutput">  (module Query_handler_instance) String.Table.t = &lt;fun&gt;</code></pre><p>Now, we need a function that dispatches to a handler using a
      dispatch table:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 12)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let dispatch dispatch_table name_and_query =</code></strong>
<strong><code>    match name_and_query with</code></strong>
<strong><code>    | Sexp.List [Sexp.Atom name; query] -&gt;</code></strong>
<strong><code>      begin match Hashtbl.find dispatch_table name with</code></strong>
<strong><code>      | None -&gt;</code></strong>
<strong><code>        Or_error.error "Could not find matching handler"</code></strong>
<strong><code>          name String.sexp_of_t</code></strong>
<strong><code>      | Some (module I : Query_handler_instance) -&gt;</code></strong>
<strong><code>        I.Query_handler.eval I.this query</code></strong>
<strong><code>      end</code></strong>
<strong><code>    | _ -&gt;</code></strong>
<strong><code>      Or_error.error_string "malformed query"</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val dispatch :</code>
<code class="computeroutput">  (string, (module Query_handler_instance)) Hashtbl.t -&gt;</code>
<code class="computeroutput">  Sexp.t -&gt; Sexp.t Or_error.t = &lt;fun&gt;</code></pre><p>This function interacts with an instance by unpacking it into a
      module <code>I</code> and then using the query
      handler instance (<code>I.this</code>) in concert
      with the associated module (<code>I.Query_handler</code>).<a data-type="indexterm" data-primary="I.Query_handler module"/></p><p>The bundling together of the module and the value is in many ways
      reminiscent of object-oriented languages. One key difference, is that
      first-class modules allow you to package up more than just functions or
      methods. As we've seen, you can also include types and even modules.
      We've only used it in a small way here, but this extra power allows you
      to build more sophisticated components that involve multiple
      interdependent types and values.</p><p>Now let's turn this into a complete, running example by adding a
      command-line interface:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 13)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let rec cli dispatch_table =</code></strong>
<strong><code>    printf "&gt;&gt;&gt; %!";</code></strong>
<strong><code>    let result =</code></strong>
<strong><code>      match In_channel.input_line stdin with</code></strong>
<strong><code>      | None -&gt; `Stop</code></strong>
<strong><code>      | Some line -&gt;</code></strong>
<strong><code>        match Or_error.try_with (fun () -&gt; Sexp.of_string line) with</code></strong>
<strong><code>        | Error e -&gt; `Continue (Error.to_string_hum e)</code></strong>
<strong><code>        | Ok (Sexp.Atom "quit") -&gt; `Stop</code></strong>
<strong><code>        | Ok query -&gt;</code></strong>
<strong><code>          begin match dispatch dispatch_table query with</code></strong>
<strong><code>          | Error e -&gt; `Continue (Error.to_string_hum e)</code></strong>
<strong><code>          | Ok s    -&gt; `Continue (Sexp.to_string_hum s)</code></strong>
<strong><code>          end;</code></strong>
<strong><code>    in</code></strong>
<strong><code>    match result with</code></strong>
<strong><code>    | `Stop -&gt; ()</code></strong>
<strong><code>    | `Continue msg -&gt;</code></strong>
<strong><code>      printf "%s\n%!" msg;</code></strong>
<strong><code>      cli dispatch_table</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val cli : (string, (module Query_handler_instance)) Hashtbl.t -&gt; unit = &lt;fun&gt;</code></pre><p>We can most effectively run this command-line interface from a
      standalone program, which we can do by putting the above code in a file
      along with following command to launch the interface:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">let () =
  cli (build_dispatch_table [unique_instance; list_dir_instance])</pre><p>Here's an example of a session with this program:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_example.rawscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><code class="computeroutput">$ ./query_handler.byte 
&gt;&gt;&gt; (unique ())
0
&gt;&gt;&gt; (unique ())
1
&gt;&gt;&gt; (ls .)
(agentx at audit backups db empty folders jabberd lib log mail msgs named
 netboot pgsql_socket_alt root rpc run rwho spool tmp vm yp)
&gt;&gt;&gt; (ls vm)
(sleepimage swapfile0 swapfile1 swapfile2 swapfile3 swapfile4 swapfile5
 swapfile6)</code>
</pre></section><section id="loading-and-unloading-query-handlers" data-type="sect2"><h2>Loading and Unloading Query Handlers</h2><p>One of the advantages of first-class modules is that they afford a
      great deal of dynamism and flexibility. For example, it's a fairly
      simple matter to change our design to allow query handlers to be loaded
      and unloaded at runtime.<a data-type="indexterm" data-primary="query-handlers" data-secondary="loading/unloading of"/></p><p>We'll do this by creating a query handler whose job is to control
      the set of active query handlers. The module in question will be called
      <code>Loader</code>, and its configuration is a
      list of known <code>Query_handler</code> modules.
      Here are the basic types:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">module Loader = struct
  type config = (module Query_handler) list sexp_opaque
  with sexp

  type t = { known  : (module Query_handler)          String.Table.t
           ; active : (module Query_handler_instance) String.Table.t
           }

  let name = "loader"</pre><p>Note that a <code>Loader.t</code> has two
      tables: one containing the known query handler modules, and one
      containing the active query handler instances. The <code>Loader.t</code> will be responsible for creating new
      instances and adding them to the table, as well as for removing
      instances, all in response to user queries.</p><p>Next, we'll need a function for creating a <code>Loader.t</code>. This function requires the list of
      known query handler modules. Note that the table of active modules
      starts out as empty:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml">let create known_list =
    let active = String.Table.create () in
    let known  = String.Table.create () in
    List.iter known_list
      ~f:(fun ((module Q : Query_handler) as q) -&gt;
        Hashtbl.replace known ~key:Q.name ~data:q);
    { known; active }</pre><p>Now we'll start writing out the functions for manipulating the
      table of active query handlers. We'll start with the function for
      loading an instance. Note that it takes as an argument both the name of
      the query handler and the configuration for instantiating that handler
      in the form of an s-expression. These are used for creating a
      first-class module of type <code>(module
      Query_handler_instance)</code>, which is then added to the active
      table:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml">let load t handler_name config =
    if Hashtbl.mem t.active handler_name then
      Or_error.error "Can't re-register an active handler"
        handler_name String.sexp_of_t
    else
      match Hashtbl.find t.known handler_name with
      | None -&gt;
        Or_error.error "Unknown handler" handler_name String.sexp_of_t
      | Some (module Q : Query_handler) -&gt;
        let instance =
          (module struct
             module Query_handler = Q
             let this = Q.create (Q.config_of_sexp config)
           end : Query_handler_instance)
        in
        Hashtbl.replace t.active ~key:handler_name ~data:instance;
        Ok Sexp.unit</pre><p>Since the <code>load</code> function will
      refuse to <code>load</code> an already active
      handler, we also need the ability to unload a handler. Note that the
      handler explicitly refuses to unload itself:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 4)</p><pre data-type="programlisting" data-code-language="ocaml">let unload t handler_name =
    if not (Hashtbl.mem t.active handler_name) then
      Or_error.error "Handler not active" handler_name String.sexp_of_t
    else if handler_name = name then
      Or_error.error_string "It's unwise to unload yourself"
    else (
      Hashtbl.remove t.active handler_name;
      Ok Sexp.unit
    )</pre><p>Finally, we need to implement the <code>eval</code> function,
                which will determine the query <span class="keep-together">interface</span>
                presented to the user. We'll do this by creating a variant type, and using the
                s-expression converter generated for that type to parse the query from the
                user:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 5)</p><pre data-type="programlisting" data-code-language="ocaml">type request =
    | Load of string * Sexp.t
    | Unload of string
    | Known_services
    | Active_services
  with sexp</pre><p>The <code>eval</code> function itself is fairly straightforward, dispatching to
                the appropriate functions to respond to each type of query. Note that we write
                    <code>&lt;:sexp_of&lt;string list&gt;&gt;</code> to
                autogenerate a function for converting a list of strings to an s-expression, as
                described in <a href="#data-serialization-with-s-expressions" data-type="xref"/>.</p><p>This function ends the definition of the <code>Loader</code> module:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 6)</p><pre data-type="programlisting" data-code-language="ocaml">let eval t sexp =
    match Or_error.try_with (fun () -&gt; request_of_sexp sexp) with
    | Error _ as err -&gt; err
    | Ok resp -&gt;
      match resp with
      | Load (name,config) -&gt; load   t name config
      | Unload name        -&gt; unload t name
      | Known_services -&gt;
        Ok (&lt;:sexp_of&lt;string list&gt;&gt; (Hashtbl.keys t.known))
      | Active_services -&gt;
        Ok (&lt;:sexp_of&lt;string list&gt;&gt; (Hashtbl.keys t.active))
end</pre><p>Finally, we can put this all together with the command-line
      interface. We first create an instance of the loader query handler and
      then add that instance to the loader's active table. We can then just
      launch the command-line interface, passing it the active table:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_loader.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">let () =
  let loader = Loader.create [(module Unique); (module List_dir)] in
  let loader_instance =
    (module struct
       module Query_handler = Loader
       let this = loader
     end : Query_handler_instance)
  in
  Hashtbl.replace loader.Loader.active
    ~key:Loader.name ~data:loader_instance;
  cli loader.Loader.active</pre><p>Now build this into a command-line interface to experiment with it:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/build_query_handler_loader.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>corebuild query_handler_loader.byte</code></strong>
</pre><p>The resulting command-line interface behaves much as you'd expect,
      starting out with no query handlers available but giving you the ability
      to load and unload them. Here's an example of it in action. As you can
      see, we start out with <code>loader</code> itself
      as the only active handler:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/loader_cli1.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>./query_handler_loader.byte</code></strong>
<code class="computeroutput">&gt;&gt;&gt; (loader known_services)</code>
<code class="computeroutput">(ls unique)</code>
<code class="computeroutput">&gt;&gt;&gt; (loader active_services)</code>
<code class="computeroutput">(loader)</code></pre><p>Any attempt to use an inactive query handler will fail:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/loader_cli2.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="computeroutput">&gt;&gt;&gt; (ls .)</code>
<code class="computeroutput">Could not find matching handler: ls</code></pre><p>But, we can load the <code>ls</code> handler
      with a config of our choice, at which point it will be available for
      use. And once we unload it, it will be unavailable yet again and could
      be reloaded with a different config:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/loader_cli3.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="computeroutput">&gt;&gt;&gt; (loader (load ls /var))</code>
<code class="computeroutput">()</code>
<code class="computeroutput">&gt;&gt;&gt; (ls /var)</code>
<code class="computeroutput">(agentx at audit backups db empty folders jabberd lib log mail msgs named</code>
<code class="computeroutput"> netboot pgsql_socket_alt root rpc run rwho spool tmp vm yp)</code>
<code class="computeroutput">&gt;&gt;&gt; (loader (unload ls))</code>
<code class="computeroutput">()</code>
<code class="computeroutput">&gt;&gt;&gt; (ls /var)</code>
<code class="computeroutput">Could not find matching handler: ls</code></pre><p>Notably, the loader can't be loaded (since it's not on the list of
      known handlers) and can't be unloaded either:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/loader_cli4.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="computeroutput">&gt;&gt;&gt; (loader (unload loader))</code>
<code class="computeroutput">It's unwise to unload yourself</code></pre><p>Although we won't describe the details here, we can push this dynamism yet further
                using OCaml's dynamic linking facilities, which allow you to compile and link in new
                code to a running program. This can be automated using libraries like
                    <code>ocaml_plugin</code>, which can be installed via OPAM, and which
                automates much of the workflow around setting up dynamic linking. <a data-type="indexterm" data-startref="FCMquery"/> </p></section></section><section id="living-without-first-class-modules" data-type="sect1"><h1>Living Without First-Class Modules</h1><p>It's worth noting that most designs that can be done with
    first-class modules can be simulated without them, with some level of
    awkwardness. For example, we could rewrite our query handler example
    without first-class modules using the following types:<a data-type="indexterm" data-primary="first-class modules" data-secondary="alternatives to"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 14)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>type query_handler_instance = { name : string</code></strong>
<strong><code>                                ; eval : Sexp.t -&gt; Sexp.t Or_error.t</code></strong>
<strong><code>                                }</code></strong>
<strong><code>  type query_handler = Sexp.t -&gt; query_handler_instance</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">type query_handler_instance = {</code>
<code class="computeroutput">  name : string;</code>
<code class="computeroutput">  eval : Sexp.t -&gt; Sexp.t Or_error.t;</code>
<code class="computeroutput">}</code>
<code class="computeroutput">type query_handler = Sexp.t -&gt; query_handler_instance</code></pre><p>The idea here is that we hide the true types of the objects in
    question behind the functions stored in the closure. Thus, we could put
    the <code>Unique</code> query handler into this
    framework as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 15)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let unique_handler config_sexp =</code></strong>
<strong><code>    let config = Unique.config_of_sexp config_sexp in</code></strong>
<strong><code>    let unique = Unique.create config in</code></strong>
<strong><code>    { name = Unique.name</code></strong>
<strong><code>    ; eval = (fun config -&gt; Unique.eval unique config)</code></strong>
<strong><code>    }</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val unique_handler : Sexp.t -&gt; query_handler_instance = &lt;fun&gt;</code></pre><p>For an example on this scale, the preceding approach is completely
    reasonable, and first-class modules are not really necessary. But the more
    functionality you need to hide away behind a set of closures, and the more
    complicated the relationships between the different types in question, the
    more awkward this approach becomes, and the better it is to use
    first-class modules.<a data-type="indexterm" data-startref="MODfirst"/></p></section></section>