%
%
%

\labelchapter{modules}{The OCaml Module System}

\index{modules}
As we saw in the previous chapter, programs can be divided into parts
that can be implemented in files, and each file can be given an
interface that specifies what its public types and values are. Files
are not the only way to partition a program, OCaml also provides
a \emph{module system} that allows programs to be partitioned even
within a single file. There are three key parts in the module
system: \emph{signatures}, \emph{structures}, and \emph{functors},
where signatures correspond to interfaces, structures correspond to
implementations, and functors are functions over structures. In this
chapter, we will discuss the first two; we'll leave discussion of
functors to Chapter~\reflabelchapter{functors}.

There are several reasons for using the module system. Perhaps the
simplest reason is that each structure has its own namespace, so name
conflicts are less likely when modules are used.  Another reason is
that abstraction can be specified explicitly within a file by
assigning a signature to a structure.  Let's begin with naming.

\labelsection{structures}{Structures and signatures}

\label{keyword:module}
\label{keyword:struct}
\index{structures}
\index{module|see{modules}@\lstinline$module$}
\index{struct@\lstinline$struct$}
Named structures are defined with the \lstinline{module} and
\lstinline{struct} keywords using the following syntax.

\begin{ocaml}
module $\nt{ModuleName}$ = struct $\nt{implementation}$ end
\end{ocaml}
%
\index{identifiers!module}
The module name \nt{ModuleName} must begin with an uppercase
letter.  The \nt{implementation} can include any definition
that might occur in a \hbox{\lstinline/.ml/} file.

In the discussion of records (page~\pageref{section:record-labels}), we
noted that the space of record label names is flat; if two record
types are defined with the same label names in the same file, the
first definition is lost.  Modules solve this problem by allowing the
name space to be partitioned.  Here is an example using records; the
same principle applies to unions and constructor names.

\begin{ocaml}
module A = struct
    type t = { name : string; phone : string }
end
module B = struct
    type t = { name : string; salary : float }
end
# let jason = { A.name = "Jason"; A.phone = "626-555-1212" };;
@
\begin{topoutput}
val jason : A.t = {A.name = "Jason"; A.phone = "626-555-1212"}
\end{topoutput}
@
# let bob = { B.name = "Bob"; B.salary = 180.0 };;
@
\begin{topoutput}
val bob : B.t = {B.name = "Bob"; B.salary = 180.}
\end{topoutput}
@
\end{ocaml}
%
\index{fully-qualified names}
A simple \emph{pathname}, or \emph{fully-qualified} name, has the
syntax \nt{ModuleName}.\nt{identifier}, where the \nt{identifier} is
the name of a module component (a type, value, record label, a nested
module, etc.), and the \nt{ModuleName} is the module containing the
component.  In the example, the pathname \hbox{\lstinline$B.salary$}
is the fully-qualified name of a field in the \hbox{\lstinline$B.t$}
record type (which is also a fully-qualified name).

Let's return to the \hbox{\lstinline/unique.ml/} example from the
previous chapter, using a simple list-based implementation of
sets. This time, instead of defining the set data structure in a
separate file, let's define it as a module,
called \hbox{\lstinline/Set/}, using an explicit module
definition. The program is shown in Figure~\reffigure{xmset1}.  The
file is compiled and executed using the usual methods.

\begin{figure}
\begin{center}
\begin{tabular}[t]{l}
File: unique.ml\\
\hline
\begin{ocamllisting}
module Set = struct
   let empty = []
   let add x l = x :: l
   let mem x l = List.mem x l
end;;

let rec unique already_read =
   output_string stdout "> ";
   flush stdout;
   let line = input_line stdin in
      if not (Set.mem line already_read) then begin
         output_string stdout line;
         output_char stdout '\n';
         unique (Set.add line already_read)
      end else
         unique already_read;;

(* Main program *)
try unique Set.empty with
   End_of_file ->
      ();;
\end{ocamllisting}
\end{tabular}
\end{center}
\caption{Gathering the \hbox{\lstinline$Set$} implementation into a module.}
\labelfigure{xmset1}
\end{figure}

\begin{ocaml}
% ocamlc -o unique unique.ml
% ./unique
> Adam Bede
@
\begin{topoutput}
Adam Bede
\end{topoutput}
@
> A passage to India
@
\begin{topoutput}
A Passage to India
\end{topoutput}
@
> Adam Bede
> Moby Dick
@
\begin{topoutput}
Moby Dick
\end{topoutput}
@
\end{ocaml}
%
In this new program, the main role of the
module \hbox{\lstinline/Set/} is to collect the set functions into a
single block of code that has an explicit name. The values are now
named using the module name as a prefix,
as \hbox{\lstinline/Set.empty/}, \hbox{\lstinline/Set.add/},
and \hbox{\lstinline/Set.mem/}. Otherwise, the program is as before.

\label{keyword:sig}
\index{signatures}
\index{abstraction!for modules}
In many ways, structures are like files.  If we wish to hide
the \hbox{\lstinline$Set$} implementation, we can specify an explicit
signature to hide parts of the implementation.  A named signature is
defined with a \hbox{\lstinline/module type/} definition.

\begin{ocaml}
module type $\nt{ModuleName}$ = sig $\nt{signature}$ end
\end{ocaml}
%
The name of the signature must begin with an uppercase letter. The
signature can contain any of the items that can occur in an
interface \hbox{\lstinline/.mli/} file. For our example, the signature
should include an abstract type declaration for
the \hbox{\lstinline/'a set/} type and \hbox{\lstinline/val/}
declarations for each of the values. The \hbox{\lstinline/Set/}
module's signature is constrained by specifying the signature after a
colon in the module definition
%
\hbox{\lstinline/module Set : SetSig = struct $\cdots$ end/},
%
as shown in Figure \reffigure{xmset2}.

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{tabular}[t]{l}
Signature definition\\
\hline
\begin{ocamllisting}
module type SetSig = sig
   type 'a set
   val empty : 'a set
   val add : 'a -> 'a set -> 'a set
   val mem : 'a -> 'a set -> bool
end;;
\end{ocamllisting}
\end{tabular}
&
\begin{tabular}[t]{l}
Structure definition\\
\hline
\begin{ocamllisting}
module Set : SetSig = struct
   type 'a set = 'a list
   let empty = []
   let add x l = x :: l
   let mem x l = List.mem x l
end;;
\end{ocamllisting}
\end{tabular}
\end{tabular}
\end{center}
\caption{Defining an explicit signature for the \hbox{\lstinline$Set$} module.}
\labelfigure{xmset2}
\end{figure}

\labelsection{module-contents}{Module definitions}

In general, structures and signatures are just like implementation
files and their interfaces. Structures are allowed to contain any of
the definitions that might occur in a implementation, including any of
the following.

\begin{itemize}
\item \lstinline$type$ definitions
\item \lstinline$exception$ definitions
\item \lstinline$let$ definitions
\item \lstinline$open$ statements to open the namespace of another module
\item \lstinline$include$ statements that include the contents of another module
\item signature definitions
\item nested structure definitions
\end{itemize}
%
Similarly, signatures may contain any of the declarations that might
occur in an interface file, including any of the following.

\begin{itemize}
\item \lstinline$type$ declarations
\item \lstinline$exception$ definitions
\item \lstinline$val$ declarations
\item \lstinline$open$ statements to open the namespace of another signature
\item \lstinline$include$ statements that include the contents of another signature
\item nested signature declarations
\end{itemize}
%

\labelsubsection{modules-first-class}{Modules are not first-class}

\index{modules!not first class}
Modules/structures/signatures are not \emph{first-class}, meaning in
particular that they are not expressions.  Modules cannot be passed as
arguments to a function nor can they be returned as results.
Normally, modules are defined as top-level outermost components in a
program, hence all type and exception definitions are also top-level.

\index{phase distinction} There are several reasons why modules are not first-class.  Perhaps the
most important is that modules and module types are complicated expressions involving types and type
abstraction; if modules could be passed as values, type inference would become undecidable.  Another
reason is called the \emph{phase-distinction}.  From the point of view of the compiler, a program
has two phases in its lifetime: compile-time and run-time.  The objective of the phase distinction
is to ensure that module expressions can be computed at compile-time.  If modules were expressions,
the phase-distinction would be difficult to ensure.  In any case, the phase distinction is simply a
guideline for the language designers.  The effect on programmers is that modules can only be defined
in a few chosen locations, but there is no performance penalty for using them.

\labelsubsection{letmodule}{The \hbox{\lstinline$let module$} expression}

\index{let module@\lstinline$let module$}
\index{modules!local definitions@local definitions using \lstinline$let$}
One exception to top-level module definitions is the
%
\hbox{\lstinline$let module$}
%
expression, which has the following syntax.

\begin{ocaml}
let module $\nt{ModuleName}$ = $\nt{module\_expression}$ in $\nt{body\_expression}$
\end{ocaml}
%
The \nt{module\_expression} is the definition of a module
(often a \hbox{\lstinline/struct $\cdots$ end/} block), and the module is
defined in the \nt{body\_expression}.  The
%
\hbox{\lstinline$let module$}
%
expression is frequently used for renaming modules locally.

\begin{ocaml}
module ModuleWithALongName
...
let f x =
   let module M = ModuleWithALongName in
   ...
\end{ocaml}
%
Similarly, it can be useful sometimes to redefine an existing module
locally.  In the following example, a \hbox{\lstinline$String$} module is
defined so that pathnames \lstinline{String.$\ms{identifier}$} in the
\texttt{\emph{function body}} refer to the locally-defined module, not the
standard library (in this case, it is for debugging purposes).

\begin{ocaml}
let f x =
   let module String = struct
      let create n =
          eprintf "Allocating a string of length %d\n%!" n;
          String.create n
      ...
   end in
   @\emph{function body}@
\end{ocaml}
%
One other use of \hbox{\lstinline/let module/} expression is to allow
types and exceptions to be defined locally, not only at the top-level.  For
example, in the following program, the
exception \hbox{\lstinline/Error/} is local.  It is guaranteed to be
different from every other exception in the program.

\begin{ocaml}
let f x =
   let module M = struct exception Abort end in
   let g y =
      ...
      if $\ms{done}$ then raise M.Abort
   in
   try map g x with
      M.Abort message -> ...
\end{ocaml}
%
In this particular case, the local definition of
the \hbox{\lstinline$M.Abort$} exception means that
the \hbox{\lstinline$map$} function (not shown) is not able to catch
the exception except generically, by catching all exceptions.

\labelsection{recursive-modules}{Recursive modules}

\index{and!recursive modules}
\index{rec!for recursive modules}
\index{modules!recursive}
It is also possible to define modules that are defined recursively.
That is, several modules that refer to one another are defined at
once.  The syntax for a recursive definition uses
the \lstinline{module rec} form.

\begin{ocaml}
module rec $\nt{Name}_1$ : $\nt{Signature}_1$ = $\nt{struct\_expression}_1$
and $\nt{Name}_2$ : $\nt{Signature}_2$ = $\nt{struct\_expression}_2$
$\vdots$
and $\nt{Name}_n$ : $\nt{Signature}_n$ = $\nt{struct\_expression}_n$
\end{ocaml}
%
The signatures $\nt{Signature}_i$ are \emph{required}.

For example, let's build a kind of nonempty trees with unbounded
branching, and a function \hbox{\lstinline$map$} with the standard
meaning.  The \hbox{\lstinline$map$} function could be defined as part
of a single module, but it is also possible to use recursive modules
to split the program into two parts 1) mapping over single tree nodes,
and 2) mapping over lists of trees.

\begin{ocaml}
type 'a ubtree = Node of 'a * 'a ubtree list

module rec Tree : sig
   val map : ('a -> 'b) -> 'a ubtree -> 'b ubtree
end = struct
   let map f (Node (x, children)) =
      Node (f x, Forest.map f children)
end

and Forest : sig
   val map : ('a -> 'b) -> 'a ubtree list -> 'b ubtree list
end = struct
   let map f l =
      List.map (Tree.map f) l
end;;
\end{ocaml}
%
This definition is necessarily recursive because
the \hbox{\lstinline$Tree$} module refers
to \hbox{\lstinline$Forest.map$}, and \hbox{\lstinline$Forest$} refers
to \hbox{\lstinline$Tree.map$}.

The signatures are required---one way to think of it is that the types
of the mutual references are needed so that type checking can be
performed for each module in isolation.\footnote{Recursive modules are
relatively new to OCaml; these requirements may change.}
Stylistically, recursive modules are used infrequently for simple
structure definitions; they become much more useful when used with
functors, which allow the module bodies to be placed in separate
files.

\labelsection{include}{The \hbox{\lstinline$include$} directive}

\label{keyword:include}
\index{include!module inclusion}
\index{modules!include@\lstinline$include$}
We have seen most of the module components before.  However, one new
construct we haven't seen is \hbox{\lstinline/include/}, which allows
the entire contents of a structure or signature to be included in
another.  The \hbox{\lstinline/include/} statement can be used to
create modules and signatures that re-use existing definitions.

\labelsubsection{include-extend}{Using include to extend modules}

Suppose we wish to define a new kind of sets \hbox{\lstinline/ChooseSet/} that has a
\hbox{\lstinline/choose/} function that returns an element of the set if one exists. Instead of
re-typing the entire signature, we can use the \hbox{\lstinline/include/} statement to include the
existing signature, as shown in Figure~\reffigure{xmset3}. The resulting signature includes all of
the types and declarations from \hbox{\lstinline/SetSig/} as well as the new function declaration
\hbox{\lstinline/val choose/}. For this example, we are using the toploop to display the inferred
signature for the new module.

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{tabular}[t]{l}
Signature definition\\
\hline
\begin{ocamllisting}
module type ChooseSetSig = sig
   include SetSig
   val choose : 'a set -> 'a option
end;;
\end{ocamllisting}
\end{tabular}
&
\begin{tabular}[t]{l}
Inferred type\\
\hline
\begin{ocamllisting}
module type ChooseSetSig = sig
   type 'a set
   val empty : 'a set
   val add : 'a -> 'a set -> 'a set
   val mem : 'a -> 'a set -> bool
   val choose : 'a set -> 'a option
end;;
\end{ocamllisting}
\end{tabular}
\end{tabular}
\end{center}
\caption{Extending a signature with \hbox{\lstinline+include+}.}
\labelfigure{xmset3}
\end{figure}

\labelsubsection{include-struct}{Using include to extend implementations}

The \texttt{include} statement can also be used in
implementations. For our example, however, there is a problem. The
straightforward approach in defining a
module \hbox{\lstinline/ChooseSet/} is to include
the \hbox{\lstinline/Set/} module, then define the new
function \hbox{\lstinline/choose/}. The result of this attempt is
shown in Figure \reffigure{xmset4}, where the toploop prints out an
extensive error message (the toploop prints out the full signature,
which we have elided in \hbox{\lstinline/sig $\cdots$ end/}).

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{tabular}[t]{l}
Structure definition\\
\hline
\begin{ocamllisting}
module ChooseSet
 : ChooseSetSig =
struct
   include Set
   let choose = function
      x :: _ -> Some x
    | [] -> None
end;;
\end{ocamllisting}
\end{tabular}
&
\begin{tabular}[t]{l}
Inferred type (from the toploop)\\
\hline
\begin{ocaml}
@
\begin{toperror}
Signature mismatch:
Modules do not match:
   sig ... end
is not included in
   ChooseSetSig
Values do not match:
   val choose : 'a list -> 'a option
   val choose : 'a set -> 'a option
\end{toperror}
@
\end{ocaml}
\end{tabular}
\end{tabular}
\end{center}
\caption{A failed attempt to extend the \hbox{\lstinline/Set/} implementation.}
\labelfigure{xmset4}
\end{figure}
%
The problem is apparent from the last few lines of the error
message---the \hbox{\lstinline/choose/} function has
type \hbox{\lstinline/'a list -> 'a option/}, not
\hbox{\lstinline/'a set -> 'a option/}
as it should. The issue is that we included the \emph{abstract}
module \hbox{\lstinline/Set/}, where the type
\hbox{\lstinline/'a set/}
has an abstract type, not a list.

One solution is to manually copy the code from
the \hbox{\lstinline/Set/} module into
the \hbox{\lstinline/ChooseSet/} module. This has its drawbacks of
course. We aren't able to re-use the existing implementation, our code
base gets larger, etc.  If we have access to the original non-abstract
set implementation, there is another solution---we can just include
the non-abstract set implementation, where it is known that the set is
represented as a list.

Suppose we start with a non-abstract
implementation \hbox{\lstinline/SetInternal/} of sets as lists. Then
the module \hbox{\lstinline/Set/} is the same implementation, with the
signature \hbox{\lstinline/SetSig/}; and
the \hbox{\lstinline/ChooseSet/} includes
the \hbox{\lstinline/SetInternal/} module instead
of \hbox{\lstinline/Set/}. Figure~\reffigure{xmset5} shows the
definitions in this order, together with the types inferred by the
toploop.

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{tabular}[t]{l}
Structure definitions\\
\hline
\begin{ocamllisting}
module SetInternal = struct
   type 'a set = 'a list
   let empty = []
   let add x l = x :: l
   let mem x l = List.mem x l
end;;

module Set : SetSig = SetInternal

module ChooseSet
 : ChooseSetSig =
 struct
   include SetInternal
   let choose = function
      x :: _ -> Some x
    | [] -> None
end;;
\end{ocamllisting}
\end{tabular}
&
\begin{tabular}[t]{l}
Inferred types (from the toploop)\\
\hline
\begin{ocamllisting}
module SetInternal : sig
   type 'a set = 'a list
   val empty : 'a list
   val add : 'a -> 'a list -> 'a list
   val mem : 'a -> 'a list -> bool
end;;

module Set : SetSig

module ChooseSet : ChooseSetSig
\end{ocamllisting}
\end{tabular}
\end{tabular}
\end{center}
\caption{Extending the \hbox{\lstinline/Set/} using an internal specification.}
\labelfigure{xmset5}
\end{figure}

Note that for the module \hbox{\lstinline/Set/} it is not necessary to
use a \hbox{\lstinline/struct $\cdots$ end/} definition because
the \hbox{\lstinline/Set/} module is \emph{equivalent} to
the \hbox{\lstinline/SetInternal/} module, it just has a different
signature. The modules \hbox{\lstinline/Set/}
and \hbox{\lstinline/ChooseSet/} are ``friends,'' in that they share
internal knowledge of each other's implementation, while keeping their
public signatures abstract.

\labelsection{module-hiding}{Abstraction, friends, and module hiding}

\index{abstraction}
\index{modules!abstraction}
So far, we have seen that modules provide two main features, 1) the
ability to divide a program into separate program units (modules) that
each have a separate namespace, and 2) the ability to assign
signatures that make each structure partially or totally abstract. In
addition, as we have seen in the previous example, a structure
like \hbox{\lstinline/SetInternal/} can be given more than one
signature (the module \hbox{\lstinline/Set/} is equal
to \hbox{\lstinline/SetInternal/} but it has a different signature).

Another frequent use of modules uses nesting to define multiple levels
of abstraction. For example, we might define a module container in
which several modules are defined and implementation are visible, but
the container type is abstract. This is akin to the C++ notion of
``friend'' classes, where a set of friend classes may mutually refer
to class implementations, but the publicly visible fields remain
protected.

In our example, there isn't much danger in leaving
the \hbox{\lstinline/SetInternal/} module publicly
accessible. A \hbox{\lstinline/SetInternal.set/} can't be used in
place of a \hbox{\lstinline/Set.set/} or
a \hbox{\lstinline/ChooseSet.set/}, because the latter types are
abstract. However, there is a cleaner solution that nests
the \hbox{\lstinline/Set/} and \hbox{\lstinline/ChooseSet/} structures
in an outer \hbox{\lstinline/Sets/} module. The signatures are left
unconstrained within the \hbox{\lstinline/Sets/} module, allowing
the \hbox{\lstinline/ChooseSet/} structure to refer to the
implementation of the \hbox{\lstinline/Set/} structure, but the
signature of the \hbox{\lstinline/Sets/} module is constrained. The
code for this is shown in Figure\reffigure{xmset6}.

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{tabular}[t]{l}
Module definitions\\
\hline
\begin{ocamllisting}
module Sets : sig
   module Set : SetSig
   module ChooseSet : ChooseSetSig
end = struct
   module Set = struct
      type 'a set = 'a list
      let empty = []
      let add x l = x :: l
      let mem x l = List.mem x l
   end
   module ChooseSet = struct
      include Set
      let choose = function
         x :: _ -> Some x
       | [] -> None
   end
end;;
\end{ocamllisting}
\end{tabular}
&
\begin{tabular}[t]{l}
Inferred types (from the toploop)\\
\hline
\begin{ocamllisting}
module Sets : sig
   module Set : SetSig
   module ChooseSet : ChooseSetSig
end
\end{ocamllisting}
\end{tabular}
\end{tabular}
\end{center}
\caption{Defining \misspelled{\texttt{ChooseSet}} and \texttt{Set} as friends.}
\labelfigure{xmset6}
\end{figure}

There are a few things to note for this definition.

\begin{enumerate}
\item{}

The \hbox{\lstinline/Sets/} module uses an \emph{anonymous} signature
(meaning that the signature has no name). Anonymous signatures
and \textbf{struct} implementations are perfectly acceptable any place
where a signature or structure is needed.

\item{}

Within the \hbox{\lstinline/Sets/} module the \hbox{\lstinline/Set/}
and \hbox{\lstinline/ChooseSet/} modules are not constrained, so that
their implementations are public. This allows
the \hbox{\lstinline/ChooseSet/} to refer to
the \hbox{\lstinline/Set/} implementation directly (so in this case,
the \hbox{\lstinline/Set/} and \hbox{\lstinline/ChooseSet/} modules
are friends). The signature for the \hbox{\lstinline/Sets/} module
makes them abstract.

\end{enumerate}

\labelsubsection{incompatible-include}{Using include with incompatible signatures}

\index{include!incompatible signatures}
In our current example, it might seem that there isn't much need to
have two separate modules \hbox{\lstinline/ChooseSet/}
(with \hbox{\lstinline/choice/}) and \hbox{\lstinline/Set/}
(without \hbox{\lstinline/choice/}). In practice it is perhaps more
likely that we would simply add a \hbox{\lstinline/choice/} function
to the \hbox{\lstinline/Set/} module. The addition would not affect
any existing code, since any existing code doesn't refer to
the \hbox{\lstinline/choice/} function anyway.

Surprisingly, this kind of example occurs in practice more than it
might seem, due to programs being developed with incompatible
signatures. For example, suppose we are writing a program that is
going to make use of two independently-developed libraries. Both
libraries have their own \hbox{\lstinline/Set/} implementation, and we
decide that we would like to use a single \hbox{\lstinline/Set/}
implementation in the combined program. Unfortunately, the signatures
are incompatible---in the first library, the \hbox{\lstinline/add/}
function was defined with type
\hbox{\lstinline/val add : 'a -> 'a set -> 'a set/};
but in the second library, it was defined with
type \hbox{\lstinline/val add : 'a set -> 'a -> 'a set/}. Let's say
that the first library uses the desired signature. Then, one solution
would be to hunt through the second library, finding all calls to
the \hbox{\lstinline/Set.add/} function, reordering the arguments to
fit a common signature. Of course, the process is tedious, and it is
unlikely we would want to do it.

An alternative is to \emph{derive} a wrapper
module \hbox{\lstinline/Set2/} for use in the second library. The
process is simple, 1) \hbox{\lstinline/include/}
the \hbox{\lstinline/Set/} module, and 2) redefine
the \hbox{\lstinline/add/} to match the desired signature; this is
shown in Figure~\reffigure{xmset7}.

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{tabular}[t]{l}
Signature\\
\hline
\begin{ocamllisting}
module type Set2Sig = sig
   type 'a set
   val empty : 'a set
   val add : 'a set -> 'a -> 'a set
   val mem : 'a -> 'a set -> bool
end;;
\end{ocamllisting}
\end{tabular}
&
\begin{tabular}[t]{l}
Implementation\\
\hline
\begin{ocamllisting}
module Set2 : Set2Sig = struct
   include Set
   let add l x = Set.add x l
end;;
\end{ocamllisting}
\end{tabular}
\end{tabular}
\end{center}
\caption{Wrapping a module to use a new signature.}
\labelfigure{xmset7}
\end{figure}

The \hbox{\lstinline/Set2/} module is just a wrapper. Apart from
the \hbox{\lstinline/add/} function, the types and values in
the \hbox{\lstinline/Set/} and \hbox{\lstinline/Set2/} modules are the
same, and the \hbox{\lstinline/Set2.add/} function simply reorders the
arguments before calling the \hbox{\lstinline/Set.add/}
function. There is little or no performance penalty for the
wrapper---in most cases the native-code OCaml compiler
will \emph{inline} the \hbox{\lstinline/Set2.add/} function (in other
words, it will perform the argument reordering at compile time).

\labelsection{sharing-constraints}{Sharing constraints}

There is one remaining problem with this example. In the combined
program, the first library uses the original \hbox{\lstinline/Set/}
module, and the second library uses \hbox{\lstinline/Set2/}. It is
likely that we will want to pass values, including sets, from one
library to the other. However, as defined, the 
\hbox{\lstinline/'a Set.set/}
and \hbox{\lstinline/'a Set2.set/} types are distinct abstract types,
and it is an error to use a value of type 
\hbox{\lstinline/'a Set.set/}
in a place where a value of type \hbox{\lstinline/'a Set2.set/} is
expected, and \textit{vice-versa}. The following error message is
typical.

\begin{ocaml}
# Set2.add Set.empty 1;;
@
\begin{toperror}
This expression has type 'a Set.set
   but is here used with type 'b Set2.set
\end{toperror}
@
\end{ocaml}
%
Of course, we might want the types to be distinct. But in this case,
it is more likely that we want the definition to be transparent. We
know that the two kinds of sets are really the
same---\hbox{\lstinline/Set2/} is really just a wrapper
for \hbox{\lstinline/Set/}. How do we establish the equivalence
of \hbox{\lstinline/'a Set.set/} and \hbox{\lstinline/'a Set2.set/}?

\index{sharing constraints|see{modules}}
\index{modules!sharing constraints}
The solution is called a \emph{sharing constraint}. The syntax for a
sharing constraint uses the \hbox{\lstinline/with/} keyword to specify
a type equivalence for a module signature in the following form.

\begin{ocaml}
$\nt{signature}$ ::= $\nt{signature}$ with type $\nt{typename}$ = $\nt{type}$
\end{ocaml}
%
In this particular case, we wish to say that the
%
\hbox{\lstinline/'a Set2.set/}
%
type is equal to the \hbox{\lstinline/'a Set.set/} type, which we can
do by adding a sharing constraint when the \hbox{\lstinline/Set2/}
module is defined, as shown in Figure \reffigure{xmset8}.

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{tabular}[t]{l}
Module definition\\
\hline
\begin{ocamllisting}
module Set2 : Set2Sig
   with type 'a set = 'a Set.set =
struct
   include Set
   let add l x = Set.add x l
end;;
\end{ocamllisting}
\end{tabular}
&
\begin{tabular}[t]{l}
Toploop\\
\hline
\begin{ocaml}
# let s = Set2.add Set.empty 1;;
@
\begin{topoutput}
val s : int Set2.set = <abstr>
\end{topoutput}
@
# Set.mem 1 s;;
@
\begin{topoutput}
- bool = true
\end{topoutput}
@
\end{ocaml}
\end{tabular}
\end{tabular}
\end{center}
\caption{Defining a sharing constraint.}
\labelfigure{xmset8}
\end{figure}
%
The constraint specifies that the types \hbox{\lstinline/'a Set2.set/}
and \hbox{\lstinline/'a Set.set/} are the same. In other words,
they \emph{share} a common type. Since the two types are equal, set
values can be freely passed between the two set implementations.

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
