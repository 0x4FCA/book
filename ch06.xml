<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="variants">
  <title>Variants</title>

  <para>Variant types are one of the most useful features of OCaml and also
  one of the most unusual. They let you represent data that may take on
  multiple different forms, where each form is marked by an explicit tag. As
  we'll see, when combined with pattern matching, variants give you a powerful
  way of representing complex data and of organizing the case-analysis on that
  information.<indexterm class="singular">
      <primary>variant types</primary>

      <secondary>usefulness of</secondary>
    </indexterm><indexterm class="startofrange" id="DTvar">
      <primary>datatypes</primary>

      <secondary>variant types</secondary>
    </indexterm></para>

  <para>The basic syntax of a variant type declaration is as
  follows:<indexterm class="singular">
      <primary>variant types</primary>

      <secondary>basic syntax of</secondary>
    </indexterm></para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/v1/code/variants/variant.syntax">Syntax</ulink></para>

  <programlisting format="linespecific" language="ocaml">type <emphasis>&lt;variant&gt;</emphasis> =
  | <emphasis>&lt;Tag&gt;</emphasis> [ of <emphasis>&lt;type&gt;</emphasis> [* <emphasis>&lt;type&gt;</emphasis>]... ]
  | <emphasis>&lt;Tag&gt;</emphasis> [ of <emphasis>&lt;type&gt;</emphasis> [* <emphasis>&lt;type&gt;</emphasis>]... ]
  | ...</programlisting>

  <para>Each row essentially represents a case of the variant. Each case has an associated tag and
    may optionally have a sequence of fields, where each field has a specified type.</para>

  <para>Let's consider a concrete example of how variants can be useful.
  Almost all terminals support a set of eight basic colors, and we can
  represent those colors using a variant. Each color is declared as a simple
  tag, with pipes used to separate the different cases. Note that variant tags
  must be capitalized:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink></para>

  <programlisting format="linespecific" language="ocaml"><prompt
      moreinfo="none"># </prompt><userinput moreinfo="none">type basic_color =</userinput>
<userinput moreinfo="none">   | Black | Red | Green | Yellow | Blue | Magenta | Cyan | White ;;</userinput>
<computeroutput moreinfo="none">type basic_color =</computeroutput>
<computeroutput moreinfo="none">    Black</computeroutput>
<computeroutput moreinfo="none">  | Red</computeroutput>
<computeroutput moreinfo="none">  | Green</computeroutput>
<computeroutput moreinfo="none">  | Yellow</computeroutput>
<computeroutput moreinfo="none">  | Blue</computeroutput>
<computeroutput moreinfo="none">  | Magenta</computeroutput>
<computeroutput moreinfo="none">  | Cyan</computeroutput>
<computeroutput moreinfo="none">  | White</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Cyan ;;</userinput>
<computeroutput moreinfo="none">- : basic_color = Cyan</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[Blue; Magenta; Red] ;;</userinput>
<computeroutput moreinfo="none">- : basic_color list = [Blue; Magenta; Red]</computeroutput></programlisting>

  <para>The following function uses pattern matching to convert a <literal
  moreinfo="none">basic_color</literal> to a corresponding integer. The
  exhaustiveness checking on pattern matches means that the compiler will warn
  us if we miss a color:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
  (part 1)</para>

  <programlisting format="linespecific" language="ocaml"><prompt
      moreinfo="none"># </prompt><userinput moreinfo="none">let basic_color_to_int = function</userinput>
<userinput moreinfo="none">  | Black -&gt; 0 | Red     -&gt; 1 | Green -&gt; 2 | Yellow -&gt; 3</userinput>
<userinput moreinfo="none">  | Blue  -&gt; 4 | Magenta -&gt; 5 | Cyan  -&gt; 6 | White  -&gt; 7 ;;</userinput>
<computeroutput moreinfo="none">val basic_color_to_int : basic_color -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:basic_color_to_int [Blue;Red];;</userinput>
<computeroutput moreinfo="none">- : int list = [4; 1]</computeroutput></programlisting>

  <para>Using the preceding function, we can generate escape codes to change
  the color of a given string displayed in a terminal:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main-2.rawscript">OCaml utop</ulink></para>

  <programlisting format="linespecific" language="ocaml"><userinput
      moreinfo="none"># let color_by_number number text =
    sprintf "\027[38;5;%dm%s\027[0m" number text;;</userinput>
<computeroutput moreinfo="none">val color_by_number : int -&gt; string -&gt; string = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># let blue = color_by_number (basic_color_to_int Blue) "Blue";;</userinput>
<computeroutput moreinfo="none">val blue : string = "\027[38;5;4mBlue\027[0m"</computeroutput>
<userinput moreinfo="none"># printf "Hello %s World!\n" blue;;</userinput>
<computeroutput moreinfo="none">Hello Blue World!</computeroutput></programlisting>

  <para>On most terminals, that word "Blue" will be rendered in blue.</para>

  <para>In this example, the cases of the variant are simple tags with no
  associated data. This is substantively the same as the enumerations found in
  languages like C and Java. But as we'll see, variants can do considerably
  more than represent a simple enumeration. As it happens, an enumeration
  isn't enough to effectively describe the full set of colors that a modern
  terminal can display. Many terminals, including the venerable <literal
  moreinfo="none">xterm</literal>, support 256 different colors, broken up
  into the following groups:</para>

  <itemizedlist>
    <listitem>
      <para>The eight basic colors, in regular and bold versions</para>
    </listitem>

    <listitem>
      <para>A 6 × 6 × 6 RGB color cube</para>
    </listitem>

    <listitem>
      <para>A 24-level grayscale ramp</para>
    </listitem>
  </itemizedlist>

  <para>We'll also represent this more complicated color space as a variant,
  but this time, the different tags will have arguments that describe the data
  available in each case. Note that variants can have multiple arguments,
  which are separated by <literal moreinfo="none">*</literal>s:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
  (part 3)</para>

  <programlisting format="linespecific" language="ocaml"><prompt
      moreinfo="none"># </prompt><userinput moreinfo="none">type weight = Regular | Bold</userinput>
<userinput moreinfo="none">  type color =</userinput>
<userinput moreinfo="none">  | Basic of basic_color * weight (* basic colors, regular and bold *)</userinput>
<userinput moreinfo="none">  | RGB   of int * int * int       (* 6x6x6 color cube *)</userinput>
<userinput moreinfo="none">  | Gray  of int                   (* 24 grayscale levels *)</userinput>
<userinput moreinfo="none">;;</userinput>
<computeroutput moreinfo="none">type weight = Regular | Bold</computeroutput>
<computeroutput moreinfo="none">type color =</computeroutput>
<computeroutput moreinfo="none">    Basic of basic_color * weight</computeroutput>
<computeroutput moreinfo="none">  | RGB of int * int * int</computeroutput>
<computeroutput moreinfo="none">  | Gray of int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[RGB (250,70,70); Basic (Green, Regular)];;</userinput>
<computeroutput moreinfo="none">- : color list = [RGB (250, 70, 70); Basic (Green, Regular)]</computeroutput></programlisting>

  <para>Once again, we'll use pattern matching to convert a color to a
  corresponding integer. But in this case, the pattern matching does more than
  separate out the different cases; it also allows us to extract the data
  associated with each tag:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
  (part 4)</para>

  <programlisting format="linespecific" language="ocaml"><prompt
      moreinfo="none"># </prompt><userinput moreinfo="none">let color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic (basic_color,weight) -&gt;</userinput>
<userinput moreinfo="none">      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in</userinput>
<userinput moreinfo="none">      base + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | Gray i -&gt; 232 + i ;;</userinput>
<computeroutput moreinfo="none">val color_to_int : color -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

  <para>Now, we can print text using the full set of available colors:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital"
  url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main-5.rawscript">OCaml utop</ulink></para>

  <programlisting format="linespecific" language="ocaml"><userinput
      moreinfo="none"># let color_print color s =
     printf "%s\n" (color_by_number (color_to_int color) s);;</userinput>
<computeroutput moreinfo="none">val color_print : color -&gt; string -&gt; unit = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># color_print (Basic (Red,Bold)) "A bold red!";;</userinput>
<computeroutput moreinfo="none">A bold red!</computeroutput>
<userinput moreinfo="none"># color_print (Gray 4) "A muted gray...";;</userinput>
<computeroutput moreinfo="none">A muted gray...</computeroutput></programlisting>

  <sect1 id="catch-all-cases-and-refactoring">
    <title>Catch-All Cases and Refactoring</title>

    <para>OCaml's type system can act as a refactoring tool, warning you of
    places where your code needs to be updated to match an interface change.
    This is particularly valuable in the context of variants.<indexterm class="singular">
        <primary>errors</primary>

        <secondary>catch-all cases and refactoring</secondary>
      </indexterm><indexterm class="singular">
        <primary>pattern matching</primary>

        <secondary>catch-all cases</secondary>
      </indexterm><indexterm class="singular">
        <primary>functional updates</primary>
      </indexterm><indexterm class="singular">
        <primary>refactoring</primary>
      </indexterm><indexterm class="singular">
        <primary>variant types</primary>

        <secondary>catch-all cases and refactoring</secondary>
      </indexterm></para>

    <para>Consider what would happen if we were to change the definition of
    <literal moreinfo="none">color</literal> to the following:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type color =</userinput>
<userinput moreinfo="none">  | Basic of basic_color     (* basic colors *)</userinput>
<userinput moreinfo="none">  | Bold  of basic_color     (* bold basic colors *)</userinput>
<userinput moreinfo="none">  | RGB   of int * int * int (* 6x6x6 color cube *)</userinput>
<userinput moreinfo="none">  | Gray  of int             (* 24 grayscale levels *)</userinput>
<userinput moreinfo="none">;;</userinput>
<computeroutput moreinfo="none">type color =</computeroutput>
<computeroutput moreinfo="none">    Basic of basic_color</computeroutput>
<computeroutput moreinfo="none">  | Bold of basic_color</computeroutput>
<computeroutput moreinfo="none">  | RGB of int * int * int</computeroutput>
<computeroutput moreinfo="none">  | Gray of int</computeroutput></programlisting>

    <para>We've essentially broken out the <literal
    moreinfo="none">Basic</literal> case into two cases, <literal
    moreinfo="none">Basic</literal> and <literal
    moreinfo="none">Bold</literal>, and <literal
    moreinfo="none">Basic</literal> has changed from having two arguments to
    one. <literal moreinfo="none">color_to_int</literal> as we wrote it still
    expects the old structure of the variant, and if we try to compile that
    same code again, the compiler will notice the discrepancy:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic (basic_color,weight) -&gt;</userinput>
<userinput moreinfo="none">      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in</userinput>
<userinput moreinfo="none">      base + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | Gray i -&gt; 232 + i ;;</userinput>
<computeroutput moreinfo="none">Characters 34-60:</computeroutput>
<computeroutput moreinfo="none">Error: This pattern matches values of type 'a * 'b</computeroutput>
<computeroutput moreinfo="none">       but a pattern was expected which matches values of type basic_color</computeroutput></programlisting>

    <para>Here, the compiler is complaining that the <literal
    moreinfo="none">Basic</literal> tag is used with the wrong number of
    arguments. If we fix that, however, the compiler flag will flag a second
    problem, which is that we haven't handled the new <literal
    moreinfo="none">Bold</literal> tag:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic basic_color -&gt; basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | Gray i -&gt; 232 + i ;;</userinput>
<computeroutput moreinfo="none">Characters 19-154:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">Bold _</computeroutput>
<computeroutput moreinfo="none">val color_to_int : color -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>Fixing this now leads us to the correct implementation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic basic_color -&gt; basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | Bold  basic_color -&gt; 8 + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | Gray i -&gt; 232 + i ;;</userinput>
<computeroutput moreinfo="none">val color_to_int : color -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>As we've seen, the type errors identified the things that needed to
    be fixed to complete the refactoring of the code. This is fantastically
    useful, but for it to work well and reliably, you need to write your code
    in a way that maximizes the compiler's chances of helping you find the
    bugs. To this end, a useful rule of thumb is to avoid catch-all cases in
    pattern matches.</para>

    <para>Here's an example that illustrates how catch-all cases interact with
    exhaustion checks. Imagine we wanted a version of <literal
    moreinfo="none">color_to_int</literal> that works on older terminals by
    rendering the first 16 colors (the eight <literal
    moreinfo="none">basic_color</literal>s in regular and bold) in the normal
    way, but renders everything else as white. We might have written the
    function as follows:<indexterm class="singular">
        <primary>exhaustion checks</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let oldschool_color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic (basic_color,weight) -&gt;</userinput>
<userinput moreinfo="none">      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in</userinput>
<userinput moreinfo="none">      base + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | _ -&gt; basic_color_to_int White;;</userinput>
<computeroutput moreinfo="none">Characters 44-70:</computeroutput>
<computeroutput moreinfo="none">Error: This pattern matches values of type 'a * 'b</computeroutput>
<computeroutput moreinfo="none">       but a pattern was expected which matches values of type basic_color</computeroutput></programlisting>

    <para>But because the catch-all case encompasses all possibilities, the
    type system will no longer warn us that we have missed the new <literal
    moreinfo="none">Bold</literal> case when we change the type to include it.
    We can get this check back by avoiding the catch-all case, and instead
    being explicit about the tags that are ignored.</para>
  </sect1>

  <sect1 id="combining-records-and-variants">
    <title>Combining Records and Variants</title>

    <para>The term <emphasis>algebraic data types</emphasis> is often used to
    describe a collection of types that includes variants, records, and
    tuples. Algebraic data types act as a peculiarly useful and powerful
    language for describing data. At the heart of their utility is the fact
    that they combine two different kinds of types: <emphasis>product
    types</emphasis>, like tuples and records, which combine multiple
    different types together and are mathematically similar to Cartesian
    products; and <emphasis>sum types</emphasis>, like variants, which let you
    combine multiple different possibilities into one type, and are
    mathematically similar to disjoint unions.<indexterm class="startofrange"
        id="RECvartyp">
        <primary>records</primary>

        <secondary sortas="variant types">and variant types</secondary>
      </indexterm><indexterm class="singular">
        <primary>sum types</primary>
      </indexterm><indexterm class="singular">
        <primary>product types</primary>
      </indexterm><indexterm class="singular">
        <primary>datatypes</primary>

        <secondary>algebraic types</secondary>
      </indexterm><indexterm class="singular">
        <primary>algebraic data types</primary>
      </indexterm><indexterm class="startofrange" id="VARTYPrec">
        <primary>variant types</primary>

        <secondary sortas="records">and records</secondary>
      </indexterm></para>

    <para>Algebraic data types gain much of their power from the ability to
    construct layered combinations of sums and products. Let's see what we can
    achieve with this by revisiting the logging server types that were
    described in <xref linkend="records" />. We'll start by reminding
    ourselves of the definition of <literal
    moreinfo="none">Log_entry.t</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Log_entry = struct</userinput>
<userinput moreinfo="none">    type t =</userinput>
<userinput moreinfo="none">      { session_id: string;</userinput>
<userinput moreinfo="none">        time: Time.t;</userinput>
<userinput moreinfo="none">        important: bool;</userinput>
<userinput moreinfo="none">        message: string;</userinput>
<userinput moreinfo="none">      }</userinput>
<userinput moreinfo="none">  end</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">module Log_entry :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = {</computeroutput>
<computeroutput moreinfo="none">      session_id : string;</computeroutput>
<computeroutput moreinfo="none">      time : Time.t;</computeroutput>
<computeroutput moreinfo="none">      important : bool;</computeroutput>
<computeroutput moreinfo="none">      message : string;</computeroutput>
<computeroutput moreinfo="none">    }</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>This record type combines multiple pieces of data into one value. In particular, a single
        <literal moreinfo="none">Log_entry.t</literal> has a <literal moreinfo="none"
        >session_id</literal>
      <emphasis>and</emphasis> a <literal moreinfo="none">time</literal>
      <emphasis>and</emphasis> an <literal moreinfo="none">important</literal> flag
        <emphasis>and</emphasis> a <literal moreinfo="none">message</literal>. More generally, you
      can think of record types as conjunctions. Variants, on the other hand, are disjunctions,
      letting you represent multiple possibilities, as in the following example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type client_message = | Logon of Logon.t</userinput>
<userinput moreinfo="none">                        | Heartbeat of Heartbeat.t</userinput>
<userinput moreinfo="none">                        | Log_entry of Log_entry.t</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type client_message =</computeroutput>
<computeroutput moreinfo="none">    Logon of Logon.t</computeroutput>
<computeroutput moreinfo="none">  | Heartbeat of Heartbeat.t</computeroutput>
<computeroutput moreinfo="none">  | Log_entry of Log_entry.t</computeroutput></programlisting>

    <para>A <literal moreinfo="none">client_message</literal> is a <literal
    moreinfo="none">Logon</literal> <emphasis>or</emphasis> a <literal
    moreinfo="none">Heartbeat</literal> <emphasis>or</emphasis> a <literal
    moreinfo="none">Log_entry</literal>. If we want to write code that
    processes messages generically, rather than code specialized to a fixed
    message type, we need something like <literal
    moreinfo="none">client_message</literal> to act as one overarching type
    for the different possible messages. We can then match on the <literal
    moreinfo="none">client_message</literal> to determine the type of the
    particular message being dealt with.</para>

    <para>You can increase the precision of your types by using variants to
    represent differences between types, and records to represent shared
    structure. Consider the following function that takes a list of <literal
    moreinfo="none">client_message</literal>s and returns all messages
    generated by a given user. The code in question is implemented by folding
    over the list of messages, where the accumulator is a pair of:</para>

    <itemizedlist>
      <listitem>
        <para>The set of session identifiers for the user that have been seen
        thus far</para>
      </listitem>

      <listitem>
        <para>The set of messages so far that are associated with the
        user</para>
      </listitem>
    </itemizedlist>

    <para>Here's the concrete code:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let messages_for_user user messages =</userinput>
<userinput moreinfo="none">    let (user_messages,_) =</userinput>
<userinput moreinfo="none">      List.fold messages ~init:([],String.Set.empty)</userinput>
<userinput moreinfo="none">        ~f:(fun ((messages,user_sessions) as acc) message -&gt;</userinput>
<userinput moreinfo="none">          match message with</userinput>
<userinput moreinfo="none">          | Logon m -&gt;</userinput>
<userinput moreinfo="none">            if m.Logon.user = user then</userinput>
<userinput moreinfo="none">              (message::messages, Set.add user_sessions m.Logon.session_id)</userinput>
<userinput moreinfo="none">            else acc</userinput>
<userinput moreinfo="none">          | Heartbeat _ | Log_entry _ -&gt;</userinput>
<userinput moreinfo="none">            let session_id = match message with</userinput>
<userinput moreinfo="none">              | Logon     m -&gt; m.Logon.session_id</userinput>
<userinput moreinfo="none">              | Heartbeat m -&gt; m.Heartbeat.session_id</userinput>
<userinput moreinfo="none">              | Log_entry m -&gt; m.Log_entry.session_id</userinput>
<userinput moreinfo="none">            in</userinput>
<userinput moreinfo="none">            if Set.mem user_sessions session_id then</userinput>
<userinput moreinfo="none">              (message::messages,user_sessions)</userinput>
<userinput moreinfo="none">            else acc</userinput>
<userinput moreinfo="none">        )</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    List.rev user_messages</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val messages_for_user : string -&gt; client_message list -&gt; client_message list =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

    <para>There's one awkward part of the preceding code, which is the logic
    that determines the session ID. The code is somewhat repetitive,
    contemplating each of the possible message types (including the <literal
    moreinfo="none">Logon</literal> case, which isn't actually possible at
    that point in the code) and extracting the session ID in each case. This
    per-message-type handling seems unnecessary, since the session ID works
    the same way for all of the message types.</para>

    <para>We can improve the code by refactoring our types to explicitly
    reflect the information that's shared between the different messages. The
    first step is to cut down the definitions of each per-message record to
    contain just the information unique to that record:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Log_entry = struct</userinput>
<userinput moreinfo="none">    type t = { important: bool;</userinput>
<userinput moreinfo="none">               message: string;</userinput>
<userinput moreinfo="none">             }</userinput>
<userinput moreinfo="none">  end</userinput>
<userinput moreinfo="none">  module Heartbeat = struct</userinput>
<userinput moreinfo="none">    type t = { status_message: string; }</userinput>
<userinput moreinfo="none">  end</userinput>
<userinput moreinfo="none">  module Logon = struct</userinput>
<userinput moreinfo="none">    type t = { user: string;</userinput>
<userinput moreinfo="none">               credentials: string;</userinput>
<userinput moreinfo="none">             }</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module Log_entry : sig type t = { important : bool; message : string; } end</computeroutput>
<computeroutput moreinfo="none">module Heartbeat : sig type t = { status_message : string; } end</computeroutput>
<computeroutput moreinfo="none">module Logon : sig type t = { user : string; credentials : string; } end</computeroutput></programlisting>

    <para>We can then define a variant type that combines these types:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type details =</userinput>
<userinput moreinfo="none">    | Logon of Logon.t</userinput>
<userinput moreinfo="none">    | Heartbeat of Heartbeat.t</userinput>
<userinput moreinfo="none">    | Log_entry of Log_entry.t</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">type details =</computeroutput>
<computeroutput moreinfo="none">    Logon of Logon.t</computeroutput>
<computeroutput moreinfo="none">  | Heartbeat of Heartbeat.t</computeroutput>
<computeroutput moreinfo="none">  | Log_entry of Log_entry.t</computeroutput></programlisting>

    <para>Separately, we need a record that contains the fields that are
    common across all messages:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Common = struct</userinput>
<userinput moreinfo="none">    type t = { session_id: string;</userinput>
<userinput moreinfo="none">               time: Time.t;</userinput>
<userinput moreinfo="none">             }</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module Common : sig type t = { session_id : string; time : Time.t; } end</computeroutput></programlisting>

    <para>A full message can then be represented as a pair of a <literal
    moreinfo="none">Common.t</literal> and a <literal
    moreinfo="none">details</literal>. Using this, we can rewrite our
    preceding example as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let messages_for_user user messages =</userinput>
<userinput moreinfo="none">    let (user_messages,_) =</userinput>
<userinput moreinfo="none">      List.fold messages ~init:([],String.Set.empty)</userinput>
<userinput moreinfo="none">        ~f:(fun ((messages,user_sessions) as acc) ((common,details) as message) -&gt;</userinput>
<userinput moreinfo="none">          let session_id = common.Common.session_id in</userinput>
<userinput moreinfo="none">          match details with</userinput>
<userinput moreinfo="none">          | Logon m -&gt;</userinput>
<userinput moreinfo="none">            if m.Logon.user = user then</userinput>
<userinput moreinfo="none">              (message::messages, Set.add user_sessions session_id)</userinput>
<userinput moreinfo="none">            else acc</userinput>
<userinput moreinfo="none">          | Heartbeat _ | Log_entry _ -&gt;</userinput>
<userinput moreinfo="none">            if Set.mem user_sessions session_id then</userinput>
<userinput moreinfo="none">              (message::messages,user_sessions)</userinput>
<userinput moreinfo="none">            else acc</userinput>
<userinput moreinfo="none">        )</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    List.rev user_messages</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val messages_for_user :</computeroutput>
<computeroutput moreinfo="none">  string -&gt; (Common.t * details) list -&gt; (Common.t * details) list = &lt;fun&gt;</computeroutput></programlisting>

    <para>As you can see, the code for extracting the session ID has been
    replaced with the simple expression <literal
    moreinfo="none">common.Common.session_id</literal>.</para>

    <para>In addition, this design allows us to essentially downcast to the
    specific message type once we know what it is and then dispatch code to
    handle just that message type. In particular, while we use the type
    <literal moreinfo="none">Common.t * details</literal> to represent an
    arbitrary message, we can use <literal moreinfo="none">Common.t *
    Logon.t</literal> to represent a logon message. Thus, if we had functions
    for handling individual message types, we could write a dispatch function
    as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let handle_message server_state (common,details) =</userinput>
<userinput moreinfo="none">    match details with</userinput>
<userinput moreinfo="none">    | Log_entry m -&gt; handle_log_entry server_state (common,m)</userinput>
<userinput moreinfo="none">    | Logon     m -&gt; handle_logon     server_state (common,m)</userinput>
<userinput moreinfo="none">    | Heartbeat m -&gt; handle_heartbeat server_state (common,m)</userinput>
<userinput moreinfo="none">  ;;</userinput></programlisting>

    <para>And it's explicit at the type level that <literal
    moreinfo="none">handle_log_entry</literal> sees only <literal
    moreinfo="none">Log_entry</literal> messages, <literal
    moreinfo="none">handle_logon</literal> sees only <literal
    moreinfo="none">Logon</literal> messages, etc.<indexterm
    class="endofrange" startref="RECvartyp"></indexterm><indexterm
    class="endofrange" startref="VARTYPrec"></indexterm></para>
  </sect1>

  <sect1 id="variants-and-recursive-data-structures">
    <title>Variants and Recursive Data Structures</title>

    <para>Another common application of variants is to represent tree-like
    recursive data structures. We'll show how this can be done by walking
    through the design of a simple Boolean expression language. Such a
    language can be useful anywhere you need to specify filters, which are
    used in everything from packet analyzers to mail clients.<indexterm
        class="singular">
        <primary>recursive data structures</primary>
      </indexterm><indexterm class="singular">
        <primary>data structures</primary>

        <secondary>recursive</secondary>
      </indexterm><indexterm class="singular">
        <primary>variant types</primary>

        <secondary sortas="recursive">and recursive data
        structures</secondary>
      </indexterm></para>

    <para>An expression in this language will be defined by the variant
    <literal moreinfo="none">expr</literal>, with one tag for each kind of
    expression we want to support:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type 'a expr =</userinput>
<userinput moreinfo="none">    | Base  of 'a</userinput>
<userinput moreinfo="none">    | Const of bool</userinput>
<userinput moreinfo="none">    | And   of 'a expr list</userinput>
<userinput moreinfo="none">    | Or    of 'a expr list</userinput>
<userinput moreinfo="none">    | Not   of 'a expr</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type 'a expr =</computeroutput>
<computeroutput moreinfo="none">    Base of 'a</computeroutput>
<computeroutput moreinfo="none">  | Const of bool</computeroutput>
<computeroutput moreinfo="none">  | And of 'a expr list</computeroutput>
<computeroutput moreinfo="none">  | Or of 'a expr list</computeroutput>
<computeroutput moreinfo="none">  | Not of 'a expr</computeroutput></programlisting>

    <para>Note that the definition of the type <literal
    moreinfo="none">expr</literal> is recursive, meaning that a <literal
    moreinfo="none">expr</literal> may contain other <literal
    moreinfo="none">expr</literal>s. Also, <literal
    moreinfo="none">expr</literal> is parameterized by a polymorphic type
    <literal moreinfo="none">'a</literal> which is used for specifying the
    type of the value that goes under the <literal
    moreinfo="none">Base</literal> tag.</para>

    <para>The purpose of each tag is pretty straightforward. <literal
    moreinfo="none">And</literal>, <literal moreinfo="none">Or</literal>, and
    <literal moreinfo="none">Not</literal> are the basic operators for
    building up Boolean expressions, and <literal
    moreinfo="none">Const</literal> lets you enter the constants <literal
    moreinfo="none">true</literal> and <literal
    moreinfo="none">false</literal>.</para>

    <para>The <literal moreinfo="none">Base</literal> tag is what allows you
    to tie the <literal moreinfo="none">expr</literal> to your application, by
    letting you specify an element of some base predicate type, whose truth or
    falsehood is determined by your application. If you were writing a filter
    language for an email processor, your base predicates might specify the
    tests you would run against an email, as in the following example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type mail_field = To | From | CC | Date | Subject</userinput>
<userinput moreinfo="none">  type mail_predicate = { field: mail_field;</userinput>
<userinput moreinfo="none">                          contains: string }</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type mail_field = To | From | CC | Date | Subject</computeroutput>
<computeroutput moreinfo="none">type mail_predicate = { field : mail_field; contains : string; }</computeroutput></programlisting>

    <para>Using the preceding code, we can construct a simple expression with
    <literal moreinfo="none">mail_predicate</literal> as its base
    predicate:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let test field contains = Base { field; contains };;</userinput>
<computeroutput moreinfo="none">val test : mail_field -&gt; string -&gt; mail_predicate expr = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">And [ Or [ test To "doligez"; test CC "doligez" ];</userinput>
<userinput moreinfo="none">        test Subject "runtime";</userinput>
<userinput moreinfo="none">      ]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : mail_predicate expr =</computeroutput>
<computeroutput moreinfo="none">And</computeroutput>
<computeroutput moreinfo="none"> [Or</computeroutput>
<computeroutput moreinfo="none">   [Base {field = To; contains = "doligez"};</computeroutput>
<computeroutput moreinfo="none">    Base {field = CC; contains = "doligez"}];</computeroutput>
<computeroutput moreinfo="none">  Base {field = Subject; contains = "runtime"}]</computeroutput></programlisting>

    <para>Being able to construct such expressions isn't enough; we also need
    to be able to evaluate them. Here's a function for doing just that:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let rec eval expr base_eval =</userinput>
<userinput moreinfo="none">    (* a shortcut, so we don't need to repeatedly pass [base_eval]
        explicitly to [eval] *)</userinput>
<userinput moreinfo="none">    let eval' expr = eval expr base_eval in</userinput>
<userinput moreinfo="none">    match expr with</userinput>
<userinput moreinfo="none">    | Base  base   -&gt; base_eval base</userinput>
<userinput moreinfo="none">    | Const bool   -&gt; bool</userinput>
<userinput moreinfo="none">    | And   exprs -&gt; List.for_all exprs ~f:eval'</userinput>
<userinput moreinfo="none">    | Or    exprs -&gt; List.exists  exprs ~f:eval'</userinput>
<userinput moreinfo="none">    | Not   expr  -&gt; not (eval' expr)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val eval : 'a expr -&gt; ('a -&gt; bool) -&gt; bool = &lt;fun&gt;</computeroutput></programlisting>

    <para>The structure of the code is pretty straightforward—we're just
    pattern matching over the structure of the data, doing the appropriate
    calculation based on which tag we see. To use this evaluator on a concrete
    example, we just need to write the <literal
    moreinfo="none">base_eval</literal> function, which is capable of
    evaluating a base predicate.</para>

    <para>Another useful operation on expressions is simplification. The
    following is a set of simplifying construction functions that mirror the
    tags of an <literal moreinfo="none">expr</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let and_ l =</userinput>
<userinput moreinfo="none">    if List.mem l (Const false) then Const false</userinput>
<userinput moreinfo="none">    else</userinput>
<userinput moreinfo="none">      match List.filter l ~f:((&lt;&gt;) (Const true)) with</userinput>
<userinput moreinfo="none">      | [] -&gt; Const true</userinput>
<userinput moreinfo="none">      | [ x ] -&gt; x</userinput>
<userinput moreinfo="none">      | l -&gt; And l</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">  let or_ l =</userinput>
<userinput moreinfo="none">    if List.mem l (Const true) then Const true</userinput>
<userinput moreinfo="none">    else</userinput>
<userinput moreinfo="none">      match List.filter l ~f:((&lt;&gt;) (Const false)) with</userinput>
<userinput moreinfo="none">      | [] -&gt; Const false</userinput>
<userinput moreinfo="none">      | [x] -&gt; x</userinput>
<userinput moreinfo="none">      | l -&gt; Or l</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">  let not_ = function</userinput>
<userinput moreinfo="none">    | Const b -&gt; Const (not b)</userinput>
<userinput moreinfo="none">    | e -&gt; Not e</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val and_ : 'a expr list -&gt; 'a expr = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val or_ : 'a expr list -&gt; 'a expr = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can now write a simplification routine that is based on the
    preceding functions.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let rec simplify = function</userinput>
<userinput moreinfo="none">    | Base _ | Const _ as x -&gt; x</userinput>
<userinput moreinfo="none">    | And l -&gt; and_ (List.map ~f:simplify l)</userinput>
<userinput moreinfo="none">    | Or l  -&gt; or_  (List.map ~f:simplify l)</userinput>
<userinput moreinfo="none">    | Not e -&gt; not_ (simplify e)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val simplify : 'a expr -&gt; 'a expr = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can apply this to a Boolean expression and see how good a job it
    does at simplifying it:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">simplify (Not (And [ Or [Base "it's snowing"; Const true];</userinput>
<userinput moreinfo="none">                       Base "it's raining"]));;</userinput>
<computeroutput moreinfo="none">- : string expr = Not (Base "it's raining")</computeroutput></programlisting>

    <para>Here, it correctly converted the <literal
    moreinfo="none">Or</literal> branch to <literal moreinfo="none">Const
    true</literal> and then eliminated the <literal
    moreinfo="none">And</literal> entirely, since the <literal
    moreinfo="none">And</literal> then had only one nontrivial
    component.</para>

    <para>There are some simplifications it misses, however. In particular,
    see what happens if we add a double negation in:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">simplify (Not (And [ Or [Base "it's snowing"; Const true];</userinput>
<userinput moreinfo="none">                       Not (Not (Base "it's raining"))]));;</userinput>
<computeroutput moreinfo="none">- : string expr = Not (Not (Not (Base "it's raining")))</computeroutput></programlisting>

    <para>It fails to remove the double negation, and it's easy to see why.
    The <literal moreinfo="none">not_</literal> function has a catch-all case,
    so it ignores everything but the one case it explicitly considers, that of
    the negation of a constant. Catch-all cases are generally a bad idea, and
    if we make the code more explicit, we see that the missing of the double
    negation is more obvious:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let not_ = function</userinput>
<userinput moreinfo="none">    | Const b -&gt; Const (not b)</userinput>
<userinput moreinfo="none">    | (Base _ | And _ | Or _ | Not _) as e -&gt; Not e</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can of course fix this by simply adding an explicit case for
    double negation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let not_ = function</userinput>
<userinput moreinfo="none">    | Const b -&gt; Const (not b)</userinput>
<userinput moreinfo="none">    | Not e -&gt; e</userinput>
<userinput moreinfo="none">    | (Base _ | And _ | Or _ ) as e -&gt; Not e</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;</computeroutput></programlisting>

    <para>The example of a Boolean expression language is more than a toy.
    There's a module very much in this spirit in Core called <literal
    moreinfo="none">Blang</literal> (short for "Boolean language"), and it
    gets a lot of practical use in a variety of applications. The
    simplification algorithm in particular is useful when you want to use it
    to specialize the evaluation of expressions for which the evaluation of
    some of the base predicates is already known.</para>

    <para>More generally, using variants to build recursive data structures is
    a common technique, and shows up everywhere from designing little
    languages to building complex data structures.</para>
  </sect1>

  <sect1 id="polymorphic-variants">
    <title>Polymorphic Variants</title>

    <para>In addition to the ordinary variants we've seen so far, OCaml also
    supports so-called <emphasis>polymorphic variants</emphasis>. As we'll
    see, polymorphic variants are more flexible and syntactically more
    lightweight than ordinary variants, but that extra power comes at a
    cost.<indexterm class="singular">
        <primary>polymorphic variant types</primary>

        <secondary>basic syntax of</secondary>
      </indexterm><indexterm class="startofrange" id="VARTYPpoly">
        <primary>variant types</primary>

        <secondary>polymorphic</secondary>
      </indexterm></para>

    <para>Syntactically, polymorphic variants are distinguished from ordinary
    variants by the leading backtick. And unlike ordinary variants,
    polymorphic variants can be used without an explicit type
    declaration:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let three = `Int 3;;</userinput>
<computeroutput moreinfo="none">val three : [&gt; `Int of int ] = `Int 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let four = `Float 4.;;</userinput>
<computeroutput moreinfo="none">val four : [&gt; `Float of float ] = `Float 4.</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let nan = `Not_a_number;;</userinput>
<computeroutput moreinfo="none">val nan : [&gt; `Not_a_number ] = `Not_a_number</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[three; four; nan];;</userinput>
<computeroutput moreinfo="none">- : [&gt; `Float of float | `Int of int | `Not_a_number ] list =</computeroutput>
<computeroutput moreinfo="none">[`Int 3; `Float 4.; `Not_a_number]</computeroutput></programlisting>

    <para>As you can see, polymorphic variant types are inferred
    automatically, and when we combine variants with different tags, the
    compiler infers a new type that knows about all of those tags. Note that
    in the preceding example, the tag name (e.g., <literal
    moreinfo="none">`Int</literal>) matches the type name (<literal
    moreinfo="none">int</literal>). This is a common convention in
    OCaml.<indexterm class="singular">
        <primary>polymorphic variant types</primary>

        <secondary>automatic inference of</secondary>
      </indexterm></para>

    <para>The type system will complain if it sees incompatible uses of the
    same tag:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let five = `Int "five";;</userinput>
<computeroutput moreinfo="none">val five : [&gt; `Int of string ] = `Int "five"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[three; four; five];;</userinput>
<computeroutput moreinfo="none">Characters 14-18:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type [&gt; `Int of string ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         [&gt; `Float of float | `Int of int ]</computeroutput>
<computeroutput moreinfo="none">       Types for tag `Int are incompatible</computeroutput></programlisting>

    <para>The <literal moreinfo="none">&gt;</literal> at the beginning of the
    variant types above is critical because it marks the types as being open
    to combination with other variant types. We can read the type <literal
    moreinfo="none">[&gt; `Int of string | `Float of float]</literal> as
    describing a variant whose tags include <literal moreinfo="none">`Int of
    string</literal> and <literal moreinfo="none">`Float of float</literal>,
    but may include more tags as well. In other words, you can roughly
    translate <literal moreinfo="none">&gt;</literal> to mean: "these tags or
    more."</para>

    <para>OCaml will in some cases infer a variant type with <literal
    moreinfo="none">&lt;</literal>, to indicate "these tags or less," as in
    the following example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let is_positive = function</userinput>
<userinput moreinfo="none">     | `Int   x -&gt; x &gt; 0</userinput>
<userinput moreinfo="none">     | `Float x -&gt; x &gt; 0.</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val is_positive : [&lt; `Float of float | `Int of int ] -&gt; bool = &lt;fun&gt;</computeroutput></programlisting>

    <para>The <literal moreinfo="none">&lt;</literal> is there because
    <literal moreinfo="none">is_positive</literal> has no way of dealing with
    values that have tags other than <literal moreinfo="none">`Float of
    float</literal> or <literal moreinfo="none">`Int of int</literal>.</para>

    <para>We can think of these <literal moreinfo="none">&lt;</literal> and
    <literal moreinfo="none">&gt;</literal> markers as indications of upper
    and lower bounds on the tags involved. If the same set of tags are both an
    upper and a lower bound, we end up with an <emphasis>exact</emphasis>
    polymorphic variant type, which has neither marker. For example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let exact = List.filter ~f:is_positive [three;four];;</userinput>
<computeroutput moreinfo="none">val exact : [ `Float of float | `Int of int ] list = [`Int 3; `Float 4.]</computeroutput></programlisting>

    <para>Perhaps surprisingly, we can also create polymorphic variant types
    that have different upper and lower bounds. Note that <literal
    moreinfo="none">Ok</literal> and <literal moreinfo="none">Error</literal>
    in the following example come from the <literal
    moreinfo="none">Result.t</literal> type from Core:<indexterm
        class="singular">
        <primary>polymorphic variant types</primary>

        <secondary>upper/lower bounds of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 10)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let is_positive = function</userinput>
<userinput moreinfo="none">     | `Int   x -&gt; Ok (x &gt; 0)</userinput>
<userinput moreinfo="none">     | `Float x -&gt; Ok (x &gt; 0.)</userinput>
<userinput moreinfo="none">     | `Not_a_number -&gt; Error "not a number";;</userinput>
<computeroutput moreinfo="none">val is_positive :</computeroutput>
<computeroutput moreinfo="none">  [&lt; `Float of float | `Int of int | `Not_a_number ] -&gt;</computeroutput>
<computeroutput moreinfo="none">  (bool, string) Result.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.filter [three; four] ~f:(fun x -&gt;</userinput>
<userinput moreinfo="none">     match is_positive x with Error _ -&gt; false | Ok b -&gt; b);;</userinput>
<computeroutput moreinfo="none">- : [&lt; `Float of float | `Int of int | `Not_a_number &gt; `Float `Int ] list =</computeroutput>
<computeroutput moreinfo="none">[`Int 3; `Float 4.]</computeroutput></programlisting>

    <para>Here, the inferred type states that the tags can be no more than
    <literal moreinfo="none">`Float</literal>, <literal
    moreinfo="none">`Int</literal>, and <literal
    moreinfo="none">`Not_a_number</literal>, and must contain at least
    <literal moreinfo="none">`Float</literal> and <literal
    moreinfo="none">`Int</literal>. As you can already start to see,
    polymorphic variants can lead to fairly complex inferred types.</para>

    <sect2 id="example-terminal-colors-redux">
      <title>Example: Terminal Colors Redux</title>

      <para>To see how to use polymorphic variants in practice, we'll return
      to terminal colors. Imagine that we have a new terminal type that adds
      yet more colors, say, by adding an alpha channel so you can specify
      translucent colors. We could model this extended set of colors as
      follows, using an ordinary variant:<indexterm class="singular">
          <primary>polymorphic variant types</primary>

          <secondary sortas="ordinary">vs. ordinary variants</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type extended_color =</userinput>
<userinput moreinfo="none">    | Basic of basic_color * weight  (* basic colors, regular and bold *)</userinput>
<userinput moreinfo="none">    | RGB   of int * int * int       (* 6x6x6 color space *)</userinput>
<userinput moreinfo="none">    | Gray  of int                   (* 24 grayscale levels *)</userinput>
<userinput moreinfo="none">    | RGBA  of int * int * int * int (* 6x6x6x6 color space *)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type extended_color =</computeroutput>
<computeroutput moreinfo="none">    Basic of basic_color * weight</computeroutput>
<computeroutput moreinfo="none">  | RGB of int * int * int</computeroutput>
<computeroutput moreinfo="none">  | Gray of int</computeroutput>
<computeroutput moreinfo="none">  | RGBA of int * int * int * int</computeroutput></programlisting>

      <para>We want to write a function <literal
      moreinfo="none">extended_color_to_int</literal>, that works like
      <literal moreinfo="none">color_to_int</literal> for all of the old kinds
      of colors, with new logic only for handling colors that include an alpha
      channel. One might try to write such a function as follows.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let extended_color_to_int = function</userinput>
<userinput moreinfo="none">    | RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216</userinput>
<userinput moreinfo="none">    | (Basic _ | RGB _ | Gray _) as color -&gt; color_to_int color</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 154-159:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type extended_color</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type color</computeroutput></programlisting>

      <para>The code looks reasonable enough, but it leads to a type error
      because <literal moreinfo="none">extended_color</literal> and <literal
      moreinfo="none">color</literal> are in the compiler's view distinct and
      unrelated types. The compiler doesn't, for example, recognize any
      equality between the <literal moreinfo="none">Basic</literal> tag in the
      two types.</para>

      <para>What we want to do is to share tags between two different variant
      types, and polymorphic variants let us do this in a natural way. First,
      let's rewrite <literal moreinfo="none">basic_color_to_int</literal> and
      <literal moreinfo="none">color_to_int</literal> using polymorphic
      variants. The translation here is pretty straightforward:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let basic_color_to_int = function</userinput>
<userinput moreinfo="none">    | `Black -&gt; 0 | `Red     -&gt; 1 | `Green -&gt; 2 | `Yellow -&gt; 3</userinput>
<userinput moreinfo="none">    | `Blue  -&gt; 4 | `Magenta -&gt; 5 | `Cyan  -&gt; 6 | `White  -&gt; 7</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">  let color_to_int = function</userinput>
<userinput moreinfo="none">    | `Basic (basic_color,weight) -&gt;</userinput>
<userinput moreinfo="none">      let base = match weight with `Bold -&gt; 8 | `Regular -&gt; 0 in</userinput>
<userinput moreinfo="none">      base + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | `RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | `Gray i -&gt; 232 + i</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val basic_color_to_int :</computeroutput>
<computeroutput moreinfo="none">  [&lt; `Black | `Blue | `Cyan | `Green | `Magenta | `Red | `White | `Yellow ] -&gt;</computeroutput>
<computeroutput moreinfo="none">  int = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val color_to_int :</computeroutput>
<computeroutput moreinfo="none">  [&lt; `Basic of</computeroutput>
<computeroutput moreinfo="none">       [&lt; `Black</computeroutput>
<computeroutput moreinfo="none">        | `Blue</computeroutput>
<computeroutput moreinfo="none">        | `Cyan</computeroutput>
<computeroutput moreinfo="none">        | `Green</computeroutput>
<computeroutput moreinfo="none">        | `Magenta</computeroutput>
<computeroutput moreinfo="none">        | `Red</computeroutput>
<computeroutput moreinfo="none">        | `White</computeroutput>
<computeroutput moreinfo="none">        | `Yellow ] *</computeroutput>
<computeroutput moreinfo="none">       [&lt; `Bold | `Regular ]</computeroutput>
<computeroutput moreinfo="none">   | `Gray of int</computeroutput>
<computeroutput moreinfo="none">   | `RGB of int * int * int ] -&gt;</computeroutput>
<computeroutput moreinfo="none">  int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Now we can try writing <literal
      moreinfo="none">extended_color_to_int</literal>. The key issue with this
      code is that <literal moreinfo="none">extended_color_to_int</literal>
      needs to invoke <literal moreinfo="none">color_to_int</literal> with a
      narrower type, i.e., one that includes fewer tags. Written properly,
      this narrowing can be done via a pattern match. In particular, in the
      following code, the type of the variable <literal
      moreinfo="none">color</literal> includes only the tags <literal
      moreinfo="none">`Basic</literal>, <literal
      moreinfo="none">`RGB</literal>, and <literal
      moreinfo="none">`Gray</literal>, and not <literal
      moreinfo="none">`RGBA</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 14)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let extended_color_to_int = function</userinput>
<userinput moreinfo="none">    | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216</userinput>
<userinput moreinfo="none">    | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val extended_color_to_int :</computeroutput>
<computeroutput moreinfo="none">  [&lt; `Basic of</computeroutput>
<computeroutput moreinfo="none">       [&lt; `Black</computeroutput>
<computeroutput moreinfo="none">        | `Blue</computeroutput>
<computeroutput moreinfo="none">        | `Cyan</computeroutput>
<computeroutput moreinfo="none">        | `Green</computeroutput>
<computeroutput moreinfo="none">        | `Magenta</computeroutput>
<computeroutput moreinfo="none">        | `Red</computeroutput>
<computeroutput moreinfo="none">        | `White</computeroutput>
<computeroutput moreinfo="none">        | `Yellow ] *</computeroutput>
<computeroutput moreinfo="none">       [&lt; `Bold | `Regular ]</computeroutput>
<computeroutput moreinfo="none">   | `Gray of int</computeroutput>
<computeroutput moreinfo="none">   | `RGB of int * int * int</computeroutput>
<computeroutput moreinfo="none">   | `RGBA of int * int * int * int ] -&gt;</computeroutput>
<computeroutput moreinfo="none">  int = &lt;fun&gt;</computeroutput></programlisting>

      <para>The preceding code is more delicately balanced than one might
      imagine. In particular, if we use a catch-all case instead of an
      explicit enumeration of the cases, the type is no longer narrowed, and
      so compilation fails:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 15)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let extended_color_to_int = function</userinput>
<userinput moreinfo="none">    | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216</userinput>
<userinput moreinfo="none">    | color -&gt; color_to_int color</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 125-130:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type [&gt; `RGBA of int * int * int * int ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         [&lt; `Basic of</computeroutput>
<computeroutput moreinfo="none">              [&lt; `Black</computeroutput>
<computeroutput moreinfo="none">               | `Blue</computeroutput>
<computeroutput moreinfo="none">               | `Cyan</computeroutput>
<computeroutput moreinfo="none">               | `Green</computeroutput>
<computeroutput moreinfo="none">               | `Magenta</computeroutput>
<computeroutput moreinfo="none">               | `Red</computeroutput>
<computeroutput moreinfo="none">               | `White</computeroutput>
<computeroutput moreinfo="none">               | `Yellow ] *</computeroutput>
<computeroutput moreinfo="none">              [&lt; `Bold | `Regular ]</computeroutput>
<computeroutput moreinfo="none">          | `Gray of int</computeroutput>
<computeroutput moreinfo="none">          | `RGB of int * int * int ]</computeroutput>
<computeroutput moreinfo="none">       The second variant type does not allow tag(s) `RGBA</computeroutput></programlisting>

      <note role="allow_break">
        <title>Polymorphic Variants and Catch-all Cases</title>

        <para>As we saw with the definition of <literal
        moreinfo="none">is_positive</literal>, a <literal>match</literal>
        statement can lead to the inference of an upper bound on a variant
        type, limiting the possible tags to those that can be handled by the
        match. If we add a catch-all case to our <literal>match</literal>
        statement, we end up with a type with a lower bound:<indexterm
            class="singular">
            <primary>pattern matching</primary>

            <secondary>catch-all cases</secondary>
          </indexterm><indexterm class="singular">
            <primary>catch-all cases</primary>
          </indexterm><indexterm class="singular">
            <primary>polymorphic variant types</primary>

            <secondary sortas="catch-all cases">and catch-all
            cases</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
        (part 16)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let is_positive_permissive = function</userinput>
<userinput moreinfo="none">     | `Int   x -&gt; Ok (x &gt; 0)</userinput>
<userinput moreinfo="none">     | `Float x -&gt; Ok (x &gt; 0.)</userinput>
<userinput moreinfo="none">     | _ -&gt; Error "Unknown number type"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val is_positive_permissive :</computeroutput>
<computeroutput moreinfo="none">  [&gt; `Float of float | `Int of int ] -&gt; (bool, string) Result.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_positive_permissive (`Int 0);;</userinput>
<computeroutput moreinfo="none">- : (bool, string) Result.t = Ok false</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_positive_permissive (`Ratio (3,4));;</userinput>
<computeroutput moreinfo="none">- : (bool, string) Result.t = Error "Unknown number type"</computeroutput></programlisting>

        <para>Catch-all cases are error-prone even with ordinary variants, but
        they are especially so with polymorphic variants. That's because you
        have no way of bounding what tags your function might have to deal
        with. Such code is particularly vulnerable to typos. For instance, if
        code that uses <literal
        moreinfo="none">is_positive_permissive</literal> passes in <literal
        moreinfo="none">Float</literal> misspelled as <literal
        moreinfo="none">Floot</literal>, the erroneous code will compile
        without complaint:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
        (part 17)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">is_positive_permissive (`Floot 3.5);;</userinput>
<computeroutput moreinfo="none">- : (bool, string) Result.t = Error "Unknown number type"</computeroutput></programlisting>

        <para>With ordinary variants, such a typo would have been caught as an
        unknown tag. As a general matter, one should be wary about mixing
        catch-all cases and polymorphic variants.</para>
      </note>

      <para>Let's consider how we might turn our code into a proper library
      with an implementation in an <literal moreinfo="none">ml</literal> file
      and an interface in a separate <literal moreinfo="none">mli</literal>,
      as we saw in <xref linkend="files-modules-and-programs" />. Let's start
      with the <literal moreinfo="none">mli</literal>:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol/terminal_color.mli">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

type basic_color =
  [ `Black   | `Blue | `Cyan  | `Green
  | `Magenta | `Red  | `White | `Yellow ]

type color =
  [ `Basic of basic_color * [ `Bold | `Regular ]
  | `Gray of int
  | `RGB  of int * int * int ]

type extended_color =
  [ color
  | `RGBA of int * int * int * int ]

val color_to_int          : color -&gt; int
val extended_color_to_int : extended_color -&gt; int</programlisting>

      <para>Here, <literal moreinfo="none">extended_color</literal> is defined
      as an explicit extension of <literal moreinfo="none">color</literal>.
      Also, notice that we defined all of these types as exact variants. We
      can implement this library as follows:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol/terminal_color.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

type basic_color =
  [ `Black   | `Blue | `Cyan  | `Green
  | `Magenta | `Red  | `White | `Yellow ]

type color =
  [ `Basic of basic_color * [ `Bold | `Regular ]
  | `Gray of int
  | `RGB  of int * int * int ]

type extended_color =
  [ color
  | `RGBA of int * int * int * int ]

let basic_color_to_int = function
  | `Black -&gt; 0 | `Red     -&gt; 1 | `Green -&gt; 2 | `Yellow -&gt; 3
  | `Blue  -&gt; 4 | `Magenta -&gt; 5 | `Cyan  -&gt; 6 | `White  -&gt; 7

let color_to_int = function
  | `Basic (basic_color,weight) -&gt;
    let base = match weight with `Bold -&gt; 8 | `Regular -&gt; 0 in
    base + basic_color_to_int basic_color
  | `RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
  | `Gray i -&gt; 232 + i

let extended_color_to_int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | `Grey x -&gt; 2000 + x
  | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color</programlisting>

      <para>In the preceding code, we did something funny to the definition of
      <literal moreinfo="none">extended_color_to_int</literal> that underlines
      some of the downsides of polymorphic variants. In particular, we added
      some special-case handling for the color gray, rather than using
      <literal moreinfo="none">color_to_int</literal>. Unfortunately, we
      misspelled <literal moreinfo="none">Gray</literal> as <literal
      moreinfo="none">Grey</literal>. This is exactly the kind of error that
      the compiler would catch with ordinary variants, but with polymorphic
      variants, this compiles without issue. All that happened was that the
      compiler inferred a wider type for <literal
      moreinfo="none">extended_color_to_int</literal>, which happens to be
      compatible with the narrower type that was listed in the <literal
      moreinfo="none">mli</literal>.</para>

      <para>If we add an explicit type annotation to the code itself (rather
      than just in the <literal moreinfo="none">mli</literal>), then the
      compiler has enough information to warn us:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol-annotated/terminal_color.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let extended_color_to_int : extended_color -&gt; int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | `Grey x -&gt; 2000 + x
  | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color</programlisting>

      <para>In particular, the compiler will complain that the <literal
      moreinfo="none">`Grey</literal> case is unused:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol-annotated/build.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild terminal_color.native</userinput>
<computeroutput moreinfo="none">File "terminal_color.ml", line 30, characters 4-11:</computeroutput>
<computeroutput moreinfo="none">Error: This pattern matches values of type [? `Grey of 'a ]</computeroutput>
<computeroutput moreinfo="none">       but a pattern was expected which matches values of type extended_color</computeroutput>
<computeroutput moreinfo="none">       The second variant type does not allow tag(s) `Grey</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>
<?hard-pagebreak?>
      <para>Once we have type definitions at our disposal, we can revisit the
      question of how we write the pattern match that narrows the type. In
      particular, we can explicitly use the type name as part of the pattern
      match, by prefixing it with a <literal
      moreinfo="none">#</literal>:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol-fixed/terminal_color.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let extended_color_to_int : extended_color -&gt; int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | #color as color -&gt; color_to_int color</programlisting>

      <para>This is useful when you want to narrow down to a type whose
      definition is long, and you don't want the verbosity of writing the tags
      down explicitly in the match.</para>
    </sect2>

    <sect2 id="when-to-use-polymorphic-variants">
      <title>When to Use Polymorphic Variants</title>

      <para>At first glance, polymorphic variants look like a strict
      improvement over ordinary variants. You can do everything that ordinary
      variants can do, plus it's more flexible and more concise. What's not to
      like?<indexterm class="singular">
          <primary>polymorphic variant types</primary>

          <secondary sortas="ordinary">vs. ordinary variants</secondary>
        </indexterm><indexterm class="singular">
          <primary>polymorphic variant types</primary>

          <secondary>drawbacks of</secondary>
        </indexterm></para>

      <para>In reality, regular variants are the more pragmatic choice most of
      the time. That's because the flexibility of polymorphic variants comes
      at a price. Here are some of the downsides:</para>

      <variablelist>
        <varlistentry>
          <term>Complexity</term>

          <listitem>
            <para>As we've seen, the typing rules for polymorphic variants are
            a lot more complicated than they are for regular variants. This
            means that heavy use of polymorphic variants can leave you
            scratching your head trying to figure out why a given piece of
            code did or didn't compile. It can also lead to absurdly long and
            hard to decode error messages. Indeed, concision at the value
            level is often balanced out by more verbosity at the type
            level.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Error-finding</term>

          <listitem>
            <para>Polymorphic variants are type-safe, but the typing
            discipline that they impose is, by dint of its flexibility, less
            likely to catch bugs in your program.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Efficiency</term>

          <listitem>
            <para>This isn't a huge effect, but polymorphic variants are
            somewhat heavier than regular variants, and OCaml can't generate
            code for matching on polymorphic variants that is quite as
            efficient as what it generated for regular variants.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>All that said, polymorphic variants are still a useful and
      powerful feature, but it's worth understanding their limitations and how
      to use them sensibly and modestly.</para>

      <para>Probably the safest and most common use case for polymorphic
      variants is where ordinary variants would be sufficient but are
      syntactically too heavyweight. For example, you often want to create a
      variant type for encoding the inputs or outputs to a function, where
      it's not worth declaring a separate type for it. Polymorphic variants
      are very useful here, and as long as there are type annotations that
      constrain these to have explicit, exact types, this tends to work
      well.</para>
<?hard-pagebreak?>
      <para>Variants are most problematic exactly where you take full
      advantage of their power; in particular, when you take advantage of the
      ability of polymorphic variant types to overlap in the tags they
      support. This ties into OCaml's support for subtyping. As we'll discuss
      further when we cover objects in <xref linkend="objects" />, subtyping
      brings in a lot of complexity, and most of the time, that's complexity
      you want to avoid.<indexterm class="endofrange"
      startref="VARTYPpoly"></indexterm><indexterm class="endofrange"
      startref="DTvar"></indexterm></para>
    </sect2>
  </sect1>
</chapter>
