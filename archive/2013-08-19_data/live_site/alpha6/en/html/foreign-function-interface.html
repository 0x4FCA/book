<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 20. Foreign Function Interface / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha6',
                        page: 'foreign\u002Dfunction\u002Dinterface.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html" class="here">20. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="memory-representation-of-values.html">21. Memory Representation of Values</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">22. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-frontend-parsing-and-type-checking.html">23. The Compiler Frontend: Parsing and Type Checking</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-backend-byte-code-and-native-code.html">24. The Compiler Backend: Byte-code and Native-code</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 20. Foreign Function Interface</h1>
                
                

    <p id="idp10836480">
    OCaml has several options available to interact with non-OCaml code.
    The compiler can link to external system libraries via C code, and
    also produce standalone native object files that can be embedded
    within other non-OCaml applications.
  </p><section><h1 id="the-ctypes-library">The Ctypes library</h1><p id="idp10838288">
      The simplest foreign function interface in OCaml doesn't even
      require you to write any C code at all! The Ctypes library lets
      you define the C interface in pure OCaml, and the library then
      takes care of loading the C symbols and invoking the foreign
      function call.
    </p><p id="idp10838992">
      Let's dive straight into a realistic example to show you how the
      library looks. We'll create a binding to the Ncurses terminal
      toolkit, as it's widely available on most systems and doesn't have
      any complex dependencies.
    </p><aside class="note"><h1>
    Installing the Ctypes library
    </h1><p id="idp10840336">
      You'll need to install the
      <a href="https://github.com/atgreen/libffi" target="_top"><code>libffi</code></a>
      library as a prerequisite to using Ctypes. It's a fairly popular
      library and should be available in your OS package manager.
    </p><p id="idp10842048">
      A special note for Mac users: the version of
      <code>libffi</code> installed by default in MacOS X 10.8 is
      too old for some of the features that Ctypes needs. Use Homebrew
      to <code>brew install libffi</code> to get the latest
      version before installing the OCaml library.
    </p><p id="idp10844128">
      Once that's done, Ctypes is available via OPAM as usual.
    </p><pre id="idp10844592">
$ brew install libffi     # for MacOS X users
$ opam install ctypes
$ utop
# require &quot;ctypes.foreign&quot; ;;
</pre><p id="idp10845440">
      You'll also need the Ncurses library for the first example. This
      comes pre-installed on many operating systems such as MacOS X.
      Debian Linux provides it as the <code>ncurses-dev</code>
      package.
    </p></aside></section><section><h1 id="example-a-terminal-interface">Example: a terminal interface</h1><p id="idp10848192">
      Ncurses is a library to help build terminal-independent text
      interfaces in a reasonably efficient way. It's used in console
      mail clients like Mutt and Pine, and console web browsers such as
      Lynx.
    </p><p id="idp10848816">
      The full C interface is quite large and is explained in the online
      <a href="http://www.gnu.org/software/ncurses/" target="_top">documentation</a>.
      We'll just use the smaller excerpt that's shown below since we
      just want to demonstrate Ctypes in action.
    </p><div class="highlight"><pre><span class="c1">// &lt;ncurses.h&gt;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_win_st</span> <span class="n">WINDOW</span><span class="p">;</span>

<span class="n">WINDOW</span> <span class="o">*</span><span class="n">initscr</span>   <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">WINDOW</span> <span class="o">*</span><span class="n">newwin</span>    <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">endwin</span>    <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">refresh</span>   <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">wrefresh</span>  <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">mvwaddstr</span> <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</pre></div><p id="idp10851600">
      The Ncurses functions either operate on the current
      pseudo-terminal or on a window that has been created via
      <code>newwin</code>. The <code>WINDOW</code> structure
      holds the internal library state and is considered abstract
      outside of Ncurses. Ncurses clients just needs to store the
      pointer somewhere and pass it back to Ncurses library calls, which
      can then dereference its contents.
    </p><p id="idp10853808">
      Note that there are over 200 library calls in Ncurses, so we're
      only binding a select few for this example. The
      <code>initscr</code> and <code>newwin</code> create
      <code>WINDOW</code> pointers for the global and sub-windows
      respectively. The <code>mvwaddrstr</code> takes a window,
      x/y offsets and a string and writes to the screen at that
      location. The terminal is only updated after
      <code>refresh</code> or <code>wrefresh</code> are
      called.
    </p><p id="idp10858832">
      Ctypes provides an OCaml interface that lets you map these C
      functions to equivalent OCaml functions. The library takes care of
      converting OCaml function calls and arguments into the C calling
      convention, invoking the foreign call within the C library and
      finally returning the result as an OCaml value.
    </p><p id="idp10859568">
      Let's begin by defining the basic values we need, starting with
      the <code>WINDOW</code> state pointer.
    </p><div class="highlight"><pre><span class="c">(* ncurses.ml 1/3 *)</span>
<span class="k">open</span> <span class="nc">Ctypes</span>

<span class="k">type</span> <span class="n">window</span> <span class="o">=</span> <span class="kt">unit</span> <span class="n">ptr</span>
<span class="k">let</span> <span class="n">window</span> <span class="o">:</span> <span class="n">window</span> <span class="n">typ</span> <span class="o">=</span> <span class="n">ptr</span> <span class="n">void</span>
</pre></div><p id="idp10861808">
      We don't know the internal representation of the window pointer,
      so we treat it as a C void pointer. We'll improve on this later on
      in the chapter, but it's good enough for now. The second statement
      defines an OCaml value that represents the
      <code>WINDOW</code> C pointer. This value is used later in
      the Ctypes function definitions.
    </p><p id="idp10863264">
      That's all we need to invoke our first function call to
      <code>initscr</code> to initalize the terminal.
    </p><div class="highlight"><pre><span class="c">(* ncurses.ml 2/3 *)</span>
<span class="k">let</span> <span class="n">initscr</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;initscr&quot;</span> <span class="o">(</span><span class="n">void</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">window</span><span class="o">))</span>
</pre></div><p id="idp10865504">
      The <code>foreign</code> function accepts two parameters:
    </p><ul><li><p id="idp10867168">
          the C function call name, which is looked up using
          <span><em>dlsym(3)</em></span>.
        </p></li><li><p id="idp10868480">
          a value that defines the complete set of C function arguments
          and its return type. The <code>@-&gt;</code> operator
          adds an argument to the C parameter list and
          <code>returning</code> terminates the parameter list
          with the return type.
        </p></li></ul><p id="idp10870800">
      The remainder of the Ncurses binding simply expands on these
      definitions.
    </p><div class="highlight"><pre><span class="c">(* ncurses.ml 3/3 *)</span>
<span class="k">let</span> <span class="n">endwin</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;endwin&quot;</span> <span class="o">(</span><span class="n">void</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">refresh</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;refresh&quot;</span> <span class="o">(</span><span class="n">void</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">wrefresh</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;wrefresh&quot;</span> <span class="o">(</span><span class="n">window</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">newwin</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;newwin&quot;</span> 
    <span class="o">(</span><span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">window</span><span class="o">))</span>

<span class="k">let</span> <span class="n">mvwaddch</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;mvwaddch&quot;</span> 
    <span class="o">(</span><span class="n">window</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">char</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">addstr</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;addstr&quot;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">mvwaddstr</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;mvwaddstr&quot;</span>
    <span class="o">(</span><span class="n">window</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">string</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">box</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;box&quot;</span> <span class="o">(</span><span class="n">window</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">cbreak</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;cbreak&quot;</span> <span class="o">(</span><span class="n">void</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>
</pre></div><p id="idp10873456">
      These definitions are all straightforward mappings from the C
      declarations in the Ncurses header file. The scalar C types such
      as <code>int</code> come pre-defined in Ctypes. The
      <code>string</code> in these definitions maps from OCaml
      strings (which have a specific length) onto C character buffers
      (whose length is defined by a null characters).
    </p><p id="idp10875568">
      The module signature for <code>ncurses.mli</code> looks much
      like a normal OCaml signature. You can infer it directly from the
      <code>ncurses.ml</code> by running:
    </p><pre id="idp10877520">
$ ocamlfind ocamlc -i -package ctypes.foreign ncurses.mli 
</pre><p id="idp10878256">
      The OCaml signature can be customized to improve its safety for
      external callers by making some of its internals more abstract.
    </p><div class="highlight"><pre><span class="c">(* ncurses.mli *)</span>
<span class="k">type</span> <span class="n">window</span>

<span class="k">val</span> <span class="n">window</span>    <span class="o">:</span> <span class="n">window</span> <span class="nn">Ctypes</span><span class="p">.</span><span class="n">typ</span>
<span class="k">val</span> <span class="n">initscr</span>   <span class="o">:</span> <span class="kt">unit</span>   <span class="o">-&gt;</span> <span class="n">window</span>
<span class="k">val</span> <span class="n">endwin</span>    <span class="o">:</span> <span class="kt">unit</span>   <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">refresh</span>   <span class="o">:</span> <span class="kt">unit</span>   <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">wrefresh</span>  <span class="o">:</span> <span class="n">window</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">newwin</span>    <span class="o">:</span> <span class="kt">int</span>    <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">window</span>
<span class="k">val</span> <span class="n">addch</span>     <span class="o">:</span> <span class="kt">char</span>   <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">mvwaddch</span>  <span class="o">:</span> <span class="n">window</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">addstr</span>    <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">mvwaddstr</span> <span class="o">:</span> <span class="n">window</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">box</span>       <span class="o">:</span> <span class="n">window</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">cbreak</span>    <span class="o">:</span> <span class="kt">unit</span>   <span class="o">-&gt;</span> <span class="kt">unit</span>
</pre></div><p id="idp10880656">
      The <code>window</code> type is left abstract in the
      signature, ensure that window pointers can only be constructed via
      the <code>Ncurses.initscr</code> function. This prevents
      void pointers obtained from other sources from being mistakenly
      passed to an Ncurses library call.
    </p><p id="idp10882736">
      Now compile a &quot;hello world&quot; terminal drawing program to
      tie this all together.
    </p><div class="highlight"><pre><span class="c">(* hello.ml *)</span>
<span class="k">open</span> <span class="nc">Ncurses</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">main_window</span> <span class="o">=</span> <span class="n">initscr</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="n">cbreak</span> <span class="bp">()</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">small_window</span> <span class="o">=</span> <span class="n">newwin</span> <span class="mi">10</span> <span class="mi">10</span> <span class="mi">5</span> <span class="mi">5</span> <span class="k">in</span>
  <span class="n">mvwaddstr</span> <span class="n">main_window</span> <span class="mi">1</span> <span class="mi">2</span> <span class="s2">&quot;Hello&quot;</span><span class="o">;</span>
  <span class="n">mvwaddstr</span> <span class="n">small_window</span> <span class="mi">2</span> <span class="mi">2</span> <span class="s2">&quot;World&quot;</span><span class="o">;</span>
  <span class="n">box</span> <span class="n">small_window</span> <span class="mi">0</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">refresh</span> <span class="bp">()</span><span class="o">;</span>
  <span class="nn">Unix</span><span class="p">.</span><span class="n">sleep</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">wrefresh</span> <span class="n">small_window</span><span class="o">;</span>
  <span class="nn">Unix</span><span class="p">.</span><span class="n">sleep</span> <span class="mi">5</span><span class="o">;</span>
  <span class="n">endwin</span> <span class="bp">()</span>
</pre></div><p id="idp10884608">
      The <code>hello</code> executable is compiled by linking
      against the <code>ctypes.foreign</code> OCamlfind package.
    </p><pre id="idp10886512">
$ ocamlfind ocamlopt -linkpkg -package ctypes.foreign -cclib -lncurses \
    ncurses.mli ncurses.ml hello.ml -o hello
</pre><p id="idp10887296">
      Running <code>./hello</code> should now display a Hello
      World in your terminal!
    </p><p id="idp10888480">
      The command-line above includes
      <code>-cclib -lncurses</code> to make the OCaml compiler
      link the executable to the <code>ncurses</code> C library,
      which in turns makes the C symbols available to the program when
      it starts. You'll get an error when you run the binary if you omit
      that link directive.
    </p><pre id="idp10890592">
$ ocamlfind ocamlopt -linkpkg -package ctypes -package unix \
  ncurses.mli ncurses.ml hello.ml -o hello_broken
$ ./hello_broken 
Fatal error: exception Dl.DL_error(&quot;dlsym(RTLD_DEFAULT, initscr): symbol not found&quot;)
</pre><p id="idp10891600">
      Ctypes wouldn't be very useful if it were limited to only defining
      simple C types of course. It provides full support for C pointer
      arithmetic, pointer conversions, reading and writing through
      pointers, using OCaml functions as function pointers to C code, as
      well as struct and union definitions.
    </p><p id="idp10892336">
      We'll go over some of these features in more detail for the
      remainder of the chapter, using some POSIX date functions as
      running examples.
    </p></section><section><h1 id="basic-scalar-c-types">Basic scalar C types</h1><p id="idp10894112">
      First, let's look at how to define basic scalar C types. Every C
      type is represented by an OCaml equivalent via the single type
      definition below.
    </p><div class="highlight"><pre><span class="c">(* Ctypes *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span>
</pre></div><p id="idp10895664">
<code>Ctypes.typ</code> is the type of values that
      represents C types to OCaml. There are two types associated with
      each instance of <code>typ</code>:
    </p><ul><li><p id="idp10898128">
          the C type used to store and pass values to the foreign
          library.
        </p></li><li><p id="idp10899008">
          the corresponding OCaml type. The <code>'a</code> type
          parameter contains the OCaml type such that a value of type
          <code>t typ</code> is used to read and write OCaml
          values of type <code>t</code>.
        </p></li></ul><p id="idp10901920">
      There are various other uses of <code>typ</code> values
      within Ctypes.
    </p><ul><li><p id="idp10903568">
          constructing function types for binding native functions.
        </p></li><li><p id="idp10904432">
          constructing pointers for reading and writing locations in
          C-managed storage.
        </p></li><li><p id="idp10905328">
          describing the fields of arrays, structures and unions.
        </p></li></ul><p id="idp10906064">
      Here are the definitions for most of the standard C99 scalar
      types, including some platform-dependent ones.
    </p><div class="highlight"><pre><span class="c">(* Ctypes *)</span>
<span class="k">val</span> <span class="n">void</span>  <span class="o">:</span> <span class="kt">unit</span> <span class="n">typ</span>
<span class="k">val</span> <span class="kt">char</span> <span class="o">:</span> <span class="kt">char</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">schar</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">short</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span>
<span class="k">val</span> <span class="kt">int</span>   <span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">long</span>  <span class="o">:</span> <span class="n">long</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">llong</span>  <span class="o">:</span> <span class="n">llong</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">nativeint</span> <span class="o">:</span> <span class="n">nativeint</span> <span class="n">typ</span>

<span class="k">val</span> <span class="n">int8_t</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">int16_t</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">int32_t</span> <span class="o">:</span> <span class="n">int32</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">int64_t</span> <span class="o">:</span> <span class="n">int64</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">uchar</span> <span class="o">:</span> <span class="n">uchar</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">uchar</span> <span class="o">:</span> <span class="n">uchar</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">uint8_t</span> <span class="o">:</span> <span class="n">uint8</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">uint16_t</span> <span class="o">:</span> <span class="n">uint16</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">uint32_t</span> <span class="o">:</span> <span class="n">uint32</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">uint64_t</span> <span class="o">:</span> <span class="n">uint64</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">size_t</span> <span class="o">:</span> <span class="n">size_t</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">ushort</span> <span class="o">:</span> <span class="n">ushort</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">uint</span> <span class="o">:</span> <span class="n">uint</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">ulong</span> <span class="o">:</span> <span class="n">ulong</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">ullong</span> <span class="o">:</span> <span class="n">ullong</span> <span class="n">typ</span>

<span class="k">val</span> <span class="kt">float</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">double</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">typ</span>
</pre></div><p id="idp10908128">
      These values are all of type <code>'a typ</code>, where the
      function name tells you the C type, and the <code>'a</code>
      component is the OCaml representation of that C type. Most of the
      mappings are straightforward, but some of them need a bit more
      explanation.
    </p><ul><li><p id="idp10910672">
          Void values appear in OCaml as the <code>unit</code>
          type. Using <code>void</code> in an argument or result
          type specification produces an OCaml function which accepts or
          returns unit. Dereferencing a pointer to
          <code>void</code> is an error, as in C, and will raise
          the <code>IncompleteType</code> exception.
        </p></li><li><p id="idp10914560">
          The C <code>size_t</code> type is an alias for one of
          the unsigned integer types. The actual size and alignment
          requirements for <code>size_t</code> varys between
          platforms. Ctypes provides an OCaml <code>size_t</code>
          type that is aliased to the appropriate integer type.
        </p></li><li><p id="idp10917744">
          OCaml only supports double-precision floating point numbers,
          and so the C <code>float</code> and
          <code>double</code> functions both map onto the OCaml
          <code>float</code> type.
        </p></li></ul></section><section><h1 id="pointers-and-arrays">Pointers and arrays</h1><p id="idp10921856">
      Pointers are at the heart of C, so they are necessarily part of
      Ctypes, which provides support for pointer arithmetic, pointer
      conversions, reading and writing through pointers, and passing and
      returning pointers to and from functions.
    </p><p id="idp10922528">
      We've already seen a simple use of pointers in the Ncurses
      example. Let's start a new example by binding some POSIX
      functions. The <code>time</code> function returns the
      current calendar time, and has the following C signature:
    </p><p id="idp10923872">
<code>c time_t time(time_t *);</code> The first step is to
      open some of the Ctypes modules.
    </p><ul><li><p id="idp10925552">
          The <code>Ctypes</code> module provides functions for
          describing C types in OCaml.
        </p></li><li><p id="idp10927136">
          The <code>PosixTypes</code> module includes some extra
          POSIX-specific types (such as <code>time_t</code>).
        </p></li><li><p id="idp10929424">
          The <code>Foreign</code> module exposes the
          <code>foreign</code> function that makes it possible to
          invoke C functions.
        </p></li></ul><p id="idp10931616">
      We can now create a binding to <code>time</code> directly
      from the top-level.
    </p><div class="highlight"><pre><span class="o">$</span> <span class="n">utop</span>
<span class="o">#</span> <span class="n">require</span> <span class="s2">&quot;ctypes.foreign&quot;</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">open</span> <span class="nc">Ctypes</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">open</span> <span class="nc">PosixTypes</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">open</span> <span class="nc">Foreign</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">time</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;time&quot;</span> <span class="o">(</span><span class="n">ptr</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="n">time_t</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">time</span> <span class="o">:</span> <span class="n">time_t</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="n">time_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp10933984">
      The <code>foreign</code> function is the main link between
      OCaml and C. It takes two arguments: the name of the C function to
      bind, and a value describing the type of the bound function. In
      the <code>time</code> binding, the function type specifies
      one argument of type <code>ptr time_t</code> and a return
      type of <code>time_t</code>.
    </p><p id="idp10937520">
      We can now call <code>time</code> immediately in the same
      top-level. The argument is actually optional, so we'll just pass a
      null pointer that has been coerced into becoming a null pointer to
      <code>time_t</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">cur_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">(</span><span class="n">from_voidp</span> <span class="n">time_t</span> <span class="n">null</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">cur_time</span> <span class="o">:</span> <span class="n">time_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp10940640">
      Since we're going to call <code>time</code> a few times,
      let's create a wrapper function that passes the null pointer
      through.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">time'</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">time</span> <span class="o">(</span><span class="n">from_voidp</span> <span class="n">time_t</span> <span class="n">null</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">time'</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">time_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp10942960">
      Since <code>time_t</code> is an abstract type, we can't
      actually do anything useful with it directly. We need to bind a
      second function to do anything useful with the return values from
      <code>time</code>. We'll use the standard C function
      <code>difftime</code>, which has the following signature:
    </p><div class="highlight"><pre><span class="kt">double</span> <span class="n">difftime</span><span class="p">(</span><span class="kt">time_t</span><span class="p">,</span> <span class="kt">time_t</span><span class="p">);</span>
</pre></div><p id="idp10946704">
      A binding to <code>difftime</code> is sufficient to compare
      two <code>time_t</code> values.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">difftime</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;difftime&quot;</span> <span class="o">(</span><span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="n">double</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">difftime</span> <span class="o">:</span> <span class="n">time_t</span> <span class="o">-&gt;</span> <span class="n">time_t</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time'</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="nn">Unix</span><span class="p">.</span><span class="n">sleep</span> <span class="mi">2</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">time'</span> <span class="bp">()</span> <span class="k">in</span> 
  <span class="n">difftime</span> <span class="n">t2</span> <span class="n">t1</span> <span class="o">;;</span>
 <span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span>
</pre></div><section><h1 id="allocating-typed-memory-for-pointers">Allocating typed memory for pointers</h1><p id="idp10951072">
        Let's look at a slightly less trivial example where we pass a
        non-null pointer to a function. Continuing with the theme from
        earlier, we'll bind to the <code>ctime</code> function
        which converts a <code>time_t</code> value to a
        human-readable string. The C signature of
        <code>ctime</code> is as follows:
      </p><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">ctime</span><span class="p">(</span><span class="k">const</span> <span class="kt">time_t</span> <span class="o">*</span><span class="n">timep</span><span class="p">);</span>
</pre></div><p id="idp10954816">
        The corresponding binding can be written in the top-level to add
        to our growing collection.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">ctime</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;ctime&quot;</span> <span class="o">(</span><span class="n">ptr</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="kt">string</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">ctime</span> <span class="o">:</span> <span class="n">time_t</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp10956464">
        However, we can't just pass the result of
        <code>time</code> to <code>ctime</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">ctime</span> <span class="o">(</span><span class="n">time'</span> <span class="bp">()</span><span class="o">);;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="n">time_t</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span>
<span class="k">of</span> <span class="k">type</span> <span class="n">time_t</span> <span class="n">ptr</span>
</pre></div><p id="idp10959424">
        This is because <code>ctime</code> needs a pointer to the
        <code>time_t</code> rather than passing it by value. We
        thus need to allocate some memory for the
        <code>time_t</code> and obtain its memory address.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">t_ptr</span> <span class="o">=</span> <span class="n">allocate</span> <span class="n">time_t</span> <span class="o">(</span><span class="n">time'</span> <span class="bp">()</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">t_ptr</span> <span class="o">:</span> <span class="n">time_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp10963216">
        The <code>allocate</code> function takes the type of the
        memory to be allocated and the initial value, and it returns a
        suitably-typed pointer. We can now call <code>ctime</code>
        using passing the pointer as an argument:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="n">ctime</span> <span class="n">t_ptr</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;Sat Jun  8 12:20:42 2013</span><span class="se">\n</span><span class="s2">&quot;</span>
</pre></div></section><section><h1 id="using-views-to-map-complex-values">Using views to map complex values</h1><p id="idp10967584">
        While scalar types typically have a 1-1 representation, other C
        types require extra work to convert them into OCaml. Views
        create new C type descriptions that have special behaviour when
        used to read or write C values.
      </p><p id="idp10968240">
        We've already used one view in the definition of
        <code>ctime</code> earlier. The <code>string</code>
        view wraps the C type <code>char *</code> (written in
        OCaml as <code>ptr char</code>), and converts between the
        C and OCaml string representations each time the value is
        written or read.
      </p><aside class="note"><h1>
      OCaml strings versus C character buffers
      </h1><p id="idp10972432">
        Although OCaml strings may look like C character buffers from an
        interface perspective, they're very different in terms of their
        memory representations.
      </p><p id="idp10973024">
        OCaml strings are stored in the OCaml heap with a header that
        explicitly defines its length. C buffers are also fixed-length,
        but by convention a C string is terminated by a null (a
        <code>0</code> byte) character. The C string functions
        calculate their length by scanning the buffer until the first
        null character is encountered.
      </p><p id="idp10974464">
        This means you need to be careful when passing OCaml strings to
        C buffers that they don't contain any null values within the
        OCaml string, or else the C string will be rudely truncated.
      </p></aside><p id="idp10975216">
        Here are the type signatures of the view functions in Ctypes.
      </p><div class="highlight"><pre><span class="c">(* Ctypes *)</span>
<span class="k">val</span> <span class="n">view</span> <span class="o">:</span> <span class="n">read</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">write</span><span class="o">:(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">string_of_char_ptr</span> <span class="o">:</span> <span class="kt">char</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="kt">string</span>
<span class="k">val</span> <span class="n">char_ptr_of_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="n">ptr</span>
<span class="k">val</span> <span class="kt">string</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">typ</span>
</pre></div><p id="idp10976880">
        The actual definition of <code>string</code> that uses
        views is quite simple and is written using these functions.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="kt">string</span> <span class="o">=</span> 
  <span class="n">view</span> 
    <span class="o">~</span><span class="n">read</span><span class="o">:</span><span class="n">string_of_char_ptr</span> 
    <span class="o">~</span><span class="n">write</span><span class="o">:</span><span class="n">char_ptr_of_string</span> 
    <span class="o">(</span><span class="kt">char</span> <span class="n">ptr</span><span class="o">)</span>
</pre></div></section><section><h1 id="abstract-pointers">Abstract pointers</h1><p id="idp10980368">
        Abstract types are typically used to interface with
        platform-dependent definitions often found in system headers.
        For example, the type <code>pthread_t</code> is a pointer
        on some platforms, an integer on other platforms, and a
        <code>struct</code> on a third set of platforms. One way
        to deal with this is to have build-time code which interrogates
        the C type in some way to determine an appropriate
        representation. Another way is to use
        <code>abstract</code> and leave the representation opaque.
      </p><div><table summary="Caution: Abstract values can't be passed by value"><tr><td rowspan="2" width="25"><img alt="[Caution]" src="support/figs/caution.png"/></td><th>
      Abstract values can't be passed by value
      </th></tr><tr><td><p id="idp10984096">
        Although <code>pthread_t</code> is a convenient example
        since the type used to implement it varies significantly across
        platforms, it's not actually a good match for
        <code>abstract</code> since values of type
        <code>pthread_t</code> are passed and returned by value
        and so can't be fully abstract.
      </p></td></tr></table></div><div class="highlight"><pre><span class="k">val</span> <span class="n">abstract</span> <span class="o">:</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alignment</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">abstract</span> <span class="n">typ</span>
</pre></div><p id="idp10988112">
        The <code>abstract</code> function accepts size and
        alignment requirements and ensures that these are satisfied when
        this type is used in a function call.
      </p></section></section><section><h1 id="structs-and-unions">Structs and unions</h1><p id="idp10990800">
      The C constructs <code>struct</code> and
      <code>union</code> make it possible to build new types from
      existing types. Ctypes contains counterparts that work similarly.
    </p><section><h1 id="defining-a-structure">Defining a structure</h1><p id="idp10993856">
        Let's improve the timer function that we wrote earlier. The
        POSIX function <code>gettimeofday</code> retrieves the
        time with microsecond resolution. The signature of
        <code>gettimeofday</code> is as follows, including the
        structure definitions.
      </p><div class="highlight"><pre><span class="k">struct</span> <span class="n">timeval</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="n">tv_sec</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">tv_usec</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">gettimeofday</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tv</span><span class="p">);</span>
</pre></div><p id="idp10996928">
        Using Ctypes, we can describe this type as follows in our
        top-level.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">timeval</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">timeval</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">timeval</span> <span class="o">:</span> <span class="n">timeval</span> <span class="n">structure</span> <span class="n">typ</span> <span class="o">=</span> <span class="n">structure</span> <span class="s2">&quot;timeval&quot;</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">timeval</span> <span class="o">:</span> <span class="n">timeval</span> <span class="n">structure</span> <span class="n">typ</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp10998528">
        The first command defines a new OCaml type
        <code>typeval</code> that we'll use to instantiate the
        OCaml version of the <code>struct</code>. Creating a new
        OCaml type to reflect the underlying C type in this way means
        that the structure we define will be distinct from other
        structures we define elsewhere, which helps to avoid getting
        them mixed up.
      </p><p id="idp11000720">
        The second command calls <code>structure</code> to create
        a fresh structure type. At this point the structure type is
        incomplete, so we can add fields, but cannot yet use it in
        <code>foreign</code> calls.
      </p></section><section><h1 id="adding-fields-to-structures">Adding fields to structures</h1><p id="idp11004016">
        The <code>timeval</code> structure definition still
        doesn't have any fields, so we need to add those next.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">tv_sec</span>  <span class="o">=</span> <span class="n">timeval</span> <span class="o">*:*</span> <span class="n">long</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">tv_sec</span> <span class="o">:</span> <span class="o">(</span><span class="nn">Signed</span><span class="p">.</span><span class="n">long</span><span class="o">,</span> <span class="n">timeval</span> <span class="n">structure</span><span class="o">)</span> <span class="n">field</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">tv_usec</span> <span class="o">=</span> <span class="n">timeval</span> <span class="o">*:*</span> <span class="n">long</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">tv_usec</span> <span class="o">:</span> <span class="o">(</span><span class="nn">Signed</span><span class="p">.</span><span class="n">long</span><span class="o">,</span> <span class="n">timeval</span> <span class="n">structure</span><span class="o">)</span> <span class="n">field</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">seal</span> <span class="n">timeval</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp11006736">
        The <code>*:*</code> operator appends a field to the
        structure, as shown with <code>tv_sec</code> and
        <code>tv_usec</code> above. Structure fields are typed
        accessors that are associated with a particular structure, and
        they correspond to the labels in C. Note that there's no
        explicit requirement that the OCaml variable names for a field
        are the same as the corresponding C struct label names, but it
        helps avoid confusion.
      </p><p id="idp11009712">
        Every field addition mutates the structure variable and records
        a new size (the exact value of which depends on the type of the
        field that was just added). Once we <code>seal</code> the
        structure the situation is reversed: we will be able to create
        values, but adding fields to a sealed structure is an error.
      </p></section><section><h1 id="incomplete-structure-definitions">Incomplete structure definitions</h1><p id="idp11012416">
        Since <code>gettimeofday</code> needs a
        <code>struct timezone</code> pointer for its second
        argument, we also need to define a second structure type.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">timezone</span> <span class="o">;;</span>
<span class="k">type</span> <span class="n">timezone</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">timezone</span> <span class="o">:</span> <span class="n">timezone</span> <span class="n">structure</span> <span class="n">typ</span> <span class="o">=</span> <span class="n">structure</span> <span class="s2">&quot;timezone&quot;</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">timezone</span> <span class="o">:</span> <span class="n">timezone</span> <span class="n">structure</span> <span class="n">typ</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp11015472">
        We don't ever need to create <code>struct timezone</code>
        values, so we can leave this struct as incomplete without adding
        any fields or sealing it. If you ever try to use it in a
        situation where its concrete size needs to be known, the library
        will raise an <code>IncompleteType</code> exception.
      </p><p id="idp11017568">
        We're finally ready to bind to <code>gettimeofday</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">gettimeofday</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;gettimeofday&quot;</span>
    <span class="o">(</span><span class="n">ptr</span> <span class="n">timeval</span> <span class="o">@-&gt;</span> <span class="n">ptr</span> <span class="n">timezone</span> <span class="o">@-&gt;</span> <span class="n">returning_checking_errno</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">gettimeofday</span> <span class="o">:</span> <span class="n">timeval</span> <span class="n">structure</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="n">timezone</span> <span class="n">structure</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp11020064">
        There's one other new feature here: the
        <code>returning_checking_errno</code> function behaves
        like <code>returning</code>, except that it checks whether
        the bound C function modifies the C error flag. Changes to
        <code>errno</code> are mapped into OCaml exceptions by the
        <code>PosixTypes</code> module. .
      </p><p id="idp11023568">
        As before we can create a wrapper to make
        <code>gettimeofday</code> easier to use. The functions
        <code>make</code>, <code>addr</code> and
        <code>getf</code> create a structure value, retrieve the
        address of a structure value, and retrieve the value of a field
        from a structure.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">gettimeofday'</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">make</span> <span class="n">timeval</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">gettimeofday</span> <span class="o">(</span><span class="n">addr</span> <span class="n">tv</span><span class="o">)</span> <span class="o">(</span><span class="n">from_voidp</span> <span class="n">timezone</span> <span class="n">null</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">secs</span> <span class="o">=</span> <span class="nn">Signed</span><span class="p">.</span><span class="nn">Long</span><span class="p">.</span><span class="err">(</span><span class="n">to_int</span> <span class="o">(</span><span class="n">getf</span> <span class="n">tv</span> <span class="n">tv_sec</span><span class="o">))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">usecs</span> <span class="o">=</span> <span class="nn">Signed</span><span class="p">.</span><span class="nn">Long</span><span class="p">.</span><span class="err">(</span><span class="n">to_int</span> <span class="o">(</span><span class="n">getf</span> <span class="n">tv</span> <span class="n">tv_usec</span><span class="o">))</span> <span class="k">in</span>
  <span class="nn">Pervasives</span><span class="p">.</span><span class="err">(</span><span class="n">float</span> <span class="n">secs</span> <span class="o">+.</span> <span class="kt">float</span> <span class="n">usecs</span> <span class="o">/.</span> <span class="mi">1000000</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">gettimeofday</span> <span class="o">:</span> <span class="n">timeval</span> <span class="n">structure</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="n">timezone</span> <span class="n">structure</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>

<span class="o">#</span> <span class="n">gettimeofday'</span> <span class="bp">()</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">1370714234</span><span class="o">.</span><span class="mi">606070</span>
</pre></div><p id="idp11028624">
        You need to be a little careful not to get all the open modules
        mixed up here. Both Pervasives and Ctypes define different
        <code>float</code> functions. The Ctypes module we opened
        up earlier overrides the Pervasives definition. As seen above
        though, you just need to locally open Pervasives again to bring
        the usual <code>float</code> function back in scope,
      </p><section><h1 id="recap-a-time-printing-command">Recap: a time-printing command</h1><p id="idp11032016">
          We built up a lot of bindings in the earlier section, so let's
          recap them with a complete example that ties it together with
          a command-line frontend.
        </p><div class="highlight"><pre><span class="c">(* datetime.ml: display time in various formats *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">open</span> <span class="nc">Ctypes</span>
<span class="k">open</span> <span class="nc">PosixTypes</span>
<span class="k">open</span> <span class="nc">Foreign</span>

<span class="k">let</span> <span class="n">time</span>     <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;time&quot;</span> <span class="o">(</span><span class="n">ptr</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="n">time_t</span><span class="o">)</span>
<span class="k">let</span> <span class="n">difftime</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;difftime&quot;</span> <span class="o">(</span><span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="n">double</span><span class="o">)</span>
<span class="k">let</span> <span class="n">ctime</span>    <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;ctime&quot;</span> <span class="o">(</span><span class="n">ptr</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="kt">string</span><span class="o">)</span>

<span class="k">type</span> <span class="n">timeval</span>
<span class="k">let</span> <span class="n">timeval</span> <span class="o">:</span> <span class="n">timeval</span> <span class="n">structure</span> <span class="n">typ</span> <span class="o">=</span> <span class="n">structure</span> <span class="s2">&quot;timeval&quot;</span>
<span class="k">let</span> <span class="n">tv_sec</span>   <span class="o">=</span> <span class="n">timeval</span> <span class="o">*:*</span> <span class="n">long</span> 
<span class="k">let</span> <span class="n">tv_usec</span>  <span class="o">=</span> <span class="n">timeval</span> <span class="o">*:*</span> <span class="n">long</span> 
<span class="k">let</span> <span class="bp">()</span>       <span class="o">=</span> <span class="n">seal</span> <span class="n">timeval</span>

<span class="k">type</span> <span class="n">timezone</span>
<span class="k">let</span> <span class="n">timezone</span> <span class="o">:</span> <span class="n">timezone</span> <span class="n">structure</span> <span class="n">typ</span> <span class="o">=</span> <span class="n">structure</span> <span class="s2">&quot;timezone&quot;</span>

<span class="k">let</span> <span class="n">gettimeofday</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;gettimeofday&quot;</span>
    <span class="o">(</span><span class="n">ptr</span> <span class="n">timeval</span> <span class="o">@-&gt;</span> <span class="n">ptr</span> <span class="n">timezone</span> <span class="o">@-&gt;</span> <span class="n">returning_checking_errno</span> <span class="kt">int</span><span class="o">)</span>

<span class="k">let</span> <span class="n">time'</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">time</span> <span class="o">(</span><span class="n">from_voidp</span> <span class="n">time_t</span> <span class="n">null</span><span class="o">)</span>

<span class="k">let</span> <span class="n">gettimeofday'</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">make</span> <span class="n">timeval</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">gettimeofday</span> <span class="o">(</span><span class="n">addr</span> <span class="n">tv</span><span class="o">)</span> <span class="o">(</span><span class="n">from_voidp</span> <span class="n">timezone</span> <span class="n">null</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">secs</span> <span class="o">=</span> <span class="nn">Signed</span><span class="p">.</span><span class="nn">Long</span><span class="p">.</span><span class="err">(</span><span class="n">to_int</span> <span class="o">(</span><span class="n">getf</span> <span class="n">tv</span> <span class="n">tv_sec</span><span class="o">))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">usecs</span> <span class="o">=</span> <span class="nn">Signed</span><span class="p">.</span><span class="nn">Long</span><span class="p">.</span><span class="err">(</span><span class="n">to_int</span> <span class="o">(</span><span class="n">getf</span> <span class="n">tv</span> <span class="n">tv_usec</span><span class="o">))</span> <span class="k">in</span>
  <span class="nn">Pervasives</span><span class="p">.</span><span class="err">(</span><span class="n">float</span> <span class="n">secs</span> <span class="o">+.</span> <span class="kt">float</span> <span class="n">usecs</span> <span class="o">/.</span> <span class="mi">1_000_000</span><span class="o">.)</span>

<span class="k">let</span> <span class="n">float_time</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">printf</span> <span class="s2">&quot;%f%!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">gettimeofday'</span> <span class="bp">()</span><span class="o">)</span>

<span class="k">let</span> <span class="n">ascii_time</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t_ptr</span> <span class="o">=</span> <span class="n">allocate</span> <span class="n">time_t</span> <span class="o">(</span><span class="n">time'</span> <span class="bp">()</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">printf</span> <span class="s2">&quot;%s%!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">ctime</span> <span class="n">t_ptr</span><span class="o">)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Command</span> <span class="k">in</span>
  <span class="n">basic</span> <span class="o">~</span><span class="n">summary</span><span class="o">:</span><span class="s2">&quot;Display the current time in various formats&quot;</span>
    <span class="nn">Spec</span><span class="p">.</span><span class="err">(</span><span class="n">empty</span> <span class="o">+&gt;</span> <span class="n">flag</span> <span class="s2">&quot;-a&quot;</span> <span class="n">no_arg</span> <span class="o">~</span><span class="n">doc</span><span class="o">:</span><span class="s2">&quot; Human-readable output format&quot;</span><span class="o">)</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">human</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">human</span> <span class="k">then</span> <span class="n">ascii_time</span> <span class="bp">()</span> <span class="k">else</span> <span class="n">float_time</span> <span class="bp">()</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nn">Command</span><span class="p">.</span><span class="n">run</span> 
</pre></div><p id="idp11036128">
          This can be compiled as usual with ocamlfind and ocamlopt.
        </p><pre id="idp11036608">
$ ocamlfind ocamlopt -o datetime -package core -package ctypes.foreign \
  -thread -linkpkg datetime.ml
$ ./datetime -a
Sat Jun  8 19:28:59 2013
</pre><section><h1><b>
        Why do we need to use <code>returning</code>?
        </b></h1><p id="idp11038832">
          The alert reader may be curious why all these function
          definitions have to be terminated by
          <code>returning</code>.
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">time</span><span class="o">:</span> <span class="n">ptr</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="n">time_t</span>
<span class="k">val</span> <span class="n">difftime</span><span class="o">:</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="n">double</span>
</pre></div><p id="idp11041216">
          The <code>returning</code> function may appear
          superfluous here. Why couldn't we simply give the types as
          follows?
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">time</span><span class="o">:</span> <span class="n">ptr</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">time_t</span>
<span class="k">val</span> <span class="n">difftime</span><span class="o">:</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">double</span>
</pre></div><p id="idp11043552">
          The reason involves higher types and two differences between
          the way that functions are treated in OCaml and C. Functions
          are first-class values in OCaml, but not in C. For example, in
          C, it is possible to return a function pointer from a
          function, but not to return an actual function.
        </p><p id="idp11044304">
          Secondly, OCaml functions are typically defined in a curried
          style. The signature of a two-argument function is written as
          follows:
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">curried</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</pre></div><p id="idp11045872">
          but this really means
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">curried</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span>
</pre></div><p id="idp11047312">
          and the arguments can be supplied one at a time to create a
          closure. In contrast, C functions receive their arguments all
          at once. The equivalent C function type is the following:
        </p><div class="highlight"><pre><span class="kt">int</span> <span class="n">uncurried_C</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</pre></div><p id="idp11048880">
          and the arguments must always be supplied together:
        </p><div class="highlight"><pre><span class="n">uncurried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</pre></div><p id="idp11050272">
          A C function that's written in curried style looks very
          different:
        </p><div class="highlight"><pre><span class="cm">/* A function that accepts an int, and returns a function pointer that</span>
<span class="cm">   accepts a second int and returns an int. */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">function_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">function_t</span> <span class="o">*</span><span class="n">curried_C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* supply both arguments */</span>
<span class="n">curried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">);</span>

<span class="cm">/* supply one argument at a time */</span>
<span class="n">function_t</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">curried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</pre></div><p id="idp11051984">
          The OCaml type of <code>uncurried_C</code> when bound by
          Ctypes is <code>int -&gt; int -&gt; int</code>: a
          two-argument function. The OCaml type of
          <code>curried_C</code> when bound by
          <code>ctypes</code> is
          <code>int -&gt; (int -&gt; int)</code>: a one-argument
          function that returns a one-argument function.
        </p><p id="idp11056192">
          In OCaml, of course, these types are absolutely equivalent.
          Since the OCaml types are the same but the C semantics are
          quite different, we need some kind of marker to distinguish
          the cases. This is the purpose of <code>returning</code>
          in function definitions.
        </p></section></section></section><section><h1 id="defining-arrays">Defining arrays</h1><p id="idp11059136">
        Arrays in C are contiguous blocks of the same value. Any of the
        basic types defined earlier can be allocated as blocks via the
        <code>Array</code> module.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Array</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">array</span>

  <span class="k">val</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
  <span class="k">val</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">of_list</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">to_list</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
  <span class="k">val</span> <span class="n">length</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">start</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">ptr</span>
  <span class="k">val</span> <span class="n">from_ptr</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">end</span>
</pre></div><p id="idp11062016">
        The array functions are similar to the standard library
        <code>Array</code> module except that they represent flat
        C arrays instead of OCaml ones.
      </p><p id="idp11063280">
        The conversion between arrays and lists still requires copying
        the values, and can be expensive for large data structures.
        Notice that you can also convert an array into a
        <code>ptr</code> pointer to the head of buffer, which can
        be useful if you need to pass the pointer and size arguments
        separately to a C function.
      </p><p id="idp11064768">
        Unions in C are named structures that can be mapped onto the
        same underlying memory. They are also fully supported in in
        Ctypes, but we won't go into more detail here.
      </p><aside class="note"><h1>
      Lifetime of allocated Ctypes
      </h1><p id="idp11066064">
        Values allocated via Ctypes (i.e. using
        <code>allocate</code>, <code>Array.make</code> and
        so on) will not be garbage-collected as long as they are
        reachable from OCaml values. The system memory they occupy is
        freed when they do become unreachable, via a finalizer function
        registered with the GC.
      </p><p id="idp11068176">
        The definition of reachability for Ctypes values is a little
        different from conventional OCaml values though. The allocation
        functions return an OCaml-managed pointer to the value, and as
        long as some derivative pointer is still reachable by the GC,
        the value won't be collected.
      </p><p id="idp11068896">
        &quot;Derivative&quot; means a pointer that's computed from the
        original pointer via arithmetic, so a reachable reference to an
        array element or a structure field protects the whole object
        from collection.
      </p><p id="idp11069760">
        A corollary of the above rule is that pointers written into the
        C heap don't have any effect on reachability. For example, if
        you have a C-managed array of pointers to structs then you'll
        need some additional way of keeping the structs around to
        protect them from collection. You could achieve this via a
        global array of values on the OCaml side that would keep them
        live until they're no longer needed.
      </p></aside></section></section><section><h1 id="passing-functions-to-c">Passing functions to C</h1><p id="idp11072160">
      It's also straightforward to pass OCaml function values to C. The
      C standard library function <code>qsort</code> has the
      following signature that requires a function pointer to use.
    </p><div class="highlight"><pre><span class="kt">void</span> <span class="n">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
           <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">compar</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</pre></div><p id="idp11074480">
      C programmers often use <code>typedef</code> to make type
      definitions involving function pointers easier to read. Using a
      typedef, the type of <code>qsort</code> looks a little more
      palatable.
    </p><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="n">compare_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">compare_t</span> <span class="o">*</span><span class="p">);</span>
</pre></div><p id="idp11077504">
      This also happens to be a close mapping to the corresponding
      Ctypes definition. Since type descriptions are regular values, we
      can just use <code>let</code> in place of
      <code>typedef</code>. The type of <code>qsort</code>
      is defined as follows.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">compare_t</span> <span class="o">=</span> <span class="n">ptr</span> <span class="n">void</span> <span class="o">@-&gt;</span> <span class="n">ptr</span> <span class="n">void</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="kt">int</span>

<span class="k">let</span> <span class="n">qsort</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;qsort&quot;</span>
   <span class="o">(</span><span class="n">ptr</span> <span class="n">void</span> <span class="o">@-&gt;</span> <span class="n">size_t</span> <span class="o">@-&gt;</span> <span class="n">size_t</span> <span class="o">@-&gt;</span> <span class="n">funptr</span> <span class="n">compare_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="n">void</span><span class="o">)</span>
</pre></div><p id="idp11081344">
      The resulting value is a higher-order function, as shown by its
      type.
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">qsort</span><span class="o">:</span> <span class="n">void</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="n">size_t</span> <span class="o">-&gt;</span> <span class="n">size_t</span> <span class="o">-&gt;</span>
           <span class="o">(</span><span class="n">void</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="n">void</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</pre></div><p id="idp11082912">
      As before, let's define a wrapper function to make
      <code>qsort</code> easier to use. The second and third
      arguments to <code>qsort</code> specify the length (number
      of elements) of the array and the element size.
    </p><p id="idp11084928">
      Arrays created using Ctypes have a richer runtime structure than C
      arrays, so we don't need to pass size information around.
      Furthermore, we can use OCaml polymorphism in place of the unsafe
      <code>void ptr</code> type.
    </p><section><h1 id="example-a-command-line-quicksort">Example: a command-line quicksort</h1><p id="idp11087472">
        Below is a command-line tool that uses the
        <code>qsort</code> binding to sort all of the integers
        supplied on the standard input.
      </p><pre id="idp11088720">
(* qsort.ml: quicksort integers from stdin *)
open Core.Std
open Ctypes
open PosixTypes
open Foreign

let compare_t = ptr void @-&gt; ptr void @-&gt; returning int

let qsort = foreign &quot;qsort&quot;
   (ptr void @-&gt; size_t @-&gt; size_t @-&gt; funptr compare_t @-&gt; 
    returning void)

let qsort' cmp arr =
  let open Unsigned.Size_t in
  let ty = Array.element_type arr in
  let len = of_int (Array.length arr) in
  let elsize = of_int (sizeof ty) in
  let start = to_voidp (Array.start arr) in
  let compare l r = cmp (!@ (from_voidp ty l)) (!@ (from_voidp ty r)) in
  qsort start len elsize compare;
  arr

let sort_stdin () =
  In_channel.input_lines stdin
  |&gt; List.map ~f:int_of_string
  |&gt; Array.of_list int
  |&gt; qsort' Int.compare
  |&gt; Array.to_list
  |&gt; List.iter ~f:(fun a -&gt; printf &quot;%d\n&quot; a)

let () =
  Command.basic ~summary:&quot;Sort integers on standard input&quot;
    Command.Spec.empty sort_stdin
  |&gt; Command.run
</pre><p id="idp11090720">
        Compile it in the usual way with ocamlfind, but also examine the
        inferred interface of the module.
      </p><pre id="idp11091248">
$ ocamlfind ocamlopt -package core -package ctypes.foreign -thread -linkpkg \
    -o qsort qsort.ml
$ ./qsort
5
3
2
1
# press &lt;Control-D&gt; to end the standard input
1
2
3
5
$ ocamlfind ocamlopt -i -package core -package ctypes.foreign -thread qsort.ml
val compare_t : (unit Ctypes.ptr -&gt; unit Ctypes.ptr -&gt; int) Ctypes.fn
val qsort :
  unit Ctypes.ptr -&gt;
  PosixTypes.size_t -&gt;
  PosixTypes.size_t -&gt; (unit Ctypes.ptr -&gt; unit Ctypes.ptr -&gt; int) -&gt; unit
val qsort' : ('a -&gt; 'a -&gt; int) -&gt; 'a Ctypes.array -&gt; 'a Ctypes.array
val sort_stdin : unit -&gt; unit
</pre><p id="idp11092736">
        The <code>qsort'</code> wrapper function has a much more
        canonical OCaml interface than the raw binding. It accepts a
        comparator function and a Ctypes array, and returns the same
        Ctypes array. It's not strictly required that it returns the
        array since it modifies it in-place, but it makes it easier to
        chain the function using the <code>|&gt;</code> operator
        (as <code>sort_stdin</code> does in the example).
      </p><p id="idp11095664">
        Using <code>qsort'</code> to sort arrays is
        straightforward. Our example code reads the standard input as a
        list, converts it to a C array, passes it through qsort, and
        outputs the result to the standard output. Again, remember to
        not confuse the <code>Ctypes.Array</code> module with the
        <code>Core.Std.Array</code> module: the former is in scope
        since we opened <code>Ctypes</code> at the start of the
        file.
      </p></section></section><section><h1 id="learning-more-about-c-bindings">Learning more about C bindings</h1><p id="idp11100640">
      The Ctypes
      <a href="http://github.com/ocamllabs/ocaml-types" target="_top">distribution</a>
      contains a number of larger-scale examples, including:
    </p><ul><li><p id="idp11102368">
          bindings to the POSIX <code>fts</code> API which
          demonstrates C callbacks more comprehensively.
        </p></li><li><p id="idp11103936">
          a more complete Ncurses binding than the example we opened the
          chapter with.
        </p></li><li><p id="idp11104832">
          a comprehensive test suite that covers the complete library,
          and can provide useful snippets for your own bindings.
        </p></li></ul><p id="idp11105632">
      This chapter hasn't really needed you to understand the innards of
      OCaml at all. Ctypes does its best to make function bindings easy,
      but the rest of this part will also fill you in about how
      interactions with OCaml memory layout and the garbage collector
      work.
    </p><aside class="note"><h1>
    Production note
    </h1><p id="idp11107024">
      This chapter contains significant contributions from Jeremy
      Yallop.
    </p></aside></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt03.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="memory-representation-of-values.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>