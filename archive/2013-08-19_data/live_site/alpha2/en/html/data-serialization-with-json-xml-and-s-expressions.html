<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 10. Data Serialization with JSON, XML and S-Expressions / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha2',
                        page: 'data\u002Dserialization\u002Dwith\u002Djson\u002Dxml\u002Dand\u002Ds\u002Dexpressions.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-json-xml-and-s-expressions.html" class="here">10. Data Serialization with JSON, XML and S-Expressions</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 10. Data Serialization with JSON, XML and S-Expressions</h1>
                
                

    <p id="idp8692224">
    Data serialization, <span><em>i.e.</em></span> reading and writing
    program data to a sequence of bytes, is an important and common
    programming task. Sometimes you need to match someone else's data
    format (such as XML), and other times you just want to quickly dump
    some values to disk and read them back later. To this end, OCaml
    comes with several techniques for data serialization depending on
    what your problem is.
  </p><p id="idp8693408">
    We'll start off by looking at JSON and XML first, as they are very
    common third-party data formats. After that, we'll introduce some
    syntax extensions in Core that make it really easy to manipulate
    s-expressions and safe binary serialisers directly from OCaml types.
  </p><section><h1 id="json">JSON</h1><p id="idp8694976">
      JSON is a lightweight data-interchange format often used in web
      services and browsers. It is described in
      <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_top">RFC4627</a>,
      and is designed to be easy to parse and generate. You'll run into
      JSON very often when working with modern APIs, and so we'll cover
      several different ways to manipulate it in this chapter. Along the
      way we'll introduce new libraries and syntax extensions which make
      the job easier.
    </p><p id="idp8696464">
      JSON consists of just two basic structures: an unordered
      collection of key/value pairs, and an ordered list of values.
      Values can be strings, booleans, floats, integers or null. Let's
      see what an example JSON record for a book description looks like:
    </p><div class="highlight"><pre><span class="p">{</span>
  <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Real World OCaml&quot;</span><span class="p">,</span>
  <span class="nt">&quot;tags&quot;</span> <span class="p">:</span> <span class="p">[</span> <span class="s2">&quot;functional programming&quot;</span><span class="p">,</span> <span class="s2">&quot;ocaml&quot;</span><span class="p">,</span> <span class="s2">&quot;algorithms&quot;</span> <span class="p">],</span>
  <span class="nt">&quot;pages&quot;</span><span class="p">:</span> <span class="mi">450</span><span class="p">,</span>
  <span class="nt">&quot;authors&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Jason Hickey&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Google&quot;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Anil Madhavapeddy&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Cambridge&quot;</span><span class="p">},</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Yaron Minsky&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Jane Street&quot;</span><span class="p">}</span>
  <span class="p">],</span>
  <span class="nt">&quot;is_online&quot;</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div><p id="idp8698400">
      JSON values usually start with an object at the top level that
      contains a set of key/value pairs. The keys must be strings, but
      values can be any JSON type. In the example above,
      <code>tags</code> is a string list, while the
      <code>authors</code> field contains a list of records.
      Unlike OCaml lists, JSON lists can contain completely different
      JSON types within them.
    </p><p id="idp8700416">
      This free-form nature of JSON types is both a blessing and a
      curse. It's very easy to generate JSON values, but code parsing
      them also has to cope with handling subtle variations in how
      values are represented. For example, what if the
      <code>pages</code> value above is actually represented as a
      string value of <code>&quot;450&quot;</code> instead of an
      integer?
    </p><p id="idp8702416">
      Our first task is to parse the JSON into a more structured OCaml
      type so that we can use static typing more effectively. When
      manipulating JSON in Python or Ruby, you might write unit tests to
      check that you have handled unusual inputs. The OCaml model
      prefers compile-time static checking as well as unit tests. For
      example, using pattern matching can warn you if you've not checked
      that a value can be <code>Null</code> as well as contain an
      actual value.
    </p><aside class="note"><h1>
    Installing the Yojson library
    </h1><p id="idp8704976">
      There are several JSON libraries available for OCaml. For this
      chapter, we've picked the
      <a href="http://mjambon.com/yojson.html" target="_top"><code>Yojson</code></a>
      library. The easiest way to install it is by using the OPAM
      package manager (see
      <a href="">???</a> for
      installation instructions). Once OPAM is working, you will need to
      run <code>opam install yojson</code>.
    </p></aside><section><h1 id="parsing-standard-json-with-yojson">Parsing standard JSON with Yojson</h1><p id="idp8708832">
        The JSON specification has very few data types, and Yojson
        implements these in the <code>Yojson.Basic</code> module.
        The <code>json</code> type shown below is sufficient to
        express any valid JSON structure. Note that some of the types
        are recursive, so that fields can contain references to more
        JSON fields, and that it also specifically includes a
        <code>Null</code> variant for empty fields.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span> 
</pre></div><p id="idp8712496">
        Let's parse the earlier JSON string example into this type now.
        The first stop is the <code>Yojson.Basic</code>
        documentation, where we find these helpful functions:
      </p><div class="highlight"><pre><span class="k">val</span> <span class="n">from_string</span> <span class="o">:</span> <span class="o">?</span><span class="n">buf</span><span class="o">:</span><span class="nn">Bi_outbuf</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fname</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lnum</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="c">(* Read a JSON value from a string.</span>
<span class="c">  [buf] : use this buffer at will during parsing instead of creating a new one.</span>
<span class="c">  [fname] : data file name to be used in error messages. It does not have to be a real file.</span>
<span class="c">  [lnum] : number of the first line of input. Default is 1.</span>

<span class="c">val from_channel : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; in_channel -&gt; json</span>
<span class="c">(* Read a JSON value from a channel. See [from_string] for the meaning of the </span>
<span class="c">   optional arguments. *)</span>

<span class="c">val from_file : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; json</span>
<span class="c">(* Read a JSON value from a file. See [from_string] for the meaning of the optional</span>
<span class="c">   arguments. *)</span>
</pre></div><p id="idp8715520">
        When first reading these interfaces, you can generally ignore
        the optional arguments (which have the question marks in the
        type signature), as they will be filled in with sensible values.
        The signature for these values with the optional elements
        removed makes their purpose quite clear:
      </p><div class="highlight"><pre><span class="k">val</span> <span class="n">from_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">from_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">from_channel</span> <span class="o">:</span> <span class="n">in_channel</span> <span class="o">-&gt;</span> <span class="n">json</span>
</pre></div><p id="idp8717312">
        The <code>in_channel</code> constructor is from the
        original OCaml standard library, and its use is considered
        deprecated when using the Core standard library. This leaves us
        with two ways of parsing the JSON: either from a string buffer,
        or from a file on a filesystem. The next example shows both in
        action, assuming the JSON record is stored in a file called
        <span><em>book.json</em></span>:
      </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span>
  <span class="c">(* Read JSON file into an OCaml string *)</span>
  <span class="k">let</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">read_all</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Use the string JSON constructor *)</span>
  <span class="k">let</span> <span class="n">json1</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_string</span> <span class="n">buf</span> <span class="k">in</span>

  <span class="c">(* Use the file JSON constructor *)</span>
  <span class="k">let</span> <span class="n">json2</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_file</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Test that the two values are the same *)</span>
  <span class="n">print_endline</span> <span class="o">(</span><span class="k">if</span> <span class="n">json1</span> <span class="o">=</span> <span class="n">json2</span> <span class="k">then</span> <span class="s2">&quot;OK&quot;</span> <span class="k">else</span> <span class="s2">&quot;FAIL&quot;</span><span class="o">)</span>
  <span class="n">print_endline</span> <span class="o">(</span><span class="k">if</span> <span class="n">phys_equal</span> <span class="n">json1</span> <span class="n">json2</span> <span class="k">then</span> <span class="s2">&quot;FAIL&quot;</span> <span class="k">else</span> <span class="s2">&quot;OK&quot;</span><span class="o">)</span>
</pre></div><p id="idp8720720">
        The <code>from_file</code> function accepts an input
        filename and takes care of opening and closing it for you. It's
        far more common to use <code>from_string</code> to
        construct a JSON value from an OCaml <code>string</code>.
        These strings can come from a network connection (we'll see more
        of this in
        <a href="">???</a>)
        or even a database. Finally, the example checks that the two
        input mechanisms actually resulted in the same OCaml data
        structure.
      </p><section><h1><b>
      The difference between <code>=</code> and
      <code>==</code>, and <code>phys_equal</code> in Core
      </b></h1><p id="idp8726416">
        If you come from a C/C++ background, you will probably
        reflexively use <code>==</code> to test two values for
        equality. In OCaml, <code>==</code> tests for
        <span><em>physical</em></span> equality, and <code>=</code>
        tests for <span><em>structural</em></span> equality.
      </p><p id="idp8729552">
        The <code>==</code> physical equality test will match if
        two data structures have precisely the same pointer in memory.
        Two data structures that have identical contents, but are
        constructed separately, will not match using this operator. In
        the JSON example, the <code>json1</code> and
        <code>json2</code> values are not identical and so would
        fail the physical equality test.
      </p><p id="idp8732192">
        The <code>=</code> structural equality operator
        recursively inspects each field in the two values and tests them
        individually for equality. In the JSON parsing example, every
        field will be traversed and checked, and they will check out as
        equal. Crucially, if your data structure is cyclical (that is, a
        value recursively points back to another field within the same
        structure), the <code>=</code> operator will never
        terminate, and your program will hang! In this situation, you
        must use the physical equality operator, or write a custom
        comparison function that breaks the recursion.
      </p><p id="idp8734496">
        It's quite easy to mix up the use of <code>=</code> and
        <code>==</code>, so Core disables the
        <code>==</code> operator and provides
        <code>phys_equal</code> instead. You'll see a type error
        if you use <code>==</code> anywhere:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">Consider_using_phys_equal</span> <span class="o">]</span>
<span class="o">#</span> <span class="n">phys_equal</span> <span class="mi">1</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp8739040">
        If you feel like hanging your OCaml interpreter, you can verify
        what happens with recursive values for yourself:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="n">bar1</span><span class="o">:</span><span class="n">t2</span> <span class="o">}</span> <span class="ow">and</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="n">bar2</span><span class="o">:</span><span class="n">t1</span> <span class="o">}</span> <span class="o">;;</span>
<span class="k">type</span> <span class="n">t1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar1</span> <span class="o">:</span> <span class="n">t2</span><span class="o">;</span> <span class="o">}</span>
<span class="ow">and</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar2</span> <span class="o">:</span> <span class="n">t1</span><span class="o">;</span> <span class="o">}</span>
<span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">v1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">bar1</span><span class="o">=</span><span class="n">v2</span> <span class="o">}</span> <span class="ow">and</span> <span class="n">v2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">bar2</span><span class="o">=</span><span class="n">v1</span> <span class="o">};;</span> 
<span class="o">&lt;</span><span class="n">lots</span> <span class="k">of</span> <span class="n">text</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">v1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">phys_equal</span> <span class="n">v1</span> <span class="n">v1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">;;</span>
<span class="o">&lt;</span><span class="n">press</span> <span class="o">^</span><span class="nc">Z</span> <span class="ow">and</span> <span class="n">kill</span> <span class="n">the</span> <span class="n">process</span> <span class="n">now</span><span class="o">&gt;</span>
</pre></div></section><section><h1 id="selecting-values-from-json-structures">Selecting values from JSON structures</h1><p id="idp8741888">
          Now that we've figured out how to parse the example JSON, lets
          see how we can manipulate it from OCaml code with a more
          complete example.
        </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">open</span> <span class="nn">Async</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">open</span> <span class="nc">Printf</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span>
  <span class="c">(* Read the JSON file *)</span>
  <span class="k">let</span> <span class="n">json</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_file</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Locally open the JSON manipulation functions *)</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="nc">Util</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">title</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|!</span> <span class="n">member</span> <span class="s2">&quot;title&quot;</span> <span class="o">|!</span> <span class="n">to_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|!</span> <span class="n">member</span> <span class="s2">&quot;tags&quot;</span> <span class="o">|!</span> <span class="n">to_list</span> <span class="o">|!</span> <span class="n">filter_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|!</span> <span class="n">member</span> <span class="s2">&quot;pages&quot;</span> <span class="o">|!</span> <span class="n">to_int</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">is_online</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|!</span> <span class="n">member</span> <span class="s2">&quot;is_online&quot;</span> <span class="o">|!</span> <span class="n">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">is_translated</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|!</span> <span class="n">member</span> <span class="s2">&quot;is_translated&quot;</span> <span class="o">|!</span> <span class="n">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">authors</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|!</span> <span class="n">member</span> <span class="s2">&quot;authors&quot;</span> <span class="o">|!</span> <span class="n">to_list</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">authors</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|!</span> <span class="n">to_string</span><span class="o">)</span> <span class="k">in</span>

  <span class="c">(* Print the results of the parsing *)</span>
  <span class="n">printf</span> <span class="s2">&quot;Title: %s (%d)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">title</span> <span class="n">pages</span><span class="o">;</span>
  <span class="n">printf</span> <span class="s2">&quot;Authors: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;, &quot;</span> <span class="n">names</span><span class="o">);</span>
  <span class="n">printf</span> <span class="s2">&quot;Tags: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;, &quot;</span> <span class="n">tags</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">string_of_bool_option</span> <span class="o">=</span>
    <span class="k">function</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="s2">&quot;&lt;none&gt;&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="bp">true</span> <span class="o">-&gt;</span> <span class="s2">&quot;yes&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="s2">&quot;no&quot;</span> <span class="k">in</span>
  <span class="n">printf</span> <span class="s2">&quot;Online: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">string_of_bool_option</span> <span class="n">is_online</span><span class="o">);</span>
  <span class="n">printf</span> <span class="s2">&quot;Translated: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">string_of_bool_option</span> <span class="n">is_translated</span><span class="o">)</span>
</pre></div><p id="idp8744896">
          This introduces the <code>Yojson.Basic.Util</code>
          module, which contains <span><em>combinator</em></span>
          functions for JSON manipulation. Combinators are a style of
          function that can be chained together using the
          <code>|!</code> pipe operator to select and convert
          values out of the JSON structure. Let's examine some of them
          in more detail:
        </p><ul><li><p id="idp8747744">
              For the <code>title</code> string, the
              <code>member</code> combinator extracts the key from
              the array, and casts it to an OCaml string. An exception
              is raised if the JSON value is not a string.
            </p></li><li><p id="idp8749952">
              The <code>tags</code> field is similar to
              <code>title</code>, but are passed through the
              <code>to_list</code> combinator since they are a
              JSON list. The <code>filter_string</code> combinator
              folds all of the strings in the JSON list into an OCaml
              list (any non-strings also in there are simply ignored).
            </p></li><li><p id="idp8753472">
              The <code>is_online</code> and
              <code>is_translated</code> fields are optional in
              our JSON schema, and no error is raised if they are not
              present in the JSON array. The resulting OCaml type is a
              <code>string option</code> to reflect this. In our
              example, only <code>is_online</code> is present and
              <code>is_translated</code> will be
              <code>None</code>.
            </p></li></ul><p id="idp8758048">
          In the last part of the example, we simply print the parsed
          fields since they are just normal OCaml values. This technique
          of using chained parsing functions is very powerful in
          combination with the OCaml type system. Many errors that don't
          make sense at runtime (for example, mixing up lists and
          objects) will be caught statically via a type error.
        </p></section></section><section><h1 id="constructing-json-values">Constructing JSON values</h1><p id="idp8760000">
        To build and print JSON values, you can just construct values of
        type <code>json</code> and call the
        <code>to_string</code> function. There are also
        pretty-printing functions that lay out the output in a more
        human-readable style:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">[</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)</span> <span class="o">]</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">])</span> <span class="kt">list</span> <span class="o">]</span> <span class="o">=</span>
  <span class="o">`</span><span class="nc">Assoc</span> <span class="o">[(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)]</span>

<span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="n">x</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;{ </span><span class="se">\&quot;</span><span class="s2">key</span><span class="se">\&quot;</span><span class="s2">: </span><span class="se">\&quot;</span><span class="s2">value</span><span class="se">\&quot;</span><span class="s2"> }&quot;</span>

<span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_channel</span> <span class="n">stdout</span> <span class="n">x</span> <span class="o">;;</span>
<span class="o">{</span> <span class="s2">&quot;key&quot;</span><span class="o">:</span> <span class="s2">&quot;value&quot;</span> <span class="o">}</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8763088">
        In the example above, although the value that
        <code>x</code> has is compatible with the type
        <code>json</code>, it's not explicitly defined as such.
        The type inference engine will figure out a type that is based
        on how the value <code>x</code> is used, and in this case
        only the <code>Assoc</code> and <code>String</code>
        variants are present. One difficulty you will encounter is that
        type errors involving polymorphic variants can be quite verbose
        if you make a mistake in your code. For example, suppose you
        build an <code>Assoc</code> and include a single value
        instead of a list of keys:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span> <span class="o">]</span> <span class="o">=</span>
  <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)</span>

<span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="n">x</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
         <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span> <span class="o">]</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span>
       <span class="nc">Types</span> <span class="k">for</span> <span class="n">tag</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="n">are</span> <span class="n">incompatible</span>
</pre></div><p id="idp8769488">
        The type error above isn't <span><em>wrong</em></span> as such,
        but can be inconvenient to wade through for larger values. An
        easy way to narrow down this sort of type error is to add
        explicit type annotations as a compiler hint about your
        intentions:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span><span class="o">)</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">);;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
</pre></div><p id="idp8771824">
        In this case, we've marked the <code>x</code> as being of
        type <code>Yojson.Basic.json</code>, and the compiler
        immediately spots that the argument to the
        <code>Assoc</code> variant has the incorrect type. This
        illustrates the strengths and drawbacks of using polymorphic
        variants: they make it possible to easily subtype across module
        boundaries (the <code>Basic</code> and
        <code>Safe</code> in Yojson's case), but the error
        messages can be more confusing. However, a bit of careful manual
        type annotation is all it takes to make tracking down such
        issues much easier.
      </p><p id="idp8775872">
<span><em>avsm</em></span>: segway into memory representation of
        polyvariants here?
      </p><section><h1 id="using-non-standard-json-extensions">Using non-standard JSON extensions</h1><p id="idp8777616">
          The standard JSON types are <span><em>really</em></span> basic,
          and OCaml types are far more expressive. Yojson supports an
          extended JSON format for those times when you're not
          interoperating with external systems and just want a
          convenient human-readable local format. The
          <code>Yojson.Safe.json</code> type is a superset of the
          <code>Basic</code> polymorphic variant, and looks like
          this:
        </p><div class="highlight"><pre><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span> 
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Floatlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Intlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Stringlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Variant</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">json</span> <span class="n">option</span> <span class="o">]</span> 
</pre></div><p id="idp8781168">
          You should immediately be able to spot a benefit of using
          polymorphic variants here. A standard JSON type such as a
          <code>String</code> will type-check against both the
          <code>Basic</code> module and also the non-standard
          <code>Safe</code> module. However, if you use extension
          values such as <code>Tuple</code> with the
          <code>Basic</code> module, they will not be a valid
          sub-type and the compiler will complain.
        </p><p id="idp8785024">
          The extensions includes with Yojson include:
        </p><ul><li><p id="idp8786000">
              The <code>lit</code> suffix denotes that the value
              is stored as a JSON string. For example, a
              <code>Floatlit</code> will be stored as
              <code>&quot;1.234&quot;</code> instead of
              <code>1.234</code>.
            </p></li><li><p id="idp8789376">
              The <code>Tuple</code> type is stored as
              <code>(&quot;abc&quot;, 123)</code> instead of a
              list.
            </p></li><li><p id="idp8791392">
              The <code>Variant</code> type encodes OCaml variants
              more explicitly, as
              <code>&lt;&quot;Foo&quot;&gt;</code> or
              <code>&lt;&quot;Bar&quot;:123&gt;</code> for a
              variant with parameters.
            </p></li></ul><p id="idp8794080">
          The only purpose of these extensions is to make the data
          representation more expressive without having to refer to the
          original OCaml types. You can always cast a
          <code>Safe.json</code> to a
          <code>Basic.json</code> type by using the
          <code>to_basic</code> function as follows:
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">to_basic</span> <span class="o">:</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span>
<span class="c">(** Tuples are converted to JSON arrays, Variants are converted to JSON strings</span>
<span class="c">or arrays of a string (constructor) and a json value (argument). Long integers</span>
<span class="c">are converted to JSON strings.  Examples: </span>

<span class="c">`Tuple [ `Int 1; `Float 2.3 ]   -&gt;    `List [ `Int 1; `Float 2.3 ]</span>
<span class="c">`Variant (&quot;A&quot;, None)            -&gt;    `String &quot;A&quot;</span>
<span class="c">`Variant (&quot;B&quot;, Some x)          -&gt;    `List [ `String &quot;B&quot;, x ]</span>
<span class="c">`Intlit &quot;12345678901234567890&quot;  -&gt;    `String &quot;12345678901234567890&quot;</span>
<span class="c"> *)</span>
</pre></div></section></section><section><h1 id="automatically-mapping-json-to-ocaml-types">Automatically mapping JSON to OCaml types</h1><p id="idp8799184">
        The combinators described earlier make it fairly easy to extract
        fields from JSON records, but the process is still pretty
        manual. We'll talk about how to do larger-scale JSON parsing
        now, using a domain-specific language known as
        <a href="http://oss.wink.com/atdgen/" target="_top">ATD</a>.
      </p><p id="idp8800480">
        The idea behind ATD is to specify the format of the JSON in a
        separate file, and then run a compiler
        (<code>atdgen</code>) that outputs OCaml code to construct
        and parse JSON values. This means that you don't need to write
        any OCaml parsing code at all, as it will all be auto-generated
        for you.
      </p><p id="idp8801856">
        Let's go straight into looking at an example of how this works,
        by using a small portion of the Github API. Github is a popular
        code hosting and sharing website that provides a JSON-based web
        <a href="http://developer.github.com" target="_top">API</a>. The ATD
        code fragment below describes the Github authorization API. It
        is based on a pseudo-standard web protocol known as OAuth, and
        is used to authorized users to access Github services.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">scope</span> <span class="o">=</span> <span class="o">[</span>
    <span class="nc">User</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Public_repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;public_repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Repo_status</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;repo_status&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Delete_repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;delete_repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Gist</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;gist&quot;</span><span class="o">&gt;</span>
<span class="o">]</span>

<span class="k">type</span> <span class="n">app</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
<span class="o">}</span>  <span class="o">&lt;</span><span class="n">ocaml</span> <span class="n">field_prefix</span><span class="o">=</span><span class="s2">&quot;app_&quot;</span><span class="o">&gt;</span>

<span class="k">type</span> <span class="n">authorization_request</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">note</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
<span class="o">}</span> <span class="o">&lt;</span><span class="n">ocaml</span> <span class="n">field_prefix</span><span class="o">=</span><span class="s2">&quot;auth_req_&quot;</span><span class="o">&gt;</span>

<span class="k">type</span> <span class="n">authorization_response</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">token</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">app</span><span class="o">:</span> <span class="n">app</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">id</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="o">?</span><span class="n">note</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="o">?</span><span class="n">note_url</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span>
</pre></div><p id="idp8804832">
        ATD is (deliberately) similar to OCaml type definitions. Each
        field can include extra annotations to customise the parsing
        code for a particular backend. For example, the Github
        <code>scope</code> field above is defined as a variant
        type, but with the actual JSON values being defined explicitly
        (as lower-case versions).
      </p><p id="idp8806224">
        The ATD spec can be compiled to a number of OCaml targets. Let's
        run the compiler twice, to generate some OCaml type definitions,
        and a JSON serialiser.
      </p><div class="highlight"><pre><span class="nv">$ </span>atdgen -t github.atd
<span class="nv">$ </span>atdgen -j github.atd
</pre></div><p id="idp8807680">
        This will generate some new files in your current directory.
        <code>Github_t.ml</code> and
        <code>Github_t.mli</code> will contain an OCaml module
        with types defines that correspond to the ATD file. It looks
        like this:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">scope</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">User</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Public_repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Repo_status</span> 
  <span class="o">|</span> <span class="o">`</span><span class="nc">Delete_repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gist</span>
<span class="o">]</span>

<span class="k">type</span> <span class="n">app</span> <span class="o">=</span> <span class="o">{</span> 
  <span class="n">app_name</span> <span class="c">(*atd name *)</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span> 
  <span class="n">app_url</span> <span class="c">(*atd url *)</span><span class="o">:</span> <span class="kt">string</span> 
<span class="o">}</span>

<span class="k">type</span> <span class="n">authorization_request</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">auth_req_scopes</span> <span class="c">(*atd scopes *)</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">auth_req_note</span> <span class="c">(*atd note *)</span><span class="o">:</span> <span class="kt">string</span>
<span class="o">}</span>

<span class="k">type</span> <span class="n">authorization_response</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">token</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">app</span><span class="o">:</span> <span class="n">app</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">id</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="n">note</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">note_url</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span>
<span class="o">}</span>
</pre></div><p id="idp8810896">
        There is an obvious correspondence to the ATD definition. Note
        in particular that field names in separate OCaml records cannot
        shadow each other, and so we specifically prefix every field
        with a prefix to distinguish it from other records. For example,
        <code>&lt;ocaml field_prefix=&quot;auth_req_&quot;&gt;</code>
        in the ATD spec prefixes every field name in the generated
        <code>authorization_request</code> record with
        <code>auth_req</code>.
      </p><p id="idp8813552">
        The <code>Github_t</code> module only contains the type
        definitions, while <code>Github_j</code> has a concrete
        serialization module to and from JSON. You can read the
        <code>github_j.mli</code> to see the full interface, but
        the important functions for most uses are the conversion
        functions to and from a string. For our example above, this
        looks like:
      </p><div class="highlight"><pre><span class="k">val</span> <span class="n">string_of_authorization_response</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">len</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">authorization_response</span> <span class="o">-&gt;</span> <span class="kt">string</span>
  <span class="c">(** Serialize a value of type {!authorization_response}</span>
<span class="c">      into a JSON string.</span>
<span class="c">      @param len specifies the initial length </span>
<span class="c">                 of the buffer used internally.</span>
<span class="c">                 Default: 1024. *)</span>

<span class="k">val</span> <span class="n">authorization_response_of_string</span> <span class="o">:</span>
  <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">authorization_response</span>
</pre></div><p id="idp8817840">
        This is pretty convenient! We've written a single ATD file, and
        all the OCaml boilerplate to convert between JSON and a strongly
        typed record has been generated for us. You can control various
        aspects of the serializer by passing flags to
        <code>atdgen</code>. The important ones for JSON are:
      </p><ul><li><p id="idp8819664">
<code>-j-std</code>: work in standard JSON mode, and
            never print non-standard JSON extensions.
          </p></li><li><p id="idp8821168">
<code>-j-custom-fields FUNCTION</code>: call a custom
            function for every unknown field encountered, instead of
            raising a parsing exception.
          </p></li><li><p id="idp8822720">
<code>-j-defaults</code>: force the output a JSON
            value even if the specification defines it as the default
            value for that field.
          </p></li></ul><p id="idp8824144">
        The full ATD specification is quite sophisticated (and well
        documented online at its homepage). The ATD compiler can also
        target formats other than JSON, and also outputs code for other
        languages such as Java if you need more interoperability. There
        are also several similar projects you can investigate which
        automate the code generation process:
        <a href="http://piqi.org" target="_top">Piqi</a> uses the Google
        protobuf format, and
        <a href="http://thrift.apache.org" target="_top">Thrift</a> supports a
        huge variety of other programming languages.
      </p><p id="idp8826384">
        We'll also return to the Github example here later in the book
        when discussing the Async networking library, and you can find
        the full ATD specification for Github in the
        <a href="http://github.com/avsm/ocaml-github" target="_top"><code>ocaml-github</code></a>
        repository.
      </p></section></section><section><h1 id="xml">XML</h1><p id="idp8829408">
      XML is a markup language designed to store tree-structured data in
      a format that is (somewhat) human- and machine-readable. Like
      JSON, it is a textual format commonly used in web technologies,
      with a complete
      <a href="http://www.w3.org/TR/REC-xml/" target="_top">specification</a>
      available online. A complete description is beyond the scope of
      this book, but we'll explain how to manipulate it now.
    </p><aside class="note"><h1>
    Obtaining and installing XMLM
    </h1><p id="idp8831568">
      The remainder of this section uses the freely available XMLM
      library. It's easiest to obtain it via OPAM (see
      <a href="">???</a> for
      installation instructions). You need to run
      <code>opam install xmlm</code> once OPAM is installed. The
      library documentation is also readable
      <a href="http://erratique.ch/software/xmlm/doc/Xmlm" target="_top">online</a>.
    </p></aside><p id="idp8834560">
      Since XML is such a common web format, we've taken our example
      document from the
      <a href="http://duckduckgo.com" target="_top">DuckDuckGo</a> search
      engine. This is a smaller search engine than the usual suspects,
      but has the advantage of a freely available API that doesn't
      require you to register before using it. We'll talk more about how
      to use the live API later in
      <a href="">???</a>, but
      for now here's what a shortened XML search response from
      DuckDuckGo looks like:
    </p><div class="highlight"><pre><span class="o">&lt;</span><span class="nc">DuckDuckGoResponse</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">Heading</span><span class="o">&gt;</span><span class="nc">DuckDuckGo</span><span class="o">&lt;/</span><span class="nc">Heading</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">AbstractText</span><span class="o">&gt;</span><span class="nc">DuckDuckGo</span> <span class="n">is</span> <span class="n">an</span> <span class="nc">Internet</span> <span class="n">search</span> <span class="n">engine</span><span class="o">.&lt;/</span><span class="nc">AbstractText</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">AbstractURL</span><span class="o">&gt;</span><span class="n">https</span><span class="o">://</span><span class="n">en</span><span class="o">.</span><span class="n">wikipedia</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">wiki</span><span class="o">/</span><span class="nc">DuckDuckGo</span><span class="o">&lt;/</span><span class="nc">AbstractURL</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">AbstractSource</span><span class="o">&gt;</span><span class="nc">Wikipedia</span><span class="o">&lt;/</span><span class="nc">AbstractSource</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">Results</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">Result</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nc">Text</span><span class="o">&gt;</span><span class="nc">Official</span> <span class="n">site</span><span class="o">&lt;/</span><span class="nc">Text</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nc">FirstURL</span><span class="o">&gt;</span><span class="n">https</span><span class="o">://</span><span class="n">duckduckgo</span><span class="o">.</span><span class="n">com</span><span class="o">/&lt;/</span><span class="nc">FirstURL</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="nc">Result</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nc">Results</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">RelatedTopics</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="nc">RelatedTopic</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="nc">Text</span><span class="o">&gt;</span><span class="nc">Companies</span> <span class="n">based</span> <span class="k">in</span> <span class="nc">Pennsylvania</span><span class="o">&lt;/</span><span class="nc">Text</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="nc">FirstURL</span><span class="o">&gt;</span> 
     <span class="n">http</span><span class="o">://</span><span class="n">duckduckgo</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">c</span><span class="o">/</span><span class="nc">Companies_based_in_Pennsylvania</span>
   <span class="o">&lt;/</span><span class="nc">FirstURL</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="nc">RelatedTopic</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="nc">RelatedTopic</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="nc">Text</span><span class="o">&gt;</span><span class="nc">Internet</span> <span class="n">search</span> <span class="n">engines</span><span class="o">&lt;/</span><span class="nc">Text</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="nc">FirstURL</span><span class="o">&gt;</span>
     <span class="n">http</span><span class="o">://</span><span class="n">duckduckgo</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">c</span><span class="o">/</span><span class="nc">Internet_search_engines</span>
   <span class="o">&lt;/</span><span class="nc">FirstURL</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="nc">RelatedTopic</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nc">RelatedTopics</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nc">DuckDuckGoResponse</span><span class="o">&gt;</span>
</pre></div><p id="idp8838976">
      The XML document is structured as a series of
      <code>&lt;tags&gt;</code> that are closed by an end
      <code>&lt;/tag&gt;</code>. The opening tags have an optional
      set of key/value attributes and usually contain text data or
      further tags within them. If the XML document is large, we don't
      want to read the whole thing into memory before processing it.
      Luckily we don't have to, as there are two parsing strategies for
      XML: a low-level <span><em>streaming</em></span> API that parses a
      document incrementally, and a simpler but more inefficient tree
      API. We'll start with the streaming API first, as the tree API is
      built on top of it.
    </p><section><h1 id="stream-parsing-xml">Stream parsing XML</h1><p id="idp8842896">
        The XMLM documentation is a good place to read about the overall
        layout of the library. It tells us that:
      </p><div><blockquote><p id="idp8843680">
          A well-formed sequence of <code>signal</code>s
          represents an XML document tree traversal in depth-first
          order. Input pulls a well-formed sequence of
          <code>signal</code>s from a data source and output
          pushes a well-formed sequence of <code>signal</code>s to
          a data destination. Functions are provided to easily transform
          sequences of <code>signal</code>s to/from arborescent
          data structures.
        </p></blockquote></div><p id="idp8847424">
        The type of a <code>signal</code> reveals the basic
        structure of the streaming API in XMLM:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">signal</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Data</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Dtd</span> <span class="k">of</span> <span class="n">dtd</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">El_end</span> 
  <span class="o">|</span> <span class="o">`</span><span class="nc">El_start</span> <span class="k">of</span> <span class="n">tag</span> 
<span class="o">]</span>
</pre></div><p id="idp8849664">
        XMLM outputs an ordered sequence of these signals to your code
        as it parses the document. The first <code>signal</code>
        when inputting an XML document is always a
        <code>Dtd</code>. The DTD (or <span><em>document type
        description</em></span>) optionally defines which tags are
        allowed within the XML document. Some XML parsers can validate a
        document against a DTD, but XMLM is a
        <span><em>non-validating</em></span> parser that reads the DTD if
        present, but disregards its contents. The
        <code>El_start</code> and <code>El_end</code>
        signals indicate the opening and closing of tags, and
        <code>Data</code> passes the free-form information
        contained between tags.
      </p><p id="idp8855040">
        Let's take a shot at handling signals by writing the XML
        identity function that parses some XML and outputs it again.
        There is no explicit buffering required since this uses the XMLM
        streaming API.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">xml_id</span> <span class="n">i</span> <span class="n">o</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="n">depth</span> <span class="o">=</span>
    <span class="nn">Xmlm</span><span class="p">.</span><span class="n">output</span> <span class="n">o</span> <span class="o">(</span><span class="nn">Xmlm</span><span class="p">.</span><span class="n">peek</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">match</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">input</span> <span class="n">i</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">El_start</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="o">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">El_end</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="o">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">Data</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="n">depth</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">Dtd</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>
  <span class="k">in</span>
  <span class="nn">Xmlm</span><span class="p">.</span><span class="n">output</span> <span class="n">o</span> <span class="o">(</span><span class="nn">Xmlm</span><span class="p">.</span><span class="n">input</span> <span class="n">i</span><span class="o">);</span> <span class="c">(* `Dtd *)</span>
  <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">if</span> <span class="n">not</span> <span class="o">(</span><span class="nn">Xmlm</span><span class="p">.</span><span class="n">eoi</span> <span class="n">i</span><span class="o">)</span> <span class="k">then</span> <span class="n">invalid_arg</span> <span class="s2">&quot;document not well-formed&quot;</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">make_input</span> <span class="o">(`</span><span class="nc">Channel</span> <span class="o">(</span><span class="n">open_in</span> <span class="s2">&quot;ddg.xml&quot;</span><span class="o">))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">o</span> <span class="o">=</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">make_output</span> <span class="o">(`</span><span class="nc">Channel</span> <span class="n">stdout</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">xml_id</span> <span class="n">i</span> <span class="n">o</span>
</pre></div><p id="idp8857360">
        Let's start at the bottom, where we open up input and output
        channels to pass to <code>Xmlm</code> parser. The
        <code>input</code> and <code>output</code>
        constructor functions use a polymorphic variant to define the
        mechanism that the library should use to read the document.
        <code>Channel</code> is the simplest, but there are
        several others available.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">source</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Channel</span> <span class="k">of</span> <span class="n">in_channel</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Fun</span> <span class="k">of</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> 
<span class="o">]</span> 
</pre></div><p id="idp8862000">
        The <code>Fun</code> channel returns one character at a
        time as an integer, and <code>String</code> starts parsing
        an OCaml string from the given integer offset. Both of these are
        will normally be used in preference to
        <code>Channel</code>, which uses an interface that is
        deprecated in Core.
      </p><p id="idp8864768">
        The <code>xml_id</code> function begins by reading one
        signal, which will always be a <code>Dtd</code>. The
        recursive <code>pull</code> function is then invoked to
        iterate over the remaining signals. This uses
        <code>Xmlm.peek</code> to inspect the current input signal
        and immediately output it. The rest of the function is not
        strictly necessary, but it tracks that all of the tags that have
        been started via the <code>El_start</code> signal are also
        closed by a corresponding <code>El_end</code> signal. Once
        the <code>pull</code> function has finished due to the
        opening tag being closed, the <code>Xmlm.eoi</code>
        function verifies that the &quot;end of input&quot; has been
        reached.
      </p></section><section><h1 id="tree-parsing-xml">Tree parsing XML</h1><p id="idp8872736">
        Signals enforce a very iterative style of parsing XML, as your
        program has to deal with signals arriving serially. It's often
        more convenient to deal with complete XML documents directly
        in-memory as an OCaml data structure. You can convert a signal
        stream into an OCaml structure by defining the following data
        type and helper functions:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">tree</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="nc">Element</span> <span class="k">of</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">tag</span> <span class="o">*</span> <span class="n">tree</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="nc">Data</span> <span class="k">of</span> <span class="kt">string</span>

<span class="k">let</span> <span class="n">in_tree</span> <span class="n">i</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">el</span> <span class="n">tag</span> <span class="n">children</span> <span class="o">=</span> <span class="nc">Element</span> <span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">children</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">data</span> <span class="n">d</span> <span class="o">=</span> <span class="nc">Data</span> <span class="n">d</span> <span class="k">in</span>
  <span class="nn">Xmlm</span><span class="p">.</span><span class="n">input_doc_tree</span> <span class="o">~</span><span class="n">el</span> <span class="o">~</span><span class="n">data</span> <span class="n">i</span>

<span class="k">let</span> <span class="n">out_tree</span> <span class="n">o</span> <span class="n">t</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">frag</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Element</span> <span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">childs</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">`</span><span class="nc">El</span> <span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">childs</span><span class="o">)</span> 
  <span class="o">|</span> <span class="nc">Data</span> <span class="n">d</span> <span class="o">-&gt;</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">d</span> 
  <span class="k">in</span>
  <span class="nn">Xmlm</span><span class="p">.</span><span class="n">output_doc_tree</span> <span class="n">frag</span> <span class="n">o</span> <span class="n">t</span>
</pre></div><p id="idp8875024">
        The type <code>tree</code> can be pattern-matched and
        traversed like a normal OCaml data structure. Let's see how this
        works by extracting out all the &quot;Related Topics&quot; in
        the example document. First, we'll need a few helper combinator
        functions to filter through tags and trees, with the following
        signature:
      </p><div class="highlight"><pre><span class="c">(* Extract a textual name from an XML tag.</span>
<span class="c">   Discards the namespace information. *)</span>
<span class="k">val</span> <span class="n">name</span> <span class="o">:</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">tag</span> <span class="o">-&gt;</span> <span class="kt">string</span>

<span class="c">(* Filter out the contents of a tag [n] from a tagset,</span>
<span class="c">   and return the concatenated contents of all of them *)</span>
<span class="k">val</span> <span class="n">filter_tag</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">tree</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">tree</span> <span class="kt">list</span>

<span class="c">(* Given a list of [trees], concatenate all of the data contents               </span>
<span class="c">   into a string, and discard any sub-tags within it *)</span>
<span class="k">val</span> <span class="n">concat_data</span> <span class="o">:</span> <span class="n">tree</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</pre></div><p id="idp8878736">
        The implementation of these signatures fold over the
        <code>tree</code> structure to filter the tags which match
        the desired tag name. A similar version that matches on tag
        attributes is left as an exercise for you to try.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">name</span> <span class="o">((_,</span><span class="n">n</span><span class="o">),_)</span> <span class="o">=</span> <span class="n">n</span>

<span class="k">let</span> <span class="n">filter_tag</span> <span class="n">n</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="o">-&gt;</span>
    <span class="k">function</span>
    <span class="o">|</span><span class="nc">Element</span> <span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">ts</span><span class="o">)</span> <span class="k">when</span> <span class="n">name</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-&gt;</span>
      <span class="n">ts</span> <span class="o">@</span> <span class="n">acc</span>
    <span class="o">|_</span> <span class="o">-&gt;</span> <span class="n">acc</span>
  <span class="o">)</span>
     
<span class="k">let</span> <span class="n">concat_data</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="s2">&quot;&quot;</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="o">-&gt;</span>
    <span class="k">function</span>
    <span class="o">|</span><span class="nc">Data</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">^</span> <span class="n">s</span>
    <span class="o">|_</span> <span class="o">-&gt;</span> <span class="n">acc</span>                           
  <span class="o">)</span>
</pre></div><p id="idp8881472">
        (<span><em>avsm</em></span>: have we explained
        <code>fold_left</code> before this section or does it need
        a full intro?)
      </p><p id="idp8883120">
        Notice the use of a <span><em>guard pattern</em></span> in the
        <code>filter_tag</code> pattern match. This looks for an
        <code>Element</code> tag that matches the name parameter,
        and concatenates the results with the accumulator list.
      </p><p id="idp8885568">
        Once we have these helper functions, the selection of all the
        <code>&lt;Text&gt;</code> tags is a matter of chaining the
        combinators together to peform the selection over the
        <code>tree</code> data structure.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">topics</span> <span class="n">trees</span> <span class="o">=</span>
  <span class="n">filter_tag</span> <span class="s2">&quot;DuckDuckGoResponse&quot;</span> <span class="n">trees</span> <span class="o">|!</span>
  <span class="n">filter_tag</span> <span class="s2">&quot;RelatedTopics&quot;</span> <span class="o">|!</span>
  <span class="n">filter_tag</span> <span class="s2">&quot;RelatedTopic&quot;</span> <span class="o">|!</span>
  <span class="n">filter_tag</span> <span class="s2">&quot;Text&quot;</span> <span class="o">|!</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">concat_data</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">|!</span> <span class="n">print_endline</span><span class="o">)</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">make_input</span> <span class="o">(`</span><span class="nc">Channel</span> <span class="o">(</span><span class="n">open_in</span> <span class="s2">&quot;ddg.xml&quot;</span><span class="o">))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">(_,</span><span class="n">it</span><span class="o">)</span> <span class="o">=</span> <span class="n">in_tree</span> <span class="n">i</span> <span class="k">in</span>
  <span class="n">topics</span> <span class="o">[</span><span class="n">it</span><span class="o">]</span>
</pre></div><p id="idp8889072">
        The <code>filter_tag</code> combinator accepts a
        <code>tree list</code> parameter and outputs a
        <code>tree list</code>. This lets us easily chain together
        the results of one filter to another, and hence select
        hierarchical XML tags very easily. When we get to the
        <code>&lt;Text&gt;</code> tag, we iterate over all the
        results and print each one individually.
      </p></section><section><h1 id="constructing-xml-documents-using-syntax-extensions">Constructing XML documents using syntax extensions</h1><p id="idp8893936">
        In the earlier JSON chapter, we explained how to construct
        records by creating the records directly. You can do exactly the
        same thing for XML, but there is also a more automated method
        available by using OCaml's facility for syntax extensions.
      </p><p id="idp8894624">
        The OCaml distribution provides the <code>camlp4</code>
        tool for this purpose, which you can view as a type-safe
        preprocessor. Camlp4 operates by loading in a set of syntax
        extension modules that transform the Abstract Syntax Tree (AST)
        of OCaml, usually by adding nodes that generate code. We'll talk
        about how to build your own syntax extensions later in the book,
        but for now we'll describe how to <span><em>use</em></span>
        several syntax extensions that make it easier to manipulate
        external data formats such as XML.
      </p><p id="idp8896736">
        We'll use the Atom 1.0 syndication format as our example here.
        Atom feeds allow web-based programs (such as browsers) to poll a
        website for updates. The website owner publishes a feed of
        content in a standardized XML format via HTTP. This feed is then
        parsed by clients and compared against previously downloaded
        versions to determine which contents are available.
      </p><p id="idp8897552">
        Here's an example of an Atom feed:
      </p><div class="highlight"><pre><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;feed</span> <span class="na">xmlns=</span><span class="s">&quot;http://www.w3.org/2005/Atom&quot;</span><span class="nt">&gt;</span>
 <span class="nt">&lt;title&gt;</span>Example Feed<span class="nt">&lt;/title&gt;</span>
 <span class="nt">&lt;subtitle&gt;</span>A subtitle.<span class="nt">&lt;/subtitle&gt;</span>
 <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;http://example.org/feed/&quot;</span> <span class="na">rel=</span><span class="s">&quot;self&quot;</span> <span class="nt">/&gt;</span>
 <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;http://example.org/&quot;</span> <span class="nt">/&gt;</span>
 <span class="nt">&lt;id&gt;</span>urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6<span class="nt">&lt;/id&gt;</span>
 <span class="nt">&lt;updated&gt;</span>2003-12-13T18:30:02Z<span class="nt">&lt;/updated&gt;</span>

 <span class="nt">&lt;entry&gt;</span>
  <span class="nt">&lt;title&gt;</span>Atom-Powered Robots Run Amok<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;http://example.org/2003/12/13/atom03&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;alternate&quot;</span> <span class="na">type=</span><span class="s">&quot;text/html&quot;</span> <span class="na">href=</span><span class="s">&quot;http://example.org/2003/12/13/atom03.html&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;edit&quot;</span> <span class="na">href=</span><span class="s">&quot;http://example.org/2003/12/13/atom03/edit&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;id&gt;</span>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a<span class="nt">&lt;/id&gt;</span>
  <span class="nt">&lt;updated&gt;</span>2003-12-13T18:30:02Z<span class="nt">&lt;/updated&gt;</span>
  <span class="nt">&lt;summary&gt;</span>Some text.<span class="nt">&lt;/summary&gt;</span>
  <span class="nt">&lt;author&gt;</span>
    <span class="nt">&lt;name&gt;</span>John Doe<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;email&gt;</span>johndoe@example.com<span class="nt">&lt;/email&gt;</span>
  <span class="nt">&lt;/author&gt;</span>
 <span class="nt">&lt;/entry&gt;</span>
<span class="nt">&lt;/feed&gt;</span>
</pre></div><p id="idp8899792">
        We want to build this by minimising the amount of repetitive XML
        generation code. The &quot;Caml on the Web&quot; (COW) library
        provides a syntax extension that is useful here.
      </p><aside class="note"><h1>
      Installing Caml on the Web (COW)
      </h1><p id="idp8901104">
        The COW library and syntax extension can be installed via OPAM
        by <code>opam install cow</code>. There are two OCamlfind
        packages installed: the library is called <code>cow</code>
        and the syntax extension is activated with the
        <code>cow.syntax</code> package.
      </p><p id="idp8903872">
        One caveat to bear in mind is that COW isn't fully compatible
        with Core yet, and so you must use the syntax extension before
        opening the Core modules. (<span><em>avsm</em></span>: we can fix
        this easily, but note is here as a warning to reviewers).
      </p></aside><p id="idp8905088">
        Let's start to build up an Atom specification using Cow. First,
        the <code>&lt;author&gt;</code> tag can be represented
        with the following type:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">author</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">uri</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">email</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="n">xml</span>
</pre></div><p id="idp8907376">
        This is a standard record type definition with the addition of
        <code>with xml</code> at the end. This uses a syntax
        extension to signify that we wish to generate boilerplate code
        for handling this record as an XML document.
      </p><section><h1><b>
      Invoking <code>camlp4</code> syntax extensions
      </b></h1><p id="idp8910128">
        The OCaml compiler can call <code>camlp4</code>
        automatically during a compilation to preprocess the source
        files. This is specified via the <code>-pp</code> flag to
        the compiler. You don't normally need to specify this flag
        yourself. Use the <code>ocamlfind</code> utility instead
        to generate the right command-line flags for you. Here's a small
        shell script which preprocesses a source file with the COW
        syntax extension:
      </p><div class="highlight"><pre><span class="c">#!/bin/sh -x</span>

<span class="nv">file</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">lib</span><span class="o">=</span>cow.syntax
<span class="nv">bin</span><span class="o">=</span>ocamlfind
<span class="nv">args</span><span class="o">=</span><span class="sb">`</span><span class="nv">$bin</span> query -predicates syntax,preprocessor -r -format <span class="s1">'-I %d %a'</span> <span class="nv">$lib</span><span class="sb">`</span>
camlp4o -printer o <span class="nv">$args</span> <span class="nv">$file</span>
</pre></div><p id="idp8914192">
        You can supply <code>ocamlfind</code> with a number of
        different predicates to define the type of build you are running
        (preprocessing, compilation or linking). The final part of the
        script invokes the <code>camlp4o</code> binary on your ML
        source file and outputs the transformed source code to your
        terminal.
      </p></section><p id="idp8916464">
        Let's see the OCaml code that has been generated for our
        <code>author</code> record after it has been preprocessed:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">author</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">uri</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">email</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">xml_of_author</span> <span class="n">author</span> <span class="o">:</span> <span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">flatten</span>
    <span class="o">[</span> <span class="o">(</span><span class="k">match</span> <span class="k">match</span> <span class="n">author</span><span class="o">.</span><span class="n">email</span> <span class="k">with</span>
             <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
             <span class="o">|</span> <span class="nc">Some</span> <span class="n">var1</span> <span class="o">-&gt;</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">var1</span> <span class="o">]</span>
       <span class="k">with</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">El</span> <span class="o">((((</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="s2">&quot;email&quot;</span><span class="o">),</span> <span class="bp">[]</span><span class="o">)</span> <span class="o">:</span> <span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">tag</span><span class="o">),</span>
           <span class="o">(</span><span class="k">match</span> <span class="n">author</span><span class="o">.</span><span class="n">email</span> <span class="k">with</span>
            <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
            <span class="o">|</span> <span class="nc">Some</span> <span class="n">var1</span> <span class="o">-&gt;</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">var1</span> <span class="o">]))</span> <span class="o">]);</span>
      <span class="o">(</span><span class="k">match</span> <span class="k">match</span> <span class="n">author</span><span class="o">.</span><span class="n">uri</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span> <span class="o">|</span> <span class="nc">Some</span> <span class="n">var2</span> <span class="o">-&gt;</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">var2</span> <span class="o">]</span>
       <span class="k">with</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">El</span> <span class="o">((((</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="s2">&quot;uri&quot;</span><span class="o">),</span> <span class="bp">[]</span><span class="o">)</span> <span class="o">:</span> <span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">tag</span><span class="o">),</span>
           <span class="o">(</span><span class="k">match</span> <span class="n">author</span><span class="o">.</span><span class="n">uri</span> <span class="k">with</span>
             <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
             <span class="o">|</span> <span class="nc">Some</span> <span class="n">var2</span> <span class="o">-&gt;</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">var2</span> <span class="o">]))</span> <span class="o">]);</span>
      <span class="o">(</span><span class="k">match</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">author</span><span class="o">.</span><span class="n">name</span> <span class="o">]</span> <span class="k">with</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">El</span> <span class="o">((((</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="s2">&quot;name&quot;</span><span class="o">),</span> <span class="bp">[]</span><span class="o">)</span> <span class="o">:</span> <span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">tag</span><span class="o">),</span> 
         <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">author</span><span class="o">.</span><span class="n">name</span> <span class="o">])</span> <span class="o">])</span> <span class="o">]</span>
</pre></div><p id="idp8920272">
        Notice that the <code>with xml</code> clause has been
        replaced with a new <code>xml_of_author</code> function
        that has been generated for you. It accepts an
        <code>author</code> value and returns an
        <code>Xml.t</code> value. The generated code isn't really
        meant to be human-readable, but you don't normally see it when
        using the syntax extension (we've only dumped it out here to
        illustrate how <code>camlp4</code> works).
      </p><p id="idp8924608">
        If we run <code>xml_of_author</code> and convert the
        result to a human-readable string, our complete example looks
        like:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">author</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">uri</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">email</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="n">xml</span>

<span class="k">let</span> <span class="n">anil</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Anil Madhavapeddy&quot;</span><span class="o">;</span>
  <span class="n">uri</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">&quot;http://anil.recoil.org&quot;</span><span class="o">;</span>
  <span class="n">email</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">&quot;anil@recoil.org&quot;</span>
<span class="o">}</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print_endline</span> <span class="o">(</span><span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">to_string</span> <span class="o">(</span><span class="n">xml_of_author</span> <span class="n">anil</span><span class="o">))</span>
</pre></div><p id="idp8927376">
        This will generate the following XML output on the terminal when
        you execute it:
      </p><div class="highlight"><pre><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;email&gt;</span>anil@recoil.org<span class="nt">&lt;/email&gt;</span>
<span class="nt">&lt;uri&gt;</span>http://anil.recoil.org<span class="nt">&lt;/uri&gt;</span>
<span class="nt">&lt;name&gt;</span>Anil Madhavapeddy<span class="nt">&lt;/name&gt;</span>
</pre></div><p id="idp8928992">
        This is convenient, but just one small portion of Atom. How do
        we express the full Atom scheme from earlier? The answer is with
        just a few more records that match the Atom XML schema.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">author</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">uri</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">email</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="n">xml</span>

<span class="k">type</span> <span class="n">date</span> <span class="o">=</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="c">(* year, month, date, hour, minute *)</span>
<span class="k">with</span> <span class="n">xml</span>

<span class="k">let</span> <span class="n">xml_of_date</span> <span class="o">(</span><span class="n">year</span><span class="o">,</span><span class="n">month</span><span class="o">,</span><span class="n">day</span><span class="o">,</span><span class="n">hour</span><span class="o">,</span><span class="n">min</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;%.4d-%.2d-%.2dT%.2d:%.2d:00Z&quot;</span> <span class="n">year</span> <span class="n">month</span> <span class="n">day</span> <span class="n">hour</span> <span class="n">min</span> <span class="k">in</span>
  <span class="o">&lt;:</span><span class="n">xml</span><span class="o">&lt;</span> <span class="o">$</span><span class="n">str</span><span class="o">:</span><span class="n">d</span><span class="o">$</span> <span class="o">&gt;&gt;</span>

<span class="k">type</span> <span class="n">meta</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">id</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">title</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">subtitle</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">author</span><span class="o">:</span> <span class="n">author</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">rights</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">updated</span><span class="o">:</span> <span class="n">date</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="n">xml</span>
</pre></div><p id="idp8931040">
        We've now filled in more of the Atom schema with these records.
        The first problem we run into is that occasionally there is a
        mismatch between the syntax extension's idea of what the
        auto-generated XML should look like, and the reality of the
        protocol you are mapping to.
      </p><p id="idp8931760">
        The Atom date field is a good example. We define it as a tuple
        of integers, but the format mandated by the specification is
        actually a free-form text format and not XML. However, because
        the syntax extension generates normal OCaml functions, we can
        just override the <code>xml_of_date</code> function with a
        custom one which returns the correct XML fragment. Any
        references further down the module will just use our overridden
        version and ignore the auto-generated one.
      </p><p id="idp8933696">
        There's another interesting bit of new syntax in the
        <code>xml_of_date</code> function known as a
        <span><em>quotation</em></span>. OCaml not only allows code to be
        generated during pre-processing, but also to override the core
        language grammar with new constructs. The most common way of
        doing this is by embedding the custom grammars inside
        <code>&lt;:foo&lt; ... &gt;&gt;</code> tags, where
        <code>foo</code> represents the particular grammar being
        used. In the case of COW, this lets you generate XMLM-compatible
        OCaml values just by typing in XML tags.
      </p><p id="idp8937152">
        TODO antiquotations.
      </p><p id="idp8937584">
        TODO finish the atom example.
      </p></section><section><h1 id="working-with-xhtml">Working with XHTML</h1><p id="idp8939264">
        TODO use Cow.Html to generate a more complete Atom feed.
      </p></section></section><section><h1 id="serialization-with-s-expressions">Serialization with s-expressions</h1><p id="idp8941200">
      So far, we've talked about interoperating with formats that are
      usually defined by third-parties. It's also very common to just
      exchange and persist OCaml values safely, so we'll discuss how to
      do this now.
    </p><p id="idp8941840">
      S-expressions are nested paranthetical strings whose atomic values
      are strings. They were first popularized by the Lisp programming
      language in the 1960s, and have remained a simple way to encode
      data structures since then.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Sexp</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Atom</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">List</span> <span class="k">of</span> <span class="n">t</span> <span class="kt">list</span>
<span class="k">end</span>
</pre></div><p id="idp8943504">
      An s-expression is in essence a nested parenthetical list whose
      atomic values are strings. The <code>Sexp</code> module
      comes with functionality for parsing and printing s-expressions.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">sexp</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">a</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">Atom</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">l</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">List</span> <span class="n">x</span> <span class="k">in</span>
    <span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;this&quot;</span><span class="o">;</span><span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;is&quot;</span><span class="o">;</span> <span class="n">a</span> <span class="s2">&quot;an&quot;</span><span class="o">];</span> <span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;s&quot;</span><span class="o">;</span> <span class="n">a</span> <span class="s2">&quot;expression&quot;</span><span class="o">]];;</span>
<span class="k">val</span> <span class="n">sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="n">this</span> <span class="o">(</span><span class="n">is</span> <span class="n">an</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">expression</span><span class="o">))</span>
</pre></div><p id="idp8946160">
      In addition, most of the base types in Core support conversion to
      and from s-expressions. For example, we can write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Int</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">sexp_of_t</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">List</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="nn">Int</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">)</span>
</pre></div><p id="idp8948016">
      Notice that <code>List.sexp_of_t</code> is polymorphic, and
      takes as its first argument another conversion function to handle
      the elements of the list to be converted. Core uses this scheme
      more generally for defining sexp-converters for polymorphic types.
    </p><p id="idp8949376">
      But what if you want a function to convert some brand new type to
      an s-expression? You can of course write it yourself:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar</span><span class="o">:</span> <span class="kt">float</span> <span class="o">};;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">sexp_of_t</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">a</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">Atom</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">l</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">List</span> <span class="n">x</span> <span class="k">in</span>
    <span class="n">l</span> <span class="o">[</span> <span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;foo&quot;</span><span class="o">;</span> <span class="nn">Int</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="n">t</span><span class="o">.</span><span class="n">foo</span>  <span class="o">];</span>
        <span class="n">l</span> <span class="o">[</span><span class="n">a</span> <span class="s2">&quot;bar&quot;</span><span class="o">;</span> <span class="nn">Float</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="n">t</span><span class="o">.</span><span class="n">bar</span><span class="o">];</span> <span class="o">]</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">bar</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="o">.</span><span class="mi">5</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">foo</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="o">-</span><span class="mi">5</span><span class="o">.</span><span class="mi">5</span><span class="o">))</span>
</pre></div><p id="idp8951520">
      This is somewhat tiresome to write, and it gets more so when you
      consider the parser, <span><em>i.e.</em></span>,
      <code>t_of_sexp</code>, which is considerably more complex.
      Writing this kind of parsing and printing code by hand is
      mechanical and error prone, not to mention a drag.
    </p><p id="idp8953328">
      Given how mechanical the code is, you could imagine writing a
      program that inspected the type definition and auto-generated the
      conversion code for you. That is precisely where syntax extensions
      come in. Using Sexplib and adding <code>with sexp</code> as
      an annotation to our type definition, we get the functions we want
      for free.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar</span><span class="o">:</span> <span class="kt">float</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">t_of_sexp__</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">t_of_sexp</span> <span class="o">(</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">&quot;((bar 35) (foo 3))&quot;</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span><span class="n">foo</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">35</span><span class="o">.}</span>
</pre></div><p id="idp8956272">
      (You can ignore <code>t_of_sexp__</code>, which is a helper
      function that is needed in very rare cases.)
    </p><p id="idp8957472">
      The syntax-extensions in Core that we're going to discuss all have
      this same basic structure: they auto-generate code based on type
      definitions, implementing functionality that you could in theory
      have implemented by hand, but with far less programmer effort.
    </p><p id="idp8958160">
      There are several syntax extensions distributed with Core,
      including:
    </p><ul><li><p id="idp8959152">
<span><strong>Sexplib</strong></span>: provides
          serialization for s-expressions.
        </p></li><li><p id="idp8960688">
<span><strong>Bin_prot</strong></span>: provides
          serialization to an efficient binary format.
        </p></li><li><p id="idp8962240">
<span><strong>Fieldslib</strong></span>: generates
          first-class values that represent fields of a record, as well
          as accessor functions and setters for mutable record fields.
        </p></li><li><p id="idp8963872">
<span><strong>Variantslib</strong></span>: like Fieldslib
          for variants, producing first-class variants and other helper
          functions for interacting with variant types.
        </p></li><li><p id="idp8965504">
<span><strong>Pa_compare</strong></span>: generates
          efficient, type-specialized comparison functions.
        </p></li><li><p id="idp8967056">
<span><strong>Pa_typehash</strong></span>: generates a
          hash value for a type definition, <span><em>i.e.</em></span>,
          an integer that is highly unlikely to be the same for two
          distinct types.
        </p></li></ul><p id="idp8969008">
      We'll discuss each of these syntax extensions in detail, starting
      with Sexplib.
    </p></section><section><h1 id="sexplib">Sexplib</h1><section><h1 id="formatting-of-s-expressions">Formatting of s-expressions</h1><p id="idp8971920">
        Sexplib's format for s-expressions is pretty straightforward: an
        s-expression is written down as a nested parenthetical
        expression, with whitespace-separated strings as the atoms.
        Quotes are used for atoms that contain parenthesis or spaces
        themselves, backslash is the escape character, and semicolons
        are used to introduce comments. Thus, if you create the
        following file:
      </p><div class="highlight"><pre><span class="c1">;; foo.scm</span>

<span class="p">((</span><span class="nf">foo</span> <span class="mf">3.3</span><span class="p">)</span> <span class="c1">;; Shall I compare thee  to a summer's dream?</span>
 <span class="p">(</span><span class="nf">bar</span> <span class="s">&quot;this is () an \&quot; atom&quot;</span><span class="p">))</span>
</pre></div><p id="idp8973856">
        we can load it up and print it back out again:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">load_sexp</span> <span class="s2">&quot;foo.scm&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">foo</span> <span class="mi">3</span><span class="o">.</span><span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="s2">&quot;this is () an </span><span class="se">\&quot;</span><span class="s2"> atom&quot;</span><span class="o">))</span>
</pre></div><p id="idp8975408">
        Note that the comments were dropped from the file upon reading.
        This is expected, since there's no place in the
        <code>Sexp.t</code> type to store comments.
      </p><p id="idp8976688">
        If we introduce an error into our s-expression, by, say,
        deleting the open-paren in front of <code>bar</code>,
        we'll get a parse error:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Exn</span><span class="p">.</span><span class="n">handle_uncaught</span> <span class="o">~</span><span class="n">exit</span><span class="o">:</span><span class="bp">false</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">ignore</span> <span class="o">(</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">load_sexp</span> <span class="s2">&quot;foo.scm&quot;</span><span class="o">));;</span>
  <span class="nc">Uncaught</span> <span class="k">exception</span><span class="o">:</span>

  <span class="o">(</span><span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="nc">Parse_error</span>
   <span class="o">((</span><span class="n">location</span> <span class="n">parse</span><span class="o">)</span> <span class="o">(</span><span class="n">err_msg</span> <span class="s2">&quot;unexpected character: ')'&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">text_line</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">(</span><span class="n">text_char</span> <span class="mi">29</span><span class="o">)</span> <span class="o">(</span><span class="n">global_offset</span> <span class="mi">94</span><span class="o">)</span> <span class="o">(</span><span class="n">buf_pos</span> <span class="mi">94</span><span class="o">)))</span>
</pre></div><p id="idp8979216">
        (In the above, we use <code>Exn.handle_uncaught</code> to
        make sure that the exception gets printed out in full detail.)
      </p></section><section><h1 id="sexp-converters">Sexp converters</h1><p id="idp8981600">
        The most important functionality provided by Sexplib is the
        auto-generation of converters for new types. We've seen a bit of
        how this works already, but let's walk through a complete
        example. Here's the source for the beginning of a library for
        representing integer intervals.
      </p><div class="highlight"><pre><span class="c">(* file: int_interval.ml *)</span>
<span class="c">(* Module for representing closed integer intervals *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* Invariant: For any Range (x,y), y &gt; x *)</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Range</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
         <span class="o">|</span> <span class="nc">Empty</span>
<span class="k">with</span> <span class="n">sexp</span>

<span class="k">let</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="k">function</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">true</span> <span class="o">|</span> <span class="nc">Range</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>
<span class="k">let</span> <span class="n">create</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">Empty</span> <span class="k">else</span> <span class="nc">Range</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span>
<span class="k">let</span> <span class="n">contains</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">false</span>
   <span class="o">|</span> <span class="nc">Range</span> <span class="o">(</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">low</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">high</span>
</pre></div><p id="idp8983872">
        We can now use this module as follows:
      </p><div class="highlight"><pre><span class="c">(* file: test_interval.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="n">intervals</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">module</span> <span class="nc">I</span> <span class="o">=</span> <span class="nc">Int_interval</span> <span class="k">in</span>
  <span class="o">[</span> <span class="nn">I</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;</span>
    <span class="nn">I</span><span class="p">.</span><span class="n">create</span> <span class="mi">5</span> <span class="mi">4</span><span class="o">;</span> <span class="c">(* should be empty *)</span>
    <span class="nn">I</span><span class="p">.</span><span class="n">create</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">;</span>
    <span class="nn">I</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="mi">6</span><span class="o">;</span>
  <span class="o">]</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">intervals</span>
  <span class="o">|!</span> <span class="nn">List</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">sexp_of_t</span>
  <span class="o">|!</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">to_string_hum</span>
  <span class="o">|!</span> <span class="n">print_endline</span>
</pre></div><p id="idp8985568">
        But we're still missing something: we haven't created an
        <code>mli</code> for <code>Int_interval</code> yet.
        Note that we need to explicitly export the s-expression
        converters that were created within the ml. If we don't:
      </p><div class="highlight"><pre><span class="c">(* file: int_interval.mli *)</span>
<span class="c">(* Module for representing closed integer intervals *)</span>

<span class="k">type</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</pre></div><p id="idp8988752">
        then we'll get the following error:
      </p><pre id="idp8989200">
File &quot;test_interval.ml&quot;, line 15, characters 20-42:
Error: Unbound value Int_interval.sexp_of_t
Command exited with code 2.
</pre><p id="idp8990208">
        We could export the types by hand:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
</pre></div><p id="idp8991664">
        But Sexplib has a shorthand for this as well, so that we can
        instead write simply:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span> <span class="k">with</span> <span class="n">sexp</span>
</pre></div><p id="idp8993136">
        at which point <code>test_interval.ml</code> will compile
        again, and if we run it, we'll get the following output:
      </p><pre id="idp8994352">
$ ./test_interval.native
((Range 3 4) Empty (Range 2 3) (Range 1 6))
</pre><section><h1><b>
      Preserving invariants
      </b></h1><p id="idp8995776">
        One easy mistake to make when dealing with sexp converters is to
        ignore the fact that those converters can violate the invariants
        of your code. For example, the <code>Int_interval</code>
        module depends for the correctness of the
        <code>is_empty</code> check on the fact that for any value
        <code>Range (x,y)</code>, <code>y</code> is greater
        than or equal to <code>x</code>. The
        <code>create</code> function preserves this invariant, but
        the <code>t_of_sexp</code> function does not.
      </p><p id="idp9001456">
        We can fix this problem by writing a custom sexp-converter, in
        this case, using the sexp-converter that we already have:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Range</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
         <span class="o">|</span> <span class="nc">Empty</span>
<span class="k">with</span> <span class="n">sexp</span>

<span class="k">let</span> <span class="n">create</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">Empty</span> <span class="k">else</span> <span class="nc">Range</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span>

<span class="k">let</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Range</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">when</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">-&gt;</span>
    <span class="n">of_sexp_error</span> <span class="s2">&quot;Upper and lower bound of Range swapped&quot;</span> <span class="n">sexp</span>
  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Range</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">t</span>
</pre></div><p id="idp9003520">
        We call the function <code>of_sexp_error</code> to raise
        an exception because that improves the error reporting that
        Sexplib can provide when a conversion fails.
      </p></section></section><section><h1 id="getting-good-error-messages">Getting good error messages</h1><p id="idp9006192">
        There are two steps to deserializing a type from an
        s-expression: first, converting the bytes in a file to an
        s-expression, and the second, converting that s-expression into
        the type in question. One problem with this is that it can be
        hard to localize errors to the right place using this scheme.
        Consider the following example:
      </p><div class="highlight"><pre><span class="c">(* file: read_foo.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">c</span><span class="o">:</span> <span class="kt">float</span> <span class="n">option</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span>

<span class="k">let</span> <span class="n">run</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span>
    <span class="nn">Sexp</span><span class="p">.</span><span class="n">load_sexp</span> <span class="s2">&quot;foo.scm&quot;</span>
    <span class="o">|!</span> <span class="n">t_of_sexp</span>
  <span class="k">in</span>
  <span class="n">printf</span> <span class="s2">&quot;b is: %d</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">t</span><span class="o">.</span><span class="n">b</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Exn</span><span class="p">.</span><span class="n">handle_uncaught</span> <span class="o">~</span><span class="n">exit</span><span class="o">:</span><span class="bp">true</span> <span class="n">run</span>
</pre></div><p id="idp9008208">
        If you were to run this on a malformatted file, say, this one:
      </p><pre id="idp9008688">
;; foo.scm
((a not-an-integer)
 (b not-an-integer)
 (c ()))
</pre><p id="idp9009424">
        you'll get the following error:
      </p><pre id="idp9009872">
read_foo $ ./read_foo.native
Uncaught exception:

  (Sexplib.Conv.Of_sexp_error
   (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;) not-an-integer)
</pre><p id="idp9010736">
        If all you have is the error message and the string, it's not
        terribly informative. In particular, you know that the parsing
        error-ed out on the atom &quot;not-an-integer&quot;, but you
        don't know which one! In a large file, this kind of bad error
        message can be pure misery.
      </p><p id="idp9011488">
        But there's hope! If we make small change to the
        <code>run</code> function as follows:
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">run</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">load_sexp_conv_exn</span> <span class="s2">&quot;foo.scm&quot;</span> <span class="n">t_of_sexp</span> <span class="k">in</span>
  <span class="n">printf</span> <span class="s2">&quot;b is: %d</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">t</span><span class="o">.</span><span class="n">b</span>
</pre></div><p id="idp9013696">
        and run it again, we'll get the following much more helpful
        error message:
      </p><div class="highlight"><pre><span class="n">read_foo</span> <span class="o">$</span> <span class="o">./</span><span class="n">read_foo</span><span class="o">.</span><span class="n">native</span>
<span class="nc">Uncaught</span> <span class="k">exception</span><span class="o">:</span>

  <span class="o">(</span><span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Conv</span><span class="p">.</span><span class="nc">Of_sexp_error</span>
   <span class="o">(</span><span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="nn">Annotated</span><span class="p">.</span><span class="nc">Conv_exn</span> <span class="n">foo</span><span class="o">.</span><span class="n">scm</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">4</span>
    <span class="o">(</span><span class="nc">Failure</span> <span class="s2">&quot;int_of_sexp: (Failure int_of_string)&quot;</span><span class="o">))</span>
   <span class="n">not</span><span class="o">-</span><span class="n">an</span><span class="o">-</span><span class="n">integer</span><span class="o">)</span>
</pre></div><p id="idp9015424">
        In the above error, &quot;foo.scm:3:4&quot; tells us that the
        error occurred on &quot;foo.scm&quot;, line 3, character 4,
        which is a much better start for figuring out what has gone
        wrong.
      </p></section><section><h1 id="sexp-conversion-directives">Sexp-conversion directives</h1><p id="idp9017296">
        Sexplib supports a collection of directives for modifying the
        default behavior of the auto-generated sexp-converters. These
        directives allow you to customize the way in which types are
        represented as s-expressions without having to write a custom
        parser. We describe these directives below.
      </p><section><h1 id="sexp-opaque"><code>sexp-opaque</code></h1><p id="idp9019584">
          The most commonly used directive is
          <code>sexp_opaque</code>, whose purpose is to mark a
          given component of a type as being unconvertible. Anything
          marked with <code>sexp_opaque</code> will be presented
          as the atom <code>&lt;opaque&gt;</code> by the to-sexp
          converter, and will trigger an exception from the from-sexp
          converter. Note that the type of a component marked as opaque
          doesn't need to have a sexp-converter defined. Here, if we
          define a type without a sexp-converter, and then try to use it
          another type with a sexp-converter, we'll error out:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">no_converter</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">no_converter</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
<span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="n">no_converter</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">14</span><span class="o">-</span><span class="mi">26</span><span class="o">:</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="n">no_converter</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
                <span class="o">^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="n">value</span> <span class="n">no_converter_of_sexp</span>
</pre></div><p id="idp9023904">
          But with <code>sexp_opaque</code>, we won't:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="n">no_converter</span> <span class="n">sexp_opaque</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">no_converter</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="n">sexp_opaque</span><span class="o">;</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">string</span><span class="o">;</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">t_of_sexp__</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9026320">
          And if we now convert a value of this type to an s-expression,
          we'll see the contents of field <code>a</code> marked as
          opaque:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">opaque</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">b</span> <span class="n">foo</span><span class="o">))</span>
</pre></div></section><section><h1 id="sexp_option"><code>sexp_option</code></h1><p id="idp9030304">
          Another common directive is <code>sexp_opaque</code>,
          which is used to make an optional field in a record. Ordinary
          optional values are represented either as
          <code>()</code> for <code>None</code>, or as
          <code>(x)</code> for <code>Some x</code>. If you
          put an option in a record field, then the record field will
          always be required, and its value will be presented in the way
          an ordinary optional value would. For example:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="kt">int</span> <span class="n">option</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">a</span> <span class="bp">()</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">hello</span><span class="o">))</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">3</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">a</span> <span class="o">(</span><span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">b</span> <span class="n">hello</span><span class="o">))</span>
</pre></div><p id="idp9036000">
          But what if we want a field to be optional,
          <span><em>i.e.</em></span>, we want to allow it to be omitted
          from the record entirely? In that case, we can mark it with
          <code>sexp_option</code>:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">:</span> <span class="kt">int</span> <span class="n">sexp_option</span><span class="o">;</span> <span class="n">b</span><span class="o">:</span> <span class="kt">string</span> <span class="o">}</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">3</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">a</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">hello</span><span class="o">))</span>
<span class="o">#</span> <span class="n">sexp_of_t</span> <span class="o">{</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">b</span> <span class="n">hello</span><span class="o">))</span>
</pre></div></section><section><h1 id="sexp_list"><code>sexp_list</code></h1><p id="idp9040704">
          One problem with the auto-generated sexp-converters is that
          they can have more parentheses than one would ideally like.
          Consider, for example, the following variant type:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">compatible_versions</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Specific</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span>
                             <span class="o">|</span> <span class="nc">All</span>
  <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">sexp_of_compatible_versions</span> <span class="o">(</span><span class="nc">Specific</span> <span class="o">[</span><span class="s2">&quot;3.12.0&quot;</span><span class="o">;</span> <span class="s2">&quot;3.12.1&quot;</span><span class="o">;</span> <span class="s2">&quot;3.13.0&quot;</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Specific</span> <span class="o">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">12</span><span class="o">.</span><span class="mi">0</span> <span class="mi">3</span><span class="o">.</span><span class="mi">12</span><span class="o">.</span><span class="mi">1</span> <span class="mi">3</span><span class="o">.</span><span class="mi">13</span><span class="o">.</span><span class="mi">0</span><span class="o">))</span>
</pre></div><p id="idp9042544">
          You might prefer to make the syntax a bit less
          parenthesis-laden by dropping the parentheses around the list.
          <code>sexp_list</code> gives us this alternate syntax:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">compatible_versions</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Specific</span> <span class="k">of</span> <span class="kt">string</span> <span class="n">sexp_list</span>
                             <span class="o">|</span> <span class="nc">All</span>
  <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">sexp_of_compatible_versions</span> <span class="o">(</span><span class="nc">Specific</span> <span class="o">[</span><span class="s2">&quot;3.12.0&quot;</span><span class="o">;</span> <span class="s2">&quot;3.12.1&quot;</span><span class="o">;</span> <span class="s2">&quot;3.13.0&quot;</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Specific</span> <span class="mi">3</span><span class="o">.</span><span class="mi">12</span><span class="o">.</span><span class="mi">0</span> <span class="mi">3</span><span class="o">.</span><span class="mi">12</span><span class="o">.</span><span class="mi">1</span> <span class="mi">3</span><span class="o">.</span><span class="mi">13</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span>
</pre></div></section></section></section><section><h1 id="bin_prot">Bin_prot</h1><p id="idp9046512">
      S-expressions are a good serialization format when you need
      something machine-parseable as well as human readable and
      editable. But Sexplib's s-expressions are not particularly
      performant. There are a number of reasons for this. For one thing,
      s-expression serialization goes through an intermediate type,
      <code>Sexp.t</code>, which must be allocated and is then
      typically thrown away, putting non-trivial pressure on the GC. In
      addition, parsing and printing to strings in an ASCII format can
      be expensive for types like <code>int</code>s,
      <code>float</code>s and <code>Time.t</code>s where
      some real computation needs to be done to produce or parse the
      ASCII representation.
    </p><p id="idp9050384">
      Bin_prot is a library designed to address these issues by
      providing fast serialization in a compact binary format. Kicking
      off the syntax extension is done by putting
      <code>with bin_io</code>. (This looks a bit unsightly in the
      top-level because of all the definitions that are generated. We'll
      elide those definitions here, but you can see it for yourself in
      the toplevel.)
    </p><p id="idp9051888">
      Here's a small complete example of a program that can read and
      write values using bin-io. Here, the serialization is of types
      that might be used as part of a message-queue, where each message
      has a topic, some content, and a source, which is in turn a
      hostname and a port.
    </p><div class="highlight"><pre><span class="c">(* file: message_example.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* The type of a message *)</span>
<span class="k">module</span> <span class="nc">Message</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">module</span> <span class="nc">Source</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">hostname</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
               <span class="n">port</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
             <span class="o">}</span>
    <span class="k">with</span> <span class="n">bin_io</span>
  <span class="k">end</span>

  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">topic</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
             <span class="n">content</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
             <span class="n">source</span><span class="o">:</span> <span class="nn">Source</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
           <span class="o">}</span>
  <span class="k">with</span> <span class="n">bin_io</span>
<span class="k">end</span>

<span class="c">(* Create the 1st-class module providing the binability of messages *)</span>
<span class="k">let</span> <span class="n">binable</span> <span class="o">=</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Message</span> <span class="o">:</span> <span class="nn">Binable</span><span class="p">.</span><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>

<span class="c">(* Saves a message to an output channel.  The message is serialized to</span>
<span class="c">   a bigstring before being written out to the channel.  Also, a</span>
<span class="c">   binary encoding of an integer is written out to tell the reader how</span>
<span class="c">   long of a message to expect.  *)</span>
<span class="k">let</span> <span class="n">save_message</span> <span class="n">outc</span> <span class="n">msg</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Binable</span><span class="p">.</span><span class="n">to_bigstring</span> <span class="n">binable</span> <span class="n">msg</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">Bigstring</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span> <span class="k">in</span>
  <span class="nn">Out_channel</span><span class="p">.</span><span class="n">output_binary_int</span> <span class="n">outc</span> <span class="n">len</span><span class="o">;</span>
  <span class="nn">Bigstring</span><span class="p">.</span><span class="n">really_output</span> <span class="n">outc</span> <span class="n">s</span>

<span class="c">(* Loading the message is done by first reading in the length, and by</span>
<span class="c">   then reading in the appropriate number of bytes into a Bigstring</span>
<span class="c">   created for that purpose. *)</span>
<span class="k">let</span> <span class="n">load_message</span> <span class="n">inc</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">input_binary_int</span> <span class="n">inc</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;Couldn't load message: length missing from header&quot;</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">len</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">Bigstring</span><span class="p">.</span><span class="n">create</span> <span class="n">len</span> <span class="k">in</span>
    <span class="nn">Bigstring</span><span class="p">.</span><span class="n">really_input</span> <span class="o">~</span><span class="n">pos</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">len</span> <span class="n">inc</span> <span class="n">buf</span><span class="o">;</span>
    <span class="nn">Binable</span><span class="p">.</span><span class="n">of_bigstring</span> <span class="n">binable</span> <span class="n">buf</span>

<span class="c">(* To generate some example messages *)</span>
<span class="k">let</span> <span class="n">example</span> <span class="n">content</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">source</span> <span class="o">=</span>
    <span class="o">{</span> <span class="nn">Message</span><span class="p">.</span><span class="nn">Source</span><span class="p">.</span>
      <span class="n">hostname</span> <span class="o">=</span> <span class="s2">&quot;ocaml.org&quot;</span><span class="o">;</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">2322</span> <span class="o">}</span>
  <span class="k">in</span>
  <span class="o">{</span> <span class="nn">Message</span><span class="p">.</span>
    <span class="n">topic</span> <span class="o">=</span> <span class="s2">&quot;rwo-example&quot;</span><span class="o">;</span> <span class="n">content</span><span class="o">;</span> <span class="n">source</span><span class="o">;</span> <span class="o">}</span>

<span class="c">(* write out three messages... *)</span>
<span class="k">let</span> <span class="n">write_messages</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">outc</span> <span class="o">=</span> <span class="nn">Out_channel</span><span class="p">.</span><span class="n">create</span> <span class="s2">&quot;tmp.bin&quot;</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="n">save_message</span> <span class="n">outc</span><span class="o">)</span> <span class="o">[</span>
    <span class="n">example</span> <span class="s2">&quot;a wonderful&quot;</span><span class="o">;</span>
    <span class="n">example</span> <span class="s2">&quot;trio&quot;</span><span class="o">;</span>
    <span class="n">example</span> <span class="s2">&quot;of messages&quot;</span><span class="o">;</span>
  <span class="o">];</span>
  <span class="nn">Out_channel</span><span class="p">.</span><span class="n">close</span> <span class="n">outc</span>

<span class="c">(* ... and read them back in *)</span>
<span class="k">let</span> <span class="n">read_messages</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">inc</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">create</span> <span class="s2">&quot;tmp.bin&quot;</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">load_message</span> <span class="n">inc</span> <span class="k">in</span>
    <span class="n">printf</span> <span class="s2">&quot;msg %d: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span> <span class="n">msg</span><span class="o">.</span><span class="nn">Message</span><span class="p">.</span><span class="n">content</span>
  <span class="k">done</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">write_messages</span> <span class="bp">()</span><span class="o">;</span> <span class="n">read_messages</span> <span class="bp">()</span>
</pre></div></section><section><h1 id="fieldslib">Fieldslib</h1><p id="idp9057136">
      One common idiom when using records is to provide field accessor
      functions for a particular record.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">topic</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
           <span class="n">content</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
           <span class="n">source</span><span class="o">:</span> <span class="nn">Source</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
         <span class="o">}</span>

<span class="k">let</span> <span class="n">topic</span>   <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">topic</span>
<span class="k">let</span> <span class="n">content</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">content</span>
<span class="k">let</span> <span class="n">source</span>  <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">source</span>
</pre></div><p id="idp9058768">
      Similarly, sometimes you simultaneously want an accessor to a
      field of a record and a textual representation of the name of that
      field. This might come up if you were validating a field and
      needed the string representation to generate an error message, or
      if you wanted to scaffold a form in a GUI automatically based on
      the fields of a record. Fieldslib provides a module
      <code>Field</code> for this purpose. Here's some code for
      creating <code>Field.t</code>'s for all the fields of our
      type <code>t</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Fields</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">topic</span> <span class="o">=</span>
      <span class="o">{</span> <span class="nn">Field</span><span class="p">.</span>
        <span class="n">name</span>   <span class="o">=</span> <span class="s2">&quot;topic&quot;</span><span class="o">;</span>
        <span class="n">setter</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">topic</span><span class="o">);</span>
        <span class="n">fset</span>   <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="n">topic</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">t</span> <span class="k">with</span> <span class="n">topic</span> <span class="o">});</span>
      <span class="o">}</span>
    <span class="k">let</span> <span class="n">content</span> <span class="o">=</span>
      <span class="o">{</span> <span class="nn">Field</span><span class="p">.</span>
        <span class="n">name</span>   <span class="o">=</span> <span class="s2">&quot;content&quot;</span><span class="o">;</span>
        <span class="n">setter</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">content</span><span class="o">);</span>
        <span class="n">fset</span>   <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="n">content</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">t</span> <span class="k">with</span> <span class="n">content</span> <span class="o">});</span>
      <span class="o">}</span>
    <span class="k">let</span> <span class="n">source</span> <span class="o">=</span>
      <span class="o">{</span> <span class="nn">Field</span><span class="p">.</span>
        <span class="n">name</span>   <span class="o">=</span> <span class="s2">&quot;source&quot;</span><span class="o">;</span>
        <span class="n">setter</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">source</span><span class="o">);</span>
        <span class="n">fset</span>   <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">t</span> <span class="n">source</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">t</span> <span class="k">with</span> <span class="n">source</span> <span class="o">});</span>
      <span class="o">}</span>
  <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Fields</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">val</span> <span class="n">topic</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="kt">string</span> <span class="kt">list</span><span class="o">)</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Field</span><span class="p">.</span><span class="n">t</span>
    <span class="k">val</span> <span class="n">content</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="kt">string</span><span class="o">)</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Field</span><span class="p">.</span><span class="n">t</span>
    <span class="k">val</span> <span class="n">source</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="nn">Source</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Std</span><span class="p">.</span><span class="nn">Field</span><span class="p">.</span><span class="n">t</span>
  <span class="k">end</span>
</pre></div></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt02.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="pt03.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>