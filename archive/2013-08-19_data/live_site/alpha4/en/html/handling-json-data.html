<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 12. Handling JSON data / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha4',
                        page: 'handling\u002Djson\u002Ddata.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html">11. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html" class="here">12. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html">13. Command Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="text-processing-and-unicode.html">14. Text Processing and Unicode</a>
                                            </li>
                                        
                                            <li>
                                                <a href="xml-streams-and-trees.html">15. XML Streams and Trees</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">16. Concurrent Programming with Async</a>
                                            </li>
                                        
                                            <li>
                                                <a href="fast-binary-serialization-with-bin_prot.html">17. Fast Binary Serialization</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">18. Plugins with First-class Modules</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 12. Handling JSON data</h1>
                
                

    <p id="idp9294480">
    Now that you've seen how to convert OCaml values into s-expressions,
    it's time to look at other useful serialization formats. We'll cover
    JSON next, as it is a very common third-party data format on the
    Internet, and much easier to parse than alternatives. This chapter
    introduces you to a couple of new techniques that glue together the
    basic ideas from Part I of the book:
  </p><ul><li><p id="idp9295792">
        Using polymorphic variants to write more portable protocols (but
        still retain the ability to extend them if needed)
      </p></li><li><p id="idp9296720">
        The use of <span><em>combinators</em></span> to compose common
        operations over data structures in a type-safe way.
      </p></li><li><p id="idp9298032">
        Using external tools to generate boilerplate OCaml modules and
        signatures from external specification files.
      </p></li></ul><section><h1 id="json-basics">JSON Basics</h1><p id="idp9299920">
      JSON is a lightweight data-interchange format often used in web
      services and browsers. It's described in
      <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_top">RFC4627</a>,
      and is easier to parse and generate than alternatives such as XML.
      You'll run into JSON very often when working with modern web APIs,
      so we'll cover several different ways to manipulate it in this
      chapter.
    </p><p id="idp9301408">
      JSON consists of two basic structures: an unordered collection of
      key/value pairs, and an ordered list of values. Values can be
      strings, booleans, floats, integers or null. Let's see what a JSON
      record for an example book description looks like:
    </p><div class="highlight"><pre><span class="p">{</span>
  <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Real World OCaml&quot;</span><span class="p">,</span>
  <span class="nt">&quot;tags&quot;</span> <span class="p">:</span> <span class="p">[</span> <span class="s2">&quot;functional programming&quot;</span><span class="p">,</span> <span class="s2">&quot;ocaml&quot;</span><span class="p">,</span> <span class="s2">&quot;algorithms&quot;</span> <span class="p">],</span>
  <span class="nt">&quot;pages&quot;</span><span class="p">:</span> <span class="mi">450</span><span class="p">,</span>
  <span class="nt">&quot;authors&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Jason Hickey&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Google&quot;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Anil Madhavapeddy&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Cambridge&quot;</span><span class="p">},</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Yaron Minsky&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Jane Street&quot;</span><span class="p">}</span>
  <span class="p">],</span>
  <span class="nt">&quot;is_online&quot;</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div><p id="idp9303392">
      The outermost JSON value is usually a record (delimited by the
      curly braces) and contains an unordered set of key/value pairs.
      The keys must be strings but values can be any JSON type. In the
      example above, <code>tags</code> is a string list, while the
      <code>authors</code> field contains a list of records.
      Unlike OCaml lists, JSON lists can contain multiple different JSON
      types within a single list.
    </p><p id="idp9305616">
      This free-form nature of JSON types is both a blessing and a
      curse. It's very easy to generate JSON values, but code that
      parses them also has to handling subtle variations in how values
      are represented. For example, what if the <code>pages</code>
      value above is actually represented as a string value of
      <code>&quot;450&quot;</code> instead of an integer?
    </p><p id="idp9307776">
      Our first task is to parse the JSON into a more structured OCaml
      type so that we can use static typing more effectively. When
      manipulating JSON in Python or Ruby, you might write unit tests to
      check that you have handled unusual inputs. The OCaml model
      prefers compile-time static checking as well as unit tests. For
      example, using pattern matching can warn you if you've not checked
      that a value can be <code>Null</code> as well as contain an
      actual value.
    </p><aside class="note"><h1>
    Installing the Yojson library
    </h1><p id="idp9310064">
      There are several JSON libraries available for OCaml. For this
      chapter, we've picked the
      <a href="http://mjambon.com/yojson.html" target="_top"><code>Yojson</code></a>
      library by Martin Jambon. It's easiest to install via OPAM.
    </p><pre id="idp9311760">
$ opam install yojson
</pre><p id="idp9312448">
      See <a href="installation.html">Appendix A, <i>Installation</i></a> for installation
      instructions if you haven't already got OPAM. Once installed, you
      can open it in the <code>utop</code> toplevel by:
    </p><pre id="idp9314352">
#require &quot;yojson&quot; ;;
open Yojson ;;
</pre></aside><section><h1 id="parsing-json-with-yojson">Parsing JSON with Yojson</h1><p id="idp9316320">
        The JSON specification has very few data types, and the
        <code>Yojson.Basic.json</code> type shown below is
        sufficient to express any valid JSON structure.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span>
</pre></div><p id="idp9318688">
        Some interesting properties should leap out at you after reading
        this definition:
      </p><ul><li><p id="idp9319712">
            Some of the type definitions are
            <span><em>recursive</em></span> (that is, one of the
            algebraic data types includes a reference to the name of the
            type being defined). Fields such as <code>Assoc</code>
            can contain references to more JSON fields, and thus
            precisely describe the underlying JSON data structure.
          </p></li><li><p id="idp9321984">
            The definition specifically includes a
            <code>Null</code> variant for empty fields. OCaml
            doesn't allow null values by default, so this must be
            encoded like any other value.
          </p></li><li><p id="idp9323680">
            The differences between certain OCaml and JSON data
            structures is more obvious. For example, a JSON
            <code>List</code> can contain more JSON fields,
            whereas an OCaml <code>list</code> must contain values
            that are all the same type.
          </p></li><li><p id="idp9326144">
            The type definition uses polymorphic variants and not normal
            variants. This will become significant later when we extend
            it with custom extensions to the JSON format.
          </p></li></ul><p id="idp9327008">
        Let's parse the earlier JSON example into this type now. The
        first stop is the <code>Yojson.Basic</code> documentation,
        where we find these helpful functions:
      </p><div class="highlight"><pre><span class="k">val</span> <span class="n">from_string</span> <span class="o">:</span> <span class="o">?</span><span class="n">buf</span><span class="o">:</span><span class="nn">Bi_outbuf</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fname</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lnum</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="c">(* Read a JSON value from a string.</span>
<span class="c">   [buf]   : use this buffer at will during parsing instead of</span>
<span class="c">             creating a new one. </span>
<span class="c">   [fname] : data file name to be used in error messages. It does not </span>
<span class="c">             have to be a real file. </span>
<span class="c">   [lnum]  : number of the first line of input. Default is 1.</span>

<span class="c">val from_channel : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; in_channel -&gt; json</span>
<span class="c">(* Read a JSON value from a channel. See [from_string] for the meaning of the</span>
<span class="c">   optional arguments. *)</span>

<span class="c">val from_file : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; json</span>
<span class="c">(* Read a JSON value from a file. See [from_string] for the meaning of the optional</span>
<span class="c">   arguments. *)</span>
</pre></div><p id="idp9330224">
        When first reading these interfaces, you can generally ignore
        the optional arguments (which have the question marks in the
        type signature), as they will be filled in with sensible values.
        In the above signature, the optional arguments offer finer
        control over the memory buffer allocation and error messages
        from parsing incorrect JSON.
      </p><p id="idp9331024">
        The type signature for these functions with the optional
        elements removed makes their purpose much clearer:
      </p><div class="highlight"><pre><span class="k">val</span> <span class="n">from_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">from_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">from_channel</span> <span class="o">:</span> <span class="n">in_channel</span> <span class="o">-&gt;</span> <span class="n">json</span>
</pre></div><p id="idp9332672">
        The <code>in_channel</code> constructor is from the
        original OCaml standard library, and its use is considered
        deprecated when using the Core standard library. This leaves us
        with two ways of parsing the JSON: either from a string or from
        a file on a filesystem. The next example shows both in action,
        assuming the JSON record is stored in a file called
        <code>book.json</code>:
      </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Read JSON file into an OCaml string *)</span>
  <span class="k">let</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">read_all</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Use the string JSON constructor *)</span>
  <span class="k">let</span> <span class="n">json1</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_string</span> <span class="n">buf</span> <span class="k">in</span>

  <span class="c">(* Use the file JSON constructor *)</span>
  <span class="k">let</span> <span class="n">json2</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_file</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Test that the two values are the same *)</span>
  <span class="n">print_endline</span> <span class="o">(</span><span class="k">if</span> <span class="n">json1</span> <span class="o">=</span> <span class="n">json2</span> <span class="k">then</span> <span class="s2">&quot;OK&quot;</span> <span class="k">else</span> <span class="s2">&quot;FAIL&quot;</span><span class="o">)</span>
  <span class="n">print_endline</span> <span class="o">(</span><span class="k">if</span> <span class="n">phys_equal</span> <span class="n">json1</span> <span class="n">json2</span> <span class="k">then</span> <span class="s2">&quot;FAIL&quot;</span> <span class="k">else</span> <span class="s2">&quot;OK&quot;</span><span class="o">)</span>
</pre></div><p id="idp9336576">
        The <code>from_file</code> function accepts an input
        filename and takes care of opening and closing it for you. It's
        far more common to use <code>from_string</code> to
        construct JSON values though, since these strings come in via a
        network connection (we'll see more of this in
        <a href="concurrent-programming-with-async.html">Chapter 16, <i>Concurrent Programming with Async</i></a>)
        or a database. Finally, the example checks that the two input
        mechanisms actually resulted in the same OCaml data structure.
      </p><section><h1><b>
      The difference between <code>=</code> and
      <code>==</code>, and <code>phys_equal</code> in Core
      </b></h1><p id="idp9342288">
        If you come from a C/C++ background, you will probably
        reflexively use <code>==</code> to test two values for
        equality. In OCaml, <code>==</code> tests for
        <span><em>physical</em></span> equality, and <code>=</code>
        tests for <span><em>structural</em></span> equality.
      </p><p id="idp9345776">
        The <code>==</code> physical equality test will match if
        two data structures have precisely the same pointer in memory.
        Two data structures that have identical contents, but are
        constructed separately, will not match using this operator. In
        the JSON example, the <code>json1</code> and
        <code>json2</code> values are not identical and so would
        fail the physical equality test.
      </p><p id="idp9348640">
        The <code>=</code> structural equality operator
        recursively inspects each field in the two values and tests them
        individually for equality. In the JSON parsing example, every
        field will be traversed and checked, and they will check out as
        equal. Crucially, if your data structure is cyclical (that is, a
        value recursively points back to another field within the same
        structure), the <code>=</code> operator will never
        terminate, and your program will hang! In this situation, you
        must use the physical equality operator, or write a custom
        comparison function that breaks the recursion.
      </p><p id="idp9351040">
        It's quite easy to mix up the use of <code>=</code> and
        <code>==</code>, so Core disables the
        <code>==</code> operator and provides the more explicit
        <code>phys_equal</code> function instead. You'll see a
        type error if you use <code>==</code> anywhere:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">Consider_using_phys_equal</span> <span class="o">]</span>
<span class="o">#</span> <span class="n">phys_equal</span> <span class="mi">1</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9356160">
        If you feel like hanging your OCaml interpreter, you can verify
        what happens with recursive values and structural equality for
        yourself:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="n">bar1</span><span class="o">:</span><span class="n">t2</span> <span class="o">}</span> <span class="ow">and</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="n">bar2</span><span class="o">:</span><span class="n">t1</span> <span class="o">}</span> <span class="o">;;</span>
<span class="k">type</span> <span class="n">t1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar1</span> <span class="o">:</span> <span class="n">t2</span><span class="o">;</span> <span class="o">}</span>
<span class="ow">and</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar2</span> <span class="o">:</span> <span class="n">t1</span><span class="o">;</span> <span class="o">}</span>
<span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">v1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">bar1</span><span class="o">=</span><span class="n">v2</span> <span class="o">}</span> <span class="ow">and</span> <span class="n">v2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">bar2</span><span class="o">=</span><span class="n">v1</span> <span class="o">};;</span>
<span class="o">&lt;</span><span class="n">lots</span> <span class="k">of</span> <span class="n">text</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">v1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">phys_equal</span> <span class="n">v1</span> <span class="n">v1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">;;</span>
<span class="o">&lt;</span><span class="n">press</span> <span class="o">^</span><span class="nc">Z</span> <span class="ow">and</span> <span class="n">kill</span> <span class="n">the</span> <span class="n">process</span> <span class="n">now</span><span class="o">&gt;</span>
</pre></div></section><section><h1 id="selecting-values-from-json-structures">Selecting values from JSON structures</h1><p id="idp9359424">
          Now that we've figured out how to parse the example JSON into
          an OCaml value, let's manipulate it from OCaml code and
          extract specific fields.
        </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>
<span class="k">open</span> <span class="nc">Printf</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Read the JSON file *)</span>
  <span class="k">let</span> <span class="n">json</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_file</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Locally open the JSON manipulation functions *)</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="nc">Util</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">title</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;title&quot;</span> <span class="o">|&gt;</span> <span class="n">to_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;tags&quot;</span> <span class="o">|&gt;</span> <span class="n">to_list</span> <span class="o">|&gt;</span> <span class="n">filter_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;pages&quot;</span> <span class="o">|&gt;</span> <span class="n">to_int</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">is_online</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;is_online&quot;</span> <span class="o">|&gt;</span> <span class="n">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">is_translated</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;is_translated&quot;</span> <span class="o">|&gt;</span> <span class="n">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">authors</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;authors&quot;</span> <span class="o">|&gt;</span> <span class="n">to_list</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">authors</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">to_string</span><span class="o">)</span> <span class="k">in</span>

  <span class="c">(* Print the results of the parsing *)</span>
  <span class="n">printf</span> <span class="s2">&quot;Title: %s (%d)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">title</span> <span class="n">pages</span><span class="o">;</span>
  <span class="n">printf</span> <span class="s2">&quot;Authors: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;, &quot;</span> <span class="n">names</span><span class="o">);</span>
  <span class="n">printf</span> <span class="s2">&quot;Tags: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;, &quot;</span> <span class="n">tags</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">string_of_bool_option</span> <span class="o">=</span>
    <span class="k">function</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="s2">&quot;&lt;none&gt;&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="bp">true</span> <span class="o">-&gt;</span> <span class="s2">&quot;yes&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="s2">&quot;no&quot;</span> <span class="k">in</span>
  <span class="n">printf</span> <span class="s2">&quot;Online: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">string_of_bool_option</span> <span class="n">is_online</span><span class="o">);</span>
  <span class="n">printf</span> <span class="s2">&quot;Translated: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">string_of_bool_option</span> <span class="n">is_translated</span><span class="o">)</span>
</pre></div><p id="idp9362208">
          This introduces the <code>Yojson.Basic.Util</code>
          module, which contains <span><em>combinator</em></span>
          functions for JSON manipulation.
        </p><section><h1><b>
        Functional Combinators
        </b></h1><p id="idp9364560">
          Combinators are a design pattern that crops up quite often in
          functional programming. John Hughes defines them as &quot;a
          function which builds program fragments from program
          fragments&quot;. In a functional language, this generally
          means higher-order functions that combine other functions to
          apply useful transformations over values.
        </p><p id="idp9365856">
          You've already run across several of these in the
          <code>List</code> module:
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">map</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span>   <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="kt">list</span>
<span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">accum</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">accum</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">accum</span>
</pre></div><p id="idp9368304">
<code>map</code> and <code>fold</code> are
          extremely common combinators that transform an input list by
          applying a function to each value of the list. The
          <code>map</code> combinator is simplest, with the
          resulting list being output directly. <code>fold</code>
          applies each value in the input list to a function that
          accumulates a single result, and returns that instead.
        </p><p id="idp9371824">
          The final example above is a more specialised combinator that
          is only useful in OCaml due to side-effects being allowed. The
          input function is applied to every value, but no result is
          supplied. Instead, the function must directly result in some
          side-effect, such as printing to the console or updating a
          reference elsewhere in the environment.
        </p></section><p id="idp9372768">
<code>Yojson</code> provides several combinators in the
          <code>Yojson.Basic.Util</code> module, such as:
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">member</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">index</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="kt">string</span>
<span class="k">val</span> <span class="n">to_int</span> <span class="o">:</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">filter_string</span> <span class="o">:</span> <span class="n">json</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span>
</pre></div><p id="idp9375936">
          We'll go through each of these uses one-by-one. Core provides
          the <code>|&gt;</code> pipe-forward which can chain
          combinators together, and the example code uses this to select
          and convert values out of the JSON structure. Let's examine
          some of them in more detail:
        </p><div class="highlight"><pre>  <span class="k">let</span> <span class="k">open</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="nc">Util</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">title</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;title&quot;</span> <span class="o">|&gt;</span> <span class="n">to_string</span> <span class="k">in</span>
</pre></div><p id="idp9378400">
          For the <code>title</code> field, the
          <code>member</code> combinator extracts the key from the
          <code>json</code> value, and converts it to an OCaml
          string. An exception is raised if the JSON value is not a
          string, so the caller must be careful to
          <code>try/with</code> the result.
        </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;tags&quot;</span> <span class="o">|&gt;</span> <span class="n">to_list</span> <span class="o">|&gt;</span> <span class="n">filter_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;pages&quot;</span> <span class="o">|&gt;</span> <span class="n">to_int</span> <span class="k">in</span>
</pre></div><p id="idp9383056">
          The <code>tags</code> field is similar to
          <code>title</code>, but the field is a list of strings
          instead of a single one. Converting this to an OCaml
          <code>string list</code> is a two stage process: first,
          we must convert it to a list of JSON values, and then filter
          out the <code>String</code> values. Remember that OCaml
          lists must have a single type, so any other JSON values will
          be skipped from the output of
          <code>filter_string</code>.
        </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">is_online</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;is_online&quot;</span> <span class="o">|&gt;</span> <span class="n">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">is_translated</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;is_translated&quot;</span> <span class="o">|&gt;</span> <span class="n">to_bool_option</span> <span class="k">in</span>
</pre></div><p id="idp9388576">
          The <code>is_online</code> and
          <code>is_translated</code> fields are optional in our
          JSON schema, so no error should be raised if they are not
          present. The OCaml type is a <code>string option</code>
          to reflect this, and can be extracted via
          <code>to_bool_option</code>. In our example JSON, only
          <code>is_online</code> is present and
          <code>is_translated</code> will be
          <code>None</code>.
        </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">authors</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;authors&quot;</span> <span class="o">|&gt;</span> <span class="n">to_list</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">authors</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">to_string</span><span class="o">)</span> <span class="k">in</span>
</pre></div><p id="idp9395376">
          The final use of JSON combinators is to extract the
          <code>name</code> fields from the
          <code>author</code> list. We first construct the
          <code>author</code> list, and then
          <code>map</code> it into a
          <code>string list</code>. Notice that the example
          explicitly binds <code>authors</code> to a variable
          name. It can also be written more succinctly using the
          pipe-forward operator:
        </p><div class="highlight"><pre><span class="k">let</span> <span class="n">names</span> <span class="o">=</span>
  <span class="n">json</span>
  <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;authors&quot;</span>
  <span class="o">|&gt;</span> <span class="n">to_list</span>
  <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">to_string</span><span class="o">)</span>
</pre></div><p id="idp9401424">
          This style of programming which omits variable names and
          chains functions together is known as &quot;point-free
          programming&quot;. It's a succinct style, but shouldn't be
          overused due to the increased difficulty of debugging
          intermediate values. If an explicit name is assigned to each
          stage of the transformations, debuggers in particular have an
          easier time making the program flow easier to represent to the
          programer.
        </p><p id="idp9402864">
          This technique of using chained parsing functions is very
          powerful in combination with the OCaml type system. Many
          errors that don't make sense at runtime (for example, mixing
          up lists and objects) will be caught statically via a type
          error.
        </p></section></section><section><h1 id="constructing-json-values">Constructing JSON values</h1><p id="idp9404912">
        Building and printing JSON values is pretty straightforward
        given the <code>Yojson.Basic.json</code> type. You can
        just construct values of type <code>json</code> and call
        the <code>to_string</code> function] on them. There are
        also pretty-printing functions available that lay out the output
        in a more human-readable style:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">[</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)</span> <span class="o">]</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">])</span> <span class="kt">list</span> <span class="o">]</span> <span class="o">=</span>
  <span class="o">`</span><span class="nc">Assoc</span> <span class="o">[(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)]</span>

<span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="n">x</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;{ </span><span class="se">\&quot;</span><span class="s2">key</span><span class="se">\&quot;</span><span class="s2">: </span><span class="se">\&quot;</span><span class="s2">value</span><span class="se">\&quot;</span><span class="s2"> }&quot;</span>

<span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_channel</span> <span class="n">stdout</span> <span class="n">x</span> <span class="o">;;</span>
<span class="o">{</span> <span class="s2">&quot;key&quot;</span><span class="o">:</span> <span class="s2">&quot;value&quot;</span> <span class="o">}</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp9408992">
        In the example above, although the type of <code>x</code>
        is compatible with the type <code>json</code>, it's not
        explicitly defined as such. The type inference engine will
        figure out a type that is based on how the value
        <code>x</code> is used and in this case only the
        <code>Assoc</code> and <code>String</code> variants
        are present. This &quot;partial&quot; type signature is checked
        against the bigger <code>json</code> type it is applied to
        the <code>pretty_to_string</code> function, and determined
        to be compatible.
      </p><section><h1><b>
      Polymorphic variants and easier type checking
      </b></h1><p id="idp9415616">
        One difficulty you will encounter is that type errors involving
        polymorphic variants can be quite verbose if you make a mistake
        in your code. For example, suppose you build an
        <code>Assoc</code> and mistakenly include a single value
        instead of a list of keys:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span> <span class="o">]</span> <span class="o">=</span>
  <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)</span>

<span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="n">x</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
         <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span> <span class="o">]</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span>
       <span class="nc">Types</span> <span class="k">for</span> <span class="n">tag</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="n">are</span> <span class="n">incompatible</span>
</pre></div><p id="idp9418800">
        The type error above isn't <span><em>wrong</em></span> as such,
        but can be inconvenient to wade through for larger values. An
        easy way to narrow down this sort of type error is to add
        explicit type annotations as a compiler hint about your
        intentions:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span><span class="o">)</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">);;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
</pre></div><p id="idp9421280">
        In this case, we've marked the <code>x</code> as being of
        type <code>Yojson.Basic.json</code>, and the compiler
        immediately spots that the argument to the
        <code>Assoc</code> variant has the incorrect type. This
        illustrates the strengths and drawbacks of using polymorphic
        variants: they make it possible to easily subtype across module
        boundaries (<code>Basic</code> and <code>Safe</code>
        in Yojson's case), but the error messages can be more confusing.
        However, a bit of careful manual type annotation is all it takes
        to make tracking down such issues much easier.
      </p></section><section><h1 id="using-non-standard-json-extensions">Using non-standard JSON extensions</h1><p id="idp9426960">
          The standard JSON types are <span><em>really</em></span> basic,
          and OCaml types are far more expressive. Yojson supports an
          extended JSON format for those times when you're not
          interoperating with external systems and just want a
          convenient human-readable local format. The
          <code>Yojson.Safe.json</code> type is a superset of the
          <code>Basic</code> polymorphic variant, and looks like
          this:
        </p><div class="highlight"><pre><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Floatlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Intlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Stringlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Variant</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">json</span> <span class="n">option</span> <span class="o">]</span>
</pre></div><p id="idp9430832">
          You should immediately be able to spot a benefit of using
          polymorphic variants here. A standard JSON type such as a
          <code>String</code> will type-check against both the
          <code>Basic</code> module and also the non-standard
          <code>Safe</code> module. However, if you use extension
          values such as <code>Tuple</code> with the
          <code>Basic</code> module, they will not be a valid
          sub-type and the compiler will complain.
        </p><p id="idp9435168">
          The extensions includes with Yojson include:
        </p><ul><li><p id="idp9436144">
              The <code>lit</code> suffix denotes that the value
              is stored as a JSON string. For example, a
              <code>Floatlit</code> will be stored as
              <code>&quot;1.234&quot;</code> instead of
              <code>1.234</code>.
            </p></li><li><p id="idp9439952">
              The <code>Tuple</code> type is stored as
              <code>(&quot;abc&quot;, 123)</code> instead of a
              list.
            </p></li><li><p id="idp9442240">
              The <code>Variant</code> type encodes OCaml variants
              more explicitly, as
              <code>&lt;&quot;Foo&quot;&gt;</code> or
              <code>&lt;&quot;Bar&quot;:123&gt;</code> for a
              variant with parameters.
            </p></li></ul><p id="idp9445184">
          The only purpose of these extensions is to make the data
          representation more expressive without having to refer to the
          original OCaml types. You can always cast a
          <code>Safe.json</code> to a
          <code>Basic.json</code> type by using the
          <code>to_basic</code> function as follows:
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">to_basic</span> <span class="o">:</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span>
<span class="c">(** Tuples are converted to JSON arrays, Variants are converted to</span>
<span class="c">    JSON strings or arrays of a string (constructor) and a json value</span>
<span class="c">    (argument). Long integers are converted to JSON strings.</span>
<span class="c">    Examples:</span>

<span class="c">    `Tuple [ `Int 1; `Float 2.3 ]   -&gt;    `List [ `Int 1; `Float 2.3 ]</span>
<span class="c">    `Variant (&quot;A&quot;, None)            -&gt;    `String &quot;A&quot;</span>
<span class="c">    `Variant (&quot;B&quot;, Some x)          -&gt;    `List [ `String &quot;B&quot;, x ]</span>
<span class="c">    `Intlit &quot;12345678901234567890&quot;  -&gt;    `String &quot;12345678901234567890&quot;</span>
<span class="c"> *)</span>
</pre></div></section></section><section><h1 id="automatically-mapping-json-to-ocaml-types">Automatically mapping JSON to OCaml types</h1><p id="idp9450960">
        The combinators described earlier make it fairly easy to extract
        fields from JSON records, but the process is still pretty
        manual. We'll talk about how to do larger-scale JSON parsing
        now, using a domain-specific language known as
        <a href="http://oss.wink.com/atdgen/" target="_top">ATD</a>.
      </p><p id="idp9452384">
        The idea behind ATD is to specify the format of the JSON in a
        separate file, and then run a compiler
        (<code>atdgen</code>) that outputs OCaml code to construct
        and parse JSON values. This means that you don't need to write
        any OCaml parsing code at all, as it will all be auto-generated
        for you.
      </p><p id="idp9453824">
        Let's go straight into looking at an example of how this works,
        by using a small portion of the Github API. Github is a popular
        code hosting and sharing website that provides a JSON-based web
        <a href="http://developer.github.com" target="_top">API</a>. The ATD
        code fragment below describes the Github authorization API. It
        is based on a pseudo-standard web protocol known as OAuth, and
        is used to authorized users to access Github services.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">scope</span> <span class="o">=</span> <span class="o">[</span>
    <span class="nc">User</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Public_repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;public_repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Repo_status</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;repo_status&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Delete_repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;delete_repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Gist</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;gist&quot;</span><span class="o">&gt;</span>
<span class="o">]</span>

<span class="k">type</span> <span class="n">app</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
<span class="o">}</span>  <span class="o">&lt;</span><span class="n">ocaml</span> <span class="n">field_prefix</span><span class="o">=</span><span class="s2">&quot;app_&quot;</span><span class="o">&gt;</span>

<span class="k">type</span> <span class="n">authorization_request</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">note</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
<span class="o">}</span> <span class="o">&lt;</span><span class="n">ocaml</span> <span class="n">field_prefix</span><span class="o">=</span><span class="s2">&quot;auth_req_&quot;</span><span class="o">&gt;</span>

<span class="k">type</span> <span class="n">authorization_response</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">token</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">app</span><span class="o">:</span> <span class="n">app</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">id</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="o">?</span><span class="n">note</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="o">?</span><span class="n">note_url</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span>
</pre></div><p id="idp9456960">
        ATD is (deliberately) similar to OCaml type definitions. Each
        field can include extra annotations to customise the parsing
        code for a particular backend. For example, the Github
        <code>scope</code> field above is defined as a variant
        type, but with the actual JSON values being defined explicitly
        (as lower-case versions).
      </p><p id="idp9458416">
        The ATD spec can be compiled to a number of OCaml targets. Let's
        run the compiler twice, to generate some OCaml type definitions,
        and a JSON serialiser.
      </p><div class="highlight"><pre><span class="nv">$ </span>atdgen -t github.atd
<span class="nv">$ </span>atdgen -j github.atd
</pre></div><p id="idp9460000">
        This will generate some new files in your current directory.
        <code>Github_t.ml</code> and
        <code>Github_t.mli</code> will contain an OCaml module
        with types defines that correspond to the ATD file. It looks
        like this:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">scope</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">User</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Public_repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Repo_status</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Delete_repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gist</span>
<span class="o">]</span>

<span class="k">type</span> <span class="n">app</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">app_name</span> <span class="c">(*atd name *)</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">app_url</span> <span class="c">(*atd url *)</span><span class="o">:</span> <span class="kt">string</span>
<span class="o">}</span>

<span class="k">type</span> <span class="n">authorization_request</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">auth_req_scopes</span> <span class="c">(*atd scopes *)</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">auth_req_note</span> <span class="c">(*atd note *)</span><span class="o">:</span> <span class="kt">string</span>
<span class="o">}</span>

<span class="k">type</span> <span class="n">authorization_response</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">token</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">app</span><span class="o">:</span> <span class="n">app</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">id</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="n">note</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">note_url</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span>
<span class="o">}</span>
</pre></div><p id="idp9463424">
        There is an obvious correspondence to the ATD definition. Note
        in particular that field names in separate OCaml records cannot
        shadow each other, and so we specifically prefix every field
        with a prefix to distinguish it from other records. For example,
        <code>&lt;ocaml field_prefix=&quot;auth_req_&quot;&gt;</code>
        in the ATD spec prefixes every field name in the generated
        <code>authorization_request</code> record with
        <code>auth_req</code>.
      </p><p id="idp9466368">
        The <code>Github_t</code> module only contains the type
        definitions, while <code>Github_j</code> has a concrete
        serialization module to and from JSON. You can read the
        <code>github_j.mli</code> to see the full interface, but
        the important functions for most uses are the conversion
        functions to and from a string. For our example above, this
        looks like:
      </p><div class="highlight"><pre><span class="k">val</span> <span class="n">string_of_authorization_response</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">len</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">authorization_response</span> <span class="o">-&gt;</span> <span class="kt">string</span>
  <span class="c">(** Serialize a value of type {!authorization_response}</span>
<span class="c">      into a JSON string.</span>
<span class="c">      @param len specifies the initial length</span>
<span class="c">                 of the buffer used internally.</span>
<span class="c">                 Default: 1024. *)</span>

<span class="k">val</span> <span class="n">authorization_response_of_string</span> <span class="o">:</span>
  <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">authorization_response</span>
</pre></div><p id="idp9470944">
        This is pretty convenient! We've written a single ATD file, and
        all the OCaml boilerplate to convert between JSON and a strongly
        typed record has been generated for us. You can control various
        aspects of the serializer by passing flags to
        <code>atdgen</code>. The important ones for JSON are:
      </p><ul><li><p id="idp9472896">
<code>-j-std</code>: work in standard JSON mode, and
            never print non-standard JSON extensions.
          </p></li><li><p id="idp9474464">
<code>-j-custom-fields FUNCTION</code>: call a custom
            function for every unknown field encountered, instead of
            raising a parsing exception.
          </p></li><li><p id="idp9476096">
<code>-j-defaults</code>: force the output a JSON
            value even if the specification defines it as the default
            value for that field.
          </p></li></ul><p id="idp9477584">
        The full ATD specification is quite sophisticated (and well
        documented online at its homepage). The ATD compiler can also
        target formats other than JSON, and also outputs code for other
        languages such as Java if you need more interoperability. There
        are also several similar projects you can investigate which
        automate the code generation process:
        <a href="http://piqi.org" target="_top">Piqi</a> uses the Google
        protobuf format, and
        <a href="http://thrift.apache.org" target="_top">Thrift</a> supports a
        huge variety of other programming languages.
      </p><p id="idp9479920">
        We'll also return to the Github example here later in the book
        when discussing the Async networking library, and you can find
        the full ATD specification for Github in the
        <a href="http://github.com/avsm/ocaml-github" target="_top"><code>ocaml-github</code></a>
        repository.
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="data-serialization-with-s-expressions.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="command-line-parsing.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>