<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 16. Parsing with OCamllex and Menhir / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta2',
                        page: 'parsing\u002Dwith\u002Docamllex\u002Dand\u002Dmenhir.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="maps-and-hash-tables.html">13. Maps and Hash Tables</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html">14. Command Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">15. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-menhir.html" class="here">16. Parsing with OCamllex and Menhir</a>
                                            </li>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html">17. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">18. Concurrent Programming with Async</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 16. Parsing with OCamllex and Menhir</h1>
                
                

    <p id="idp10322256">
    Many programming tasks start with the interpretion of some form of
    structured textual data. <span><em>Parsing</em></span> is the process
    of converting such data into data structures that are easy to
    program against. For simple formats, it's often enough to parse the
    data in an ad-hoc way, say, by breaking up the data into lines, and
    then using regular expressions for breaking those lines down into
    their component pieces.
  </p><p id="idp10323504">
    But this simplistic approach tends to fall down when parsing more
    complicated data, particularly data with the kind of recursive
    structure you find in full-blown programming languages or flexible
    data formats like JSON and XML. Parsing such formats accurately and
    efficiently while providing useful error messages is a complex task.
  </p><p id="idp10324256">
    Often, you can find an existing parsing library that handles these
    issues for you. But there are tools to help simplify the task when
    you do need to write a parser, in the form of <span><em>parser
    generators</em></span>. A parser generator creates a parser from a
    specification of the data format that you want to parse, and uses
    that to generate a parser.
  </p><p id="idp10325424">
    Parser generators have a long history, including tools like
    <code>lex</code> and <code>yacc</code> that date back to
    the early 1970's. OCaml has its own alternatives, including
    <code>ocamllex</code>, which replaces <code>lex</code>,
    and <code>ocamlyacc</code> and <code>menhir</code>,
    which are replacements for <code>yacc</code>. We'll explore
    these tools in the course of walking through the implementation of a
    parser for the JSON serialization format that we discussed in
    <a href="handling-json-data.html">Chapter 15, <i>Handling JSON data</i></a>.
  </p><p id="idp10331824">
    Parsing is a broad and often intricate topic, and our purpose here
    is not to teach all of the theoretical issues, but to provide a
    pragmatic introduction of how to build a parser in OCaml.
  </p><aside class="note"><h1>
  Menhir vs ocamlyacc
</h1><p id="idp10334176">
    Menhir is an alternative parser generator that is generally superior
    to the venerable <code>ocamlyacc</code>, which dates back
    quite a few years. Menhir is mostly compatible with
    <code>ocamlyacc</code> grammars, and so you can usually just
    switch to Menhir and expect older code to work (with some minor
    differences described in the Menhir manual).
  </p><p id="idp10336320">
    The biggest advantage of Menhir is that its error messages are
    generally more human-comprehensible, and the parsers that it
    generates are fully reentrant and can be parameterized in OCaml
    modules more easily. We recommend that any new code you develop
    should use Menhir instead of <code>ocamlyacc</code>.
  </p><p id="idp10337744">
    Menhir isn't distributed directly with OCaml, but is available
    through OPAM by running <code>opam install menhir</code>.
  </p></aside><section><h1 id="lexing-and-parsing">Lexing and parsing</h1><p id="idp10340128">
      Parsing is traditionally broken down into two parts:
      <span><em>lexical analysis</em></span>, which is a kind of
      simplified parsing phase that converts a stream of characters into
      a stream of logical tokens; and full-on parsing, which involves
      converting a stream of tokens into the final representation, which
      is often in the form of a tree-like data-structure called an
      <span><em>abstract syntax-tree</em></span>, or AST.
    </p><p id="idp10341776">
      It's confusing that the term parsing is applied to both the
      overall process of converting textual data to structured data, and
      also more specifically to the second phase of converting a stream
      of tokens to an AST, so from here on in, we'll use the term
      parsing to refer only to this second phase.
    </p><p id="idp10342512">
      Let's consider lexing and parsing in the context of the JSON
      format. Here's an example of a snippet of text that represents a
      JSON object containing a string labeled <code>title</code>,
      and an array containing two objects, each with a name and array of
      zip codes.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="p">{</span>
  <span class="err">title:</span> <span class="nt">&quot;Cities&quot;</span><span class="p">,</span>
  <span class="err">cities:</span> <span class="err">[</span>
    <span class="err">{</span> <span class="err">name:</span> <span class="nt">&quot;Chicago&quot;</span><span class="p">,</span>  <span class="err">zips:</span> <span class="err">[60601]</span> <span class="p">}</span><span class="err">,</span>
    <span class="p">{</span> <span class="err">name:</span> <span class="nt">&quot;New York&quot;</span><span class="p">,</span> <span class="err">zips:</span> <span class="err">[10004]</span> <span class="p">}</span> 
  <span class="err">]</span>
<span class="err">}</span>
</div></code></pre><div class="rwocodeinfo">JSON ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/example.json">parsing/example.json</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10344624">
      At a syntactic level, we can think of a JSON file as a series of
      simple logical units, like curly braces, square brackets, commas,
      colons, identifiers, numbers, and quoted strings. Thus, we could
      represent our JSON text as a sequence of tokens of the following
      type.
    </p><div class="rwocode"><pre><code><span class="keyword4">type</span> token <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">TRUE
</span>  <span class="keyword2">|</span> <span class="keyword6">STRING </span><span class="keyword2">of</span> <span class="keyword3">string</span>
  <span class="keyword2">|</span> <span class="keyword6">RIGHT_BRACK
</span>  <span class="keyword2">|</span> <span class="keyword6">RIGHT_BRACE
</span>  <span class="keyword2">|</span> <span class="keyword6">NULL
</span>  <span class="keyword2">|</span> <span class="keyword6">LEFT_BRACK
</span>  <span class="keyword2">|</span> <span class="keyword6">LEFT_BRACE
</span>  <span class="keyword2">|</span> <span class="keyword6">INT </span><span class="keyword2">of</span> <span class="keyword3">int</span>
  <span class="keyword2">|</span> <span class="keyword6">ID </span><span class="keyword2">of</span> <span class="keyword3">string</span>
  <span class="keyword2">|</span> <span class="keyword6">FLOAT </span><span class="keyword2">of</span> <span class="keyword3">float</span>
  <span class="keyword2">|</span> <span class="keyword6">FALSE
</span>  <span class="keyword2">|</span> <span class="keyword6">EOF
</span>  <span class="keyword2">|</span> <span class="keyword6">COMMA
</span>  <span class="keyword2">|</span> COLON</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/manual_token_type.ml">parsing/manual_token_type.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10346048">
      Note that this representation loses some information about the
      original text. For example, white space is not represented. It's
      common, and indeed useful, for the token stream to forget some
      details of the original text that are not required for
      understanding its meaning.
    </p><p id="idp10346752">
      If we converted the above example into a list of these tokens, it
      would look something like this.
    </p><div class="rwocode"><pre><code><span class="keyword2">[</span> LEFT_BRACE<span class="keyword2">;</span> ID<span class="keyword2">(</span><span class="keyword7">&quot;title&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span> COLON<span class="keyword2">;</span> STRING<span class="keyword2">(</span><span class="keyword7">&quot;Cities&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span> COMMA<span class="keyword2">;</span> ID<span class="keyword2">(</span><span class="keyword7">&quot;cities&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span> ...</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/tokens.ml">parsing/tokens.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10347968">
      This kind of representation is easier to work with than the
      original text, since it gets rid of some unimportant syntactic
      details and adds useful structure. But it's still a good deal more
      low-level than the simple AST we used for representing JSON data
      in <a href="handling-json-data.html">Chapter 15, <i>Handling JSON data</i></a>, shown below.
    </p><div class="rwocode"><pre><code><span class="keyword4">type</span> value <span class="keyword2">=</span> <span class="keyword2">[</span>
  <span class="keyword2">|</span> <span class="keyword6">`Assoc </span><span class="keyword2">of</span> <span class="keyword2">(</span><span class="keyword3">string</span> <span class="keyword2">*</span> value<span class="keyword2">)</span> <span class="keyword3">list</span>
  <span class="keyword2">|</span> <span class="keyword6">`Bool </span><span class="keyword2">of</span> bool
  <span class="keyword2">|</span> <span class="keyword6">`Float </span><span class="keyword2">of</span> <span class="keyword3">float</span>
  <span class="keyword2">|</span> <span class="keyword6">`Int </span><span class="keyword2">of</span> <span class="keyword3">int</span>
  <span class="keyword2">|</span> <span class="keyword6">`List </span><span class="keyword2">of</span> value <span class="keyword3">list</span>
  <span class="keyword2">|</span> <span class="keyword6">`Null
</span>  <span class="keyword2">|</span> <span class="keyword6">`String </span><span class="keyword2">of</span> <span class="keyword3">string</span>
<span class="keyword2">]</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/json.ml">parsing/json.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10350048">
      This representation is much richer than our token stream,
      capturing the fact that JSON values can be nested inside each
      other, and that JSON has a variety of value types, including
      numbers, strings, arrays, and objects. The above type is
      effectively an AST, and the job of the parser we'll write will be
      to convert a token stream into a value of this type, as shown
      below.
    </p><div class="rwocode"><pre><code><span class="keyword6">`Assoc
</span>  <span class="keyword2">[</span><span class="keyword7">&quot;title&quot;</span>, <span class="keyword6">`String </span><span class="keyword7">&quot;Cities&quot;</span><span class="keyword2">;</span>
   <span class="keyword7">&quot;cities&quot;</span>, <span class="keyword6">`List
</span>     <span class="keyword2">[</span><span class="keyword6">`Assoc </span><span class="keyword2">[</span><span class="keyword7">&quot;name&quot;</span>, <span class="keyword6">`String </span><span class="keyword7">&quot;Chicago&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;zips&quot;</span>, <span class="keyword6">`List </span><span class="keyword2">[</span><span class="keyword6">`Int </span><span class="keyword8">60601</span><span class="keyword2">]</span><span class="keyword2">]</span><span class="keyword2">;</span>
      <span class="keyword6">`Assoc </span><span class="keyword2">[</span><span class="keyword7">&quot;name&quot;</span>, <span class="keyword6">`String </span><span class="keyword7">&quot;New York&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;zips&quot;</span>, <span class="keyword6">`List </span><span class="keyword2">[</span><span class="keyword6">`Int </span><span class="keyword8">10004</span><span class="keyword2">]</span><span class="keyword2">]</span><span class="keyword2">]</span><span class="keyword2">]</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/parsed_example.ml">parsing/parsed_example.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="defining-a-parser">Defining a parser</h1><p id="idp10352800">
      A parser-specification file has suffix <code>.mly</code> and
      contains several sections that are broken up by separator lines
      consisting of the characters <code>%%</code> on a line by
      themselves. The first section of the file is for declarations,
      including token and type specifications, precedence directives,
      and other output directives, and the second section is for
      specifying the grammar of the language to be parsed.
    </p><p id="idp10355072">
      We'll start by declaring the list of tokens. A token is declared
      using the syntax
      <code>%token &lt;</code><span><em>type</em></span><code>&gt;</code>
<span><em>uid</em></span>, where the
      <code>&lt;type&gt;</code> is optional, and
      <span><em>uid</em></span> is a capitalized identifier. For JSON, we
      need tokens for numbers, strings, identifiers, and punctuation.
    </p><div class="rwocode"><pre><code>%token <span class="keyword2">&lt;</span><span class="keyword3">int</span><span class="keyword2">&gt;</span> <span class="keyword6">INT
</span>%token <span class="keyword2">&lt;</span><span class="keyword3">float</span><span class="keyword2">&gt;</span> <span class="keyword6">FLOAT
</span>%token <span class="keyword2">&lt;</span><span class="keyword3">string</span><span class="keyword2">&gt;</span> <span class="keyword6">ID
</span>%token <span class="keyword2">&lt;</span><span class="keyword3">string</span><span class="keyword2">&gt;</span> <span class="keyword6">STRING
</span>%token <span class="keyword6">TRUE
</span>%token <span class="keyword6">FALSE
</span>%token <span class="keyword6">NULL
</span>%token <span class="keyword6">LEFT_BRACE
</span>%token <span class="keyword6">RIGHT_BRACE
</span>%token <span class="keyword6">LEFT_BRACK
</span>%token <span class="keyword6">RIGHT_BRACK
</span>%token <span class="keyword6">COLON
</span>%token <span class="keyword6">COMMA
</span>%token EOF</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/parser.mly">parsing/parser.mly</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10359536">
      The
      <code>&lt;</code><span><em>type</em></span><code>&gt;</code>
      specifications mean that a token carries a value. The
      <code>INT</code> token carries an integer value with it,
      <code>FLOAT</code> has a <code>float</code> value, and
      both <code>ID</code> and <code>STRING</code> carry a
      <code>string</code> value. The remaining tokens, such as
      <code>TRUE</code>, <code>FALSE</code> or the
      punctuation, aren't associated with any value and so we can omit
      the
      <code>&lt;</code><span><em>type</em></span><code>&gt;</code>
      specification.
    </p><section><h1 id="describing-the-grammar">Describing the grammar</h1><p id="idp10370160">
        The next thing we need to do is to specify the grammar of a JSON
        expression. <code>menhir</code>, like many parsers,
        expresses grammars as <span><em>context free
        grammars</em></span>. (More precisely, <code>menhir</code>
        supports LR(1) grammars, but we will ignore that technical
        distinction here.) You can think of a context-free grammar as a
        set of abstract names, called <span><em>non-terminal
        symbols</em></span>, along with a collection of rules for
        transforming a non-terminal symbol into a sequence, where each
        element of the sequence is either a token or another
        non-terminal symbol. A sequence of tokens is parsable by a
        grammar if you can apply the grammar's rules to produce a series
        of transformations, starting at a distinguished <span><em>start
        symbol</em></span>, that produces the token sequence in question.
      </p><p id="idp10374048">
        We'll start describing the JSON grammar by declaring the
        start-symbol to be the non-terminal symbol
        <code>prog</code>, and by declaring that when parsed, a
        <code>prog</code> value should be converted into an OCaml
        value of type <code>Json.value option</code>. We then end
        the declaration section of the parser with a
        <code>%%</code>.
      </p><div class="rwocode"><pre><code>%start <span class="keyword2">&lt;</span><span class="keyword5">Json.</span>value option<span class="keyword2">&gt;</span> prog
%%</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/parser.mly">parsing/parser.mly</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10378288">
        Once that's in place, we can start specifying the productions.
        In <code>menhir</code>, productions are organized into
        <span><em>rules</em></span>, where each rule lists all the
        possible productions for a given non-terminal. Here, for
        example, is the rule for <code>prog</code>.
      </p><div class="rwocode"><pre><code>prog<span class="keyword2">:</span>
  <span class="keyword2">|</span> <span class="keyword6">EOF </span>      <span class="keyword2">{</span> <span class="keyword6">None </span><span class="keyword2">}</span>
  <span class="keyword2">|</span> v <span class="keyword2">=</span> value <span class="keyword2">{</span> <span class="keyword6">Some </span>v <span class="keyword2">}</span>
  <span class="keyword2">;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/parser.mly">parsing/parser.mly</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10381520">
        The syntax for this is reminiscent of an OCaml match statement.
        The pipes separate the individual productions, and the code in
        curly-braces is OCaml code that generates the OCaml value
        corresponding to the production in question. In the case of
        <code>prog</code>, we have two cases: either there's an
        <code>EOF</code>, which means the text is empty, and so
        there's no JSON value to read, and so we return the OCaml value
        <code>None</code>; or we have an instance of the
        <code>value</code> non-terminal, which corresponds to a
        well-formed JSON value, in which case we wrap the corresponding
        <code>Json.value</code> in a <code>Some</code> tag.
        Note that in the <code>value</code> case, we wrote
        <code>v = value</code> to bind the OCaml value that
        corresponds to to the variable <code>v</code>, which we
        can then use within the curly-braces for that production.
      </p><p id="idp10389088">
        Now let's consider a more complicated example, the rule for the
        <code>value</code> symbol.
      </p><div class="rwocode"><pre><code>value<span class="keyword2">:</span>
  <span class="keyword2">|</span> LEFT_BRACE<span class="keyword2">;</span> obj <span class="keyword2">=</span> object_fields<span class="keyword2">;</span> <span class="keyword6">RIGHT_BRACE
</span>    <span class="keyword2">{</span> <span class="keyword6">`Assoc </span>obj <span class="keyword2">}</span>
  <span class="keyword2">|</span> LEFT_BRACK<span class="keyword2">;</span> vl <span class="keyword2">=</span> array_values<span class="keyword2">;</span> <span class="keyword6">RIGHT_BRACK
</span>    <span class="keyword2">{</span> <span class="keyword6">`List </span>vl <span class="keyword2">}</span>
  <span class="keyword2">|</span> s <span class="keyword2">=</span> <span class="keyword6">STRING
</span>    <span class="keyword2">{</span> <span class="keyword6">`String </span>s <span class="keyword2">}</span>
  <span class="keyword2">|</span> i <span class="keyword2">=</span> <span class="keyword6">INT
</span>    <span class="keyword2">{</span> <span class="keyword6">`Int </span>i <span class="keyword2">}</span>
  <span class="keyword2">|</span> x <span class="keyword2">=</span> <span class="keyword6">FLOAT
</span>    <span class="keyword2">{</span> <span class="keyword6">`Float </span>x <span class="keyword2">}</span>
  <span class="keyword2">|</span> <span class="keyword6">TRUE
</span>    <span class="keyword2">{</span> <span class="keyword6">`Bool </span>true <span class="keyword2">}</span>
  <span class="keyword2">|</span> <span class="keyword6">FALSE
</span>    <span class="keyword2">{</span> <span class="keyword6">`Bool </span>false <span class="keyword2">}</span>
  <span class="keyword2">|</span> <span class="keyword6">NULL
</span>    <span class="keyword2">{</span> <span class="keyword6">`Null </span><span class="keyword2">}</span>
  <span class="keyword2">;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/parser.mly">parsing/parser.mly</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10391008">
        According to these rules, a JSON <code>value</code> is
        either:
      </p><ul><li><p id="idp10392704">
            an object bracketed by curly braces,
          </p></li><li><p id="idp10393552">
            an array bracketed by square braces,
          </p></li><li><p id="idp10394400">
            a string, integer, float, bool, or null value.
          </p></li></ul><p id="idp10395120">
        In each of the productions, the OCaml code in curly-braces shows
        what to transform the object in question to. Note that we still
        have two non-terminals whose definitions we depend on here, but
        have not yet defined: <code>object_fields</code> and
        <code>array_values</code>. We'll look at how these are
        parsed next.
      </p></section><section><h1 id="parsing-sequences">Parsing sequences</h1><p id="idp10398480">
        The rule for <code>object_fields</code> is shown below,
        and is really just a thin wrapper that reverses the list
        returned by the following rule for
        <code>rev_object_fields</code>. Note that the first
        production in <code>rev_object_fields</code> has an empty
        left-hand side. That's because what we're matching on in this
        case is an empty sequence of tokens. The comment
        <code>/* empty */</code> is used to make this clear.
        C-style comment syntax is used within the body of a rule.
      </p><div class="rwocode"><pre><code>object_fields<span class="keyword2">:</span> obj <span class="keyword2">=</span> rev_object_fields <span class="keyword2">{</span> <span class="keyword5">List.</span>rev obj <span class="keyword2">}</span><span class="keyword2">;</span>

rev_object_fields<span class="keyword2">:</span>
  <span class="keyword2">|</span> /<span class="keyword2">*</span> empty <span class="keyword2">*</span>/ <span class="keyword2">{</span> <span class="keyword2">[</span><span class="keyword2">]</span> <span class="keyword2">}</span>
  <span class="keyword2">|</span> obj <span class="keyword2">=</span> rev_object_fields<span class="keyword2">;</span> COMMA<span class="keyword2">;</span> k <span class="keyword2">=</span> ID<span class="keyword2">;</span> COLON<span class="keyword2">;</span> v <span class="keyword2">=</span> value
    <span class="keyword2">{</span> <span class="keyword2">(</span>k, v<span class="keyword2">)</span> <span class="keyword2">:</span><span class="keyword2">:</span> obj <span class="keyword2">}</span>
  <span class="keyword2">;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/parser.mly">parsing/parser.mly</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10402848">
        The rules are structured as they are because
        <code>menhir</code> generates left-recursive parsers,
        which means that the constructed pushdown automaton uses less
        stack space with left-recursive definitions. The following
        right-recursive rule accepts the same input, but during parsing
        it requires linear stack space to read object field definitions.
      </p><div class="rwocode"><pre><code>/<span class="keyword2">*</span> <span class="keyword6">Inefficient </span>right-recursive rule <span class="keyword2">*</span>/
object_fields<span class="keyword2">:</span>
  <span class="keyword2">|</span> /<span class="keyword2">*</span> empty <span class="keyword2">*</span>/ <span class="keyword2">{</span> <span class="keyword2">[</span><span class="keyword2">]</span> <span class="keyword2">}</span>
  <span class="keyword2">|</span> k <span class="keyword2">=</span> ID<span class="keyword2">;</span> COLON<span class="keyword2">;</span> v <span class="keyword2">=</span> value<span class="keyword2">;</span> COMMA<span class="keyword2">;</span> obj <span class="keyword2">=</span> object_fields
    <span class="keyword2">{</span> <span class="keyword2">(</span>k, v<span class="keyword2">)</span> <span class="keyword2">:</span><span class="keyword2">:</span> obj <span class="keyword2">}</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/right_rec_rule.mly">parsing/right_rec_rule.mly</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10405072">
        Alternatively, we could keep the left-recursive definition and
        simply construct the returned value in left-to-right order. This
        is is even less efficient, since the complexity of building thes
        list incrementally in this way is quadratic in the length of the
        list.
      </p><div class="rwocode"><pre><code>/<span class="keyword2">*</span> <span class="keyword6">Quadratic </span>left-recursive rule <span class="keyword2">*</span>/
object_fields<span class="keyword2">:</span>
  <span class="keyword2">|</span> /<span class="keyword2">*</span> empty <span class="keyword2">*</span>/ <span class="keyword2">{</span> <span class="keyword2">[</span><span class="keyword2">]</span> <span class="keyword2">}</span>
  <span class="keyword2">|</span> obj <span class="keyword2">=</span> object_fields<span class="keyword2">;</span> COMMA<span class="keyword2">;</span> k <span class="keyword2">=</span> ID<span class="keyword2">;</span> COLON<span class="keyword2">;</span> v <span class="keyword2">=</span> value
    <span class="keyword2">{</span> obj <span class="keyword2">@</span> <span class="keyword2">[</span>k, v<span class="keyword2">]</span> <span class="keyword2">}</span>
  <span class="keyword2">;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/quadratic_rule.mly">parsing/quadratic_rule.mly</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10406512">
        Assembling lists like this is a pretty common requirement in
        most realistic grammars, and the above rules (while useful for
        illustrating how parsing works) are rather verbose. Menhir
        features an extended standard library of built-in rules to
        simplify this handling. These rules are detailed in the Menhir
        manual, and include optional values, pairs of values with
        optional separators, and lists of elements (also with optional
        separators).
      </p><p id="idp10407424">
        A version of the JSON grammar using these more succinct Menhir
        rules is shown below. Notice the use of
        <code>separated_list</code> to parse both JSON objects and
        lists with one rule.
      </p><div class="rwocode"><pre><code>prog<span class="keyword2">:</span>
  <span class="keyword2">|</span> v <span class="keyword2">=</span> value <span class="keyword2">{</span> <span class="keyword6">Some </span>v <span class="keyword2">}</span>
  <span class="keyword2">|</span> <span class="keyword6">EOF </span>      <span class="keyword2">{</span> <span class="keyword6">None </span>  <span class="keyword2">}</span> <span class="keyword2">;</span>

value<span class="keyword2">:</span>
  <span class="keyword2">|</span> LEFT_BRACE<span class="keyword2">;</span> obj <span class="keyword2">=</span> obj_fields<span class="keyword2">;</span> <span class="keyword6">RIGHT_BRACE </span><span class="keyword2">{</span> <span class="keyword6">`Assoc </span>obj  <span class="keyword2">}</span>
  <span class="keyword2">|</span> LEFT_BRACK<span class="keyword2">;</span> vl <span class="keyword2">=</span> list_fields<span class="keyword2">;</span> <span class="keyword6">RIGHT_BRACK </span><span class="keyword2">{</span> <span class="keyword6">`List </span>vl    <span class="keyword2">}</span>
  <span class="keyword2">|</span> s <span class="keyword2">=</span> <span class="keyword6">STRING </span>                               <span class="keyword2">{</span> <span class="keyword6">`String </span>s   <span class="keyword2">}</span>
  <span class="keyword2">|</span> i <span class="keyword2">=</span> <span class="keyword6">INT </span>                                  <span class="keyword2">{</span> <span class="keyword6">`Int </span>i      <span class="keyword2">}</span>
  <span class="keyword2">|</span> x <span class="keyword2">=</span> <span class="keyword6">FLOAT </span>                                <span class="keyword2">{</span> <span class="keyword6">`Float </span>x    <span class="keyword2">}</span>
  <span class="keyword2">|</span> <span class="keyword6">TRUE </span>                                     <span class="keyword2">{</span> <span class="keyword6">`Bool </span>true  <span class="keyword2">}</span>
  <span class="keyword2">|</span> <span class="keyword6">FALSE </span>                                    <span class="keyword2">{</span> <span class="keyword6">`Bool </span>false <span class="keyword2">}</span>
  <span class="keyword2">|</span> <span class="keyword6">NULL </span>                                     <span class="keyword2">{</span> <span class="keyword6">`Null </span>      <span class="keyword2">}</span> <span class="keyword2">;</span>

obj_fields<span class="keyword2">:</span>
    obj <span class="keyword2">=</span> separated_list<span class="keyword2">(</span>COMMA, obj_field<span class="keyword2">)</span>    <span class="keyword2">{</span> obj <span class="keyword2">}</span> <span class="keyword2">;</span>

obj_field<span class="keyword2">:</span>
    k <span class="keyword2">=</span> ID<span class="keyword2">;</span> COLON<span class="keyword2">;</span> v <span class="keyword2">=</span> value                  <span class="keyword2">{</span> <span class="keyword2">(</span>k, v<span class="keyword2">)</span> <span class="keyword2">}</span> <span class="keyword2">;</span>

list_fields<span class="keyword2">:</span>
    vl <span class="keyword2">=</span> separated_list<span class="keyword2">(</span>COMMA, value<span class="keyword2">)</span>         <span class="keyword2">{</span> vl <span class="keyword2">}</span> <span class="keyword2">;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/short_parser.mly">parsing/short_parser.mly</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10409440">
        We can invoke <code>menhir</code> by using
        <code>corebuild</code> with the
        <code>-use-menhir</code> flag. This tells the build system
        to switch to using <code>menhir</code> instead of
        <code>ocamlyacc</code> to handle files with the
        <code>.mly</code> suffix.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -use-menhir short_parser.mli
</div><div class="rwocodeout">menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' short_parser.mly &gt; short_parser.mly.depends</div><div class="rwocodeout">menhir --ocamlc 'ocamlfind ocamlc -w A-4-33-41-42-43-34-44 -strict-sequence -principal -g -annot -bin-annot -short-paths -thread -syntax camlp4o -package bin_prot.syntax -package sexplib.syntax,comparelib.syntax,fieldslib.syntax,variantslib.syntax -package core' --infer short_parser.mly</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/build_short_parser.out">parsing/build_short_parser.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section></section><section><h1 id="defining-a-lexer">Defining a lexer</h1><p id="idp10416320">
      For the next part, we need to define a lexer to tokenize the input
      text, meaning that we break the input into a sequence of words or
      tokens. For this, we'll define a lexer using
      <code>ocamllex</code>. In this case, the specification is
      placed in a file with a <code>.mll</code> suffix (we'll use
      the name <code>lexer.mll</code>). A lexer file has several
      parts in the following sequence.
    </p><div class="rwocode"><pre><code><div class="highlight">{ OCaml code }
let definitions...
rules...
{ OCaml code }
</div></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/lex.syntax">parsing/lex.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1 id="let-definitions-for-regular-expressions">Let-definitions for regular expressions</h1><p id="idp10421072">
        The OCaml code for the header and trailer is optional. The
        let-definitions are used to ease the definition of regular
        expressions by defining utility functions. They are optional,
        but very useful. To get started, let's define a utility function
        that can track the location of tokens across line breaks.
      </p><div class="rwocode"><pre><code><span class="keyword2">{</span>
<span class="keyword1">open</span> <span class="keyword6">Lexing
</span><span class="keyword1">open</span> <span class="keyword6">Parser
</span>
<span class="keyword1">exception</span> <span class="keyword6">SyntaxError </span><span class="keyword2">of</span> <span class="keyword3">string</span>

<span class="keyword4">let</span> next_line lexbuf <span class="keyword2">=</span>
  <span class="keyword4">let</span> pos <span class="keyword2">=</span> lexbuf.lex_curr_p <span class="keyword4">in</span>
  lexbuf.lex_curr_p <span class="keyword2">&lt;</span>-
    <span class="keyword2">{</span> pos <span class="keyword1">with</span> pos_bol <span class="keyword2">=</span> lexbuf.lex_curr_pos<span class="keyword2">;</span>
               pos_lnum <span class="keyword2">=</span> pos.pos_lnum <span class="keyword2">+</span> <span class="keyword8">1</span>
    <span class="keyword2">}</span>
<span class="keyword2">}</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/lexer.mll">parsing/lexer.mll</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10422544">
        The <code>Lexing</code> module defines a
        <code>lexbuf</code> structure that holds all of the lexer
        state, including the current location within the source file.
        The <code>next_line</code> function simply accesses the
        <code>lex_curr_p</code> field that holds the current
        location and updates its line number. This is intended to be
        called from within the lexing regular expressions that we'll
        define next.
      </p><p id="idp10426160">
        To get started with our rules, we know that we'll need to match
        numbers and strings, so let's define names for the regular
        expressions that specify their form.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword3">int</span> <span class="keyword2">=</span> '-'? <span class="keyword2">[</span>'<span class="keyword8">1</span>'-'<span class="keyword8">9</span>'<span class="keyword2">]</span> <span class="keyword2">[</span>'<span class="keyword8">0</span>'-'<span class="keyword8">9</span>'<span class="keyword2">]</span><span class="keyword2">*</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/lexer.mll">parsing/lexer.mll</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10427584">
        An integer is a sequence of digits, optionally preceded by a
        minus sign. Leading zeroes are not allowed. The question mark
        means that the preceding symbol <code>-</code> is
        optional. The square brackets ['1'-'9'] define a character
        range, meaning that the first digit of the integer should be
        1-9. The final range <code>['0'-'9']*</code> includes the
        star <code>*</code>, which means zero-or-more occurrences
        of the characters 0-9. Read formally then, an
        <code>int</code> has an optional minus sign, followed by a
        digit in the range 1-9, followed by zero or more digits in the
        range 0-9.
      </p><p id="idp10431328">
        Floating-point numbers are similar, but we deal with decimal
        points and exponents. We can use multiple let-definitions for
        the different parts.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> digits <span class="keyword2">=</span> <span class="keyword2">[</span>'<span class="keyword8">0</span>'-'<span class="keyword8">9</span>'<span class="keyword2">]</span>
<span class="keyword4">let</span> frac <span class="keyword2">=</span> '.' digits<span class="keyword2">*</span>
<span class="keyword4">let</span> exp <span class="keyword2">=</span> <span class="keyword2">[</span>'e' 'E'<span class="keyword2">]</span> <span class="keyword2">[</span>'-' '<span class="keyword2">+</span>'<span class="keyword2">]</span>? digits<span class="keyword2">+</span>
<span class="keyword4">let</span> <span class="keyword3">float</span> <span class="keyword2">=</span> digits<span class="keyword2">*</span> frac? exp?</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/lexer.mll">parsing/lexer.mll</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10432624">
        The <code>digits</code> expression defines a single
        character regexp in the range 0-9. A fractional part
        <code>frac</code> has a compulsary decimal point followed
        by some optional digits; an exponent <code>exp</code>
        begins with an <code>e</code> followed by some digits; and
        a <code>float</code> has an integer part, and one, both or
        none of a <code>frac</code> and <code>exp</code>
        part.
      </p><p id="idp10438192">
        Finally, let's define identifiers and whitespace. An identifier
        (label), is an alphanumeric sequence not beginning with a digit.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> white <span class="keyword2">=</span> <span class="keyword2">[</span>' ' '\t'<span class="keyword2">]</span><span class="keyword2">+</span>
<span class="keyword4">let</span> newline <span class="keyword2">=</span> '\r' <span class="keyword2">|</span> '\n' <span class="keyword2">|</span> <span class="keyword7">&quot;\r\n&quot;</span>

<span class="keyword4">let</span> id <span class="keyword2">=</span> <span class="keyword2">[</span>'a'-'z' 'A'-'<span class="keyword6">Z' </span>'_'<span class="keyword2">]</span> <span class="keyword2">[</span>'a'-'z' 'A'-'<span class="keyword6">Z' </span>'<span class="keyword8">0</span>'-'<span class="keyword8">9</span>' '_'<span class="keyword2">]</span><span class="keyword2">*</span>
<span class="keyword4">let</span> hex <span class="keyword2">=</span> <span class="keyword2">[</span>'<span class="keyword8">0</span>'-'<span class="keyword8">9</span>' 'a'-'f' 'A'-'F'<span class="keyword2">]</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/lexer.mll">parsing/lexer.mll</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="lexing-rules">Lexing rules</h1><p id="idp10440704">
        The lexing rules are specified as a set of
        <code>parse</code> rules. A <code>parse</code> rule
        has a regular expression followed by OCaml code that defines a
        semantic action. Let's write the rule for JSON next.
      </p><div class="rwocode"><pre><code>rule read <span class="keyword2">=</span> parse
<span class="keyword2">|</span> white    <span class="keyword2">{</span> read lexbuf <span class="keyword2">}</span>
<span class="keyword2">|</span> newline  <span class="keyword2">{</span> next_line lexbuf<span class="keyword2">;</span> read lexbuf <span class="keyword2">}</span>
<span class="keyword2">|</span> <span class="keyword3">int</span>      <span class="keyword2">{</span> <span class="keyword6">INT </span><span class="keyword2">(</span>int_of_string <span class="keyword2">(</span><span class="keyword5">Lexing.</span>lexeme lexbuf<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">}</span>
<span class="keyword2">|</span> <span class="keyword3">float</span>    <span class="keyword2">{</span> <span class="keyword6">FLOAT </span><span class="keyword2">(</span>float_of_string <span class="keyword2">(</span><span class="keyword5">Lexing.</span>lexeme lexbuf<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">}</span>
<span class="keyword2">|</span> <span class="keyword7">&quot;true&quot;</span>   <span class="keyword2">{</span> <span class="keyword6">TRUE </span><span class="keyword2">}</span>
<span class="keyword2">|</span> <span class="keyword7">&quot;false&quot;</span>  <span class="keyword2">{</span> <span class="keyword6">FALSE </span><span class="keyword2">}</span>
<span class="keyword2">|</span> <span class="keyword7">&quot;null&quot;</span>   <span class="keyword2">{</span> <span class="keyword6">NULL </span><span class="keyword2">}</span>
<span class="keyword2">|</span> id       <span class="keyword2">{</span> <span class="keyword6">ID </span><span class="keyword2">(</span><span class="keyword5">Lexing.</span>lexeme lexbuf<span class="keyword2">)</span> <span class="keyword2">}</span>
<span class="keyword2">|</span> '<span class="keyword7">&quot;'      { read_string (Buffer.create 17) lexbuf }
| '{'      { LEFT_BRACE }
| '}'      { RIGHT_BRACE }
| '['      { LEFT_BRACK }
| ']'      { RIGHT_BRACK }
| ':'      { COLON }
| ','      { COMMA }
| _ { raise (SyntaxError (&quot;</span><span class="keyword6">Unexpected </span>char<span class="keyword2">:</span> &quot; <span class="keyword2">^</span> <span class="keyword5">Lexing.</span>lexeme lexbuf<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">}</span>
<span class="keyword2">|</span> eof      <span class="keyword2">{</span> <span class="keyword6">EOF </span><span class="keyword2">}</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/lexer.mll">parsing/lexer.mll</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10443456">
        The rules are structured very similarly to pattern matches,
        except that the variants are replaced by regular expressions on
        the left hand side. The right hand side clause is the parsed
        OCaml return value of that rule. The OCaml code for the rules
        has a parameter called <code>lexbuf</code> that defines
        the input, including the position in the input file, as well as
        the text that was matched by the regular expression.
      </p><p id="idp10445024">
        The first <code>white { read lexbuf }</code> calls the
        lexer recursively. That is, it skips the input whitespace and
        returns the following token. The action
        <code>newline { next_line lexbuf; read lexbuf }</code> is
        similar, but we use it to advance the line number for the lexer
        using the utility function that we defined at the top of the
        file. Let's skip to the third action.
      </p><div class="rwocode"><pre><code><span class="keyword2">|</span> <span class="keyword3">int</span> <span class="keyword2">{</span> <span class="keyword6">INT </span><span class="keyword2">(</span>int_of_string <span class="keyword2">(</span><span class="keyword5">Lexing.</span>lexeme lexbuf<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">}</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/lexer_int_fragment.mll">parsing/lexer_int_fragment.mll</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10447936">
        This action specifies that when the input matches the
        <code>int</code> regular expression, then the lexer should
        return the expression
        <code>INT (int_of_string (Lexing.lexeme lexbuf))</code>.
        The expression <code>Lexing.lexeme lexbuf</code> returns
        the complete string matched by the regular expression. In this
        case, the string represents a number, so we use the
        <code>int_of_string</code> function to convert it to a
        number.
      </p><p id="idp10451520">
        There are actions for each different kind of token. The string
        expressions like <code>&quot;true&quot; { TRUE }</code>
        are used for keywords, and the special characters have actions
        too, like <code>'{' { LEFT_BRACE }</code>.
      </p><p id="idp10453568">
        Some of these patterns overlap. For example, the regular
        expression <code>&quot;true&quot;</code> is also matched
        by the <code>id</code> pattern.
        <code>ocamllex</code> used the following disambiguation
        when a prefix of the input is matched by more than one pattern.
      </p><ul><li><p id="idp10456800">
            The longest match always wins. For example, the first input
            <code>trueX:   167</code> matches the regular
            expression <code>&quot;true&quot;</code> for 4
            characters, and it matches <code>id</code> for 5
            characters. The longer match wins, and the return value is
            <code>ID &quot;trueX&quot;</code>.
          </p></li><li><p id="idp10460656">
            If all matches have the same length, then the first action
            wins. If the input were <code>true: 167</code>, then
            both <code>&quot;true&quot;</code> and
            <code>id</code> match the first 4 characters;
            <code>&quot;true&quot;</code> is first, so the return
            value is <code>TRUE</code>.
          </p></li></ul></section><section><h1 id="recursive-rules">Recursive rules</h1><p id="idp10466288">
        Unlike many other lexer generators, <code>ocamllex</code>
        allows the definition of multiple lexers in the same file, and
        the definitions can be recursive. In this case, we use recursion
        to match string literals using the following rule definition.
      </p><div class="rwocode"><pre><code><span class="keyword4">and</span> read_string buf <span class="keyword2">=</span> parse
<span class="keyword2">|</span> '<span class="keyword7">&quot;' { STRING (Buffer.contents buf) }
| '\\' '/' { Buffer.add_char buf '/'; read_string buf lexbuf }
| '\\' '\\' { Buffer.add_char buf '\\'; read_string buf lexbuf }
| '\\' 'b' { Buffer.add_char buf '\b'; read_string buf lexbuf }
| '\\' 'f' { Buffer.add_char buf '\012'; read_string buf lexbuf }
| '\\' 'n' { Buffer.add_char buf '\n'; read_string buf lexbuf }
| '\\' 'r' { Buffer.add_char buf '\r'; read_string buf lexbuf }
| '\\' 't' { Buffer.add_char buf '\t'; read_string buf lexbuf }
| [^ '&quot;</span>' '\\'<span class="keyword2">]</span><span class="keyword2">+</span>
  <span class="keyword2">{</span> <span class="keyword5">Buffer.</span>add_string buf <span class="keyword2">(</span><span class="keyword5">Lexing.</span>lexeme lexbuf<span class="keyword2">)</span><span class="keyword2">;</span>
    read_string buf lexbuf
  <span class="keyword2">}</span>
<span class="keyword2">|</span> <span class="keyword8">_</span> <span class="keyword2">{</span> <span class="keyword1">raise</span> <span class="keyword2">(</span><span class="keyword6">SyntaxError </span><span class="keyword2">(</span><span class="keyword7">&quot;Illegal string character: &quot;</span> <span class="keyword2">^</span> <span class="keyword5">Lexing.</span>lexeme lexbuf<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">}</span>
<span class="keyword2">|</span> eof <span class="keyword2">{</span> <span class="keyword1">raise</span> <span class="keyword2">(</span><span class="keyword6">SyntaxError </span><span class="keyword2">(</span><span class="keyword7">&quot;String is not terminated&quot;</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">}</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/lexer.mll">parsing/lexer.mll</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10468384">
        This rule takes a <code>buf : Buffer.t</code> as an
        argument. If we reach the terminating double quote
        <code>&quot;</code>, then we return the contents of the
        buffer as a <code>STRING</code>.
      </p><p id="idp10471088">
        The other cases are for handling the string contents. The action
        <code>[^ '&quot;' '\\']+ { ... }</code> matches normal
        input that does not contain a double-quote or backslash. The
        actions beginning with a backslash <code>\</code> define
        what to do for escape sequences. In each of these cases, the
        final step includes a recursive call to the lexer.
      </p><p id="idp10473248">
        That covers the lexer. Next, we need to combine the lexer with
        the parser to bring it all together.
      </p><aside class="note"><h1>
      Handling Unicode
      </h1><p id="idp10474464">
        We've glossed over an important detail here: parsing Unicode
        characters to handle the full spectrum of the world's writing
        systems. OCaml has several third-party solutions to handling
        Unicode, with varying degrees of flexibility and complexity.
      </p><ul><li><p id="idp10475664">
<a href="http://camomile.sourceforge.net" target="_top">Camomile</a>
            supports the full spectrum of Unicode character types,
            conversion from around 200 encodings, and collation and
            locale-sensitive case mappings.
          </p></li><li><p id="idp10477344">
<a href="http://www.cduce.org/ulex" target="_top">Ulex</a> is a
            lexer generator for Unicode that can serve as a
            Unicode-aware replacement for <code>ocamllex</code>.
          </p></li><li><p id="idp10479664">
<a href="http://erratique.ch/software/uutf" target="_top">Uutf</a>
            is a non-blocking streaming Unicode codec for OCaml,
            available as a standalone library. It is accompanied by the
            <a href="http://erratique.ch/software/uunf" target="_top">Uunf</a>
            text normalization and
            <a href="http://erratique.ch/software/uucd" target="_top">Uucd</a>
            Unicode character database libraries. There is also a robust
            parser for
            <a href="http://erratique.ch/software/jsonm" target="_top">JSON</a>
            available that illustrates the use of Uutf in your own
            libraries.
          </p></li></ul><p id="idp10483584">
        All of these libraries are available via OPAM under their
        respective names.
      </p></aside></section></section><section><h1 id="bringing-it-all-together">Bringing it all together</h1><p id="idp10485600">
      For the final part, we need to compose the lexer and parser. As we
      saw in the type definition in <code>parser.mli</code>, the
      parsing function expects a lexer of type
      <code>Lexing.lexbuf -&gt; token</code>, and it also expects
      a <code>lexbuf</code>.
    </p><div class="rwocode"><pre><code><span class="keyword4">val</span> prog<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword5">Lexing.</span>lexbuf -<span class="keyword2">&gt;</span> token<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword5">Lexing.</span>lexbuf -<span class="keyword2">&gt;</span> <span class="keyword5">Json.</span>value option</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing/prog.mli">parsing/prog.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10489056">
      Before we start with the lexing, let's first define some functions
      to handle parsing errors. There are currently two errors:
      <code>Parser.Error</code> and
      <code>Lexer.SyntaxError</code>. A simple solution when
      encountering an error is to print the error and give up, which we
      do below.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword6">Lexer
</span><span class="keyword1">open</span> <span class="keyword6">Lexing
</span>
<span class="keyword4">let</span> print_position outx lexbuf <span class="keyword2">=</span>
  <span class="keyword4">let</span> pos <span class="keyword2">=</span> lexbuf.lex_curr_p <span class="keyword4">in</span>
  fprintf outx <span class="keyword7">&quot;%s:%d:%d&quot;</span> pos.pos_fname
    pos.pos_lnum <span class="keyword2">(</span>pos.pos_cnum - pos.pos_bol <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span>

<span class="keyword4">let</span> parse_with_error lexbuf <span class="keyword2">=</span>
  <span class="keyword1">try</span> <span class="keyword5">Parser.</span>prog <span class="keyword5">Lexer.</span>read lexbuf <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">SyntaxError </span>msg -<span class="keyword2">&gt;</span>
    fprintf stderr <span class="keyword7">&quot;%a: %s\n&quot;</span> print_position lexbuf msg<span class="keyword2">;</span>
    <span class="keyword6">None
</span>  <span class="keyword2">|</span> <span class="keyword5">Parser.Error </span>-<span class="keyword2">&gt;</span>
    fprintf stderr <span class="keyword7">&quot;%a: syntax error\n&quot;</span> print_position lexbuf<span class="keyword2">;</span>
    exit <span class="keyword2">(</span><span class="keyword8">-1</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing-test/test.ml">parsing-test/test.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10491856">
      The &quot;give up on the first error&quot; approach is easy to
      implement but isn't very friendly. In general, error handling can
      be pretty intricate, and we won't discuss it here. However, the
      Menhir parser defines additional mechanisms you can use to try and
      recover from errors. These are described in detail in its
      reference
      <a href="http://gallium.inria.fr/~fpottier/menhir/" target="_top">manual</a>.
    </p><p id="idp10493856">
      The standard lexing library <code>Lexing</code> provides a
      function <code>from_channel</code> to read the input from a
      channel. The following function describes the structure, where the
      <code>Lexing.from_channel</code> function is used to
      construct a <code>lexbuf</code>, which is passed with the
      lexing function <code>Lexer.read</code> to the
      <code>Parser.prog</code> function.
      <code>Parsing.prog</code> returns <code>None</code>
      when it reaches end of file. We define a function
      <code>Json.output_value</code>, not shown here, to print a
      <code>Json.value</code>.
    </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword4">rec</span> parse_and_print lexbuf <span class="keyword2">=</span>
  <span class="keyword1">match</span> parse_with_error lexbuf <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Some </span>value -<span class="keyword2">&gt;</span>
    printf <span class="keyword7">&quot;%a\n&quot;</span> <span class="keyword5">Json.</span>output_value value<span class="keyword2">;</span>
    parse_and_print lexbuf
  <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span>

<span class="keyword4">let</span> loop filename <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> inx <span class="keyword2">=</span> <span class="keyword5">In_channel.</span>create filename <span class="keyword4">in</span>
  <span class="keyword4">let</span> lexbuf <span class="keyword2">=</span> <span class="keyword5">Lexing.</span>from_channel inx <span class="keyword4">in</span>
  lexbuf.lex_curr_p <span class="keyword2">&lt;</span>- <span class="keyword2">{</span> lexbuf.lex_curr_p <span class="keyword1">with</span> pos_fname <span class="keyword2">=</span> filename <span class="keyword2">}</span><span class="keyword2">;</span>
  parse_and_print lexbuf<span class="keyword2">;</span>
  <span class="keyword5">In_channel.</span>close inx</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing-test/test.ml">parsing-test/test.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10502432">
      Here's a test input file we can use to test the code we just
      wrote.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="kc">true</span>
<span class="kc">false</span>
<span class="kc">null</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="err">.</span><span class="p">,</span> <span class="mi">4</span><span class="err">.</span><span class="mi">0</span><span class="p">,</span> <span class="err">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="err">.</span><span class="mi">5</span><span class="err">e</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="err">.</span><span class="mi">3</span><span class="p">]</span>
<span class="s2">&quot;Hello World&quot;</span>
<span class="p">{</span> <span class="err">field1:</span> <span class="nt">&quot;Hello&quot;</span><span class="p">,</span>
  <span class="err">field2:</span> <span class="err">17e13,</span>
  <span class="err">field3:</span> <span class="err">[1,</span> <span class="err">2,</span> <span class="err">3],</span>
  <span class="err">field4:</span> <span class="err">{</span> <span class="err">fieldA:</span> <span class="err">1,</span> <span class="err">fieldB:</span> <span class="nt">&quot;Hello&quot;</span> <span class="p">}</span>
<span class="err">}</span>
</div></code></pre><div class="rwocodeinfo">JSON ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing-test/test1.json">parsing-test/test1.json</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10503632">
      Now build and run the example using this file, and you you can see
      the full parser in action.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlbuild -use-menhir -tag thread -use-ocamlfind -pkg core test.native
</div><div class="rwocodeout">/home/rwo/.opam/4.01.0dev+trunk/bin/ocamllex.opt -q lexer.mll</div><div class="rwocodeout">menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' parser.mly &gt; parser.mly.depends</div><div class="rwocodeout">menhir --ocamlc 'ocamlfind ocamlc -thread -package core' --infer parser.mly</div><div class="highlight"><span class="gp">$</span> ./test.native test1.json
</div><div class="rwocodeout">true</div><div class="rwocodeout">false</div><div class="rwocodeout">null</div><div class="rwocodeout">[1, 2, 3.000000, 4.000000, 0.500000, 550000.000000, 6.300000]</div><div class="rwocodeout">&quot;Hello World&quot;</div><div class="rwocodeout">{ field1: &quot;Hello&quot;, field2: 170000000000000.000000, field3: [1, 2, 3], field4: { fieldA: 1, fieldB: &quot;Hello&quot; } }</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing-test/build_test.out">parsing-test/build_test.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10504864">
      With our simple error handling scheme, errors are fatal and cause
      the program to terminate with a non-zero exit code.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> cat test2.json
</div><div class="rwocodeout">{ name: &quot;Chicago&quot;,</div><div class="rwocodeout">  zips: [12345,</div><div class="rwocodeout">}</div><div class="rwocodeout">{ name: &quot;New York&quot;,</div><div class="rwocodeout">  zips: [10004]</div><div class="rwocodeout">}</div><div class="highlight"><span class="gp">$</span> ./test.native test2.json
</div><div class="rwocodeout">test2.json:3:2: syntax error</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/parsing-test/run_broken_test.out">parsing-test/run_broken_test.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10506128">
      That wraps up our parsing tutorial. As an aside, notice that the
      JSON polymorphic variant type that we defined in this chapter is
      actually structurally compatible with the Yojson representation
      explained earlier in
      <a href="handling-json-data.html">Chapter 15, <i>Handling JSON data</i></a>. That means that
      you can take this parser and use it with the helper functions in
      Yojson to build more sophisticated applications.
    </p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="handling-json-data.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="data-serialization-with-s-expressions.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>