<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 14. Command Line Parsing / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta2',
                        page: 'command\u002Dline\u002Dparsing.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="maps-and-hash-tables.html">13. Maps and Hash Tables</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html" class="here">14. Command Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">15. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-menhir.html">16. Parsing with OCamllex and Menhir</a>
                                            </li>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html">17. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">18. Concurrent Programming with Async</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 14. Command Line Parsing</h1>
                
                

    <p id="idp9773952">
    Many of the OCaml programs that you'll write will end up as binaries
    that need to be run from a command prompt. Any non-trivial
    command-line should support a collection of basic features:
  </p><ul><li><p id="idp9775072">
        Parsing of command line arguments.
      </p></li><li><p id="idp9775904">
        Generation of error messages in response to incorrect inputs.
      </p></li><li><p id="idp9776768">
        Help for all the available options.
      </p></li><li><p id="idp9777600">
        Interactive auto-completion of commands to assist the user.
      </p></li></ul><p id="idp9778336">
    It's tedious and error-prone to code all this manually for every
    program you write. Core provides the Command library that simplifies
    all of this by letting you declare all your command-line options in
    one place, and deriving all of the above functionality from that
    declaration.
  </p><p id="idp9779040">
    Command is simple to use for simple applications, but also also
    scales well as your needs grow more complex. In particular, Command
    provides a sophisticated subcommand mode that groups related
    commands together as the complexity of your user interface grows.
    You may already be familiar with this command-line style from the
    Git or Mercurial version control systems.
  </p><p id="idp9779840">
    In this chapter, we'll:
  </p><ul><li><p id="idp9780784">
        Learn how to use Command to construct basic and grouped
        command-line interfaces.
      </p></li><li><p id="idp9781680">
        See examples that extend the cryptographic utility from
        <a href="classes.html">Chapter 12, <i>Classes</i></a> and build a simple
        equivalent to the <code>md5</code> and
        <code>shasum</code> utilities.
      </p></li><li><p id="idp9784704">
        Demonstrate how <span><em>functional combinators</em></span> can
        be used to declare complex command line interfaces in a
        type-safe and elegant way.
      </p></li></ul><section><h1 id="basic-command-line-parsing">Basic command-line parsing</h1><p id="idp9787072">
      Let's start by working through a clone of the
      <code>md5sum</code> command that is present on most Linux
      installations (the equivalent command on MacOS X is simply
      <code>md5</code>). The function defined below reads in the
      contents of a file, applies the MD5 one-way cryptographic hash
      function to the data, and outputs an ASCII hex representation of
      the result.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> do_hash file <span class="keyword2">=</span>
  <span class="keyword5">In_channel.</span>with_file file ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> ic -<span class="keyword2">&gt;</span>
    <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Cryptokit </span><span class="keyword4">in</span>
    hash_channel <span class="keyword2">(</span><span class="keyword5">Hash.</span>md5 <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> ic
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> transform_string <span class="keyword2">(</span><span class="keyword5">Hexa.</span>encode <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline
  <span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5.ml">command-line-parsing/basic_md5.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9789968">
      The <code>do_hash</code> function accepts a
      <code>filename</code> parameter and prints the
      human-readable MD5 string to the console standard output. The
      first step towards turning this function into a command-line
      program is to declare all the possible command-line arguments in a
      <span><em>specification</em></span>.
      <code>Command.Spec</code> defines combinators that can be
      chained together to define optional flags and positional
      arguments, what types they should map to, and whether to take
      special actions (such as pausing for interactive input) if certain
      inputs are encountered.
    </p><section><h1 id="anonymous-arguments">Anonymous arguments</h1><p id="idp9794640">
        Let's build the specification for a single argument that is
        passed directly on the command-line. This is known as an
        <span><em>anonymous</em></span> argument.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> spec <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword5">Command.Spec </span><span class="keyword4">in</span>
  empty
  <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5.ml">command-line-parsing/basic_md5.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9796368">
        The <code>Command.Spec</code> module defines the tools
        you'll need to build up a command-line specification. We start
        with the <code>empty</code> value, and add parameters to
        that using the <code>+&gt;</code> combinator. (Both of
        these values come from <code>Command.Spec</code>.)
      </p><p id="idp9799824">
        In this case, we defined a single anonymous argument called
        <code>filename</code> which takes a value of type
        <code>string</code>. Anonymous parameters are created
        using the <code>%:</code> operator, which binds a textual
        name (used in the help text to identify the parameter) to an
        OCaml conversion function that parses the command-line string
        fragments into a higher-level OCaml data type. In the example
        above this is just <code>Command.Spec.string</code>, but
        we'll see more complex conversion options later in the chapter.
      </p></section><section><h1 id="defining-basic-commands">Defining basic commands</h1><p id="idp9804784">
        Once we've defined a specification, we need to put it to work on
        real input. The simplest way is to directly create a
        command-line interface via the <code>Command.basic</code>
        module.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    ~readme<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;More detailed information&quot;</span><span class="keyword2">)</span>
    spec
    <span class="keyword2">(</span><span class="keyword1">fun</span> filename <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> do_hash filename<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5.ml">command-line-parsing/basic_md5.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9806816">
<code>Command.basic</code> defines a complete command-line
        interface that takes the following extra arguments, in addition
        to the ones defined in the specification.
      </p><ul><li><p id="idp9808576">
<code>summary</code> is a required one-line
            description to go at the top of the command help screen.
          </p></li><li><p id="idp9810144">
<code>readme</code> is for longer help text when the
            command is called with <code>-help</code>. The
            <code>readme</code> argument is a function that is
            only evaluated when the help text is actually needed.
          </p></li><li><p id="idp9813216">
            The specification and the callback function follow as
            non-labeled arguments.
          </p></li></ul><p id="idp9813984">
        The callback function is where all the work happens after the
        command-line parsing is complete. This function is applied with
        the arguments containing the parsed command-line values, and it
        takes over as the main thread of the application. The callback's
        arguments are passed in the same order as they were bound in the
        specification (using the <code>+&gt;</code> operator).
      </p><aside class="note"><h1>
      The extra unit argument to callbacks
      </h1><p id="idp9816912">
        The callback above needs an extra <code>unit</code>
        argument after <code>filename</code>. This is to ensure
        that specifications can work even when they are empty
        (<span><em>i.e.</em></span> the
        <code>Command.Spec.empty</code> value).
      </p><p id="idp9820064">
        Every OCaml function needs at least one argument, so the final
        <code>unit</code> guarantees that it will not be evaluated
        immediately as a value if there are no other arguments.
      </p></aside></section><section><h1 id="running-basic-commands">Running basic commands</h1><p id="idp9822656">
        Once we've defined the basic command, running it is just one
        function call away.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>run ~version<span class="keyword2">:</span><span class="keyword7">&quot;1.0&quot;</span> ~build_info<span class="keyword2">:</span><span class="keyword7">&quot;RWO&quot;</span> command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5.ml">command-line-parsing/basic_md5.ml</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9823904">
<code>Command.run</code> takes a couple of optional
        arguments that are useful to identify which version of the
        binary you are running in production. Let's build the complete
        MD5 example first so that we can see this in action. Makes sure
        to run <code>opam install cryptokit</code> if you didn't
        do so when reading <a href="classes.html">Chapter 12, <i>Classes</i></a>.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg cryptokit basic_md5.native
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/build_basic_md5.out">command-line-parsing/build_basic_md5.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9827408">
        You can now query the version information for the binary you
        just compiled.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./basic_md5.native -version
</div><div class="rwocodeout">1.0</div><div class="highlight"><span class="gp">$</span> ./basic_md5.native -build-info
</div><div class="rwocodeout">RWO</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/get_basic_md5_version.out">command-line-parsing/get_basic_md5_version.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9828640">
        The versions that you see in the output were defined via the
        optional arguments to <code>Command.run</code>. You can
        leave these blank in your own programs or get your build system
        to generate them directly from your version control system
        (<span><em>e.g.</em></span> by running <code>hg id</code>
        to generate a build revision number, in the case of Mercurial).
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./basic_md5.native
</div><div class="rwocodeout">Generate an MD5 hash of the input data</div><div class="rwocodeout"> </div><div class="rwocodeout">  basic_md5.native FILENAME</div><div class="rwocodeout"> </div><div class="rwocodeout">More detailed information</div><div class="rwocodeout"> </div><div class="rwocodeout">=== flags ===</div><div class="rwocodeout"> </div><div class="rwocodeout">  [-build-info]  print info about this build and exit</div><div class="rwocodeout">  [-version]     print the version of this build and exit</div><div class="rwocodeout">  [-help]        print this help text and exit</div><div class="rwocodeout">                 (alias: -?)</div><div class="rwocodeout"> </div><div class="rwocodeout">missing anonymous argument: FILENAME</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/get_basic_md5_help.out">command-line-parsing/get_basic_md5_help.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9831968">
        When we invoke this binary without any arguments, it helpfully
        displays all of the command-line options available, along with a
        message to the standard error that informs you that a required
        argument <code>filename</code> is missing.
      </p><p id="idp9833328">
        If you do supply the <code>filename</code> argument, then
        <code>do_hash</code> is called with the argument and the
        MD5 output is displayed to the standard output.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./basic_md5.native ./basic_md5.native
</div><div class="rwocodeout">c9970914b335e160e5597aef11c2c0fa</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/run_basic_md5.out">command-line-parsing/run_basic_md5.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9836032">
        And that's all it took to build our little MD5 utility! Here's a
        complete version of the example we just walked through, but made
        slightly more succinct by removing intermediate variables.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> do_hash file <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">In_channel.</span>with_file file ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> ic -<span class="keyword2">&gt;</span>
    <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Cryptokit </span><span class="keyword4">in</span>
    hash_channel <span class="keyword2">(</span><span class="keyword5">Hash.</span>md5 <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> ic
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> transform_string <span class="keyword2">(</span><span class="keyword5">Hexa.</span>encode <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline
  <span class="keyword2">)</span>

<span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    ~readme<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;More detailed information&quot;</span><span class="keyword2">)</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">)</span><span class="keyword2">)</span>
    do_hash

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>run ~version<span class="keyword2">:</span><span class="keyword7">&quot;1.0&quot;</span> ~build_info<span class="keyword2">:</span><span class="keyword7">&quot;RWO&quot;</span> command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5_succinct.ml">command-line-parsing/basic_md5_succinct.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9837392">
        Now that we have the basics in place, the rest of the chapter
        will examine some of the more advanced features of Command.
      </p></section></section><section><h1 id="argument-types">Argument types</h1><p id="idp9839232">
      You aren't just limited to parsing command lines as strings, of
      course. <code>Command.Spec</code> defines several other
      conversion functions that validate and parse input into various
      types.
    </p><table><thead><tr><th>
              Argument type
            </th><th>
              OCaml type
            </th><th>
              Example
            </th></tr></thead><tbody><tr><td>
<code>string</code>
</td><td>
<code>string</code>
</td><td>
<code>foo</code>
</td></tr><tr><td>
<code>int</code>
</td><td>
<code>int</code>
</td><td>
<code>123</code>
</td></tr><tr><td>
<code>float</code>
</td><td>
<code>float</code>
</td><td>
<code>123.01</code>
</td></tr><tr><td>
<code>bool</code>
</td><td>
<code>bool</code>
</td><td>
<code>true</code>
</td></tr><tr><td>
<code>date</code>
</td><td>
<code>Date.t</code>
</td><td>
<code>2013-12-25</code>
</td></tr><tr><td>
<code>time_span</code>
</td><td>
<code>Span.t</code>
</td><td>
<code>5s</code>
</td></tr><tr><td>
<code>file</code>
</td><td>
<code>string</code>
</td><td>
<code>/etc/passwd</code>
</td></tr></tbody></table><p id="idp9870672">
      We can tighten up the specification of the command to
      <code>file</code> to reflect that the argument must be a
      valid filename, and not just any string.
    </p><div class="rwocode"><pre><code><span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    ~readme<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;More detailed information&quot;</span><span class="keyword2">)</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> file<span class="keyword2">)</span><span class="keyword2">)</span>
    do_hash

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>run ~version<span class="keyword2">:</span><span class="keyword7">&quot;1.0&quot;</span> ~build_info<span class="keyword2">:</span><span class="keyword7">&quot;RWO&quot;</span> command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5_as_filename.ml">command-line-parsing/basic_md5_as_filename.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9872688">
      Running this with a non-existent filename will now output an error
      if the file doesn't exist. As a bonus, it also enables interactive
      command-line completion to work on the filename argument
      (explained later in the chapter).
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./basic_md5_as_filename.native nonexistent
</div><div class="rwocodeout">Fatal error: exception Sys_error(&quot;nonexistent: No such file or directory&quot;)</div><div class="rwocodeout">Raised by primitive operation at file &quot;pervasives.ml&quot;, line 292, characters 20-46</div><div class="rwocodeout">Called from file &quot;lib/in_channel.ml&quot;, line 19, characters 46-65</div><div class="rwocodeout">Called from file &quot;lib/command.ml&quot;, line 1387, characters 4-54</div><div class="rwocodeout">Called from file &quot;basic_md5_as_filename.ml&quot;, line 21, characters 2-54</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/run_basic_md5_as_filename.out">command-line-parsing/run_basic_md5_as_filename.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1 id="defining-custom-argument-types">Defining custom argument types</h1><p id="idp9875232">
        We can also define our own argument types if the predefined ones
        aren't sufficient. For instance, let's make a
        <code>regular_file</code> argument type that ensures that
        the input file isn't a character device or some other odd UNIX
        file type that can't be fully read.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> do_hash file <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">In_channel.</span>with_file file ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> ic -<span class="keyword2">&gt;</span>
    <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Cryptokit </span><span class="keyword4">in</span>
    hash_channel <span class="keyword2">(</span><span class="keyword5">Hash.</span>md5 <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> ic
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> transform_string <span class="keyword2">(</span><span class="keyword5">Hexa.</span>encode <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline
  <span class="keyword2">)</span>

<span class="keyword4">let</span> regular_file <span class="keyword2">=</span>
  <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword5">Arg_type.</span>create
    <span class="keyword2">(</span><span class="keyword1">fun</span> filename -<span class="keyword2">&gt;</span>
       <span class="keyword1">match</span> <span class="keyword5">Sys.</span>is_file filename <span class="keyword1">with</span>
       <span class="keyword2">|</span> <span class="keyword6">`Yes </span>-<span class="keyword2">&gt;</span> filename
       <span class="keyword2">|</span> <span class="keyword6">`No </span><span class="keyword2">|</span> <span class="keyword6">`Unknown </span>-<span class="keyword2">&gt;</span>
         eprintf <span class="keyword7">&quot;'%s' is not a regular file.\n%!&quot;</span> filename<span class="keyword2">;</span>
         exit <span class="keyword8">1</span>
    <span class="keyword2">)</span>

<span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    ~readme<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;More detailed information&quot;</span><span class="keyword2">)</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> regular_file<span class="keyword2">)</span><span class="keyword2">)</span>
    do_hash

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>run ~version<span class="keyword2">:</span><span class="keyword7">&quot;1.0&quot;</span> ~build_info<span class="keyword2">:</span><span class="keyword7">&quot;RWO&quot;</span> command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5_with_custom_arg.ml">command-line-parsing/basic_md5_with_custom_arg.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9877376">
        The <code>regular_file</code> function transforms a
        <code>filename</code> string parameter into the same
        string, but first checks that the file exists and is a regular
        file type. When you build and run this code, you will see the
        new error messages if you try to open a special device such as
        <code>/dev/null</code>.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./basic_md5_with_custom_arg.native /etc/passwd
</div><div class="rwocodeout">8cfb68a5622dd12932df658a54698aad</div><div class="highlight"><span class="gp">$</span> ./basic_md5_with_custom_arg.native /dev/null
</div><div class="rwocodeout">'/dev/null' is not a regular file.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/run_basic_md5_with_custom_arg.out">command-line-parsing/run_basic_md5_with_custom_arg.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="optional-and-default-arguments">Optional and default arguments</h1><p id="idp9882288">
        A more realistic MD5 binary could also read from the standard
        input if a <code>filename</code> isn't specified.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    ~readme<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;More detailed information&quot;</span><span class="keyword2">)</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span>maybe <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">)</span>
    do_hash

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>run ~version<span class="keyword2">:</span><span class="keyword7">&quot;1.0&quot;</span> ~build_info<span class="keyword2">:</span><span class="keyword7">&quot;RWO&quot;</span> command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5_with_optional_file_broken.ml">command-line-parsing/basic_md5_with_optional_file_broken.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9884288">
        This just wraps the <code>filename</code> argument
        declaration in the <code>maybe</code> function to mark it
        as an optional argument. However, building this results in a
        compile-time error.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlbuild -use-ocamlfind -pkg cryptokit,core -tag thread basic_md5_with_optional_file_broken.native
</div><div class="rwocodeout">File &quot;basic_md5_with_optional_file_broken.ml&quot;, line 18, characters 4-11:</div><div class="rwocodeout">Error: This expression has type string -&gt; unit -&gt; unit</div><div class="rwocodeout">       but an expression was expected of type string option -&gt; unit -&gt; unit</div><div class="rwocodeout">       Type string is not compatible with type string option </div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/build_basic_md5_with_optional_file_broken.out">command-line-parsing/build_basic_md5_with_optional_file_broken.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9887056">
        This is because changing the argument type has also changed the
        type of the callback function. It now wants a
        <code>string option</code> instead of a
        <code>string</code> since the value has become optional.
        We can adapt our example to use the new information and read
        from standard input if no file is specified.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> get_inchan <span class="keyword2">=</span> <span class="keyword1">function</span>
  <span class="keyword2">|</span> <span class="keyword6">None </span><span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword7">&quot;-&quot;</span> -<span class="keyword2">&gt;</span>
    <span class="keyword5">In_channel.</span>stdin
  <span class="keyword2">|</span> <span class="keyword6">Some </span>filename -<span class="keyword2">&gt;</span>
    <span class="keyword5">In_channel.</span>create ~binary<span class="keyword2">:</span>true filename

<span class="keyword4">let</span> do_hash filename <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Cryptokit </span><span class="keyword4">in</span>
  get_inchan filename
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> hash_channel <span class="keyword2">(</span><span class="keyword5">Hash.</span>md5 <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> transform_string <span class="keyword2">(</span><span class="keyword5">Hexa.</span>encode <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline

<span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    ~readme<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;More detailed information&quot;</span><span class="keyword2">)</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span>maybe <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> file<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">)</span>
    do_hash

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>run ~version<span class="keyword2">:</span><span class="keyword7">&quot;1.0&quot;</span> ~build_info<span class="keyword2">:</span><span class="keyword7">&quot;RWO&quot;</span> command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5_with_optional_file.ml">command-line-parsing/basic_md5_with_optional_file.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9889920">
        The <code>filename</code> parameter to
        <code>do_hash</code> is now a
        <code>string option</code> type. This is resolved into an
        input channel via <code>get_file_data</code> to determine
        whether to open the standard input or a file, and then the rest
        of the command is similar to our previous examples.
      </p><p id="idp9893408">
        Another possible way to handle this would be to supply a dash as
        the default filename if one isn't specified. The
        <code>maybe_with_default</code> function can do just this,
        with the benefit of not having to change the callback parameter
        type (which may be a problem in more complex applications).
      </p><p id="idp9894832">
        The example below behaves exactly the same as the previous
        example, but replaces <code>maybe</code> with
        <code>maybe_with_default</code>.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> get_inchan <span class="keyword2">=</span> <span class="keyword1">function</span>
  <span class="keyword2">|</span> <span class="keyword7">&quot;-&quot;</span>      -<span class="keyword2">&gt;</span> <span class="keyword5">In_channel.</span>stdin
  <span class="keyword2">|</span> filename -<span class="keyword2">&gt;</span> <span class="keyword5">In_channel.</span>create ~binary<span class="keyword2">:</span>true filename

<span class="keyword4">let</span> do_hash filename <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Cryptokit </span><span class="keyword4">in</span>
  get_inchan filename
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> hash_channel <span class="keyword2">(</span><span class="keyword5">Hash.</span>md5 <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> transform_string <span class="keyword2">(</span><span class="keyword5">Hexa.</span>encode <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline

<span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    ~readme<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;More detailed information&quot;</span><span class="keyword2">)</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span>maybe_with_default <span class="keyword7">&quot;-&quot;</span> <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> file<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
    do_hash

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>run ~version<span class="keyword2">:</span><span class="keyword7">&quot;1.0&quot;</span> ~build_info<span class="keyword2">:</span><span class="keyword7">&quot;RWO&quot;</span> command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5_with_default_file.ml">command-line-parsing/basic_md5_with_default_file.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9897520">
        Building and running both against a system file confirms that
        they have the same behavior.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> cat /etc/passwd | ./basic_md5_with_optional_file.native
</div><div class="rwocodeout">8cfb68a5622dd12932df658a54698aad</div><div class="highlight"><span class="gp">$</span> cat /etc/passwd | ./basic_md5_with_default_file.native
</div><div class="rwocodeout">8cfb68a5622dd12932df658a54698aad</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/run_basic_and_default_md5.out">command-line-parsing/run_basic_and_default_md5.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="sequences-of-arguments">Sequences of arguments</h1><p id="idp9900016">
        One last transformation that's useful is to obtain lists of
        anonymous arguments rather than a single one. As an example,
        let's modify our MD5 code to take a collection of files to
        process on the command line.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> do_hash filename ic <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Cryptokit </span><span class="keyword4">in</span>
  hash_channel <span class="keyword2">(</span><span class="keyword5">Hash.</span>md5 <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> ic
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> transform_string <span class="keyword2">(</span><span class="keyword5">Hexa.</span>encode <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword1">fun</span> md5 -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;MD5 (%s) = %s\n&quot;</span> filename md5

<span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    ~readme<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword7">&quot;More detailed information&quot;</span><span class="keyword2">)</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span>sequence <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> file<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> files <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword1">match</span> files <span class="keyword1">with</span>
       <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> do_hash <span class="keyword7">&quot;-&quot;</span> <span class="keyword5">In_channel.</span>stdin
       <span class="keyword2">|</span> <span class="keyword8">_</span>  -<span class="keyword2">&gt;</span>
         <span class="keyword5">List.</span>iter files ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> file -<span class="keyword2">&gt;</span>
           <span class="keyword5">In_channel.</span>with_file ~f<span class="keyword2">:</span><span class="keyword2">(</span>do_hash file<span class="keyword2">)</span> file
         <span class="keyword2">)</span>
    <span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>run ~version<span class="keyword2">:</span><span class="keyword7">&quot;1.0&quot;</span> ~build_info<span class="keyword2">:</span><span class="keyword7">&quot;RWO&quot;</span> command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5_sequence.ml">command-line-parsing/basic_md5_sequence.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9901408">
        The callback function is a little more complex now to handle the
        extra options. The <code>files</code> are now a
        <code>string list</code>, and an empty list reverts to
        using standard input just as our previous
        <code>maybe</code> and
        <code>maybe_with_default</code> examples did. If the list
        of files isn't empty, then it opens up each file and runs them
        through <code>do_hash</code> sequentially.
      </p></section></section><section><h1 id="adding-labeled-flags-to-the-command-line">Adding labeled flags to the command line</h1><p id="idp9907136">
      You aren't just limited to anonymous arguments on the
      command-line. A <span><em>flag</em></span> is a named field that
      can be followed by an optional argument. These flags can appear in
      any order on the command-line, or multiple times, depending on how
      they're declared in the specification.
    </p><p id="idp9908272">
      Let's add two arguments to our <code>md5</code> command that
      mimics the MacOS X version. A <code>-s</code> flag specifies
      the string to be hashed directly on the command-line and
      <code>-t</code> runs a self-test. The complete example is
      below.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword6">Cryptokit
</span>
<span class="keyword4">let</span> checksum_from_string buf <span class="keyword2">=</span>
  hash_string <span class="keyword2">(</span><span class="keyword5">Hash.</span>md5 <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> buf
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> transform_string <span class="keyword2">(</span><span class="keyword5">Hexa.</span>encode <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline

<span class="keyword4">let</span> checksum_from_file filename <span class="keyword2">=</span>
  <span class="keyword4">let</span> ic <span class="keyword2">=</span> <span class="keyword1">match</span> filename <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword7">&quot;-&quot;</span> -<span class="keyword2">&gt;</span> <span class="keyword5">In_channel.</span>stdin
    <span class="keyword2">|</span> <span class="keyword8">_</span>   -<span class="keyword2">&gt;</span> <span class="keyword5">In_channel.</span>create ~binary<span class="keyword2">:</span>true filename
  <span class="keyword4">in</span>
  hash_channel <span class="keyword2">(</span><span class="keyword5">Hash.</span>md5 <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> ic
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> transform_string <span class="keyword2">(</span><span class="keyword5">Hexa.</span>encode <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline

<span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Generate an MD5 hash of the input data&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> flag <span class="keyword7">&quot;-s&quot;</span> <span class="keyword2">(</span>optional <span class="keyword3">string</span><span class="keyword2">)</span> ~doc<span class="keyword2">:</span><span class="keyword7">&quot;string Checksum the given string&quot;</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> flag <span class="keyword7">&quot;-t&quot;</span> no_arg ~doc<span class="keyword2">:</span><span class="keyword7">&quot; run a built-in time trial&quot;</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span>maybe_with_default <span class="keyword7">&quot;-&quot;</span> <span class="keyword2">(</span><span class="keyword7">&quot;filename&quot;</span> %<span class="keyword2">:</span> file<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> use_string trial filename <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword1">match</span> trial <span class="keyword1">with</span>
       <span class="keyword2">|</span> true -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;Running time trial\n&quot;</span>
       <span class="keyword2">|</span> false -<span class="keyword2">&gt;</span> <span class="keyword4">begin</span>
           <span class="keyword1">match</span> use_string <span class="keyword1">with</span>
           <span class="keyword2">|</span> <span class="keyword6">Some </span>buf -<span class="keyword2">&gt;</span> checksum_from_string buf
           <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span> checksum_from_file filename
         <span class="keyword4">end</span>
    <span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">Command.</span>run command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic_md5_with_flags.ml">command-line-parsing/basic_md5_with_flags.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9911744">
      The specification now uses the <code>flag</code> function to
      define the two new labeled command-line arguments. The
      <code>doc</code> string is formatted so that the first word
      is the short name that appears in the usage text, with the
      remainder being the full help text. Notice that the
      <code>-t</code> flag has no argument, and so we prepend its
      <code>doc</code> text with a blank space. The help text for
      the above code looks like this.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./basic_md5_with_flags.native -help
</div><div class="rwocodeout">Generate an MD5 hash of the input data</div><div class="rwocodeout"> </div><div class="rwocodeout">  basic_md5_with_flags.native [FILENAME]</div><div class="rwocodeout"> </div><div class="rwocodeout">=== flags ===</div><div class="rwocodeout"> </div><div class="rwocodeout">  [-s string]    Checksum the given string</div><div class="rwocodeout">  [-t]           run a built-in time trial</div><div class="rwocodeout">  [-build-info]  print info about this build and exit</div><div class="rwocodeout">  [-version]     print the version of this build and exit</div><div class="rwocodeout">  [-help]        print this help text and exit</div><div class="rwocodeout">                 (alias: -?)</div><div class="rwocodeout"> </div><div class="highlight"><span class="gp">$</span> ./basic_md5_with_flags.native -s <span class="s2">&quot;ocaml rocks&quot;</span>
</div><div class="rwocodeout">5a118fe92ac3b6c7854c595ecf6419cb</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/run_basic_md5_flags_help.out">command-line-parsing/run_basic_md5_flags_help.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9916032">
      The <code>-s</code> flag in our specification requires a
      <code>string</code> argument and isn't optional. The Command
      parser outputs an error message if the flag isn't supplied, as
      with the anonymous arguments in earlier examples. Here's a list of
      some of the functions that you can wrap flags in to control how
      they are parsed.
    </p><table><thead><tr><th>
              Flag function
            </th><th>
              OCaml type
            </th></tr></thead><tbody><tr><td>
<code>required</code> <span><em>arg</em></span>
</td><td>
<span><em>arg</em></span> and error if not present
            </td></tr><tr><td>
<code>optional</code> <span><em>arg</em></span>
</td><td>
<span><em>arg</em></span> <code>option</code>
</td></tr><tr><td>
<code>optional_with_default</code>
<span><em>val</em></span> <span><em>arg</em></span>
</td><td>
<span><em>arg</em></span> with default
              <span><em>val</em></span> if not present
            </td></tr><tr><td>
<code>listed</code> <span><em>arg</em></span>
</td><td>
<span><em>arg</em></span> <code>list</code>, flag may
              appear multiple times
            </td></tr><tr><td>
<code>no_arg</code>
</td><td>
<code>bool</code> that is true if flag is present.
            </td></tr></tbody></table><p id="idp9937648">
      The flags affect the type of the callback function in exactly the
      same way as anonymous arguments do. This lets you change the
      specification and ensure that all the callback functions are
      updated appropriately, without runtime errors.
    </p></section><section><h1 id="grouping-sub-commands-together">Grouping sub-commands together</h1><p id="idp9939648">
      You can get pretty far by using flags and anonymous arguments to
      assemble complex command-line interfaces. After a while though,
      too many options can make the program very confusing for newcomers
      to your application. One way to solve this is by grouping common
      operations together and adding some hierarchy to the command-line
      interface.
    </p><p id="idp9940432">
      You'll have run across this style already when using the OPAM
      package manager (or, in the non-OCaml world, the Git or Mercurial
      commands). OPAM exposes commands in this form.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> opam config env
</div><div class="highlight"><span class="gp">$</span> opam remote list -k git
</div><div class="highlight"><span class="gp">$</span> opam install --help
</div><div class="highlight"><span class="gp">$</span> opam install cryptokit --verbose
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/opam.out">command-line-parsing/opam.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9941744">
      The <code>config</code>, <code>remote</code> and
      <code>install</code> keywords form a logical grouping of
      commands that factor out a set of flags and arguments. This lets
      you prevent flags that are specific to a particular sub-command
      from leaking into the general configuration space.
    </p><p id="idp9944512">
      This usually only becomes a concern when your application
      organically grows features. Luckily, it's simple to extend your
      application to do this in Command: just swap the
      <code>Command.basic</code> for
      <code>Command.group</code>, which takes an association list
      of specifications and handles the sub-command parsing and help
      output for you.
    </p><div class="rwocode"><pre><code># <span class="keyword5">Command.</span>basic <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t
= &lt;fun&gt;
</div># <span class="keyword5">Command.</span>group <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt; (string * Command.t) list -&gt; Command.t
= &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/group.topscript">command-line-parsing/group.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9947392">
      The <code>group</code> signature accepts a list of basic
      <code>Command.t</code> values and their corresponding names.
      When executed, it looks for the appropriate sub-command from the
      name list, and dispatches it to the right command handler.
    </p><p id="idp9949440">
      Let's build the outline of a calendar tool that does a few
      operations over dates from the command-line. We first need to
      define a command that adds days to an input date and prints the
      resulting date.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> add <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Add [days] to the [base] date and print day&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;base&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;days&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> base span <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword5">Date.</span>add_days base span
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Date.</span>to_string
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline
    <span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">Command.</span>run add</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/cal_add_days.ml">command-line-parsing/cal_add_days.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9950800">
      Everything in this command should be familiar to you by now. Once
      you've tested it and made sure it works, we can define another new
      command that takes the difference of two dates. However, instead
      of creating a new binary, we group both operations as sub-commands
      using <code>Command.group</code>.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> add <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Add [days] to the [base] date&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;base&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;days&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> base span <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword5">Date.</span>add_days base span
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Date.</span>to_string
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline
    <span class="keyword2">)</span>

<span class="keyword4">let</span> diff <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Show days between [date1] and [date2]&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;date1&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;date2&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> date1 date2 <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword5">Date.</span>diff date1 date2
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;%d days\n&quot;</span>
    <span class="keyword2">)</span>

<span class="keyword4">let</span> command <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>group ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Manipulate dates&quot;</span>
    <span class="keyword2">[</span> <span class="keyword7">&quot;add&quot;</span>, add<span class="keyword2">;</span> <span class="keyword7">&quot;diff&quot;</span>, diff <span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">Command.</span>run command</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/cal_add_sub_days.ml">command-line-parsing/cal_add_sub_days.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9952960">
      And that's all you really need to add sub-command support! Let's
      build the example first in the usual way and inspect the help
      output, which now reflects the sub-commands we just added.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild cal_add_sub_days.native
</div><div class="highlight"><span class="gp">$</span> ./cal_add_sub_days.native -help
</div><div class="rwocodeout">Manipulate dates</div><div class="rwocodeout"> </div><div class="rwocodeout">  cal_add_sub_days.native SUBCOMMAND</div><div class="rwocodeout"> </div><div class="rwocodeout">=== subcommands ===</div><div class="rwocodeout"> </div><div class="rwocodeout">  add      Add [days] to the [base] date</div><div class="rwocodeout">  diff     Show days between [date1] and [date2]</div><div class="rwocodeout">  version  print version information</div><div class="rwocodeout">  help     explain a given subcommand (perhaps recursively)</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/build_cal_add_sub_days.out">command-line-parsing/build_cal_add_sub_days.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9954304">
      We can invoke the two commands we just defined to verify that they
      work and see the date parsing in action.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ./cal_add_sub_days.native add 2012-12-25 40
</div><div class="rwocodeout">2013-02-03</div><div class="highlight"><span class="gp">$</span> ./cal_add_sub_days.native diff 2012-12-25 2012-11-01
</div><div class="rwocodeout">54 days</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/run_cal_add_sub_days.out">command-line-parsing/run_cal_add_sub_days.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="advanced-control-over-parsing">Advanced control over parsing</h1><p id="idp9956896">
      The functions for generating a specification may seem like magic.
      In particular, even if you know how to use them, it's not entirely
      clear how they work, and in particular, why the types work out the
      way they do.
    </p><p id="idp9957536">
      Understanding the details of how these specifications fit together
      becomes more useful as your command line interfaces get more
      complex. In particular, you may want to factor out common
      functionality between specifications, or interrupt the parsing to
      perform special processing, such as requesting an interactive
      passphrase from the user before proceeding. All of this is helped
      by a deeper understanding of the Command library.
    </p><p id="idp9958416">
      In the following, we'll explain the logic behind the combinators
      we've already described and show you some new combinators that let
      you use Command even more effectively.
    </p><section><h1 id="the-types-behind-command.spec">The types behind <code>Command.Spec</code></h1><p id="idp9960800">
        The Command module's safety relies on the specification's output
        values precisely matching the callback function which invokes
        the main program. In order to prevent any such mismatches,
        Command uses some interesting type machinery to guarantee they
        remain in sync. You don't have to understand this section to use
        the more advanced combinators, but it'll help you debug type
        errors as you use Command more.
      </p><p id="idp9962144">
        The <code>Command.Spec.t</code> type looks deceptively
        simple: <code>('a, 'b) t</code>. You can think of
        <code>('a, 'b) t</code> here as a function of type
        <code>'a -&gt; 'b</code>, but embellished with information
        about:
      </p><ul><li><p id="idp9966016">
            how to parse the command line
          </p></li><li><p id="idp9966848">
            what the command does and how to call it
          </p></li><li><p id="idp9967696">
            how to auto-complete a partial command line
          </p></li></ul><p id="idp9968416">
        The type of a specification transforms a <code>'a</code>
        to a <code>'b</code> value. For instance, a value of
        <code>Spec.t</code> might have type
        <code>(arg1 -&gt; ... -&gt; argN -&gt; 'r, 'r) Spec.t</code>.
      </p><p id="idp9971760">
        Such a value transforms a main function of type
        <code>arg1 -&gt; ... -&gt; argN -&gt; 'r</code> by
        supplying all the argument values, leaving a main function that
        returns a value of type <code>'r</code>. Let's look at
        some examples of specs, and their types:
      </p><div class="rwocode"><pre><code># <span class="keyword5">Command.</span><span class="keyword5">Spec.</span>empty <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : ('m, 'm) Command.Spec.t = &lt;abstr&gt;
</div># <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;foo&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (int -&gt; '_a, '_a) Command.Spec.t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/command_types.topscript">command-line-parsing/command_types.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9974592">
        The empty specification is simple as it doesn't add any
        parameters to the callback type. The second example adds an
        <code>int</code> anonymous parameter that is reflected in
        the inferred type. One forms a command by combining a spec of
        type <code>('main, unit) Spec.t</code> with a function of
        type <code>'main</code>. The combinators we've shown so
        far incrementally build the type of <code>'main</code>
        according to the command-line parameters it expects, so the
        resulting type of <code>'main</code> is something like
        <code>arg1 -&gt; ... -&gt; argN -&gt; unit</code>.
      </p><p id="idp9979744">
        The type of <code>Command.basic</code> should make more
        sense now:
      </p><div class="rwocode"><pre><code># <span class="keyword5">Command.</span>basic <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t
= &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/basic.topscript">command-line-parsing/basic.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9981648">
        The parameters to <code>Spec.t</code> are important here.
        They show that the callback function for a spec should consume
        identical arguments to the supplied <code>main</code>
        function, except for an additional <code>unit</code>
        argument. This final <code>unit</code> is there to make
        sure the callback is evaluated as a function, since if zero
        command-line arguments are specified (<span><em>i.e.</em></span>
<code>Spec.empty</code>), the callback would otherwise
        have no arguments and be evaluated immediately. That's why you
        have to supply an additional <code>()</code> to the
        callback function in all the previous examples.
      </p></section><section><h1 id="composing-specification-fragments-together">Composing specification fragments together</h1><p id="idp9988560">
        If you want to factor out common command-line operations, the
        <code>++</code> operator will append two specifications
        together. Let's add some dummy verbosity and debug flags to our
        calendar application to illustrate this.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> add ~common <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Add [days] to the [base] date&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;base&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;days&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">+</span> common
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> base span debug verbose <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword5">Date.</span>add_days base span
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Date.</span>to_string
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline
    <span class="keyword2">)</span>

<span class="keyword4">let</span> diff ~common <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Show days between [date2] and [date1]&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;date1&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;date2&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">+</span> common
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> date1 date2 debug verbose <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword5">Date.</span>diff date1 date2
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;%d days\n&quot;</span>
    <span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/cal_append.ml">command-line-parsing/cal_append.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9990624">
        The definitions of the specifications are very similar to the
        earlier example, except that they append a
        <code>common</code> parameter after each specification. We
        can supply these flags when defining the groups.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> common <span class="keyword2">=</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> flag <span class="keyword7">&quot;-d&quot;</span> <span class="keyword2">(</span>optional_with_default false bool<span class="keyword2">)</span> ~doc<span class="keyword2">:</span><span class="keyword7">&quot; Debug mode&quot;</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> flag <span class="keyword7">&quot;-v&quot;</span> <span class="keyword2">(</span>optional_with_default false bool<span class="keyword2">)</span> ~doc<span class="keyword2">:</span><span class="keyword7">&quot; Verbose output&quot;</span>
    <span class="keyword2">)</span>
  <span class="keyword4">in</span>
  <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span>name, cmd<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>name, cmd ~common<span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">[</span> <span class="keyword7">&quot;add&quot;</span>, add<span class="keyword2">;</span> <span class="keyword7">&quot;diff&quot;</span>, diff <span class="keyword2">]</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>group ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Manipulate dates&quot;</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/cal_append.ml">command-line-parsing/cal_append.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9992688">
        Both of these flags will now be applied and passed to all the
        callback functions. This makes code refactoring a breeze by
        using the compiler to spot places where you use commands. Just
        add a parameter to the common definition, run the compiler, and
        fix type errors until everything works again.
      </p><p id="idp9993424">
        For example, if we remove the <code>verbose</code> flag
        and recompile, we'll get this impressively long type error:
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlbuild -use-ocamlfind -tag thread -pkg core cal_append_broken.native
</div><div class="rwocodeout">File &quot;cal_append_broken.ml&quot;, line 38, characters 46-52:</div><div class="rwocodeout">Error: This expression has type</div><div class="rwocodeout">         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit -&gt; unit) Command.Spec.t</div><div class="rwocodeout">       but an expression was expected of type</div><div class="rwocodeout">         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit) Command.Spec.t</div><div class="rwocodeout">       Type unit -&gt; unit is not compatible with type unit </div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/build_cal_append_broken.out">command-line-parsing/build_cal_append_broken.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp9995392">
        While this does look scary, the key line to scan is the last
        one, where it's telling you that you have supplied too many
        arguments in the callback function
        (<code>unit -&gt; unit</code> vs <code>unit</code>).
        If you started with a working program and made this single
        change, you typically don't even need to read the type error, as
        the filename and location information is sufficient to make the
        obvious fix.
      </p></section><section><h1 id="prompting-for-interactive-input">Prompting for interactive input</h1><p id="idp9998864">
        The <code>step</code> combinator lets you control the
        normal course of parsing by supplying a function that maps
        callback arguments to a new set of values. For instance, let's
        revisit our first calendar application that added a number of
        days onto a supplied base date.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> add <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Add [days] to the [base] date and print day&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span>
      empty
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;base&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;days&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> base span <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
       <span class="keyword5">Date.</span>add_days base span
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Date.</span>to_string
       <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline
    <span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">Command.</span>run add</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/cal_add_days.ml">command-line-parsing/cal_add_days.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10001008">
        This program requires you to specify both the
        <code>base</code> date and the number of
        <code>days</code> to add onto it. If
        <code>days</code> isn't supplied on the command-line, an
        error is output. Now let's modify it to interactively prompt for
        a number of days if only the <code>base</code> date is
        supplied.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> add_days base span <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Date.</span>add_days base span
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Date.</span>to_string
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline

<span class="keyword4">let</span> add <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Add [days] to the [base] date and print day&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span> 
      step 
        <span class="keyword2">(</span><span class="keyword1">fun</span> m base days -<span class="keyword2">&gt;</span>
           <span class="keyword1">match</span> days <span class="keyword1">with</span>
           <span class="keyword2">|</span> <span class="keyword6">Some </span>days -<span class="keyword2">&gt;</span>
             m base days
           <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span>
             print_endline <span class="keyword7">&quot;enter days: &quot;</span><span class="keyword2">;</span>
             read_int <span class="keyword2">(</span><span class="keyword2">)</span>
             <span class="keyword2">|</span><span class="keyword2">&gt;</span> m base
        <span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;base&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span>maybe <span class="keyword2">(</span><span class="keyword7">&quot;days&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
    add_days

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">Command.</span>run add</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/cal_add_interactive.ml">command-line-parsing/cal_add_interactive.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10005264">
        The <code>days</code> anonymous argument is now an
        optional integer in the spec, and we want to transform it into a
        non-optional value before calling our
        <code>add_days</code> callback. The
        <code>step</code> combinator lets us perform this
        transformation by applying its supplied callback function first.
        In the example, the callback first checks if
        <code>day</code> is defined. If it's undefined, then it
        interactively reads an integer from the standard input.
      </p><p id="idp10008960">
        The first <code>m</code> argument to the
        <code>step</code> callback is the next callback function
        in the chain. The transformation is completed by calling
        <code>m base days</code> to continue processing with the
        new values we've just calculated. The <code>days</code>
        value that is passed onto the next callback now has a
        non-optional <code>int</code> type.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlbuild -use-ocamlfind -tag thread -pkg core cal_add_interactive.native
</div><div class="highlight"><span class="gp">$</span> ./cal_add_interactive.native 2013-12-01
</div><div class="rwocodeout">enter days:</div><div class="rwocodeout">35</div><div class="rwocodeout">2014-01-05</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/build_and_run_cal_add_interactive.out">command-line-parsing/build_and_run_cal_add_interactive.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10013904">
        The transformation means that the <code>add_days</code>
        callback can just keep its original definition of
        <code>Date.t -&gt; int -&gt; unit</code>. The
        <code>step</code> function transformed the
        <code>int option</code> argument from the parsing into an
        <code>int</code> suitable for <code>add_days</code>.
        This transformation is explicitly represented in the type of the
        <code>step</code> return value:
      </p><div class="rwocode"><pre><code># <span class="keyword1">open</span> <span class="keyword5">Command.Spec </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># step <span class="keyword2">(</span><span class="keyword1">fun</span> m <span class="keyword2">(</span>base<span class="keyword2">:</span><span class="keyword5">Date.</span>t<span class="keyword2">)</span> days -<span class="keyword2">&gt;</span>
  <span class="keyword1">match</span> days <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Some </span>days -<span class="keyword2">&gt;</span> m base days
  <span class="keyword2">|</span> <span class="keyword6">None </span>-<span class="keyword2">&gt;</span>
     print_endline <span class="keyword7">&quot;enter days: &quot;</span><span class="keyword2">;</span>
     m base <span class="keyword2">(</span>read_int <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : (Date.t -&gt; int -&gt; '_a, Date.t -&gt; int option -&gt; '_a) t = &lt;abstr&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/step.topscript">command-line-parsing/step.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10020288">
        The first half of the <code>Spec.t</code> shows that the
        callback type is <code>Date.t -&gt; int</code>, whereas
        the resulting value expected from the next specification in the
        chain is a <code>Date.t -&gt; int option</code>.
      </p></section><section><h1 id="adding-labeled-arguments-to-callbacks">Adding labeled arguments to callbacks</h1><p id="idp10024256">
        The <code>step</code> chaining lets you control the types
        of your callbacks very easily. This can help you match existing
        interfaces or make things more explicit by adding labeled
        arguments.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> add_days ~base_date ~num_days <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Date.</span>add_days base_date num_days
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Date.</span>to_string
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline

<span class="keyword4">let</span> add <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic
    ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Add [days] to the [base] date and print day&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span><span class="keyword2">(</span> 
      step <span class="keyword2">(</span><span class="keyword1">fun</span> m base days -<span class="keyword2">&gt;</span> m ~base_date<span class="keyword2">:</span>base ~num_days<span class="keyword2">:</span>days<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;base&quot;</span> %<span class="keyword2">:</span> date<span class="keyword2">)</span>
      <span class="keyword2">+</span><span class="keyword2">&gt;</span> anon <span class="keyword2">(</span><span class="keyword7">&quot;days&quot;</span> %<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">)</span>
    <span class="keyword2">)</span>
    add_days

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword5">Command.</span>run add</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/cal_add_labels.ml">command-line-parsing/cal_add_labels.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10026320">
        This <code>cal_add_labels</code> example goes back to our
        non-interactive calendar addition program, but the
        <code>add_days</code> main function now expects labeled
        arguments. The <code>step</code> function in the
        specification simply converts the default
        <code>base</code> and <code>days</code> arguments
        into a labeled function.
      </p><p id="idp10030560">
        Labelled arguments are more verbose but can also help prevent
        errors with command-line arguments with similar types but
        different names and purposes. It's good form to use labels when
        you have a lot of otherwise anonymous <code>int</code> and
        <code>string</code> arguments.
      </p></section></section><section><h1 id="command-line-auto-completion-with-bash">Command-line auto-completion with
    <code>bash</code></h1><p id="idp10034640">
      Modern UNIX shells usually have a tab-completion feature to
      interactively help you figure out how to build a command-line.
      These work by pressing the <code>&lt;tab&gt;</code> key in
      the middle of typing a command, and seeing the options that pop
      up. You've probably used this most often to find the files in the
      current directory, but it can actually be extended for other parts
      of the command too.
    </p><p id="idp10036176">
      The precise mechanism for autocompletion varies depending on what
      shell you are using, but we'll assume you are using the most
      common one: <code>bash</code>. This is the default
      interactive shell on most Linux distributions and Mac OS X, but
      you may need to switch to it on *BSD or Windows (when using
      Cygwin). The rest of this section assumes that you're using
      <code>bash</code>.
    </p><p id="idp10038384">
      Bash autocompletion isn't always installed by default, so check
      your OS package manager to see if you have it available.
    </p><table><thead><tr><th>
              Operating System
            </th><th>
              Package Manager
            </th><th>
              Package
            </th></tr></thead><tbody><tr><td>
              Debian Linux
            </td><td>
<code>apt</code>
</td><td>
<code>bash-completion</code>
</td></tr><tr><td>
              Mac OS X
            </td><td>
              Homebrew
            </td><td>
<code>bash-completion</code>
</td></tr><tr><td>
              FreeBSD
            </td><td>
              Ports System
            </td><td>
<code>/usr/ports/shells/bash-completion</code>
</td></tr></tbody></table><p id="idp10051616">
      Once bash completion is installed and configured, check that it
      works by typing the <code>ssh</code> command, and pressing
      <code>&lt;tab&gt;</code>. This should show you the list of
      known hosts from your <code>~/.ssh/known_hosts</code> file.
      If it lists some hosts that you've recently connected to, you can
      continue on. If it lists the files in your current directory
      instead, then check your OS documentation to configure completion
      correctly.
    </p><p id="idp10054576">
      One last bit of information you'll need to find is the location of
      the <code>bash_completion.d</code> directory. This is where
      all the shell fragments that contain the completion logic are
      held. On Linux, this is often in
      <code>/etc/bash_completion.d</code>, and in Homebrew on Mac
      OS X it would be
      <code>/usr/local/etc/bash_completion.d</code> by default.
    </p><section><h1 id="generating-completion-fragments-from-command">Generating completion fragments from Command</h1><p id="idp10058528">
        The Command library has a declarative description of all the
        possible valid options, and it can use this information to
        generate a shell script which provides completion support for
        that command. To generate the fragment, just run the command
        with the <code>COMMAND_OUTPUT_INSTALLATION_BASH</code>
        environment variable set to any value.
      </p><p id="idp10059984">
        For example, let's try it on our MD5 example from earlier,
        assuming that the binary is called
        <code>basic_md5_with_flags</code> in the current
        directory.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> env <span class="nv">COMMAND_OUTPUT_INSTALLATION_BASH</span><span class="o">=</span>1 ./basic_md5_with_flags.native
</div><div class="rwocodeout">function _jsautocom_13612 {</div><div class="rwocodeout">  export COMP_CWORD</div><div class="rwocodeout">  COMP_WORDS[0]=./basic_md5_with_flags.native</div><div class="rwocodeout">  COMPREPLY=($(&quot;${COMP_WORDS[@]}&quot;))</div><div class="rwocodeout">}</div><div class="rwocodeout">complete -F _jsautocom_13612 ./basic_md5_with_flags.native</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/md5_completion.out">command-line-parsing/md5_completion.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10061984">
        Recall that we used the <code>Arg_type.file</code> to
        specify the argument type. This also supplies the completion
        logic so that you can just press <code>&lt;tab&gt;</code>
        to complete files in your current directory.
      </p></section><section><h1 id="installing-the-completion-fragment">Installing the completion fragment</h1><p id="idp10065328">
        You don't need to worry about what the output script above
        actually does (unless you have an unhealthy fascination with
        shell scripting internals, that is). Instead, redirect the
        output to a file in your current directory and source it into
        your current shell.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> env <span class="nv">COMMAND_OUTPUT_INSTALLATION_BASH</span><span class="o">=</span>1 ./cal_add_sub_days.native &gt; cal.cmd
</div><div class="highlight"><span class="gp">$</span> . cal.cmd
</div><div class="highlight"><span class="gp">$</span> ./cal_add_sub_days.native &lt;tab&gt;
</div><div class="rwocodeout">add      diff     help     version</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/command-line-parsing/cal_completion.out">command-line-parsing/cal_completion.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10066768">
        Command completion support works for flags and grouped commands,
        and is very useful when building larger command-line interfaces.
        Don't forget to install the shell fragment into your global
        <code>bash_completion.d</code> directory if you want it to
        be loaded in all of your login shells.
      </p><aside class="note"><h1>
      Installing a generic completion handler
      </h1><p id="idp10068880">
        Sadly, <code>bash</code> doesn't support installing a
        generic handler for all Command-based applications. This means
        that you have to install the completion script for every
        application, but you should be able to automate this in the
        build and packaging system for your application.
      </p><p id="idp10070304">
        It will help to check out how other applications that install
        tab-completion scripts and following their lead, as the details
        are very OS-specific.
      </p></aside></section></section><section><h1 id="alternative-command-line-parsers">Alternative command-line parsers</h1><p id="idp10072400">
      This rounds up our tour of the Command library. This isn't the
      only way to parse command-line arguments of course; there are
      several alternatives available on OPAM. Three of the most
      prominent ones are introduced below.
    </p><ul><li><p id="idp10073568">
          The <code>Arg</code> module from the OCaml standard
          library, which is used by the compiler itself to handle its
          command-line interface. Command is generally more featureful
          than Arg (mainly via support for sub-commands, the
          <code>step</code> combinator to transform inputs, and
          help generation), but there's absolutely nothing wrong with
          using Arg either.
        </p><p id="idp10075792">
          You can use the
          <code>Command.Spec.flags_of_args_exn</code> function to
          convert Arg specifications into ones compatible with Command.
          This is quite often used to help port older non-Core code into
          the Core standard library world.
        </p></li><li><p id="idp10077536">
<a href="https://forge.ocamlcore.org/projects/ocaml-getopt/" target="_top">ocaml-getopt</a>
          provides the general command-line syntax of GNU
          <code>getopt</code> and <code>getopt_long</code>.
          The GNU conventions are widely used in the open-source world,
          and this library lets your OCaml programs obey the same rules.
        </p></li><li><p id="idp10080688">
<a href="http://erratique.ch/software/cmdliner" target="_top">Cmdliner</a>
          is a mix between the Command and Getopt libraries. It allows
          for the declarative definition of command-line interfaces, but
          exposes a more <code>getopt</code>-like interface. It
          also automates the generation of UNIX <code>man</code>
          pages as part of the specification. Cmdliner is the parser
          used by OPAM to manage its command-line.
        </p></li></ul></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="maps-and-hash-tables.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="handling-json-data.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>