<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Prologue / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta2',
                        page: 'prologue.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html" class="here">Prologue</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="prologue.html#why-ocaml">Why OCaml?</a>
                                            </li>
                                        
                                            <li>
                                                <a href="prologue.html#about-this-book">About this book</a>
                                            </li>
                                        
                                            <li>
                                                <a href="prologue.html#about-the-authors">About the Authors</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Prologue</h1>
                
                

    <section><h1 id="why-ocaml">Why OCaml?</h1><p id="idp4093520">
      The programming languages that you use affect the software you
      create. They influence your software's reliability, security and
      efficiency, and how easy it is to read, refactor, and extend. The
      languages you know can also deeply affect how you think about
      programming and software design.
    </p><p id="idp2080240">
      But not all ideas about how to design a programming language are
      created equal. Over the last 40 years, a few key language features
      have emerged that together form a kind of sweet-spot in language
      design. These features include:
    </p><ul><li><p id="idp4672000">
<span><em>Garbage collection</em></span> for automatic memory
          management, now a feature of almost every modern high-level
          language.
        </p></li><li><p id="idp5018592">
<span><em>First-class functions</em></span> that can be passed
          around like ordinary values, as seen in JavaScript and C#.
        </p></li><li><p id="idp4338992">
<span><em>Static type-checking</em></span> to increase
          performance and reduce the number of runtime errors, as found
          in Java and C#.
        </p></li><li><p id="idp5441408">
<span><em>Parametric polymorphism</em></span>, which enables
          the construction of abstractions that work across different
          datatypes, similar to generics in Java and C# and templates in
          C++.
        </p></li><li><p id="idp5070928">
          Good support for <span><em>immutable programming</em></span>,
          <span><em>i.e.</em></span>, programming without making
          destructive updates to data-structures. This is present in
          traditional functional languages like Scheme, and is also
          found in distributed big data frameworks like Hadoop.
        </p></li><li><p id="idp4078976">
<span><em>Automatic type inference</em></span> to avoid having
          to laboriously define the type of every single variable in a
          program and instead have them inferred based on how a value is
          used. Available in C# with implicitly typed local variables
          and in a limited form in C++11 with its
          <code>auto</code> keyword.
        </p></li><li><p id="idp4135568">
<span><em>Algebraic datatypes</em></span> and <span><em>pattern
          matching</em></span> to define and manipulate complex data
          structures. Available in Scala and F#.
        </p></li></ul><p id="idp4117264">
      Some of you will know and love these features, and others will be
      completely new to them. Most of you will have seen
      <span><em>some</em></span> of them in other languages that you've
      used. As we'll demonstrate over the course of this book, there is
      something transformative about having them all together and able
      to interact in a single language. Despite their importance, these
      ideas have made only limited inroads into mainstream languages and
      when they do arrive there, like higher-order functions in C# or
      parametric polymorphism in Java, it's typically in a limited and
      awkward form. The only languages that completely embody these
      ideas are <span><em>statically-typed functional programming
      languages</em></span> like OCaml, F#, Haskell, Scala and Standard
      ML.
    </p><p id="idp4651648">
      Among this worthy set of languages, OCaml stands apart because it
      manages to provide a great deal of power while remaining highly
      pragmatic. The compiler has a straightforward compilation strategy
      that produces performant code without requiring heavy optimization
      and without the complexities of dynamic JIT compilation. This,
      along with OCaml's strict evaluation model, makes runtime behavior
      easy to predict. The garbage collector is
      <span><em>incremental</em></span>, letting you avoid large
      GC-related pauses, and <span><em>precise</em></span>, meaning it
      will collect all unreferenced data (unlike many reference-counting
      collectors), and the runtime is simple and highly portable.
    </p><p id="idp5012240">
      All of this makes OCaml a great choice for programmers who want to
      step up to a better programming language, and at the same time get
      practical work done.
    </p><section><h1 id="a-brief-history-from-the-1960s">A brief history from the 1960s</h1><p id="idp228432">
        OCaml was written in 1996 by Xavier Leroy, Jérôme Vouillon,
        Damien Doligez and Didier Rémy at INRIA in France. It was
        inspired by a long line of research into ML starting in the
        1960s, and continues to have deep links to the academic
        community.
      </p><p id="idp229424">
        ML was originally the <span><em>meta language</em></span> of the
        LCF proof assistant released by Robin Milner in 1972 (at
        Stanford, and later at Cambridge). ML was turned into a compiler
        in order to make it easier to use LCF on different machines, and
        gradually turned into a fully fledged system of its own by the
        1980s.
      </p><p id="idp230592">
        The first implementation of Caml appeared in 1987, initially
        created by Ascander Saurez and later continued by Pierre Weis
        and Michel Mauny. In 1990, Xavier Leroy and Damien Doligez built
        a new implementation called Caml Light that was based on a
        bytecode interpreter with a fast sequential garbage collector.
        Over the next few years useful libraries appeared, such as
        Michel Mauny's syntax manipulation tools, and this helped
        promote the use of Caml in education and research teams.
      </p><p id="idp231552">
        Xavier Leroy continued extending Caml Light with new features,
        which resulted in the 1995 release of Caml Special Light. This
        improved the executable efficiency significantly by adding a
        fast native code compiler that made Caml's performance
        competitive with mainstream languages such as C++. A module
        system inspired by Standard ML also provided powerful facilities
        for abstraction and made larger-scale programs easier to
        construct.
      </p><p id="idp232464">
        The modern OCaml emerged in 1996, when a powerful and elegant
        object system was implemented by Didier Rémy and Jérôme
        Vouillon. This object system was notable for supporting many
        common OO idioms in a statically type-safe way, whereas the same
        idioms required runtime checks in languages such as C++ or Java.
        In 2000, Jacques Garrigue extended OCaml with several new
        features such as polymorphic methods and variants and labeled
        and optional arguments.
      </p><p id="idp370160">
        The last decade has seen OCaml attract a significant user base.
        Language improvements have been steadily added to support the
        growing commercial and academic codebases written in OCaml.
        First-class modules, Generalized Algebraic Data Types (GADTs)
        and dynamic linking have improved the flexibility of the
        language and there is fast native code support for x86_64, ARM,
        PowerPC, and Sparc, making OCaml a good choice for systems where
        resource usage, predictability, and performance all matter.
      </p></section><section><h1 id="the-core-standard-library">The Core Standard Library</h1><p id="idp300704">
        A language on its own isn't enough. You also need a rich set of
        libraries to base your applications on. A common source of
        frustration for those learning OCaml is that the standard
        library that ships with the compiler is limited, covering only a
        small subset of the functionality you would expect from a
        general-purpose standard library. That's because the standard
        library isn't a general-purpose tool; it was developed for use
        in bootstrapping the compiler, and is purposefully kept small
        and simple.
      </p><p id="idp301680">
        Happily, in the world of open-source software nothing stops
        alternative libraries from being written to supplement the
        compiler-supplied standard library, and this is exactly what the
        Core distribution is.
      </p><p id="idp302320">
        Jane Street, a company that has been using OCaml for more than a
        decade, developed Core for its own internal use, but designed it
        from the start with an eye towards being a general-purpose
        standard library. Like the OCaml language itself, Core is
        engineered with correctness, reliability and performance in
        mind.
      </p><p id="idp303088">
        Core is distributed with syntax extensions which provide useful
        new functionality to OCaml, and there are additional libraries
        such as the Async network communications library that extend the
        reach of Core into building complex distributed systems. All of
        these libraries are distributed under a liberal Apache 2 license
        to permit free use in hobby, academic and commercial settings.
      </p></section><section><h1 id="the-ocaml-platform">The OCaml Platform</h1><p id="idp305072">
        Core is a comprehensive and effective standard library, but
        there's much more OCaml software out there. A large community of
        programmers have been using OCaml since its first release in
        1996 and have generated many useful libraries and tools. We'll
        introduce some of these libraries in the course of the examples
        presented in the book.
      </p><p id="idp305856">
        The installation and management of these third-party libraries
        is made much easier via a package management tool known as OPAM.
        We'll explain more about OPAM as the book unfolds, but it forms
        the basis of the Platform, which is a set of tools and libraries
        that, along with the OCaml compiler, let you build real-world
        applications quickly and effectively.
      </p><p id="idp207888">
        We'll also use OPAM for installing the <code>utop</code>
        command-line interface. This is a modern interactive tool that
        supports command history, macro expansion, module completion,
        and other niceties that make it much more pleasant to work with
        the language. We'll be using <code>utop</code> throughout
        the book instead of the normal OCaml toplevel.
      </p></section></section><section><h1 id="about-this-book">About this book</h1><p id="idp211200">
      Real World OCaml is aimed at programmers who have some experience
      with conventional programming languages, but not specifically with
      statically-typed functional programming. Depending on your
      background, many of the concepts we cover will be new, including
      traditional functional-programming techniques like higher-order
      functions and immutable data types, as well as aspects of OCaml's
      powerful type and module systems.
    </p><p id="idp212544">
      If you've learned some OCaml before, this book may surprise you
      with some differences from your experience. Core redefines most of
      the standard modules to be much more consistent, so you'll need to
      adapt older code to work with Core. We believe the Core model is
      worth learning; it's been successfully used on large,
      multi-million-line codebases and removes a big barrier to building
      sophisticated applications in OCaml. Code that uses only the
      traditional compiler standard library will always exist, but there
      are other online resources to learn how that works. Real World
      OCaml focuses on the techniques the authors have used in their
      personal experience to construct scalable, robust software
      systems.
    </p><section><h1 id="what-to-expect">What to expect</h1><p id="idp214704">
        Real World OCaml is split into three parts:
      </p><ul><li><p id="idp259248">
            Part I covers the language itself, opening with a guided
            tour designed to provide a quick sketch of the language.
            Don't expect to understand everything in the tour; it's
            meant to give you a taste of many different aspects of the
            language, but the ideas covered there will be explained in
            more depth in the chapters that follow.
          </p><p id="idp260064">
            After covering the core language, Part I then moves onto
            more advanced features like modules, functors and objects,
            which may take some time to digest. Understanding these
            concepts is important, though. These ideas will put you in
            good stead even beyond OCaml when switching to other modern
            languages, many of which have drawn inspiration from ML.
          </p></li><li><p id="idp261280">
            Part II builds on the basics by working through useful tools
            and techniques for addressing common practical applications,
            from command-line parsing to asynchronous network
            programming. Along the way, you'll see how some of the
            concepts from Part I are glued together into real libraries
            and tools that combine different features of the language to
            good effect.
          </p></li><li><p id="idp262528">
            Part III discusses OCaml's runtime system and compiler
            toolchain. It is remarkably simple when compared to some
            other language implementations (such as Java's or .NET's
            CLR). Reading this part will enable you to build very high
            performance systems, or to interface with C libraries. This
            is also where we talk about profiling and debugging
            techniques using tools such as GNU <code>gdb</code>.
          </p></li></ul><aside class="note"><h1>
      Note to reviewers
      </h1><p id="idp265072">
        Real World OCaml uses some tools that we've developed while
        writing this book. Some of these resulted in improvements to the
        OCaml compiler, which means that you will need to ensure that
        you have an up-to-date development environment (using the 4.01.0
        compiler). We've automated everything you need to do via the
        OPAM package manager, so please do follow the installation
        instructions in <a href="installation.html">Appendix A, <i>Installation</i></a>
        carefully.
      </p><p id="idp266576">
        At this stage, the Windows operating system is unsupported, and
        only Mac OS X, Linux, FreeBSD and OpenBSD can be expected to
        work reliably. We realize this is a concern; there are no
        fundamental barriers to Windows support, but we're focused on
        getting the main content finished before getting stuck into the
        porting effort.
      </p></aside></section></section><section><h1 id="about-the-authors">About the Authors</h1><section><h1 id="yaron-minsky">Yaron Minsky</h1><p id="idp186592">
        Yaron Minsky heads the Technology group at Jane Street, a
        proprietary trading firm that is the largest industrial user of
        OCaml. He was responsible for introducing OCaml to the company
        and for managing the company's transition to using OCaml for all
        of its core infrastructure. Today, billions of dollars worth of
        securities transactions flow each day through those systems.
      </p><p id="idp187424">
        Yaron obtained his PhD in Computer Science from Cornell
        University, where he studied distributed systems. Yaron has
        lectured, blogged and written about OCaml for years, with
        articles published in Communications of the ACM and the Journal
        of Functional Programming. He chairs the steering committee of
        the Commercial Users of Functional Programming, and is a member
        of the steering committee for the International Conference on
        Functional Programming.
      </p></section><section><h1 id="anil-madhavapeddy">Anil Madhavapeddy</h1><p id="idp189456">
        Anil Madhavapeddy is a Senior Research Fellow at the University
        of Cambridge, based in the Systems Research Group. He was on the
        original team that developed the Xen hypervisor and helped
        develop an industry-leading cloud management toolstack written
        entirely in OCaml. This XenServer product has been deployed on
        millions of physical hosts, and drives critical infrastructure
        for many Fortune 500 companies.
      </p><p id="idp190336">
        Prior to obtaining his PhD in 2006 from the University of
        Cambridge, Anil had a diverse background in industry at NetApp,
        NASA, and Internet Vision. He is an active member of the
        open-source development community with the OpenBSD operating
        system, is on the steering committee of the ACM Commercial Uses
        of Functional Programming workshop, and serves on the boards of
        startup companies where OCaml is extensively used. He has also
        developed the Mirage unikernel system that is written entirely
        in OCaml from the device drivers up.
      </p></section><section><h1 id="jason-hickey">Jason Hickey</h1><p id="idp192448">
        Jason Hickey is a Software Engineer at Google Inc. in Mountain
        View, California. He is part of the team that designs and
        develops the global computing infrastructure used to support
        Google services, including the software systems for managing and
        scheduling massively distributed computing resources.
      </p><p id="idp192832">
        Prior to joining Google, Jason was an Assistant Professor of
        Computer Science at Caltech, where he researched reliable and
        fault-tolerant computing systems, including programming language
        design, formal methods, compilers, and new models of distributed
        computation. He obtained his PhD in Computer Science from
        Cornell University, where he studied programming languages. He
        is the author of the MetaPRL system, a logical framework for
        design and analysis of large software systems; and OMake, an
        advanced build system for large software projects. He is the
        author of the textbook, <span><em>An Introduction to Objective
        Caml</em></span> (unpublished).
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="index.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="pt01.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>