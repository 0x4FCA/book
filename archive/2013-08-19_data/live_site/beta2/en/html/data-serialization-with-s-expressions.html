<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 17. Data Serialization with S-Expressions / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta2',
                        page: 'data\u002Dserialization\u002Dwith\u002Ds\u002Dexpressions.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="maps-and-hash-tables.html">13. Maps and Hash Tables</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html">14. Command Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">15. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-menhir.html">16. Parsing with OCamllex and Menhir</a>
                                            </li>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html" class="here">17. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">18. Concurrent Programming with Async</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 17. Data Serialization with S-Expressions</h1>
                
                

    <p id="idp10508880">
    We've already discussed the parsing of third-party data formats like
    JSON. Sometimes, though, you're less concerned with interoperating
    with specific file formats, and you instead want an easy to use,
    human-readable format that integrates well with OCaml and its
    libraries. Core's solution to this problem is to use s-expressions.
  </p><p id="idp10509632">
    S-expressions are nested parenthetical expressions whose atomic
    values are strings. They were first popularized by the Lisp
    programming language in the 1960s, and have remained one of the
    simplest and most effective ways to encode structured data. There's
    a full definition of them available
    <a href="http://people.csail.mit.edu/rivest/Sexp.txt" target="_top">online</a>.
    An example s-expression might look like this.
  </p><div class="rwocode"><pre><code><div class="highlight"><span class="p">(</span><span class="nf">this</span> <span class="p">(</span><span class="nf">is</span> <span class="nv">an</span><span class="p">)</span> <span class="p">(</span><span class="nf">s</span> <span class="nv">expression</span><span class="p">))</span>
</div></code></pre><div class="rwocodeinfo">S-expression ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/basic.scm">sexpr/basic.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10511808">
    This chapter will show you how to:
  </p><ul><li><p id="idp10512768">
        generate s-expressions from arbitrary OCaml types, thus giving
        you a human-readable format for persisting any values in your
        code.
      </p></li><li><p id="idp10513712">
        expose s-expressions across module interfaces, including with
        abstract types.
      </p></li><li><p id="idp10514592">
        generate good error messages for debugging malformed inputs.
      </p></li><li><p id="idp10515456">
        use custom type annotations to control the exact printing
        behavior for s-expression converters.
      </p></li></ul><section><h1 id="basic-usage">Basic Usage</h1><p id="idp10517328">
      OCaml values aren't directly converted to-and-from strings of
      s-expressions when you use Core. The s-expression is instead built
      up as an OCaml value which is later serialized into strings or
      memory buffers. The OCaml type of an s-expression is quite simple.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">module</span> <span class="keyword6">Sexp </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
  <span class="keyword4">type</span> t <span class="keyword2">=</span> 
  <span class="keyword2">|</span> <span class="keyword6">Atom </span><span class="keyword2">of</span> <span class="keyword3">string</span>
  <span class="keyword2">|</span> <span class="keyword6">List </span><span class="keyword2">of</span> t <span class="keyword3">list</span>
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp.mli">sexpr/sexp.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10518720">
      An s-expression can be thought of as a tree where each node
      contains a list of its children, and where the leaves of the tree
      are strings. Here's how we can use this type to represent the our
      example s-expression.
    </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">float</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : int; bar : float; }
</div># <span class="keyword4">let</span> sexp_of_t t <span class="keyword2">=</span>
    <span class="keyword4">let</span> a x <span class="keyword2">=</span> <span class="keyword5">Sexp.Atom </span>x <span class="keyword4">and</span> l x <span class="keyword2">=</span> <span class="keyword5">Sexp.List </span>x <span class="keyword4">in</span>
    l <span class="keyword2">[</span> l <span class="keyword2">[</span>a <span class="keyword7">&quot;foo&quot;</span><span class="keyword2">;</span> <span class="keyword5">Int.</span>sexp_of_t t.foo  <span class="keyword2">]</span><span class="keyword2">;</span>
        l <span class="keyword2">[</span>a <span class="keyword7">&quot;bar&quot;</span><span class="keyword2">;</span> <span class="keyword5">Float.</span>sexp_of_t t.bar<span class="keyword2">]</span><span class="keyword2">;</span> <span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_t <span class="keyword2">{</span> foo <span class="keyword2">=</span> <span class="keyword8">3</span><span class="keyword2">;</span> bar <span class="keyword2">=</span> <span class="keyword8">-5</span>.<span class="keyword8">5</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((foo 3) (bar -5.5))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/manually_making_sexp.topscript">sexpr/manually_making_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10520096">
      Core provides good support for <code>s-expressions</code> in
      its <code>Sexp</code> module, including functions for
      converting s-expressions to and from strings. If we do the same
      example above with Core's s-expression type, we'll see that the
      output in the top-level is easier to read.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> a x <span class="keyword2">=</span> <span class="keyword5">Sexp.Atom </span>x <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val a : string -&gt; Sexp.t = &lt;fun&gt;
</div># <span class="keyword4">let</span> l x <span class="keyword2">=</span> <span class="keyword5">Sexp.List </span>x <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val l : Sexp.t list -&gt; Sexp.t = &lt;fun&gt;
</div># <span class="keyword4">let</span> sexp <span class="keyword2">=</span> l <span class="keyword2">[</span>
    a <span class="keyword7">&quot;this&quot;</span><span class="keyword2">;</span>
    l <span class="keyword2">[</span>a <span class="keyword7">&quot;is&quot;</span><span class="keyword2">;</span> a <span class="keyword7">&quot;an&quot;</span><span class="keyword2">]</span><span class="keyword2">;</span>
    l <span class="keyword2">[</span> a <span class="keyword7">&quot;s&quot;</span><span class="keyword2">;</span> a <span class="keyword7">&quot;expression&quot;</span><span class="keyword2">]</span> <span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sexp : Sexp.t = (this (is an) (s expression))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/print_sexp.topscript">sexpr/print_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10522896">
      This prints out nicely because Core registers a pretty printer
      with the toplevel. This pretty-printer uses Core's functions for
      converting s-expressions to and from strings.
    </p><div class="rwocode"><pre><code># <span class="keyword5">Sexp.</span>of_string <span class="keyword2">(</span><span class="keyword7">&quot;(1 2 (3 4))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (1 2 (3 4))
</div># <span class="keyword5">Sexp.</span>to_string <span class="keyword2">(</span><span class="keyword5">Sexp.List </span><span class="keyword2">[</span><span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;1&quot;</span><span class="keyword2">;</span> <span class="keyword5">Sexp.Atom </span><span class="keyword7">&quot;2&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;(1 2)&quot;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_printer.topscript">sexpr/sexp_printer.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10524208">
      In addition to providing the <code>Sexp</code> module, most
      of the base types in Core support conversion to and from
      s-expressions. For example, we can write:
    </p><div class="rwocode"><pre><code># <span class="keyword5">Int.</span>sexp_of_t <span class="keyword8">3</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = 3
</div># <span class="keyword5">List.</span>sexp_of_t <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : ('a -&gt; Sexp.t) -&gt; 'a list -&gt; Sexp.t = &lt;fun&gt;
</div># <span class="keyword5">List.</span>sexp_of_t <span class="keyword5">Int.</span>sexp_of_t <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span> <span class="keyword8">2</span><span class="keyword2">;</span> <span class="keyword8">3</span><span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (1 2 3)
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/to_from_sexp.topscript">sexpr/to_from_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10526192">
      Notice that <code>List.sexp_of_t</code> is polymorphic, and
      takes as its first argument another conversion function to handle
      the elements of the list to be converted. Core uses this scheme
      more generally for defining sexp-converters for polymorphic types.
    </p><aside class="note"><h1>
    More on toplevel printing
    </h1><p id="idp10528240">
      The values of the s-expressions that we created above were printed
      properly as s-expressions in the toplevel, instead of as the tree
      of <code>Atom</code> and <code>List</code> variants
      that they're actually made of.
    </p><p id="idp10530272">
      This is due to OCaml's facility for installing custom
      <span><em>toplevel printers</em></span> that can rewrite some
      values into more toplevel-friendly equivalents. They are generally
      installed as <code>ocamlfind</code> packages ending in
      <code>top</code>.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlfind list | grep top
</div><div class="rwocodeout">compiler-libs.toplevel (version: [distributed with Ocaml])</div><div class="rwocodeout">core.top            (version: 109.36.00)</div><div class="rwocodeout">lwt.simple-top      (version: 2.4.3)</div><div class="rwocodeout">num-top             (version: 1.3.3)</div><div class="rwocodeout">sexplib.top         (version: 109.20.00)</div><div class="rwocodeout">uri.top             (version: 1.3.8)</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/list_top_packages.out">sexpr/list_top_packages.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10533424">
      The <code>core.top</code> package (which you should have
      loaded by default in your <code>.ocamlinit</code> file)
      loads in printers for the Core extensions already, so you don't
      need to do anything special to use the Sexplib printer.
    </p></aside><section><h1 id="generating-s-expressions-from-ocaml-types">Generating s-expressions from OCaml types</h1><p id="idp10536832">
        But what if you want a function to convert some brand new type
        to an s-expression? You can of course write it yourself
        manually:
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">float</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : int; bar : float; }
</div># <span class="keyword4">let</span> sexp_of_t t <span class="keyword2">=</span>
    <span class="keyword4">let</span> a x <span class="keyword2">=</span> <span class="keyword5">Sexp.Atom </span>x <span class="keyword4">and</span> l x <span class="keyword2">=</span> <span class="keyword5">Sexp.List </span>x <span class="keyword4">in</span>
    l <span class="keyword2">[</span> l <span class="keyword2">[</span>a <span class="keyword7">&quot;foo&quot;</span><span class="keyword2">;</span> <span class="keyword5">Int.</span>sexp_of_t t.foo  <span class="keyword2">]</span><span class="keyword2">;</span>
        l <span class="keyword2">[</span>a <span class="keyword7">&quot;bar&quot;</span><span class="keyword2">;</span> <span class="keyword5">Float.</span>sexp_of_t t.bar<span class="keyword2">]</span><span class="keyword2">;</span> <span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_t <span class="keyword2">{</span> foo <span class="keyword2">=</span> <span class="keyword8">3</span><span class="keyword2">;</span> bar <span class="keyword2">=</span> <span class="keyword8">-5</span>.<span class="keyword8">5</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((foo 3) (bar -5.5))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/manually_making_sexp.topscript">sexpr/manually_making_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10538128">
        This is somewhat tiresome to write, and it gets more so when you
        consider the parser, <span><em>i.e.</em></span>,
        <code>t_of_sexp</code>, which is considerably more
        complex. Writing this kind of parsing and printing code by hand
        is mechanical and error prone, not to mention a drag.
      </p><p id="idp10539952">
        Given how mechanical the code is, you could imagine writing a
        program that inspected the type definition and autogenerated the
        conversion code for you. As it turns out, we can do just that
        using <code>sexplib</code>. The <code>sexplib</code>
        package, which is included with Core, provides both a library
        for manipulating s-expressions and a <span><em>syntax
        extension</em></span> for generating such conversion functions.
        With that syntax extension enabled, any type that has
        <code>with sexp</code> as an annotation will trigger the
        generation of the functions we want for free.
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> <span class="keyword3">float</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : int; bar : float; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># t_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((bar 35) (foo 3))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : t = {foo = 3; bar = 35.}
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/auto_making_sexp.topscript">sexpr/auto_making_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10544208">
        The <code>sexplib</code> syntax extension sees the
        <code>with sexp</code> annotation replaces it with the
        definition of the conversions functions we see above.
      </p><p id="idp10546160">
        The syntax extension can be used outside of type declarations as
        well. As discussed in
        <a href="error-handling.html">Chapter 7, <i>Error Handling</i></a>,
        <code>with sexp</code> can be attached to the declaration
        of an exception, which will improve the ability of Core to
        generate a useful string representation of an exception.
      </p><div class="rwocode"><pre><code># <span class="keyword1">exception</span> <span class="keyword6">Bad_message </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword3">list</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">exception Bad_message of string list
</div># <span class="keyword5">Exn.</span>to_string <span class="keyword2">(</span><span class="keyword6">Bad_message </span><span class="keyword2">[</span><span class="keyword7">&quot;1&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;2&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;3&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;(\&quot;Bad_message(_)\&quot;)&quot;
</div># <span class="keyword1">exception</span> <span class="keyword6">Good_message </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword3">list</span> <span class="keyword1">with</span> sexp<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">exception Good_message of string list
</div># <span class="keyword5">Exn.</span>to_string <span class="keyword2">(</span><span class="keyword6">Good_message </span><span class="keyword2">[</span><span class="keyword7">&quot;1&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;2&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;3&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;(//toplevel//.Good_message (1 2 3))&quot;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/auto_making_sexp.topscript">sexpr/auto_making_sexp.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10548960">
        You don't always have to declare a named type to create an
        s-expression converter. The following syntax lets you create one
        inline, as part of a larger expression.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> l <span class="keyword2">=</span> <span class="keyword2">[</span><span class="keyword2">(</span><span class="keyword8">1</span>,<span class="keyword7">&quot;one&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span> <span class="keyword2">(</span><span class="keyword8">2</span>,<span class="keyword7">&quot;two&quot;</span><span class="keyword2">)</span><span class="keyword2">]</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val l : (int * string) list = [(1, &quot;one&quot;); (2, &quot;two&quot;)]
</div># <span class="keyword5">List.</span>iter l ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span>
    <span class="keyword1">&lt;:sexp_of&lt;</span><span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">string</span><span class="keyword1">&gt;&gt;</span> x
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>to_string
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>(1 one)
(2 two)
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/inline_sexp.topscript">sexpr/inline_sexp.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10550272">
        The declaration
        <code>&lt;:sexp_of&lt;int * string&gt;&gt;</code> simply
        gets expanded to the sexp-converter for the type
        <code>int * string</code>. This is useful whenever you
        need a sexp-converter for an anonymous type.
      </p><p id="idp10552336">
        The syntax extensions bundled with Core almost all have the same
        basic structure: they autogenerate code based on type
        definitions, implementing functionality that you could in theory
        have implemented by hand, but with far less programmer effort.
      </p><aside class="note"><h1>
      Syntax extensions, camlp4 and
      type_conv
</h1><p id="idp10555120">
        OCaml doesn't directly support generating code from type
        definitions. Instead, it supplies a powerful syntax extension
        mechanism known as <code>camlp4</code>, which lets you
        extend the grammar of the language. In the case of
        <code>sexplib</code>, <code>camlp4</code> is used to
        create s-expression conversion functions.
        <code>camlp4</code> is well integrated into the OCaml
        toolchain, and can be activated within the toplevel and also
        included in compilation using the <code>-pp</code>
        compiler flag.
      </p><p id="idp10559472">
<code>sexplib</code> is part of a family of syntax
        extensions, including <code>comparelib</code>, described
        in <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a>, and
        <code>fieldslib</code>, described in
        <a href="records.html">Chapter 5, <i>Records</i></a>, that generate code based on
        type declarations, and are all based on a common library called
        <code>type_conv</code>. This library provides a common
        language for annotating types (<span><em>e.g.</em></span>, using
        the <code>with</code> notation) and utilities for working
        with type definitions. If you want to build your own type-driven
        syntax extension, you should consider basing it on
        <code>type_conv</code>.
      </p></aside></section></section><section><h1 id="the-sexp-format">The Sexp format</h1><p id="idp10567808">
      The textual representation of s-expressions is pretty
      straightforward. An s-expression is written down as a nested
      parenthetical expression, with whitespace-separated strings as the
      atoms. Quotes are used for atoms that contain parentheses or
      spaces themselves; backslash is the escape character; and
      semicolons are used to introduce single-line comments. Thus, the
      following file, <code>example.scm</code>:
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="c1">;; example.scm</span>

<span class="p">((</span><span class="nf">foo</span> <span class="mf">3.3</span><span class="p">)</span> <span class="c1">;; This is a comment</span>
 <span class="p">(</span><span class="nf">bar</span> <span class="s">&quot;this is () an \&quot; atom&quot;</span><span class="p">))</span>
</div></code></pre><div class="rwocodeinfo">S-expression ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/example.scm">sexpr/example.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10570080">
      can be loaded using sexplib. As you can see, the commented data is
      not part of the resulting s-expression.
    </p><div class="rwocode"><pre><code># <span class="keyword5">Sexp.</span>load_sexp <span class="keyword7">&quot;example.scm&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((foo 3.3) (bar &quot;this is () an \&quot; atom&quot;))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/example_load.topscript">sexpr/example_load.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10571344">
      All in, the s-expression format actually supports three comment
      syntaxes:
    </p><ul><li><p id="idp10572352">
<code>;</code>, which comments out everything to the end
          of a line
        </p></li><li><p id="idp10573856">
<code>#|</code> and <code>|#</code>, which are
          delimiters for commenting out a block
        </p></li><li><p id="idp10576096">
<code>#;</code>, which comments out the first complete
          s-expression that follows.
        </p></li></ul><p id="idp10577536">
      The following example shows all of these in action.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="c1">;; comment_heavy_example.scm</span>
<span class="p">((</span><span class="nf">this</span> <span class="nv">is</span> <span class="nv">included</span><span class="p">)</span>
 <span class="c1">; (this is commented out</span>
 <span class="p">(</span><span class="nf">this</span> <span class="nv">stays</span><span class="p">)</span>
 <span class="o">#</span><span class="c1">; (all of this is commented</span>
     <span class="nv">out</span> <span class="p">(</span><span class="nf">even</span> <span class="nv">though</span> <span class="nv">it</span> <span class="nv">crosses</span> <span class="nv">lines</span><span class="o">.</span><span class="p">))</span>
  <span class="p">(</span><span class="k">and </span><span class="o">#</span><span class="nv">|</span> <span class="nv">block</span> <span class="nv">delimiters</span> <span class="o">#</span><span class="nv">|</span> <span class="nv">which</span> <span class="nv">can</span> <span class="nv">be</span> <span class="nv">nested</span> <span class="nv">|</span><span class="o">#</span>
     <span class="nv">will</span> <span class="nv">comment</span> <span class="nv">out</span>
    <span class="nv">an</span> <span class="nv">arbitrary</span> <span class="nv">multi-line</span> <span class="nv">block</span><span class="p">)))</span> <span class="nv">|</span><span class="o">#</span>
   <span class="nv">now</span> <span class="nv">we</span><span class="ss">'re</span> <span class="nv">done</span>
   <span class="p">))</span>
</div></code></pre><div class="rwocodeinfo">S-expression ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/comment_heavy.scm">sexpr/comment_heavy.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10578720">
      Again, loading the file as an s-expression drops the comments.
    </p><div class="rwocode"><pre><code># <span class="keyword5">Sexp.</span>load_sexp <span class="keyword7">&quot;comment_heavy.scm&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((this is included) (this stays) (and now we're done))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/example_load.topscript">sexpr/example_load.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10579936">
      Note that the comments were dropped from the file upon reading.
      This is expected, since there's no place in the
      <code>Sexp.t</code> type to store comments.
    </p><p id="idp10581200">
      If we introduce an error into our s-expression, by, say, creating
      a file <code>broken_example.scm</code> which is
      <code>example.scm</code> without open-paren in front of
      <code>bar</code>, we'll get a parse error:
    </p><div class="rwocode"><pre><code># <span class="keyword5">Exn.</span>handle_uncaught ~exit<span class="keyword2">:</span>false <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
    ignore <span class="keyword2">(</span><span class="keyword5">Sexp.</span>load_sexp <span class="keyword7">&quot;example_broken.scm&quot;</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>Uncaught exception:
  
  (Sexplib.Sexp.Parse_error
   ((location parse) (err_msg &quot;unexpected character: ')'&quot;) (text_line 4)
    (text_char 29) (global_offset 78) (buf_pos 78)))

- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/example_load.topscript">sexpr/example_load.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10584576">
      In the above, we use <code>Exn.handle_uncaught</code> to
      make sure that the exception gets printed out in full detail. You
      should generally wrap every Core program in this handler to get
      good error messages for any unexpected exceptions.
    </p></section><section><h1 id="sexp-converters">Sexp converters</h1><p id="idp10587200">
      The most important functionality provided by Sexplib is the
      auto-generation of converters for new types. We've seen a bit of
      how this works already, but let's walk through a complete example.
      Here's the source for the beginning of a library for representing
      integer intervals.
    </p><div class="rwocode"><pre><code><span class="comments">(* Module for representing closed integer intervals *)</span>
<span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="comments">(* Invariant: For any Range (x,y), y &gt;= x *)</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword2">of</span> <span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">int</span>
  <span class="keyword2">|</span> <span class="keyword6">Empty
</span><span class="keyword1">with</span> sexp

<span class="keyword4">let</span> is_empty <span class="keyword2">=</span>
  <span class="keyword1">function</span> 
  <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> true 
  <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword8">_</span> -<span class="keyword2">&gt;</span> false

<span class="keyword4">let</span> create x y <span class="keyword2">=</span>
  <span class="keyword1">if</span> x <span class="keyword2">&gt;</span> y <span class="keyword1">then</span>
    <span class="keyword6">Empty </span>
  <span class="keyword1">else</span> 
    <span class="keyword6">Range </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span>

<span class="keyword4">let</span> contains i x <span class="keyword2">=</span>
  <span class="keyword1">match</span> i <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> false
  <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword2">(</span>low,high<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> x <span class="keyword2">&gt;</span><span class="keyword2">=</span> low <span class="keyword2">&amp;&amp;</span> x <span class="keyword2">&lt;</span><span class="keyword2">=</span> high</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/int_interval.ml">sexpr/int_interval.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10588640">
      We can now use this module as follows.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">let</span> intervals <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">module</span> <span class="keyword6">I </span><span class="keyword2">=</span> <span class="keyword6">Int_interval </span><span class="keyword4">in</span>
  <span class="keyword2">[</span> <span class="keyword5">I.</span>create <span class="keyword8">3</span> <span class="keyword8">4</span><span class="keyword2">;</span>
    <span class="keyword5">I.</span>create <span class="keyword8">5</span> <span class="keyword8">4</span><span class="keyword2">;</span> <span class="comments">(* should be empty *)</span>
    <span class="keyword5">I.</span>create <span class="keyword8">2</span> <span class="keyword8">3</span><span class="keyword2">;</span>
    <span class="keyword5">I.</span>create <span class="keyword8">1</span> <span class="keyword8">6</span><span class="keyword2">;</span>
  <span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  intervals
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>sexp_of_t <span class="keyword5">Int_interval.</span>sexp_of_t
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>to_string_hum
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> print_endline</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/test_interval.ml">sexpr/test_interval.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10589808">
      But we're still missing something: we haven't created an
      <code>mli</code> signature for
      <code>Int_interval</code> yet. Note that we need to
      explicitly export the s-expression converters that were created
      within the <code>ml</code> file. For example, here's an
      interface that doesn't export the s-expression functions.
    </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t

<span class="keyword4">val</span> is_empty <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> bool
<span class="keyword4">val</span> create <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> t
<span class="keyword4">val</span> contains <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> bool</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/int_interval_nosexp.mli">sexpr/int_interval_nosexp.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10593264">
      Building this will give us the following error:
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlbuild -use-ocamlfind -tag thread -syntax camlp4o -pkgs core,sexplib.syntax test_interval_nosexp.native
</div><div class="rwocodeout">File &quot;test_interval_nosexp.ml&quot;, line 14, characters 20-42:</div><div class="rwocodeout">Error: Unbound value Int_interval.sexp_of_t</div><div class="rwocodeout">Command exited with code 2.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/build_test_interval_nosexp.out">sexpr/build_test_interval_nosexp.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10594464">
      We could export the types by hand in the signature, by writing the
      signatures for the extra functions generated by
      <code>sexplib</code>.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t
<span class="keyword4">val</span> t_of_sexp <span class="keyword2">:</span> <span class="keyword5">Sexp.</span>t -<span class="keyword2">&gt;</span> t
<span class="keyword4">val</span> sexp_of_t <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword5">Sexp.</span>t

<span class="keyword4">val</span> is_empty <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> bool
<span class="keyword4">val</span> create <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> t
<span class="keyword4">val</span> contains <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> bool</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/int_interval_manual_sexp.mli">sexpr/int_interval_manual_sexp.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10596448">
      This isn't an ideal solution, as it makes you repeatedly expose
      these extra functions in every signature you create where you want
      to serialize values. Sexplib solves this by exposing the same
      syntax extension in signature definitions, so that we can just use
      the same <code>with</code> shorthand in the
      <code>mli</code> file. Here's the final version of the
      signature that does just this.
    </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword1">with</span> sexp

<span class="keyword4">val</span> is_empty <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> bool
<span class="keyword4">val</span> create <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> t
<span class="keyword4">val</span> contains <span class="keyword2">:</span> t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> bool</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/int_interval.mli">sexpr/int_interval.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10599360">
      At this point <code>test_interval.ml</code> will compile
      again, and if we run it, we'll get the following output.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild test_interval.native
</div><div class="highlight"><span class="gp">$</span> ./test_interval.native
</div><div class="rwocodeout">((Range 3 4) Empty (Range 2 3) (Range 1 6))</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/build_test_interval.out">sexpr/build_test_interval.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1 id="preserving-invariants">Preserving invariants</h1><p id="idp10602368">
        One easy mistake to make when dealing with sexp converters is to
        ignore the fact that those converters can violate the invariants
        of your code. For example, the <code>Int_interval</code>
        module depends for the correctness of the
        <code>is_empty</code> check on the fact that for any value
        <code>Range (x,y)</code>, <code>y</code> is greater
        than or equal to <code>x</code>. The
        <code>create</code> function preserves this invariant, but
        the <code>t_of_sexp</code> function does not.
      </p><p id="idp10608048">
        We can fix this problem by overriding the autogenerated function
        and writing a custom sexp-converter that is based on the
        autogenerated converter.
      </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword2">of</span> <span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">int</span>
  <span class="keyword2">|</span> <span class="keyword6">Empty
</span><span class="keyword1">with</span> sexp

<span class="keyword4">let</span> create x y <span class="keyword2">=</span>
  <span class="keyword1">if</span> x <span class="keyword2">&gt;</span> y <span class="keyword1">then</span> <span class="keyword6">Empty </span><span class="keyword1">else</span> <span class="keyword6">Range </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span>

<span class="keyword4">let</span> t_of_sexp sexp <span class="keyword2">=</span>
  <span class="keyword4">let</span> t <span class="keyword2">=</span> t_of_sexp sexp <span class="keyword4">in</span>
  <span class="keyword4">begin</span> <span class="keyword1">match</span> t <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Empty </span>-<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword2">)</span>
    <span class="keyword2">|</span> <span class="keyword6">Range </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword1">if</span> y <span class="keyword2">&lt;</span> x <span class="keyword1">then</span> of_sexp_error <span class="keyword7">&quot;Upper and lower bound of Range swapped&quot;</span> sexp
  <span class="keyword4">end</span><span class="keyword2">;</span>
  t</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_override.ml">sexpr/sexp_override.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10609344">
        This trick of overriding an existing function definition with a
        new one is perfectly acceptable in OCaml. Function definitions
        are only recursive if the <code>rec</code> keyword is
        specified, and so in this case the inner
        <code>t_of_sexp</code> call will go to the earlier
        autogenerated definition that resulted from the
        <code>type t with sexp</code> definition.
      </p><p id="idp10612176">
        We call the function <code>of_sexp_error</code> to raise
        an exception because that improves the error reporting that
        Sexplib can provide when a conversion fails.
      </p></section><section><h1 id="getting-good-error-messages">Getting good error messages</h1><p id="idp10614720">
        There are two steps to deserializing a type from an
        s-expression: first, converting the bytes in a file to an
        s-expression, and the second, converting that s-expression into
        the type in question. One problem with this is that it can be
        hard to localize errors to the right place using this scheme.
        Consider the following example:
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> 
  a<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
  b<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
  c<span class="keyword2">:</span> <span class="keyword3">float</span> option 
<span class="keyword2">}</span> <span class="keyword1">with</span> sexp

<span class="keyword4">let</span> run <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> t <span class="keyword2">=</span>
    <span class="keyword5">Sexp.</span>load_sexp <span class="keyword7">&quot;foo_broken_example.scm&quot;</span>
    <span class="keyword2">|</span><span class="keyword2">&gt;</span> t_of_sexp
  <span class="keyword4">in</span>
  printf <span class="keyword7">&quot;b is: %d\n%!&quot;</span> t.b

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Exn.</span>handle_uncaught ~exit<span class="keyword2">:</span>true run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/read_foo.ml">sexpr/read_foo.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10616208">
        If you were to run this on a malformatted file, say, this one:
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="p">((</span><span class="nf">a</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">b</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">c</span> <span class="mf">1.0</span><span class="p">))</span>
</div></code></pre><div class="rwocodeinfo">S-expression ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/foo_broken_example.scm">sexpr/foo_broken_example.scm</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10617408">
        you'll get the following error:
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlbuild -use-ocamlfind -tag thread -syntax camlp4o -pkg core,sexplib.syntax read_foo.native
</div><div class="highlight"><span class="gp">$</span> ./read_foo.native foo_example_broken.scm
</div><div class="rwocodeout">Uncaught exception:</div><div class="rwocodeout">  </div><div class="rwocodeout">  (Sexplib.Conv.Of_sexp_error</div><div class="rwocodeout">   (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;) &quot;&quot;)</div><div class="rwocodeout"> </div><div class="rwocodeout">Raised at file &quot;lib/conv.ml&quot;, line 281, characters 36-72</div><div class="rwocodeout">Called from file &quot;lib/core_int.ml&quot;, line 6, characters 7-14</div><div class="rwocodeout">Called from file &quot;lib/std_internal.ml&quot;, line 115, characters 7-33</div><div class="rwocodeout">Called from file &quot;lib/exn.ml&quot;, line 87, characters 6-10</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/build_read_foo.out">sexpr/build_read_foo.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10618576">
        If all you have is the error message and the string, it's not
        terribly informative. In particular, you know that the parsing
        error-ed out on the atom &quot;not-an-integer&quot;, but you
        don't know which one! In a large file, this kind of bad error
        message can be pure misery.
      </p><p id="idp10619328">
        But there's hope! If we make small change to the
        <code>run</code> function as follows:
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> 
  a<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
  b<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
  c<span class="keyword2">:</span> <span class="keyword3">float</span> option 
<span class="keyword2">}</span> <span class="keyword1">with</span> sexp

<span class="keyword4">let</span> run <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> t <span class="keyword2">=</span> <span class="keyword5">Sexp.</span>load_sexp_conv_exn <span class="keyword7">&quot;foo_broken_example.scm&quot;</span> t_of_sexp <span class="keyword4">in</span>
  printf <span class="keyword7">&quot;b is: %d\n%!&quot;</span> t.b

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Exn.</span>handle_uncaught ~exit<span class="keyword2">:</span>true run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/read_foo_better_errors.ml">sexpr/read_foo_better_errors.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10621264">
        and run it again, we'll get the following much more helpful
        error message:
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlbuild -use-ocamlfind -tag thread -syntax camlp4o -pkg core,sexplib.syntax read_foo_better_errors.native
</div><div class="highlight"><span class="gp">$</span> ./read_foo_better_errors.native foo_example_broken.scm
</div><div class="rwocodeout">Uncaught exception:</div><div class="rwocodeout">  </div><div class="rwocodeout">  (Sexplib.Conv.Of_sexp_error</div><div class="rwocodeout">   (Sexplib.Sexp.Annotated.Conv_exn foo_broken_example.scm:2:5</div><div class="rwocodeout">    (Failure &quot;int_of_sexp: (Failure int_of_string)&quot;))</div><div class="rwocodeout">   &quot;&quot;)</div><div class="rwocodeout"> </div><div class="rwocodeout">Raised at file &quot;lib/pre_sexp.ml&quot;, line 1145, characters 12-58</div><div class="rwocodeout">Called from file &quot;lib/exn.ml&quot;, line 87, characters 6-10</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/build_read_foo_better_errors.out">sexpr/build_read_foo_better_errors.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10622496">
        In the above error, &quot;foo_broken_example.scm:2:5&quot; tells
        us that the error occurred on
        &quot;foo_broken_example.scm&quot;, line 2, character 5, which
        is a much better start for figuring out what has gone wrong.
      </p></section></section><section><h1 id="sexp-conversion-directives">Sexp-conversion directives</h1><p id="idp10625024">
      Sexplib supports a collection of directives for modifying the
      default behavior of the autogenerated sexp-converters. These
      directives allow you to customize the way in which types are
      represented as s-expressions without having to write a custom
      parser.
    </p><section><h1 id="sexp_opaque"><code>sexp_opaque</code></h1><p id="idp10627264">
        The most commonly used directive is
        <code>sexp_opaque</code>, whose purpose is to mark a given
        component of a type as being unconvertible. Anything marked with
        <code>sexp_opaque</code> will be presented as the atom
        <code>&lt;opaque&gt;</code> by the to-sexp converter, and
        will trigger an exception from the from-sexp converter.
      </p><p id="idp10630064">
        Note that the type of a component marked as opaque doesn't need
        to have a sexp-converter defined. Here, if we define a type
        without a sexp-converter, and then try to use another type with
        a sexp-converter, we'll error out:
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> no_converter <span class="keyword2">=</span> <span class="keyword3">int</span> <span class="keyword2">*</span> <span class="keyword3">int</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type no_converter = int * int
</div># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 14-26:
Error: Unbound value no_converter_of_sexp
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10631456">
        But with <code>sexp_opaque</code>, we won't:
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter sexp_opaque<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : no_converter; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10633328">
        And if we now convert a value of this type to an s-expression,
        we'll see the contents of field <code>a</code> marked as
        opaque:
      </p><div class="rwocode"><pre><code># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword8">3</span>,<span class="keyword8">4</span><span class="keyword2">)</span><span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;foo&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a &lt;opaque&gt;) (b foo))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10635280">
        Note that the <code>t_of_sexp</code> function for an
        opaque type is generated, but will fail at runtime if it is
        used.
      </p><div class="rwocode"><pre><code># t_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((a whatever) (b foo))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception:
(Sexplib.Conv.Of_sexp_error
 (Failure &quot;opaque_of_sexp: cannot convert opaque values&quot;) whatever).
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10637248">
        This is there to allow for s-expression converters to be created
        for types containing <code>sexp_opaque</code> values, and
        the resulting converters won't necessarily fail. For example, if
        we made the field containing a <code>no_converter</code> a
        list, the <code>t_of_sexp</code> function could still
        succeed when that list was empty, as shown below.
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter sexp_opaque <span class="keyword3">list</span><span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : no_converter list; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># t_of_sexp <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((a ()) (b foo))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : t = {a = []; b = &quot;foo&quot;}
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10640816">
        If you really only want to generate one direction of converter,
        one can do this by annotating the type with
        <code>with sexp_of</code> or
        <code>with of_sexp</code>, as shown below.
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter sexp_opaque<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp_of <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : no_converter; b : string; }
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> no_converter sexp_opaque<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> of_sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : no_converter; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_opaque.topscript">sexpr/sexp_opaque.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="sexp_list"><code>sexp_list</code></h1><p id="idp10645168">
        Sometimes, sexp-converters have more parentheses than one would
        ideally like. Consider, for example, the following variant type:
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> compatible_versions <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Specific </span><span class="keyword2">of</span> <span class="keyword3">string</span> <span class="keyword3">list</span>
  <span class="keyword2">|</span> <span class="keyword6">All </span><span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type compatible_versions = Specific of string list | All
val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;
val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_compatible_versions
  <span class="keyword2">(</span><span class="keyword6">Specific </span><span class="keyword2">[</span><span class="keyword7">&quot;3.12.0&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;3.12.1&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;3.13.0&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (Specific (3.12.0 3.12.1 3.13.0))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_list.topscript">sexpr/sexp_list.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10646464">
        You might prefer to make the syntax a bit less parenthesis-laden
        by dropping the parentheses around the list.
        <code>sexp_list</code> gives us this alternate syntax:
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> compatible_versions <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Specific </span><span class="keyword2">of</span> <span class="keyword3">string</span> sexp_list
  <span class="keyword2">|</span> <span class="keyword6">All </span><span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type compatible_versions = Specific of string list | All
val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;
val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_compatible_versions
  <span class="keyword2">(</span><span class="keyword6">Specific </span><span class="keyword2">[</span><span class="keyword7">&quot;3.12.0&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;3.12.1&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;3.13.0&quot;</span><span class="keyword2">]</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = (Specific 3.12.0 3.12.1 3.13.0)
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_list.topscript">sexpr/sexp_list.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="sexp_option"><code>sexp_option</code></h1><p id="idp10650096">
        Another common directive is <code>sexp_option</code>,
        which is used to to make a record field optional in the
        s-expression. Normally, optional values are represented either
        as <code>()</code> for <code>None</code>, or as
        <code>(x)</code> for <code>Some x</code>, and a
        record field containing an option would be rendered accordingly.
        For example:
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> <span class="keyword3">int</span> option<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : int option; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> None<span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;hello&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a ()) (b hello))
</div># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> <span class="keyword6">Some </span><span class="keyword8">3</span><span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;hello&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a (3)) (b hello))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_option.topscript">sexpr/sexp_option.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10655072">
        But what if we want a field to be optional,
        <span><em>i.e.</em></span>, we want to allow it to be omitted
        from the record entirely? In that case, we can mark it with
        <code>sexp_option</code>:
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> a<span class="keyword2">:</span> <span class="keyword3">int</span> sexp_option<span class="keyword2">;</span> b<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { a : int option; b : string; }
val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
</div># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> <span class="keyword6">Some </span><span class="keyword8">3</span><span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;hello&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((a 3) (b hello))
</div># sexp_of_t <span class="keyword2">{</span> a <span class="keyword2">=</span> None<span class="keyword2">;</span> b <span class="keyword2">=</span> <span class="keyword7">&quot;hello&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((b hello))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_option.topscript">sexpr/sexp_option.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="specifying-defaults">Specifying defaults</h1><p id="idp10658816">
        The <code>sexp_option</code> declaration is really just an
        example of how one might want to deal with default values. With
        <code>sexp_option</code>, your type on the OCaml side is
        an option, with <code>None</code> representing the case
        where no value is provided. But you might want to allow other
        ways of filling in default values.
      </p><p id="idp10661664">
        Consider the following type which represents the configuration
        of a very simple web-server.
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> http_server_config <span class="keyword2">=</span> <span class="keyword2">{</span>
     web_root<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
     port<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
     addr<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
  <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10662912">
        One could imagine making some of these parameters optional; in
        particular, by default, we might want the web server to bind to
        port 80, and to listen as localhost. The sexp-syntax allows this
        as follows.
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> http_server_config <span class="keyword2">=</span> <span class="keyword2">{</span>
     web_root<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
     port<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword1">with</span> default<span class="keyword2">(</span><span class="keyword8">80</span><span class="keyword2">)</span><span class="keyword2">;</span>
     addr<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword1">with</span> default<span class="keyword2">(</span><span class="keyword7">&quot;localhost&quot;</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10664288">
        The top-level will echo back the type you just defined as usual,
        but also generate the additional conversion functions that let
        you convert to and from s-expressions.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> cfg <span class="keyword2">=</span> http_server_config_of_sexp
   <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((web_root /var/www/html))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val cfg : http_server_config =
  {web_root = &quot;/var/www/html&quot;; port = 80; addr = &quot;localhost&quot;}
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10665616">
        When we convert the configuration back out to an s-expression,
        you'll notice that no data is dropped.
      </p><div class="rwocode"><pre><code># sexp_of_http_server_config cfg <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((web_root /var/www/html) (port 80) (addr localhost))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10666880">
        We could make the generated s-expression also drop exported
        values, by using the <code>sexp_drop_default</code>
        directive.
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> http_server_config <span class="keyword2">=</span> <span class="keyword2">{</span>
     web_root<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span>
     port<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword1">with</span> default<span class="keyword2">(</span><span class="keyword8">80</span><span class="keyword2">)</span>, sexp_drop_default<span class="keyword2">;</span>
     addr<span class="keyword2">:</span> <span class="keyword3">string</span> <span class="keyword1">with</span> default<span class="keyword2">(</span><span class="keyword7">&quot;localhost&quot;</span><span class="keyword2">)</span>, sexp_drop_default<span class="keyword2">;</span>
  <span class="keyword2">}</span> <span class="keyword1">with</span> sexp <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type http_server_config = { web_root : string; port : int; addr : string; }
val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;
val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;
</div># <span class="keyword4">let</span> cfg <span class="keyword2">=</span> http_server_config_of_sexp
  <span class="keyword2">(</span><span class="keyword5">Sexp.</span>of_string <span class="keyword7">&quot;((web_root /var/www/html))&quot;</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val cfg : http_server_config =
  {web_root = &quot;/var/www/html&quot;; port = 80; addr = &quot;localhost&quot;}
</div># sexp_of_http_server_config cfg <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((web_root /var/www/html))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10668848">
        As you can see, the fields that are at their default values are
        simply omitted from the s-expression. On the other hand, if we
        convert a config with other values, then those values will be
        included in the s-expression.
      </p><div class="rwocode"><pre><code># sexp_of_http_server_config <span class="keyword2">{</span> cfg <span class="keyword1">with</span> port <span class="keyword2">=</span> <span class="keyword8">8080</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((web_root /var/www/html) (port 8080))
</div># sexp_of_http_server_config 
  <span class="keyword2">{</span> cfg <span class="keyword1">with</span> port <span class="keyword2">=</span> <span class="keyword8">8080</span><span class="keyword2">;</span> addr <span class="keyword2">=</span> <span class="keyword7">&quot;192.168.0.1&quot;</span> <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : Sexp.t = ((web_root /var/www/html) (port 8080) (addr 192.168.0.1))
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/sexpr/sexp_default.topscript">sexpr/sexp_default.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp10670240">
        This can be very useful in designing config file formats that
        are both reasonably terse and easy to generate and maintain. It
        can also be useful for backwards compatibility: if you add a new
        field to your config record, but you make that field optional,
        then you should still be able to parse older version of your
        config.
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="parsing-with-ocamllex-and-menhir.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="concurrent-programming-with-async.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>