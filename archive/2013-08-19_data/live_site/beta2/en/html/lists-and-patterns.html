<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 3. Lists and Patterns / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta2',
                        page: 'lists\u002Dand\u002Dpatterns.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html" class="here">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">4. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">10. First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="objects.html">11. Objects</a>
                                            </li>
                                        
                                            <li>
                                                <a href="classes.html">12. Classes</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 3. Lists and Patterns</h1>
                
                

    <p id="idp7420160">
    This chapter will focus on two common elements of programming in
    OCaml: lists and pattern matching. Both of these were discussed in
    <a href="a-guided-tour.html">Chapter 1, <i>A Guided Tour</i></a>, but we'll go into more
    depth here, presenting the two topics together and using one to help
    illustrate the other.
  </p><section><h1 id="list-basics">List basics</h1><p id="idp7422224">
      An OCaml list is an immutable, finite sequence of elements of the
      same type. As we've seen, OCaml lists can be generated using a
      bracket-and-semicolon notation:
    </p><div class="rwocode"><pre><code># <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7423520">
      And they can also be generated using the equivalent
      <code>::</code> notation.
    </p><div class="rwocode"><pre><code># <span class="keyword8">1</span> <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">(</span><span class="keyword8">2</span> <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">(</span><span class="keyword8">3</span> <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">[</span><span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7425312">
      As you can see, the <code>::</code> operator is
      right-associative, which means that we can build up lists without
      parentheses. The empty list <code>[]</code> is used to
      terminate a list. Note that the empty list is polymorphic, meaning
      it can be used with elements of any type.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> empty <span class="keyword2">=</span> <span class="keyword2">[</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val empty : 'a list = []
</div># <span class="keyword8">3</span> <span class="keyword2">:</span><span class="keyword2">:</span> empty<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [3]
</div># <span class="keyword7">&quot;three&quot;</span> <span class="keyword2">:</span><span class="keyword2">:</span> empty<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string list = [&quot;three&quot;]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7427936">
      The <code>::</code> operator conveys something important
      about the nature of lists, which is that they are implemented as
      singly-linked lists. The following is a rough graphical
      representation of how the list
      <code>1 :: 2 :: 3 :: []</code> is laid out as a
      data-structure. The final arrow (from the box containing
      <code>3</code>) points to the empty list.
    </p><div class="rwocode"><pre><code><pre>+---+---+   +---+---+   +---+---+
| 1 | *----&gt;| 2 | *----&gt;| 3 | *----&gt;||
+---+---+   +---+---+   +---+---+
</pre></code></pre><div class="rwocodeinfo">Ascii Art ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/lists_layout.ascii">lists-and-patterns/lists_layout.ascii</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7431216">
      Each <code>::</code> essentially adds a new block to the
      picture above. Such a block contains two things: a reference to
      the data in that list element, and a reference to the remainder of
      the list. This is why <code>::</code> can extend a list
      without modifying it; extension allocates a new list element but
      doesn't need to change any of the existing ones, as you can see:
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> l <span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword8">2</span> <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword8">3</span> <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">[</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val l : int list = [1; 2; 3]
</div># <span class="keyword4">let</span> m <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword2">:</span><span class="keyword2">:</span> l<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val m : int list = [0; 1; 2; 3]
</div># l<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="using-patterns-to-extract-data-from-a-list">Using patterns to extract data from a list</h1><p id="idp7434960">
      We can read data out of a list using a match statement. Here's a
      simple example of a recursive function that computes the sum of
      all elements of a list.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> sum l <span class="keyword2">=</span>
    <span class="keyword1">match</span> l <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> hd <span class="keyword2">+</span> sum tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sum : int list -&gt; int = &lt;fun&gt;
</div># sum <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span>  
sum <span class="keyword2">[</span><span class="keyword2">]</span>
<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 6
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7436240">
      This code follows the convention of using <code>hd</code> to
      represent the first element (or head) of the list, and
      <code>tl</code> to represent the remainder (or tail).
    </p><p id="idp7437952">
      The match statement in <code>sum</code> is really doing two
      things: first, it's acting as a case-analysis tool, breaking down
      the possibilities into a pattern-indexed list of cases. Second, it
      lets you name sub-structures within the data-structure being
      matched. In this case, the variables <code>hd</code> and
      <code>tl</code> are bound by the pattern that defines the
      first case of the match statement. Variables that are bound in
      this way can be used in the expression to the right of the arrow
      for the pattern in question.
    </p><p id="idp7440736">
      The fact that match statements can be used to bind new variables
      can be a source of confusion. To see how, imagine we wanted to
      write a function that filtered out from a list all elements equal
      to a particular value. You might be tempted to write that code as
      follows, but when you do, the compiler will immediately warn you
      that something is wrong.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> drop_value l to_drop <span class="keyword2">=</span>
    <span class="keyword1">match</span> l <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
    <span class="keyword2">|</span> to_drop <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> drop_value tl to_drop
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> drop_value tl to_drop
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>Characters 114-122:
Warning 11: this match case is unused.
val drop_value : 'a list -&gt; 'a -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7442224">
      Moreover, the function clearly does the wrong thing, filtering out
      all elements of the list rather than just those equal to the
      provided value, as you can see below.
    </p><div class="rwocode"><pre><code># drop_value <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span> <span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = []
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7443520">
      So, what's going on?
    </p><p id="idp7443904">
      The key observation is that the appearance of
      <code>to_drop</code> in the second case doesn't imply a
      check that the first element is equal to the value
      <code>to_drop</code> passed in as an argument to
      <code>drop_value</code>. Instead, it just causes a new
      variable <code>to_drop</code> to be bound to whatever
      happens to be in the first element of the list, shadowing the
      earlier definition of <code>to_drop</code>. The third case
      is unused because it is essentially the same pattern as we had in
      the second case.
    </p><p id="idp7447872">
      A better way to write this code is not to use pattern matching for
      determining whether the first element is equal to
      <code>to_drop</code>, but to instead use an ordinary
      if-statement.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> drop_value l to_drop <span class="keyword2">=</span>
    <span class="keyword1">match</span> l <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span>
      <span class="keyword4">let</span> new_tl <span class="keyword2">=</span> drop_value tl to_drop <span class="keyword4">in</span>
      <span class="keyword1">if</span> hd <span class="keyword2">=</span> to_drop <span class="keyword1">then</span> new_tl <span class="keyword1">else</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> new_tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val drop_value : 'a list -&gt; 'a -&gt; 'a list = &lt;fun&gt;
</div># drop_value <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span> <span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 3]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7449824">
      Note that if we wanted to drop a particular literal value (rather
      than a value that was passed in), we could do this using something
      like our original implementation of <code>drop_value</code>.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> drop_zero l <span class="keyword2">=</span>
    <span class="keyword1">match</span> l <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
    <span class="keyword2">|</span> <span class="keyword8">0</span>  <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> drop_zero tl
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> drop_zero tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val drop_zero : int list -&gt; int list = &lt;fun&gt;
</div># drop_zero <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">0</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="limitations-and-blessings-of-pattern-matching">Limitations (and blessings) of pattern matching</h1><p id="idp7452752">
      The above example highlights an important fact about patterns,
      which is that they can't be used to express arbitrary conditions.
      Patterns can characterize the layout of a data-structure, and can
      even include literals as in the <code>drop_zero</code>
      example, but that's where they stop. A pattern can check if a list
      has two elements, but it can't check if the first two elements are
      equal to each other.
    </p><p id="idp7454224">
      You can think of patterns as a specialized sub-language that can
      express a limited (though still quite rich) set of conditions. The
      fact that the pattern language is limited turns out to be a very
      good thing, making it possible to build better support for
      patterns in the compiler. In particular, both the efficiency of
      match statements and the ability of the compiler to detect errors
      in matches depend on the constrained nature of patterns.
    </p><section><h1 id="performance">Performance</h1><p id="idp7456000">
        Naively, you might think that it would be necessary to check
        each case in a <code>match</code> in sequence to figure
        out which one fires. If the cases of a match were guarded by
        arbitrary code, that would be the case. But OCaml is often able
        to generate machine code that jumps directly to the matched case
        based on an efficiently chosen set of runtime checks.
      </p><p id="idp7457440">
        As an example, consider the following rather silly functions for
        incrementing an integer by one. The first is implemented with a
        match statement, and the second with a sequence of if
        statements.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> plus_one_match x <span class="keyword2">=</span>
    <span class="keyword1">match</span> x <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword8">0</span> -<span class="keyword2">&gt;</span> <span class="keyword8">1</span>
    <span class="keyword2">|</span> <span class="keyword8">1</span> -<span class="keyword2">&gt;</span> <span class="keyword8">2</span>
    <span class="keyword2">|</span> <span class="keyword8">2</span> -<span class="keyword2">&gt;</span> <span class="keyword8">3</span>
    <span class="keyword2">|</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> x <span class="keyword2">+</span> <span class="keyword8">1</span>

  <span class="keyword4">let</span> plus_one_if x <span class="keyword2">=</span>
    <span class="keyword1">if</span>      x <span class="keyword2">=</span> <span class="keyword8">0</span> <span class="keyword1">then</span> <span class="keyword8">1</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> x <span class="keyword2">=</span> <span class="keyword8">1</span> <span class="keyword1">then</span> <span class="keyword8">2</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> x <span class="keyword2">=</span> <span class="keyword8">2</span> <span class="keyword1">then</span> <span class="keyword8">3</span>
    <span class="keyword1">else</span> x <span class="keyword2">+</span> <span class="keyword8">1</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val plus_one_match : int -&gt; int = &lt;fun&gt;
val plus_one_if : int -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7458784">
        Note the use of <code>_</code> in the above match. This is
        a wild-card pattern that matches any value, but without binding
        a variable name to the value in question.
      </p><p id="idp7459968">
        If you benchmark these functions, you'll see that
        <code>plus_one_if</code> is considerably slower than
        <code>plus_one_match</code>, and the advantage gets larger
        as the number of cases increases. Here, we'll benchmark these
        functions using the <code>core_bench</code> library, which
        can be installed by running
        <code>opam install core_bench</code> from the
        command-line.
      </p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;core_bench&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>/home/rwo/.opam/4.01.0dev+trunk/lib/textutils: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/textutils/textutils.cma: loaded
/home/rwo/.opam/4.01.0dev+trunk/lib/core_bench: added to search path
/home/rwo/.opam/4.01.0dev+trunk/lib/core_bench/core_bench.cma: loaded
 </div># <span class="keyword1">open</span> <span class="keyword5">Core_bench.</span>Std<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword2">[</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create ~name<span class="keyword2">:</span><span class="keyword7">&quot;plus_one_match&quot;</span> <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      ignore <span class="keyword2">(</span>plus_one_match <span class="keyword8">10</span><span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">;</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create ~name<span class="keyword2">:</span><span class="keyword7">&quot;plus_one_if&quot;</span> <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      ignore <span class="keyword2">(</span>plus_one_if <span class="keyword8">10</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">]</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span>bench
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>Estimated testing time 20s (change using -quota SECS).
┌────────────────┬───────────┬──────────┐
│ Name           │ Time (ns) │ % of max │
├────────────────┼───────────┼──────────┤
│ plus_one_match │     46.81 │    68.20 │
│ plus_one_if    │     68.64 │   100.00 │
└────────────────┴───────────┴──────────┘
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 10) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7463856">
        Here's another less artificial example. We can rewrite the
        <code>sum</code> function we described earlier in the
        chapter using an <code>if</code> statement rather than a
        match. We can then use the functions
        <code>is_empty</code>, <code>hd_exn</code> and
        <code>tl_exn</code> from the <code>List</code>
        module to deconstruct the list, allowing us to implement the
        entire function without pattern matching.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> sum_if l <span class="keyword2">=</span>
    <span class="keyword1">if</span> <span class="keyword5">List.</span>is_empty l <span class="keyword1">then</span> <span class="keyword8">0</span>
    <span class="keyword1">else</span> <span class="keyword5">List.</span>hd_exn l <span class="keyword2">+</span> sum_if <span class="keyword2">(</span><span class="keyword5">List.</span>tl_exn l<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val sum_if : int list -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 11) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7469104">
        Again, we can benchmark these to see the difference.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> numbers <span class="keyword2">=</span> <span class="keyword5">List.</span>range <span class="keyword8">0</span> <span class="keyword8">1000</span> <span class="keyword4">in</span>
  <span class="keyword2">[</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create ~name<span class="keyword2">:</span><span class="keyword7">&quot;sum_if&quot;</span> <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> ignore <span class="keyword2">(</span>sum_if numbers<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">;</span> <span class="keyword5">Bench.</span><span class="keyword5">Test.</span>create ~name<span class="keyword2">:</span><span class="keyword7">&quot;sum&quot;</span>    <span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword2">(</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> ignore <span class="keyword2">(</span>sum numbers<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">]</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Bench.</span>bench
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>Estimated testing time 20s (change using -quota SECS).
┌────────┬───────────┬──────────┐
│ Name   │ Time (ns) │ % of max │
├────────┼───────────┼──────────┤
│ sum_if │   110_524 │   100.00 │
│ sum    │    22_358 │    20.23 │
└────────┴───────────┴──────────┘
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 12) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7470272">
        In this case, the <code>match</code>-based implementation
        is more than three times faster than the one using
        <code>if</code>. The difference comes because we need to
        effectively do the same work multiple times, since each function
        we call has to re-examine the first element of the list to
        determine whether or not it's the empty cell. With a match
        statement, this work happens exactly once per list element.
      </p><p id="idp7472352">
        Generally, pattern matching is more efficient than the
        alternatives you might code by hand. One notable exception is
        matches over strings, which are in fact tested sequentially, so
        matches containing a long sequence of strings can be
        outperformed by a hash table. But most of the time, pattern
        matching is a clear performance win.
      </p></section><section><h1 id="detecting-errors">Detecting errors</h1><p id="idp7474144">
        The error-detecting capabilities of match statements are if
        anything more important than their performance. We've already
        seen one example of OCaml's ability to find problems in a
        pattern match: in our broken implementation of
        <code>drop_value</code>, OCaml warned us that the final
        case was redundant. There are no algorithms for determining if a
        predicate written in a general-purpose language is redundant,
        but it can be solved reliably in the context of patterns.
      </p><p id="idp7475712">
        OCaml also checks match statements for exhaustiveness. Consider
        what happens if we modify <code>drop_zero</code> by
        deleting the handler for one of the cases. As you can see, the
        compiler will produce a warning that we've missed a case, along
        with an example of an unmatched pattern.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> drop_zero l <span class="keyword2">=</span>
    <span class="keyword1">match</span> l <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
    <span class="keyword2">|</span> <span class="keyword8">0</span>  <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> drop_zero tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>Characters 26-84:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
1::_
val drop_zero : int list -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 13) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7477776">
        For simple examples like this, exhaustiveness checks are useful
        enough. But as we'll see in
        <a href="variants.html">Chapter 6, <i>Variants</i></a>, as you get to more
        complicated examples, especially those involving user-defined
        types, exhaustiveness checks become a lot more valuable. In
        addition to catching outright errors, they act as a sort of
        refactoring tool, guiding you to the locations where you need to
        adapt your code to deal with changing types.
      </p></section></section><section><h1 id="using-the-list-module-effectively">Using the <code>List</code> module effectively</h1><p id="idp7480912">
      We've so far written a fair amount of list-munging code using
      pattern matching and recursive functions. But in real life, you're
      usually better off using the <code>List</code> module, which
      is full of reusable functions that abstract out common patterns
      for computing with lists.
    </p><p id="idp7482256">
      Let's work through a concrete example to see this in action. We'll
      write a function <code>render_table</code> that, given a
      list of column headers and a list of rows, prints them out in a
      well formatted text table, as follows.
    </p><div class="rwocode"><pre><code># printf <span class="keyword7">&quot;%s\n&quot;</span>
   <span class="keyword2">(</span>render_table
     <span class="keyword2">[</span><span class="keyword7">&quot;language&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;architect&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;first release&quot;</span><span class="keyword2">]</span>
     <span class="keyword2">[</span> <span class="keyword2">[</span><span class="keyword7">&quot;Lisp&quot;</span> <span class="keyword2">;</span><span class="keyword7">&quot;John McCarthy&quot;</span> <span class="keyword2">;</span><span class="keyword7">&quot;1958&quot;</span><span class="keyword2">]</span> <span class="keyword2">;</span>
       <span class="keyword2">[</span><span class="keyword7">&quot;C&quot;</span>    <span class="keyword2">;</span><span class="keyword7">&quot;Dennis Ritchie&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;1969&quot;</span><span class="keyword2">]</span> <span class="keyword2">;</span>
       <span class="keyword2">[</span><span class="keyword7">&quot;ML&quot;</span>   <span class="keyword2">;</span><span class="keyword7">&quot;Robin Milner&quot;</span>  <span class="keyword2">;</span><span class="keyword7">&quot;1973&quot;</span><span class="keyword2">]</span> <span class="keyword2">;</span>
       <span class="keyword2">[</span><span class="keyword7">&quot;OCaml&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;Xavier Leroy&quot;</span>  <span class="keyword2">;</span><span class="keyword7">&quot;1996&quot;</span><span class="keyword2">]</span> <span class="keyword2">;</span>
     <span class="keyword2">]</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |
- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 69) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7484224">
      The first step is to write a function to compute the maximum width
      of each column of data. We can do this by converting the header
      and each row into a list of integer lengths, and then taking the
      element-wise max of those lists of lengths. Writing the code for
      all of this directly would be a bit of a chore, but we can do it
      quite concisely by making use of three functions from the
      <code>List</code> module: <code>map</code>,
      <code>map2_exn</code>, and <code>fold</code>.
    </p><p id="idp7487552">
<code>List.map</code> is the simplest to explain. It takes a
      list and a function for transforming elements of that list, and
      returns a new list with the transformed elements. Thus, we can
      write:
    </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span><span class="keyword5">String.</span>length <span class="keyword2">[</span><span class="keyword7">&quot;Hello&quot;</span><span class="keyword2">;</span> <span class="keyword7">&quot;World!&quot;</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [5; 6]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 14) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7489472">
<code>List.map2_exn</code> is similar to
      <code>List.map</code>, except that it takes two lists and a
      function for combining them. Thus, we might write:
    </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>map2_exn ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>max <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span> <span class="keyword2">[</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">1</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [3; 2; 3]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 15) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7491920">
      The <code>_exn</code> is there because the function throws
      an exception if the lists are of mismatched length.
    </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>map2_exn ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>max <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span> <span class="keyword2">[</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">0</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception: (Invalid_argument &quot;length mismatch in rev_map2_exn: 3 &lt;&gt; 4 &quot;).
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 16) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7493744">
<code>List.fold</code> is the most complicated of the three,
      taking three arguments: a list to process, an initial accumulator
      value, and a function for updating the accumulator with the
      information from a list element. <code>List.fold</code>
      walks over the list from left to right, updating the accumulator
      at each step and returning the final value of the accumulator when
      it's done. You can see some of this by looking at the
      type-signature for <code>fold</code>.
    </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>fold<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a list -&gt; init:'accum -&gt; f:('accum -&gt; 'a -&gt; 'accum) -&gt; 'accum = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 17) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7497184">
      We can use <code>List.fold</code> for something as simple as
      summing up a list:
    </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>fold ~init<span class="keyword2">:</span><span class="keyword8">0</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword2">+</span><span class="keyword2">)</span> <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 10
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 18) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7498976">
      This example is particularly simple because the accumulator and
      the list elements are of the same type. But
      <code>fold</code> is not limited to such cases. We can for
      example use <code>fold</code> to reverse a list, in which
      case the accumulator is itself a list.
    </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>fold ~init<span class="keyword2">:</span><span class="keyword2">[</span><span class="keyword2">]</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> <span class="keyword3">list</span> x -<span class="keyword2">&gt;</span> x <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword3">list</span><span class="keyword2">)</span> <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [4; 3; 2; 1]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 19) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7501632">
      Let's bring our three functions together to compute the maximum
      column widths.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> max_widths header rows <span class="keyword2">=</span>
    <span class="keyword4">let</span> lengths l <span class="keyword2">=</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span><span class="keyword5">String.</span>length l <span class="keyword4">in</span>
    <span class="keyword5">List.</span>fold rows
      ~init<span class="keyword2">:</span><span class="keyword2">(</span>lengths header<span class="keyword2">)</span>
      ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> acc row -<span class="keyword2">&gt;</span>
        <span class="keyword5">List.</span>map2_exn ~f<span class="keyword2">:</span><span class="keyword5">Int.</span>max acc <span class="keyword2">(</span>lengths row<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val max_widths : string list -&gt; string list list -&gt; int list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 20) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7502832">
      Using <code>List.map</code> we define the function
      <code>lengths</code> which converts a list of strings to a
      list of integer lengths. <code>List.fold</code> is then used
      to iterate over the rows, using <code>map2_exn</code> to
      take the max of the accumulator with the lengths of the strings in
      each row of the table, with the accumulator initialized to the
      lengths of the header row.
    </p><p id="idp7505984">
      Now that we know how to compute column widths, we can write the
      code to generate the line that separates the header from the rest
      of the text table. We'll do this in part by mapping
      <code>String.make</code> over the lengths of the columns to
      generate a string of dashes of the appropriate length. We'll then
      join these sequences of dashes together using
      <code>String.concat</code>, which concatenates a list of
      strings with an optional separator string, and
      <code>^</code>, which is a pairwise string concatenation
      function, to add the delimiters on the outside.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> render_separator widths <span class="keyword2">=</span>
    <span class="keyword4">let</span> pieces <span class="keyword2">=</span> <span class="keyword5">List.</span>map widths
      ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> w -<span class="keyword2">&gt;</span> <span class="keyword5">String.</span>make <span class="keyword2">(</span>w <span class="keyword2">+</span> <span class="keyword8">2</span><span class="keyword2">)</span> '-'<span class="keyword2">)</span>
    <span class="keyword4">in</span>
    <span class="keyword7">&quot;|&quot;</span> <span class="keyword2">^</span> <span class="keyword5">String.</span>concat ~sep<span class="keyword2">:</span><span class="keyword7">&quot;+&quot;</span> pieces <span class="keyword2">^</span> <span class="keyword7">&quot;|&quot;</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val render_separator : int list -&gt; string = &lt;fun&gt;
</div># render_separator <span class="keyword2">[</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">6</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;|-----+--------+----|&quot;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 21) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7509568">
      Note that we make the line of dashes two larger than the provided
      width to provide some whitespace around each entry in the table.
    </p><aside class="note"><h1>
    Performance of String.concat and
    ^
</h1><p id="idp7512000">
      In the above, we're using two different ways of concatenating
      strings, <code>String.concat</code>, which operates on lists
      of strings, and <code>^</code>, which is a pairwise
      operator. You should avoid <code>^</code> for joining long
      numbers of strings, since, it allocates a new string every time it
      runs. Thus, the following code:
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> s <span class="keyword2">=</span> <span class="keyword7">&quot;.&quot;</span> <span class="keyword2">^</span> <span class="keyword7">&quot;.&quot;</span>  <span class="keyword2">^</span> <span class="keyword7">&quot;.&quot;</span>  <span class="keyword2">^</span> <span class="keyword7">&quot;.&quot;</span>  <span class="keyword2">^</span> <span class="keyword7">&quot;.&quot;</span>  <span class="keyword2">^</span> <span class="keyword7">&quot;.&quot;</span>  <span class="keyword2">^</span> <span class="keyword7">&quot;.&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val s : string = &quot;.......&quot;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 22) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7515200">
      will allocate strings of length 2, 3, 4, 5, 6 and 7, whereas this
      code:
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> s <span class="keyword2">=</span> <span class="keyword5">String.</span>concat <span class="keyword2">[</span><span class="keyword7">&quot;.&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;.&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;.&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;.&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;.&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;.&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;.&quot;</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val s : string = &quot;.......&quot;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 23) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7516400">
      allocates one string of size 7, as well as a list of length 7. At
      these small sizes, the differences don't amount to much, but for
      assembling of large strings, it can be a serious performance
      issue.
    </p></aside><p id="idp7517152">
      Now we need code for rendering a row with data in it. We'll first
      write a function <code>pad</code> for padding out a string
      to a specified length plus one blank space on either side.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> pad s length <span class="keyword2">=</span>
    <span class="keyword7">&quot; &quot;</span> <span class="keyword2">^</span> s <span class="keyword2">^</span> <span class="keyword5">String.</span>make <span class="keyword2">(</span>length - <span class="keyword5">String.</span>length s <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span> ' '
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val pad : string -&gt; int -&gt; string = &lt;fun&gt;
</div># pad <span class="keyword7">&quot;hello&quot;</span> <span class="keyword8">10</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot; hello      &quot;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 24) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7519088">
      We can render a row of data by merging together the padded
      strings. Again, we'll use <code>List.map2_exn</code> for
      combining the list of data in the row with the list of widths.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> render_row row widths <span class="keyword2">=</span>
    <span class="keyword4">let</span> padded <span class="keyword2">=</span> <span class="keyword5">List.</span>map2_exn row widths ~f<span class="keyword2">:</span>pad <span class="keyword4">in</span>
    <span class="keyword7">&quot;|&quot;</span> <span class="keyword2">^</span> <span class="keyword5">String.</span>concat ~sep<span class="keyword2">:</span><span class="keyword7">&quot;|&quot;</span> padded <span class="keyword2">^</span> <span class="keyword7">&quot;|&quot;</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val render_row : string list -&gt; int list -&gt; string = &lt;fun&gt;
</div># render_row <span class="keyword2">[</span><span class="keyword7">&quot;Hello&quot;</span><span class="keyword2">;</span><span class="keyword7">&quot;World&quot;</span><span class="keyword2">]</span> <span class="keyword2">[</span><span class="keyword8">10</span><span class="keyword2">;</span><span class="keyword8">15</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;| Hello      | World           |&quot;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 25) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7521008">
      Now we can bring this all together in a single function that
      renders the table.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> render_table header rows <span class="keyword2">=</span>
    <span class="keyword4">let</span> widths <span class="keyword2">=</span> max_widths header rows <span class="keyword4">in</span>
    <span class="keyword5">String.</span>concat ~sep<span class="keyword2">:</span><span class="keyword7">&quot;\n&quot;</span>
      <span class="keyword2">(</span>render_row header widths
       <span class="keyword2">:</span><span class="keyword2">:</span> render_separator widths
       <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword5">List.</span>map rows ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> row -<span class="keyword2">&gt;</span> render_row row widths<span class="keyword2">)</span>
      <span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val render_table : string list -&gt; string list list -&gt; string = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 26) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1 id="more-useful-list-functions">More useful list functions</h1><p id="idp7523088">
        The example we worked through above only touched on three of the
        function in <code>List</code>. We won't cover the entire
        interface, but there are a few more functions that are useful
        enough to mention here.
      </p><section><h1 id="combining-list-elements-with-list.reduce">Combining list elements with
        <code>List.reduce</code></h1><p id="idp7525744">
<code>List.fold</code>, which we described earlier, is a
          very general and powerful function. Sometimes, however, you
          want something more that's simpler and thereby easier to use.
          One such function is <code>List.reduce</code>, which is
          essentially a specialized version of
          <code>List.fold</code> that doesn't require an explicit
          starting value, and whose accumulator has to consume and
          produce values of the same type as the elements of the list it
          applies to.
        </p><p id="idp7528528">
          Here's the type signature:
        </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>reduce<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a list -&gt; f:('a -&gt; 'a -&gt; 'a) -&gt; 'a option = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 27) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7529616">
<code>reduce</code> returns an optional result,
          returning <code>None</code> when the input list is
          empty.
        </p><p id="idp7531248">
          Now we can see reduce in action.
        </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>reduce ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword2">+</span><span class="keyword2">)</span> <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int option = Some 15
</div># <span class="keyword5">List.</span>reduce ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword2">+</span><span class="keyword2">)</span> <span class="keyword2">[</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int option = None
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 28) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="filtering-with-list.filter-and-list.filter_map">Filtering with <code>List.filter</code> and
        <code>List.filter_map</code></h1><p id="idp7534464">
          Very often when processing lists, one wants to restrict
          attention to just a subset of values. The
          <code>List.filter</code> function does just that.
        </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>filter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> x <span class="keyword2">mod</span> <span class="keyword8">2</span> <span class="keyword2">=</span> <span class="keyword8">0</span><span class="keyword2">)</span> <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [2; 4]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 29) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7536320">
          Note that the <code>mod</code> used above is an infix
          operator, as described in
          <a href="variables-and-functions.html">Chapter 2, <i>Variables and Functions</i></a>.
        </p><p id="idp7537904">
          Sometimes, you want to both transform and filter as part of
          the same computation. <code>List.filter_map</code>
          allows you to do just that. The function passed to
          <code>List.filter_map</code> returns an optional value,
          and <code>List.filter_map</code> drops all elements for
          which <code>None</code> is returned.
        </p><p id="idp7540992">
          Here's an example. The following expression computes the list
          of file extensions in the current directory, piping the
          results through <code>List.dedup</code> to remove
          duplicates. Note that this example also uses some functions
          from other modules, including <code>Sys.ls_dir</code> to
          get a directory listing, and <code>String.rsplit2</code>
          to split a string on the rightmost appearance of a given
          character.
        </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>filter_map <span class="keyword2">(</span><span class="keyword5">Sys.</span>ls_dir <span class="keyword7">&quot;.&quot;</span><span class="keyword2">)</span> ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> fname -<span class="keyword2">&gt;</span>
    <span class="keyword1">match</span> <span class="keyword5">String.</span>rsplit2 ~on<span class="keyword2">:</span>'.' fname <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span> <span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword7">&quot;&quot;</span>,<span class="keyword8">_</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword6">None
</span>    <span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword8">_</span>,ext<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword6">Some </span>ext<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>dedup
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string list = [&quot;ascii&quot;; &quot;ml&quot;; &quot;mli&quot;; &quot;topscript&quot;]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 30) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7544384">
          The above is also an example of an or-patterns, which allows
          you to have multiple sub-patterns within a larger pattern. In
          this case, <code>None | Some (&quot;&quot;,_)</code> is
          an or-pattern. As we'll see later, or-patterns can be nested
          anywhere within larger patterns.
        </p></section><section><h1 id="partitioning-with-list.partition_tf">Partitioning with
        <code>List.partition_tf</code></h1><p id="idp7547216">
          Another function that is similar to <code>filter</code>
          is <code>partition_tf</code>, which takes a list and
          partitions it into a pair of lists based on a boolean
          condition. <code>tf</code> is a mnemonic to remind the
          reader that <code>true</code> elements go to the first
          bucket and <code>false</code> ones go to the second.
          Thus, one could write:
        </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> is_ocaml_source s <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword5">String.</span>rsplit2 s ~on<span class="keyword2">:</span>'.' <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword2">(</span><span class="keyword8">_</span>,<span class="keyword2">(</span><span class="keyword7">&quot;ml&quot;</span><span class="keyword2">|</span><span class="keyword7">&quot;mli&quot;</span><span class="keyword2">)</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> true
    <span class="keyword2">|</span> <span class="keyword8">_</span> -<span class="keyword2">&gt;</span> false
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val is_ocaml_source : string -&gt; bool = &lt;fun&gt;
</div># <span class="keyword4">let</span> <span class="keyword2">(</span>ml_files,other_files<span class="keyword2">)</span> <span class="keyword2">=</span>
    <span class="keyword5">List.</span>partition_tf <span class="keyword2">(</span><span class="keyword5">Sys.</span>ls_dir <span class="keyword7">&quot;.&quot;</span><span class="keyword2">)</span>  ~f<span class="keyword2">:</span>is_ocaml_source<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ml_files : string list = [&quot;example.mli&quot;; &quot;example.ml&quot;]
val other_files : string list = [&quot;main.topscript&quot;; &quot;lists_layout.ascii&quot;]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 31) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7551632">
          Note the use of a nested or-pattern in
          <code>is_ocaml_source</code>.
        </p></section><section><h1 id="combining-lists">Combining lists</h1><p id="idp7553728">
          Another very common operation on lists is concatenation. The
          list module actually comes with a few different ways of doing
          this. First, there's <code>List.append</code>, for
          concatenating a pair of lists.
        </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>append <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span> <span class="keyword2">[</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">;</span><span class="keyword8">6</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3; 4; 5; 6]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 32) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7555632">
          There's also <code>@</code>, an operator equivalent of
          <code>List.append</code>.
        </p><div class="rwocode"><pre><code># <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span> <span class="keyword2">@</span> <span class="keyword2">[</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">;</span><span class="keyword8">6</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3; 4; 5; 6]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 33) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7557968">
          In addition, there is <code>List.concat</code>, for
          concatenating a list of lists.
        </p><div class="rwocode"><pre><code># <span class="keyword5">List.</span>concat <span class="keyword2">[</span><span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">[</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">[</span><span class="keyword8">6</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">[</span><span class="keyword2">]</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int list = [1; 2; 3; 4; 5; 6]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 34) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7559680">
          Here's an example of using <code>List.concat</code>
          along with <code>List.map</code> to compute a recursive
          listing of a directory tree.
        </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> ls_rec s <span class="keyword2">=</span>
    <span class="keyword1">if</span> <span class="keyword5">Sys.</span>is_file_exn ~follow_symlinks<span class="keyword2">:</span>true s
    <span class="keyword1">then</span> <span class="keyword2">[</span>s<span class="keyword2">]</span>
    <span class="keyword1">else</span>
      <span class="keyword5">Sys.</span>ls_dir s
      <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> sub -<span class="keyword2">&gt;</span> ls_rec <span class="keyword2">(</span>s <span class="keyword2">^</span> <span class="keyword7">&quot;/&quot;</span> <span class="keyword2">^</span> sub<span class="keyword2">)</span><span class="keyword2">)</span>
      <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>concat
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ls_rec : string -&gt; string list = &lt;fun&gt;
</div># ls_rec <span class="keyword7">&quot;.&quot;</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string list =
[&quot;./main.topscript&quot;; &quot;./example.mli&quot;; &quot;./example.ml&quot;; &quot;./lists_layout.ascii&quot;]
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 35) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7562096">
          The above combination of <code>List.map</code> and
          <code>List.concat</code> is common enough that there is
          a function <code>List.concat_map</code> that combines
          these into one, more efficient operation.
        </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> ls_rec s <span class="keyword2">=</span>
    <span class="keyword1">if</span> <span class="keyword5">Sys.</span>is_file_exn ~follow_symlinks<span class="keyword2">:</span>true s
    <span class="keyword1">then</span> <span class="keyword2">[</span>s<span class="keyword2">]</span>
    <span class="keyword1">else</span>
      <span class="keyword5">Sys.</span>ls_dir s
      <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>concat_map ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> sub -<span class="keyword2">&gt;</span> ls_rec <span class="keyword2">(</span>s <span class="keyword2">^</span>/ sub<span class="keyword2">)</span><span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ls_rec : string -&gt; string list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 36) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7565152">
          Note that <code>^/</code> is an infix operator provided
          by Core for adding a new element to a string representing a
          file path. It is equivalent to Core's
          <code>Filename.concat</code>.
        </p></section></section></section><section><h1 id="tail-recursion">Tail recursion</h1><p id="idp7568224">
      The only way to compute the length of an OCaml list is to walk the
      list from beginning to end. As a result, computing the length of a
      list takes time linear in the size of the list. Here's a simple
      function for doing so.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> length <span class="keyword2">=</span> <span class="keyword1">function</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> <span class="keyword8">_</span> <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> <span class="keyword8">1</span> <span class="keyword2">+</span> length tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val length : 'a list -&gt; int = &lt;fun&gt;
</div># length <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 3
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 37) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7569584">
      This looks simple enough, but you'll discover that this
      implementation runs into problems on very large lists. Here are
      some examples, using another useful function from the
      <code>List</code> module, <code>List.init</code>, to
      create the lists. <code>List.init</code> takes an integer
      <code>n</code> and a function <code>f</code> and
      creates a list of length <code>n</code> where the data for
      each element is created by calling <code>f</code> on the
      index of that element.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> make_list n <span class="keyword2">=</span> <span class="keyword5">List.</span>init n ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> x<span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val make_list : int -&gt; int list = &lt;fun&gt;
</div># make_list <span class="keyword8">10</span><span class="keyword2">;</span>
length <span class="keyword2">(</span>make_list <span class="keyword8">10_000_000</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>Characters -1-12:
Warning 10: this expression should have type unit.
Characters -1-12:
Warning 10: this expression should have type unit.
Stack overflow during evaluation (looping recursion?).
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 38) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7575328">
      To understand what went wrong, you need to learn a bit more about
      how function calls work. Typically, a function call needs some
      space to keep track of information associated with the call, such
      as the arguments passed to the function, or the location of the
      code that needs to start executing when the function call is
      complete. To allow for nested function calls, this information is
      typically organized in a stack, where a new <span><em>stack
      frame</em></span> is allocated for each nested function call, and
      then deallocated when the function call is complete.
    </p><p id="idp7576720">
      And that's the problem with our call to <code>length</code>:
      it tried to allocate ten million stack frames, which exhausted the
      available stack space. Happily, there's a way around this problem.
      Consider the following alternative implementation.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> length_plus_n l n <span class="keyword2">=</span>
    <span class="keyword1">match</span> l <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> n
    <span class="keyword2">|</span> <span class="keyword8">_</span> <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> length_plus_n tl <span class="keyword2">(</span>n <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val length_plus_n : 'a list -&gt; int -&gt; int = &lt;fun&gt;
</div># <span class="keyword4">let</span> length l <span class="keyword2">=</span> length_plus_n l <span class="keyword8">0</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val length : 'a list -&gt; int = &lt;fun&gt;
</div># length <span class="keyword2">[</span><span class="keyword8">1</span><span class="keyword2">;</span><span class="keyword8">2</span><span class="keyword2">;</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 4
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 39) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7578656">
      This implementation depends on a helper function,
      <code>length_plus_n</code>, that computes the length of a
      given list plus a given <code>n</code>. In practice,
      <code>n</code> acts as an accumulator in which the answer is
      built up, step by step. As a result, we can do the additions along
      the way rather than doing them as we unwind the nested sequence of
      function calls, as we did in our first implementation of
      <code>length</code>.
    </p><p id="idp7581968">
      The advantage of this approach is that the recursive call in
      <code>length_plus_n</code> is a <span><em>tail
      call</em></span>. We'll explain more precisely what it means to be
      a tail call shortly, but the reason it's important is that tail
      calls don't require the allocation of a new stack frame, due to
      what is called the <span><em>tail-call optimization</em></span>. A
      recursive function is said to be <span><em>tail
      recursive</em></span> if all of its recursive calls are tail calls.
      <code>length_plus_n</code> is indeed tail recursive, and as
      a result, <code>length</code> can take a long list as input
      without blowing the stack.
    </p><div class="rwocode"><pre><code># length <span class="keyword2">(</span>make_list <span class="keyword8">10_000_000</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 10000000
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 40) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7586496">
      So when is a call a tail call? Let's think about the situation of
      one function (the <span><em>caller</em></span>) invokes another
      (the <span><em>callee</em></span>). The invocation is considered a
      tail call when the caller doesn't do anything with the value
      returned by the callee except to return it. The tail-call
      optimization makes sense because, when a caller makes a tail call,
      the caller's stack frame need never be used again, and so you
      don't need to keep it around. Thus, instead of allocating a new
      stack frame for the callee, the compiler is free to reuse the
      caller's stack frame.
    </p><p id="idp7588256">
      Tail recursion is important for more than just lists. Ordinary
      (non-tail) recursive calls are reasonable when dealing with
      data-structures like binary trees where the depth of the tree is
      logarithmic in the size of your data. But when dealing with
      situations where the depth of the sequence of nested calls is on
      the order of the size of your data, tail recursion is usually the
      right approach.
    </p></section><section><h1 id="more-concise-and-faster-patterns">More concise and faster patterns</h1><p id="idp7590112">
      Now that we know more about how lists and patterns work, let's
      consider how we can improve on an example from
      <a href="a-guided-tour.html#recursive-list-functions">the section called “Recursive list functions”</a>: the function
      <code>destutter</code>, which removes sequential duplicates
      from a list. Here's the implementation that was described earlier.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> destutter <span class="keyword3">list</span> <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword3">list</span> <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span><span class="keyword2">]</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span>hd<span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword2">[</span>hd<span class="keyword2">]</span>
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> hd' <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span>
      <span class="keyword1">if</span> hd <span class="keyword2">=</span> hd' <span class="keyword1">then</span> destutter <span class="keyword2">(</span>hd' <span class="keyword2">:</span><span class="keyword2">:</span> tl<span class="keyword2">)</span>
      <span class="keyword1">else</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> destutter <span class="keyword2">(</span>hd' <span class="keyword2">:</span><span class="keyword2">:</span> tl<span class="keyword2">)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 41) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7592592">
      We'll consider some ways of making this code more concise and more
      efficient.
    </p><p id="idp7593088">
      First, let's consider efficiency. One problem with the
      <code>destutter</code> code above is that it in some cases
      recreates on the right-hand side of the arrow a value that already
      existed on the left hand side. Thus, the pattern
      <code>[hd] -&gt; [hd]</code> actually allocates a new list
      element, which really, it should be able to just return the list
      being matched. We can reduce allocation here by using an
      <code>as</code> pattern, which allows us to declare a name
      for the thing matched by a pattern or sub-pattern. While we're at
      it, we'll use the <code>function</code> keyword to eliminate
      the need for an explicit match.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> destutter <span class="keyword2">=</span> <span class="keyword1">function</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> <span class="keyword1">as</span> l -<span class="keyword2">&gt;</span> l
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword8">_</span><span class="keyword2">]</span> <span class="keyword1">as</span> l -<span class="keyword2">&gt;</span> l
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">(</span>hd' <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword8">_</span> <span class="keyword1">as</span> tl<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword1">if</span> hd <span class="keyword2">=</span> hd' <span class="keyword1">then</span> destutter tl
      <span class="keyword1">else</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> destutter tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 42) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7597376">
      We can further collapse this by combining the first two cases into
      one, using an or-pattern.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> destutter <span class="keyword2">=</span> <span class="keyword1">function</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword8">_</span><span class="keyword2">]</span> <span class="keyword1">as</span> l -<span class="keyword2">&gt;</span> l
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">(</span>hd' <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword8">_</span> <span class="keyword1">as</span> tl<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
      <span class="keyword1">if</span> hd <span class="keyword2">=</span> hd' <span class="keyword1">then</span> destutter tl
      <span class="keyword1">else</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> destutter tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 43) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7598592">
      We can make the code slightly terser now by using a
      <code>when</code> clause. A <code>when</code> clause
      allows one to add an extra precondition on a pattern in the form
      of an arbitrary OCaml expression. In this case, we can use it to
      include the check on whether the first two elements are equal.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> destutter <span class="keyword2">=</span> <span class="keyword1">function</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword8">_</span><span class="keyword2">]</span> <span class="keyword1">as</span> l -<span class="keyword2">&gt;</span> l
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword2">(</span>hd' <span class="keyword2">:</span><span class="keyword2">:</span> <span class="keyword8">_</span> <span class="keyword1">as</span> tl<span class="keyword2">)</span> <span class="keyword1">when</span> hd <span class="keyword2">=</span> hd' -<span class="keyword2">&gt;</span> destutter tl
    <span class="keyword2">|</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> hd <span class="keyword2">:</span><span class="keyword2">:</span> destutter tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 44) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="note"><h1> 
    Polymorphic compare
    </h1><p id="idp7601888">
      In the <code>destutter</code> example above, we made use of
      the fact that OCaml lets us test equality between values of any
      type, using the <code>=</code> operator. Thus, we can write:
    </p><div class="rwocode"><pre><code># <span class="keyword8">3</span> <span class="keyword2">=</span> <span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = false
</div># <span class="keyword2">[</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">]</span> <span class="keyword2">=</span> <span class="keyword2">[</span><span class="keyword8">3</span><span class="keyword2">;</span><span class="keyword8">4</span><span class="keyword2">;</span><span class="keyword8">5</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = true
</div># <span class="keyword2">[</span><span class="keyword6">Some </span><span class="keyword8">3</span><span class="keyword2">;</span> None<span class="keyword2">]</span> <span class="keyword2">=</span> <span class="keyword2">[</span>None<span class="keyword2">;</span> <span class="keyword6">Some </span><span class="keyword8">3</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : bool = false
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 45) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7604368">
      Indeed, if we look at the type of the equality operator, we'll see
      that it is polymorphic:
    </p><div class="rwocode"><pre><code># <span class="keyword2">(</span><span class="keyword2">=</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 46) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7605584">
      OCaml actually comes with a whole family of polymorphic comparison
      operators, including the standard infix comparators,
      <code>&lt;</code>, <code>&gt;=</code>,
      <span><em>etc.</em></span>, as well as the function
      <code>compare</code> that returns <code>-1</code>,
      <code>0</code> or <code>1</code> to flag whether the
      first operand is smaller than, equal to, or greater than the
      second, respectively.
    </p><p id="idp7610400">
      You might wonder how you could build functions like these yourself
      if OCaml didn't come with them built-in. It turns out that you
      <span><em>can't</em></span> build these functions on your own.
      OCaml's polymorphic comparison functions are actually built-in to
      the runtime to a low level. These comparisons are polymorphic on
      the basis of ignoring almost everything about the types of the
      values that are being compared, paying attention only to the
      structure of the values as they're laid out in memory.
    </p><p id="idp7611728">
      Polymorphic compare does have some limitations. For example, it
      will fail at runtime if it encounters a function value.
    </p><div class="rwocode"><pre><code># <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> x <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword2">(</span><span class="keyword1">fun</span> x -<span class="keyword2">&gt;</span> x <span class="keyword2">+</span> <span class="keyword8">1</span><span class="keyword2">)</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Exception: (Invalid_argument &quot;equal: functional value&quot;).
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 47) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7612976">
      Similarly, it will fail on values that come from outside the OCaml
      heap, like values from C-bindings. But it will work in a
      reasonable way for other kinds of values.
    </p><p id="idp7613568">
      For simple atomic types, polymorphic compare has the semantics you
      would expect: for floating-point numbers and integer, polymorphic
      compare corresponds to the expected numerical comparison
      functions. For strings, it's a lexicographic comparison.
    </p><p id="idp7614240">
      Sometimes, however, the type-ignoring nature of polymorphic
      compare is a problem, particularly when you have your own notion
      of equality and ordering that you want to impose. We'll discuss
      this issue more, as well as some of the other downsides of
      polymorphic compare, in
      <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a>.
    </p></aside><p id="idp7615568">
      Note that <code>when</code> clauses have some downsides. As
      we noted earlier, the static checks associated with pattern
      matches rely on the fact that patterns are restricted in what they
      can express. Once we add the ability to add an arbitrary condition
      to a pattern, something will be lost. In particular, the ability
      for the compiler to determine if a match is exhaustive, or if some
      case is redundant, is compromised.
    </p><p id="idp111136">
      Consider the following function which takes a list of optional
      values, and returns the number of those values that are
      <code>Some</code>. Because this implementation uses
      <code>when</code> clauses, the compiler can't tell that the
      code is exhaustive.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> count_some <span class="keyword3">list</span> <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword3">list</span> <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> x <span class="keyword2">:</span><span class="keyword2">:</span> tl <span class="keyword1">when</span> <span class="keyword5">Option.</span>is_none x -<span class="keyword2">&gt;</span> count_some tl
    <span class="keyword2">|</span> x <span class="keyword2">:</span><span class="keyword2">:</span> tl <span class="keyword1">when</span> <span class="keyword5">Option.</span>is_some x -<span class="keyword2">&gt;</span> <span class="keyword8">1</span> <span class="keyword2">+</span> count_some tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>Characters 30-169:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_
(However, some guarded clause may match this value.)
val count_some : 'a option list -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 48) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp113856">
      Despite the warning, the function does work fine.
    </p><div class="rwocode"><pre><code># count_some <span class="keyword2">[</span><span class="keyword6">Some </span><span class="keyword8">3</span><span class="keyword2">;</span> None<span class="keyword2">;</span> <span class="keyword6">Some </span><span class="keyword8">4</span><span class="keyword2">]</span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : int = 2
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 49) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp115056">
      If we add another redundant case without a <code>when</code>
      clause, the compiler will stop complaining about exhaustiveness,
      and won't produce a warning about the redundancy.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> count_some <span class="keyword3">list</span> <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword3">list</span> <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> x <span class="keyword2">:</span><span class="keyword2">:</span> tl <span class="keyword1">when</span> <span class="keyword5">Option.</span>is_none x -<span class="keyword2">&gt;</span> count_some tl
    <span class="keyword2">|</span> x <span class="keyword2">:</span><span class="keyword2">:</span> tl <span class="keyword1">when</span> <span class="keyword5">Option.</span>is_some x -<span class="keyword2">&gt;</span> <span class="keyword8">1</span> <span class="keyword2">+</span> count_some tl
    <span class="keyword2">|</span> x <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> <span class="keyword8">-1</span> <span class="comments">(* unreachable *)</span>
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val count_some : 'a option list -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 50) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp117008">
      Probably a better approach is to simply drop the second
      <code>when</code> clause.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> count_some <span class="keyword3">list</span> <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword3">list</span> <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> x <span class="keyword2">:</span><span class="keyword2">:</span> tl <span class="keyword1">when</span> <span class="keyword5">Option.</span>is_none x -<span class="keyword2">&gt;</span> count_some tl
    <span class="keyword2">|</span> <span class="keyword8">_</span> <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> <span class="keyword8">1</span> <span class="keyword2">+</span> count_some tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val count_some : 'a option list -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 51) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp118928">
      This is a little less clear, however, than the direct pattern
      matching solution, where the meaning of each pattern is clearer on
      its own.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> <span class="keyword4">rec</span> count_some <span class="keyword3">list</span> <span class="keyword2">=</span>
    <span class="keyword1">match</span> <span class="keyword3">list</span> <span class="keyword1">with</span>
    <span class="keyword2">|</span> <span class="keyword2">[</span><span class="keyword2">]</span> -<span class="keyword2">&gt;</span> <span class="keyword8">0</span>
    <span class="keyword2">|</span> <span class="keyword6">None </span>  <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> count_some tl
    <span class="keyword2">|</span> <span class="keyword6">Some </span><span class="keyword8">_</span> <span class="keyword2">:</span><span class="keyword2">:</span> tl -<span class="keyword2">&gt;</span> <span class="keyword8">1</span> <span class="keyword2">+</span> count_some tl
  <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val count_some : 'a option list -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 52) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp7634304">
      The takeaway from all of this is that, while
      <code>when</code> clauses can be useful, one should prefer
      patterns wherever they are sufficient.
    </p><p id="idp7635504">
      As a side note, the above implementation of
      <code>count_some</code> is longer than necessary, and even
      worse is not tail recursive. In real life, you would probably just
      use the <code>List.count</code> function from
      <code>Core</code>:
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> count_some l <span class="keyword2">=</span> <span class="keyword5">List.</span>count ~f<span class="keyword2">:</span><span class="keyword5">Option.</span>is_some l<span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val count_some : 'a option list -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml UTop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/lists-and-patterns/main.topscript">lists-and-patterns/main.topscript</a> , continued (part 53) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="variables-and-functions.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="files-modules-and-programs.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>