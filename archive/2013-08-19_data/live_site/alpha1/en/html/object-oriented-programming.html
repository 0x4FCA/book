<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 14. Object Oriented Programming / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha1',
                        page: 'object\u002Doriented\u002Dprogramming.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-json-xml-and-s-expressions.html">7. Data Serialization with JSON, XML and S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">8. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">9. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">10. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors-and-first-class-modules.html">11. Functors and First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="input-and-output.html">12. Input and Output</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">13. Concurrent Programming with Async</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html" class="here">14. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 14. Object Oriented Programming</h1>
                
                

    <p id="idp9337328">
<span><em>(yminsky: If we don't feel like these are
    &quot;great&quot; tools, maybe we shouldn't say it!)</em></span>
</p><p id="idp9338208">
<span><em>(yminsky: I wonder if it's worth emphasizing what makes
    objects unique early on. I think of them as no better of an
    encapsulation tool than closures. What makes them unique in my mind
    is that they are some combination of lighter weight and more dynamic
    than the alternatives (modules, records of closures,
    etc.))</em></span>
</p><p id="idp9339328">
<span><em>(yminsky: I'm not sure where we should say it, but OCaml's
    object system is strikingly different from those that most people
    are used to. It would be nice if we could call those differences out
    clearly somewhere. The main difference I see is the fact that
    subtyping and inheritance are not tied together, and that subtyping
    is structural.)</em></span>
</p><p id="idp9340464">
    We've already seen several tools that OCaml provides for organizing
    programs, particularly first-class modules. In addition, OCaml also
    supports object-oriented programming. There are objects, classes,
    and their associated types. Objects are good for encapsulation and
    abstraction, and classes are good for code re-use.
  </p><section><h1 id="when-to-use-objects">When to use objects</h1><p id="idp9342352">
      You might wonder when to use objects. First-class modules are more
      expressive (a module can include types, classes and objects
      cannot), and modules, functors, and algebraic data types offer a
      wide range of ways to express program structure. In fact, many
      seasoned OCaml programmers rarely use classes and objects, if at
      all.
    </p><p id="idp9343120">
      What exactly is object-oriented programming? Mitchell [6] points
      out four fundamental properties.
    </p><ul><li><p id="idp9344144">
<span><em>Abstraction</em></span>: the details of the
          implementation are hidden in the object; the interface is just
          the set of publically-accessible methods.
        </p></li><li><p id="idp9345504">
<span><em>Subtyping</em></span>: if an object
          <code>a</code> has all the functionality of an object
          <code>b</code>, then we may use <code>a</code> in
          any context where <code>b</code> is expected.
        </p></li><li><p id="idp9349584">
<span><em>Dynamic lookup</em></span>: when a message is sent to
          an object, the method to be executed is determined by the
          implementation of the object, not by some static property of
          the program. In other words, different objects may react to
          the same message in different ways.
        </p></li><li><p id="idp9351072">
<span><em>Inheritance</em></span>: the definition of one kind
          of object can be re-used to produce a new kind of object.
        </p></li></ul><p id="idp9352256">
      Modules already provide these features in some form, but the main
      focus of classes is on code re-use through inheritance and late
      binding of methods. This is a critical property of classes: the
      methods that implement an object are determined when the object is
      instantiated, a form of <span><em>dynamic</em></span> binding. In
      the meantime, while classes are being defined, it is possible (and
      necessary) to refer to methods without knowing statically how they
      will be implemented.
    </p><p id="idp9353600">
      In contrast, modules use static (lexical) scoping. If you want to
      parameterize your module code so that some part of it can be
      implemented later, you would write a function/functor. This is
      more explicit, but often more verbose than overriding a method in
      a class.
    </p><p id="idp9354304">
      In general, a rule of thumb might be: use classes and objects in
      situations where dynamic binding is a big win, for example if you
      have many similar variations in the implementation of a concept.
      Real world examples are fairly rare, but one good example is
      Xavier Leroy's
      <a href="http://gallium.inria.fr/~xleroy/software.html#cryptokit" target="_top">Cryptokit</a>,
      which provides a variety of cryptographic primitives that can be
      combined in building-block style.
    </p></section><section><h1 id="ocaml-objects">OCaml objects</h1><p id="idp9357136">
      If you already know about object oriented programming in a
      language like Java or C++, the OCaml object system may come as a
      surprise. Foremost is the complete separation of subtyping and
      inheritance in OCaml. In a language like Java, a class name is
      also used as the type of objects created by instantiating it, and
      the subtyping rule corresponds to inheritance. For example. if we
      implement a class <code>Stack</code> in Java by inheriting
      from a class <code>Deque</code>, we would be allowed to pass
      a stack anywhere a deque is expected (this is a silly example of
      course, practitioners will point out that we shouldn't do it).
    </p><p id="idp9359616">
      OCaml is entirely different. Classes are used to construct objects
      and support inheritance, including non-subtyping inheritance.
      Classes are not types. Instead, objects have <span><em>object
      types</em></span>, and if you want to use objects, you aren't
      required to use classes at all. Here is an example of a simple
      object.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">p</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">i</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">p</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
</pre></div><p id="idp9361872">
      The object has an integer value <code>x</code>, a method
      <code>get</code> that returns x, and a method
      <code>set</code> that updates the value of x.
    </p><p id="idp9364400">
      The object type is enclosed in angle brackets
      <code>&lt; ... &gt;</code>, containing just the types of the
      methods. Fields, like x, are not part of the public interface of
      an object. All interaction with an object is through its methods.
      The syntax for a method invocation (also called &quot;sending a
      message&quot; to the object) uses the <code>#</code>
      character.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">set</span> <span class="mi">17</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span>
</pre></div><p id="idp9367744">
      Objects can also be constructed by functions. If we want to
      specify the initial value of the object, we can define a function
      that takes the initial value and produces an object.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">make</span> <span class="n">i</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">y</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make</span> <span class="mi">5</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">p</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div><p id="idp9369712">
      Note that the types of the function <code>make</code> and
      the returned object now use the polymorphic type
      <code>'a</code>. When make is invoked on a concrete value
      <code>5</code>, we get the same object type as before, with
      type <code>int</code> for the value.
    </p></section><section><h1 id="object-polymorphism">Object Polymorphism</h1><p id="idp9374352">
<span><em>(yminsky: Maybe this is a good time to talk about the
      nature of object subtyping?)</em></span>
</p><p id="idp9375232">
      Functions can also take object arguments. Let's construct a new
      object <code>average</code> that's the average of any two
      objects with a <code>get</code> method.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">average</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="o">(</span><span class="n">p1</span><span class="o">#</span><span class="n">get</span> <span class="o">+</span> <span class="n">p2</span><span class="o">#</span><span class="n">get</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">average</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">make</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">make</span> <span class="mi">15</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">average</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">a</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">#</span> <span class="n">p2</span><span class="o">#</span><span class="n">set</span> <span class="mi">25</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">a</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div><p id="idp9378736">
      Note that the type for <code>average</code> uses the object
      type <code>&lt; get : int; .. &gt;</code>. The
      <code>..</code> are ellipsis, standing for any other
      methods. The type <code>&lt; get : int; .. &gt;</code>
      specifies an object that must have at least a
      <code>get</code> method, and possibly some others as well.
      If we try using the exact type
      <code>&lt; get : int &gt;</code> for an object with more
      methods, type inference will fail.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;)</span> <span class="o">=</span> <span class="n">make</span> <span class="mi">5</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">&gt;</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span>
       <span class="nc">The</span> <span class="n">second</span> <span class="k">object</span> <span class="k">type</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">set</span>
</pre></div><section><h1><b>
    Elisions are polymorphic
    </b></h1><p id="idp9385760">
      The <code>..</code> in an object type is an elision,
      standing for &quot;possibly more methods.&quot; It may not be
      apparent from the syntax, but an elided object type is actually
      polymorphic. If we try to write a type definition, we get an
      obscure error.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">point</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">A</span> <span class="k">type</span> <span class="n">variable</span> <span class="n">is</span> <span class="n">unbound</span> <span class="k">in</span> <span class="n">this</span> <span class="k">type</span> <span class="n">declaration</span><span class="o">.</span>
<span class="nc">In</span> <span class="k">type</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="k">as</span> <span class="k">'</span><span class="n">a</span> <span class="n">the</span> <span class="n">variable</span> <span class="k">'</span><span class="n">a</span> <span class="n">is</span> <span class="n">unbound</span>
</pre></div><p id="idp9388576">
      A <code>..</code> in an object type is called a
      <span><em>row variable</em></span> and this typing scheme is called
      <span><em>row polymorphism</em></span>. Even though
      <code>..</code> doesn't look like a type variable, it
      actually is. The error message suggests a solution, which is to
      add the <code>as 'a</code> type constraint.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">point</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="k">as</span> <span class="k">'</span><span class="n">a</span><span class="o">;;</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">point</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="k">constraint</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span>
</pre></div><p id="idp9393264">
      In other words, the type <code>'a point</code> is equal to
      <code>'a</code>, where
      <code>'a = &lt; get : int; .. &gt;</code>. That may seem
      like an odd way to say it, and in fact, this type definition is
      not really an abbreviation because <code>'a</code> refers to
      the entire type.
    </p></section><p id="idp9396816">
      An object of type <code>&lt; get:int; .. &gt;</code> can be
      any object with a method <code>get:int</code>, it doesn't
      matter how it is implemented. So far, we've constructed two
      objects with that type; the function <code>make</code>
      constructed one, and so did <code>average</code>. When the
      method <code>#get</code> is invoked, the actual method that
      is run is determined by the object.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">print_point</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Point: %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">print_point</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">print_point</span> <span class="o">(</span><span class="n">make</span> <span class="mi">5</span><span class="o">);;</span>
<span class="nc">Point</span><span class="o">:</span> <span class="mi">5</span>
<span class="o">#</span> <span class="n">print_point</span> <span class="o">(</span><span class="n">average</span> <span class="o">(</span><span class="n">make</span> <span class="mi">5</span><span class="o">)</span> <span class="o">(</span><span class="n">make</span> <span class="mi">15</span><span class="o">));;</span>
<span class="nc">Point</span><span class="o">:</span> <span class="mi">10</span>
</pre></div></section><section><h1 id="classes">Classes</h1><p id="idp9403744">
      Programming with objects directly is great for encapsulation, but
      one of the main goals of object-oriented programming is code
      re-use through inheritance. For inheritance, we need to introduce
      <span><em>classes</em></span>. In object-oriented programming, a
      class is a &quot;recipe&quot; for creating objects. The recipe can
      be changed by adding new methods and fields, or it can be changed
      by modifying existing methods.
    </p><p id="idp9405328">
      In OCaml, class definitions must be defined as top-level
      statements in a module. A class is not an object, and a class
      definition is not an expression. The syntax for a class definition
      uses the keyword <code>class</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">point</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">y</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">point</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span>
</pre></div><p id="idp9408176">
      The type <code>class point : ... end</code> is a
      <span><em>class type</em></span>. This particular type specifies
      that the <code>point</code> class defines a mutable field
      <code>x</code>, a method <code>get</code> that returns
      an <code>int</code>, and a method <code>set</code>
      with type <code>int -&gt; unit</code>.
    </p><p id="idp9414000">
      To produce an object, classes are instantiated with the keyword
      <code>new</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">point</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">p</span> <span class="o">:</span> <span class="n">point</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">p</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div><p id="idp9416464">
<span><em>(yminsky: You say that inheritance uses an existing
      class to define a new one, but the example below looks like using
      an existing class to define a new module. Is that what's going on?
      Or is a new class being created implicitly? If the latter, it
      might be better to be more explicit in this example and name the
      new class.)</em></span>
</p><p id="idp9417600">
      Inheritance uses an existing class to define a new one. For
      example, the following class definition supports an addition
      method <code>moveby</code> that moves the point by a
      relative amount. This also makes use of the
      <code>(self : 'self)</code> binding after the
      <code>object</code> keyword. The variable
      <code>self</code> stands for the current object, allowing
      self-invocation, and the type variable <code>'self</code>
      stands for the type of the current object (which in general is a
      subtype of <code>movable_point</code>).
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">movable_point</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
    <span class="k">inherit</span> <span class="n">point</span>
    <span class="k">method</span> <span class="n">moveby</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="o">(</span><span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="o">+</span> <span class="n">dx</span><span class="o">)</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="class-parameters-and-polymorphism">Class parameters and polymorphism</h1><p id="idp9425056">
      A class definition serves as the <span><em>constructor</em></span>
      for the class. In general, a class definition may have parameters
      that must be provided as arguments when the object is created with
      <code>new</code>.
    </p><p id="idp9426784">
      Let's build an example of an imperative singly-linked list using
      object-oriented techniques. First, we'll want to define a class
      for a single element of the list. We'll call it a
      <code>node</code>, and it will hold a value of type
      <code>'a</code>. When defining the class, the type
      parameters are placed in square brackets before the class name in
      the class definition. We also need a parameter
      <code>x</code> for the initial value.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span>
<span class="k">object</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>

  <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">method</span> <span class="n">set</span> <span class="n">x</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;-</span> <span class="n">x</span>

  <span class="k">method</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next_node</span>
  <span class="k">method</span> <span class="n">set_next</span> <span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span> <span class="o">&lt;-</span> <span class="n">node</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9430928">
      The <code>value</code> is the value stored in the node, and
      it can be retrieved and changed with the <code>get</code>
      and <code>set</code> methods. The
      <code>next_node</code> field is the link to the next element
      in the stack. Note that the type parameter <code>['a]</code>
      in the definition uses square brackets, but other uses of the type
      can omit them (or use parentheses if there is more than one type
      parameter).
    </p><p id="idp9435168">
      The type annotations on the <code>val</code> declarations
      are used to constrain type inference. If we omit these
      annotations, the type inferred for the class will be &quot;too
      polymorphic,&quot; <code>x</code> could have some type
      <code>'b</code> and <code>next_node</code> some type
      <code>'c option</code>.
    </p><div class="highlight"><pre>  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">=</span> <span class="nc">None</span>
  
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">x</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;-</span> <span class="n">x</span>
  
    <span class="k">method</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next_node</span>
    <span class="k">method</span> <span class="n">set_next</span> <span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span> <span class="o">&lt;-</span> <span class="n">node</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Some</span> <span class="k">type</span> <span class="n">variables</span> <span class="n">are</span> <span class="n">unbound</span> <span class="k">in</span> <span class="n">this</span> <span class="k">type</span><span class="o">:</span>
         <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="o">:</span>
           <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span>
           <span class="k">object</span>
             <span class="k">val</span> <span class="k">mutable</span> <span class="n">next_node</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span>
             <span class="k">val</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span>
             <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span>
             <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span>
             <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
             <span class="k">method</span> <span class="n">set_next</span> <span class="o">:</span> <span class="k">'</span><span class="n">c</span> <span class="n">option</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
           <span class="k">end</span>
       <span class="nc">The</span> <span class="k">method</span> <span class="n">get</span> <span class="n">has</span> <span class="k">type</span> <span class="k">'</span><span class="n">b</span> <span class="n">where</span> <span class="k">'</span><span class="n">b</span> <span class="n">is</span> <span class="n">unbound</span>
</pre></div><p id="idp9441120">
      In general, we need to provide enough constraints so that the
      compiler will infer the correct type. We can add type constraints
      to the parameters, to the fields, and to the methods. It is a
      matter of preference how many constraints to add. You can add type
      constraints in all three places, but the extra text may not help
      clarity. A convenient middle ground is to annotate the fields
      and/or class parameters, and add constraints to methods only if
      necessary.
    </p><p id="idp9442032">
      Next, we can define the list itself. We'll keep a field
      <code>head</code> the refers to the first element in the
      list, and <code>last</code> refers to the final element in
      the list. The method <code>insert</code> adds an element to
      the end of the list.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span>
<span class="k">object</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="n">first</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="n">last</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>

   <span class="k">method</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="nc">None</span>

   <span class="k">method</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Some</span> <span class="o">(</span><span class="k">new</span> <span class="n">node</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">last</span> <span class="k">with</span>
         <span class="nc">Some</span> <span class="n">last_node</span> <span class="o">-&gt;</span>
            <span class="n">last_node</span><span class="o">#</span><span class="n">set_next</span> <span class="n">new_node</span><span class="o">;</span>
            <span class="n">last</span> <span class="o">&lt;-</span> <span class="n">new_node</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
            <span class="n">first</span> <span class="o">&lt;-</span> <span class="n">new_node</span><span class="o">;</span>
            <span class="n">last</span> <span class="o">&lt;-</span> <span class="n">new_node</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="object-types">Object types</h1><p id="idp9447472">
      This definition of the class <code>slist</code> is not
      complete, we can construct lists, but we also need to add the
      ability to traverse the elements in the list. One common style for
      doing this is to define a class for an <code>iterator</code>
      object. An iterator provides a generic mechanism to inspect and
      traverse the elements of a collection. This pattern isn't
      restricted to lists, it can be used for many different kinds of
      collections.
    </p><p id="idp9449728">
      There are two common styles for defining abstract interfaces like
      this. In Java, an iterator would normally be specified with an
      interface, which specifies a set of method types. In languages
      without interfaces, like C++, the specification would normally use
      <span><em>abstract</em></span> classes to specify the methods
      without implementing them (C++ uses the &quot;= 0&quot; definition
      to mean &quot;not implemented&quot;).
    </p><pre id="idp9451008">
// Java-style iterator, specified as an interface.
interface &lt;T&gt; iterator {
  T Get();
  boolean HasValue();
  void Next();
};

// Abstract class definition in C++.
template&lt;typename T&gt;
class Iterator {
 public:
  virtual ~Iterator() {}
  virtual T get() const = 0;
  virtual bool has_value() const = 0;
  virtual void next() = 0;
};
</pre><p id="idp9452160">
      OCaml support both styles. In fact, OCaml is more flexible than
      these approaches because an object type can be implemented by any
      object with the appropriate methods, it does not have to be
      specified by the object's class <span><em>a priori</em></span>.
      We'll leave abstract classes for later. Let's demonstrate the
      technique using object types.
    </p><p id="idp9453344">
      First, we'll define an object type <code>iterator</code>
      that specifies the methods in an iterator.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;;;`</span>
</pre></div><p id="idp9455664">
      Next, we'll define an actual iterator for the class
      <code>slist</code>. We can represent the position in the
      list with a field <code>current</code>, following links as
      we traverse the list.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="n">cur</span> <span class="o">=</span>
<span class="k">object</span>
  <span class="k">val</span> <span class="k">mutable</span> <span class="n">current</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">=</span> <span class="n">cur</span>

  <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">current</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>

  <span class="k">method</span> <span class="n">get</span> <span class="o">=</span>
     <span class="k">match</span> <span class="n">current</span> <span class="k">with</span>
        <span class="nc">Some</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">node</span><span class="o">#</span><span class="n">get</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;no value&quot;</span><span class="o">)</span>

  <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
     <span class="k">match</span> <span class="n">current</span> <span class="k">with</span>
        <span class="nc">Some</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">current</span> <span class="o">&lt;-</span> <span class="n">node</span><span class="o">#</span><span class="n">next</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;no value&quot;</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9459056">
      Finally, we add a method <code>iterator</code> to the slist
      class to produce an iterator. To do so, we construct an
      <code>slist_iterator</code> that refers to the first node in
      the list, but we want to return a value with the object type
      <code>iterator</code>. This requires an explicit coercion
      using the <code>:&gt;</code> operator.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span> <span class="k">object</span>
<span class="o">...</span>
   <span class="k">method</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">slist_iterator</span> <span class="n">first</span> <span class="o">:&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span><span class="o">)</span>
<span class="k">end</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">slist</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="o">#</span><span class="n">iterator</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9464288">
      We may also wish to define functional-style methods,
      <code>iter f</code> takes a function <code>f</code>
      and applies it to each of the elements of the list.
    </p><div class="highlight"><pre><span class="k">method</span> <span class="n">iter</span> <span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
  <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
    <span class="n">f</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span>
    <span class="n">it</span><span class="o">#</span><span class="n">next</span>
  <span class="k">end</span>
</pre></div><p id="idp9467248">
      What about functional operations similar to
      <code>List.map</code> or <code>List.fold</code>? In
      general, these methods take a function that produces a value of
      some other type than the elements of the set. For example, the
      function <code>List.fold</code> has type
      <code>'a list -&gt; ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</code>,
      where <code>'b</code> is an arbitrary type. To replicate
      this in the <code>slist</code> class, we need a method type
      <code>('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</code>, where
      the method type is polymorphic over <code>'b</code>.
    </p><p id="idp9473680">
      The solution is to use a type quantifier, as shown in the
      following example. The method type must be specified directly
      after the method name, which means that method parameters must be
      expressed using a <code>fun</code> or
      <code>function</code> expression.
    </p><div class="highlight"><pre><span class="k">method</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="o">.</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
   <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span>
         <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">x</span> <span class="k">in</span>
         <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
         <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
            <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">!</span><span class="n">y</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
            <span class="n">it</span><span class="o">#</span><span class="n">next</span>
         <span class="k">done</span><span class="o">;</span>
         <span class="o">!</span><span class="n">y</span><span class="o">)</span>
</pre></div></section><section><h1 id="immutable-objects">Immutable objects</h1><p id="idp9478448">
      Many people consider object-oriented programming to be
      intrinsically imperative, where an object is like a state machine.
      Sending a message to an object causes it to change state,
      possibily sending messages to other objects.
    </p><p id="idp9479104">
      Indeed, in many programs, this makes sense, but it is by no means
      required. Let's define an object-oriented version of lists similar
      to the imperative list above. We'll implement it with a regular
      list type <code>'a list</code>, and insertion will be to the
      beginning of the list instead of to the end.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">flist</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">elements</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span>

   <span class="k">method</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="n">elements</span> <span class="o">=</span> <span class="bp">[]</span>

   <span class="k">method</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span> <span class="o">=</span> <span class="o">{&lt;</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">x</span> <span class="o">::</span> <span class="n">elements</span> <span class="o">&gt;}</span>

   <span class="k">method</span> <span class="n">iterator</span> <span class="o">=</span>
      <span class="o">(</span><span class="k">new</span> <span class="n">flist_iterator</span> <span class="n">elements</span> <span class="o">:&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span><span class="o">)</span>

   <span class="k">method</span> <span class="n">iter</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">f</span> <span class="n">elements</span>

   <span class="k">method</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="o">.</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">f</span> <span class="n">x</span> <span class="n">elements</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9482160">
      A key part of the implementation is the definition of the method
      <code>insert</code>. The expression
      <code>{&lt; ... &gt;}</code> produces a copy of the current
      object, with the same type, and the specified fields updated. In
      other words, the <code>new_fst new_x</code> method produces
      a copy of the object, with <code>x</code> replaced by
      <code>new_x</code>. The original object is not modified, and
      the value of <code>y</code> is also unaffected.
    </p><p id="idp9487104">
      There are some restriction on the use of the expression
      <code>{&lt; ... &gt;}</code>. It can be used only within a
      method body, and only the values of fields may be updated. Method
      implementations are fixed at the time the object is created, they
      cannot be changed dynamically.
    </p><p id="idp9488496">
      We use the same object type <code>iterator</code> for
      iterators, but implement it differently.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">flist_iterator</span> <span class="n">l</span> <span class="o">=</span>
<span class="k">object</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="n">elements</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="n">l</span>

   <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="bp">[]</span>

   <span class="k">method</span> <span class="n">get</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
         <span class="n">h</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">h</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;list is empty&quot;</span><span class="o">)</span>

   <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
         <span class="o">_</span> <span class="o">::</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">elements</span> <span class="o">&lt;-</span> <span class="n">l</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;list is empty&quot;</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="class-types">Class types</h1><p id="idp9492352">
      Once we have defined the list implementation, the next step is to
      wrap it in a module or <code>.ml</code> file and give it a
      type so that it can be used in the rest of our code. What is the
      type?
    </p><p id="idp9493632">
      Before we begin, let's wrap up the implementation in an explicit
      module (we'll use explicit modules for illustration, but the
      process is similar when we want to define a
      <code>.mli</code> file). In keeping with the usual style for
      modules, we define a type <code>'a t</code> to represent the
      type of list values.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">SList</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="n">x</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>
   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>
   <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">=</span> <span class="k">object</span> <span class="o">...</span> <span class="k">end</span>
   
   <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span> <span class="k">new</span> <span class="n">slist</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9497472">
      We have multiple choices in definining the module type, depending
      on how much of the implementation we want to expose. At one
      extreme, a maximally-abstract signature would completely hide the
      class definitions.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">AbstractSList</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

   <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">end</span> <span class="o">=</span> <span class="nc">SList</span>
</pre></div><p id="idp9499296">
      The abstract signature is simple because we ignore the classes.
      But what if we want to include them in the signature, so that
      other modules can inherit from the class definitions? For this, we
      need to specify types for the classes, called <span><em>class
      types</em></span>. Class types do not appear in mainstream
      object-oriented programming languages, so you may not be familiar
      with them, but the concept is pretty simple. A class type
      specifies the type of each of the visible parts of the class,
      including both fields and methods. Just like for module types, you
      don't have to give a type for everything; anything you omit will
      be hidden.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">VisibleSList</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">&gt;</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">node</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span>
  <span class="k">object</span>
     <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span>
     <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
     <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
     <span class="k">method</span> <span class="n">set_next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="o">-&gt;</span>
  <span class="k">object</span>
     <span class="k">method</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span>
     <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span>
     <span class="k">method</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">first</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">last</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span>
    <span class="k">method</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span>
    <span class="k">method</span> <span class="n">insert</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
    <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
  <span class="k">end</span>

  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">slist</span>
<span class="k">end</span> <span class="o">=</span> <span class="nc">SList</span>
</pre></div><p id="idp9503392">
      In this signature, we've chosen to make nearly everything visible.
      The class type for <code>slist</code> specifies the types of
      the fields <code>first</code> and <code>last</code>,
      as well ad the types of each of the methods. We've also included a
      class type for <code>slist_iterator</code>, which is of
      somewhat more questionable value, since the type doesn't appear in
      the type for <code>slist</code> at all.
    </p><p id="idp9507696">
      One more thing, in this example the function
      <code>make</code> has type
      <code>unit -&gt; 'a slist</code>. But wait, we've stressed
      <span><em>classes are not types</em></span>, so what's up with
      that? In fact, what we've said is entirely true, classes and class
      names <span><em>are not</em></span> types. However, class names can
      be used to stand for types. When the compiler sees a class name in
      type position, it automatically constructs an object type from it
      by erasing all the fields and keeping only the method types. In
      this case, the type expression <code>'a slist</code> is
      exactly equivalent to <code>'a t</code>.
    </p></section><section><h1 id="subtyping">Subtyping</h1><p id="idp9513600">
      Subtyping is a central concept in object-oriented programming. It
      governs when an object with one type <span><em>A</em></span> can be
      used in an expression that expects an object of another type
      <span><em>B</em></span>. When this is true, we say that
      <span><em>A</em></span> is a <span><em>subtype</em></span> of
      <span><em>B</em></span>. Actually, more concretely, subtyping
      determines when the coercion operator <code>e :&gt; t</code>
      can be applied. This coercion works only if the expression
      <code>e</code> has some type <code>s</code> and
      <code>s</code> is a subtype of <code>t</code>.
    </p><p id="idp9520000">
      To explore this, let's define some simple classes for geometric
      shapes. The generic type <code>shape</code> has a method to
      compute the area, and a <code>square</code> is a specific
      kind of shape.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;;;</span>

<span class="k">class</span> <span class="n">square</span> <span class="n">w</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
  <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*.</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9523232">
      A <code>square</code> has a method <code>area</code>
      just like a <code>shape</code>, and an additional method
      <code>width</code>. Still, we expect a
      <code>square</code> to be a <code>shape</code>, and it
      is. The coercion <code>:&gt;</code> must be explicit.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">new_square</span> <span class="n">x</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="n">square</span> <span class="n">x</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">27</span><span class="o">-</span><span class="mi">39</span><span class="o">:</span>
  <span class="k">let</span> <span class="n">new_square</span> <span class="n">x</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="n">square</span> <span class="n">x</span><span class="o">;;</span>
                             <span class="o">^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="n">square</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="n">shape</span>
<span class="nc">The</span> <span class="n">second</span> <span class="k">object</span> <span class="k">type</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">width</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">new_square</span> <span class="n">x</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="n">x</span> <span class="o">:&gt;</span> <span class="n">shape</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">new_square</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9530320">
      What are the rules for subtyping? In general, object subtyping has
      two general forms, called <span><em>width</em></span> and
      <span><em>depth</em></span> subtyping. Width subtyping means that
      an object type <span><em>A</em></span> is a a subtype of
      <span><em>B</em></span>, if <span><em>A</em></span> has all of the
      methods of <span><em>B</em></span>, and possibly more. A
      <code>square</code> is a subtype of <code>shape</code>
      because it implements all of the methods of
      <code>shape</code> (the <code>area</code> method).
    </p><p id="idp9536416">
      The subtyping rules are purely technical, they have no relation to
      object semantics. We can define a class
      <code>rectangle</code> that has all of the methods of a
      <code>square</code>, so it is a subtype of square and can be
      used wherever a <code>square</code> is expected.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">rectangle</span> <span class="n">h</span> <span class="n">w</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">inherit</span> <span class="n">square</span> <span class="n">w</span>
     <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*.</span> <span class="n">self</span><span class="o">#</span><span class="n">height</span>
     <span class="k">method</span> <span class="n">height</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">square_rectangle</span> <span class="n">h</span> <span class="n">w</span> <span class="o">:</span> <span class="n">square</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">rectangle</span> <span class="n">h</span> <span class="n">w</span> <span class="o">:&gt;</span> <span class="n">square</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">square_rectangle</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9540544">
      This may seem absurd, but this concept is expressible in all
      object-oriented languages. The contradiction is semantic -- we
      know that in the real world, not all rectangles are squares; but
      in the programming world, rectangles have all of the features of
      squares (according to our definition), so they can be used just
      like squares. Suffice it to say that it is usually better to avoid
      such apparent contradictions.
    </p><p id="idp9541408">
      Next, let's take a seemingly tiny step forward, and start building
      collections of shapes. It is easy enough to define a
      <code>slist</code> of squares.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">squares</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">SList</span><span class="p">.</span><span class="n">make</span> <span class="bp">()</span> <span class="k">in</span>
     <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">);</span>
     <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">);</span>
     <span class="n">l</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">squares</span> <span class="o">:</span> <span class="n">square</span> <span class="n">slist</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
</pre></div><p id="idp9543920">
      We can also define a function to calculate the total area of a
      list of shapes. There is no reason to restrict this to squares, it
      should work for any list of shapes with type
      <code>shape slist</code>. The problem is that doing so
      raises some serious typing questions -- can a
      <code>square slist</code> be passed to a function that
      expects a <code>shape slist</code>? If we try it, the
      compiler produces a verbose error message.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">total_area</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">slist</span><span class="o">)</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">total</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
     <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
     <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
        <span class="n">total</span> <span class="o">:=</span> <span class="o">!</span><span class="n">total</span> <span class="o">+.</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">#</span><span class="n">area</span><span class="o">;</span>
        <span class="n">it</span><span class="o">#</span><span class="n">next</span>
     <span class="k">done</span><span class="o">;</span>
     <span class="o">!</span><span class="n">total</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">total_area</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">slist</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">total_area</span> <span class="n">squares</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">11</span><span class="o">-</span><span class="mi">18</span><span class="o">:</span>
  <span class="n">total_area</span> <span class="n">squares</span><span class="o">;;</span>
             <span class="o">^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
         <span class="n">square</span> <span class="n">slist</span> <span class="o">=</span>
           <span class="o">&lt;</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">square</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span>
             <span class="n">iterator</span> <span class="o">:</span> <span class="n">square</span> <span class="n">iterator</span> <span class="o">&gt;</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="n">shape</span> <span class="n">slist</span> <span class="o">=</span>
           <span class="o">&lt;</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span>
             <span class="n">iterator</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">iterator</span> <span class="o">&gt;</span>
       <span class="nc">Type</span> <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;</span>
       <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;</span> 
       <span class="nc">The</span> <span class="n">second</span> <span class="k">object</span> <span class="k">type</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">width</span>
</pre></div><p id="idp9548896">
      It might seem tempting to give up at this point, especially
      because the subtyping is not even true -- the type
      <code>square slist</code> is not a subtype of
      <code>shape slist</code>. The problem is with the
      <code>insert</code> method. For
      <code>shape slist</code>, the <code>insert</code>
      method takes an arbitrary <code>shape</code> and inserts it
      into the list. So if we could coerce a
      <code>square slist</code> to a
      <code>shape slist</code>, then it would be possible to
      insert an arbitrary shape into the list, which would be an error.
    </p><section><h1 id="using-more-precise-types-to-address-subtyping-problems">Using more precise types to address subtyping
      problems</h1><p id="idp9556704">
        Still, the <code>total_area</code> function should be
        fine, in principle. It doesn't call <code>insert</code>,
        so it isn't making that error. To make it work, we need to use a
        more precise type that indicates we are not going to be mutating
        the list. We define a type
        <code>readonly_shape_slist</code> and confirm that we can
        coerce the list of squares.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">readonly_shape_slist</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">iterator</span> <span class="o">&gt;;;</span>
<span class="k">type</span> <span class="n">readonly_shape_slist</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">iterator</span> <span class="o">:</span> <span class="n">shape</span> <span class="n">iterator</span> <span class="o">&gt;</span>
<span class="o">#</span> <span class="o">(</span><span class="n">squares</span> <span class="o">:&gt;</span> <span class="n">readonly_shape_slist</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">readonly_shape_slist</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">total_area</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">readonly_shape_slist</span><span class="o">)</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">...;;</span>
<span class="k">val</span> <span class="n">total_area</span> <span class="o">:</span> <span class="n">readonly_shape_slist</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span>   <span class="n">total_area</span> <span class="o">(</span><span class="n">squares</span> <span class="o">:&gt;</span> <span class="n">readonly_shape_slist</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">5</span><span class="o">.</span>
</pre></div><p id="idp9561088">
        Why does this work, why is a <code>square slist</code> a
        subtype of <code>readonly_shape_slist</code>. The
        reasoning is in two steps. First, the easy part is width
        subtyping: we can drop the other methods to see that
        <code>square slist</code> is a subtype of
        <code>&lt; iterator : square iterator &gt;</code>. The
        next step is to use <span><em>depth</em></span> subtyping, which,
        in its general form, says that an object type
        <code>&lt; m : t1 &gt;</code> is a subtype of a type
        <code>&lt; m : t2&gt;</code> iff <code>t1</code> is
        a subtype of <code>t2</code>. In other words, instead of
        reasoning about the number of methods in a type (the width), the
        number of methods is fixed, and we look within the method types
        themselves (the &quot;depth&quot;).
      </p><p id="idp9568400">
        In this particular case, depth subtyping on the
        <code>iterator</code> method requires that
        <code>square iterator</code> be a subtype of
        <code>shape iterator</code>. Expanding the type definition
        for the type <code>iterator</code>, we again invoke depth
        subtyping, and we need to show that the type
        <code>&lt; get : square &gt;</code> is a subtype of
        <code>&lt;get : shape &gt;</code>, which follows because
        <code>square</code> is a subtype of
        <code>shape</code>.
      </p><p id="idp9574768">
        This reasoning may seem fairly long and complicated, but it
        should be pointed out that this typing
        <span><em>works</em></span>, and in the end the type annotations
        are fairly minor. In most typed object-oriented languages, the
        coercion would simply not be possible. For example, in C++, a
        STL type <code>slist&lt;T&gt;</code> is invariant in
        <code>T</code>, it is simply not possible to use
        <code>slist&lt;square&gt;</code> where
        <code>slist&lt;shape&gt;</code> is expected (at least
        safely). The situation is similar in Java, although Java
        supports has an escape hatch that allows the program to fall
        back to dynamic typing. The situation in OCaml is much better;
        it works, it is statically checked, and the annotations are
        pretty simple.
      </p></section><section><h1 id="using-elided-types-to-address-subtyping-problems">Using elided types to address subtyping problems</h1><p id="idp9580384">
        Before we move to the next topic, there is one more thing to
        address. The typing we gave above, using
        <code>readonly_shape_slist</code>, requires that the
        caller perform an explicit coercion before calling the
        <code>total_area</code> function. We would like to give a
        better type that avoids the coercion.
      </p><p id="idp9582496">
        A solution is to use an elided type. Instead of
        <code>shape</code>, we can use the elided type
        <code>&lt; area : float; .. &gt;</code>. In fact, once we
        do this, it also becomes possible to use the
        <code>slist</code> type.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">total_area</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="n">slist</span><span class="o">)</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">...;;</span>
<span class="k">val</span> <span class="n">total_area</span> <span class="o">:</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="o">..</span> <span class="o">&gt;</span> <span class="n">slist</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">total_area</span> <span class="n">squares</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">5</span><span class="o">.</span>
</pre></div><p id="idp9586336">
        This works, and it removes the need for explicit coercions. This
        type is still fairly simple, but it does have the drawback that
        the programmer needs to remember that the types
        <code>&lt; area : float; ..&gt;</code> and
        <code>shape</code> are related.
      </p><p id="idp9588400">
        OCaml supports an abbreviation in this case, but it works only
        for classes, not object types. The type expression
        <code># classname</code> is an abbreviation for an elided
        type containing all of the methods in the named class, and more.
        Since <code>shape</code> is an object type, we can't write
        <code>#shape</code>. However, if a class definition is
        available, this abbreviation can be useful. The following
        definition is exactly equivalent to the preceeding.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">cshape</span> <span class="o">=</span> <span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">cshape</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">total_area</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="o">#</span><span class="n">cshape</span> <span class="kt">list</span><span class="o">)</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">...;;</span>
<span class="k">val</span> <span class="n">total_area</span> <span class="o">:</span> <span class="o">#</span><span class="n">cshape</span> <span class="n">slist</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">total_area</span> <span class="n">squares</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">5</span><span class="o">.</span>
</pre></div></section><section><h1 id="narrowing">Narrowing</h1><p id="idp9593888">
        Narrowing, also called <span><em>down casting</em></span>, is the
        ability to coerce an object to one of its subtypes. For example,
        if we have a list of shapes <code>shape slist</code>, we
        might know (for some reason) what the actual type of each shape
        is. Perhaps we know that all objects in the list have type
        <code>square</code>. In this case,
        <span><em>narrowing</em></span> would allow the re-casting of the
        object from type <code>shape</code> to type
        <code>square</code>. Many languages support narrowing
        through dynamic type checking. For example, in Java, a coercion
        <code>(Square) x</code> is allowed if the value
        <code>x</code> has type <code>Square</code> or one
        of its subtypes; otherwise the coercion throws an exception.
      </p><p id="idp9600704">
        Narrowing is <span><em>not permitted</em></span> in OCaml.
        Period.
      </p><p id="idp9601584">
        Why? There are two reasonable explanations, one based on a
        design principle, and another technical (the technical reason is
        simple: it is hard to implement).
      </p><p id="idp9602176">
        The design argument is this: narrowing violates abstraction. In
        fact, with a structural typing system like in OCaml, narrowing
        would essentially provide the ability to enumerate the methods
        in an object. To check whether an object <code>obj</code>
        has some method <code>foo : int</code>, one would attempt
        a coercion <code>(obj :&gt; &lt; foo : int &gt;)</code>.
      </p><p id="idp9605088">
        More commonly, narrowing leads to poor object-oriented style.
        Consider the following Java code, which returns the name of a
        shape object.
      </p><pre id="idp9605664">
String GetShapeName(Shape s) {
  if (s instanceof Square) {
    return &quot;Square&quot;;
  } else if (s instanceof Circle) {
    return &quot;Circle&quot;;
  } else {
    return &quot;Other&quot;;
  }
}
</pre><p id="idp9606672">
        Most programmers would consider this code to be
        &quot;wrong.&quot; Instead of performing a case analysis on the
        type of object, it would be better to define a method to return
        the name of the shape. Instead of calling
        <code>GetShapeName(s)</code>, we should call
        <code>s.Name()</code> instead.
      </p><p id="idp9609152">
        However, the situation is not always so obvious. The following
        code checks whether an array of shapes looks like a
        &quot;barbell,&quot; composed to two <code>Circle</code>
        objects separated by a <code>Line</code>, where the
        circles have the same radius.
      </p><pre id="idp9611344">
boolean IsBarBell(Shape[] s) {
  return s.length == 3 &amp;&amp; (s[0] instanceof Circle) &amp;&amp;
    (s[1] instanceof Line) &amp;&amp; (s[2] instanceof Circle) &amp;&amp;
    ((Circle) s[0]).radius() == ((Circle) s[2]).radius();
}
</pre><p id="idp9612240">
        In this case, it is much less clear how to augment the
        <code>Shape</code> class to support this kind of pattern
        analysis. It is also not obvious that object-oriented
        programming is well-suited for this situation. Pattern matching
        seems like a better fit.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">is_bar_bell</span> <span class="o">=</span> <span class="k">function</span>
 <span class="o">|</span> <span class="o">[</span><span class="nc">Circle</span> <span class="n">r1</span><span class="o">;</span> <span class="nc">Line</span> <span class="o">_;</span> <span class="nc">Circle</span> <span class="n">r2</span><span class="o">]</span> <span class="k">when</span> <span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span> <span class="o">-&gt;</span> <span class="bp">true</span>
 <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span><span class="o">;;</span>
</pre></div><p id="idp9614736">
        Regardless, there is a solution if you find yourself in this
        situation, which is to augment the classes with variants. You
        can define a method <code>variant</code> that injects the
        actual object into a variant type.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">variant</span> <span class="o">:</span> <span class="n">repr</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">&gt;</span>
<span class="ow">and</span> <span class="n">circle</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">variant</span> <span class="o">:</span> <span class="n">repr</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="n">radius</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;</span>
<span class="ow">and</span> <span class="n">line</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">variant</span> <span class="o">:</span> <span class="n">repr</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">float</span><span class="o">;</span> <span class="n">length</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">&gt;</span>
<span class="ow">and</span> <span class="n">repr</span> <span class="o">=</span>
 <span class="o">|</span> <span class="nc">Circle</span> <span class="k">of</span> <span class="n">circle</span>
 <span class="o">|</span> <span class="nc">Line</span> <span class="k">of</span> <span class="n">line</span><span class="o">;;</span>
 
<span class="k">let</span> <span class="n">is_bar_bell</span> <span class="o">=</span> <span class="k">function</span>
 <span class="o">|</span> <span class="o">[</span><span class="n">s1</span><span class="o">;</span> <span class="n">s2</span><span class="o">;</span> <span class="n">s3</span><span class="o">]</span> <span class="o">-&gt;</span>
   <span class="o">(</span><span class="k">match</span> <span class="n">s1</span><span class="o">#</span><span class="n">variant</span><span class="o">,</span> <span class="n">s2</span><span class="o">#</span><span class="n">variant</span><span class="o">,</span> <span class="n">s3</span><span class="o">#</span><span class="n">variant</span> <span class="k">with</span>
     <span class="o">|</span> <span class="nc">Circle</span> <span class="n">c1</span><span class="o">,</span> <span class="nc">Line</span> <span class="o">_,</span> <span class="nc">Circle</span> <span class="n">c2</span> <span class="k">when</span> <span class="n">c1</span><span class="o">#</span><span class="n">radius</span> <span class="o">==</span> <span class="n">c2</span><span class="o">#</span><span class="n">radius</span> <span class="o">-&gt;</span> <span class="bp">true</span>
     <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span><span class="o">)</span>
 <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span><span class="o">;;</span>
</pre></div><p id="idp9617920">
        This pattern works, but it has drawbacks. In particular, the
        recursive type definition should make it clear that this pattern
        is essentially equivalent to using variants, and that objects do
        not provide much value here.
      </p></section><section><h1 id="binary-methods">Binary methods</h1><p id="idp9619792">
        A <span><em>binary method</em></span> is a method that takes an
        object of <code>self</code> type. One common example is
        defining a method for equality.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">square</span> <span class="n">w</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> 
    <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">width</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">square</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="k">object</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">method</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">rectangle</span> <span class="n">w</span> <span class="n">h</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
    <span class="k">method</span> <span class="n">height</span> <span class="o">=</span> <span class="n">h</span>
    <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">height</span>
    <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">width</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="o">#</span><span class="n">height</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">height</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">...</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">)#</span><span class="n">equals</span> <span class="o">(</span><span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">rectangle</span> <span class="mi">5</span> <span class="mi">6</span><span class="o">)#</span><span class="n">equals</span> <span class="o">(</span><span class="k">new</span> <span class="n">rectangle</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9623664">
        This works, but there is a problem lurking here. The method
        <code>equals</code> takes an object of the exact type
        <code>square</code> or <code>rectangle</code>.
        Because of this, we can't define a common base class
        <code>shape</code> that also includes an equality method.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">sq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">square</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="o">(</span><span class="n">sq</span> <span class="o">:&gt;</span> <span class="n">shape</span><span class="o">);;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">13</span><span class="o">:</span>
  <span class="o">(</span><span class="n">sq</span> <span class="o">:&gt;</span> <span class="n">shape</span><span class="o">);;</span>
  <span class="o">^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Type</span> <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">square</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span>
       <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">subtype</span> <span class="k">of</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">&gt;</span> 
<span class="nc">Type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">&gt;</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">subtype</span> <span class="k">of</span>
  <span class="n">square</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">square</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;</span> 
</pre></div><p id="idp9628704">
        The problem is that a <code>square</code> expects to be
        compared with a <code>square</code>, not an arbitrary
        shape; similarly for <code>rectangle</code>.
      </p><p id="idp9631344">
        This problem is fundamental. Many languages solve it either with
        narrowing (with dynamic type checking), or by method
        overloading. Since OCaml has neither of these, what can we do?
      </p><p id="idp9631952">
        One proposal we could consider is, since the problematic method
        is equality, why not just drop it from the base type
        <code>shape</code> and use polymorphic equality instead?
        Unfortunately, the builtin equality has very poor behavior when
        applied to objects.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">(</span><span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">end</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="k">object</span> <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">end</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9634368">
        The problem here is that the builtin polymorphic equality
        compares the method implementations, not their return values.
        The method implementations (the function values that implement
        the methods) are different, so the equality comparison is false.
        There are other reasons not to use the builtin polymorphic
        equality, but these false negatives are a showstopper.
      </p><p id="idp9635184">
        If we want to define equality for shapes in general, the
        remaining solution is to use the same approach as we described
        for narrowing. That is, introduce a
        <span><em>representation</em></span> type implemented using
        variants, and implement the comparison based on the
        representation type.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">shape_repr</span> <span class="o">=</span>
 <span class="o">|</span> <span class="nc">Square</span> <span class="k">of</span> <span class="kt">int</span>
 <span class="o">|</span> <span class="nc">Circle</span> <span class="k">of</span> <span class="kt">int</span>
 <span class="o">|</span> <span class="nc">Rectangle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">;;</span>
 
<span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">&gt;;;</span>

<span class="k">class</span> <span class="n">square</span> <span class="n">w</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
  <span class="k">method</span> <span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
  <span class="k">method</span> <span class="n">area</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span> <span class="o">*</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">method</span> <span class="n">repr</span> <span class="o">=</span> <span class="nc">Square</span> <span class="n">self</span><span class="o">#</span><span class="n">width</span>
  <span class="k">method</span> <span class="n">equals</span> <span class="o">(</span><span class="n">other</span> <span class="o">:</span> <span class="n">shape</span><span class="o">)</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">repr</span> <span class="o">=</span> <span class="n">other</span><span class="o">#</span><span class="n">repr</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9638048">
        The binary method <code>equals</code> is now implemented
        in terms of the concrete type <code>shape_repr</code>. In
        fact, the objects are now isomorphic to the
        <code>shape_repr</code> type. When using this pattern, you
        will not be able to hide the <code>repr</code> method, but
        you can hide the type definition using the module system.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Shapes</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">shape_repr</span>
  <span class="k">type</span> <span class="n">shape</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span><span class="o">;</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">area</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">&gt;</span>
  
  <span class="k">class</span> <span class="n">square</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span>
    <span class="k">object</span>
      <span class="k">method</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span>
      <span class="k">method</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span>
      <span class="k">method</span> <span class="n">repr</span> <span class="o">:</span> <span class="n">shape_repr</span>
      <span class="k">method</span> <span class="n">equals</span> <span class="o">:</span> <span class="n">shape</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">shape_repr</span> <span class="o">=</span> <span class="nc">Square</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Circle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Rectangle</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
  <span class="o">...</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section></section><section><h1 id="private-methods">Private methods</h1><p id="idp9644624">
      Methods can be declared <span><em>private</em></span>, which means
      that they may be called by subclasses, but they are not visible
      otherwise (similar to a <span><em>protected</em></span> method in
      C++).
    </p><p id="idp9646064">
      To illustrate, let's build a class <code>vector</code> that
      contains an array of integers, resizing the storage array on
      demand. The field <code>values</code> contains the actual
      values, and the <code>get</code>, <code>set</code>,
      and <code>length</code> methods implement the array access.
      For clarity, the resizing operation is implemented as a private
      method <code>ensure_capacity</code> that resizes the array
      if necessary.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">vector</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">val</span> <span class="k">mutable</span> <span class="n">values</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[||]</span>
  
     <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">set</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span>
        <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="n">i</span><span class="o">;</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">x</span>
     <span class="k">method</span> <span class="n">length</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span>
  
     <span class="k">method</span> <span class="k">private</span> <span class="n">ensure_capacity</span> <span class="n">i</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">self</span><span class="o">#</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="k">then</span>
           <span class="k">let</span> <span class="n">new_values</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">in</span>
           <span class="nn">Array</span><span class="p">.</span><span class="n">blit</span> <span class="n">values</span> <span class="mi">0</span> <span class="n">new_values</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span><span class="o">);</span>
           <span class="n">values</span> <span class="o">&lt;-</span> <span class="n">new_values</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">get</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="kt">int</span>
<span class="o">#</span> <span class="n">v</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="mi">10</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span>
  <span class="n">v</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="mi">10</span><span class="o">;;</span>
  <span class="o">^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="n">vector</span>
       <span class="nc">It</span> <span class="n">has</span> <span class="n">no</span> <span class="k">method</span> <span class="n">ensure_capacity</span>
</pre></div><p id="idp9653008">
      To be precise, the method <code>ensure_capacity</code> is
      part of the class type, but it is not part of the object type.
      This means the object <code>v</code> has no method
      <code>ensure_capacity</code>. However, it is available to
      subclasses. We can extend the class, for example, to include a
      method <code>swap</code> that swaps two elements.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">swappable_vector</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">inherit</span> <span class="n">vector</span>

     <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
        <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="o">(</span><span class="n">max</span> <span class="n">i</span> <span class="n">j</span><span class="o">);</span>
        <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">);</span>
        <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9657808">
      Yet another reason for private methods is to factor the
      implementation and support recursion. Moving along with this
      example, let's build a binary heap, which is a binary tree in heap
      order: where the label of parent elements is smaller than the
      labels of its children. One efficient implementation is to use an
      array to represent the values, where the root is at index 0, and
      the children of a parent node at index <code>i</code> are at
      indexes <code>2 * i</code> and <code>2 * i + 1</code>.
      To insert a node into the tree, we add it as a leaf, and then
      recursively move it up the tree until we restore heap order.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">binary_heap</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">values</span> <span class="o">=</span> <span class="k">new</span> <span class="n">swappable_vector</span>

   <span class="k">method</span> <span class="n">min</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">values</span><span class="o">#</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
         <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;heap is empty&quot;</span><span class="o">);</span>
      <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="mi">0</span>

   <span class="k">method</span> <span class="n">add</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">values</span><span class="o">#</span><span class="n">length</span> <span class="k">in</span>
      <span class="n">values</span><span class="o">#</span><span class="n">set</span> <span class="n">pos</span> <span class="n">x</span><span class="o">;</span>
      <span class="n">self</span><span class="o">#</span><span class="n">move_up</span> <span class="n">pos</span>

   <span class="k">method</span> <span class="k">private</span> <span class="n">move_up</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span>
         <span class="k">let</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">values</span><span class="o">#</span><span class="n">get</span> <span class="n">parent</span> <span class="k">then</span> <span class="k">begin</span>
               <span class="n">values</span><span class="o">#</span><span class="n">swap</span> <span class="n">i</span> <span class="n">parent</span><span class="o">;</span>
               <span class="n">self</span><span class="o">#</span><span class="n">move_up</span> <span class="n">parent</span>
            <span class="k">end</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9662896">
      The method <code>move_up</code> implements the process of
      restoring heap order as a recursive method (though it would be
      straightforward avoid the recursion and use iteration here).
    </p><p id="idp9664176">
      The key property of private methods is that they are visible to
      subclasses, but not anywhere else. If you want the stronger
      guarantee that a method is <span><em>really</em></span> private,
      not even accessible in subclasses, you can use an explicit typing
      that omits the method. In the following code, the
      <code>move_up</code> method is explicitly omitted from the
      object type, and it can't be invoked in subclasses.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">binary_heap</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">min</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">method</span> <span class="k">private</span> <span class="n">move_up</span> <span class="n">i</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div></section><section><h1 id="virtual-classes-and-methods">Virtual classes and methods</h1><p id="idp9668832">
      A <span><em>virtual</em></span> class is a class where some methods
      or fields are declared, but not implemented. This should not be
      confused with the word &quot;virtual&quot; as it is used in C++.
      In C++, a &quot;virtual&quot; method uses dynamic dispatch,
      regular non-virtual methods use static dispatched. In OCaml,
      <span><em>all</em></span> methods use dynamic dispatch, but the
      keyword <span><em>virtual</em></span> means the method or field is
      not implemented.
    </p><p id="idp9671376">
      In the previous section, we defined a class
      <code>swappable_vector</code> that inherits from
      <code>array_vector</code> and adds a <code>swap</code>
      method. In fact, the <code>swap</code> method could be
      defined for any object with <code>get</code> and
      <code>set</code> methods; it doesn't have to be the specific
      class <code>array_vector</code>.
    </p><p id="idp9676928">
      One way to do this is to declare the
      <code>swappable_vector</code> abstractly, declaring the
      methods <code>get</code> and <code>set</code>, but
      leaving the implementation for later. However, the
      <code>swap</code> method can be defined immediately.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="n">abstract_swappable_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="n">i</span> <span class="k">in</span>
      <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="n">i</span> <span class="o">(</span><span class="n">self</span><span class="o">#</span><span class="n">get</span> <span class="n">j</span><span class="o">);</span>
      <span class="n">self</span><span class="o">#</span><span class="n">set</span> <span class="n">j</span> <span class="n">tmp</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9681856">
      At some future time, we may settle on a concrete implementation
      for the vector. We can inherit from the
      <code>abstract_swappable_bvector</code> to get the
      <code>swap</code> method &quot;for free.&quot; Here's one
      implementation using arrays.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">array_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">inherit</span> <span class="n">abstract_swappable_vector</span>

   <span class="k">val</span> <span class="k">mutable</span> <span class="n">values</span> <span class="o">=</span> <span class="o">[||]</span>
   <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
   <span class="k">method</span> <span class="n">set</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span>
      <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="n">i</span><span class="o">;</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">x</span>
   <span class="k">method</span> <span class="n">length</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span>

   <span class="k">method</span> <span class="k">private</span> <span class="n">ensure_capacity</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">self</span><span class="o">#</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="k">then</span>
         <span class="k">let</span> <span class="n">new_values</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">in</span>
            <span class="nn">Array</span><span class="p">.</span><span class="n">blit</span> <span class="n">values</span> <span class="mi">0</span> <span class="n">new_values</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">values</span><span class="o">);</span>
            <span class="n">values</span> <span class="o">&lt;-</span> <span class="n">new_values</span>
<span class="k">end</span>
</pre></div><p id="idp9686048">
      Here's a different implementation using
      <code>HashTbl</code>.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="n">hash_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">inherit</span> <span class="n">abstract_swappable_vector</span>

   <span class="k">val</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">19</span>

   <span class="k">method</span> <span class="n">get</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="n">i</span> <span class="k">with</span>
         <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="mi">0</span>

   <span class="k">method</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">table</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9688544">
      One way to view a <code>virtual</code> class is that it is
      like a functor, where the &quot;inputs&quot; are the declared, but
      not defined, virtual methods and fields. The functor application
      is implemented through inheritance, when virtual methods are given
      concrete implementations.
    </p><p id="idp9690304">
      We've been mentioning that fields can be virtual too. Here is
      another implementation of the swapper, this time with direct
      access to the array of values.
    </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="n">abstract_swappable_array_vector</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">val</span> <span class="k">mutable</span> <span class="k">virtual</span> <span class="n">values</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span>
   <span class="k">method</span> <span class="k">private</span> <span class="k">virtual</span> <span class="n">ensure_capacity</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

   <span class="k">method</span> <span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
      <span class="n">self</span><span class="o">#</span><span class="n">ensure_capacity</span> <span class="o">(</span><span class="n">max</span> <span class="n">i</span> <span class="n">j</span><span class="o">);</span>
      <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">);</span>
      <span class="n">values</span><span class="o">.(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9692144">
      This level of dependency on the implementation details is
      possible, but it is hard to justify the use of a virtual class --
      why not just define the <code>swap</code> method as part of
      the concrete class? Virtual classes are better suited for
      situations where there are multiple (useful) implementations of
      the virtual parts. In most cases, this will be public virtual
      methods.
    </p></section><section><h1 id="multiple-inheritance">Multiple inheritance</h1><p id="idp9694816">
      When a class inherits from more than one superclass, it is using
      <span><em>multiple inheritance</em></span>. Multiple inheritance
      extends the variety of ways in which classes can be combined, and
      it can be quite useful, particularly with virtual classes.
      However, it can be tricky to use, particularly when the
      inheritance hierarchy is a graph rather than a tree, so it should
      be used with care.
    </p><section><h1 id="how-names-are-resolved">How names are resolved</h1><p id="idp9697136">
        The main &quot;trickiness&quot; of multiple inheritance is due
        to naming -- what happens when a method or field with some name
        is defined in more than one class?
      </p><p id="idp9697920">
        If there is one thing to remember about inheritance in OCaml, it
        is this: inheritance is like textual inclusion. If there is more
        than one definition for a name, the last definition wins. Let's
        look at some artificial, but illustrative, examples.
      </p><p id="idp9698608">
        First, let's consider what happens when we define a method more
        than once. In the following example, the method
        <code>get</code> is defined twice; the second definition
        &quot;wins,&quot; meaning that it overrides the first one.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m1</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="k">method</span> <span class="n">f</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">get</span>
   <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m1</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">m1</span><span class="o">)#</span><span class="n">f</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9701248">
        Fields have similar behavior, though the compiler produces a
        warning message about the override.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m2</span> <span class="o">=</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m2</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
     <span class="k">method</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">69</span><span class="o">-</span><span class="mi">74</span><span class="o">:</span>
     <span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
         <span class="o">^^^^^</span>
<span class="nc">Warning</span> <span class="mi">13</span><span class="o">:</span> <span class="n">the</span> <span class="n">instance</span> <span class="n">variable</span> <span class="n">x</span> <span class="n">is</span> <span class="n">overridden</span><span class="o">.</span>
<span class="nc">The</span> <span class="n">behaviour</span> <span class="n">changed</span> <span class="k">in</span> <span class="n">ocaml</span> <span class="mi">3</span><span class="o">.</span><span class="mi">10</span> <span class="o">(</span><span class="n">previous</span> <span class="n">behaviour</span> <span class="n">was</span> <span class="n">hiding</span><span class="o">.)</span>
<span class="k">class</span> <span class="n">m2</span> <span class="o">:</span> <span class="k">object</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="o">(</span><span class="k">new</span> <span class="n">m2</span><span class="o">)#</span><span class="n">f</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9703424">
        Of course, it is unlikely that you will define two methods or
        two fields of the same name in the same class. However, the
        rules for inheritance follow the same pattern: the last
        definition wins. In the following definition, the
        <code>inherit</code> declaration comes last, so the method
        definition <code>method get = 2</code> overrides the
        previous definition, always returning 2.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m4</span> <span class="o">=</span> <span class="k">object</span> <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m5</span> <span class="o">=</span>
  <span class="k">object</span>
    <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">method</span> <span class="n">get</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">method</span> <span class="n">set</span> <span class="n">x'</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">x'</span>
    <span class="k">inherit</span> <span class="n">m4</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m5</span> <span class="o">:</span> <span class="k">object</span> <span class="k">val</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">get</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="n">set</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">m5</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m5</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">set</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">get</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp9707168">
        To reiterate, to understand what inheritance means, replace each
        <code>inherit</code> directive with its definition, and
        take the last definition of each method or field. This holds
        even for private methods. However, it does
        <span><em>not</em></span> hold for private methods that are
        &quot;really&quot; private, meaning that they have been hidden
        by a type constraint. In the following definitions, there are
        three definitions of the private method <code>g</code>.
        However, the definition of <code>g</code> in
        <code>m8</code> is not overridden, because it is not part
        of the class type for <code>m8</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="n">m6</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m6</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f1</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m7</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m7</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f2</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m8</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">g</span>
     <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="n">m8</span> <span class="o">:</span> <span class="k">object</span> <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m9</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">inherit</span> <span class="n">m6</span>
     <span class="k">inherit</span> <span class="n">m7</span>
     <span class="k">inherit</span> <span class="n">m8</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">m9</span> <span class="o">:</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">f1</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">f2</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="n">f3</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">method</span> <span class="k">private</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">int</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">m9</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m9</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">f1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">f3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></section><section><h1 id="mixins">Mixins</h1><p id="idp9715856">
        When should you use multiple inheritance? If you ask multiple
        people, you're likely to get multiple (perhaps heated) answers.
        Some will argue that multiple inheritance is overly complicated;
        others will argue that inheritance is problematic in general,
        and one should use object composition instead. But regardless of
        who you talk to, you will rarely hear that multiple inheritance
        is great and you should use it widely.
      </p><p id="idp9716736">
        In any case, if you're programming with objects, there's one
        general pattern for multiple inheritance that is both useful and
        reasonably simple, the <span><em>mixin</em></span> pattern.
        Generically, a <span><em>mixin</em></span> is just a virtual
        class that implements a feature based on another one. If you
        have a class that implements methods <span><em>A</em></span>, and
        you have a mixin <span><em>M</em></span> that provides methods
        <span><em>B</em></span> from <span><em>A</em></span>, then you can
        inherit from <span><em>M</em></span> -- &quot;mixing&quot; it in
        -- to get features <span><em>B</em></span>.
      </p><p id="idp9720976">
        That's too abstract, so let's give an example based on
        collections. In Section XXX:Objecttypes, we introduced the
        <span><em>iterator</em></span> pattern, where an
        <span><em>iterator</em></span> object is used to enumerate the
        elements of a collection. Lots of containers can have iterators,
        singly-linked lists, dictionaries, vectors, etc.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">vector</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">deque</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">]</span> <span class="n">map</span> <span class="o">:</span> <span class="k">object</span> <span class="o">...</span> <span class="k">method</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="n">iterator</span> <span class="k">end</span><span class="o">;;</span>
<span class="o">...</span>
</pre></div><p id="idp9724416">
        The collections are different is some ways, but they share a
        common pattern for iteration that we can re-use. For a simple
        example, let's define a mixin that implements an arithmetic sum
        for a collection of integers.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">class</span> <span class="k">virtual</span> <span class="n">int_sum_mixin</span> <span class="o">=</span>
  <span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
     <span class="k">method</span> <span class="k">virtual</span> <span class="n">iterator</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">iterator</span>
     <span class="k">method</span> <span class="n">sum</span> <span class="o">=</span>
        <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">total</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
        <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
           <span class="n">total</span> <span class="o">:=</span> <span class="o">!</span><span class="n">total</span> <span class="o">+</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
           <span class="n">it</span><span class="o">#</span><span class="n">next</span>
        <span class="k">done</span><span class="o">;</span>
        <span class="o">!</span><span class="n">total</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">int_slist</span> <span class="o">=</span>
  <span class="k">object</span>
     <span class="k">inherit</span> <span class="o">[</span><span class="kt">int</span><span class="o">]</span> <span class="n">slist</span>
     <span class="k">inherit</span> <span class="n">int_sum_mixin</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">int_slist</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">l</span> <span class="o">:</span> <span class="n">int_slist</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">insert</span> <span class="mi">12</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">l</span><span class="o">#</span><span class="n">sum</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span>
<span class="o">#</span> <span class="k">class</span> <span class="n">int_deque</span> <span class="o">=</span>
  <span class="k">object</span>
     <span class="k">inherit</span> <span class="o">[</span><span class="kt">int</span><span class="o">]</span> <span class="n">deque</span>
     <span class="k">inherit</span> <span class="n">int_sum_mixin</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9726896">
        In this particular case, the mixin works only for a collection
        of integers, so we can't add the mixin to the polymorphic class
        definition <code>['a] slist</code> itself. However, the
        result of using the mixin is that the integer collection has a
        method <code>sum</code>, and it is done with very little
        of the fuss we would need if we used object composition instead.
      </p><p id="idp9729056">
        The mixin pattern isn't limited to non-polymorphic classes, of
        course. We can use it to implement generic features as well. The
        following mixin defines functional-style iteration in terms of
        the imperative iterator pattern.
      </p><div class="highlight"><pre><span class="k">class</span> <span class="k">virtual</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">fold_mixin</span> <span class="o">=</span>
<span class="k">object</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="k">'</span><span class="n">self</span><span class="o">)</span>
   <span class="k">method</span> <span class="k">virtual</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
   <span class="k">method</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="o">.</span> <span class="o">(</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span>
            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">x</span> <span class="k">in</span>
            <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="o">#</span><span class="n">iterator</span> <span class="k">in</span>
            <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">do</span>
               <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">!</span><span class="n">y</span> <span class="n">it</span><span class="o">#</span><span class="n">get</span><span class="o">;</span>
               <span class="n">it</span><span class="o">#</span><span class="n">next</span>
            <span class="k">done</span><span class="o">;</span>
            <span class="o">!</span><span class="n">y</span><span class="o">)</span>
<span class="k">end</span><span class="o">;;</span>

<span class="k">class</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist_with_fold</span> <span class="o">=</span>
<span class="k">object</span>
   <span class="k">inherit</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">slist</span>
   <span class="k">inherit</span> <span class="o">[</span><span class="k">'</span><span class="n">a</span><span class="o">]</span> <span class="n">fold_mixin</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="concurrent-programming-with-async.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="pt03.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>