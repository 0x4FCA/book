<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 9. Imperative Programming / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha1',
                        page: 'imperative\u002Dprogramming\u002D1.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-json-xml-and-s-expressions.html">7. Data Serialization with JSON, XML and S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">8. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html" class="here">9. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">10. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors-and-first-class-modules.html">11. Functors and First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="input-and-output.html">12. Input and Output</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">13. Concurrent Programming with Async</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">14. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 9. Imperative Programming</h1>
                
                

    <p id="idp8358768">
    The OCaml programming language is <span><em>functional</em></span>,
    meaning that functions are first-class values that can be passed
    around like any other. However, this doesn't mean that OCaml
    programs are <span><em>pure</em></span>. The language includes
    assignment, mutable values like arrays and strings. Evaluation order
    is strict and sequential. In principle, you can port many imperative
    programs directly to OCaml. If you find yourself doing this a lot,
    then OCaml may not be the right programming language for your
    problem. However, there are times when imperative programming is
    both appropriate and efficient, and OCaml shines at supporting
    programs with both functional and imperative aspects.
  </p><p id="idp8360608">
    To illustrate imperative programming, let's start by implementing a
    hash table. Hash tables are an efficient way to implement imperative
    <span><em>dictionaries</em></span>. There are full-featured
    implementations of hash tables in Core as well as in the OCaml
    standard library. For illustration, we'll construct just a basic
    dictionary using <span><em>open hashing</em></span>, where the hash
    table consists of an array of buckets, each of which contain a
    linked list of elements. We'll use regular (pure) OCaml lists, and
    an array for the buckets.
  </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">HashMap</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span>
  <span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="kt">list</span> <span class="kt">array</span>

  <span class="k">let</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">17</span>
  <span class="k">let</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span><span class="o">)</span> <span class="ow">mod</span> <span class="n">num_buckets</span>

  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="n">num_buckets</span> <span class="bp">[]</span>

  <span class="k">let</span> <span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
    <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="o">::</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">find</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">::</span> <span class="o">_</span> <span class="k">when</span> <span class="n">k</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">d</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">find</span> <span class="n">t</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Not_found</span>
    <span class="k">in</span>
    <span class="n">find</span> <span class="n">table</span><span class="o">.(</span><span class="n">hash_bucket</span> <span class="n">key</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">iter</span> <span class="n">table</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">num_buckets</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">table</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span><span class="o">)</span>
    <span class="k">done</span>
<span class="k">end</span>
</pre></div><p id="idp8364384">
    The signature for the <code>HashMap</code> declares the type
    of dictionaries <code>('a, 'b) t</code>, with keys of type
    <code>'a</code> and associated values of type
    <code>'b</code>. It also includes three functions. The
    <code>create</code> function constructs an empty dictionary.
    The <code>add</code> function adds a key/value association in
    the dictionary, by <span><em>side-effect</em></span>. That is, the
    hash table is modified <span><em>in place</em></span>, and any
    references to the table will be able to observe the change.
    Furthermore, the <code>add</code> method doesn't return a
    useful value; the type <code>unit</code> contains just the
    trivial value <code>()</code>, which is used by convention to
    represent &quot;nothing.&quot; The <code>find</code> function
    returns the value associated with a key, raising the exception
    <code>Not_found</code> if the table does not contain the key.
    The <code>iter</code> function iterates through all of the
    elements in the table, applying the function <code>f</code> to
    each element in turn.
  </p><p id="idp8374144">
    The hash table is implemented as an array of buckets (the array is
    fixed-size, in this example). The OCaml runtime provides a builtin
    polymorphic hash function <code>Hashtbl.hash</code> that works
    for almost any value in OCaml, excluding functions and abstract
    values like C data. The <code>create</code> function creates a
    new array where all buckets are empty. The <code>add</code>
    function uses the hash function to determine the appropriate bucket,
    then adds a new key/value association to the bucket through an array
    <span><em>assignment</em></span>
<code>table.(index) &lt;- (key, data) :: table.(index)</code>,
    which <span><em>replaces</em></span> the bucket with a new one where
    the new key/value pair is added to the front of the list. The
    <code>find</code> function performs a linear search through
    the appropriate bucket to find the value associated with a key. The
    <code>iter</code> function iterates through each of the
    elements in the buckets.
  </p><section><h1 id="imperative-operations">Imperative operations</h1><p id="idp8380944">
      This example illustrates <span><em>one</em></span> of the mutating
      operations in OCaml: array field assignment. There are just three
      others: the contents of a string can be mutated, and so can record
      and object fields that have been declared as
      <code>mutable</code>.
    </p><ul><li><p id="idp8383088">
<code>array.(index) &lt;- expr</code>: Array field
          assignment. See also the <code>Array.blit</code>
          functions for mutating multiple fields at once.
        </p></li><li><p id="idp8385184">
<code>string.[index] &lt;- char</code>: String element
          assignment. See also the <code>String.blit</code>
          functions for mutating substrings.
        </p></li><li><p id="idp8387200">
<code>record.label &lt;- expr</code>: Record field
          assignment. The field <code>label</code> must be
          declared as <code>mutable</code>.
        </p></li><li><p id="idp8389840">
<code>object.label &lt;- expr</code>: Object field
          assignment. The field <code>label</code> must be
          declared as <code>mutable</code>.
        </p></li></ul><p id="idp8392352">
      Note that <span><em>variables are not mutable</em></span>.
      Variables can refer to mutable data, but the binding of a variable
      cannot be changed. For convenience, OCaml defines a type of
      &quot;reference cell,&quot; that is a like a &quot;box&quot; where
      the contents can be mutated.
    </p><ul><li><p id="idp8393952">
<code>ref expr</code> constructs a reference cell
          containing the value defined by the expression
          <code>expr</code>.
        </p></li><li><p id="idp8396080">
<code>! refcell</code> returns the contents of the
          reference cell.
        </p></li><li><p id="idp8397552">
<code>refcell := expr</code> replaces the contents of
          the reference cell.
        </p></li></ul><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">1</span><span class="o">}</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">7</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span>
<span class="o">#</span> <span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="mi">12</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">x</span><span class="o">.</span><span class="n">contents</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">12</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div><p id="idp8400000">
      As the example shows, reference cells are actually just a short
      form for record operations. The <code>ref</code> type is a
      record with a single mutable field <code>contents</code>,
      with the following definition. The expression
      <code>!x</code> is equivalent to
      <code>x.contents</code>, and <code>x := e</code> is
      equivalent to <code>x.contents &lt;- e</code>.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="n">contents</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">};;</span>
</pre></div></section><section><h1 id="looping">Looping</h1><p id="idp8406208">
      The <code>iter</code> function iterates through all of the
      elements in the table using a <code>for</code> loop. There
      are two kinds of loops in OCaml, <code>for</code> loops and
      <code>while</code> loops.
    </p><div class="highlight"><pre><span class="k">for</span> <span class="n">index</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">initial</span><span class="o">&gt;</span> <span class="k">to</span> <span class="o">&lt;</span><span class="n">final</span><span class="o">&gt;</span> <span class="k">do</span> <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span> <span class="k">done</span>
<span class="k">for</span> <span class="n">index</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">initial</span><span class="o">&gt;</span> <span class="k">downto</span> <span class="o">&lt;</span><span class="n">final</span><span class="o">&gt;</span> <span class="k">do</span> <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span> <span class="k">done</span>
<span class="k">while</span> <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span> <span class="k">do</span> <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span> <span class="k">done</span>
</pre></div><p id="idp8410208">
      A loop
      <code>for index = &lt;initial&gt; to &lt;final&gt; do &lt;body&gt; done</code>
      advances by from the <code>&lt;initial&gt;</code> integer to
      the <code>&lt;final&gt;</code> one (inclusive). The
      iterations are evaluated if <code>&lt;final&gt;</code> is
      smaller than <code>&lt;initial&gt;</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span>
  <span class="k">done</span><span class="o">;;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8415024">
      A downto loop
      <code>for = &lt;initial&gt; downto &lt;final&gt; do &lt;body&gt; done</code>
      advances downward by 1 on each iteration.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span> <span class="k">done</span><span class="o">;;</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8417168">
      A while-loop iterates until the condition is false.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">0</span><span class="o">}</span>
<span class="o">#</span> <span class="k">while</span> <span class="o">!</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">do</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">!</span><span class="n">i</span><span class="o">;</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">!</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">done</span><span class="o">;;</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="k">while</span> <span class="o">!</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">do</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">!</span><span class="n">i</span><span class="o">;</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">!</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">done</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">i</span><span class="o">;;</span>  
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></section><section><h1 id="doubly-linked-lists">Doubly-linked lists</h1><p id="idp8419920">
      Another common imperative data structure is the doubly-linked
      list, which allows traversal in both directions, as well as O(1)
      deletion of any element. Doubly-linked lists are a
      <span><em>cyclic</em></span> data structure, meaning that it is
      possible to follow a nontrivial sequence of references from an
      element, through other elements, back to itself. Cyclic data
      structures can be constructed only through side-effects, by
      constructing a set of data elements first, then using assignment
      to set up the references. (Some kinds of cyclic data structures
      can also be constructed with <code>let rec</code>.)
    </p><p id="idp8421968">
      For doubly-linked lists, we define an element
      <code>'a element</code> with a reference both to the
      previous and next elements. The elements at the ends have nothing
      to refer to, so we use an option to allow the reference to be
      <code>None</code>. The element record fields are declared as
      <code>mutable</code> to allow them to be modified when the
      list is mutated.
    </p><p id="idp8424576">
      The list itself is either empty, or it refers to the first element
      of the list. We use the type
      <code>type 'a dlist = 'a element option ref</code>; the
      <code>ref</code> allows the list to be mutated, and the
      value is either <code>None</code> for the empty list, or
      <code>Some first_element</code> if the list is non-empty.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="o">=</span>
  <span class="o">{</span> <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">next</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">previous</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span>
  <span class="o">}</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">dlist</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="n">element</span> <span class="n">option</span> <span class="n">ref</span>

<span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>

<span class="k">let</span> <span class="n">is_empty</span> <span class="n">l</span> <span class="o">=</span> <span class="o">(!</span><span class="n">l</span> <span class="o">=</span> <span class="nc">None</span><span class="o">)</span>
</pre></div><p id="idp8428768">
      The function <code>create</code> creates an empty list. The
      function <code>is_empty l</code> dereferences the list using
      the <code>!</code> operator, returning true if the value is
      <code>None</code>, or false otherwise.
    </p><p id="idp8431648">
      Next, let's define the function that inserts a value onto the
      front of the list as a new first element. We define a new element
      <code>new_front</code>, link in the new element, and set the
      list references.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">push_front</span> <span class="n">l</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">new_front</span> <span class="o">=</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">previous</span> <span class="o">=</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">in</span>
  <span class="k">begin</span> <span class="k">match</span> <span class="o">!</span><span class="n">l</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Some</span> <span class="n">el</span> <span class="o">-&gt;</span>
     <span class="n">el</span><span class="o">.</span><span class="n">previous</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">new_front</span><span class="o">;</span>
     <span class="n">new_front</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="nc">Some</span> <span class="n">el</span>
   <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
     <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>
  <span class="n">l</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">new_front</span>
</pre></div><p id="idp8434032">
      This example introduces the <span><em>sequencing</em></span>
      operator <code>;</code>. In the case where the list is
      non-empty (the <code>Some el</code> case in the
      <code>match</code>), we first set
      <code>el.previous</code> to refer to the
      <code>new_front</code> element, and next set
      <code>new_front.next</code> to refer to
      <code>el</code>.
    </p><p id="idp8439168">
      In general, when a sequence expression
      <code>expr1; expr2</code> is evaluated,
      <code>expr1</code> is evaluated first, and then
      <code>expr2</code>. The expression <code>expr1</code>
      must have type <code>unit</code>, and the the value of
      <code>expr2</code> is returned as the value of the entire
      sequence. So, for example, the sequence
      <code>print_string &quot;hello world&quot;; 1 + 2</code>
      first prints the string
      <code>&quot;hello world&quot;</code>, then returns the
      integer <code>3</code>.
    </p><p id="idp8445376">
      There are a few more things to note. First, semicolon
      <code>;</code> is a <span><em>separator</em></span>, not a
      terminator, like it is in C or Java. The compiler is somewhat
      relaxed about parsing a terminating semicolon, so it may work for
      you, but you should not rely on it.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">print_string</span> <span class="s2">&quot;Hello world</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="k">in</span> <span class="n">i</span><span class="o">;;</span>
<span class="nc">Hello</span> <span class="n">world</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp8448112">
      Also note, the precedence of a <code>match</code> expression
      is very low, so to separate it from the following assignment
      <code>l := Some new_front</code>, we surround the match in a
      <code>begin ... end</code> bracketing (we could also use
      parentheses). If we did not, the final assignment would become
      part of the <code>None -&gt; ...</code> case, which is not
      what we want.
    </p><p id="idp8451216">
      To complete this initial part of the implementation, let's define
      function <code>front</code> to return the first element, and
      <code>pop_front</code> to remove it.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">front</span> <span class="o">=</span> <span class="k">function</span>
 <span class="o">|</span> <span class="o">{</span> <span class="n">contents</span> <span class="o">=</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span> <span class="o">}</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="n">v</span>
 <span class="o">|</span> <span class="o">{</span> <span class="n">contents</span> <span class="o">=</span> <span class="nc">None</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;front&quot;</span><span class="o">)</span>

<span class="k">let</span> <span class="n">pop_front</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="o">!</span><span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="nc">None</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="n">l</span> <span class="o">:=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">v</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Some</span> <span class="n">el</span><span class="o">)</span> <span class="k">as</span> <span class="n">next</span> <span class="o">}</span> <span class="o">-&gt;</span>
    <span class="n">l</span> <span class="o">:=</span> <span class="n">next</span><span class="o">;</span>
    <span class="n">el</span><span class="o">.</span><span class="n">previous</span> <span class="o">&lt;-</span> <span class="nc">None</span><span class="o">;</span>
    <span class="n">v</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;pop_front&quot;</span><span class="o">)</span>
</pre></div><p id="idp8454240">
      For illustration the <code>front</code> function uses
      pattern matching on the reference cell -- it would be equivalent
      to write an explicit dereference
      <code>let front l = match !l with Some { value = v } -&gt; v | None -&gt; ...</code>.
    </p><p id="idp8456128">
      The function <code>pop_front</code> performs the unlinking.
      There are three cases, 1) the list has one element, so it becomes
      empty, 2) the list has more than one element, so the second
      element is relinked, or 3) the list is empty, which is an error.
      In the second case, the list <code>l</code> is set to point
      to the second element, the <code>previous</code> field is
      set to <code>None</code>, and <code>v</code> is
      returned.
    </p></section><section><h1 id="iteration">Iteration</h1><p id="idp8460928">
      When defining containers like lists, dictionaries, trees, etc. it
      is conventional to define some kind of iteration to allow the
      elements of the collection to be enumerated. When the containers
      are immutable, like <code>'a list</code>, this is normaly
      done with functions like <code>iter</code>,
      <code>map</code>, and <code>fold</code>. Each of these
      iteration functions takes a function that will be applied to each
      of the elements in order.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span>  <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Element: %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span><span class="o">);;</span>
<span class="nc">Element</span><span class="o">:</span> <span class="mi">1</span>
<span class="nc">Element</span><span class="o">:</span> <span class="mi">2</span>
<span class="nc">Element</span><span class="o">:</span> <span class="mi">3</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span> <span class="o">~</span><span class="n">f</span><span class="o">:((+)</span> <span class="mi">10</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">11</span><span class="o">;</span> <span class="mi">12</span><span class="o">;</span> <span class="mi">13</span><span class="o">]</span>
</pre></div><p id="idp8465472">
      Defining this for doubly-linked lists is simple enough. The
      following function iterates through the list, applying the
      function <code>f</code> to each element in turn.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">iter</span> <span class="n">l</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">function</span>
   <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">v</span><span class="o">;</span> <span class="n">loop</span> <span class="n">next</span>
   <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="o">!</span><span class="n">l</span><span class="o">;;</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">create</span> <span class="bp">()</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">2</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">3</span><span class="o">;</span>
  <span class="nn">DList</span><span class="p">.</span><span class="n">iter</span> <span class="n">l</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Item: %d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">);;</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">3</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">2</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">1</span>
</pre></div><p id="idp8468112">
      This style of iteration is concise and completely general.
      However, with imperative containers, we often want more control.
      We may not want to iterate through all elements, and we often want
      to mutate the container as we iterate. One conventional way to do
      this is to define a generic <code>iterator</code> type that
      can be used to enumerate and/or mutate the elements in a
      container. This is a style seen, for example, in Java (type
      <code>Iterator</code>) or the C++ Standard Template Library.
    </p><p id="idp8470240">
      Let's define a Java-style kind of generic iterator object that
      allows manual enumeration and mutation of the container. Here is
      the Java interface.
    </p><div class="highlight"><pre><span class="kd">public</span> <span class="n">iterface</span> <span class="n">Iterator</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">next</span><span class="o">();</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">();</span>
<span class="o">};</span>
</pre></div><p id="idp8471808">
      At any time, a <code>Iterator</code> object refers
      (optionally) to some element of a container. The
      <code>hasNext()</code> method returns true if the iterator
      refers to an element; the method <code>next()</code> returns
      the element, and also advances to the next one; and
      <code>remove()</code> removes the last element returned by
      the iterator.
    </p><p id="idp8475056">
      When we define a similar iterator concept in OCaml, we need to
      choose how to represent it. We <span><em>could</em></span> define a
      separate iterator type for each kind of container, but this would
      be inconvenient, since iterators have similar behavior for many
      different kinds of containers. To define a
      <span><em>generic</em></span> iterator, there are several
      reasonable choices: we can use first-class modules, or we can use
      objects. The simpler approach is to use objects.
    </p><p id="idp8476736">
      You can skip forward to the Objects chapter for more informatation
      about objects, but we'll be using basic objects, which are just
      collections of methods, similar to having a record of functions --
      we could also implement the iterator as a record of functions, but
      the code would be somewhat more verbose.
    </p><p id="idp8477472">
      First, we need to define a generic iterator type. For clarity,
      we'll use a more verbose type than in Java. We'll separate
      retrieving a value from advacing to the next element. The object
      type is specified like a record type, but using angle brackets
      <code>&lt; ... &gt;</code>.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span> <span class="o">=</span>
   <span class="o">&lt;</span> <span class="n">has_value</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">unit</span><span class="o">;</span> <span class="n">remove</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">&gt;</span>
</pre></div><p id="idp8479872">
      Each of the labeled parts <code>has_value</code>,
      <code>value</code>, etc. are object
      <span><em>methods</em></span>. This object type corresponds to an
      <span><em>interface</em></span> consisting of a set of methods.
    </p><p id="idp8482272">
      Next, to define the iterator implementation, we implement each of
      the methods, bracketed by <code>object ... end</code>,
      declaring each method with the <code>method</code> keyword.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">iterator</span> <span class="o">(</span><span class="kt">list</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">!</span><span class="kt">list</span> <span class="k">in</span>
  <span class="k">object</span>
    <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="o">!</span><span class="n">current</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>
    <span class="k">method</span> <span class="n">value</span> <span class="o">=</span>
      <span class="k">match</span> <span class="o">!</span><span class="n">current</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="n">v</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;next&quot;</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
      <span class="k">match</span> <span class="o">!</span><span class="n">current</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="n">current</span> <span class="o">:=</span> <span class="n">next</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;next&quot;</span><span class="o">)</span>
    <span class="k">method</span> <span class="n">remove</span> <span class="o">=</span>
      <span class="k">match</span> <span class="o">!</span><span class="n">current</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span> <span class="o">}</span> <span class="o">-&gt;</span>
            <span class="o">(</span><span class="k">match</span> <span class="n">previous</span> <span class="k">with</span>
              <span class="o">|</span> <span class="nc">Some</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">el</span><span class="o">.</span><span class="n">next</span> <span class="o">&lt;-</span> <span class="n">next</span>
              <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="kt">list</span> <span class="o">:=</span> <span class="n">next</span><span class="o">);</span>
            <span class="o">(</span><span class="k">match</span> <span class="n">next</span> <span class="k">with</span>
              <span class="o">|</span> <span class="nc">Some</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">el</span><span class="o">.</span><span class="n">previous</span> <span class="o">&lt;-</span> <span class="n">previous</span><span class="o">;</span>
              <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
            <span class="n">current</span> <span class="o">:=</span> <span class="n">next</span>
       <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;remove&quot;</span><span class="o">)</span>
  <span class="k">end</span>
</pre></div><p id="idp8486032">
      The reference cell <code>current</code> holds the current
      position in the list. The method <code>has_value</code>
      returns true if <code>current</code> refers to an element,
      <code>value</code> returns the element, and
      <code>next</code> advances the iterator. The method
      <code>remove</code> unlinks the <code>current</code>
      element by setting the previous element's <code>next</code>
      pointer, and the next's elements <code>previous</code>
      pointer, then advancing <code>current</code> to the next
      element. The following example illustrates the semantics.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">create</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">l</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="n">dlist</span>
<span class="o">#</span> <span class="n">push_front</span> <span class="n">l</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">2</span><span class="o">;</span>
  <span class="n">push_front</span> <span class="n">l</span> <span class="mi">3</span><span class="o">;</span>
  <span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Item: %d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span> <span class="n">l</span><span class="o">;;</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">3</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">2</span>
<span class="nc">Item</span><span class="o">:</span> <span class="mi">1</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">iterator</span> <span class="n">l</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">iterator</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">remove</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">next</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span> <span class="n">l</span><span class="o">;;</span>
<span class="mi">3</span>
<span class="mi">1</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp8494608">
      Note that the doubly-linked list is a <span><em>cyclic</em></span>
      data structure. Most notably, the builtin equality <span><em>does
      not work</em></span> in general with cyclic values.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">create</span><span class="bp">()</span><span class="o">;</span>
<span class="k">val</span> <span class="n">l2</span> <span class="o">:</span> <span class="k">'</span><span class="o">_</span><span class="n">a</span> <span class="n">dlist</span>
<span class="o">#</span> <span class="n">push_front</span> <span class="n">l2</span> <span class="mi">1</span><span class="o">;</span> <span class="n">push_front</span> <span class="n">l2</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">l</span> <span class="o">==</span> <span class="n">l2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;;</span>
<span class="nc">Out</span> <span class="k">of</span> <span class="n">memory</span> <span class="n">during</span> <span class="n">evaluation</span><span class="o">.</span>
</pre></div></section><section><h1 id="doubly-linked-list-module">Doubly-linked list module</h1><p id="idp8497888">
      Now that we have defined iterators, let's declare the complete
      signature for doubly-linked lists as a module. The type of
      elements <code>'a element</code> is internal to the
      implementation, and the type of lists
      <code>'a DList.t</code> is abstract.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">DList</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">push_front</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">val</span> <span class="n">front</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
   <span class="k">val</span> <span class="n">pop_front</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
   <span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">val</span> <span class="n">iterator</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
   <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">iterator</span>
<span class="k">end</span>
</pre></div><p id="idp8501232">
      We have seen the definition of all of the functions except
      <code>find</code>, which searches for an element in the list
      (sequentially), returning an iterator that refers to that element
      if it exists. The implementation simply creates an iterator, then
      uses a loop to search sequentially for the element. If the element
      is found, the returned iterator refers to that value, otherwise
      the iterator does not have a value.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">DList</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="o">...</span>

   <span class="k">let</span> <span class="n">find</span> <span class="n">l</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">iterator</span> <span class="n">l</span> <span class="k">in</span>
     <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span> <span class="o">&lt;&gt;</span> <span class="n">data</span> <span class="k">do</span>
        <span class="n">it</span><span class="o">#</span><span class="n">next</span>
     <span class="k">done</span><span class="o">;</span>
     <span class="n">it</span>
<span class="k">end</span>
</pre></div></section><section><h1 id="hash-tables-with-iterators">Hash tables with iterators</h1><p id="idp8504832">
      Let's return to the example of hash tables, but this time let's
      define an iterator-style interface. We'll use the same
      <code>iterator</code> object type as we did for
      doubly-linked lists, but this time the iteration is over key/value
      pairs. The signature changes slightly, the main change being tat
      the <code>find</code> function returns an iterator. This
      allows retrieval of the value associated with a key, and it also
      allows the entry to be deleted.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">IterableHashMap</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">iterator</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">iterator</span>
  <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">iterator</span>
<span class="k">end</span>
</pre></div><p id="idp8508208">
      The implementation of <code>IterableHashMap</code> is
      similar to the original <code>HashMap</code> using lists,
      except now we will use doubly-linked lists. The
      <code>create</code> function creates an array of
      doubly-linked lists. The <code>add</code> function first
      removes any existing entry, then add the new element to the front
      of the bucket.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">IterableHashMap</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">DList</span><span class="p">.</span><span class="n">t</span> <span class="kt">array</span>

  <span class="k">let</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">17</span>
  <span class="k">let</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span><span class="o">)</span> <span class="ow">mod</span> <span class="n">num_buckets</span>

  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">num_buckets</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nn">DList</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">DList</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">~</span><span class="n">data</span><span class="o">:(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">then</span> <span class="n">it</span><span class="o">#</span><span class="n">remove</span><span class="o">;</span>
    <span class="nn">DList</span><span class="p">.</span><span class="n">push_front</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span>

  <span class="o">...</span>
<span class="k">end</span>
</pre></div><p id="idp8513600">
      We can define iterators in the hash table as a pair of a bucket
      index and <code>DList</code> iterator into the bucket. To
      define this as an object, we'll introduce a few more object
      concepts, including mutable fields, private methods, and
      initializers. The function
      <code>make_iterator table index_ dlist_it_</code> returns an
      iterator for the bucket with index <code>index_</code> and
      list iterator <code>dlist_it_</code>.
    </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">make_iterator</span> <span class="n">table</span> <span class="n">index_</span> <span class="n">dlist_it_</span> <span class="o">=</span>
    <span class="k">object</span> <span class="o">(</span><span class="n">self</span><span class="o">)</span>
      <span class="k">val</span> <span class="k">mutable</span> <span class="n">index</span> <span class="o">=</span> <span class="n">index_</span>
      <span class="k">val</span> <span class="k">mutable</span> <span class="n">dlist_it</span> <span class="o">=</span> <span class="n">dlist_it_</span>
      <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">dlist_it</span><span class="o">#</span><span class="n">has_value</span>
      <span class="k">method</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dlist_it</span><span class="o">#</span><span class="n">value</span>
      <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
         <span class="n">dlist_it</span><span class="o">#</span><span class="n">next</span><span class="o">;</span>
         <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
      <span class="k">method</span> <span class="n">remove</span> <span class="o">=</span>
         <span class="n">dlist_it</span><span class="o">#</span><span class="n">remove</span><span class="o">;</span>
         <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
      <span class="k">method</span> <span class="k">private</span> <span class="n">normalize</span> <span class="o">=</span>
        <span class="k">while</span> <span class="n">not</span> <span class="n">dlist_it</span><span class="o">#</span><span class="n">has_value</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">num_buckets</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="n">index</span> <span class="o">&lt;-</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
          <span class="n">dlist_it</span> <span class="o">&lt;-</span> <span class="nn">DList</span><span class="p">.</span><span class="n">iterator</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span>
        <span class="k">done</span>
      <span class="k">initializer</span> <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
    <span class="k">end</span>
</pre></div><p id="idp8518512">
      The iterator implementation relies on a &quot;normal&quot; form,
      where the list iterator <span><em>always</em></span> refers to an
      element. This is handled by the <code>normalize</code>
      method, which advances past empty buckets until either a non-empty
      bucket is found, or the end of the table is reached.
    </p><p id="idp8520176">
      The <code>normalize</code> method is declared a
      <code>private</code>, so that it does not appear as part of
      the iterator type. The <code>has_value</code> and
      <code>value</code> methods delagate directly to the list
      iterator. The <code>next</code> and
      <code>remove</code> methods also delagate to the list
      iterator; however, since the iterator has been mutated, the
      <code>normalize</code> method is called to advance to the
      next element.
    </p><p id="idp8525296">
      There are several more things to note. The syntax
      <code>object (self) ... end</code> means that the variable
      <code>self</code> refers to the object itself, allowing
      other method in the object to be called (like
      <code>self#normalize</code>). The fields
      <code>index</code> and <code>dlist_it</code> are
      declared as <code>val mutable</code>, which means that they
      can be modified by assignment using the <code>&lt;-</code>
      syntax seen in the <code>normalize</code> method. Finally,
      the object also has an <code>initializer</code> expression,
      which is called when the object is first created, in this case
      normalizing the iterator.
    </p><p id="idp8531696">
      Now that the iterator is defined, we can complete the
      <code>IterableHashMap</code> implementation.
    </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">iterator</span> <span class="n">table</span> <span class="o">=</span>
    <span class="n">make_iterator</span> <span class="n">table</span> <span class="mi">0</span> <span class="o">(</span><span class="nn">DList</span><span class="p">.</span><span class="n">iterator</span> <span class="n">table</span><span class="o">.(</span><span class="mi">0</span><span class="o">))</span>

  <span class="k">let</span> <span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash_bucket</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">DList</span><span class="p">.</span><span class="n">iterator</span> <span class="n">table</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">while</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="o">&amp;&amp;</span> <span class="n">fst</span> <span class="n">it</span><span class="o">#</span><span class="n">value</span> <span class="o">&lt;&gt;</span> <span class="n">key</span> <span class="k">do</span>
      <span class="n">it</span><span class="o">#</span><span class="n">next</span>
    <span class="k">done</span><span class="o">;</span>
    <span class="k">if</span> <span class="n">it</span><span class="o">#</span><span class="n">has_value</span> <span class="k">then</span>
       <span class="n">make_iterator</span> <span class="n">table</span> <span class="n">index</span> <span class="n">it</span>
    <span class="k">else</span>
       <span class="n">make_iterator</span> <span class="n">table</span> <span class="n">num_buckets</span> <span class="n">it</span>
</pre></div><p id="idp8534080">
      The <code>iterator</code> function returns in iterator that
      refers to the first element in the table (if the table is
      non-empty). The <code>find</code> function searches for an
      element in the table, returning an iterator referring to that
      value if found, or else the an iterator at the end of the table.
    </p></section><section><h1 id="lazy-computation">Lazy computation</h1><p id="idp8537056">
      There are many instances where imperative programming is used to
      change or improve the performance characteristics of a program,
      without otherwise changing the behavior. In other words, the
      program could be written without side-effects, but performance is
      improved by techniques like lazy computation, caching,
      memoization, etc.
    </p><p id="idp8537824">
      One of the simplest of these is the builtin lazy computation. The
      keyword <code>lazy</code> can be used to prefix any
      expression, returning a value of type
      <code>'a Lazy.t</code>. The computation is delayed until
      forced with the <code>Lazy.force</code> function, and then
      saved thereafter.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">lazy</span> <span class="o">(</span><span class="n">print_string</span> <span class="s2">&quot;performing lazy computation</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span> <span class="mi">1</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">v</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">lazy_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">lazy</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="n">performing</span> <span class="k">lazy</span> <span class="n">computation</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">v</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div><p id="idp8541408">
      The builtin <code>lazy</code> computation has a nice syntax,
      but the technique is pretty generic, and we can implement it with
      a mutable value.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">ImpLazy</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">force</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">delayed</span> <span class="o">=</span> <span class="nc">Delayed</span> <span class="k">of</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">|</span> <span class="nc">Value</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="n">delayed</span> <span class="n">ref</span>

   <span class="k">let</span> <span class="n">create</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="nc">Delayed</span> <span class="n">f</span><span class="o">)</span>
   <span class="k">let</span> <span class="n">force</span> <span class="n">v</span> <span class="o">=</span>
     <span class="k">match</span> <span class="o">!</span><span class="n">v</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Delayed</span> <span class="n">f</span> <span class="o">-&gt;</span>
           <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span>
           <span class="n">v</span> <span class="o">:=</span> <span class="nc">Value</span> <span class="n">x</span><span class="o">;</span>
           <span class="n">x</span>
      <span class="o">|</span> <span class="nc">Value</span> <span class="n">x</span> <span class="o">-&gt;</span>
           <span class="n">x</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8544320">
      The <code>'a delayed</code> type contains a delayed value
      represented as a function, or else an actual value. The
      <code>ImpLazy.force</code> function forces the computation;
      if it is delayed, the function is evaluated, and the value is
      mutated to save the resulting value. Subsequent calls to
      <code>ImpLazy.force</code> will fall into the
      <code>Value</code> case, without needing to reevaluate the
      function. The main difference between our module
      <code>ImpLazy</code> and the builtin module
      <code>Lazy</code> is the nice syntax for the latter. Rather
      than writing <code>ImpLazy.create (fun () -&gt; e)</code>,
      the builtin syntax is just <code>lazy e</code>.
    </p><section><h1 id="memoization">Memoization</h1><p id="idp8551072">
        We can generalize lazy computations to function
        <span><em>memoization</em></span>, where we save the result of
        function applications to avoid their recomputation. One simple
        implementation is to use a hash table to save the values by side
        effect.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Memo</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">apply</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">arg</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">t</span>

   <span class="k">let</span> <span class="n">create</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">create</span>
   <span class="k">let</span> <span class="n">apply</span> <span class="n">table</span> <span class="o">~</span><span class="n">func</span> <span class="o">~</span><span class="n">arg</span> <span class="o">=</span>
      <span class="k">try</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">arg</span> <span class="k">with</span>
         <span class="nc">Not_found</span> <span class="o">-&gt;</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">func</span> <span class="n">arg</span> <span class="k">in</span>
            <span class="nn">HashMap</span><span class="p">.</span><span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">arg</span> <span class="o">~</span><span class="n">data</span><span class="o">:</span><span class="n">x</span><span class="o">;</span>
            <span class="n">x</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8553920">
        Memoization is useful for <span><em>dynamic
        programming</em></span>, where problems are solved by breraking
        them down into simpler subproblems. If subproblems occur more
        than once, memoization can be used to avoid recomputing the
        subproblem. A canonical example of this is the Fibonacci
        sequence, which is defined by the following program, which
        produces the sequence <span><em>0, 1, 1, 2, 3, 5, 8, 13, 21,
        ...</em></span> starting from 0.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">=</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);;</span>
</pre></div><p id="idp8556480">
        The complexity of this function is exponential
        <span><em>O(2^i)</em></span>, because for large inputs the
        function computes two similar-sized subproblems. To illustrate,
        let's time the computation using the <code>Sys.time</code>
        function to measure the wall clock.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">time</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">time</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="k">in</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Time: %g sec</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">time</span> <span class="bp">()</span> <span class="o">-.</span> <span class="n">start</span><span class="o">);</span>
    <span class="n">y</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">time</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">time</span> <span class="n">fib</span> <span class="mi">40</span><span class="o">;;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mi">5</span><span class="o">.</span><span class="mi">53724</span> <span class="n">sec</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">102334155</span>
</pre></div><p id="idp8559344">
        Next, let's construct a memoized version of the function, where
        the recursive calls are made through a memo table. This makes a
        dramatic improvement in performance. Since the recursive calls
        are computed just once, the complexity is linear, and the
        computation is fast.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">memo_fib</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">memo</span> <span class="o">=</span> <span class="nn">Memo</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span>
         <span class="n">i</span>
      <span class="k">else</span>
         <span class="nn">Memo</span><span class="p">.</span><span class="n">apply</span> <span class="n">memo</span> <span class="o">~</span><span class="n">func</span><span class="o">:</span><span class="n">fib</span> <span class="o">~</span><span class="n">arg</span><span class="o">:(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span>
         <span class="nn">Memo</span><span class="p">.</span><span class="n">apply</span> <span class="n">memo</span> <span class="o">~</span><span class="n">func</span><span class="o">:</span><span class="n">fib</span> <span class="o">~</span><span class="n">arg</span><span class="o">:(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="n">fib</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">memo_fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">time</span> <span class="n">memo_fib</span> <span class="mi">40</span><span class="o">;;</span>
<span class="nc">Time</span><span class="o">:</span> <span class="mf">3.7e-05</span> <span class="n">sec</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">102334155</span>
</pre></div><p id="idp8561616">
        Note that this use of memoization relies on side-effects to
        cache intermediate computations, but it doesn't change the
        values of the function. Its purpose is to improve performance.
      </p></section><section><h1 id="hash-consing">Hash consing</h1><p id="idp8563232">
        &quot;Hash consing&quot; is a technique to share values that are
        structurally equal. The term comes from Lisp, where the
        technique is used to share s-expressions that are equal. In some
        situations, hash-consing can result in dramatic performance
        improvements in two ways. First, space can be reduced by using a
        single physical representation for values that are equal.
        Second, values can be compared for equality using the
        constant-time physical equality operator <code>==</code>.
      </p><p id="idp8565376">
        One of the simplest ways to implement hash-consing is to use a
        hash-table to remember (memoize) values that have already been
        created. To illustrate, let's define a kind of numerical
        expression <code>Exp.t</code> consisting of integers,
        variables, addition, and multiplication (we can define more
        operators, but let's keep the example simple).
      </p><p id="idp8566800">
        The type <code>Exp.t</code> is declared as
        <code>private</code>, meaning that pattern matching can be
        used on the expressions outside the module, but expressions
        can't be constructed without explicitly using the constructors
        <code>num</code>, <code>var</code>,
        <code>plus</code>, <code>times</code> provided by
        the <code>Exp</code> module. These functions enforce the
        hash-consing, ensuring that structurally equal expressions are
        mapped to physically equal representations.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Exp</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="k">private</span>
   <span class="o">|</span> <span class="nc">Num</span> <span class="k">of</span> <span class="kt">int</span>
   <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
   <span class="o">|</span> <span class="nc">Plus</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
   <span class="o">|</span> <span class="nc">Times</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">num</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">var</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">times</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span>
   <span class="o">|</span> <span class="nc">Num</span> <span class="k">of</span> <span class="kt">int</span>
   <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
   <span class="o">|</span> <span class="nc">Plus</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
   <span class="o">|</span> <span class="nc">Times</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">let</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span>
  <span class="k">let</span> <span class="n">merge</span> <span class="n">exp</span> <span class="o">=</span>
     <span class="k">try</span> <span class="nn">HashMap</span><span class="p">.</span><span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">exp</span> <span class="k">with</span>
        <span class="nc">Not_found</span> <span class="o">-&gt;</span>
           <span class="nn">HashMap</span><span class="p">.</span><span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="n">exp</span> <span class="o">~</span><span class="n">data</span><span class="o">:</span><span class="n">exp</span><span class="o">;</span>
           <span class="n">exp</span>

  <span class="k">let</span> <span class="n">num</span> <span class="n">i</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">i</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">var</span> <span class="n">s</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Var</span> <span class="n">s</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">plus</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Plus</span> <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>
  <span class="k">let</span> <span class="n">times</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Times</span> <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8573760">
        The implementation defines a hash table
        <code>table</code>, and a <code>merge</code>
        function that merges an expression into the table, returning the
        previous value if there was one, or inserting a new value if
        there is not. The constructors can rely on the fact that
        subexpressions have already been hash-consed, so they simply
        call the merge function to memoize the value.
      </p><p id="idp8575824">
        Note that expressions that are structurally equal are now also
        physically equal.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">e1</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">num</span> <span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;x&quot;</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;y&quot;</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">e1</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;x&quot;</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span><span class="o">))</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">e2</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">num</span> <span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;x&quot;</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;y&quot;</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">e2</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;x&quot;</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span><span class="o">))</span>
<span class="o">#</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div><p id="idp8577568">
        Expressions that are not equal are equal are not physically
        equal either, however common subexpressions are equal.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">e3</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">num</span> <span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;z&quot;</span><span class="o">)</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="n">var</span> <span class="s2">&quot;y&quot;</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">e3</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(</span><span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;z&quot;</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span><span class="o">))</span>
<span class="o">#</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e3</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="k">let</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(_,</span> <span class="n">a2</span><span class="o">))</span> <span class="o">=</span> <span class="n">e1</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">a1</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span>
<span class="k">val</span> <span class="n">a2</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span>
<span class="o">#</span> <span class="k">let</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Times</span> <span class="o">(</span><span class="n">b1</span><span class="o">,</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Plus</span> <span class="o">(_,</span> <span class="n">b2</span><span class="o">))</span> <span class="o">=</span> <span class="n">e3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">b1</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Num</span> <span class="mi">10</span>
<span class="k">val</span> <span class="n">b2</span> <span class="o">:</span> <span class="nn">Exp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Exp</span><span class="p">.</span><span class="nc">Var</span> <span class="s2">&quot;y&quot;</span>
<span class="o">#</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">b1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">a2</span> <span class="o">==</span> <span class="n">b2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div></section><section><h1 id="weak-hash-consing">Weak hash consing</h1><p id="idp8580896">
        There is two issues with hash-consing as we have just defined
        it. A minor problem is that hashing is linear in the size of the
        expression. This can be fixed by storing the hash code in the
        expression itself, avoiding the recursive computation. If
        expressions are small, this won't be much of a benefit, but it
        can save time if large expressions are frequently constructed.
      </p><p id="idp8581728">
        A more serious problem is that the hash table holds onto
        expressions <span><em>forever</em></span>, even if they are no
        longer used in the program. This can result in a space leak that
        cancels out any space saving we had in the first place, perhaps
        making it even worse.
      </p><p id="idp8582816">
        To deal with this problem, we can use &quot;weak&quot; hash
        tables, implemented in the <code>Weak</code> module in the
        OCaml standard library. The main difference is that a weak table
        may drop values that are no longer being used elsewhere. Weak
        tables are tied into the garbage collector, which removes values
        that are no longer live.
      </p><p id="idp8584224">
        We define the type <code>WExp.t</code> much as before,
        except including the hash code for the <code>Plus</code>
        and <code>Times</code> expressions.
      </p><p id="idp8586560">
        The weak hash table requires that hash and equality functions be
        provided explicitly, so we construct a module
        <code>HashExp</code> that defines the
        <code>equal</code> and <code>hash</code> functions.
        Note that equality and hashing are both constant-time functions
        -- equality can rely on physical equality of subexpressions, and
        hashing can use the explcitly represented hash values.
      </p><p id="idp8589216">
        The module <code>WeakHash</code> has the semantics of a
        set of elements. The <code>WeakHash.merge</code> function
        retrieves an element if it already exists, or adds it otherwise.
        The constructors are much as before.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">WExp</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="k">private</span>
   <span class="o">|</span> <span class="nc">Num</span> <span class="k">of</span> <span class="kt">int</span>
   <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
   <span class="o">|</span> <span class="nc">Plus</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
   <span class="o">|</span> <span class="nc">Times</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">num</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">var</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">times</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span>
   <span class="o">|</span> <span class="nc">Num</span> <span class="k">of</span> <span class="kt">int</span>
   <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
   <span class="o">|</span> <span class="nc">Plus</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
   <span class="o">|</span> <span class="nc">Times</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">module</span> <span class="nc">HashExp</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="n">exp</span>
    <span class="k">let</span> <span class="n">equal</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Num</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Num</span> <span class="n">i2</span> <span class="o">-&gt;</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i2</span>
       <span class="o">|</span> <span class="nc">Var</span> <span class="n">v1</span><span class="o">,</span> <span class="nc">Var</span> <span class="n">v2</span> <span class="o">-&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">v2</span>
       <span class="o">|</span> <span class="nc">Plus</span> <span class="o">(_,</span> <span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">),</span> <span class="nc">Plus</span> <span class="o">(_,</span> <span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">)</span>
       <span class="o">|</span> <span class="nc">Times</span> <span class="o">(_,</span> <span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">),</span> <span class="nc">Times</span> <span class="o">(_,</span> <span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">)</span> <span class="o">-&gt;</span>
            <span class="n">a1</span> <span class="o">==</span> <span class="n">b1</span> <span class="o">&amp;&amp;</span> <span class="n">a2</span> <span class="o">==</span> <span class="n">b2</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">function</span>
     <span class="o">|</span> <span class="nc">Num</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="ow">lxor</span> <span class="mh">0xabababab</span>
     <span class="o">|</span> <span class="nc">Var</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">v</span><span class="o">)</span> <span class="ow">lxor</span> <span class="mh">0xcdcdcdcdc</span>
     <span class="o">|</span> <span class="nc">Plus</span> <span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="o">_,</span> <span class="o">_)</span>
     <span class="o">|</span> <span class="nc">Times</span> <span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="o">_,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="n">hash</span>
  <span class="k">end</span>

  <span class="k">module</span> <span class="nc">WeakHash</span> <span class="o">=</span> <span class="nn">Weak</span><span class="p">.</span><span class="nc">Make</span> <span class="o">(</span><span class="nc">HashExp</span><span class="o">);;</span>

  <span class="k">let</span> <span class="n">table</span> <span class="o">=</span> <span class="nn">WeakHash</span><span class="p">.</span><span class="n">create</span> <span class="mi">17</span>
  <span class="k">let</span> <span class="n">merge</span> <span class="n">e</span> <span class="o">=</span> <span class="nn">WeakHash</span><span class="p">.</span><span class="n">merge</span> <span class="n">table</span> <span class="n">e</span>

  <span class="k">let</span> <span class="n">num</span> <span class="n">i</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">i</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">var</span> <span class="n">s</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Var</span> <span class="n">s</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">plus</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="nn">HashExp</span><span class="p">.</span><span class="n">hash</span> <span class="n">e1</span><span class="o">)</span> <span class="ow">lxor</span> <span class="o">(</span><span class="nn">HashExp</span><span class="p">.</span><span class="n">hash</span> <span class="n">e2</span><span class="o">)</span> <span class="ow">lxor</span> <span class="mh">0x12345678</span> <span class="k">in</span>
     <span class="n">merge</span> <span class="o">(</span><span class="nc">Plus</span> <span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>

  <span class="k">let</span> <span class="n">times</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="nn">HashExp</span><span class="p">.</span><span class="n">hash</span> <span class="n">e1</span><span class="o">)</span> <span class="ow">lxor</span> <span class="o">(</span><span class="nn">HashExp</span><span class="p">.</span><span class="n">hash</span> <span class="n">e2</span><span class="o">)</span> <span class="ow">lxor</span> <span class="mh">0xdeadbeef</span> <span class="k">in</span>
     <span class="n">merge</span> <span class="o">(</span><span class="nc">Times</span> <span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div></section></section><section><h1 id="concurrency">Concurrency</h1><p id="idp8596032">
      Concurrency is another tool OCaml programmers can use to simplify
      programs in certain cases. In OCaml, threads do not introduce
      parallelism; only one thread may be running at a time. However,
      threads can be used to simplify control flow -- a program can
      devote some threads to reading input, others for performing work,
      others for producing output, etc.
    </p><p id="idp8596832">
      The OCaml standard library supports threads, where individual
      threads of control can be created that run concurrently (but only
      one thread at a time), and context switches are
      <span><em>involuntary</em></span>, meaning that a thread may be
      preempted at any time.
    </p><p id="idp8597904">
      When threads share imperative state, this gives rise to the
      standard synchronization issues, where multiple threads may be
      mutating shared state at the same time. To illustrate, let's write
      a program with two threads that increment a shared reference cell
      concurrently.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span>

<span class="k">let</span> <span class="n">loop</span> <span class="bp">()</span> <span class="o">=</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span>
     <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="o">!</span><span class="n">value</span> <span class="k">in</span>
     <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span><span class="o">;</span>
     <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
     <span class="n">value</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="k">done</span>

<span class="k">let</span> <span class="n">thread1</span> <span class="o">=</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">create</span> <span class="n">loop</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">thread2</span> <span class="o">=</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">create</span> <span class="n">loop</span> <span class="bp">()</span><span class="o">;;</span>

<span class="nn">Thread</span><span class="p">.</span><span class="n">join</span> <span class="n">thread1</span><span class="o">;;</span>
<span class="nn">Thread</span><span class="p">.</span><span class="n">join</span> <span class="n">thread2</span><span class="o">;;</span>

<span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;value = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">!</span><span class="n">value</span>
</pre></div><p id="idp8600256">
      The reference cell <code>value</code> holds a shared value
      that is incremented 10 times, in a loop, by the
      <code>loop</code> function. Each iteration of the loop
      prints the current value, then assigns the new value. We create
      two threads with the <code>Thread.create</code> expressions,
      then use <code>Thread.join</code> to block until the threads
      terminate.
    </p><p id="idp8603376">
      The exact behavior of the program is nondeterminstic -- it depends
      on the relative sopeed of the two theads. One output is listed
      below.
    </p><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ii</span>  <span class="o">==</span>  <span class="mi">01</span>

<span class="n">ii</span>  <span class="o">==</span>  <span class="mi">12</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">value</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div><p id="idp8604800">
      This represents a nearly perfect interleaving of the thread
      executions. Each thread fetches the value from the
      <code>value</code> reference cell, prints the value, then
      performs the assignment. Since both threads effectively run in
      lockstep, the final value in the <code>value</code>
      reference cell is the same as if there were just one thread
      running.
    </p><p id="idp8606832">
      If this is not the behavior that was expected, one solution is to
      use a <code>Mutex</code> to ensure that the increment
      operation is atomic. We can allocate a lock with
      <code>Mutex.create</code>, then acquire the lock in the loop
      body.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span>
<span class="k">let</span> <span class="n">mutex</span> <span class="o">=</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span>

<span class="k">let</span> <span class="n">loop</span> <span class="bp">()</span> <span class="o">=</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="mi">3</span> <span class="k">do</span>
     <span class="nn">Mutex</span><span class="p">.</span><span class="n">lock</span> <span class="n">mutex</span><span class="o">;</span>
     <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="o">!</span><span class="n">value</span> <span class="k">in</span>
     <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;i = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span><span class="o">;</span>
     <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
     <span class="n">value</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
     <span class="nn">Mutex</span><span class="p">.</span><span class="n">unlock</span> <span class="n">mutex</span>
   <span class="k">done</span>
</pre></div><p id="idp8609856">
      When we run this program, it produces a deterministic output.
    </p><pre id="idp8610336">
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
value = 6
</pre><section><h1 id="dealing-with-concurrency">Dealing with concurrency</h1><p id="idp8611840">
        In general the interaction of concurrency with imperative
        programs causes problems with races. There are many techniques
        you can use to address the issue.
      </p><ul><li><p id="idp8612944">
            Do not use assignment, mutable data structures, or perform
            input/output in threads.
          </p></li><li><p id="idp8613840">
            Use <span><em>cooperative</em></span> multitasking, where
            only one thread runs at a time, and context switches are
            <span><em>voluntary</em></span>. This is the dominant model
            in <code>Async</code>.
          </p></li><li><p id="idp8616112">
            Do not share mutable data between threads. In practice, this
            usually includes explicit communication channels between
            threads that otherwise have isolated state.
          </p></li><li><p id="idp8617104">
            Give in, and use threads, and the standard synchronization
            toolkit that comes with OCaml, including locks
            (<code>Mutex</code>), condition variables, etc.
          </p></li></ul><p id="idp8618528">
        Out of all of these choices, the simplest one is to use the
        <code>Async</code> model and cooperative multitasking.
        However, let's go ahead and work through some examples of using
        traditional concurrent programming using locks and other
        synchronization primitives to build a concurrency library.
      </p></section><section><h1 id="concurrent-hash-tables">Concurrent hash tables</h1><p id="idp8620896">
        Let's extend our hash table example to support concurrency. To
        begin, let's first give the signature of the module we will
        implement. The table has operations to add, remove, and find
        elements, and it also supports imperative iterators.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">ConcurrentHashMap</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span>
  <span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">iterator</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">iterator</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
</pre></div><p id="idp8622800">
        We'll use the same basic construction that we used to implement
        the <code>HashMap</code> -- a hash table contains an array
        of buckets. In addition we'll add locking to ensure that
        concurrent operations do not interfere. In addition, to reduce
        lock contention, we'll use an array of locks to partition the
        table into multiple parts. If operations are randomly
        disitribted, this should reduce lock contention.
      </p><div class="highlight"><pre>  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">element</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">key</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">value</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">locks</span> <span class="o">:</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">t</span> <span class="kt">array</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">buckets</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">element</span> <span class="kt">list</span> <span class="kt">array</span>
  <span class="o">}</span>

  <span class="k">let</span> <span class="n">num_locks</span> <span class="o">=</span> <span class="mi">32</span>
  <span class="k">let</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">256</span>

  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">locks</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">num_locks</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span><span class="o">);</span>
    <span class="n">buckets</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="n">num_buckets</span> <span class="bp">[]</span>
  <span class="o">}</span>
</pre></div><p id="idp8625728">
        Each <code>element</code> is a key/value pair, where the
        value is mutable so that the <code>add</code> function can
        mutate it in place. For this implementation, we'll use 32 locks,
        and start with 256 buckets.
      </p><p id="idp8627584">
        Each bucket is an <span><em>association list</em></span>, meaning
        that it is list of key/value pairs that implement a dictionary.
        We can start the implementation by defining dictionary
        operations for association lists. The function
        <code>find_assoc</code> finds the value associated with a
        key, and <code>remove_assoc</code> removes an association.
        Both functions raise an exception <code>Not_found</code>
        if the list does not contain the association.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="k">rec</span> <span class="n">find_assoc</span> <span class="n">key</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">{</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key'</span> <span class="o">}</span> <span class="k">as</span> <span class="n">element</span> <span class="o">::</span> <span class="o">_</span> <span class="k">when</span> <span class="n">key'</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">element</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">find_assoc</span> <span class="n">key</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Not_found</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">remove_assoc</span> <span class="n">key</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">{</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key'</span> <span class="o">}</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="n">key'</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">remove_assoc</span> <span class="n">key</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Not_found</span>
</pre></div><p id="idp8632048">
        The locks are intended to partition the table into multiple
        sub-parts, where each lock provides synchronization for a
        contiguous range of buckets. To make synchronization each we
        define a function <code>synchronize</code> that takes a
        bucket index and a function, and evaluates the function with the
        bucket lock acquired, releasing the lock before returning.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">locks</span><span class="o">.(</span><span class="n">index</span> <span class="o">*</span> <span class="n">num_locks</span> <span class="o">/</span> <span class="n">num_buckets</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">Mutex</span><span class="p">.</span><span class="n">lock</span> <span class="n">lock</span><span class="o">;</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="nn">Mutex</span><span class="p">.</span><span class="n">unlock</span> <span class="n">lock</span><span class="o">;</span>
    <span class="n">result</span>
</pre></div><p id="idp8634528">
        Note that the <code>synchronize</code> function is
        <span><em>not</em></span> exception-safe, meaning that if
        evaluation of <code>f ()</code> raises an exception, the
        lock will not be released. An exception-safe version would catch
        all exceptions; when an exception is raised, the lock would be
        released, and the exception re-raised.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">synchronize_exn</span> <span class="n">table</span> <span class="n">index</span> <span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">locks</span><span class="o">.(</span><span class="n">index</span> <span class="o">*</span> <span class="n">num_locks</span> <span class="o">/</span> <span class="n">num_buckets</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">Mutex</span><span class="p">.</span><span class="n">lock</span> <span class="n">lock</span><span class="o">;</span>
    <span class="k">try</span> <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f</span> <span class="bp">()</span> <span class="k">in</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">unlock</span> <span class="n">lock</span><span class="o">;</span> <span class="n">result</span> <span class="k">with</span>
      <span class="n">exn</span> <span class="o">-&gt;</span> <span class="nn">Mutex</span><span class="p">.</span><span class="n">unlock</span> <span class="n">lock</span><span class="o">;</span> <span class="k">raise</span> <span class="n">exn</span>
</pre></div><p id="idp8638064">
        To add a new entry to the table, the <code>add</code>
        function acquires the bucket lock, then uses
        <code>find_assoc</code> to look for an existing
        association. If one is found, the <code>value</code> is
        updated in-place to the new value. Otherwise, a new entry is
        added to the beginning of the bucket.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">add</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">~</span><span class="n">data</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="ow">mod</span> <span class="n">num_buckets</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span> <span class="k">in</span>
    <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="k">try</span> <span class="o">(</span><span class="n">find_assoc</span> <span class="n">key</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)).</span><span class="n">value</span> <span class="o">&lt;-</span> <span class="n">data</span> <span class="k">with</span>
        <span class="nc">Not_found</span> <span class="o">-&gt;</span>
          <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">{</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">data</span> <span class="o">}</span> <span class="o">::</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">))</span>
</pre></div><p id="idp8641856">
        Removing an element from the table is similar. If here is a
        previous entry in the table, the entry is removed. Otherwise,
        the table is left unchanged.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">remove</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="ow">mod</span> <span class="n">num_buckets</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span> <span class="k">in</span>
    <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="k">try</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">remove_assoc</span> <span class="n">key</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="k">with</span>
        <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">)</span>
</pre></div><p id="idp8643664">
        The function to find an association in the table is similar --
        we jsut find the entry in the table and return the value part.
        However, this particular implementation is somewhat more subtle,
        because it omits the synchronization step, examining the bucket
        <span><em>without</em></span> acquiring the lock.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="ow">mod</span> <span class="n">num_buckets</span> <span class="k">in</span>
    <span class="c">(* Unsynchronized! *)</span>
    <span class="o">(</span><span class="n">find_assoc</span> <span class="n">key</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)).</span><span class="n">value</span>
</pre></div><p id="idp8645808">
        From a performance perspective, this is clearly a win, because
        retrieving elements from the table has no locking at all. But
        why is it valid?
      </p><p id="idp8646384">
        The reasoning has to do with two things: 1) the semantics we
        expect from the table, and 2) the OCaml memory model. Ideally,
        the semantics we would expect is <span><em>sequential
        semantics</em></span>, meaning that all memory operations are
        processed in <span><em>some</em></span> sequence that is
        compatible with the order in which they were performed in each
        thread. Thus, if some thread adds two entries for keys
        <code>K1</code> and <code>K2</code> in sequential
        order, then all other threads will see either, 1) neither entry,
        or 2) a entry for <code>K1</code>, or 3) a entry for both
        <code>K1</code> and <code>K2</code>, but it will
        <span><em>not</em></span> see an entry for <code>K2</code>
        without also having an entry for <code>K1</code>.
      </p><p id="idp8652864">
        Unfortunately, for some processor architectures, primary memory
        does not have sequential semantics, due to caching and other
        effects. Fortunately for us, OCaml does provide sequential
        memory semantics due to its threading model where: 1) only one
        thread executes at a time, and 2) there is a memory barrier the
        prevents reordering of thread context switches and memort
        operations, and 3) the compiler does not reorder memory
        operations in ways that would violate sequential memory
        semantics.
      </p><p id="idp8653840">
        Note, OCaml does not a <span><em>guarantee</em></span> this
        semantics. The OCaml implementation may change to support
        parallelism. If it does, the memory semantics will change
        accordingly. The simplest fix is just to synchronize the access.
        Performance of <code>find</code> operations will decrease
        somewhat due to contention.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">synchronized_find</span> <span class="n">table</span> <span class="o">~</span><span class="n">key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">hash</span> <span class="n">key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="ow">mod</span> <span class="n">num_buckets</span> <span class="k">in</span>
    <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="o">(</span><span class="n">find_assoc</span> <span class="n">key</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)).</span><span class="n">value</span><span class="o">)</span>
</pre></div><p id="idp8656752">
        For the final part of the implementation, let's define
        imperative iteration. The iterator object contains a bucket
        index, and the field <code>elements</code> refers to some
        suffix of the list stored in the bucket. The
        <code>value</code> method returns the current elements,
        and the <code>next</code> method advances the
        <code>elements</code> field. The method
        <code>normalize</code> is used to maintain the invariant
        that the <code>elements</code> field always refers to a
        value in the table unless the iterator has advanced past the
        final element. The <code>remove</code> method removes the
        current element from the bucket in which it is stored.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="k">rec</span> <span class="n">remove_element</span> <span class="n">elements</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">(_</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="k">as</span> <span class="n">elements'</span> <span class="k">when</span> <span class="n">elements'</span> <span class="o">==</span> <span class="n">elements</span> <span class="o">-&gt;</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">remove_element</span> <span class="n">elements</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Not_found</span>

  <span class="k">let</span> <span class="n">iterator</span> <span class="n">table</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">buckets</span> <span class="k">in</span>
    <span class="k">object</span> <span class="o">(</span><span class="n">self</span><span class="o">)</span>
      <span class="k">val</span> <span class="k">mutable</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">val</span> <span class="k">mutable</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">.(</span><span class="mi">0</span><span class="o">)</span>
      <span class="k">method</span> <span class="n">has_value</span> <span class="o">=</span> <span class="n">elements</span> <span class="o">&lt;&gt;</span> <span class="bp">[]</span>
      <span class="k">method</span> <span class="n">value</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">elements</span> <span class="k">with</span>
        <span class="o">|</span> <span class="o">{</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">}</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span>
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;value&quot;</span><span class="o">)</span>
      <span class="k">method</span> <span class="n">next</span> <span class="o">=</span>
        <span class="n">elements</span> <span class="o">&lt;-</span> <span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="n">elements</span><span class="o">;</span>
        <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
      <span class="k">method</span> <span class="n">remove</span> <span class="o">=</span>
        <span class="n">synchronize</span> <span class="n">table</span> <span class="n">index</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
          <span class="k">try</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">remove_element</span> <span class="n">elements</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span> <span class="k">with</span>
            <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
        <span class="n">self</span><span class="o">#</span><span class="n">next</span>
      <span class="k">method</span> <span class="k">private</span> <span class="n">normalize</span> <span class="o">=</span>
        <span class="k">while</span> <span class="n">elements</span> <span class="o">=</span> <span class="bp">[]</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">num_buckets</span> <span class="k">do</span>
          <span class="n">index</span> <span class="o">&lt;-</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
      <span class="n">elements</span> <span class="o">&lt;-</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">index</span><span class="o">)</span>
        <span class="k">done</span>
      <span class="k">initializer</span> <span class="n">self</span><span class="o">#</span><span class="n">normalize</span>
    <span class="k">end</span>
</pre></div><p id="idp8664688">
        All method are unsychronized except the method
        <code>remove</code>, which mutates the bucket. As a
        consequence, it means that hash operations that add and remove
        elements from the list can happen concurrently with iteration.
        Again, this is great from a performance perspective, but it
        means that iteration has non-sequential semantics. In
        particular, whenever iteration enters a new bucket, subsequent
        concurrent operations that add new elements or remove old ones
        have <span><em>no effect</em></span> on the iteration. Iteration
        advances through that bucket as if it were unchanged.
      </p><p id="idp8666752">
        One advantage of this relaxed iteration semantics is peformance,
        since iteration is largely unsynchronized. Another advantage is
        that deadlock is less likely. If we were to
        <span><em>lock</em></span> the bucket during iteration, then
        changes to that bucket would not be allowed during iteration
        (even by the iterating thread). We might allow lock recursion to
        allow mutations by the iterating thread, but in general the
        synchronization might involve multiple threads, resulting in
        deadlock. Lock-free iteration ensures that the
        <code>ConcurrentHashMap</code> will not be involved in a
        deadlock cycle.
      </p></section></section><section><h1 id="summary">Summary</h1><p id="idp8669984">
      The OCaml language supports a fairly standard imperative
      programming model, with looping, assignment, mutable arrays,
      records, and objects. If desired, we can write programs that
      correspond directly to what we would have written in some other
      imperative language like C or Java. Of course, doing so is really
      not the best match -- if you want to write imperative programs,
      you should probably use an imperative programming language.
    </p><p id="idp8670864">
      However, there are times when imperative programming might provide
      efficiency (as with lazy evaluation, or memoization), or you might
      require techniques or data structures that are traditional
      imperative (like graphs represented with adjacency lists), and in
      these cases OCaml usually shines. Used with discretion, imperative
      programming can lead to smaller, simpler programs.
    </p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="error-handling.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="files-modules-and-programs.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>