<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 13. Concurrent Programming with Async / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha1',
                        page: 'concurrent\u002Dprogramming\u002Dwith\u002Dasync.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-json-xml-and-s-expressions.html">7. Data Serialization with JSON, XML and S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">8. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">9. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">10. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors-and-first-class-modules.html">11. Functors and First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="input-and-output.html">12. Input and Output</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html" class="here">13. Concurrent Programming with Async</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">14. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 13. Concurrent Programming with Async</h1>
                
                

    <p id="idp9186400">
    When you start building OCaml code that interfaces with external
    systems, you'll soon need to handle concurrent operations. Consider
    the case of a web server sending a large file to many clients, or a
    GUI waiting for a mouse clicks. These applications often need to
    block while waiting for input for a particular task, and process
    something else during that time. Meanwhile, when new data does
    appear, the blocked task needs to be resumed as quickly as possible.
  </p><p id="idp9187296">
    Efficiency really matters here, as busy servers can often handle
    tens of thousands of simultaneous connections. An equally important
    concern is readable source code, where the control flow of the
    program is obvious at a glance.
  </p><p id="idp9187936">
    You've probably used preemptive system threads before in some
    programming languages such as Java or C#. In this model, each task
    is usually given an operating system thread of its own. Other
    languages such as Javascript are single-threaded, and applications
    must register function callbacks to be triggered upon external
    events (such as a timeout or browser click).
  </p><p id="idp9188736">
    Both of these mechanisms have tradeoffs. Preemptive threads require
    their own memory stacks and can be memory hungry. The operating
    system can also arbitrarily interleave the execution of threads, and
    so they require careful locking around shared data structures.
  </p><p id="idp9189424">
    Event-driven systems usually only execute a single task at a time
    and require less locking. However, the program structure can often
    descend into a maze of event callbacks for even a simple operation
    that blocks a few times. Code readability matters, and so we'd like
    to avoid such spaghetti control flow.
  </p><p id="idp9190160">
    The <code>Async</code> OCaml library offers a hybrid model
    that lets you write event-driven code that can block
    <span><em>without</em></span> the complexity of preemptive threading.
    Let's dive straight into an example to see what this looks like, and
    then explain some of the new concepts. We're going to search for
    definitions of English terms using the DuckDuckGo search engine.
  </p><section><h1 id="example-searching-definitions-with-duckduckgo">Example: searching definitions with DuckDuckGo</h1><p id="idp9193264">
      DuckDuckGo is a search engine with a freely available search
      interface. A DuckDuckGo search is executed by making an HTTP
      request to <code>api.duckduckgo.com</code>. The result comes
      back in either JSON or XML format, depending on what was requested
      in the original query string. Let's write some functions that
      construct the right URI and can parse the resulting JSON.
    </p><p id="idp9194752">
      Before we can make the HTTP calls, we need a couple of helper
      functions with the following signature.
    </p><div class="highlight"><pre><span class="c">(* Generate a DuckDuckGo API search URI for [query] *)</span>
<span class="k">val</span> <span class="n">make_ddg_uri</span> <span class="o">:</span> <span class="n">query</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Uri</span><span class="p">.</span><span class="n">t</span>

<span class="c">(* Extract the Definition field from the DuckDuckGo search</span>
<span class="c">   response, or return [None] if it doesn't exist *)</span>
<span class="k">val</span> <span class="n">get_definition_from_json</span><span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="n">option</span>
</pre></div><p id="idp9196880">
      This code uses a couple of new libraries we haven't seen before.
      You will need to OPAM install <code>uri</code> and
      <code>yojson</code> (refer to chapter {{{installation}}} if
      you need help). Let's see how to implement them first.
    </p><section><h1 id="uri-handling">URI handling</h1><p id="idp9199936">
        You're hopefully familiar with HTTP URLs, which identify
        endpoints across the World Wide Web. These are actually part of
        a more general family known as Uniform Resource Identifiers
        (URIs). The full URI specification is defined in
        <a href="http://tools.ietf.org/html/rfc3986" target="_top">RFC3986</a>
        (and is rather complicated!). Luckily, the
        <code>ocaml-uri</code> library provides a strongly-typed
        interface which takes care of much of the hassle.
      </p><div class="highlight"><pre><span class="c">(* Generate a DuckDuckGo search URI from a query string *)</span>
<span class="k">let</span> <span class="n">make_ddg_uri</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">base_uri</span> <span class="o">=</span> <span class="s2">&quot;http://api.duckduckgo.com/?format=json&quot;</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">uri</span> <span class="o">=</span> <span class="nn">Uri</span><span class="p">.</span><span class="n">of_string</span> <span class="n">base_uri</span> <span class="k">in</span>
  <span class="k">fun</span> <span class="o">~</span><span class="n">query</span> <span class="o">-&gt;</span>
    <span class="nn">Uri</span><span class="p">.</span><span class="n">add_query_param</span> <span class="n">uri</span> <span class="o">(</span><span class="s2">&quot;q&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">query</span><span class="o">])</span>
</pre></div><p id="idp9203584">
        A <code>Uri.t</code> is constructed from the
        <code>Uri.of_string</code> function, and a query parameter
        <code>q</code> is added with the desired search query. The
        library takes care of encoding the URI correctly when outputting
        it in the network protocol.
      </p><p id="idp9206320">
        Note that the URI manipulation functions are all
        <span><em>pure</em></span> functions which return a new URI
        value, and never modify the input. This makes it easier to pass
        around URI values through your application stack without fear of
        modification.
      </p></section><section><h1 id="parsing-json-strings">Parsing JSON strings</h1><p id="idp9208640">
        The HTTP response from DuckDuckGo is in JSON, a common (and
        thankfully simple) format that is specified in
        <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_top">RFC4627</a>.
        There are quite a few JSON parsers available for OCaml, and
        we've picked
        <a href="http://mjambon.com/yojson.html" target="_top"><code>Yojson</code></a>
        for this example.
      </p><p id="idp9211136">
        There are a few non-standard extensions to JSON, so Yojson
        exposes them as the <code>Basic</code> and
        <code>Safe</code> sub-modules. It doesn't really matter
        which one we pick for this simple example, so we'll go with
        <code>Safe</code>.
      </p><p id="idp9213888">
        The input <code>string</code> is parsed using
        <code>Yojson.Safe.from_string</code> into an OCaml data
        type. The JSON values are represented using polymorphic
        variants, and can thus be pattern matched more easily once they
        have been parsed by Yojson.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
<span class="o">]</span>
</pre></div><p id="idp9217072">
        We're expecting the DuckDuckGo response to be a record, with an
        optional <code>Description</code> field being one of the
        keys in the record. The
        <code>get_definition_from_json</code> does a pattern match
        on this, and returns an optional string if a definition is found
        within the result.
      </p><div class="highlight"><pre><span class="c">(* Extract the Definition field from the DuckDuckGo search</span>
<span class="c">   response, or return [None] if it doesn't exist *)</span>
<span class="k">let</span> <span class="n">get_definition_from_json</span> <span class="o">(</span><span class="n">json</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Safe</span><span class="p">.</span><span class="n">from_string</span> <span class="n">json</span> <span class="k">with</span>
  <span class="o">|`</span><span class="nc">Assoc</span> <span class="n">kv_list</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="k">open</span> <span class="nc">Option</span> <span class="k">in</span>
      <span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">find</span> <span class="n">kv_list</span> <span class="s2">&quot;Definition&quot;</span> <span class="o">&gt;&gt;|</span>
      <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Safe</span><span class="p">.</span><span class="n">to_string</span>
  <span class="o">|_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div><p id="idp9220576">
        Notice that we use options here instead of throwing exceptions
        on an error. When the <code>Option</code> module is
        opened, it provides a <code>map</code> operator
        (<code>&gt;&gt;|</code>) which calls the bound closure if
        the value exists. If no result is found, then the
        <code>Yojson.Safe.to_string</code> conversion function is
        simply ignored, and a <code>None</code> returned.
      </p></section><section><h1 id="executing-an-http-client-query">Executing an HTTP client query</h1><p id="idp9226048">
        Now that we've written those utility functions, let's look at
        the Async code that performs the actual search:
      </p><div class="highlight"><pre><span class="c">(* Execute the DuckDuckGo search *)</span>
<span class="c">(* TODO: This client API is being simplified in Cohttp *)</span>
<span class="k">let</span> <span class="n">do_ddg_query</span> <span class="n">query</span> <span class="o">=</span>
  <span class="nn">Cohttp_async</span><span class="p">.</span><span class="nn">Client</span><span class="p">.</span><span class="n">call</span> <span class="o">`</span><span class="nc">GET</span> <span class="o">(</span><span class="n">make_ddg_uri</span> <span class="o">~</span><span class="n">query</span><span class="o">)</span>
  <span class="o">&gt;&gt;=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="nc">Some</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">128</span> <span class="k">in</span>
      <span class="nn">Pipe</span><span class="p">.</span><span class="n">iter_without_pushback</span> <span class="n">body</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="nn">Buffer</span><span class="p">.</span><span class="n">add_string</span> <span class="n">buf</span><span class="o">)</span>
      <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
      <span class="n">get_definition_from_json</span> <span class="o">(</span><span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buf</span><span class="o">)</span> <span class="o">|!</span>
      <span class="nn">Option</span><span class="p">.</span><span class="n">value</span> <span class="o">~</span><span class="n">default</span><span class="o">:</span><span class="s2">&quot;???&quot;</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(_,</span> <span class="nc">None</span><span class="o">)</span> <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
      <span class="n">failwith</span> <span class="s2">&quot;no body in response&quot;</span>
</pre></div><p id="idp9228400">
        For this code, you'll need to OPAM install the
        <code>cohttp</code> library. The
        <code>Cohttp_async.Client</code> module executes the HTTP
        call, and returns a status and response body wrapped. This whole
        result is wrapped in a type you haven't seen before:
        <code>Async.Deferred.t</code>.
      </p><p id="idp9231184">
        The <code>Deferred.t</code> represents a
        <span><em>future</em></span> value whose result is not available
        yet. You can &quot;wait&quot; for the result by binding a
        callback using the <code>&gt;&gt;=</code> operator (which
        is imported when you open <code>Async.Std</code>). This is
        the same monad pattern available in other Core libraries such as
        <code>Option</code>, but instead of operating on optional
        values, we are now mapping over future values. We'll come back
        to monads later in this chapter. (<span><em>avsm</em></span>:
        TODO xref)
      </p><p id="idp9235984">
        The <code>ddg_query</code> function invokes the HTTP
        client call, and returns a tuple containing the response codes
        and headers, and a <code>string Pipe.Reader</code>. Pipes
        in Async are often used to transmit large amounts of data
        between two processes or concurrent threads. The
        <code>Cohttp</code> library creates a
        <code>Pipe.Writer</code> which it outputs the HTTP body
        into, and provides your application with the
        <code>Reader</code> end.
      </p><p id="idp9240336">
        In this case, the HTTP body probably isn't very large, so we
        just iterate over the Pipe's contents until we have the full
        HTTP body in a <code>Buffer.t</code>. Once the full body
        has been retrieved into our buffer, the next callback passes it
        through the JSON parser and returns a human-readable string of
        the search description that DuckDuckGo gave us.
      </p><div class="highlight"><pre><span class="c">(* Run a single search *)</span>
<span class="k">let</span> <span class="n">run_one_search</span> <span class="o">=</span>
  <span class="n">do_ddg_query</span> <span class="s2">&quot;Camel&quot;</span> <span class="o">&gt;&gt;|</span> <span class="n">prerr_endline</span>

<span class="c">(* Start the Async scheduler *)</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Scheduler</span><span class="p">.</span><span class="n">go</span> <span class="bp">()</span>
</pre></div><p id="idp9243168">
        Let's actually use the search function to run a real query now.
        The fragment above spawns a single search, and then fires up the
        Async scheduler. The scheduler is where all the work happens,
        and must be started in every application that uses Async.
        Without it, logging won't be output, nor will blocked functions
        ever wake up. When the scheduler is active, it is waiting for
        incoming I/O events and waking up function callbacks that were
        sleeping on that particular file descriptor or timeout.
      </p><p id="idp9244128">
        A single connection isn't that interesting from a concurrency
        perspective. Luckily, Async makes it very easy to run multiple
        parallel searches:
      </p><div class="highlight"><pre><span class="c">(* Run many searches in parallel *)</span>
<span class="k">let</span> <span class="n">run_many_searches</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">searches</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;Duck&quot;</span><span class="o">;</span> <span class="s2">&quot;Sheep&quot;</span><span class="o">;</span> <span class="s2">&quot;Cow&quot;</span><span class="o">;</span> <span class="s2">&quot;Llama&quot;</span><span class="o">;</span> <span class="s2">&quot;Camel&quot;</span><span class="o">]</span> <span class="k">in</span>
  <span class="nn">Deferred</span><span class="p">.</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">how</span><span class="o">:`</span><span class="nc">Parallel</span> <span class="n">searches</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">do_ddg_query</span> <span class="o">&gt;&gt;|</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">print_endline</span>
</pre></div><p id="idp9246096">
        The <code>Deferred.List</code> module lets you specify
        exactly how to map over a collection of futures. The searches
        will be executed simultaneously, and the map thread will
        complete once all of the sub-threads are complete. If you
        replace the <code>Parallel</code> parameter with
        <code>Serial</code>, the map will wait for each search to
        fully complete before issuing the next one.
      </p><aside class="note"><h1>
      Terminating Async applications
      </h1><p id="idp9249696">
        When you run the search example, you'll notice that the
        application doesn't terminate even when all of the searches are
        complete. The Async scheduler doesn't terminate by default, and
        so most applications will listen for a signal to exit or simply
        use <code>CTRL-C</code> to interrupt it from a console.
      </p><p id="idp9251120">
        Another alternative is to run an Async function in a separate
        system thread. You can do this by wrapping the function in the
        <code>Async.Thread_safe.block_on_async_exn</code>. The
        <code>utop</code> top-level does this automatically for
        you if you attempt to evaluate an Async function interactively.
      </p></aside></section></section><section><h1 id="manipulating-async-threads">Manipulating Async threads</h1><p id="idp9254800">
      Now that we've seen the search example above, let's examine how
      Async works in more detail.
    </p><p id="idp9255312">
      Async threads are co-operative and never preempt each other, and
      the library internally converts blocking code into a single event
      loop. The threads are normal OCaml heap-allocated values (without
      any runtime magic!) and are therefore very fast to allocate.
      Concurrency is mostly limited only by your available main memory,
      or operating system limits on non-memory resources such as file
      descriptors.
    </p><p id="idp9256160">
      Lets begin by constructing a simple thread. Async follows the Core
      convention and provides an <code>Async.Std</code> that
      provides threaded variants of many standard library functions. The
      examples throughout this chapter assume that
      <code>Async.Std</code> is open in your environment.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">require</span> <span class="s2">&quot;async.unix&quot;</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">open</span> <span class="nn">Async</span><span class="p">.</span><span class="nc">Std</span> <span class="o">;;</span>
<span class="o">#</span> <span class="n">return</span> <span class="mi">5</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp9259376">
      The basic type of an Async thread is a
      <code>Deferred.t</code>, which can be constructed by the
      <code>return</code> function. The type parameter (in this
      case <code>int</code>) represents the ultimate type of the
      thread once it has completed in the future. This return value
      cannot be used directly while it is wrapped in a
      <code>Deferred.t</code> as it may not be available yet.
      Instead, we <code>bind</code> a function closure that is
      called once the value is eventually ready.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">return</span> <span class="mi">5</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">bind</span> <span class="n">x</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="o">(</span><span class="n">string_of_int</span> <span class="n">a</span><span class="o">))</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">string</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp9264960">
      Here, we've bound a function to <code>x</code> that will
      convert the <code>int</code> to a <code>string</code>.
      Notice that while both <code>x</code> and
      <code>y</code> share a common <code>Deferred.t</code>
      type, their type variables differ and so they cannot be
      interchangably used except in polymorphic functions. This is
      useful when refactoring large codebases, as you can tell if any
      function will block simply by the presence of an
      <code>Deferred.t</code> in the signature.
    </p><p id="idp9270576">
      Let's examine the function signatures of <code>bind</code>
      and <code>return</code> more closely.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">return</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">bind</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9273584">
<code>return</code>, <code>bind</code> and the
      <code>Deferred.t</code> type all contain polymorphic type
      variables (the <code>'a</code>) which represent the type of
      the thread, and are inferred based on how they are used in your
      code. The <code>'a</code> type of the argument passed to the
      <code>bind</code> callback <span><em>must</em></span> be the
      same as the <code>'a Deferred.t</code> of the input thread,
      preventing runtime mismatches between thread callbacks. Both
      <code>bind</code> and <code>return</code> form a
      design pattern in functional programming known as
      <span><em>monads</em></span>, and you will run across this
      signature in many applications beyond just threads.
    </p><p id="idp9281648">
      _(avsm: do we talk about Monads earlier in the Core chapter? I
      presume we do, since the Option monad is very useful)
    </p><p id="idp9282176">
      Binding callbacks is to deferred values is the most common way to
      compose blocking operations, and inline operators are provided to
      make it easier to use. In the fragment below, we see
      <code>&gt;&gt;=</code> and <code>&gt;&gt;|</code> used
      in similar ways to convert an integer into a string:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">return</span> <span class="mi">5</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="o">(</span><span class="n">string_of_int</span> <span class="n">y</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">val</span> <span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">&gt;&gt;|</span> <span class="n">string_of_int</span> <span class="o">;;</span>
<span class="k">val</span> <span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
</pre></div><p id="idp9285536">
      The <code>&gt;&gt;=</code> operator is exactly the same as
      <code>bind</code> and unpacks the integer future into the
      <code>y</code> variable. The subsequent closure receives the
      unpacked integer and builds a new string future. It can be a
      little verbose to keep calling <code>bind</code> and
      <code>return</code>, and so the <code>&gt;&gt;|</code>
      operator maps a non-Async function across a future value. In the
      second example, the future value of <code>x</code> is mapped
      to <code>string_of_int</code> directly, and the result is a
      <code>string</code> future.
    </p><p id="idp9292656">
      Async threads can be evaluated from the toplevel by wrapping them
      in <code>Thread_safe.block_on_async_exn</code>, which spawns
      a system thread that waits until a result is available. The
      <code>utop</code> top-level automatically detects
      <code>Deferred.t</code> types that are entered interactively
      and wraps them in this function for you automatically.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">fn</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">return</span> <span class="mi">5</span> <span class="o">&gt;&gt;|</span> <span class="n">string_of_int</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">fn</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Thread_safe</span><span class="p">.</span><span class="n">block_on_async_exn</span> <span class="n">fn</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;5&quot;</span>
<span class="o">#</span> <span class="n">fn</span> <span class="bp">()</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;5&quot;</span>
</pre></div><p id="idp9296768">
      In the second evaluation of <code>fn</code>, the top-level
      detected the return type of a future and evaluated the result into
      a concrete string.
    </p><p id="idp9298032">
      (<span><em>avsm</em></span>: this utop feature not actually
      implemented yet for Async, but works for Lwt)
    </p></section><section><h1 id="timing-and-thread-composition">Timing and Thread Composition</h1><p id="idp9300304">
      Our examples so far have been with static threads, and now we'll
      look at how to coordinate multiple threads and timeouts. Let's
      write a program that spawns two threads, each of which sleep for
      some random time and return either &quot;Heads&quot; or
      &quot;Tails&quot;, and the quickest thread returns its value.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">flip</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">span</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">of_sec</span> <span class="mi">3</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">span_heads</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">randomize</span> <span class="n">span</span> <span class="o">~</span><span class="n">percent</span><span class="o">:</span><span class="mi">0</span><span class="o">.</span><span class="mi">75</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">span_tails</span> <span class="o">=</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">randomize</span> <span class="n">span</span> <span class="o">~</span><span class="n">percent</span><span class="o">:</span><span class="mi">0</span><span class="o">.</span><span class="mi">75</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">coin_heads</span> <span class="o">=</span>
    <span class="nn">Clock</span><span class="p">.</span><span class="n">after</span> <span class="n">span_heads</span>
    <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="s2">&quot;Heads!&quot;</span><span class="o">,</span> <span class="n">span_heads</span><span class="o">,</span> <span class="n">span_tails</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">coin_tails</span> <span class="o">=</span>
    <span class="nn">Clock</span><span class="p">.</span><span class="n">after</span> <span class="n">span_tails</span>
    <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="s2">&quot;Tails!&quot;</span><span class="o">,</span> <span class="n">span_heads</span><span class="o">,</span> <span class="n">span_tails</span>
  <span class="k">in</span>
  <span class="nn">Deferred</span><span class="p">.</span><span class="n">any</span> <span class="o">[</span><span class="n">coin_heads</span><span class="o">;</span> <span class="n">coin_tails</span><span class="o">]</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">flip</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9303168">
      This introduces a couple of new time-related Async functions. The
      <code>Time</code> module contains functions to express both
      absolute and relative temporal relationships. In our coin flipping
      example, we create a relative time span of 3 seconds, and then
      permute it randomly twice by 75%. We then create two threads,
      <code>coin_heads</code> and <code>coin_tails</code>
      which return after their respective intervals. Finally,
      <code>Deferred.any</code> waits for the first thread which
      completes and returns its value, ignoring the remaining
      undetermined threads.
    </p><p id="idp9306928">
      Both of the threads encode the time intervals in their return
      value so that you can can easily verify the calculations (you
      could also simply print the time spans to the console as they are
      calculated and simplify the return types). You can see this by
      executing the <code>flip</code> function at the toplevel a
      few times.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Thread_safe</span><span class="p">.</span><span class="n">block_on_async_exn</span> <span class="n">flip</span> <span class="o">;;</span>
<span class="o">#</span> <span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">*</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="s2">&quot;Heads!&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="mi">86113</span><span class="n">s</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">64635</span><span class="n">s</span><span class="o">)</span> 
<span class="o">#</span> <span class="nn">Thread_safe</span><span class="p">.</span><span class="n">block_on_async_exn</span> <span class="n">flip</span> <span class="o">;;</span>
<span class="o">#</span> <span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">*</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Time</span><span class="p">.</span><span class="nn">Span</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="s2">&quot;Tails!&quot;</span><span class="o">,</span> <span class="mi">4</span><span class="o">.</span><span class="mi">44979</span><span class="n">s</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="mi">14977</span><span class="n">s</span><span class="o">)</span>
</pre></div><p id="idp9309888">
      The <code>Deferred</code> module has a number of other ways
      to select between multiple threads, such as:
    </p><table><thead><tr><th>
              Function
            </th><th>
              # Threads
            </th><th>
              Behaviour
            </th></tr></thead><tbody><tr><td>
              both
            </td><td>
              2
            </td><td>
              Combines both threads into a tuple and returns both
              values.
            </td></tr><tr><td>
              any
            </td><td>
              list
            </td><td>
              Returns the first thread that becomes determined.
            </td></tr><tr><td>
              all
            </td><td>
              list
            </td><td>
              Waits for all threads to complete and returns their
              values.
            </td></tr><tr><td>
              all_unit
            </td><td>
              list
            </td><td>
              Waits for all <code>unit</code> threads to complete
              and returns <code>unit</code>.
            </td></tr><tr><td>
              peek
            </td><td>
              1
            </td><td>
              Inspects a single thread to see if it is determined yet.
            </td></tr></tbody></table><p id="idp9326240">
      Try modifying the <code>Deferred.any</code> in the above
      example to use some of the other thread joining functions above,
      such as <code>Deferred.both</code>.
    </p><section><h1 id="cancellation">Cancellation</h1><p id="idp9329280">
</p></section></section><section><h1 id="a-simple-tcp-echo-server">A simple TCP Echo Server</h1><p id="idp9331056">
</p></section><section><h1 id="onto-an-http-server">Onto an HTTP Server</h1><p id="idp9332672">
</p></section><section><h1 id="binding-to-the-github-api">Binding to the Github API</h1><p id="idp9334384">
      Show how we can use a monadic style to bind to the Github API and
      make simple JSON requests/responses.
    </p><section><h1><b>
    A Note on Portability
    </b></h1><p id="idp9335472">
      Explain libev and why its needed here.
    </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="input-and-output.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="object-oriented-programming.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>