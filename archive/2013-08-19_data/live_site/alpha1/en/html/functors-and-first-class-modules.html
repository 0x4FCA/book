<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 11. Functors and First-Class Modules / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha1',
                        page: 'functors\u002Dand\u002Dfirst\u002Dclass\u002Dmodules.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-json-xml-and-s-expressions.html">7. Data Serialization with JSON, XML and S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">8. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">9. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">10. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors-and-first-class-modules.html" class="here">11. Functors and First-Class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="input-and-output.html">12. Input and Output</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">13. Concurrent Programming with Async</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">14. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 11. Functors and First-Class Modules</h1>
                
                

    <p id="idp8858752">
    Up until now, we've seen modules play a limited role, serving as a
    mechanism for organizing code into units with specified interfaces.
    But OCaml's module system plays a bigger role in the language,
    acting as a powerful toolset for structuring large-scale systems.
    This chapter will introduce you to functors and first class modules,
    which greatly increase the power of the module system.
  </p><section><h1 id="functors">Functors</h1><p id="idp8860448">
      Functors are, roughly speaking, functions from modules to modules,
      and they can be used to solve a variety of code-structuring
      problems, including:
    </p><ul><li><p id="idp8861536">
<span><em>Dependency injection</em></span>, or making the
          implementations of some components of a system swappable. This
          is particularly useful when you want to mock up parts of your
          system for testing and simulation purposes.
        </p></li><li><p id="idp8862928">
<span><em>Auto-extension of modules</em></span>. Sometimes,
          there is some functionality that you want to build in a
          standard way for different types, in each case based on a some
          piece of type-specific logic. For example, you might want to
          add a slew of comparison operators derived from a base
          comparison function. To do this by hand would require a lot of
          repetitive code for each type, but functors let you write this
          logic just once and apply it to many different types.
        </p></li><li><p id="idp8864608">
<span><em>Instantiating modules with state</em></span>. Modules
          can contain mutable state, and that means that you'll
          occasionally want to have multiple instantiations of a
          particular module, each with its own separate and independent
          mutable state. Functors let you automate the construction of
          such modules.
        </p></li></ul><section><h1 id="a-trivial-example">A trivial example</h1><p id="idp8866848">
        We'll start by considering the simplest possible example: a
        functor for incrementing an integer.
      </p><p id="idp8867376">
        More precisely, we'll create a functor that takes a module
        containing a single integer variable <code>x</code>, and
        returns a new module with <code>x</code> incremented by
        one. The first step is to define a module type which will
        describe the input and output of the functor.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div><p id="idp8870256">
        Now, we can use that module type to write the increment functor.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Increment</span> <span class="o">(</span><span class="nc">M</span><span class="o">:</span><span class="nc">X_int</span><span class="o">)</span> <span class="o">:</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Increment</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">X_int</span>
</pre></div><p id="idp8871856">
        One thing that immediately jumps out about functors is that
        they're considerably more heavyweight syntactically than
        ordinary functions. For one thing, functors require explicit
        type annotations, which ordinary functions do not. Here, we've
        specified the module type for both the input and output of the
        functor. Technically, only the type on the input is mandatory,
        although in practice, one often specifies both.
      </p><p id="idp8872736">
        The following shows what happens when we omit the module type
        for the output of the functor.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Increment</span> <span class="o">(</span><span class="nc">M</span><span class="o">:</span><span class="nc">X_int</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Increment</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div><p id="idp8874352">
        We can see that the inferred module type of the output is now
        written out explicitly, rather than being a reference to the
        named signature <code>X_int</code>.
      </p><p id="idp8875536">
        Here's what <code>Increment</code> looks like in action.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Three</span> <span class="o">=</span> <span class="k">struct</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">end</span><span class="o">;;</span>
  <span class="k">module</span> <span class="nc">Three</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Four</span> <span class="o">=</span> <span class="nc">Increment</span><span class="o">(</span><span class="nc">Three</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Four</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="nn">Four</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="nn">Three</span><span class="p">.</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div><p id="idp8877600">
        In this case, we applied <code>Increment</code> to a
        module whose signature is exactly equal to
        <code>X_int</code>. But we can apply
        <code>Increment</code> to any module that satisfies
        <code>X_int</code>. So, for example,
        <code>Increment</code> can take as its input a module that
        has more fields than are contemplated in
        <code>X_int</code>, as shown below.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Three_and_more</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;three&quot;</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Three_and_more</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">val</span> <span class="n">x_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Four</span> <span class="o">=</span> <span class="nc">Increment</span><span class="o">(</span><span class="nc">Three_and_more</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Four</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div></section><section><h1 id="a-bigger-example-computing-with-intervals">A bigger example: computing with intervals</h1><p id="idp8884368">
        We'll now look at a more complex example, which will give us an
        opportunity to learn more about how functors work. In
        particular, we'll walk through the design of a library for
        computing with intervals. This library will be functorized over
        the type of the endpoints of the intervals and the ordering of
        those endpoints.
      </p><p id="idp8885152">
        First we'll define a module type that captures the information
        we'll need about the endpoint type. This interface, which we'll
        call <code>Comparable</code>, contains just two things: a
        comparison function, and the type of the values to be compared.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Comparable</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">end</span> <span class="o">;;</span>
</pre></div><p id="idp8887472">
        The comparison function follows the standard OCaml idiom for
        such functions, returning <code>0</code> if the two
        elements are equal, a positive number if the first element is
        larger than the second, and a negative number if the first
        element is smaller than the second. Thus, we could rewrite the
        standard comparison functions on top of
        <code>compare</code> as shown below.
      </p><div class="highlight"><pre><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span>     <span class="c">(* x &lt; y *)</span>
<span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c">(* x = y *)</span>
<span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span>     <span class="c">(* x &gt; y *)</span>
</pre></div><p id="idp8890560">
        Now that we have the <code>Comparable</code> interface, we
        can write the implementation of our interval module. In this
        module, we'll represent an interval with a variant type, which
        is either <code>Empty</code> or
        <code>Interval (x,y)</code>, where <code>x</code>
        and <code>y</code> are the bounds of the interval.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nc">Empty</span>

    <span class="k">let</span> <span class="n">create</span> <span class="n">low</span> <span class="n">high</span> <span class="o">=</span>
      <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">low</span> <span class="n">high</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Empty</span>
      <span class="k">else</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">)</span>

    <span class="k">let</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">true</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

    <span class="k">let</span> <span class="n">contains</span> <span class="n">t</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">false</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">h</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="mi">0</span>

    <span class="k">let</span> <span class="n">intersect</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">min</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">max</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">t1</span><span class="o">,</span><span class="n">t2</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_</span> <span class="o">|</span> <span class="o">_,</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="nc">Empty</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l1</span><span class="o">,</span><span class="n">h1</span><span class="o">),</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l2</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="n">create</span> <span class="o">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span> <span class="o">(</span><span class="n">min</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span>

  <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="nc">Empty</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp8897024">
        We can instantiate the functor by applying it to a module with
        the right signature. In the following, we provide the functor
        input as an anonymous module.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span>
    <span class="nc">Make_interval</span><span class="o">(</span><span class="k">struct</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
      <span class="k">let</span> <span class="n">compare</span> <span class="o">=</span> <span class="nn">Int</span><span class="p">.</span><span class="n">compare</span>
    <span class="k">end</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Empty</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp8898912">
        If we choose our interfaces to be aligned with the standards of
        our libraries, then we often don't have to construct a custom
        module for a given functor. In this case, for example, we can
        directly use the <code>Int</code> or
        <code>String</code> modules provided by Core.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">String_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="o">;;</span>
</pre></div><p id="idp8901776">
        This works because many modules in Core, including
        <code>Int</code> and <code>String</code>, satisfy an
        extended version of the <code>Comparable</code> signature
        described above. As a general matter, having standardized
        signatures is a good practice, both because a more uniform
        codebase is easier to navigate, and because it makes functors
        easier to use.
      </p><p id="idp8904496">
        Now we can use the newly defined <code>Int_interval</code>
        module like any ordinary module.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i1</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">8</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i1</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">i2</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">10</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i2</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">intersect</span> <span class="n">i1</span> <span class="n">i2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
</pre></div><p id="idp8906912">
        This design gives us the freedom to use any comparison function
        we want for comparing the endpoints. We could, for example,
        create a type of int interval with the order of the comparison
        reversed, as follows:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Rev_int_interval</span> <span class="o">=</span>
    <span class="nc">Make_interval</span><span class="o">(</span><span class="k">struct</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
      <span class="k">let</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Int</span><span class="p">.</span><span class="n">compare</span> <span class="n">y</span> <span class="n">x</span>
    <span class="k">end</span><span class="o">);;</span>
</pre></div><p id="idp8908640">
        The behavior of <code>Rev_int_interval</code> is of course
        different from <code>Int_interval</code>, as we can see
        below.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">interval</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">interval</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Empty</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">rev_interval</span> <span class="o">=</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">rev_interval</span> <span class="o">:</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div><p id="idp8911712">
        Importantly, <code>Rev_int_interval.t</code> is a
        different type than <code>Int_interval.t</code>, even
        though its physical representation is the same. Indeed, the type
        system will prevent us from confusing them.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">rev_interval</span> <span class="mi">3</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">22</span><span class="o">-</span><span class="mi">34</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">rev_interval</span> <span class="mi">3</span><span class="o">;;</span>
                        <span class="o">^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">t</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">).</span><span class="n">t</span>
</pre></div><p id="idp8914944">
        This is important, because confusing the two kinds of intervals
        would be a semantic error, and it's an easy one to make. The
        ability of functors to mint new types is a useful trick that
        comes up a lot.
      </p><section><h1 id="making-the-functor-abstract">Making the functor abstract</h1><p id="idp8916720">
          There's a problem with <code>Make_interval</code>. The
          code we wrote depends on the invariant that the upper bound of
          an interval is greater than its lower bound, but that
          invariant can be violated. The invariant is enforced by the
          create function, but because <code>Interval.t</code> is
          not abstract, we can bypass the <code>create</code>
          function.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span> <span class="c">(* going through create *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Empty</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span> <span class="c">(* bypassing create *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div><p id="idp8920752">
          To make <code>Int_interval.t</code> abstract, we need to
          apply an interface to the output of the
          <code>Make_interval</code>. Here's an explicit interface
          that we can use for that purpose.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Interval_intf</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">t</span>
   <span class="k">type</span> <span class="n">endpoint</span>
   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8924096">
          This interface includes the type <code>endpoint</code>
          to represent the type of the endpoints of the interval. Given
          this interface, we can redo our definition of
          <code>Make_interval</code>, as follows. Notice that we
          added the type <code>endpoint</code> to the
          implementation of the module to make the implementation match
          <code>Interval_intf</code>.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">....</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Interval_intf</span>
</pre></div></section><section><h1 id="sharing-constraints">Sharing constraints</h1><p id="idp8930336">
          The resulting module is abstract, but unfortunately, it's too
          abstract. In particular, we haven't exposed the type
          <code>endpoint</code>, which means that we can't even
          construct an interval anymore.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">:</span> <span class="nc">Interval_intf</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">20</span><span class="o">-</span><span class="mi">21</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
                      <span class="o">^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="nn">Int_interval</span><span class="p">.</span><span class="n">endpoint</span>
</pre></div><p id="idp8932896">
          To fix this, we need to expose the fact that
          <code>endpoint</code> is equal to
          <code>Int.t</code> (or more generally,
          <code>Endpoint.t</code>, where
          <code>Endpoint</code> is the argument to the functor).
          One way of doing this is through a <span><em>sharing
          constraint</em></span>, which allows you to tell the compiler
          to expose the fact that a given type is equal to some other
          type. The syntax for a sharing constraint on a module type is
          as follows.
        </p><div class="highlight"><pre><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span>
</pre></div><p id="idp8937936">
          where <code>S</code> is a module type,
          <code>t</code> is a type inside of <code>S</code>,
          and <code>s</code> is a different type. The result of
          this expression is a new signature that's been modified so
          that it exposes the fact that <code>t</code> is equal to
          <code>s</code>. We can use a sharing constraint to
          create a specialized version of
          <code>Interval_intf</code> for integer intervals.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="kt">int</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp8944784">
          And we can also use it in the context of a functor, where the
          right-hand side of the sharing constraint is an element of the
          functor argument. Thus, we expose an equality between a type
          in the output of the functor (in this case, the type
          <code>endpoint</code>) and a type in its input
          (<code>Endpoint.t</code>).
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
      <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">...</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp8948464">
          So now, the interface is as it was, except that
          <code>endpoint</code> is now known to be equal to
          <code>Endpoint.t</code>. As a result of that type
          equality, we can now do things like construct intervals again.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">i</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div></section><section><h1 id="destructive-substitution">Destructive substitution</h1><p id="idp8952832">
          Sharing constraints basically do the job, but the approach we
          used has some downsides. In particular, we've now been stuck
          with the useless type declaration of
          <code>endpoint</code> that clutters up both the
          interface and the implementation. A better solution would be
          to modify the <code>Interval_intf</code> signature by
          replacing <code>endpoint</code> with
          <code>Endpoint.t</code> everywhere it shows up, making
          <code>endpoint</code> unnecessary. We can do just this
          using what's called <span><em>destructive
          substitution</em></span>. Here's the basic syntax.
        </p><div class="highlight"><pre><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">s</span>
</pre></div><p id="idp8958688">
          where <code>S</code> is a signature,
          <code>t</code> is a type inside of <code>S</code>,
          and <code>s</code> is a different type. The following
          shows how we could use this with
          <code>Make_interval</code>.
        </p><p id="idp8962672">
          Here's an example of what we get if we use destructive
          substitution to specialize the
          <code>Interval_intf</code> interface to integer
          intervals.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp8965184">
          There's now no mention of n <code>endpoint</code>, all
          occurrences of that type having been replaced by
          <code>int</code>. As with sharing constraints, we can
          also use this in the context of a functor.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
    <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">....</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp8968640">
          The interface is precisely what we want, and we didn't need to
          define the <code>endpoint</code> type alias in the body
          of the module. If we instantiate this module, we'll see that
          it works properly: we can construct new intervals, but
          <code>t</code> is abstract, and so we can't directly
          access the constructors and violate the invariants of the data
          structure.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">);;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">27</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span>
  <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="n">constructor</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span>
</pre></div></section><section><h1 id="using-multiple-interfaces">Using multiple interfaces</h1><p id="idp8973696">
          Another feature that we might want for our interval module is
          the ability to serialize the type, in particular, by
          converting to s-expressions. If we simply invoke the
          <code>sexplib</code> macros by adding
          <code>with sexp</code> to the definition of
          <code>t</code>, though, we'll get an error:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
    <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nc">Empty</span>
    <span class="k">with</span> <span class="n">sexp</span>

    <span class="o">....</span>

  <span class="k">end</span> <span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">120</span><span class="o">-</span><span class="mi">123</span><span class="o">:</span>
        <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
                               <span class="o">^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="n">value</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t_of_sexp</span>
</pre></div><p id="idp8977792">
          The problem is that <code>with sexp</code> adds code for
          defining the s-expression converters, and that code assumes
          that <code>Endpoint</code> has the appropriate
          sexp-conversion functions for <code>Endpoint.t</code>.
          But all we know about <code>Endpoint</code> is that it
          satisfies the <code>Comparable</code> interface, which
          doesn't say anything about s-expressions.
        </p><p id="idp8982048">
          Happily, Core comes with a built in interface for just this
          purpose called <code>Sexpable</code>, which is defined
          as follows:
        </p><div class="highlight"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">Sexpable</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
  <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span>
</pre></div><p id="idp8984368">
          We can modify <code>Make_interval</code> to use the
          <code>Sexpable</code> interface, for both its input and
          its output. Note the use of destructive substitution to
          combine multiple signatures together. This is important
          because it stops the <code>type t</code>'s from the
          different signatures from interfering with each other.
        </p><p id="idp8987200">
          Also note that we have been careful to override the
          sexp-converter here to ensure that the datastructures
          invariants are still maintained when reading in from an
          s-expression.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Interval_intf_with_sexp</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">t</span>
   <span class="k">include</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
   <span class="k">include</span> <span class="nc">Sexpable</span>      <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">include</span> <span class="nc">Comparable</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
    <span class="k">include</span> <span class="nc">Sexpable</span>   <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Interval_intf_with_sexp</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="k">struct</span>

      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
               <span class="o">|</span> <span class="nc">Empty</span>
      <span class="k">with</span> <span class="n">sexp</span>

      <span class="k">let</span> <span class="n">create</span> <span class="n">low</span> <span class="n">high</span> <span class="o">=</span>
         <span class="o">...</span>

      <span class="c">(* put a wrapper round the auto-generated sexp_of_t to enforce</span>
<span class="c">         the invariants of the datastructure *)</span>
      <span class="k">let</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="nc">Empty</span>
        <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">create</span> <span class="n">x</span> <span class="n">y</span>

      <span class="o">....</span>

     <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span>
    <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="k">sig</span>
           <span class="k">type</span> <span class="n">t</span>
           <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
           <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
           <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
         <span class="k">end</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
      <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp8990144">
          And now, we can use that sexp-converter in the ordinary way:
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">(</span><span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Interval</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">(</span><span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Empty</span>
</pre></div></section></section><section><h1 id="extending-modules">Extending modules</h1><p id="idp8993072">
        One common use of functors is to generate type-specific
        functionality for a given module in a standardized way. We'll
        think about this in the context of an example of creating a
        simple data structure.
      </p><p id="idp8993712">
        The following is a minimal interface for a functional queue. A
        functional queue is simply a functional version of a FIFO
        (first-in, first-out) queue. Being functional, operations on the
        queue return new queues, rather than modifying the queues that
        were passed in.
      </p><div class="highlight"><pre><span class="c">(* file: fqueue.mli *)</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">enqueue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="c">(** [dequeue q] returns None if the [q] is empty *)</span>
<span class="k">val</span> <span class="n">dequeue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>
</pre></div><p id="idp8995824">
        A standard trick for implementing functional queues efficiently
        is to maintain both an input and an output list, where the input
        list is ordered to make <code>enqueue</code> fast, and the
        output list is ordered to make <code>dequeue</code> fast.
        When the output list is empty, the input list is reversed and
        becomes the new output list. Thinking through why this is
        efficient is a worthwhile exercise, but we won't dwell on that
        here.
      </p><p id="idp8998096">
        Here's a concrete implementation.
      </p><div class="highlight"><pre><span class="c">(* file: fqueue.ml *)</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="o">(</span><span class="bp">[]</span><span class="o">,</span><span class="bp">[]</span><span class="o">)</span>

<span class="k">let</span> <span class="n">enqueue</span> <span class="o">(</span><span class="n">l1</span><span class="o">,</span><span class="n">l2</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l1</span><span class="o">,</span><span class="n">l2</span><span class="o">)</span>

<span class="k">let</span> <span class="n">dequeue</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">out_list</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">tl</span><span class="o">))</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="bp">[]</span><span class="o">,</span> <span class="n">tl</span><span class="o">))</span>

<span class="k">let</span> <span class="n">fold</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span>
     <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span><span class="o">)</span>
</pre></div><p id="idp9000496">
        The code above works fine, but the interface it implements is
        unfortunately quite skeletal; there are lots of useful helper
        functions that one might want that aren't there. And
        implementing those helper functions can be something of a dull
        affair, since you need to implement essentially the same helper
        functions for multiple different data structures in essentially
        the same way.
      </p><p id="idp9001344">
        As it happens, many of these helper functions can be derived
        mechanically from just the fold function we already implemented.
        Rather than write all of these helper functions by hand for
        every new container type, we can instead use a functor to write
        the code for these once and for all, basing them off of the
        <code>fold</code> function.
      </p><p id="idp9003184">
        Let's create a new module, <code>Foldable</code>, that
        contains support for this. The first thing we'll need is a
        signature to describe a container that supports fold.
      </p><div class="highlight"><pre><span class="c">(* file: foldable.ml *)</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>
<span class="k">end</span>
</pre></div><p id="idp9005568">
        We'll also need a signature for the helper functions we're going
        to generate. This just represents some of the helper functions
        we can derive from fold, but it's enough to give you a flavor of
        what you can do.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">Extension</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">iter</span>    <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">length</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">count</span>   <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">for_all</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">val</span> <span class="n">exists</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
<span class="k">end</span>
</pre></div><p id="idp9007488">
        Finally, we can define the functor itself.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Extend</span><span class="o">(</span><span class="nc">Container</span> <span class="o">:</span> <span class="nc">S</span><span class="o">)</span>
  <span class="o">:</span> <span class="nc">Extension</span> <span class="k">with</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">'</span><span class="n">a</span> <span class="nn">C</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="k">open</span> <span class="nc">Container</span>

  <span class="k">let</span> <span class="n">iter</span>   <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span> <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">()</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="bp">()</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">length</span> <span class="n">t</span>    <span class="o">=</span> <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span>  <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">count</span>  <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span> <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span>  <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">count</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count</span> <span class="o">+</span> <span class="k">if</span> <span class="n">f</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">exception</span> <span class="nc">Short_circuit</span>

  <span class="k">let</span> <span class="n">for_all</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">try</span> <span class="n">iter</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">not</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="k">then</span> <span class="k">raise</span> <span class="nc">Short_circuit</span><span class="o">);</span> <span class="bp">true</span>
    <span class="k">with</span> <span class="nc">Short_circuit</span> <span class="o">-&gt;</span> <span class="bp">false</span>

  <span class="k">let</span> <span class="n">exists</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">try</span> <span class="n">iter</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">x</span> <span class="k">then</span> <span class="k">raise</span> <span class="nc">Short_circuit</span><span class="o">);</span> <span class="bp">false</span>
    <span class="k">with</span> <span class="nc">Short_circuit</span> <span class="o">-&gt;</span> <span class="bp">true</span>
<span class="k">end</span>
</pre></div><p id="idp9009696">
        Now we can apply this to <code>Fqueue</code>. First, we
        can extend the interface:
      </p><div class="highlight"><pre><span class="c">(* file: fqueue.mli, 2nd version *)</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">enqueue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">dequeue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>

<span class="k">include</span> <span class="nn">Foldable</span><span class="p">.</span><span class="nc">Extension</span> <span class="k">with</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
</pre></div><p id="idp9012192">
        In order to apply the functor, we'll put the definition of
        <code>Fqueue</code> in a sub-module called
        <code>T</code>, and then call
        <code>Foldable.Extend</code> on <code>T</code>.
        Here's how that code would look.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">T</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>

  <span class="o">....</span>

  <span class="k">let</span> <span class="n">fold</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="n">out_list</span><span class="o">)</span>
      <span class="o">~</span><span class="n">f</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span><span class="o">)</span>

<span class="k">end</span>
<span class="k">include</span> <span class="nc">T</span>
<span class="k">include</span> <span class="nn">Foldable</span><span class="p">.</span><span class="nc">Extend</span><span class="o">(</span><span class="nc">T</span><span class="o">)</span>
</pre></div><p id="idp9016768">
        This pattern comes up quite a bit in Core. It's used to
        implement various standard bits of functionality, including:
      </p><ul><li><p id="idp9017824">
            Comparison-based datastructures like maps and sets, based on
            the <code>Comparable</code> interface.
          </p></li><li><p id="idp9019424">
            Hash-based datastructures like hash sets and hash heaps.
          </p></li><li><p id="idp9020288">
            Support for so-called monadic libraries, like the ones
            discussed in <a href="error-handling.html">Chapter 8, <i>Error Handling</i></a> and
            <a href="concurrent-programming-with-async.html">Chapter 13, <i>Concurrent Programming with Async</i></a>.
            Here, the functor is used to provide a collection of
            standard helper functions based on the core
            <code>bind</code> and <code>return</code>
            operators.
          </p></li></ul></section></section><section><h1 id="first-class-modules">First class modules</h1><p id="idp9025456">
      _(jyh: I'm going to start some new text on FCM. We might want
      another chapter, but let's see how it goes. I've kept Ron's
      original text below.)
    </p><p id="idp9026016">
      OCaml provides several mechanisms for organizing your programs,
      including modules and functors, files and compilation units, and
      classes and objects. Files and compilation units
      (<code>.ml</code> and <code>.mli</code> files) are
      really just a simplified module system. Classes and objects are a
      different form of organization altogether (as we'll see in
      <a href="object-oriented-programming.html">Chapter 14, <i>Object Oriented Programming</i></a>. Yet, in
      each of these cases, there is a clear separation between types and
      values -- values cannot contain types, and types cannot contain
      values. And since modules can contain types, modules can't be
      values.
    </p><p id="idp9029200">
<span><em>(yminsky: Instead of saying that ml and mli files are a
      simplified module system, maybe say that they &quot;provide a
      simple way of creating modules and interfaces&quot;, or some such?
      It's not like there's a simplified module system floating
      around)</em></span>
</p><p id="idp9030608">
<span><em>(yminsky: consider dropping &quot;Yet&quot; in the
      above.)</em></span>
</p><p id="idp9031456">
      Next, we'll relax this restriction with <span><em>first-class
      modules</em></span>. &quot;First-class&quot; means that modules can
      be passed around as ordinary values that can be created from and
      converted back to regular modules. This is a relatively recent
      addition to the OCaml language, and while it might seem trivial to
      say, it has profound consequences on the language. First-class
      modules are strictly more expressive than any other organization
      mechanism, including classes and objects. Once you use first-class
      modules, you'll never want to go back.
    </p><p id="idp9033376">
<span><em>(yminsky: I wouldn't say they're strictly more
      expressive. For example, they don't give you a way of expressing
      sub typing relationships effectively, which objects
      do.)</em></span>
</p><p id="idp9034352">
      This is not say that first-class modules should be used
      indiscriminately. When you pass modules as values, the reason is
      to support dynamic behavior, and this can have a negative impact
      on understandability. As we proceed, we'll compare first-class
      modules to other techniques, and suggest alternatives when it
      seems appropriate.
    </p><p id="idp9035120">
      _(jyh: Original text You can think of OCaml as being broken up
      into two sub-language: a core language that is concerned with
      values and types, and a module language that is concerned with
      modules and module signatures. These sub-languages are stratified,
      in that modules can contain types and values, but ordinary values
      can't contain modules or module types. That means you can't do
      things like define a variable whose definition is a module, or a
      function that takes a module as an argument.
    </p><p id="idp9036064">
      OCaml provides a way around this stratification in the form of
      <span><em>first-class modules</em></span>. First-class modules are
      ordinary values that can be created from and converted back to
      regular modules. As we'll see, letting modules into the core
      language makes it possible to use more flexible and dynamic
      module-oriented designs.)_
    </p><section><h1 id="another-trivial-example">Another trivial example</h1><p id="idp9038336">
        Much as we did with functors, we'll start out with an utterly
        trivial example, to allow us to show the basic mechanics of
        first class modules with a minimum of fuss.
      </p><p id="idp9038928">
        A first-class module is created by packaging up a module with a
        signature that it satisfies. The following defines a simple
        signature and a module that matches it.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Three</span> <span class="o">:</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">struct</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Three</span> <span class="o">:</span> <span class="nc">X_int</span>
<span class="o">#</span> <span class="nn">Three</span><span class="p">.</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div><p id="idp9040640">
        We can then create a first-class module using the
        <code>module</code> keyword.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">three</span> <span class="o">=</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Three</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">three</span> <span class="o">:</span> <span class="o">(</span><span class="k">module</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">module</span><span class="o">&gt;</span>
</pre></div><p id="idp9042912">
        Note that the type of the first-class module,
        <code>(module X_int)</code>, is based on the name of the
        signature that we used in constructing it.
      </p><p id="idp9044160">
        To get at the contents of <code>three</code>, we need to
        unpack it into a module again, which we can do using the
        <code>val</code> keyword.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">New_three</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">three</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">New_three</span> <span class="o">:</span> <span class="nc">X_int</span>
<span class="o">#</span> <span class="nn">New_three</span><span class="p">.</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div><p id="idp9047104">
        Using these conversions as building blocks, we can create tools
        for working with first-class modules in a natural way. The
        following shows the definition of two function,
        <code>to_int</code>, which converts a
        <code>(module X_int)</code> into an
        <code>int</code>. And <code>plus</code>, which adds
        two <code>(module X_int)</code>s.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">to_int</span> <span class="n">m</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">module</span> <span class="nc">M</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">m</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">x</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">to_int</span> <span class="o">:</span> <span class="o">(</span><span class="k">module</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">plus</span> <span class="n">m1</span> <span class="n">m2</span> <span class="o">=</span>
    <span class="o">(</span><span class="k">module</span> <span class="k">struct</span>
       <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">to_int</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">to_int</span> <span class="n">m2</span>
     <span class="k">end</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">plus</span> <span class="o">:</span> <span class="o">(</span><span class="k">module</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9052912">
        With these functions in hand, we can start operating on our
        <code>(module X_int)</code>'s in a more natural style,
        taking full advantage of the concision and simplicity of the
        core language.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">six</span> <span class="o">=</span> <span class="n">plus</span> <span class="n">three</span> <span class="n">three</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">six</span> <span class="o">:</span> <span class="o">(</span><span class="k">module</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">module</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">to_int</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="n">six</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">plus</span> <span class="o">[</span><span class="n">three</span><span class="o">;</span><span class="n">three</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div><p id="idp9055616">
        Of course, all we've really done with this example is come up
        with a more cumbersome way of working with integers. Let's see
        what happens when with work with more complex abstract types.
      </p></section><section><h1 id="standard-vs.-first-class-modules">Standard vs. first-class modules</h1><p id="idp9057504">
<span><em>(yminsky: I'm not in solve with the example. It feels
        in some sense too artificial, and that aside, when you get to
        the end of the example, you haven't really gotten any juice of
        first-class modules)</em></span>
</p><p id="idp9058512">
<span><em>(yminsky: using &quot;standard&quot; in quotes seems a
        little awkward. Maybe just drop the quotes, and talk about
        standard or ordinary modules directly?)</em></span>
</p><p id="idp9059632">
        Let's compare the style of &quot;standard&quot; modules to
        first-class modules, using a simple library of abstract
        geometric shapes. In a &quot;standard&quot; module definition,
        we would define the shapes using abstract data types, where
        there is a type <code>t</code> that defines the actual
        representation, and the module would include functions that
        operate on the values of type <code>t</code>. In the
        following code, the module type <code>Shape</code> defines
        the type of generic shape, and the modules
        <code>Rectangle</code> and <code>Line</code>
        implement some concrete shapes.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">Shape</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">area</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">position</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Rectangle</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">height</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">}</span>
   <span class="k">let</span> <span class="n">make</span> <span class="o">~</span><span class="n">x</span> <span class="o">~</span><span class="n">y</span> <span class="o">~</span><span class="n">width</span> <span class="o">~</span><span class="n">height</span> <span class="o">=</span>
      <span class="o">{</span> <span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span> <span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">}</span>
   <span class="k">let</span> <span class="n">area</span> <span class="o">{</span> <span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span> <span class="n">height</span> <span class="o">=</span> <span class="n">height</span> <span class="o">}</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
   <span class="k">let</span> <span class="n">position</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">}</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Line</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">dx</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">dy</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">}</span>
   <span class="k">let</span> <span class="n">make</span> <span class="o">~</span><span class="n">x</span> <span class="o">~</span><span class="n">y</span> <span class="o">~</span><span class="n">dx</span> <span class="o">~</span><span class="n">dy</span> <span class="o">=</span> <span class="o">{</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="o">;</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">dy</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">}</span>
   <span class="k">let</span> <span class="n">area</span> <span class="o">_</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">let</span> <span class="n">position</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">}</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="k">end</span>
</pre></div><p id="idp9066288">
        Next, if we want to define a generic shape that is either a
        rectangle or a line, we would probably use a variant type. The
        following module <code>Shapes</code> is entirely
        boilerplate. We define the variant type, then functions to
        perform a dynamic dispatch based on the type of object.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Shapes</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Rect</span> <span class="k">of</span> <span class="nn">Rectangle</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Line</span> <span class="k">of</span> <span class="nn">Line</span><span class="p">.</span><span class="n">t</span> <span class="o">]</span>
   <span class="k">let</span> <span class="n">make_rectangle</span> <span class="o">=</span> <span class="nn">Rectangle</span><span class="p">.</span><span class="n">make</span>
   <span class="k">let</span> <span class="n">make_line</span> <span class="o">=</span> <span class="nn">Line</span><span class="p">.</span><span class="n">make</span>
   <span class="k">let</span> <span class="n">area</span> <span class="o">=</span> <span class="k">function</span>
      <span class="o">`</span><span class="nc">Rect</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="nn">Rectangle</span><span class="p">.</span><span class="n">area</span> <span class="n">r</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">Line</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="nn">Line</span><span class="p">.</span><span class="n">area</span> <span class="n">l</span>
   <span class="k">let</span> <span class="n">position</span> <span class="o">=</span> <span class="k">function</span>
      <span class="o">`</span><span class="nc">Rect</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="nn">Rectangle</span><span class="p">.</span><span class="n">position</span> <span class="n">r</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">Line</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="nn">Line</span><span class="p">.</span><span class="n">position</span> <span class="n">l</span>
<span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9069008">
        In fact, confronted with this boilerplate, we would probably
        choose not use modules at all, but simply define a single module
        with a variant type and the code for all of the shapes. This
        isn't to say that separate code for separate shapes is bad, it
        just means that the language doesn't support it well (at least
        with standard modules).
      </p><p id="idp9069808">
        With first-class modules, the situation changes, but we have to
        dispense with the representation type altogether. For immutable
        shapes, the implementation is now trivial.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Shape</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">val</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="k">val</span> <span class="n">position</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Shape</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">val</span> <span class="n">position</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">make_rectangle</span> <span class="o">~</span><span class="n">x</span> <span class="o">~</span><span class="n">y</span> <span class="o">~</span><span class="n">width</span> <span class="o">~</span><span class="n">height</span> <span class="o">=</span>
   <span class="k">let</span> <span class="k">module</span> <span class="nc">Rectangle</span> <span class="o">=</span> <span class="k">struct</span>
      <span class="k">let</span> <span class="n">area</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
      <span class="k">let</span> <span class="n">position</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
   <span class="k">end</span> <span class="k">in</span>
   <span class="o">(</span><span class="k">module</span> <span class="nc">Rectangle</span> <span class="o">:</span> <span class="nc">Shape</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">make_rectangle</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">width</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">height</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Shape</span><span class="o">)</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">make_line</span> <span class="o">~</span><span class="n">x</span> <span class="o">~</span><span class="n">y</span> <span class="o">~</span><span class="n">dx</span> <span class="o">~</span><span class="n">dy</span> <span class="o">=</span>
   <span class="k">let</span> <span class="k">module</span> <span class="nc">Line</span> <span class="o">=</span> <span class="k">struct</span>
      <span class="k">let</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">let</span> <span class="n">position</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
   <span class="k">end</span> <span class="k">in</span>
   <span class="o">(</span><span class="k">module</span> <span class="nc">Line</span> <span class="o">:</span> <span class="nc">Shape</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">make_line</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">dx</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">dy</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Shape</span><span class="o">)</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9072080">
        For mutable shapes, it isn't much different, but we have to
        include the state as values in the module implementations. For
        this, we'll define a representation type <code>t</code> in
        the module implementation, and for rectangles, a value
        <code>rect</code> of that type. The code for lines is
        similar.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Shape</span> <span class="o">=</span> <span class="k">sig</span>
     <span class="k">val</span> <span class="n">area</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span>
     <span class="k">val</span> <span class="n">position</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
     <span class="k">val</span> <span class="n">moveby</span> <span class="o">:</span> <span class="n">dx</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">dy</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
     <span class="k">val</span> <span class="n">enlargeby</span> <span class="o">:</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Shape</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">make_rectangle</span> <span class="o">~</span><span class="n">x</span> <span class="o">~</span><span class="n">y</span> <span class="o">~</span><span class="n">width</span> <span class="o">~</span><span class="n">height</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">module</span> <span class="nc">Rectangle</span> <span class="o">=</span> <span class="k">struct</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="k">mutable</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
                 <span class="k">mutable</span> <span class="n">width</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="k">mutable</span> <span class="n">height</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">}</span>
      <span class="k">let</span> <span class="n">rect</span> <span class="o">=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span> <span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span> <span class="n">height</span> <span class="o">=</span> <span class="n">height</span> <span class="o">}</span>
      <span class="k">let</span> <span class="n">area</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">rect</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">rect</span><span class="o">.</span><span class="n">height</span>
      <span class="k">let</span> <span class="n">position</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">(</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="o">,</span> <span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
      <span class="k">let</span> <span class="n">moveby</span> <span class="o">~</span><span class="n">dx</span> <span class="o">~</span><span class="n">dy</span> <span class="o">=</span>
         <span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;-</span> <span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">;</span>
         <span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;-</span> <span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span>
      <span class="k">let</span> <span class="n">enlargeby</span> <span class="o">~</span><span class="n">size</span> <span class="o">=</span>
         <span class="n">rect</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;-</span> <span class="n">rect</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">size</span><span class="o">;</span>
         <span class="n">rect</span><span class="o">.</span><span class="n">height</span> <span class="o">&lt;-</span> <span class="n">rect</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">size</span>
    <span class="k">end</span> <span class="k">in</span>
    <span class="o">(</span><span class="k">module</span> <span class="nc">Rectangle</span> <span class="o">:</span> <span class="nc">Shape</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">make_rectangle</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">width</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">height</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Shape</span><span class="o">)</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div></section><section><h1 id="a-more-complete-example----containers">A more complete example -- containers</h1><p id="idp9077808">
        So far, we haven't done anything that really needs modules. The
        type <code>Shape</code> could just as well be specified as
        a record type
        <code>type shape = { area : int; position : int * int; ... }</code>.
      </p><p id="idp9079808">
        To explore the topic more fully, let's implement a system of
        dynamic containers. OCaml already provides a set of standard
        containers like <code>List</code>, <code>Set</code>,
        <code>Hashtbl</code>, etc., but these types have to be
        selected statically. If a function expects a value of type
        <code>Set.Make(ElementType).t</code>, then you have to
        pass it a set of exactly that type. What we would like is a kind
        of container where the container implementation is chosen by the
        caller. We define an abstract <span><em>interface</em></span>, as
        a module type, then define one or more concrete module
        implementations.
      </p><p id="idp9084048">
        Let's start by defining an abstract container interface. It
        contains some elements of type <code>elt</code>, and
        functions to examine and iterate through the contents. For
        convenience, we also define a normal type
        <code>'a container</code> to represent containers with
        elements of type <code>'a</code>.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">Container</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">elt</span>
   <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="o">(</span><span class="n">elt</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
<span class="k">end</span><span class="o">;;</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">container</span> <span class="o">=</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Container</span> <span class="k">with</span> <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span>
</pre></div><section><h1 id="imperative-containers">Imperative containers</h1><p id="idp9089120">
          For imperative containers, will also want functions to mutate
          the contents by adding or removing elements. For example, a
          stack can be implemented as a module <code>Stack</code>
          that includes all the functions in the generic
          <code>Container</code> module, as well as functions to
          push and pop elements.
        </p><div class="highlight"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">Stack</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">include</span> <span class="nc">Container</span>
   <span class="k">val</span> <span class="n">push</span> <span class="o">:</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
   <span class="k">val</span> <span class="n">pop</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">elt</span>
<span class="k">end</span><span class="o">;;</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">stack</span> <span class="o">=</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Stack</span> <span class="k">with</span> <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span>
</pre></div><p id="idp9092592">
          Now that the types are defined, the next step is to define a
          concrete container implementation. For this simple example,
          we'll use a list to represent a stack. The function
          <code>make_list_stack</code> constructs module
          implementation using a <code>let module</code>
          construction, then returns the result.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">make_list_stack</span> <span class="o">(</span><span class="k">type</span> <span class="n">element</span><span class="o">)</span> <span class="bp">()</span> <span class="o">:</span> <span class="n">element</span> <span class="n">stack</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">module</span> <span class="nc">ListStack</span> <span class="o">=</span> <span class="k">struct</span>
      <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">element</span>
      <span class="k">let</span> <span class="n">contents</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span>
      <span class="k">let</span> <span class="n">empty</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">!</span><span class="n">contents</span> <span class="o">=</span> <span class="bp">[]</span>
      <span class="k">let</span> <span class="n">iter</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">f</span> <span class="o">!</span><span class="n">contents</span>
      <span class="k">let</span> <span class="n">fold</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">f</span> <span class="n">x</span> <span class="o">!</span><span class="n">contents</span>
      <span class="k">let</span> <span class="n">push</span> <span class="n">x</span> <span class="o">=</span> <span class="n">contents</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">::</span> <span class="o">!</span><span class="n">contents</span>
      <span class="k">let</span> <span class="n">pop</span> <span class="bp">()</span> <span class="o">=</span>
         <span class="k">match</span> <span class="o">!</span><span class="n">contents</span> <span class="k">with</span>
            <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="o">-&gt;</span> <span class="n">contents</span> <span class="o">:=</span> <span class="n">rest</span><span class="o">;</span> <span class="n">x</span>
          <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;stack is empty&quot;</span><span class="o">)</span>
    <span class="k">end</span> <span class="k">in</span>
    <span class="o">(</span><span class="k">module</span> <span class="nc">ListStack</span> <span class="o">:</span> <span class="nc">Stack</span> <span class="k">with</span> <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">element</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">make_list_stack</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">stack</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9096448">
          Note the use of the explicit type parameter
          <code>element</code>. This is required because the use
          of a type variable in the module definition (like
          <code>type elt = 'a</code>) would be rejected by the
          compiler. The construction and use of the stack is
          straightforward.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">demo</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">stack</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">module</span> <span class="nc">S</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">s</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">S</span><span class="p">.</span><span class="n">push</span> <span class="mi">5</span><span class="o">;</span>
    <span class="nn">S</span><span class="p">.</span><span class="n">push</span> <span class="mi">17</span><span class="o">;</span>
    <span class="nn">S</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Element: %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">demo</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">stack</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">demo</span> <span class="o">(</span><span class="n">make_list_stack</span> <span class="bp">()</span><span class="o">);;</span>
<span class="nc">Element</span><span class="o">:</span> <span class="mi">17</span>
<span class="nc">Element</span><span class="o">:</span> <span class="mi">5</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp9100080">
          The <code>demo</code> function is entirely oblivious to
          the implementation of the stack. Instead of passing a module
          implementation based on lists, we could pass a different
          implementation based on arrays.
        </p><p id="idp9101424">
          We could go on to define other containers, sets, dictionaries,
          queues, etc. but the implementations would be similar to what
          we have seen. Instead, let's look at functional data
          structures, which require a little more work to express.
        </p></section><section><h1 id="pure-functional-containers">Pure functional containers</h1><p id="idp9103328">
          Imperative data structures have simpler types that functional
          ones because the return type of imperative functions is just
          <code>unit</code>. When we look at pure functional data
          structures, we immediately run into a problem with type
          recursion.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Container</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">elt</span>
    <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="o">(</span><span class="n">elt</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
    <span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
    <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Container</span><span class="o">)</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">160</span><span class="o">-</span><span class="mi">178</span><span class="o">:</span>
     <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Container</span><span class="o">)</span>
                      <span class="o">^^^^^^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Container</span>
</pre></div><p id="idp9106144">
          The problem here is that module type definitions are not
          recursive -- we can't use the type being defined in its own
          definition.
        </p><p id="idp9106720">
          Recursive modules provide a solution, but it requires a
          &quot;trick&quot;, where we define a module that is equal to
          itself. This module contains only type definitions, and the
          only purpose of the outer recursive module is to allow the
          recursion in the definition. While we're at it, let's include
          a <code>map</code> function with the usual semantics.
        </p><div class="highlight"><pre><span class="k">module</span> <span class="k">rec</span> <span class="nc">Container</span> <span class="o">:</span> <span class="k">sig</span>
   <span class="k">module</span> <span class="k">type</span> <span class="nc">T</span> <span class="o">=</span> <span class="k">sig</span>
      <span class="k">type</span> <span class="n">elt</span>
      <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="o">(</span><span class="n">elt</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
      <span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
      <span class="k">val</span> <span class="n">map</span> <span class="o">:</span> <span class="o">(</span><span class="n">elt</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Container</span><span class="p">.</span><span class="n">t</span>
      <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="nn">Container</span><span class="p">.</span><span class="n">t</span>
   <span class="k">end</span>
   <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="k">module</span> <span class="nn">Container</span><span class="p">.</span><span class="nc">T</span> <span class="k">with</span> <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span>
<span class="k">end</span> <span class="o">=</span> <span class="nc">Container</span><span class="o">;;</span>
</pre></div><p id="idp9110160">
          There are several ways to write this model, but this
          definition is convenient because it defines both a module type
          <code>Container.T</code> and a value type
          <code>'a Container.t</code>. The outer recursive module
          <code>Container</code> allows the module type
          <code>T</code> to refer to the value type
          <code>t</code> and <span><em>vice versa</em></span>. Note
          that the module <code>Container</code> is defined as
          itself (as <code>Container</code>).
        </p><p id="idp9116224">
          With this first technicality out of the way, the next one is
          how to construct values of type
          <code>Container.t</code>. In the imperative version of
          the stack, we used a function
          <code>make_list_stack</code>. We want to do the same
          here, but the function definition must be both recursive and
          polymorphic.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">make_stack</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">make</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="o">.</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Container</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="k">fun</span>
      <span class="o">(</span><span class="k">type</span> <span class="n">element</span><span class="o">)</span> <span class="o">(</span><span class="n">contents</span> <span class="o">:</span> <span class="n">element</span> <span class="kt">list</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="k">module</span> <span class="nc">NewList</span> <span class="o">=</span> <span class="k">struct</span>
         <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">element</span>
         <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">contents</span> <span class="o">=</span> <span class="bp">[]</span>
         <span class="k">let</span> <span class="n">iter</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">f</span> <span class="n">contents</span>
         <span class="k">let</span> <span class="n">fold</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">f</span> <span class="n">x</span> <span class="n">contents</span>
         <span class="k">let</span> <span class="n">map</span> <span class="n">f</span> <span class="o">=</span> <span class="n">make</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">f</span> <span class="n">contents</span><span class="o">)</span>
         <span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="o">=</span> <span class="n">make</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">contents</span><span class="o">)</span>
      <span class="k">end</span> <span class="k">in</span>
      <span class="o">(</span><span class="k">module</span> <span class="nc">NewList</span> <span class="o">:</span> <span class="nn">Container</span><span class="p">.</span><span class="nc">T</span> <span class="k">with</span> <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="n">element</span><span class="o">)</span>
   <span class="k">in</span>
   <span class="n">make</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">make_stack</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Container</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp9120848">
          The recursion here is particularly important. The functions
          <code>map</code> and <code>add</code> return new
          collections, so they call the function <code>make</code>
          recursively. The explicit polymorphic type
          <code>make : 'a. 'a list -&gt; 'a Container.t</code>
          means that the function <code>make</code> is properly
          polymorphic, so that the <code>map</code> function is
          polymorphic.
        </p><p id="idp9125760">
          Now that the construction is done, the usage is similar to the
          imperative case, except that now the data structure is
          functional.
        </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">demo</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Container</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">module</span> <span class="nc">S</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">s</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="k">module</span> <span class="nc">S</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="o">(</span><span class="nn">S</span><span class="p">.</span><span class="n">add</span> <span class="mi">5</span><span class="o">))</span> <span class="k">in</span>
    <span class="k">let</span> <span class="k">module</span> <span class="nc">S</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="o">(</span><span class="nn">S</span><span class="p">.</span><span class="n">add</span> <span class="mi">17</span><span class="o">))</span> <span class="k">in</span>
    <span class="nn">S</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Int Element: %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">S</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">float_of_int</span> <span class="n">i</span> <span class="o">+.</span> <span class="mi">0</span><span class="o">.</span><span class="mi">1</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="k">module</span> <span class="nc">S</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">s</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">S</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Float Element: %f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">x</span><span class="o">);</span>
    <span class="n">s</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">demo</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Container</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="nn">Container</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">demo</span> <span class="o">(</span><span class="n">make_stack</span> <span class="bp">()</span><span class="o">);;</span>
<span class="nc">Int</span> <span class="nc">Element</span><span class="o">:</span> <span class="mi">17</span>
<span class="nc">Int</span> <span class="nc">Element</span><span class="o">:</span> <span class="mi">5</span>
<span class="nc">Float</span> <span class="nc">Element</span><span class="o">:</span> <span class="mi">17</span><span class="o">.</span><span class="mi">100000</span>
<span class="nc">Float</span> <span class="nc">Element</span><span class="o">:</span> <span class="mi">5</span><span class="o">.</span><span class="mi">100000</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp9127968">
          The syntactic load here is pretty high, requiring a
          <code>let module</code> expression to name every
          intermediate value. First-class modules are fairly new to the
          language, and this is likely to change, but in the meantime
          the syntactic load can be pretty daunting.
        </p><p id="idp9129376">
          Let's look a some other more typical examples, where dynamic
          module selection is more localized.
        </p><p id="idp9129904">
          _(jyh: This is a rough draft, I'm not sure about the ordering
          and the topics, yet. Switching back to Ron's text now.)
        </p></section></section><section><h1 id="dynamically-choosing-a-module">Dynamically choosing a module</h1><p id="idp9131840">
        Perhaps the simplest thing you can do with first-class modules
        that you can't do without them is to pick the implementation of
        a module at runtime.
      </p><p id="idp9132416">
        Consider an application that does I/O multiplexing using a
        system call like <code>select</code> to determine which
        file descriptors are ready to use. There are in fact multiple
        APIs you might want to use, including <code>select</code>
        itself, <code>epoll</code>, and <code>libev</code>,
        where different multiplexers make somewhat different performance
        and portability trade-offs. You could support all of these in
        one application by defining a single module, let's call it
        <code>Mutliplexer</code>, whose implementation is chosen
        at run-time based on an environment variable.
      </p><p id="idp9136928">
        To do this, you'd first need an interface <code>S</code>
        that all of the different multiplexer implementations would need
        to match, and then an implementation of each multiplexer.
      </p><div class="highlight"><pre><span class="c">(* file: multiplexer.ml *)</span>

<span class="c">(* An interface the OS-specific functionality *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">sig</span> <span class="o">...</span> <span class="k">end</span>

<span class="c">(* The implementations of each individual multiplexer *)</span>
<span class="k">module</span> <span class="nc">Select</span> <span class="o">:</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">struct</span> <span class="o">...</span> <span class="k">end</span>  
<span class="k">module</span> <span class="nc">Epoll</span>  <span class="o">:</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">struct</span> <span class="o">...</span> <span class="k">end</span>
<span class="k">module</span> <span class="nc">Libev</span>  <span class="o">:</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">struct</span> <span class="o">...</span> <span class="k">end</span>
</pre></div><p id="idp9139408">
        We can choose the first-class module that we want based on
        looking up an environment variable.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">multiplexer</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">getenv</span> <span class="s2">&quot;MULTIPLEXER&quot;</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="s2">&quot;select&quot;</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Select</span> <span class="o">:</span> <span class="nc">S</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="s2">&quot;epoll&quot;</span>  <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Epoll</span> <span class="o">:</span> <span class="nc">S</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="s2">&quot;libev&quot;</span>  <span class="o">-&gt;</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Libev</span> <span class="o">:</span> <span class="nc">S</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">other</span> <span class="o">-&gt;</span> <span class="n">failwithf</span> <span class="s2">&quot;Unknown multiplexer: %s&quot;</span> <span class="n">other</span> <span class="bp">()</span>
</pre></div><p id="idp9141280">
        Finally, we can convert the resulting first-class module back to
        an ordinary module, and then include that so it becomes part of
        the body of our module.
      </p><div class="highlight"><pre><span class="c">(* The final, dynamically chosen, implementation *)</span>
<span class="k">include</span> <span class="o">(</span><span class="k">val</span> <span class="n">multiplexer</span> <span class="o">:</span> <span class="nc">S</span><span class="o">)</span>
</pre></div></section><section><h1 id="example-a-service-bundle">Example: A service bundle</h1><p id="idp9144160">
        This section describes the design of a library for bundling
        together multiple services, where a service is a piece of code
        that exports a query interface. A service bundle combines
        together multiple individual services under a single query
        interface that works by dispatching incoming queries to the
        appropriate underlying service.
      </p><p id="idp9144944">
        The following is a first attempt at an interface for our
        <code>Service</code> module, which contains both a module
        type <code>S</code>, which is the interface that a service
        should meet, as well as a <code>Bundle</code> module which
        is for combining multiple services.
      </p><div class="highlight"><pre><span class="c">(* file: service.mli *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(** The module type for a service. *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">name</span>           <span class="o">:</span> <span class="kt">string</span>
  <span class="k">val</span> <span class="n">create</span>         <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">handle_request</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">t</span>
<span class="k">end</span>

<span class="c">(** Bundles multiple services together *)</span>
<span class="k">module</span> <span class="nc">Bundle</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">(</span><span class="k">module</span> <span class="nc">S</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">handle_request</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">t</span>
  <span class="k">val</span> <span class="n">service_names</span>  <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span>
<span class="k">end</span>
</pre></div><p id="idp9149376">
        Here, a service has a state, represented by the type
        <code>t</code>, a name by which the service can be
        referenced, a function <code>create</code> for
        instantiating a service, and a function by which a service can
        actually handle a request. Here, requests and responses are
        delivered as s-expressions. At the <code>Bundle</code>
        level, the s-expression of a request is expected to be formatted
        as follows:
      </p><pre id="idp9152272">
(&lt;service-name&gt; &lt;body&gt;)
</pre><p id="idp9152976">
        where <code>&lt;service_name&gt;</code> is the service
        that should handle the request, and
        <code>&lt;body&gt;</code> is the body of the request.
      </p><p id="idp9154912">
        Now let's look at how to implement <code>Service</code>.
        The core datastructure of <code>Bundle</code> is a
        hashtable of request handlers, one per service. Each request
        handler is a function of type
        <code>(Sexp.t -&gt; Sexp.t Or_error.t)</code>. These
        request handlers really stand in for the underlying service,
        with the particular state of the service in question being
        hidden inside of the request handler.
      </p><p id="idp9157888">
        The first part of <code>service.ml</code> is just the
        preliminaries: the definition of the module type
        <code>S</code>, and the definition of the type
        <code>Bundle.t</code>.
      </p><div class="highlight"><pre><span class="c">(* file: service.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">name</span>           <span class="o">:</span> <span class="kt">string</span>
  <span class="k">val</span> <span class="n">create</span>         <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">handle_request</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">t</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Bundle</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span> <span class="n">handlers</span><span class="o">:</span> <span class="o">(</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="nn">String</span><span class="p">.</span><span class="nn">Table</span><span class="p">.</span><span class="n">t</span><span class="o">;</span> <span class="o">}</span>
</pre></div><p id="idp9162080">
        The next thing we need is a function for creating a
        <code>Bundle.t</code>. This <code>create</code>
        function builds a table to hold the request handlers, and then
        iterates through the services, unpacking each module,
        constructing the request handler, and then putting that request
        handler in the table.
      </p><div class="highlight"><pre>  <span class="c">(** Creates a handler given a list of services *)</span>
  <span class="k">let</span> <span class="n">create</span> <span class="n">services</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">handlers</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="nn">Table</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">services</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">service_m</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="k">module</span> <span class="nc">Service</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">service_m</span> <span class="o">:</span> <span class="nc">S</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">service</span> <span class="o">=</span> <span class="nn">Service</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
      <span class="k">if</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">mem</span> <span class="n">handlers</span> <span class="nn">Service</span><span class="p">.</span><span class="n">name</span> <span class="k">then</span>
        <span class="n">failwith</span> <span class="o">(</span><span class="s2">&quot;Attempt to register duplicate handler for &quot;</span><span class="o">^</span><span class="nn">Service</span><span class="p">.</span><span class="n">name</span><span class="o">);</span>
      <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">replace</span> <span class="n">handlers</span> <span class="o">~</span><span class="n">key</span><span class="o">:</span><span class="nn">Service</span><span class="p">.</span><span class="n">name</span>
        <span class="o">~</span><span class="n">data</span><span class="o">:(</span><span class="k">fun</span> <span class="n">sexp</span> <span class="o">-&gt;</span> <span class="nn">Service</span><span class="p">.</span><span class="n">handle_request</span> <span class="n">service</span> <span class="n">sexp</span><span class="o">)</span>
    <span class="o">);</span>
    <span class="o">{</span><span class="n">handlers</span><span class="o">}</span>
</pre></div><p id="idp9165904">
        Note that the <code>Service.t</code> that is created is
        referenced by the corresponding request handler, so that it is
        effectively hidden behind the function in the
        <code>handlers</code> table.
      </p><p id="idp9167904">
        Now we can write the function for the bundle to handle requests.
        The handler will examine the s-expression to determine the body
        of the query and the name of the service to dispatch to. It then
        looks up the handler calls it to generate the response.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">handle_request</span> <span class="n">t</span> <span class="n">sexp</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">sexp</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nn">Sexp</span><span class="p">.</span><span class="nc">List</span> <span class="o">[</span><span class="nn">Sexp</span><span class="p">.</span><span class="nc">Atom</span> <span class="n">name</span><span class="o">;</span><span class="n">query</span><span class="o">]</span> <span class="o">-&gt;</span>
      <span class="k">begin</span> <span class="k">match</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">t</span><span class="o">.</span><span class="n">handlers</span> <span class="n">name</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">error_string</span> <span class="o">(</span><span class="s2">&quot;Unknown service: &quot;</span><span class="o">^</span><span class="n">name</span><span class="o">)</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">handler</span> <span class="o">-&gt;</span>
        <span class="k">try</span> <span class="n">handler</span> <span class="n">query</span>
        <span class="k">with</span> <span class="n">exn</span> <span class="o">-&gt;</span> <span class="nc">Error</span> <span class="o">(</span><span class="nn">Error</span><span class="p">.</span><span class="n">of_exn</span> <span class="n">exn</span><span class="o">)</span>
      <span class="k">end</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">error_string</span> <span class="s2">&quot;Malformed query&quot;</span>
</pre></div><p id="idp9169936">
        Last of all, we define a function for looking up the names of
        the available services.
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">service_names</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">keys</span> <span class="n">t</span><span class="o">.</span><span class="n">handlers</span>

<span class="k">end</span>
</pre></div><p id="idp9171440">
        To see this system in action, we need to define some services,
        create the corresponding bundle, and then hook that bundle up to
        some kind of client. For simplicity, we'll build a simple
        command-line interface. There are two functions below:
        <code>handle_one</code>, which handles a single
        interaction; and <code>handle_loop</code>, which creates
        the bundle and then runs <code>handle_one</code> in a
        loop.
      </p><div class="highlight"><pre><span class="c">(* file: service_client.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(** Handles a single request coming from stdin *)</span>
<span class="k">let</span> <span class="n">handle_one</span> <span class="n">bundle</span> <span class="o">=</span>
  <span class="n">printf</span> <span class="s2">&quot;&gt;&gt;&gt; %!&quot;</span><span class="o">;</span> <span class="c">(* prompt *)</span>
  <span class="k">match</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">input_line</span> <span class="n">stdin</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="o">`</span><span class="nc">Stop</span> <span class="c">(* terminate on end-of-stream, so Ctrl-D will exit *)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">line</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">line</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">strip</span> <span class="n">line</span> <span class="k">in</span> <span class="c">(* drop leading and trailing whitespace *)</span>
    <span class="k">if</span> <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">then</span> <span class="o">`</span><span class="nc">Continue</span>
    <span class="k">else</span> <span class="k">match</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">try_with</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">of_string</span> <span class="n">line</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Error</span> <span class="n">err</span> <span class="o">-&gt;</span>
      <span class="n">eprintf</span> <span class="s2">&quot;Couldn't parse query: %s</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="o">(</span><span class="nn">Error</span><span class="p">.</span><span class="n">to_string_hum</span> <span class="n">err</span><span class="o">);</span>
      <span class="o">`</span><span class="nc">Continue</span>
    <span class="o">|</span> <span class="nc">Ok</span> <span class="n">query_sexp</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">resp</span> <span class="o">=</span> <span class="nn">Service</span><span class="p">.</span><span class="nn">Bundle</span><span class="p">.</span><span class="n">handle_request</span> <span class="n">bundle</span> <span class="n">query_sexp</span> <span class="k">in</span>
      <span class="nn">Sexp</span><span class="p">.</span><span class="n">output_hum</span> <span class="n">stdout</span> <span class="o">(&lt;:</span><span class="n">sexp_of</span><span class="o">&lt;</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">t</span><span class="o">&gt;&gt;</span> <span class="n">resp</span><span class="o">);</span>
      <span class="nn">Out_channel</span><span class="p">.</span><span class="n">newline</span> <span class="n">stdout</span><span class="o">;</span>
      <span class="o">`</span><span class="nc">Continue</span>

<span class="k">let</span> <span class="n">handle_loop</span> <span class="n">services</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">bundle</span> <span class="o">=</span> <span class="nn">Service</span><span class="p">.</span><span class="nn">Bundle</span><span class="p">.</span><span class="n">create</span> <span class="n">services</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">handle_one</span> <span class="n">bundle</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">Stop</span> <span class="o">-&gt;</span> <span class="bp">()</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">Continue</span> <span class="o">-&gt;</span> <span class="n">loop</span> <span class="bp">()</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="bp">()</span>
</pre></div><p id="idp9176864">
        Now we'll create a couple of toy services. One service is a
        counter that can be updated by query; and the other service
        lists a directory. The last line then kicks off the shell with
        the services we've defined.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Counter</span> <span class="o">:</span> <span class="nn">Service</span><span class="p">.</span><span class="nc">S</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span> <span class="n">ref</span>

  <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;update-counter&quot;</span>
  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span>

  <span class="k">let</span> <span class="n">handle_request</span> <span class="n">t</span> <span class="n">sexp</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">try_with</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">int_of_sexp</span> <span class="n">sexp</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Error</span> <span class="o">_</span> <span class="k">as</span> <span class="n">err</span> <span class="o">-&gt;</span> <span class="n">err</span>
    <span class="o">|</span> <span class="nc">Ok</span> <span class="n">x</span> <span class="o">-&gt;</span>
      <span class="n">t</span> <span class="o">:=</span> <span class="o">!</span><span class="n">t</span> <span class="o">+</span> <span class="n">x</span><span class="o">;</span>
      <span class="nc">Ok</span> <span class="o">(</span><span class="n">sexp_of_int</span> <span class="o">!</span><span class="n">t</span><span class="o">)</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">List_dir</span> <span class="o">:</span> <span class="nn">Service</span><span class="p">.</span><span class="nc">S</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">unit</span>

  <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;ls&quot;</span>
  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="bp">()</span>

  <span class="k">let</span> <span class="n">handle_request</span> <span class="bp">()</span> <span class="n">sexp</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">Or_error</span><span class="p">.</span><span class="n">try_with</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">string_of_sexp</span> <span class="n">sexp</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Error</span> <span class="o">_</span> <span class="k">as</span> <span class="n">err</span> <span class="o">-&gt;</span> <span class="n">err</span>
    <span class="o">|</span> <span class="nc">Ok</span> <span class="n">dir</span> <span class="o">-&gt;</span> <span class="nc">Ok</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="nn">String</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">readdir</span> <span class="n">dir</span><span class="o">))</span>
<span class="k">end</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">handle_loop</span> <span class="o">[(</span><span class="k">module</span> <span class="nc">List_dir</span> <span class="o">:</span> <span class="nn">Service</span><span class="p">.</span><span class="nc">S</span><span class="o">);</span> <span class="o">(</span><span class="k">module</span> <span class="nc">Counter</span> <span class="o">:</span> <span class="nn">Service</span><span class="p">.</span><span class="nc">S</span><span class="o">)]</span>
</pre></div><p id="idp9179504">
        And now we can go ahead and start up the client.
      </p><pre id="idp9179968">
$ ./service_client.byte
&gt;&gt;&gt; (update-counter 1)
(Ok 1)
&gt;&gt;&gt; (update-counter 10)
(Ok 11)
&gt;&gt;&gt; (ls .)
(Ok
 (_build _tags service.ml service.mli service.mli~ service.ml~
  service_client.byte service_client.ml service_client.ml~))
&gt;&gt;&gt;
</pre><p id="idp9181232">
        Now, let's consider what happens to the design when we want to
        make the interface of a service a bit more realistic. In
        particular, right now services are created without any
        configuration. Let's add a config type to each service, and
        change the interface of <code>Bundle</code> so that
        services can be registered along with their configs. At the same
        time, we'll change the <code>Bundle</code> API to allow
        services to be changed dynamically, rather than just added at
        creation time.
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="files-modules-and-programs.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="input-and-output.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>