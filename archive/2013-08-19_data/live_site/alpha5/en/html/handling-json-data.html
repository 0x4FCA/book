<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 14. Handling JSON data / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha5',
                        page: 'handling\u002Djson\u002Ddata.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="maps-and-hashtables.html">12. Maps and Hashtables</a>
                                            </li>
                                        
                                            <li>
                                                <a href="command-line-parsing.html">13. Command Line Parsing</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html" class="here">14. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-with-ocamllex-and-menhir.html">15. Parsing with OCamllex and Menhir</a>
                                            </li>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html">16. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="concurrent-programming-with-async.html">17. Concurrent Programming with Async</a>
                                            </li>
                                        
                                            <li>
                                                <a href="fast-binary-serialization.html">18. Fast Binary Serialization</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">19. Plugins with First-class Modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="xml-streams-and-trees.html">20. XML Streams and Trees</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 14. Handling JSON data</h1>
                
                

    <p id="idp9910560">
    Data serialization, <span><em>i.e.</em></span> converting data to and
    from a sequence of bytes that's suitable for writing to disk or
    sending across the network, is an important and common programming
    task. Sometimes you need to match someone else's data format (such
    as XML), sometimes you need a highly efficient format, and sometimes
    you just want something that is easy for humans to read and edit. To
    this end, OCaml comes with several techniques for data serialization
    depending on what your problem is.
  </p><p id="idp9911920">
    We'll start by using the popular and simple JSON data format, and
    then look at other serialization formats later in in the book. This
    chapter introduces you to a couple of new techniques that glue
    together the basic ideas from Part I of the book:
  </p><ul><li><p id="idp9913104">
        Using polymorphic variants to write more extensible libraries
        and protocols (but still retain the ability to extend them if
        needed)
      </p></li><li><p id="idp9914048">
        The use of <span><em>combinators</em></span> to compose common
        operations over data structures in a type-safe way.
      </p></li><li><p id="idp9915360">
        Using external tools to generate boilerplate OCaml modules and
        signatures from external specification files.
      </p></li></ul><section><h1 id="json-basics">JSON Basics</h1><p id="idp9917296">
      JSON is a lightweight data-interchange format often used in web
      services and browsers. It's described in
      <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_top">RFC4627</a>,
      and is easier to parse and generate than alternatives such as XML.
      You'll run into JSON very often when working with modern web APIs,
      so we'll cover several different ways to manipulate it in this
      chapter.
    </p><p id="idp9918784">
      JSON consists of two basic structures: an unordered collection of
      key/value pairs, and an ordered list of values. Values can be
      strings, booleans, floats, integers or null. Let's see what a JSON
      record for an example book description looks like:
    </p><div class="highlight"><pre><span class="p">{</span>
  <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Real World OCaml&quot;</span><span class="p">,</span>
  <span class="nt">&quot;tags&quot;</span> <span class="p">:</span> <span class="p">[</span> <span class="s2">&quot;functional programming&quot;</span><span class="p">,</span> <span class="s2">&quot;ocaml&quot;</span><span class="p">,</span> <span class="s2">&quot;algorithms&quot;</span> <span class="p">],</span>
  <span class="nt">&quot;pages&quot;</span><span class="p">:</span> <span class="mi">450</span><span class="p">,</span>
  <span class="nt">&quot;authors&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Jason Hickey&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Google&quot;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Anil Madhavapeddy&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Cambridge&quot;</span><span class="p">},</span>
    <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Yaron Minsky&quot;</span><span class="p">,</span> <span class="nt">&quot;affiliation&quot;</span><span class="p">:</span> <span class="s2">&quot;Jane Street&quot;</span><span class="p">}</span>
  <span class="p">],</span>
  <span class="nt">&quot;is_online&quot;</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div><p id="idp9920768">
      The outermost JSON value is usually a record (delimited by the
      curly braces) and contains an unordered set of key/value pairs.
      The keys must be strings but values can be any JSON type. In the
      example above, <code>tags</code> is a string list, while the
      <code>authors</code> field contains a list of records.
      Unlike OCaml lists, JSON lists can contain multiple different JSON
      types within a single list.
    </p><p id="idp9922992">
      This free-form nature of JSON types is both a blessing and a
      curse. It's very easy to generate JSON values, but code that
      parses them also has to handle subtle variations in how the values
      are represented. For example, what if the <code>pages</code>
      value above is actually represented as a string value of
      <code>&quot;450&quot;</code> instead of an integer?
    </p><p id="idp9925152">
      Our first task is to parse the JSON into a more structured OCaml
      type so that we can use static typing more effectively. When
      manipulating JSON in Python or Ruby, you might write unit tests to
      check that you have handled unusual inputs. The OCaml model
      prefers compile-time static checking as well as unit tests. For
      example, using pattern matching can warn you if you've not checked
      that a value can be <code>Null</code> as well as contain an
      actual value.
    </p><aside class="note"><h1>
    Installing the Yojson library
    </h1><p id="idp9927888">
      There are several JSON libraries available for OCaml. For this
      chapter, we've picked the
      <a href="http://mjambon.com/yojson.html" target="_top"><code>Yojson</code></a>
      library by Martin Jambon. It's easiest to install via OPAM.
    </p><pre id="idp9929584">
$ opam install yojson
</pre><p id="idp9930272">
      See <a href="installation.html">Appendix A, <i>Installation</i></a> for installation
      instructions if you haven't already got OPAM. Once installed, you
      can open it in the <code>utop</code> toplevel by:
    </p><pre id="idp9932176">
#require &quot;yojson&quot; ;;
open Yojson ;;
</pre></aside></section><section><h1 id="parsing-json-with-yojson">Parsing JSON with Yojson</h1><p id="idp9934384">
      The JSON specification has very few data types, and the
      <code>Yojson.Basic.json</code> type shown below is
      sufficient to express any valid JSON structure.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span>
</pre></div><p id="idp9936736">
      Some interesting properties should leap out at you after reading
      this definition:
    </p><ul><li><p id="idp9937744">
          Some of the type definitions are
          <span><em>recursive</em></span> (that is, one of the algebraic
          data types includes a reference to the name of the type being
          defined). Fields such as <code>Assoc</code> can contain
          references to more JSON fields, and thus precisely describe
          the underlying JSON data structure. The JSON
          <code>List</code> can contain fields of different types,
          unlike the OCaml <code>list</code> whose contents must
          be uniform.
        </p></li><li><p id="idp9941520">
          The definition specifically includes a <code>Null</code>
          variant for empty fields. OCaml doesn't allow null values by
          default, so this must be encoded like any other value.
        </p></li><li><p id="idp9943200">
          The type definition uses polymorphic variants and not normal
          variants. This will become significant later when we extend it
          with custom extensions to the JSON format.
        </p></li></ul><p id="idp9944064">
      Let's parse the earlier JSON example into this type now. The first
      stop is the <code>Yojson.Basic</code> documentation, where
      we find these helpful functions:
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">from_string</span> <span class="o">:</span> <span class="o">?</span><span class="n">buf</span><span class="o">:</span><span class="nn">Bi_outbuf</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fname</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lnum</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="c">(* Read a JSON value from a string.</span>
<span class="c">   [buf]   : use this buffer at will during parsing instead of</span>
<span class="c">             creating a new one. </span>
<span class="c">   [fname] : data file name to be used in error messages. It does not </span>
<span class="c">             have to be a real file. </span>
<span class="c">   [lnum]  : number of the first line of input. Default is 1.</span>

<span class="c">val from_channel : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; in_channel -&gt; json</span>
<span class="c">(* Read a JSON value from a channel. See [from_string] for the meaning of the</span>
<span class="c">   optional arguments. *)</span>

<span class="c">val from_file : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; json</span>
<span class="c">(* Read a JSON value from a file. See [from_string] for the meaning of the optional</span>
<span class="c">   arguments. *)</span>
</pre></div><p id="idp9947280">
      When first reading these interfaces, you can generally ignore the
      optional arguments (which have the question marks in the type
      signature), as they will be filled in with sensible values. In the
      above signature, the optional arguments offer finer control over
      the memory buffer allocation and error messages from parsing
      incorrect JSON.
    </p><p id="idp9948064">
      The type signature for these functions with the optional elements
      removed makes their purpose much clearer:
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">from_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">from_file</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">from_channel</span> <span class="o">:</span> <span class="n">in_channel</span> <span class="o">-&gt;</span> <span class="n">json</span>
</pre></div><p id="idp9949712">
      The <code>in_channel</code> constructor is from the original
      OCaml standard library, and its use is considered deprecated when
      using the Core standard library. This leaves us with two ways of
      parsing the JSON: either from a string or from a file on a
      filesystem. The next example shows both in action, assuming the
      JSON record is stored in a file called
      <code>book.json</code>.
    </p><div class="highlight"><pre><span class="c">(* read_json.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Read JSON file into an OCaml string *)</span>
  <span class="k">let</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">read_all</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Use the string JSON constructor *)</span>
  <span class="k">let</span> <span class="n">json1</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_string</span> <span class="n">buf</span> <span class="k">in</span>

  <span class="c">(* Use the file JSON constructor *)</span>
  <span class="k">let</span> <span class="n">json2</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_file</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Test that the two values are the same *)</span>
  <span class="n">print_endline</span> <span class="o">(</span><span class="k">if</span> <span class="n">json1</span> <span class="o">=</span> <span class="n">json2</span> <span class="k">then</span> <span class="s2">&quot;OK&quot;</span> <span class="k">else</span> <span class="s2">&quot;FAIL&quot;</span><span class="o">)</span>
  <span class="n">print_endline</span> <span class="o">(</span><span class="k">if</span> <span class="n">phys_equal</span> <span class="n">json1</span> <span class="n">json2</span> <span class="k">then</span> <span class="s2">&quot;FAIL&quot;</span> <span class="k">else</span> <span class="s2">&quot;OK&quot;</span><span class="o">)</span>
</pre></div><p id="idp9953680">
      You can build this by writing a <code>_tags</code> file to
      define the package dependencies, and then running
      <code>ocamlbuild</code>.
    </p><pre id="idp9955600">
$ cat _tags
true: package(core,yojson)
true: thread, debug, annot

$ ocamlbuild -use-ocamlfind read_json.native
$ ./read_json.native
OK
OK
</pre><p id="idp9956416">
      The <code>from_file</code> function accepts an input
      filename and takes care of opening and closing it for you. It's
      far more common to use <code>from_string</code> to construct
      JSON values though, since these strings come in via a network
      connection (we'll see more of this in
      <a href="concurrent-programming-with-async.html">Chapter 17, <i>Concurrent Programming with Async</i></a>) or
      a database. Finally, the example checks that the two input
      mechanisms actually resulted in the same OCaml data structure.
    </p><section><h1><b>
    The difference between <code>=</code> and
    <code>==</code>, and <code>phys_equal</code> in Core
    </b></h1><p id="idp9962160">
      If you come from a C/C++ background, you will probably reflexively
      use <code>==</code> to test two values for equality. In
      OCaml, <code>==</code> tests for
      <span><em>physical</em></span> equality, and <code>=</code>
      tests for <span><em>structural</em></span> equality.
    </p><p id="idp9965632">
      The <code>==</code> physical equality test will match if two
      data structures have precisely the same pointer in memory. Two
      data structures that have identical contents, but are constructed
      separately, will not match using this operator. In the JSON
      example, the <code>json1</code> and <code>json2</code>
      values are not identical and so would fail the physical equality
      test.
    </p><p id="idp9968512">
      The <code>=</code> structural equality operator recursively
      inspects each field in the two values and tests them individually
      for equality. In the JSON parsing example, every field will be
      traversed and checked, and they will check out as equal.
      Crucially, if your data structure is cyclical (that is, a value
      recursively points back to another field within the same
      structure), the <code>=</code> operator will never
      terminate, and your program will hang! In this situation, you must
      use the physical equality operator, or write a custom comparison
      function that breaks the recursion.
    </p><p id="idp9970880">
      It's quite easy to mix up the use of <code>=</code> and
      <code>==</code>, so Core disables the <code>==</code>
      operator and provides the more explicit
      <code>phys_equal</code> function instead. You'll see a type
      error if you use <code>==</code> anywhere:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">Consider_using_phys_equal</span> <span class="o">]</span>
<span class="o">#</span> <span class="n">phys_equal</span> <span class="mi">1</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp9975984">
      If you feel like hanging your OCaml interpreter, you can verify
      what happens with recursive values and structural equality for
      yourself:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="n">bar1</span><span class="o">:</span><span class="n">t2</span> <span class="o">}</span> <span class="ow">and</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span><span class="o">:</span><span class="kt">int</span><span class="o">;</span> <span class="n">bar2</span><span class="o">:</span><span class="n">t1</span> <span class="o">}</span> <span class="o">;;</span>
<span class="k">type</span> <span class="n">t1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar1</span> <span class="o">:</span> <span class="n">t2</span><span class="o">;</span> <span class="o">}</span>
<span class="ow">and</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">bar2</span> <span class="o">:</span> <span class="n">t1</span><span class="o">;</span> <span class="o">}</span>
<span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">v1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo1</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">bar1</span><span class="o">=</span><span class="n">v2</span> <span class="o">}</span> <span class="ow">and</span> <span class="n">v2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">foo2</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">bar2</span><span class="o">=</span><span class="n">v1</span> <span class="o">};;</span>
<span class="o">&lt;</span><span class="n">lots</span> <span class="k">of</span> <span class="n">text</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">v1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">phys_equal</span> <span class="n">v1</span> <span class="n">v1</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">;;</span>
<span class="o">&lt;</span><span class="n">press</span> <span class="o">^</span><span class="nc">Z</span> <span class="ow">and</span> <span class="n">kill</span> <span class="n">the</span> <span class="n">process</span> <span class="n">now</span><span class="o">&gt;</span>
</pre></div></section></section><section><h1 id="selecting-values-from-json-structures">Selecting values from JSON structures</h1><p id="idp9979296">
      Now that we've figured out how to parse the example JSON into an
      OCaml value, let's manipulate it from OCaml code and extract
      specific fields.
    </p><div class="highlight"><pre><span class="c">(* parse_book.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Read the JSON file *)</span>
  <span class="k">let</span> <span class="n">json</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_file</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Locally open the JSON manipulation functions *)</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="nc">Util</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">title</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;title&quot;</span> <span class="o">|&gt;</span> <span class="n">to_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;tags&quot;</span> <span class="o">|&gt;</span> <span class="n">to_list</span> <span class="o">|&gt;</span> <span class="n">filter_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;pages&quot;</span> <span class="o">|&gt;</span> <span class="n">to_int</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">is_online</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;is_online&quot;</span> <span class="o">|&gt;</span> <span class="n">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">is_translated</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;is_translated&quot;</span> <span class="o">|&gt;</span> <span class="n">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">authors</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;authors&quot;</span> <span class="o">|&gt;</span> <span class="n">to_list</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">authors</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">to_string</span><span class="o">)</span> <span class="k">in</span>

  <span class="c">(* Print the results of the parsing *)</span>
  <span class="n">printf</span> <span class="s2">&quot;Title: %s (%d)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">title</span> <span class="n">pages</span><span class="o">;</span>
  <span class="n">printf</span> <span class="s2">&quot;Authors: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;, &quot;</span> <span class="n">names</span><span class="o">);</span>
  <span class="n">printf</span> <span class="s2">&quot;Tags: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;, &quot;</span> <span class="n">tags</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">string_of_bool_option</span> <span class="o">=</span>
    <span class="k">function</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="s2">&quot;&lt;none&gt;&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="bp">true</span> <span class="o">-&gt;</span> <span class="s2">&quot;yes&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="s2">&quot;no&quot;</span> <span class="k">in</span>
  <span class="n">printf</span> <span class="s2">&quot;Online: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">string_of_bool_option</span> <span class="n">is_online</span><span class="o">);</span>
  <span class="n">printf</span> <span class="s2">&quot;Translated: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">string_of_bool_option</span> <span class="n">is_translated</span><span class="o">)</span>
</pre></div><p id="idp9982256">
      Build this with the same <code>_tags</code> file as the
      earlier example, and run <code>ocamlbuild</code> on the new
      file.
    </p><pre id="idp9984176">
$ ocamlbuild -use-ocamlfind parse_book.native
$ ./parse_book.native 
Title: Real World OCaml (450)
Authors: Jason Hickey, Anil Madhavapeddy, Yaron Minsky
Tags: functional programming, ocaml, algorithms
Online: yes
Translated: &lt;none&gt;
</pre><p id="idp9985312">
      This code introduces the <code>Yojson.Basic.Util</code>
      module, which contains <span><em>combinator</em></span> functions
      that let you easily map a JSON object into a more strongly-typed
      OCaml value.
    </p><section><h1><b>
    Functional Combinators
    </b></h1><p id="idp9987712">
      Combinators are a design pattern that crops up quite often in
      functional programming. John Hughes defines them as &quot;a
      function which builds program fragments from program
      fragments&quot;. In a functional language, this generally means
      higher-order functions that combine other functions to apply
      useful transformations over values.
    </p><p id="idp9988944">
      You've already run across several of these in the
      <code>List</code> module:
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">map</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span>   <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="kt">list</span>
<span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">accum</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">accum</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">accum</span>
</pre></div><p id="idp9991216">
<code>map</code> and <code>fold</code> are extremely
      common combinators that transform an input list by applying a
      function to each value of the list. The <code>map</code>
      combinator is simplest, with the resulting list being output
      directly. <code>fold</code> applies each value in the input
      list to a function that accumulates a single result, and returns
      that instead.
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">iter</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</pre></div><p id="idp9995744">
<code>iter</code> is a more specialised combinator that is
      only useful in OCaml due to side-effects being allowed. The input
      function is applied to every value, but no result is supplied. The
      function must instead apply some side-effect such as changing a
      mutable record field or printing to the standard output.
    </p></section><p id="idp9997280">
<code>Yojson</code> provides several combinators in the
      <code>Yojson.Basic.Util</code> module, such as:
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">member</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">index</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="kt">string</span>
<span class="k">val</span> <span class="n">to_int</span> <span class="o">:</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">filter_string</span> <span class="o">:</span> <span class="n">json</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span>
</pre></div><p id="idp10000432">
      We'll go through each of these uses one-by-one. Core provides the
      <code>|&gt;</code> pipe-forward which can chain combinators
      together, and the example code uses this to select and convert
      values out of the JSON structure. Let's examine some of them in
      more detail:
    </p><div class="highlight"><pre>  <span class="k">let</span> <span class="k">open</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="nc">Util</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">title</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;title&quot;</span> <span class="o">|&gt;</span> <span class="n">to_string</span> <span class="k">in</span>
</pre></div><p id="idp10002880">
      The <code>member</code> function accepts a JSON object and
      named key and returns the JSON field associated with that key, or
      <code>Null</code>. Since we know that the
      <code>title</code> value is always a string in our example
      schema, we want to convert it to an OCaml string. The
      <code>to_string</code> function performs this conversion,
      and raises an exception if there is an unexpected JSON type. The
      <code>|&gt;</code> operator provides a convenient way to
      chain these operations together.
    </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;tags&quot;</span> <span class="o">|&gt;</span> <span class="n">to_list</span> <span class="o">|&gt;</span> <span class="n">filter_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;pages&quot;</span> <span class="o">|&gt;</span> <span class="n">to_int</span> <span class="k">in</span>
</pre></div><p id="idp10008448">
      The <code>tags</code> field is similar to
      <code>title</code>, but the field is a list of strings
      instead of a single one. Converting this to an OCaml
      <code>string list</code> is a two stage process. First, we
      convert the JSON <code>List</code> to an OCaml list of JSON
      values, and then filter out the <code>String</code> values
      as an OCaml <code>string list</code>. Remember that OCaml
      lists must contain values of the same type, so any JSON values
      that cannot be converted to a <code>string</code> will be
      skipped from the output of <code>filter_string</code>.
    </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">is_online</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;is_online&quot;</span> <span class="o">|&gt;</span> <span class="n">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">is_translated</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;is_translated&quot;</span> <span class="o">|&gt;</span> <span class="n">to_bool_option</span> <span class="k">in</span>
</pre></div><p id="idp10016128">
      The <code>is_online</code> and
      <code>is_translated</code> fields are optional in our JSON
      schema, so no error should be raised if they are not present. The
      OCaml type is a <code>string option</code> to reflect this,
      and can be extracted via <code>to_bool_option</code>. In our
      example JSON, only <code>is_online</code> is present and
      <code>is_translated</code> will be <code>None</code>.
    </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">authors</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;authors&quot;</span> <span class="o">|&gt;</span> <span class="n">to_list</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">authors</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">to_string</span><span class="o">)</span> <span class="k">in</span>
</pre></div><p id="idp10022896">
      The final use of JSON combinators is to extract all the
      <code>name</code> fields from the list of authors. We first
      construct the <code>author list</code>, and then
      <code>map</code> it into a <code>string list</code>.
      Notice that the example explicitly binds
      <code>authors</code> to a variable name. It can also be
      written more succinctly using the pipe-forward operator:
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">names</span> <span class="o">=</span>
  <span class="n">json</span>
  <span class="o">|&gt;</span> <span class="n">member</span> <span class="s2">&quot;authors&quot;</span>
  <span class="o">|&gt;</span> <span class="n">to_list</span>
  <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="n">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="n">to_string</span><span class="o">)</span>
</pre></div><p id="idp10028160">
      This style of programming which omits variable names and chains
      functions together is known as &quot;point-free programming&quot;.
      It's a succinct style, but shouldn't be overused due to the
      increased difficulty of debugging intermediate values. If an
      explicit name is assigned to each stage of the transformations,
      debuggers in particular have an easier time making the program
      flow easier to represent to the programer.
    </p><p id="idp10029648">
      This technique of using chained parsing functions is very powerful
      in combination with the OCaml type system. Many errors that don't
      make sense at runtime (for example, mixing up lists and objects)
      will be caught statically via a type error.
    </p></section><section><h1 id="constructing-json-values">Constructing JSON values</h1><p id="idp10031536">
      Building and printing JSON values is pretty straightforward given
      the <code>Yojson.Basic.json</code> type. You can just
      construct values of type <code>json</code> and call the
      <code>to_string</code> function] on them. Let's remind
      ourselves of the <code>Yojson.Basic.type</code> again:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span>
</pre></div><p id="idp10036080">
      We can directly build a JSON value against this type, and use the
      pretty-printing functions in the <code>Yojson.Basic</code>
      module to lay the output out in the JSON format.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">[</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)</span> <span class="o">]</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">])</span> <span class="kt">list</span> <span class="o">]</span> <span class="o">=</span>
  <span class="o">`</span><span class="nc">Assoc</span> <span class="o">[(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)]</span>
</pre></div><p id="idp10038640">
      In the example above, we've constructed a value
      <code>x</code> that represents a simple JSON object. We
      haven't actually defined the type of <code>x</code>
      explicitly here, as we're relying on the magic of polymorphic
      variants to make this all work. The OCaml type system infers a
      type for <code>x</code> based on how you construct the
      value. In this case only the <code>Assoc</code> and
      <code>String</code> variants are used, and the inferred type
      only contains these fields without knowledge of the other possible
      variants that you haven't used yet.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">?</span><span class="n">std</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>  
</pre></div><p id="idp10044064">
<code>pretty_to_string</code> has a more explicit signature
      that wants an argument of type
      <code>Yojson.Basic.json</code>. When <code>x</code> is
      applied to <code>pretty_to_string</code>, the inferred type
      of <code>x</code> is statically checked against the
      structure of the <code>json</code> type to ensure that
      they're compatible.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="n">x</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;{ </span><span class="se">\&quot;</span><span class="s2">key</span><span class="se">\&quot;</span><span class="s2">: </span><span class="se">\&quot;</span><span class="s2">value</span><span class="se">\&quot;</span><span class="s2"> }&quot;</span>

<span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_channel</span> <span class="n">stdout</span> <span class="n">x</span> <span class="o">;;</span>
<span class="o">{</span> <span class="s2">&quot;key&quot;</span><span class="o">:</span> <span class="s2">&quot;value&quot;</span> <span class="o">}</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div><p id="idp10050112">
      In this case, there are no problems. Our <code>x</code>
      value has an inferred type that is a valid sub-type of
      <code>json</code>, and the function application just works
      without us ever having to explicitly specify a type for
      <code>x</code>. Type inference lets you write more succinct
      code without sacrificing runtime reliability, as all the uses of
      polymorphic variants are still checked at compile-time.
    </p><section><h1><b>
    Polymorphic variants and easier type checking
    </b></h1><p id="idp10053664">
      One difficulty you will encounter is that type errors involving
      polymorphic variants can be quite verbose if you make a mistake in
      your code. For example, suppose you build an
      <code>Assoc</code> and mistakenly include a single value
      instead of a list of keys:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span> <span class="o">]</span> <span class="o">=</span>
  <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">)</span>

<span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="n">x</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
         <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">]</span> <span class="o">]</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span>
       <span class="nc">Types</span> <span class="k">for</span> <span class="n">tag</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="n">are</span> <span class="n">incompatible</span>
</pre></div><p id="idp10056848">
      The type error above isn't <span><em>wrong</em></span> as such, but
      can be inconvenient to wade through for larger values. An easy way
      to narrow down this sort of type error is to add explicit type
      annotations as a compiler hint about your intentions:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span><span class="o">)</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;key&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;value&quot;</span><span class="o">);;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
</pre></div><p id="idp10059312">
      In this case, we've marked the <code>x</code> as being of
      type <code>Yojson.Basic.json</code>, and the compiler
      immediately spots that the argument to the
      <code>Assoc</code> variant has the incorrect type. This
      illustrates the strengths and weaknesses of polymorphic variants:
      they make it possible to easily subtype across module boundaries,
      but the error messages can be more confusing. However, a bit of
      careful manual type annotation is all it takes to make tracking
      down such issues much easier.
    </p></section></section><section><h1 id="using-non-standard-json-extensions">Using non-standard JSON extensions</h1><p id="idp10063760">
      The standard JSON types are <span><em>really</em></span> basic, and
      OCaml types are far more expressive. Yojson supports an extended
      JSON format for those times when you're not interoperating with
      external systems and just want a convenient human-readable local
      format. The <code>Yojson.Safe.json</code> type is a superset
      of the <code>Basic</code> polymorphic variant, and looks
      like this:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Floatlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Intlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Stringlit</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Variant</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">json</span> <span class="n">option</span> <span class="o">]</span>
</pre></div><p id="idp10067584">
      The <code>Safe.json</code> type includes all of the variants
      from <code>Basic.json</code> and extends it with a few more
      useful ones. A standard JSON type such as a
      <code>String</code> will type-check against both the
      <code>Basic</code> module and also the non-standard
      <code>Safe</code> module. If you use the extension values
      with the <code>Basic</code> module however, the compiler
      will reject your code until you make it compliant with the
      portable subset of JSON.
    </p><p id="idp10072656">
      Yojson supports the following JSON extensions:
    </p><ul><li><p id="idp10073632">
          The <code>lit</code> suffix denotes that the value is
          stored as a JSON string. For example, a
          <code>Floatlit</code> will be stored as
          <code>&quot;1.234&quot;</code> instead of
          <code>1.234</code>.
        </p></li><li><p id="idp10077424">
          The <code>Tuple</code> type is stored as
          <code>(&quot;abc&quot;, 123)</code> instead of a list.
        </p></li><li><p id="idp10079696">
          The <code>Variant</code> type encodes OCaml variants
          more explicitly, as <code>&lt;&quot;Foo&quot;&gt;</code>
          or <code>&lt;&quot;Bar&quot;:123&gt;</code> for a
          variant with parameters.
        </p></li></ul><p id="idp10082608">
      The only purpose of these extensions is to make the data
      representation more expressive without having to refer to the
      original OCaml types. You can always cast a
      <code>Safe.json</code> to a <code>Basic.json</code>
      type by using the <code>to_basic</code> function as follows:
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">to_basic</span> <span class="o">:</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span>
<span class="c">(** Tuples are converted to JSON arrays, Variants are converted to</span>
<span class="c">    JSON strings or arrays of a string (constructor) and a json value</span>
<span class="c">    (argument). Long integers are converted to JSON strings.</span>
<span class="c">    Examples:</span>

<span class="c">    `Tuple [ `Int 1; `Float 2.3 ]   -&gt;    `List [ `Int 1; `Float 2.3 ]</span>
<span class="c">    `Variant (&quot;A&quot;, None)            -&gt;    `String &quot;A&quot;</span>
<span class="c">    `Variant (&quot;B&quot;, Some x)          -&gt;    `List [ `String &quot;B&quot;, x ]</span>
<span class="c">    `Intlit &quot;12345678901234567890&quot;  -&gt;    `String &quot;12345678901234567890&quot;</span>
<span class="c"> *)</span>
</pre></div></section><section><h1 id="automatically-mapping-json-to-ocaml-types">Automatically mapping JSON to OCaml types</h1><p id="idp10088352">
      The combinators described earlier make it easy to write functions
      that extract fields from JSON records, but the process is still
      pretty manual. When you implement larger specifications, it's much
      easier to generate the mappings from JSON schemas to OCaml values
      more mechanically than writing conversion functions individually.
      We'll cover an alternative JSON processing method that is better
      for larger-scale JSON handling now, using the
      <a href="http://mjambon.com/atd-biniou-intro.html" target="_top">ATD</a>
      tool. This will introduce our first <span><em>Domain Specific
      Language</em></span> that ccompiles JSON specifications into OCaml
      modules, which are then used throughout your application.
    </p><aside class="note"><h1>
    Installing the ATDgen library and tool
    </h1><p id="idp10091312">
      ATDgen installs some OCaml libraries that interface with Yojson,
      and also a command-line tool that generates code. It can all be
      installed via OPAM:
    </p><pre id="idp10091888">
$ opam install atdgen
$ atdgen -version
1.2.3
</pre><p id="idp10092608">
      The command-line tool will be installed within your
      <code>~/.opam</code> directory, and will already be on your
      <code>PATH</code> from running
      <code>opam config env</code>. See
      <a href="installation.html">Appendix A, <i>Installation</i></a> if this isn't working.
    </p></aside><p id="idp10096112">
      The idea behind ATD is to specify the format of the JSON in a
      separate file, and then run a compiler (<code>atdgen</code>)
      that outputs OCaml code to construct and parse JSON values. This
      means that you don't need to write any OCaml parsing code at all,
      as it will all be auto-generated for you.
    </p><p id="idp10097488">
      Let's go straight into looking at an example of how this works, by
      using a small portion of the GitHub API. GitHub is a popular code
      hosting and sharing website that provides a JSON-based web
      <a href="http://developer.github.com" target="_top">API</a>. The ATD code
      fragment below describes the GitHub authorization API. It is based
      on a pseudo-standard web protocol known as OAuth, and is used to
      authorize users for GitHub services.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">scope</span> <span class="o">=</span> <span class="o">[</span>
    <span class="nc">User</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Public_repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;public_repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Repo_status</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;repo_status&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Delete_repo</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;delete_repo&quot;</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nc">Gist</span> <span class="o">&lt;</span><span class="n">json</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;gist&quot;</span><span class="o">&gt;</span>
<span class="o">]</span>

<span class="k">type</span> <span class="n">app</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
<span class="o">}</span>  <span class="o">&lt;</span><span class="n">ocaml</span> <span class="n">field_prefix</span><span class="o">=</span><span class="s2">&quot;app_&quot;</span><span class="o">&gt;</span>

<span class="k">type</span> <span class="n">authorization_request</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">note</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
<span class="o">}</span> <span class="o">&lt;</span><span class="n">ocaml</span> <span class="n">field_prefix</span><span class="o">=</span><span class="s2">&quot;auth_req_&quot;</span><span class="o">&gt;</span>

<span class="k">type</span> <span class="n">authorization_response</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">token</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">app</span><span class="o">:</span> <span class="n">app</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">id</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="o">?</span><span class="n">note</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="o">?</span><span class="n">note_url</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span>
</pre></div><p id="idp10100608">
      ATD specifications are deliberately similar to OCaml type
      definitions. Each field can include extra annotations to customise
      the parsing code for a particular backend. For example, the GitHub
      <code>scope</code> field above is defined as a variant type,
      but with the actual JSON values being defined explicitly (as
      lower-case versions).
    </p><p id="idp10102080">
      The ATD spec can be compiled to a number of OCaml targets. Let's
      run the compiler twice, to generate some OCaml type definitions,
      and a JSON serialiser.
    </p><div class="highlight"><pre><span class="nv">$ </span>atdgen -t github.atd
<span class="nv">$ </span>atdgen -j github.atd
</pre></div><p id="idp10103648">
      This will generate some new files in your current directory.
      <code>Github_t.ml</code> and <code>Github_t.mli</code>
      will contain an OCaml module with types defines that correspond to
      the ATD file. The signature looks like this:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">scope</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">User</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Public_repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Repo_status</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Delete_repo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gist</span>
<span class="o">]</span>

<span class="k">type</span> <span class="n">app</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">app_name</span> <span class="c">(*atd name *)</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">app_url</span> <span class="c">(*atd url *)</span><span class="o">:</span> <span class="kt">string</span>
<span class="o">}</span>

<span class="k">type</span> <span class="n">authorization_request</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">auth_req_scopes</span> <span class="c">(*atd scopes *)</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">auth_req_note</span> <span class="c">(*atd note *)</span><span class="o">:</span> <span class="kt">string</span>
<span class="o">}</span>

<span class="k">type</span> <span class="n">authorization_response</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">scopes</span><span class="o">:</span> <span class="n">scope</span> <span class="kt">list</span><span class="o">;</span>
  <span class="n">token</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">app</span><span class="o">:</span> <span class="n">app</span><span class="o">;</span>
  <span class="n">url</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">id</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="n">note</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">note_url</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span>
<span class="o">}</span>
</pre></div><p id="idp10107072">
      There is an obvious correspondence to the ATD definition. Note
      that field names in OCaml records in the same module cannot shadow
      each other, and so we instruct ATDgen to prefix every field with a
      name that distinguishes it from other records in the same module.
      For example,
      <code>&lt;ocaml field_prefix=&quot;auth_req_&quot;&gt;</code>
      in the ATD spec prefixes every field name in the generated
      <code>authorization_request</code> record with
      <code>auth_req</code>.
    </p><p id="idp10110048">
      The <code>Github_t</code> module only contains the type
      definitions, while <code>Github_j</code> provides
      serialization functions to and from JSON. You can read the
      <code>github_j.mli</code> to see the full interface, but the
      important functions for most uses are the conversion functions to
      and from a string. For our example above, this looks like:
    </p><div class="highlight"><pre><span class="k">val</span> <span class="n">string_of_authorization_response</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">len</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">authorization_response</span> <span class="o">-&gt;</span> <span class="kt">string</span>
  <span class="c">(** Serialize a value of type {!authorization_response}</span>
<span class="c">      into a JSON string.</span>
<span class="c">      @param len specifies the initial length</span>
<span class="c">                 of the buffer used internally.</span>
<span class="c">                 Default: 1024. *)</span>

<span class="k">val</span> <span class="n">authorization_response_of_string</span> <span class="o">:</span>
  <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">authorization_response</span>
</pre></div><p id="idp10114592">
      This is pretty convenient! We've written a single ATD file, and
      all the OCaml boilerplate to convert between JSON and a strongly
      typed record has been generated for us. You can control various
      aspects of the serializer by passing flags to
      <code>atdgen</code>. The important ones for JSON are:
    </p><ul><li><p id="idp10116512">
<code>-j-std</code>: work in standard JSON mode, and
          never print non-standard JSON extensions.
        </p></li><li><p id="idp10118080">
<code>-j-custom-fields FUNCTION</code>: call a custom
          function for every unknown field encountered, instead of
          raising a parsing exception.
        </p></li><li><p id="idp10119696">
<code>-j-defaults</code>: always explicitly output a
          JSON value if possible. This requires the default value for
          that field to be defined in the ATD specification.
        </p></li></ul><p id="idp10121216">
      The full ATD specification is quite sophisticated (and well
      documented online at its homepage). The ATD compiler can also
      target formats other than JSON, and outputs code for other
      languages such as Java if you need more interoperability. There
      are also several similar projects you can investigate which
      automate the code generation process:
      <a href="http://piqi.org" target="_top">Piqi</a> uses the Google protobuf
      format, and <a href="http://thrift.apache.org" target="_top">Thrift</a>
      supports many other programming languages and includes OCaml
      bindings.
    </p><section><h1 id="example-querying-github-organization-information">Example: Querying Github organization information</h1><p id="idp10124816">
        Let's finish up with an example of some live JSON parsing from
        Github, and build a tool to query organization information via
        their API. Look at the online
        <a href="http://developer.github.com/v3/orgs/" target="_top">API
        documentation</a> for Github to see what the JSON schema
        looks like retrieving the organization information. Then create
        an ATD file that covers the fields we need. Any extra fields
        present in the response will be ignored by the ATD parser.
      </p><pre id="idp10126400">
(* github_org.atd *)
type org = {
  login: string;
  id: int;
  url: string;
  ?name: string option;
  ?blog: string option;
  ?email: string option;
  public_repos: int
}
</pre><p id="idp10127248">
        The OCaml program that uses this will fetch the JSON and output
        a one-line summary. You'll also need the <code>curl</code>
        tool installed on your system to fetch the HTTP web pages, as
        our example below calls <code>curl</code> via the
        <code>Core_extended.Shell</code> interface.
      </p><div class="highlight"><pre><span class="c">(* github_org_info.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="n">print_org</span> <span class="n">file</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">url</span> <span class="o">=</span> <span class="n">sprintf</span> <span class="s2">&quot;https://api.github.com/orgs/%s&quot;</span> <span class="n">file</span> <span class="k">in</span>
  <span class="nn">Core_extended</span><span class="p">.</span><span class="nn">Shell</span><span class="p">.</span><span class="n">run_full</span> <span class="s2">&quot;curl&quot;</span> <span class="o">[</span><span class="n">url</span><span class="o">]</span>
  <span class="o">|&gt;</span> <span class="nn">Github_org_j</span><span class="p">.</span><span class="n">org_of_string</span>
  <span class="o">|&gt;</span> <span class="k">fun</span> <span class="n">org</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="k">open</span> <span class="nc">Github_org_t</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="nn">Option</span><span class="p">.</span><span class="n">value</span> <span class="o">~</span><span class="n">default</span><span class="o">:</span><span class="s2">&quot;???&quot;</span> <span class="n">org</span><span class="o">.</span><span class="n">name</span> <span class="k">in</span>
      <span class="n">printf</span> <span class="s2">&quot;%s (%d) with %d public repos</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">name</span> <span class="n">org</span><span class="o">.</span><span class="n">id</span> <span class="n">org</span><span class="o">.</span><span class="n">public_repos</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Command</span><span class="p">.</span><span class="n">basic</span> <span class="o">~</span><span class="n">summary</span><span class="o">:</span><span class="s2">&quot;Print Github organization information&quot;</span>
    <span class="nn">Command</span><span class="p">.</span><span class="nn">Spec</span><span class="p">.</span><span class="err">(</span><span class="n">empty</span> <span class="o">+&gt;</span> <span class="n">anon</span> <span class="o">(</span><span class="s2">&quot;organization&quot;</span> <span class="o">%:</span> <span class="kt">string</span><span class="o">))</span>
    <span class="n">print_org</span>
  <span class="o">|&gt;</span> <span class="nn">Command</span><span class="p">.</span><span class="n">run</span>
</pre></div><p id="idp10131712">
        Finally, write a short shell script to generate the OCaml
        <code>Github_org</code> parsers via
        <code>atdgen</code>, and build the OCaml command-line
        interface.
      </p><pre id="idp10133680">
$ cat _tags 
true: package(core,core_extended,yojson,atdgen)
true: thread, debug, annot

$ cat buildgh.sh 
#!/bin/sh

atdgen -t github_org.atd
atdgen -j github_org.atd
ocamlbuild -use-ocamlfind github_org_info.native

$ ./buildgh.sh
</pre><p id="idp10134592">
        You can now run the command-line tool with a single argument to
        specify the name of the organization, and it will dynamically
        fetch the JSON from the web, parse it, and render the summary to
        your console.
      </p><pre id="idp10135232">
$ curl https://api.github.com/orgs/janestreet 
{
  &quot;login&quot;: &quot;janestreet&quot;,
  &quot;id&quot;: 3384712,
  &quot;url&quot;: &quot;https://api.github.com/orgs/janestreet&quot;,
  &quot;public_repos&quot;: 31,
  &quot;public_gists&quot;: 0,
  &quot;followers&quot;: 0,
  &quot;following&quot;: 0,
  &quot;html_url&quot;: &quot;https://github.com/janestreet&quot;,
  &quot;created_at&quot;: &quot;2013-01-25T19:35:43Z&quot;,
  &quot;updated_at&quot;: &quot;2013-05-23T14:03:06Z&quot;,
  &quot;type&quot;: &quot;Organization&quot;
}
$ ./github_org_info.native mirage
Mirage account (131943) with 32 public repos
$ ./github_org_info.native janestreet
??? (3384712) with 31 public repos
</pre><p id="idp10136528">
        The JSON returned from the <code>janestreet</code> query
        is missing an organization name, but this is explicitly
        reflected in the OCaml type since the ATD spec marked
        <code>name</code> as an optional field. Our OCaml code
        explicitly handles this case and doesn't have to worry about
        null-pointer exceptions. Similarly, the JSON integer for the
        <code>id</code> is mapped into a native OCaml integer via
        the ATD conversion.
      </p><p id="idp10139456">
        While this tool is obviously quite simple, the ability to
        specify optional and default fields is very powerful. Take a
        look at the full ATD specification for the GitHub API in the
        <a href="http://github.com/avsm/ocaml-github" target="_top"><code>ocaml-github</code></a>
        repository online, which has lots of quirks typical in
        real-world web APIs.
      </p><p id="idp10141280">
        Our example shells out to <code>curl</code> on the
        command-line to obtain the JSON, which is rather inefficient.
        We'll explain how to integrate the HTTP fetch directly into your
        OCaml application later on in
        <a href="concurrent-programming-with-async" target="_top">xref</a>.
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="command-line-parsing.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="parsing-with-ocamllex-and-menhir.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>