<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 21. Foreign Function Interface / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha5',
                        page: 'foreign\u002Dfunction\u002Dinterface.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html" class="here">21. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="memory-representation-of-values.html">22. Memory Representation of Values</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-binary-protocols-with-bigarray.html">23. Handling Binary Protocols with Bigarray</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">24. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 21. Foreign Function Interface</h1>
                
                

    <p id="idp10952688">
    OCaml has several options available to interact with non-OCaml code.
    The compiler toolchain can link to external system libraries, and
    also produce standalone object code. This object code can be turned
    into shared libraries that that let your OCaml code be called from
    C, or linked in more exotic ways to embed it directly into
    applications or even kernel modules.
  </p><p id="idp10953488">
    This chapter walks you through the basics interfacing with C
    libraries, and then moves onto how to embed your code for a variety
    of other platforms.
  </p><section><h1 id="the-ctypes-ffi-library">The <code>ctypes</code> FFI library</h1><p id="idp10955856">
      We'll introduce the foreign function interface via the simplest
      method, which doesn't require writing any C code. The
      <code>ctypes</code> library lets you describe the C
      interface in pure OCaml, and it takes care of opening the foreign
      library and invoking the correct function calls . We'll use the
      <code>ncurses</code> terminal-drawing toolkit as our firts
      example, as it's widely available on most systems.
    </p><aside class="note"><h1>
    Installing the ctypes library
    </h1><p id="idp10959472">
      TODO <code>ctypes</code> is not yet available on OPAM, but
      will be soon. For now, install it manually:
    </p><pre id="idp10960688">
$ git clone git://github.com/ocamllabs/ocaml-ctypes
$ cd ocaml-ctypes
$ make &amp;&amp; make install
</pre><p id="idp10961520">
      It will then be available via the <code>ctypes</code>
      ocamlfind package.
    </p></aside></section><section><h1 id="example-an-ncurses-terminal-interface">Example: an ncurses terminal interface</h1><p id="idp10964160">
      Ncurses is a library to build terminal-independent text interfaces
      in a reasonably efficient way. The manual page (usually via
      <code>man ncurses</code>) explains the basics of the C
      interface. Below is an excerpt of the header interface found in
      <code>&lt;ncurses.h</code>&gt;.
    </p><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_win_st</span> <span class="n">WINDOW</span><span class="p">;</span>

<span class="n">WINDOW</span> <span class="o">*</span><span class="n">initscr</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">WINDOW</span> <span class="o">*</span><span class="n">newwin</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">endwin</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">refresh</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wrefresh</span> <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mvwaddstr</span> <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</pre></div><p id="idp10967408">
      The <code>WINDOW</code> typedef is a forward declaration of
      a C structure that holds the internal ncurses library state. The
      specific contents of the structure don't matter, as you need to
      pass pointers to the structure to the various library calls. The
      <code>initscr</code> function initialises this library state
      and returns it as a <code>WINDOW</code> pointer, and the
      <code>newwin</code> function allows further sub-windows to
      be created. This pointer is passed to various terminal drawing
      functions such as <code>mvwaddrstr</code>. The terminal is
      only updated when <code>refresh</code> or
      <code>wrefresh</code> are called, and all other drawing
      calls just manipulate data structures without taking effect on the
      screen.
    </p><p id="idp10973424">
      The <code>ctypes</code> library provides an OCaml interface
      that lets you declare these C functions as OCaml values. The
      library takes care of converting the OCaml arguments into the C
      calling convention, invoking the foreign call within the
      <code>ncurses</code> library, and finally returning the
      result as an OCaml value.
    </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Ctypes</span><span class="p">.</span><span class="nn">Ffi</span><span class="p">.</span><span class="nc">C</span>
<span class="k">open</span> <span class="nc">Type</span>

<span class="k">type</span> <span class="n">window</span> <span class="o">=</span> <span class="kt">unit</span> <span class="n">ptr</span>
<span class="k">let</span> <span class="n">window</span> <span class="o">:</span> <span class="n">window</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ptr</span> <span class="n">void</span>
</pre></div><p id="idp10976592">
      The <code>window</code> type is declared as a
      <code>void</code> pointer. We also need a value to pass to
      the <code>ctypes</code> library to represent this type, and
      so the <code>window</code> value is built using the
      <code>Ctypes.Ffi.C.ptr</code> function. The actual pointer
      type from C is a <code>WINDOW</code> and not
      <code>void</code>, but we'll show you shortly how we can
      hide the details of the <code>window</code> type in the
      OCaml module signature. The next step is to use these values to
      build a foreign function call to <code>initscr</code>.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">initscr</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;initscr&quot;</span> <span class="o">(</span><span class="n">void</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">window</span><span class="o">))</span>
</pre></div><p id="idp10984864">
      The <code>foreign</code> function takes two parameters: the
      C function call name, and a definition of the arguments and return
      type. The definition is built up using the combinators defined in
      <code>Ctypes.Ffi.C</code>. The <code>@-&gt;</code>
      operator adds an argument to the parameter list, and the
      <code>returning</code> function declares the return value.
      The remainder of the <code>Ncurses</code> implementation
      expands on these definitions for the other library functions.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">endwin</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;endwin&quot;</span> <span class="o">(</span><span class="n">void</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">refresh</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;refresh&quot;</span> <span class="o">(</span><span class="n">void</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">wrefresh</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;wrefresh&quot;</span> <span class="o">(</span><span class="n">window</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">newwin</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;newwin&quot;</span> 
    <span class="o">(</span><span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">window</span><span class="o">))</span>

<span class="k">let</span> <span class="n">mvwaddch</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;mvwaddch&quot;</span> 
    <span class="o">(</span><span class="n">window</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">char</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">addstr</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;addstr&quot;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">mvwaddstr</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;mvwaddstr&quot;</span>
    <span class="o">(</span><span class="n">window</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">string</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">box</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;box&quot;</span> <span class="o">(</span><span class="n">window</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="kt">int</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>

<span class="k">let</span> <span class="n">cbreak</span> <span class="o">=</span>
  <span class="n">foreign</span> <span class="s2">&quot;cbreak&quot;</span> <span class="o">(</span><span class="n">void</span> <span class="o">@-&gt;</span> <span class="o">(</span><span class="n">returning</span> <span class="n">void</span><span class="o">))</span>
</pre></div><p id="idp10991120">
      These function calls all have different arguments, but the basic C
      types are provided by the <code>Ffi.C</code> module and can
      be directly used. The module signature for
      <code>ncurses.mli</code> looks much like a normal OCaml
      signature:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">window</span>

<span class="k">val</span> <span class="n">window</span>    <span class="o">:</span> <span class="n">window</span> <span class="nn">Ffi</span><span class="p">.</span><span class="nn">C</span><span class="p">.</span><span class="nn">Type</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">initscr</span>   <span class="o">:</span> <span class="kt">unit</span>   <span class="o">-&gt;</span> <span class="n">window</span>
<span class="k">val</span> <span class="n">endwin</span>    <span class="o">:</span> <span class="kt">unit</span>   <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">refresh</span>   <span class="o">:</span> <span class="kt">unit</span>   <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">wrefresh</span>  <span class="o">:</span> <span class="n">window</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">newwin</span>    <span class="o">:</span> <span class="kt">int</span>    <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">window</span>
<span class="k">val</span> <span class="n">addch</span>     <span class="o">:</span> <span class="kt">char</span>   <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">mvwaddch</span>  <span class="o">:</span> <span class="n">window</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">addstr</span>    <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">mvwaddstr</span> <span class="o">:</span> <span class="n">window</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">box</span>       <span class="o">:</span> <span class="n">window</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">cbreak</span>    <span class="o">:</span> <span class="kt">unit</span>   <span class="o">-&gt;</span> <span class="kt">unit</span>
</pre></div><p id="idp10994880">
      Notice that the <code>window</code> type is left abstract to
      external users, so that it can only be constructed via
      <code>Ncurses.initscr</code>. This interface is now safe to
      use in example code. Here's what an ncurses hello world looks
      like:
    </p><div class="highlight"><pre><span class="k">open</span> <span class="nc">Ncurses</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">main_window</span> <span class="o">=</span> <span class="n">initscr</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="n">cbreak</span> <span class="bp">()</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">small_window</span> <span class="o">=</span> <span class="n">newwin</span> <span class="mi">10</span> <span class="mi">10</span> <span class="mi">5</span> <span class="mi">5</span> <span class="k">in</span>
  <span class="n">mvwaddstr</span> <span class="n">main_window</span> <span class="mi">1</span> <span class="mi">2</span> <span class="s2">&quot;Hello&quot;</span><span class="o">;</span>
  <span class="n">mvwaddstr</span> <span class="n">small_window</span> <span class="mi">2</span> <span class="mi">2</span> <span class="s2">&quot;World&quot;</span><span class="o">;</span>
  <span class="n">box</span> <span class="n">small_window</span> <span class="mi">0</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">refresh</span> <span class="bp">()</span><span class="o">;</span>
  <span class="nn">Unix</span><span class="p">.</span><span class="n">sleep</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">wrefresh</span> <span class="n">small_window</span><span class="o">;</span>
  <span class="nn">Unix</span><span class="p">.</span><span class="n">sleep</span> <span class="mi">5</span><span class="o">;</span>
  <span class="n">endwin</span> <span class="bp">()</span>
</pre></div><p id="idp10998640">
      This code can be compiled by:
    </p><pre id="idp10999088">
$ ocamlfind ocamlopt -linkpkg -package ctypes -package unix \
  -cclib -lncurses ncurses.mli ncurses.ml hello.ml -o hello
</pre><p id="idp10999888">
      Running <code>./hello</code> should now display a Hello
      World in your terminal with a box around the &quot;World&quot;.
      Notice that the compilation line includes
      <code>-cclib -lncurses</code>. This tells the OCaml compiler
      to link the output binary to the ncurses library, which in turns
      makes the symbols available to the program when it starts. If you
      omit that line, you'll get an error when you try to run the
      binary:
    </p><pre id="idp11002128">
$ ocamlfind ocamlopt -linkpkg -package ctypes -package unix \
  ncurses.mli ncurses.ml hello.ml -o hello_broken
$ ./hello_broken 
Fatal error: exception Dl.DL_error(&quot;dlsym(RTLD_DEFAULT, initscr): symbol not found&quot;)
</pre></section><section><h1 id="defining-basic-c-formats-from-ocaml">Defining basic C formats from OCaml</h1><p id="idp11004464">
      The <code>Ctypes</code> library provides an
      <code>FFi.C</code> module that lets you describe not only
      basic C types, but also more complex structures and unions. It
      defines abstract OCaml types for all of these in
      <code>FFi.C</code>:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span>        <span class="c">(** Basic C type  *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">ptr</span>        <span class="c">(** C pointer *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="kt">array</span>      <span class="c">(** C array of 'a values *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">structure</span>  <span class="c">(** C `struct` *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">union</span>      <span class="c">(** C `union` *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">abstract</span>   <span class="c">(** Abstract C pointer *)</span>
</pre></div><p id="idp11008400">
      The <code>Ffi.C.Type</code> module defines constructors for
      the familiar C basic types and lets you build
      <code>'a typ</code> values.
    </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Type</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> 
  
  <span class="k">val</span> <span class="n">void</span>  <span class="o">:</span> <span class="kt">unit</span> <span class="n">t</span>
  <span class="k">val</span> <span class="kt">char</span> <span class="o">:</span> <span class="kt">char</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">schar</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">t</span>
  <span class="k">val</span> <span class="kt">float</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">double</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">short</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">t</span>
  <span class="k">val</span> <span class="kt">int</span>   <span class="o">:</span> <span class="kt">int</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">long</span>  <span class="o">:</span> <span class="n">long</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">llong</span>  <span class="o">:</span> <span class="n">llong</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">nativeint</span> <span class="o">:</span> <span class="n">nativeint</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">int8_t</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">int16_t</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">int32_t</span> <span class="o">:</span> <span class="n">int32</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">int64_t</span> <span class="o">:</span> <span class="n">int64</span> <span class="n">t</span>
<span class="o">...</span>
</pre></div><p id="idp11011632">
      These functions all return an <code>'a typ</code>, where the
      <code>'a</code> component is the OCaml representation of the
      C type. For example, OCaml only supports double-precision floating
      point numbers, and so both of the C <code>float</code> and
      <code>double</code> functions map to the OCaml
      <code>float</code> type. The <code>Ffi.Unsigned</code>
      and <code>Ffi.Signed</code> modules provide some optimized
      implementations of specific C types, such as
      <code>llong</code> (for <code>long long</code> 64-bit
      values).
    </p><p id="idp11018768">
      The module also defines some more advanced C types
    </p><div class="highlight"><pre><span class="o">...</span> 
  <span class="k">val</span> <span class="kt">string</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">abstract</span> <span class="o">:</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alignment</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">abstract</span> <span class="n">t</span>
  <span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">array</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">ptr</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">ptr</span> <span class="n">t</span>
</pre></div><p id="idp11020416">
      Strings in C are null-terminator character arrays, whereas OCaml
      strings have a fixed-length and can contain null values. The
      <code>string</code> mapping safely copies between these two
      strings. if you need an abstract C type (for example, from a
      forward declaration of a <code>struct</code>), then just
      define an <code>abstract t</code>. Arrays and pointers can
      be built out of primitive types by using the corresponding
      constructor functions.
    </p><div class="highlight"><pre><span class="o">...</span>
  <span class="k">val</span> <span class="o">(</span> <span class="o">@-&gt;</span> <span class="o">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">f</span>
  <span class="k">val</span> <span class="n">returning</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">f</span>
  <span class="k">val</span> <span class="n">funptr</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span>
</pre></div><p id="idp11024528">
      Sequences of <code>'a typ</code> values are constructed by
      using the <code>@-&gt;</code> and
      <code>returning</code> functions. You can even exchange
      function pointers between OCaml and C by wrapping the OCaml
      callback using <code>funptr</code>. The library takes care
      of the garbage collector interface to ensure that the OCaml value
      isn't moved around while the C library is holding a reference to
      the value.
    </p><section><h1 id="arrays-structures-and-unions">Arrays, structures and unions</h1><p id="idp11029280">
        Arrays in C are contiguous blocks of the same value. Any of the
        basic types defined earlier can be allocated as blocks via the
        <code>Ffi.C.Type.Array</code> module.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Array</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">array</span>

  <span class="k">val</span> <span class="n">get</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span>
  <span class="k">val</span> <span class="n">set</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">of_list</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">to_list</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
  <span class="k">val</span> <span class="n">length</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">start</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">ptr</span>
  <span class="k">val</span> <span class="n">from_ptr</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">end</span>
</pre></div><p id="idp11032160">
        The array functions are similar to the standard library
        <code>Array</code> module. The conversion between arrays
        and lists involves reallocating the values, and can be expensive
        for very large data structures. Notice that you can also convert
        an array into a <code>ptr</code> pointer to the head of
        buffer, which can be useful if you need to pass the pointer and
        size arguments separately to a C function.
      </p><p id="idp11034432">
        Structures in C can contain a mixture of types, and, like OCaml
        records, their order is significant. The
        <code>Ffi.C.Type.Struct</code> module defines combinators
        to make this as easy as arrays and basic types. Let's start with
        an example by binding some time-related UNIX functions.
      </p></section><section><h1 id="example-binding-unix-date-functions">Example: binding UNIX date functions</h1><p id="idp11037168">
        The UNIX standard C library defines several useful time and date
        functions in <code>&lt;time.h&gt;</code> (usually found in
        <code>/usr/include</code> on a Linux or MacOS X system).
        The <code>localtime</code> function has the following
        signature and return value:
      </p><div class="highlight"><pre><span class="k">struct</span> <span class="n">tm</span> <span class="p">{</span>
  <span class="kt">int</span>     <span class="n">tm_sec</span><span class="p">;</span>         <span class="cm">/* seconds after the minute [0-60] */</span>
  <span class="kt">int</span>     <span class="n">tm_min</span><span class="p">;</span>         <span class="cm">/* minutes after the hour [0-59] */</span>
  <span class="kt">int</span>     <span class="n">tm_hour</span><span class="p">;</span>        <span class="cm">/* hours since midnight [0-23] */</span>
  <span class="kt">int</span>     <span class="n">tm_mday</span><span class="p">;</span>        <span class="cm">/* day of the month [1-31] */</span>
  <span class="kt">int</span>     <span class="n">tm_mon</span><span class="p">;</span>         <span class="cm">/* months since January [0-11] */</span>
  <span class="kt">int</span>     <span class="n">tm_year</span><span class="p">;</span>        <span class="cm">/* years since 1900 */</span>
  <span class="kt">int</span>     <span class="n">tm_wday</span><span class="p">;</span>        <span class="cm">/* days since Sunday [0-6] */</span>
  <span class="kt">int</span>     <span class="n">tm_yday</span><span class="p">;</span>        <span class="cm">/* days since January 1 [0-365] */</span>
  <span class="kt">int</span>     <span class="n">tm_isdst</span><span class="p">;</span>       <span class="cm">/* Daylight Savings Time flag */</span>
<span class="p">};</span>

<span class="kt">time_t</span> <span class="n">time</span><span class="p">(</span><span class="kt">time_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">localtime</span><span class="p">(</span><span class="k">const</span> <span class="kt">time_t</span> <span class="o">*</span><span class="p">);</span>
</pre></div><p id="idp11041440">
        This example is more complicated than ncurses for a couple of
        reasons. We need to allocate some memory to store a
        <code>time_t</code> value, and pass that memory into the
        <code>time</code> library call to obtain the current
        timezone. This <code>time_t</code> is then passed to the
        <code>localtime</code> library call, which returns a
        pointer to the <code>struct tm</code>.
      </p><p id="idp11045712">
        The <code>time_t</code>, and most other standard POSIX
        types, are already provided by the
        <code>Ffi.PosixTypes</code> module. Let's start by
        defining the OCaml mapping to <code>struct tm</code>:
      </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Ffi</span><span class="p">.</span><span class="nc">C</span>
<span class="k">open</span> <span class="nc">Type</span>
<span class="k">open</span> <span class="nc">PosixTypes</span>
<span class="k">open</span> <span class="nc">Struct</span>

<span class="k">type</span> <span class="n">tm</span>
<span class="k">let</span> <span class="n">tm</span> <span class="o">=</span> <span class="n">structure</span> <span class="s2">&quot;tm&quot;</span>
<span class="k">let</span> <span class="n">tm_sec</span>   <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* seconds *)</span>
<span class="k">let</span> <span class="n">tm_min</span>   <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* minutes *)</span>
<span class="k">let</span> <span class="n">tm_hour</span>  <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* hours *)</span>
<span class="k">let</span> <span class="n">tm_mday</span>  <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* day of the month *)</span>
<span class="k">let</span> <span class="n">tm_mon</span>   <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* month *)</span>
<span class="k">let</span> <span class="n">tm_year</span>  <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* year *)</span>
<span class="k">let</span> <span class="n">tm_wday</span>  <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* day of the week *)</span>
<span class="k">let</span> <span class="n">tm_yday</span>  <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* day in the year *)</span>
<span class="k">let</span> <span class="n">tm_isdst</span> <span class="o">=</span> <span class="n">tm</span> <span class="o">*:*</span> <span class="kt">int</span> <span class="c">(* daylight saving time *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">seals</span> <span class="o">(</span><span class="n">tm</span> <span class="o">:</span> <span class="n">tm</span> <span class="n">structure</span> <span class="n">typ</span><span class="o">)</span>
</pre></div><p id="idp11050528">
        This is a very mechanical translation from the C structure, due
        to the magic of the <code>*:*</code> combinator provided
        by the <code>Struct</code> module. We start building the
        definition via the <code>structure</code> allocator. Then
        the types are added in sequence, with each application recording
        the position in the <code>tm</code> structure. When all
        the fields have been added, the structure is finalized via the
        <code>seals</code> call. The definitions of
        <code>time</code> and <code>localtime</code> should
        now be familiar:
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">time</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;time&quot;</span> <span class="o">(</span><span class="n">ptr</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">syscall</span> <span class="n">time_t</span><span class="o">)</span>
<span class="k">let</span> <span class="n">asctime</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;asctime&quot;</span> <span class="o">(</span><span class="n">ptr</span> <span class="n">tm</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="kt">string</span><span class="o">)</span>
<span class="k">let</span> <span class="n">localtime</span> <span class="o">=</span> <span class="n">foreign</span> <span class="s2">&quot;localtime&quot;</span> <span class="o">(</span><span class="n">ptr</span> <span class="n">time_t</span> <span class="o">@-&gt;</span> <span class="n">returning</span> <span class="o">(</span><span class="n">ptr</span> <span class="n">tm</span><span class="o">))</span>
</pre></div><p id="idp11057584">
        The complete signature for this definition looks like this:
      </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Ffi</span><span class="p">.</span><span class="nc">C</span>
<span class="k">type</span> <span class="n">tm</span>
<span class="k">val</span> <span class="n">tm</span> <span class="o">:</span> <span class="n">tm</span> <span class="n">structure</span> <span class="n">typ</span>
<span class="k">val</span> <span class="n">tm_sec</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>
<span class="k">val</span> <span class="n">tm_min</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>
<span class="k">val</span> <span class="n">tm_hour</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>
<span class="k">val</span> <span class="n">tm_mday</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>
<span class="k">val</span> <span class="n">tm_mon</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>
<span class="k">val</span> <span class="n">tm_year</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>
<span class="k">val</span> <span class="n">tm_wday</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>
<span class="k">val</span> <span class="n">tm_yday</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>
<span class="k">val</span> <span class="n">tm_isdst</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">tm</span><span class="o">)</span> <span class="nn">Struct</span><span class="p">.</span><span class="n">field</span>

<span class="k">val</span> <span class="n">time</span> <span class="o">:</span> <span class="nn">PosixTypes</span><span class="p">.</span><span class="n">time_t</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="nn">PosixTypes</span><span class="p">.</span><span class="n">time_t</span>
<span class="k">val</span> <span class="n">localtime</span> <span class="o">:</span> <span class="nn">PosixTypes</span><span class="p">.</span><span class="n">time_t</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="n">tm</span> <span class="n">structure</span> <span class="n">ptr</span>
<span class="k">val</span> <span class="n">asctime</span> <span class="o">:</span> <span class="nn">PosixTypes</span><span class="p">.</span><span class="n">time_t</span> <span class="n">ptr</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</pre></div><p id="idp11059840">
        Unlike the ncurses example, some of the FFI types are still
        exposed in this signature due to the manual memory interface
        required by the C libraries. To use the OCaml
        <code>time</code> and <code>localtime</code>
        functions, we need to allocate some memory and construct values
        of type <code>time_t ptr</code> to them.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">timep</span> <span class="o">=</span> <span class="nn">Ptr</span><span class="p">.</span><span class="n">allocate</span> <span class="o">~</span><span class="n">count</span><span class="o">:</span><span class="mi">1</span> <span class="n">time_t</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="n">timep</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">tm</span> <span class="o">=</span> <span class="n">localtime</span> <span class="n">timep</span> <span class="k">in</span>
  <span class="n">print_endline</span> <span class="o">(</span><span class="n">asctime</span> <span class="n">tm</span><span class="o">)</span>
</pre></div><p id="idp11063776">
        The <code>Ptr.allocate</code> function allocates memory
        via <code>malloc</code> and creates an OCaml value to
        point to it. This OCaml value (<code>timep</code> in the
        example) has a finalizer function which frees the external
        memory when it is garbage collected. The
        <code>timep</code> pointer is passed into the
        <code>time</code> library call, which modifies it
        in-place. The <code>timep</code> pointer is then passed on
        to <code>localtime</code>, whose return value is converted
        into an OCaml string via <code>asctime</code>. The garbage
        collector can then collect <code>timep</code> during the
        next collection cycle.
      </p><p id="idp11071024">
        Unions in C are a collection of named structures that can be
        mapped onto the same memory. They are also supported in the
        <code>ctypes</code> library via the
        <code>Ffi.C.Union</code> module, although we won't go into
        more detail here.
      </p></section></section><section><h1 id="callbacks-between-c-and-ocaml">Callbacks between C and OCaml</h1><p id="idp11074480">
      TODO: the fts(3) interface.
    </p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt03.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="memory-representation-of-values.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>