<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 3. Lists and Patterns / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha5',
                        page: 'lists\u002Dand\u002Dpatterns.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html" class="here">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">4. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">10. Object Oriented Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-subtyping-and-inheritance.html">11. Object Subtyping and Inheritance</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 3. Lists and Patterns</h1>
                
                

    <p id="idp7502096">
    This chapter will focus on two common elements of programming in
    OCaml: lists and pattern matching. Both of these were discussed in
    <a href="a-guided-tour.html">Chapter 1, <i>A Guided Tour</i></a>, but we'll go into more
    depth here, presenting the two topics together and using one to help
    illustrate the other.
  </p><section><h1 id="list-basics">List Basics</h1><p id="idp7504160">
      An OCaml list is an immutable, finite sequence of elements of the
      same type. As we've seen, OCaml lists can be generated using a
      bracket-and-semicolon notation:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div><p id="idp7505616">
      And they can also be generated using the equivalent
      <code>::</code> notation.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">(</span><span class="mi">2</span> <span class="o">::</span> <span class="o">(</span><span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">))</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
<span class="o">#</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div><p id="idp7507680">
      As you can see, the <code>::</code> operator is
      right-associative, which means that we can built up lists without
      parenthesis. The empty list <code>[]</code> is used to
      terminate a list.
    </p><p id="idp7509440">
      The <code>::</code> operator conveys something important
      about the nature of lists, which is that they are implemented as
      singly-linked lists. The following is a rough graphical
      representation of how the list
      <code>1 :: 2 :: 3 :: []</code> is laid out as a
      data-structure. The final arrow (from the box containing
      <code>3</code>) points to the empty list.
    </p><pre id="idp7512016">
+---+---+   +---+---+   +---+---+
| 1 | *----&gt;| 2 | *----&gt;| 3 | *----&gt;||
+---+---+   +---+---+   +---+---+
</pre><p id="idp7512928">
      The <code>::</code> operator essentially adds a new block to
      the picture above. Such a block contains two things: a reference
      to the data in that list element, and a reference to the remainder
      of the list. This is why <code>::</code> can extend a list
      without modifying it; extension allocates a new list element but
      doesn't need to change any of the existing ones, as you can see:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">l</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">l</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">m</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
<span class="o">#</span> <span class="n">l</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div></section><section><h1 id="using-patterns-to-extract-data-from-a-list">Using patterns to extract data from a list</h1><p id="idp7517008">
      We can read data out of a list using a match statement. Here's a
      simple example of a recursive function that computes the sum of
      all elements of a list.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">sum</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">sum</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">6</span>
<span class="o">#</span> <span class="n">sum</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div><p id="idp7518736">
      This code follows the convention of using <code>hd</code> to
      represent the first element (or head) of the list, and
      <code>tl</code> to represent the remainder (or tail).
    </p><p id="idp7520448">
      The match statement in <code>sum</code> is really doing two
      things: first, it's acting as a case-analysis tool, breaking down
      the possibilities into a pattern-indexed list of cases. Second, it
      lets you name sub-structures within the data-structure being
      matched. In this case, the variables <code>hd</code> and
      <code>tl</code> are bound by the pattern that defines the
      first case of the match statment. Variables that are bound in this
      way can be used in the expression to the right of the arrow for
      the pattern in question.
    </p><p id="idp7523232">
      The fact that match statements can be used to bind new variables
      can be a source of confusion. To see how, imagine we wanted to
      write a function that filtered out from a list all elements equal
      to a particular value. You might be tempted to write that code as
      follows.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">drop_value</span> <span class="n">l</span> <span class="n">to_drop</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">to_drop</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">drop_value</span> <span class="n">tl</span> <span class="n">to_drop</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">drop_value</span> <span class="n">tl</span> <span class="n">to_drop</span>
  <span class="o">;;</span>
</pre></div><p id="idp7525152">
      But when we type this in, the compiler will immediately warn us
      that something is wrong. Moreover, the function clearly does the
      wrong thing, filtering out all elements of the list rather than
      just those equal to the provided value.
    </p><pre id="idp7525808">
Characters 114-122:
      | hd :: tl -&gt; hd :: drop_value tl to_drop
        ^^^^^^^^
Warning 11: this match case is unused.
val drop_value : 'a list -&gt; 'a -&gt; 'a list = &lt;fun&gt;
# drop_value [1;2;3] 2;;
- : int list = []
</pre><p id="idp7526832">
      So, what's going on?
    </p><p id="idp7527216">
      The key observation is that the appearance of
      <code>to_drop</code> in the second case doesn't imply a
      check that the first element is equal to the value
      <code>to_drop</code> passed in as an argument to
      <code>drop_value</code>. Instead, it just causes a new
      variable <code>to_drop</code> to be bound to whatever
      happens to be in the first element of the list, shadowing the
      earlier definition of <code>to_drop</code>. The third case
      is unused because it is essentially the same pattern as we had in
      the second case.
    </p><p id="idp7531184">
      A better way to write this code is not to use pattern matching for
      determining whether the first element is equal to
      <code>to_drop</code>, but to instead use an ordinary
      if-statement.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">drop_value</span> <span class="n">l</span> <span class="n">to_drop</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">new_tl</span> <span class="o">=</span> <span class="n">drop_value</span> <span class="n">tl</span> <span class="n">to_drop</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">to_drop</span> <span class="k">then</span> <span class="n">new_tl</span> <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">new_tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">drop_value</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">drop_value</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="mi">2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div><p id="idp7533824">
      Note that if we wanted to drop a particular literal value (rather
      than a value that was passed in), we could do this using something
      like our original implementation of <code>drop_value</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">drop_zero</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="mi">0</span>  <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">drop_zero</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">drop_zero</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">drop_zero</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">drop_zero</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">0</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div></section><section><h1 id="limitations-and-blessings-of-pattern-matching">Limitations (and blessings) of pattern matching</h1><p id="idp7537248">
      The above example highlights an important fact about patterns,
      which is that they can't be used to express arbitrary conditions.
      Patterns can characterize the layout of a data-structure, and can
      even include literals as in the <code>drop_zero</code>
      example, but that's where they stop. A pattern can check if a list
      has two elements, but it can't check if the first two elements are
      equal to each other.
    </p><p id="idp7538800">
      You can think of patterns as a specialized sub-language that can
      express a limited (though still quite rich) set of conditions. The
      fact that the pattern language is limited turns out to be a very
      good thing, making it possible to build better support for
      patterns in the compiler. In particular, both the efficiency of
      match statements and the ability of the compiler to detect errors
      in matches depend on the constrained nature of patterns.
    </p><section><h1 id="performance">Performance</h1><p id="idp7540576">
        Naively, you might think that it would be necessary to check
        each case in a <code>match</code> in sequence to figure
        out which one fires. If the cases of a match were guarded by
        arbitrary code, that would be the case. But OCaml is often able
        to generate machine code that jumps directly to the matched case
        based on an efficiently chosen set of run-time checks.
      </p><p id="idp7542016">
        As an example, consider the following rather silly functions for
        incrementing an integer by one. The first is implemented with a
        match statement, and the second with a sequence of if
        statements.
      </p><div class="highlight"><pre><span class="k">let</span> <span class="n">plus_one</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span>
  <span class="o">|</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">2</span>
  <span class="o">|</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">let</span> <span class="n">plus_one_slow</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">if</span>      <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">2</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">then</span> <span class="mi">3</span>
  <span class="k">else</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div><p id="idp7543920">
        If you benchmark these, you'll see that
        <code>plus_one_slow</code> is about 35% slower than
        <code>plus_one</code>, and the advantage gets larger as
        the number of cases increases.
      </p><p id="idp7545728">
        Here's another less artificial example. We can rewrite the
        <code>sum</code> function we described earlier in the
        chapter using an <code>if</code> statement rather than a
        match. We can then use the functions
        <code>is_empty</code>, <code>hd_exn</code> and
        <code>tl_exn</code> from the <code>List</code>
        module to deconstruct the list, allowing us to implement the
        entire function without pattern matching.
      </p><pre id="idp7550272">
let rec sum_slow l =
  if List.is_empty l then 0
  else List.hd_exn l + sum_slow (List.tl_exn l)
;;
</pre><p id="idp7551008">
        In this case, the match-based implementation is 70% faster than
        the one using if. The difference comes because we need to
        effectively do the same work multiple times, since each function
        we call has to re-examine the first element of the list to
        determine whether or not it's the empty cell. With a match
        statement, this work happens exactly once per list element.
      </p><p id="idp7551824">
        Generally, pattern matching is typically more efficient than the
        alternatives you might code by hand. One notable exception is
        matches over strings, which are in fact tested sequentially. But
        most of the time, using pattern matching is a clear performance
        win.
      </p></section><section><h1 id="detecting-errors">Detecting errors</h1><p id="idp7553536">
        The error-detecting capabilities of match statements are if
        anything more important than their performance. We've already
        seen one example of OCaml's ability to find problems in a
        pattern match: in our broken implementation of
        <code>drop_value</code>, OCaml warned us that the final
        case was redundant. There are no algorithms for determining if a
        predicate written in a general-purpose language is redundant,
        but it can be solved reliably in the context of patterns.
      </p><p id="idp7555104">
        OCaml also checks match statements for exhaustiveness. Consider
        what happens if we modify <code>drop_zero</code> by
        deleting the handler for one of the cases.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">drop_zero</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="mi">0</span>  <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">drop_zero</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7557312">
        The compiler will produce a warning that we've missed a case,
        along with an example of an unmatched pattern.
      </p><pre id="idp7557840">
val drop_zero : int list -&gt; 'a list = &lt;fun&gt;
Characters 26-84:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
1::_
</pre><p id="idp7558848">
        For simple examples like this, exhaustiveness checks are useful
        enough. But as we'll see in
        <a href="variants.html">Chapter 6, <i>Variants</i></a>, as you get to more
        complicated examples, especially those involving user-defined
        types, exhaustiveness checks become a lot more valuable. In
        addition to catching outright errors, they act as a sort of
        refactoring tool, guiding you to the locations where you need to
        adapt your code to deal with changing types.
      </p></section></section><section><h1 id="using-the-list-module-effectively">Using the <code>List</code> module effectively</h1><p id="idp7561984">
      We've so far written a fair amount of list-munging code using
      pattern matching and recursive functions. But in real life, you're
      usually better off using the <code>List</code> module, which
      is full of reusable functions that abstract out common patterns
      for computing with lists.
    </p><p id="idp7563328">
      Let's work through a concrete example to see this in action. We'll
      write a function <code>render_table</code> that, given a
      list of column headers and a list of rows, prints them out in a
      well formatted text table. So, if you were to write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span>
   <span class="o">(</span><span class="n">render_table</span>
     <span class="o">[</span><span class="s2">&quot;language&quot;</span><span class="o">;</span><span class="s2">&quot;architect&quot;</span><span class="o">;</span><span class="s2">&quot;first release&quot;</span><span class="o">]</span>
     <span class="o">[</span> <span class="o">[</span><span class="s2">&quot;Lisp&quot;</span> <span class="o">;</span><span class="s2">&quot;John McCarthy&quot;</span> <span class="o">;</span><span class="s2">&quot;1958&quot;</span><span class="o">]</span> <span class="o">;</span>
       <span class="o">[</span><span class="s2">&quot;C&quot;</span>    <span class="o">;</span><span class="s2">&quot;Dennis Ritchie&quot;</span><span class="o">;</span><span class="s2">&quot;1969&quot;</span><span class="o">]</span> <span class="o">;</span>
       <span class="o">[</span><span class="s2">&quot;ML&quot;</span>   <span class="o">;</span><span class="s2">&quot;Robin Milner&quot;</span>  <span class="o">;</span><span class="s2">&quot;1973&quot;</span><span class="o">]</span> <span class="o">;</span>
       <span class="o">[</span><span class="s2">&quot;OCaml&quot;</span><span class="o">;</span><span class="s2">&quot;Xavier Leroy&quot;</span>  <span class="o">;</span><span class="s2">&quot;1996&quot;</span><span class="o">]</span> <span class="o">;</span>
     <span class="o">]);;</span>
</pre></div><p id="idp7565888">
      it would generate the following output.
    </p><pre id="idp7566272">
| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |
</pre><p id="idp7567184">
      The first step is to write a function to compute the maximum width
      of each column of data. We can do this by converting the header
      and each row into a list of integer lengths, and then taking the
      element-wise max of those lists of lengths. Writing the code for
      all of this directly would be a bit of a chore, but we can do it
      quite concisely by making use of three functions from the
      <code>List</code> module: <code>map</code>,
      <code>map2_exn</code>, and <code>fold</code>.
    </p><p id="idp7570512">
<code>List.map</code> is the simplest to explain. It takes a
      list and a function for transforming elements of that list, and
      returns a new list with the transformed elements. Thus, we can
      write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="o">[</span><span class="s2">&quot;Hello&quot;</span><span class="o">;</span> <span class="s2">&quot;World!&quot;</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">]</span>
</pre></div><p id="idp7572784">
<code>List.map2_exn</code> is similar to
      <code>List.map</code>, except that it takes two lists and a
      function for combining them. Thus, we might write:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">1</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span>
</pre></div><p id="idp7575472">
      The <code>_exn</code> is there because the function throws
      an exception if the lists are of mismatched length.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">1</span><span class="o">;</span><span class="mi">0</span><span class="o">];;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="o">(</span><span class="nc">Invalid_argument</span> <span class="s2">&quot;length mismatch in rev_map2_exn: 3 &lt;&gt; 4 &quot;</span><span class="o">).</span>
</pre></div><p id="idp7577632">
<code>List.fold</code> is the most complicated of the three,
      takin three arguments: a list to process, an initial accumulator
      value, and a function for updating the accumulator with the
      information from a list element. <code>List.fold</code>
      walks over the list from left to right, updating the accumulator
      at each step and returning the final value of the accumulator when
      it's done. You can see some of this by looking at the
      type-signature for <code>fold</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">accum</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">accum</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">accum</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7581360">
      We can use <code>List.fold</code> for something as simple as
      summing up a list:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:(+)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div><p id="idp7583312">
      This example is particularly simple because the accumulator and
      the list elements are of the same type. But
      <code>fold</code> is not limited to such cases. We can for
      example use <code>fold</code> to reverse a list, in which
      case the accumulator is itself a list.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="kt">list</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="kt">list</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">1</span><span class="o">]</span>
</pre></div><p id="idp7586400">
      Let's bring our three functions together to compute the maximum
      column widths.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">max_widths</span> <span class="n">header</span> <span class="n">rows</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">lengths</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">l</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="n">rows</span>
      <span class="o">~</span><span class="n">init</span><span class="o">:(</span><span class="n">lengths</span> <span class="n">header</span><span class="o">)</span>
      <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">row</span> <span class="o">-&gt;</span>
        <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="n">acc</span> <span class="o">(</span><span class="n">lengths</span> <span class="n">row</span><span class="o">))</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">max_widths</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7588080">
      Using <code>List.map</code> we define the function
      <code>lengths</code> which converts a list of strings to a
      list of integer lengths. <code>List.fold</code> is then used
      to iterate over the rows, using <code>map2_exn</code> to
      take the max of the accumulator with the lengths of the strings in
      each row of the table, with the accumulator initialized to the
      lengths of the header row.
    </p><p id="idp7591232">
      Now that we know how to compute column widths, we can write the
      code to generate the line that separates the header from the rest
      of the text table. We'll do this in part by mapping
      <code>String.make</code> over the lengths of the columns to
      generate a string of dashes of the appropriate length. We'll then
      join these sequences of dashes together using
      <code>String.concat</code>, which concatenates a list of
      strings with an optional separator string, and
      <code>^</code>, which is a pairwise string concatenation
      function, to add the delimiters on the outside.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">render_separator</span> <span class="n">widths</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">pieces</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">widths</span>
      <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">w</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="o">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="sc">'-'</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="s2">&quot;|&quot;</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;+&quot;</span> <span class="n">pieces</span> <span class="o">^</span> <span class="s2">&quot;|&quot;</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">render_separator</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">render_separator</span> <span class="o">[</span><span class="mi">3</span><span class="o">;</span><span class="mi">6</span><span class="o">;</span><span class="mi">2</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;|-----+--------+----|&quot;</span>
</pre></div><p id="idp7595408">
      Note that we make the line of dashes two larger than the provided
      width to provide some whitespace around each entry in the table.
    </p><aside class="note"><h1>
    Performance of String.concat and
    ^
</h1><p id="idp7597840">
      In the above, we're using two different ways of concatenating
      strings, <code>String.concat</code>, which operates on lists
      of strings, and <code>^</code>, which is a pairwise
      operator. You should avoid <code>^</code> for joining long
      numbers of strings, since, it allocates a new string every time it
      runs. Thus, the following code:
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span> <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>
</pre></div><p id="idp7601328">
      will allocate a string of length 2, 3, 4, 5, 6 and 7, whereas this
      code:
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">[</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">]</span>
</pre></div><p id="idp7602816">
      allocates one string of size 7, as well as a list of length 7. At
      these small sizes, the differences don't amount to much, but for
      assembling of large strings, it can be a serious performance
      issue.
    </p></aside><p id="idp7603568">
      Now we need code for rendering a row with data in it. We'll first
      write a function <code>pad</code> for padding out a string
      to a specified length plus one blank space on either side.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">pad</span> <span class="n">s</span> <span class="n">length</span> <span class="o">=</span>
    <span class="s2">&quot; &quot;</span> <span class="o">^</span> <span class="n">s</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="o">(</span><span class="n">length</span> <span class="o">-</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="sc">' '</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">pad</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">pad</span> <span class="s2">&quot;hello&quot;</span> <span class="mi">10</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot; hello      &quot;</span>
</pre></div><p id="idp7605952">
      We can render a row of data by merging together the padded
      strings. Again, we'll use <code>List.map2_exn</code> for
      combining the list of data in the row with the list of widths.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">render_row</span> <span class="n">row</span> <span class="n">widths</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">padded</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="n">row</span> <span class="n">widths</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">pad</span> <span class="k">in</span>
    <span class="s2">&quot;|&quot;</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;|&quot;</span> <span class="n">padded</span> <span class="o">^</span> <span class="s2">&quot;|&quot;</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">render_row</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">render_row</span> <span class="o">[</span><span class="s2">&quot;Hello&quot;</span><span class="o">;</span><span class="s2">&quot;World&quot;</span><span class="o">]</span> <span class="o">[</span><span class="mi">10</span><span class="o">;</span><span class="mi">15</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;| Hello      | World           |&quot;</span>
</pre></div><p id="idp7608416">
      Now we can bring this all together in a single function that
      renders the table.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">render_table</span> <span class="n">header</span> <span class="n">rows</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">widths</span> <span class="o">=</span> <span class="n">max_widths</span> <span class="n">header</span> <span class="n">rows</span> <span class="k">in</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~</span><span class="n">sep</span><span class="o">:</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="o">(</span><span class="n">render_row</span> <span class="n">header</span> <span class="n">widths</span>
       <span class="o">::</span> <span class="n">render_separator</span> <span class="n">widths</span>
       <span class="o">::</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">rows</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">row</span> <span class="o">-&gt;</span> <span class="n">render_row</span> <span class="n">row</span> <span class="n">widths</span><span class="o">)</span>
      <span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">render_table</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><section><h1 id="more-useful-list-functions">More useful list functions</h1><p id="idp7611280">
        The example we worked through above only touched on three of the
        function in <code>List</code>. We won't cover the entire
        interface, but there are a few more functions that are useful
        enough to mention here.
      </p><p id="idp7612560">
        Very often when processing lists, one wants to restrict
        attention to just a subset of values. The
        <code>List.filter</code> function does just that.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">;</span> <span class="mi">4</span><span class="o">]</span>
</pre></div><p id="idp7614800">
        Sometimes, you want to both transform and filter as part of the
        same computation. <code>List.filter_map</code> allows you
        to do just that. The following expression uses
        <code>List.filter_map</code> to produce the list of file
        extensions in the current directory, piping the results through
        <code>List.dedup</code> to remove duplicates. Note that
        this example also uses some functions from other modules,
        including <code>Sys.ls_dir</code> to get a directory
        listing, and <code>String.rsplit2</code> to split a string
        on the rightmost appearance ofa given character.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter_map</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="s2">&quot;.&quot;</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">fname</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">rsplit2</span> <span class="o">~</span><span class="n">on</span><span class="o">:</span><span class="sc">'.'</span> <span class="n">fname</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span>  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(_,</span><span class="n">ext</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="nc">Some</span> <span class="n">ext</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">dedup</span>
  <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;byte&quot;</span><span class="o">;</span> <span class="s2">&quot;ml&quot;</span><span class="o">;</span> <span class="s2">&quot;mli&quot;</span><span class="o">;</span> <span class="s2">&quot;native&quot;</span><span class="o">;</span> <span class="s2">&quot;txt&quot;</span><span class="o">]</span>
</pre></div><p id="idp7620000">
        In the match statement above, you may notice that we for the
        first time used an underscore in a pattern match. You use an
        underscore when you want to indicate that the pattern doesn't
        depend on some sub-component of the data structure, but that you
        don't want to name it is an explicit variable.
      </p><p id="idp7620736">
        Another feature of OCaml's pattern language that we encounter
        here is <span><em>or-patterns</em></span>, which allow you to
        have multiple sub-patterns within a larger pattern. In this
        case, <code>None | Some (&quot;&quot;,_)</code> is an
        or-pattern. As we'll see later, or-patterns can be nested
        anywhere within larger patterns.
      </p><p id="idp7622480">
        Another function that is similar to <code>filter</code> is
        <code>partition_tf</code>, which takes a list and
        partitions it into a pair of lists based on a boolean condition.
        <code>tf</code> is a mnemonic to remind the reader that
        <code>true</code> elements go to the first bucket and
        <code>false</code> ones go to the second. Thus, one could
        write:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">is_ocaml_source</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">rsplit2</span> <span class="n">s</span> <span class="o">~</span><span class="n">on</span><span class="o">:</span><span class="sc">'.'</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(_,(</span><span class="s2">&quot;ml&quot;</span><span class="o">|</span><span class="s2">&quot;mli&quot;</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">is_ocaml_source</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">ml_files</span><span class="o">,</span><span class="n">other_files</span><span class="o">)</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">partition_tf</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="s2">&quot;.&quot;</span><span class="o">)</span>  <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">is_ocaml_source</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">ml_files</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;example.ml&quot;</span><span class="o">]</span>
<span class="k">val</span> <span class="n">other_files</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;_build&quot;</span><span class="o">;</span> <span class="s2">&quot;_tags&quot;</span><span class="o">]</span>
</pre></div><p id="idp7627760">
        Note the use of a nested or-pattern in
        <code>is_ocaml_source</code>.
      </p><p id="idp7628848">
        Another very common operation on lists is concatenation. The
        list module actually comes with a few different ways of doing
        this. First, there's<code>List.append</code>, for
        concatenating a pair of lists.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">;</span><span class="mi">6</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">]</span>
<span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span> <span class="o">@</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span><span class="mi">5</span><span class="o">;</span><span class="mi">6</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">]</span>
</pre></div><p id="idp7631056">
<code>@</code> is just a synonym for
        <code>List.append</code>. In addition, there is
        <code>List.concat</code>, for concatenating a list of
        lists.
      </p><p id="idp7633312">
<code>ocaml # List.concat [[1;2];[3;4;5];[6];[]];; - : int list = [1; 2; 3; 4; 5; 6]</code>
        Here's an example of using <code>List.concat</code> along
        with <code>List.map</code> to compute a recursive listing
        of a directory tree.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">ls_rec</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">is_file_exn</span> <span class="o">~</span><span class="n">follow_symlinks</span><span class="o">:</span><span class="bp">true</span> <span class="n">s</span>
    <span class="k">then</span> <span class="o">[</span><span class="n">s</span><span class="o">]</span>
    <span class="k">else</span>
      <span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="n">s</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">sub</span> <span class="o">-&gt;</span> <span class="n">ls_rec</span> <span class="o">(</span><span class="n">s</span> <span class="o">^</span> <span class="s2">&quot;/&quot;</span> <span class="o">^</span> <span class="n">sub</span><span class="o">))</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat</span>
  <span class="o">;;</span>
<span class="o">#</span> <span class="n">all_files</span> <span class="s2">&quot;.&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span>
<span class="o">[</span><span class="s2">&quot;./_build/_digests&quot;</span><span class="o">;</span> <span class="s2">&quot;./_build/_log&quot;</span><span class="o">;</span> <span class="s2">&quot;./_build/example.ml&quot;</span><span class="o">;</span>
 <span class="s2">&quot;./_build/example.ml.depends&quot;</span><span class="o">;</span> <span class="s2">&quot;./_build/ocamlc.where&quot;</span><span class="o">;</span> <span class="s2">&quot;./_tags&quot;</span><span class="o">;</span>
 <span class="s2">&quot;./example.ml&quot;</span><span class="o">]</span>
</pre></div><p id="idp7637136">
        The above combination of <code>List.map</code> and
        <code>List.concat</code> is common enough that there is a
        function <code>List.concat_map</code> that combines these
        into one, more efficient operation.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">ls_rec</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">is_file_exn</span> <span class="o">~</span><span class="n">follow_symlinks</span><span class="o">:</span><span class="bp">true</span> <span class="n">s</span>
    <span class="k">then</span> <span class="o">[</span><span class="n">s</span><span class="o">]</span>
    <span class="k">else</span>
      <span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="n">s</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat_map</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">sub</span> <span class="o">-&gt;</span> <span class="n">ls_rec</span> <span class="o">(</span><span class="n">s</span> <span class="o">^/</span> <span class="n">sub</span><span class="o">))</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">ls_rec</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div></section></section><section><h1 id="tail-recursion">Tail recursion</h1><p id="idp7641728">
      The only way to compute the length of an OCaml list is to walk the
      list from beginning to end. As a result, computing the length of a
      list takes time linear in the size of the list. Here's a simple
      function for doing so.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">length</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="o">#</span> <span class="n">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div><p id="idp7643536">
      This looks simple enough, but you'll discover that this
      implementation runs into problems on very large lists. Here are
      some examples, using another useful function from the
      <code>List</code> module, <code>List.init</code>, to
      create the lists. <code>List.init</code> takes an integer
      <code>n</code> and a function <code>f</code> and
      creates a list of length <code>n</code> where the data for
      each element is created by calling <code>f</code> on the
      index of that element.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">make_list</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">init</span> <span class="n">n</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">make_list</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">make_list</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">9</span><span class="o">]</span>
<span class="o">#</span> <span class="n">length</span> <span class="o">(</span><span class="n">make_list</span> <span class="mi">10_000_000</span><span class="o">);;</span>
<span class="nc">Stack</span> <span class="n">overflow</span> <span class="n">during</span> <span class="n">evaluation</span> <span class="o">(</span><span class="n">looping</span> <span class="n">recursion</span><span class="o">?).</span>
</pre></div><p id="idp7649936">
      To understand what went wrong, you need to learn a bit more about
      how function calls work. Typically, a function call needs some
      space to keep track of information associated with the call, such
      as the arguments passed to the function, or the location of the
      code that needs to start executing when the function call is
      complete. To allow for nested function calls, this information is
      typically organized in a stack, where a new <span><em>stack
      frame</em></span> is allocated for each nested function call, and
      then deallocated when the function call is complete.
    </p><p id="idp7651328">
      And that's the problem with our call to <code>length</code>:
      it tried to allocate ten million stack frames, which exhausted the
      available stack space. Happily, there's a way around this problem.
      Consider the following alternative implementation.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">length_plus_n</span> <span class="n">l</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">n</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">length_plus_n</span> <span class="n">tl</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">length_plus_n</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">length</span> <span class="n">l</span> <span class="o">=</span> <span class="n">length_plus_n</span> <span class="n">l</span> <span class="mi">0</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">length</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="n">utop</span><span class="o">[</span><span class="mi">41</span><span class="o">]&gt;</span> <span class="n">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div><p id="idp7653792">
      This implementation depends on a helper function,
      <code>length_plus_n</code>, that computes the length of a
      given list plus a given <code>n</code>. In practice,
      <code>n</code> acts as an accumulator in which the answer is
      built up, step by step. As a result, we can do the additions along
      the way rather than doing them as we unwind the nested sequence of
      function calls, as we did in our first implemenation of
      <code>length</code>.
    </p><p id="idp7657104">
      The advantage of this approach is that the recursive call in
      <code>length_plus_n</code> is a <span><em>tail
      call</em></span>. We'll explain more precisely what it means to be
      a tail call shortly, but the reason it's important is that tail
      calls don't require the allocation of a new stack frame, due to
      what is called the <span><em>tail-call optimization</em></span>. A
      recursive function is said to be <span><em>tail
      recursive</em></span> if all of its recursive calls are tail calls.
      <code>length_plus_n</code> is indeed tail recursive, and as
      a result, <code>length</code> can take a long list as input
      without blowing the stack.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">length</span> <span class="o">(</span><span class="n">make_list</span> <span class="mi">10_000_000</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10000000</span>
</pre></div><p id="idp7661792">
      So when is a call a tail call? Let's think about the situation of
      one function (the <span><em>caller</em></span>) invokes another
      (the <span><em>callee</em></span>). The invocation is considered a
      tail call when the caller doesn't do anything with the value
      returned by the callee except to return it. The tail-call
      optimization makes sense because, when a caller makes a tail call,
      the caller's stack frame need never be used again, and so you
      don't need to keep it around. Thus, instead of allocating a new
      stack frame for the callee, the compiler is free to resuse the
      caller's stack frame.
    </p><p id="idp7663552">
      Tail recursion are important for more than just lists. Ordinary
      (non-tail) recursive calls are reasonable when the dealing with
      data-structures like binary trees where the depth of the tree is
      logarithmic in the size of your data. But when dealing with
      situations where the depth of the sequence of nested calls is on
      the order of the size of your data, tail recursion is usually the
      right approach.
    </p></section><section><h1 id="more-concise-and-faster-patterns">More concise and faster patterns</h1><p id="idp7665408">
      Now that we know more about how lists and patterns work, let's
      consider how we can improve on an example from
      (xref)(#recursive-list-functions): the function
      <code>destutter</code>, which removes sequential duplicates
      from a list. Here's the implementation that was described earlier.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">destutter</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">hd'</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">hd'</span> <span class="k">then</span> <span class="n">destutter</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span>
      <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">destutter</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span>
  <span class="o">;;</span>
</pre></div><p id="idp7668032">
      We'll consider some ways of making this code more concise and more
      efficient.
    </p><p id="idp7668528">
      First, let's consider efficiency. One problem with the
      <code>destutter</code> code above is that it in some cases
      recreates on the right-hand side of the arrow a value that already
      existed on the left hand side. Thus, the pattern
      <code>hd :: [] -&gt; hd :: []</code> actually allocates a
      new list element, which really, it should be able to just return
      the list being matched. We can reduce allocation here by using an
      <code>as</code> pattern, which allows us to declare a name
      for the thing matched by a pattern or sub-pattern. While we're at
      it, we'll use the <code>function</code> keyword to eliminate
      the need for an explicit match.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="bp">[]</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="n">tl</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">hd'</span> <span class="k">then</span> <span class="n">destutter</span> <span class="n">tl</span>
      <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">destutter</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7673248">
      We can further collapse this by combining the first two cases into
      one, using an or-pattern. At the same time, we'll use the more
      concise <code>[_]</code> pattern to match a list with a
      single element, rather than <code>_ :: []</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[_]</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="n">tl</span><span class="o">)</span> <span class="k">when</span> <span class="n">hd1</span> <span class="o">=</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">hd1</span> <span class="o">=</span> <span class="n">hd2</span> <span class="k">then</span> <span class="n">destutter</span> <span class="n">tl</span>
      <span class="k">else</span> <span class="n">hd1</span> <span class="o">::</span> <span class="n">destutter</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7676384">
      We can make the code slightly terser now by using a
      <code>when</code> clause. A <code>when</code> clause
      allows one to add an extra precondition on a pattern in the form
      of an arbitrary OCaml expression. In this case, we can use it to
      include the check on whether the first two elements are equal.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[_]</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="o">(</span><span class="n">hd'</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="n">tl</span><span class="o">)</span> <span class="k">when</span> <span class="n">hd</span> <span class="o">=</span> <span class="n">hd'</span> <span class="o">-&gt;</span> <span class="n">destutter</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">destutter</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7679488">
      Note that <code>when</code> clauses have some downsides. As
      we noted earlier, the static checks associated with pattern
      matches rely on the fact that patterns are restricted in what they
      can express. Once we add the ability to add an arbitrary condition
      to a pattern, something will be lost. In particular, the ability
      for the compiler to determine if a match is exhaustive, or if some
      case is redundant, is compromised.
    </p><p id="idp7680944">
      Consider the following function which takes a list of optional
      values, and returns the number of those values that are
      <code>Some</code>. Because this implementation uses
      <code>when</code> clauses, the compiler can't tell that the
      code is exhaustive.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">count_some</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_some</span> <span class="n">tl</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">count_some</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="nc">Characters</span> <span class="mi">30</span><span class="o">-</span><span class="mi">169</span><span class="o">:</span>
<span class="k">val</span> <span class="n">count_some</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="nc">Warning</span> <span class="mi">8</span><span class="o">:</span> <span class="n">this</span> <span class="n">pattern</span><span class="o">-</span><span class="n">matching</span> <span class="n">is</span> <span class="n">not</span> <span class="n">exhaustive</span><span class="o">.</span>
<span class="nc">Here</span> <span class="n">is</span> <span class="n">an</span> <span class="n">example</span> <span class="k">of</span> <span class="n">a</span> <span class="n">value</span> <span class="n">that</span> <span class="n">is</span> <span class="n">not</span> <span class="n">matched</span><span class="o">:</span>
<span class="o">_::_</span>
<span class="o">(</span><span class="nc">However</span><span class="o">,</span> <span class="n">some</span> <span class="n">guarded</span> <span class="n">clause</span> <span class="n">may</span> <span class="k">match</span> <span class="n">this</span> <span class="n">value</span><span class="o">.)</span>
</pre></div><p id="idp7684736">
      Despite the warning, the function does work fine.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="n">count_some</span> <span class="o">[</span><span class="nc">Some</span> <span class="mi">3</span><span class="o">;</span> <span class="nc">None</span><span class="o">;</span> <span class="nc">Some</span> <span class="mi">4</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div><p id="idp7686064">
      If we add another redundant case without a <code>when</code>
      clause, the compiler will stop complaining about exhaustiveness,
      and won't produce a warning about the redundancy.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">count_some</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="c">(* unreachable *)</span>
  <span class="o">;;</span>
<span class="k">val</span> <span class="n">count_some</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div><p id="idp7688448">
      Probably a better approach is to simply drop the second
      <code>when</code> clause.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">count_some</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_some</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7690720">
      This is a little less clear, however, than the direct pattern
      matching solution, where the meaning of each pattern is clearer on
      its own.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">count_some</span> <span class="kt">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="nc">None</span>   <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">count_some</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">_</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_some</span> <span class="n">tl</span>
  <span class="o">;;</span>
</pre></div><p id="idp7692448">
      The takeaway from all of this is that, while
      <code>when</code> clauses can be useful, one should prefer
      patterns wherever they are sufficient.
    </p><p id="idp7693648">
      As a side note, the above implementation of
      <code>count_some</code> is longer than necessary, and to
      boot is not tail recursive. For real work, you should probably
      just use the<code>List.count</code> function from
      <code>Core</code> as follows:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">count_some</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">count</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="n">l</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">count_some</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="variables-and-functions.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="files-modules-and-programs.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>