<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 22. Runtime Memory Layout / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha5',
                        page: 'runtime\u002Dmemory\u002Dlayout.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="runtime-memory-layout.html" class="here">22. Runtime Memory Layout</a>
                                            </li>
                                        
                                            <li>
                                                <a href="parsing-binary-protocols-with-bigarray.html">23. Handling Binary Protocols with Bigarray</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">24. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 22. Runtime Memory Layout</h1>
                
                

    <p id="idp10956272">
    Much of the static type information contained within an OCaml
    program is checked and discarded at compilation time, leaving a much
    simpler <span><em>runtime</em></span> representation for values.
    Understanding this difference is important for writing efficient
    programs and profiling them at runtime.
  </p><aside class="note"><h1>
  Why do OCaml types disappear at runtime?
  </h1><p id="idp10958112">
    The OCaml compiler runs through several phases during the
    compilation process. The first phase is syntax checking, during
    which source files are parsed into Abstract Syntax Trees (ASTs). The
    next stage is a <span><em>type checking</em></span> pass over the
    AST. In a validly typed program, a function cannot be applied with
    an unexpected type. For example, the
    <code>print_endline</code> function must receive a single
    <code>string</code> argument, and an <code>int</code>
    will result in a type error.
  </p><p id="idp10961456">
    Since OCaml verifies these properties at compile time, it doesn't
    need to keep track of as much information at runtime. Thus, later
    stages of the compiler can discard and simplify the type
    declarations to a much more minimal subset that's actually required
    to distinguish polymorphic values at runtime. This is a major
    performance win versus something like a Java or .NET method call,
    where the runtime must look up the concrete instance of the object
    and dispatch the method call. Those languages amortize some of the
    cost via &quot;Just-in-Time&quot; dynamic patching, but OCaml
    prefers runtime simplicity instead.
  </p></aside><p id="idp10963120">
    Another reason to use the C interface directly is if you need to
    build foreign-function interfaces directly instead of going through
    the <code>ctypes</code> library described in
    <a href="foreign-function-interface" target="_top">xref</a>. This could be
    for performance reasons, or some more specialised embedded or kernel
    environment. Let's start by explaining the memory layout, and then
    move onto the details of how low-level C bindings work.
  </p><section><h1 id="the-garbage-collector">The garbage collector</h1><p id="idp10966432">
      A running OCaml program uses blocks of memory (i.e. contiguous
      sequences of words in RAM) to represent many of the values that it
      deals with such as tuples, records, closures or arrays. An OCaml
      program implicitly allocates a block of memory when such a value
      is created.
    </p><pre id="idp10967136">
# let x = { foo = 13; bar = 14 } ;;
</pre><p id="idp10967840">
      An expression such as the record above requires a new block of
      memory with two words of available space. One word holds the
      <code>foo</code> field and the second word holds the
      <code>bar</code> field. The OCaml compiler translates such
      an expression into an explicit allocation for the block from
      OCaml's runtime system: a C library that provides a collection of
      routines that can be called by running OCaml programs. The runtime
      system manages a <span><em>heap</em></span>, which is a collection
      of memory regions it obtains from the operating system using
      <span><em>malloc(3)</em></span>. The OCaml runtime uses these
      memory regions to hold <span><em>heap blocks</em></span>, which it
      then fills up in response to allocation requests by the OCaml
      program.
    </p><p id="idp10971600">
      When there isn't enough memory available to satisfy an allocation
      request from the allocated heap blocks, the runtime system invokes
      the <span><em>garbage collector</em></span> (or GC). An OCaml
      program does not explicitly free a heap block when it is done with
      it, and the GC must determine which heap blocks are
      &quot;live&quot; and which heap blocks are &quot;dead&quot;, i.e.
      no longer in use. Dead blocks are collected and their memory made
      available for re-use by the application.
    </p><p id="idp10973488">
      The garbage collector does not keep constant track of blocks as
      they are allocated and used. Instead, it regularly scans blocks by
      starting from a set of <span><em>roots</em></span>, which are
      values that the application always has access to (such as the
      stack). The GC maintains a directed graph in which heap blocks are
      nodes, and there is an edge from heap block <code>b1</code>
      to heap block <code>b2</code> if some field of
      <code>b1</code> points to <code>b2</code>. All blocks
      reachable from the roots by following edges in the graph must be
      retained, and unreachable blocks can be reused. This strategy is
      commonly known as &quot;mark and sweep&quot; collection.
    </p><p id="idp10977920">
      The typical OCaml programming style typically involves allocating
      many small blocks of memory that are used for a short period of
      time and then never accessed again. OCaml takes advantage of this
      fact to improve the performance of allocation and collection by
      using a <span><em>generational</em></span> garbage collector. This
      means that it has different memory regions to hold blocks based on
      how long the blocks have been live. OCaml's heap is split in two;
      there is a small, fixed-size <span><em>minor heap</em></span> where
      most most blocks are initially allocated, and a large,
      variable-sized <span><em>major heap</em></span> for blocks that
      have been live longer or are larger than 4KB. A typical functional
      programming style means that young blocks tend to die young, and
      old blocks tend to stay around for longer than young ones (this is
      referred to as the <span><em>generational hypothesis</em></span>).
    </p><p id="idp10980928">
      OCaml uses different memory layouts and garbage collection
      algorithms for the major and minor heaps to account for this
      generational difference. We're going to describe the memory layout
      in this chapter, and move onto the garbage collections algorithms
      in <a href="inside-the-runtime" target="_top">xref</a>.
    </p><section><h1 id="the-fast-minor-heap">The fast minor heap</h1><p id="idp10983488">
        The minor heap is one contiguous chunk of virtual memory
        containing a sequence of heap blocks that have been allocated.
        If there is space, allocating a new block is a fast
        constant-time operation in which the pointer to the end of the
        heap is incremented by the desired size. To garbage collect the
        minor heap, OCaml uses <span><em>copying collection</em></span>
        to copy all live blocks in the minor heap to the major heap.
        This only takes work proportional to the number of live blocks
        in the minor heap, which is typically small according to the
        generational hypothesis.
      </p><p id="idp10984944">
        One complexity of generational collection is that in order to
        know which blocks in the minor heap are live, the collector must
        track which minor-heap blocks are directly pointed to by
        major-heap blocks. Without this information, the minor
        collection would require scanning the much larger major heap.
        OCaml maintains a set of such <span><em>inter-generational
        pointers</em></span>, and, through cooperation with the compiler,
        introduces a write barrier to update this set whenever a
        major-heap block is modified to point at a minor-heap block.
        We'll talk more about the implications of the write barrier in
        <a href="tuning-and-profiling" target="_top">xref</a>.
      </p></section><section><h1 id="the-long-lived-major-heap">The long-lived major heap</h1><p id="idp10988432">
        The major heap consists of any number of non-contiguous chunks
        of virtual memory, each containing live blocks interspersed with
        regions of free memory. The runtime system maintains a free list
        data structure that indexes all the free memory, and this list
        is used to satisfy allocation requests for OCaml blocks. The
        major heap is cleaned via a mark and sweep garbage collection
        algorithm.
      </p><ul><li><p id="idp10989792">
            The <span><em>mark</em></span> phase traverses the block
            graph and marks all live blocks by setting a bit in the tag
            of the block header (known as the <span><em>color</em></span>
            tag).
          </p></li><li><p id="idp10991632">
            The <span><em>sweep</em></span> phase sequentially scans the
            heap chunks and identifies dead blocks that weren't marked
            earlier.
          </p></li><li><p id="idp10992992">
            The <span><em>compact</em></span> phase moves live blocks to
            eliminate the gaps of free memory into a freshly allocated
            heap, and ensures that memory does not fragment in
            long-lived programs.
          </p></li></ul><p id="idp10994304">
        A major heap garbage collection must <span><em>stop the
        world</em></span> (that is, halt the application) in order to
        ensure that blocks can be safely moved around without this move
        being observed by the live application. The mark and sweep
        phases run incrementally over slices of memory, and are broken
        up into a number of steps that are interspersed with the running
        OCaml program. Only the compaction phase touches all the memory
        in one go, and is a relatively rare operation.
      </p><p id="idp10995648">
        The <code>Gc</code> module lets you control all these
        parameters from your application. Although the defaults are
        usually sensible, understanding them and tuning them is an
        important concern we will discuss later in
        <a href="tuning-and-profiling" target="_top">xref</a>.
      </p></section></section><section><h1 id="the-representation-of-ocaml-values">The representation of OCaml values</h1><p id="idp10999072">
      So far, we've described the overall memory layout, but not what
      the contents of each block contains. Every OCaml variable points
      to a <code>value</code> at runtime, which is a single memory
      word that is either an integer or a pointer. The OCaml runtime
      needs to understand the difference between the two so that it can
      follow pointers, but not integers (which directly hold the value
      and don't point to anything meaningful).
    </p><p id="idp11000640">
      If the lowest bit of the block word is non-zero, the value is an
      unboxed integer. Several OCaml types map onto this integer
      representation, including <code>bool</code>,
      <code>int</code>, the empty list, <code>unit</code>,
      and variants without constructors. Integers are the only unboxed
      runtime values in OCaml, which means that they can be stored
      directly without having to allocate a wrapper structure that will
      take up more memory. They can also be passed directly to other
      function calls in registers, and so are generally the cheapest and
      fastest values to use in OCaml.
    </p><p id="idp11003728">
      If the lowest bit of the <code>value</code> is zero, then
      the value is a memory pointer. A pointer value is stored
      unmodified, since pointers are guaranteed to be word-aligned and
      so the bottom bits are always zero. If the pointer is inside a
      memory chunk that is marked as being managed by the OCaml runtime,
      it is assumed to point to an OCaml block (see below). If it points
      outside the OCaml runtime area, it is is treated as an opaque C
      pointer to some other system resource.
    </p><aside class="note"><h1>
    Some history about OCaml's word-aligned pointers
    </h1><p id="idp11006064">
      The alert reader may be wondering how OCaml can guarantee that all
      of its pointers are word-aligned. In the old days when RISC chips
      such as Sparc, MIPS and Alpha were commonplace, unaligned memory
      accesses were forbidden by the instruction set architecture and
      would result in a CPU exception that terminated the program. Thus,
      all pointers were historically rounded off to the architecture
      word-size (usually 32- or 64-bits).
    </p><p id="idp11006944">
      Modern CISC processors such as the Intel x86 do support unaligned
      memory accesses, but the chip still runs faster if accesses are
      word-aligned. OCaml therefore simply mandates that all pointers be
      word-aligned, which guarantees that the bottom few bits of any
      valid pointer will be zero. Setting the bottom bit to a non-zero
      value is a simple way to mark an integer, at the cost of losing
      that single bit of precision.
    </p><p id="idp11007808">
      An even more alert reader will be wondering about the performance
      implications are for integer arithmetic using this tagged
      representation. Since the bottom bit is set, any operation on the
      integer has to shift the bottom bit right to recover the
      &quot;native&quot; value. The native code OCaml compiler generates
      very efficient x86 assembly code in this case, and takes advantage
      of modern processor instructions to either hide the extra work, or
      get it for free from the instruction set. Addition and
      substraction are a single instruction, and multiplication is only
      a few more.
    </p></aside><section><h1 id="blocks-and-values">Blocks and values</h1><p id="idp11011248">
        An OCaml <span><em>block</em></span> is the basic unit of
        allocation on the heap. A block consists of a one-word header
        (either 32- or 64-bits) followed by variable-length data that is
        either opaque bytes or an array of <span><em>fields</em></span>.
        The header has a multi-purpose tag byte that defines whether to
        interprete the subsequent data as opaque or OCaml fields. The
        garbage collector never inspects opaque bytes, but the array of
        fields are all treated as more valid OCaml values. The garbage
        collector always inspects fields, and follows them as part of
        the collection process described earlier.
      </p><pre id="idp11013152">
+------------------------+-------+----------+----------+----------+----
| size of block in words |  col  | tag byte | value[0] | value[1] | ...
+------------------------+-------+----------+----------+----------+----
 &lt;-either 22 or 54 bits-&gt; &lt;2 bit&gt; &lt;--8 bit--&gt;
</pre><p id="idp11014256">
        The size field records the length of the block in memory words.
        Note that it is limited to 22-bits on 32-bit platforms, which is
        the reason why OCaml strings are limited to 16MB on that
        architecture. If you need bigger strings, either switch to a
        64-bit host, or use the <code>Bigarray</code> module
        described in
        <a href="managing-external-memory-with-bigarrays" target="_top">xref</a>.
        The 2-bit color field is used by the garbage collector to keep
        track of its state during mark-and-sweep, and is not exposed
        directly to OCaml programs.
      </p><table><thead><tr><th>
                Tag Color
              </th><th>
                Block Status
              </th></tr></thead><tbody><tr><td>
                blue
              </td><td>
                on the free list and not currently in use
              </td></tr><tr><td>
                white
              </td><td>
                not reached yet, but possibly reachable
              </td></tr><tr><td>
                gray
              </td><td>
                reachable, but its fields have not been scanned
              </td></tr><tr><td>
                black
              </td><td>
                reachable, and its fields have been scanned
              </td></tr></tbody></table><p id="idp11025904">
        A block's tag byte is multi-purpose, and indicates whether the
        data array represents opaque bytes or fields. If a block's tag
        is greater than or equal to <code>No_scan_tag</code>
        (251), then the block's data are all opaque bytes, and are not
        scanned by the collector. The most common such block is the
        <code>string</code> type, which we describe more below.
      </p><p id="idp11028080">
        The exact representation of values inside a block depends on
        their OCaml type. They are summarised in the table below, and
        then we'll examine some of them in greater detail.
      </p><table><thead><tr><th>
                OCaml Value
              </th><th>
                Representation
              </th></tr></thead><tbody><tr><td>
                any <code>int</code> or <code>char</code>
</td><td>
                directly as a value, shifted left by 1 bit, with the
                least significant bit set to 1
              </td></tr><tr><td>
<code>unit</code>, <code>[]</code>,
                <code>false</code>
</td><td>
                as OCaml <code>int</code> 0.
              </td></tr><tr><td>
<code>true</code>
</td><td>
                as OCaml <code>int</code> 1.
              </td></tr><tr><td>
<code>Foo | Bar</code>
</td><td>
                as ascending OCaml <code>int</code>s, starting
                from 0.
              </td></tr><tr><td>
<code>Foo | Bar of int</code>
</td><td>
                variants with parameters are boxed, while entries with
                no parameters are unboxed (see below).
              </td></tr><tr><td>
                polymorphic variants
              </td><td>
                variable space usage depending on the number of
                parameters (see below).
              </td></tr><tr><td>
                floating point number
              </td><td>
                as a block with a single field containing the
                double-precision float.
              </td></tr><tr><td>
                string
              </td><td>
                word-aligned byte arrays that are also directly
                compatible with C strings.
              </td></tr><tr><td>
<code>[1; 2; 3]</code>
</td><td>
                as <code>1::2::3::[]</code> where
                <code>[]</code> is an int, and
                <code>h::t</code> a block with tag 0 and two
                parameters.
              </td></tr><tr><td>
                tuples, records and arrays
              </td><td>
                an array of values. Arrays can be variable size, but
                structs and tuples are fixed size.
              </td></tr><tr><td>
                records or arrays, all float
              </td><td>
                special tag for unboxed arrays of floats. Doesn't apply
                to tuples.
              </td></tr></tbody></table></section><section><h1 id="integers-characters-and-other-basic-types">Integers, characters and other basic types</h1><p id="idp11058848">
        Many basic types are stored directly as unboxed values at
        runtime. The native <code>int</code> type is the most
        obvious, although it drops a single bit of precision due to the
        tag bit described earlier. Other atomic types such as the
        <code>unit</code> and empty list <code>[]</code>
        value are stored as constant integers. Boolean values have a
        value of <code>0</code> and <code>1</code> for
        <code>true</code> and <code>false</code>
        respectively.
      </p><p id="idp11064480">
        Remember that since integers are never allocated on the heap,
        all of these basic types such as empty lists and
        <code>unit</code> are therefore very efficient to use.
        They will often be passed in registers and never even appear on
        the stack, if you don't have too many parameters to your
        functions or are running on a modern architecture with lots of
        spare registers (such as <code>x86_64</code>).
      </p></section><section><h1 id="tuples-records-and-arrays">Tuples, records and arrays</h1><pre id="idp11068000">
+---------+----------+----------- - - - - 
| header  | value[0] | value[1] | ....
+---------+----------+----------+- - - - -
</pre><p id="idp11068800">
        Tuples, records and arrays are all represented identically at
        runtime as a block with tag <code>0</code>. Tuples and
        records have constant sizes determined at compile-time, whereas
        arrays can be of variable length. While arrays are restricted to
        containing a single type of element in the OCaml type system,
        this is not required by the memory representation.
      </p><p id="idp11070272">
        You can check the difference between a block and a direct
        integer yourself using the <code>Obj</code> module, which
        exposes the internal representation of values to OCaml code.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">is_block</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">is_block</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="mi">1</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp11072576">
        The <code>Obj.repr</code> function retrieves the runtime
        representation of any OCaml value.
        <code>Obj.is_block</code> checks the bottom bit to
        determine if the value is a block header or an unboxed integer.
      </p></section><section><h1 id="floating-point-numbers-and-arrays">Floating point numbers and arrays</h1><p id="idp11075856">
        Floating point numbers in OCaml are always stored as full
        double-precision values. Individual floating point values are
        stored as a block with a single field that contains the number.
        This block has the <code>Double_tag</code> set which
        signals to the collector that the floating point value is not to
        be scanned.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">tag</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="o">=</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">double_tag</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">253</span>
<span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">double_tag</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">253</span>
</pre></div><p id="idp11078352">
        Since each floating-point value is boxed in a separate memory
        block, it can be inefficient to handle large arrays of floats in
        comparison to unboxed integers. OCaml therefore special-cases
        records or arrays that contain <span><em>only</em></span>
<code>float</code> types. These are stored in a block that
        contains the floats packed directly in the data section, with
        the <code>Double_array_tag</code> set to signal to the
        collector that the contents are not OCaml values.
      </p><pre id="idp11081040">
+---------+----------+----------- - - - - 
| header  | float[0] | float[1] | ....
+---------+----------+----------+- - - - -
</pre><p id="idp11081840">
        You can test this for yourself using the
        <code>Obj.tag</code> function to check that the allocated
        block has the expected runtime tag, and
        <code>Obj.double_field</code> to retrieve a float from
        within the block.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">open</span> <span class="nc">Obj</span> <span class="o">;;</span>
<span class="o">#</span> <span class="n">tag</span> <span class="o">(</span><span class="n">repr</span> <span class="o">[|</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">;</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">;</span> <span class="mi">3</span><span class="o">.</span><span class="mi">0</span> <span class="o">|])</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">254</span>
<span class="o">#</span> <span class="n">tag</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span> 
<span class="o">#</span> <span class="n">double_field</span> <span class="o">(</span><span class="n">repr</span> <span class="o">[|</span> <span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">.</span><span class="mi">3</span> <span class="o">|]</span> <span class="o">)</span> <span class="mi">1</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span>
<span class="o">#</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">double_field</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="mi">1</span><span class="o">.</span><span class="mi">234</span><span class="o">)</span> <span class="mi">0</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">234</span>
</pre></div><p id="idp11085056">
        Notice that float tuples are <span><em>not</em></span> optimized
        in the same way as float records or arrays, and so they have the
        usual tuple tag value of <code>0</code>. Only records and
        arrays can have the array optimization, and only if every single
        field is a float.
      </p></section><section><h1 id="variants-and-lists">Variants and lists</h1><p id="idp11088080">
        Basic variant types with no extra parameters for any of their
        branches are simply stored as an OCaml integer, starting with
        <code>0</code> for the first option and in ascending
        order.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">open</span> <span class="nc">Obj</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Apple</span> <span class="o">|</span> <span class="nc">Orange</span> <span class="o">|</span> <span class="nc">Pear</span> <span class="o">;;</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Apple</span> <span class="o">|</span> <span class="nc">Orange</span> <span class="o">|</span> <span class="nc">Pear</span>
<span class="o">#</span> <span class="o">((</span><span class="n">magic</span> <span class="o">(</span><span class="n">repr</span> <span class="nc">Apple</span><span class="o">))</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="o">((</span><span class="n">magic</span> <span class="o">(</span><span class="n">repr</span> <span class="nc">Pear</span><span class="o">))</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">#</span> <span class="n">is_block</span> <span class="o">(</span><span class="n">repr</span> <span class="nc">Apple</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div><p id="idp11090528">
<code>Obj.magic</code> unsafely forces a type cast between
        any two OCaml types; in this example the <code>int</code>
        type hint retrieves the runtime integer value. The
        <code>Obj.is_block</code> confirms that the value isn't a
        more complex block, but just an OCaml <code>int</code>.
      </p><p id="idp11093904">
        Variants that have parameters arguments are a little more
        complex. They are stored as blocks, with the value
        <span><em>tags</em></span> ascending from 0 (counting from
        leftmost variants with parameters). The parameters are stored as
        words in the block.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Apple</span> <span class="o">|</span> <span class="nc">Orange</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Pear</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Kiwi</span> <span class="o">;;</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Apple</span> <span class="o">|</span> <span class="nc">Orange</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Pear</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Kiwi</span>
<span class="o">#</span> <span class="n">is_block</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Orange</span> <span class="mi">1234</span><span class="o">))</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">tag</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Orange</span> <span class="mi">1234</span><span class="o">))</span> <span class="o">;;</span> 
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="n">tag</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Pear</span> <span class="s2">&quot;xyz&quot;</span><span class="o">))</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">#</span> <span class="o">(</span><span class="n">magic</span> <span class="o">(</span><span class="n">field</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Orange</span> <span class="mi">1234</span><span class="o">))</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="o">(</span><span class="n">magic</span> <span class="o">(</span><span class="n">field</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="nc">Pear</span> <span class="s2">&quot;xyz&quot;</span><span class="o">))</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="kt">string</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;xyz&quot;</span>
</pre></div><p id="idp11096416">
        In the above example, the <code>Apple</code> and
        <code>Kiwi</code> values are still stored as normal OCaml
        integers with values <code>0</code> and
        <code>1</code> respectively. The <code>Orange</code>
        and <code>Pear</code> values both have parameters, and are
        stored as blocks whose tags ascend from <code>0</code>
        (and so <code>Pear</code> has a tag of
        <code>1</code>, as the use of <code>Obj.tag</code>
        verifies). Finally, the parameters are fields which contain
        OCaml values within the block, and <code>Obj.field</code>
        can be used to retrieve them.
      </p><p id="idp11104880">
        Lists are stored with a representation that is exactly the same
        as if the list was written as a variant type with
        <code>Head</code> and <code>Cons</code>. The empty
        list <code>[]</code> is an integer <code>0</code>,
        and subsequent blocks have tag <code>0</code> and two
        parameters: a block with the current value, and a pointer to the
        rest of the list.
      </p><aside class="warning"><h1>
Obj module considered harmful
      </h1><p id="idp11110416">
        The <code>Obj</code> module is an undocumented module that
        exposes the internals of the OCaml compiler and runtime. It is
        very useful for examining and understanding how your code will
        behave at runtime, but should <span><em>never</em></span> be used
        for production code unless you understand the implications. The
        module bypasses the OCaml type system, making memory corruption
        and segmentation faults possible.
      </p><p id="idp11112368">
        Some theorem provers such as Coq do output code which uses
        <code>Obj</code> internally, but the external module
        signatures never expose it. Unless you too have a machine proof
        of correctness to accompany your use of <code>Obj</code>,
        stay away from it except for debugging!
      </p></aside><p id="idp11114544">
        Due to this encoding, there is a limit around 240 variants with
        parameters that applies to each type definition, but the only
        limit on the number of variants without parameters is the size
        of the native integer (either 31- or 63-bits). This limit arises
        because of the size of the tag byte, and that some of the high
        numbered tags are reserved.
      </p></section><section><h1 id="polymorphic-variants-1">Polymorphic variants</h1><p id="idp11116512">
        Polymorphic variants are more flexible than normal variants when
        writing code, but can be less efficient at runtime. This is
        because there isn't as much static compile-time information
        available to optimise their memory layout. This isn't always the
        case, however. A polymorphic variant without any parameters is
        stored as an unboxed integer and so only takes up one word of
        memory. Unlike normal variants, the integer value is determined
        by apply a hash function to the <span><em>name</em></span> of the
        variant. The hash function isn't exposed directly by the
        compiler, but the <code>type_conv</code> library from Core
        provides an alternative implementation.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;type_conv&quot;</span> <span class="o">;;</span>
<span class="o">#</span> <span class="nn">Pa_type_conv</span><span class="p">.</span><span class="n">hash_variant</span> <span class="s2">&quot;Foo&quot;</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3505894</span>
<span class="o">#</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">magic</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="o">`</span><span class="nc">Foo</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3505894</span>
</pre></div><p id="idp11120112">
        The hash function is designed to give the same results on 32-bit
        and 64-bit architectures, so the memory representation is stable
        across different CPUs and host types.
      </p><p id="idp11120704">
        Polymorphic variants use more memory space when parameters are
        included in the datatype constructors. Normal variants use the
        tag byte to encode the variant value, but this byte is
        insufficient to encode the hashed value for polymoprhic
        variants. Therefore, they must allocate a new block (with tag
        <code>0</code>) and store the value in there instead. This
        means that polymorphic variants with constructors use one word
        of memory more than normal variant constructors.
      </p><p id="idp11122304">
        Another inefficiency is when a polymorphic variant constructor
        has more than one parameter. Normal variants hold parameters as
        a single flat block with multiple fields for each entry, but
        polymorphic variants must adopt a more flexible uniform memory
        representation since they may be re-used in a different context.
        They allocate a tuple block for the parameters that is pointed
        to from the argument field of the variant. Thus, there are three
        additional words for such variants, along with an extra memory
        indirection due to the tuple.
      </p></section><section><h1 id="string-values">String values</h1><p id="idp11124496">
        Strings are standard OCaml blocks with the header size defining
        the size of the string in machine words. The
        <code>String_tag</code> (252) is higher than the
        <code>No_scan_tag</code>, indicating that the contents of
        the block are opaque to the collector. The block contents are
        the contents of the string, with padding bytes to align the
        block on a word boundary.
      </p><div class="highlight"><pre><span class="o">+---------------+----------------+--------+-----------+</span>
<span class="o">|</span> <span class="n">header</span>        <span class="o">|</span> <span class="sc">'a'</span> <span class="sc">'b'</span> <span class="sc">'c'</span> <span class="sc">'d'</span> <span class="sc">'e'</span> <span class="sc">'f'</span> <span class="o">|</span> <span class="k">'</span><span class="err">\</span><span class="nc">O'</span> <span class="k">'</span><span class="err">\</span><span class="mi">1</span><span class="k">'</span> <span class="o">|</span>
<span class="o">+---------------+----------------+--------+-----------+</span>
                <span class="nc">L</span> <span class="n">data</span>                    <span class="nc">L</span> <span class="n">padding</span>
</pre></div><p id="idp11127840">
        On a 32-bit machine, the padding is calculated based on the
        modulo of the string length and word size to ensure the result
        is word-aligned. A 64-bit machine extends the potential padding
        up to 7 bytes instead of 3.
      </p><table><thead><tr><th>
                String length mod 4
              </th><th>
                Padding
              </th></tr></thead><tbody><tr><td>
                0
              </td><td>
<code>00 00 00 03</code>
</td></tr><tr><td>
                1
              </td><td>
<code>00 00 02</code>
</td></tr><tr><td>
                2
              </td><td>
<code>00 01</code>
</td></tr><tr><td>
                3
              </td><td>
<code>00</code>
</td></tr></tbody></table><p id="idp11140112">
        This string representation is a clever way to ensure that the
        string contents are always zero-terminated by the padding word,
        and still compute its length efficiently without scanning the
        whole string. The following formula is used:
      </p><pre id="idp11140784">
number_of_words_in_block * sizeof(word) - last_byte_of_block - 1
</pre><p id="idp11141520">
        The guaranteed NULL-termination comes in handy when passing a
        string to C, but is not relied upon to compute the length from
        OCaml code. Thus, OCaml strings can contain null bytes at any
        point within the string, but care should be taken that any C
        library functions can also cope with this.
      </p></section><section><h1 id="custom-heap-blocks">Custom heap blocks</h1><p id="idp11143472">
        OCaml supports <span><em>custom</em></span> heap blocks via a
        <code>Custom_tag</code> that let the runtime perform
        user-defined operations over OCaml values. A custom block lives
        in the OCaml heap like an ordinary block and can be of whatever
        size the user desires. The <code>Custom_tag</code> (255)
        is higher than <code>No_scan_tag</code> and isn't scanned
        by the garbage collector. This means that it cannot contain any
        OCaml values, but is useful to track pointers into the external
        C heap.
      </p><p id="idp11146912">
        The first word of the data within the custom block is a C
        pointer to a <code>struct</code> of custom operations. The
        custom block cannot have pointers to OCaml blocks and is opaque
        to the garbage collector.
      </p><div class="highlight"><pre><span class="k">struct</span> <span class="n">custom_operations</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">identifier</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">finalize</span><span class="p">)(</span><span class="n">value</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="n">value</span> <span class="n">v1</span><span class="p">,</span> <span class="n">value</span> <span class="n">v2</span><span class="p">);</span>
  <span class="n">intnat</span> <span class="p">(</span><span class="o">*</span><span class="n">hash</span><span class="p">)(</span><span class="n">value</span> <span class="n">v</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">serialize</span><span class="p">)(</span><span class="n">value</span> <span class="n">v</span><span class="p">,</span>
                    <span class="cm">/*out*/</span> <span class="n">uintnat</span> <span class="o">*</span> <span class="n">wsize_32</span> <span class="cm">/*size in bytes*/</span><span class="p">,</span>
                    <span class="cm">/*out*/</span> <span class="n">uintnat</span> <span class="o">*</span> <span class="n">wsize_64</span> <span class="cm">/*size in bytes*/</span><span class="p">);</span>
  <span class="n">uintnat</span> <span class="p">(</span><span class="o">*</span><span class="n">deserialize</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">dst</span><span class="p">);</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare_ext</span><span class="p">)(</span><span class="n">value</span> <span class="n">v1</span><span class="p">,</span> <span class="n">value</span> <span class="n">v2</span><span class="p">);</span>
<span class="p">};</span>
</pre></div><p id="idp11149552">
        The custom operations specify how the runtime should perform
        polymorphic comparison, hashing and binary marshalling. They
        also optionally contain a <span><em>finalizer</em></span> that
        the runtime calls just before the block is garbage collected.
        This finalizer has nothing to do with ordinary OCaml finalizers
        (as created by <code>Gc.finalise</code> and explained in
        <a href="tuning-the-runtime" target="_top">xref</a>). Instead, they are
        used to call C cleanup functions such as
        <code>free</code>.
      </p><p id="idp11152976">
        When a custom block is allocated, you can also specify the
        proportion of &quot;extra-heap resources&quot; consumed by the
        block, which will affect the garbage collector's decision as to
        how much work to do in the next major slice.
        (<span><em>avsm</em></span>: TODO elaborate on this or move to
        the C interface section)
      </p></section></section><section><h1 id="interfacing-with-c">Interfacing with C</h1><p id="idp11155856">
      Now that you understand the runtime structure of the garbage
      collector, you can interface it with C. OCaml defines an
      <code>external</code> keyword that maps OCaml functions to a
      C symbol. When the function is invoked from OCaml, the C function
      will be called with the OCaml function arguments using their
      native <code>value</code> representation. This corresponds
      to the memory layout for OCaml values described earlier.
    </p><section><h1 id="a-hello-world-c-binding">A &quot;Hello World&quot; C binding</h1><p id="idp11159184">
        Let's define a simple &quot;Hello World&quot; C binding to see
        how this works. First create a <code>hello.ml</code> that
        contains the external declaration:
      </p><div class="highlight"><pre><span class="k">external</span> <span class="n">hello_world</span><span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="s2">&quot;caml_hello_world&quot;</span>
<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">hello_world</span> <span class="bp">()</span>
</pre></div><p id="idp11161664">
        If you try to compile this module to an executable now, you
        should receive a linker error:
      </p><pre id="idp11162176">
$ ocamlopt -o hello hello.ml
Undefined symbols for architecture x86_64:
  &quot;_caml_hello_world&quot;, referenced from:
      .L100 in hello.o
      _camlHello in hello.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
File &quot;caml_startup&quot;, line 1:
Error: Error during linking
</pre><p id="idp11163568">
        This is the system linker telling you that there is a missing
        <code>caml_hello_world</code> symbol. We need to provide a
        C file that will implement this function and make it available
        to the linker before it creates a standalone executable. The
        OCaml compiler uses file extensions to determine how to compile
        each file. When it sees a <code>.c</code> extension, it
        passes it to the system C compiler and appends an include
        directory containing the OCaml runtime header files. You can
        find these runtime header files by running
        <code>ocamlc -where</code> and looking under the
        <code>caml/</code> subdirectory.
      </p><p id="idp11167408">
<code>mlvalues.h</code> is the basic header file that all
        OCaml-C bindings need. It is also shared by the garbage
        collector, and defines a few important typedefs early on that
        should be familiar after the earlier explanation about the
        memory representation of OCaml values:
      </p><div class="highlight"><pre><span class="k">typedef</span> <span class="n">intnat</span> <span class="n">value</span><span class="p">;</span>

<span class="cp">#define Is_long(x)   (((x) &amp; 1) != 0)</span>
<span class="cp">#define Is_block(x)  (((x) &amp; 1) == 0)</span>

<span class="cp">#define Val_unit Val_int(0)</span>
</pre></div><p id="idp11169984">
        The <code>value</code> typedef is a memory word that can
        either be an integer if <code>Is_long</code> is true, or a
        heap block if <code>Is_block</code> is true. All of the
        arguments passed to the C bindings will be of type
        <code>value</code>, since this is sufficient to represent
        any valid OCaml value in memory. Let's look at the external
        declaration for <code>hello_world</code> again:
      </p><div class="highlight"><pre><span class="k">external</span> <span class="n">hello_world</span><span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="s2">&quot;caml_hello_world&quot;</span>
</pre></div><p id="idp11175264">
        This external function has a single argument of type
        <code>unit</code>, which is represented as an integer of
        value 0 in memory. Our C function definition of
        <code>caml_hello_world</code> must therefore accept a
        single <code>value</code> parameter and return a
        <code>value</code>. Let's create the
        <code>hello_stubs.c</code> file now that implements this:
      </p><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;caml/mlvalues.h&gt;</span>

<span class="n">CAMLprim</span> <span class="n">value</span>
<span class="nf">caml_hello_world</span><span class="p">(</span><span class="n">value</span> <span class="n">v_unit</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello OCaml World from C!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Val_unit</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><p id="idp11180672">
        You can now recompile the <code>hello</code> binary with
        this additional C file included in the compiler command-line,
        and it should succeed:
      </p><pre id="idp11181936">
$ ocamlopt -o hello hello.ml hello_stubs.c
$ ./hello
Hello OCaml World from C!
</pre><p id="idp11182688">
        You must be <span><em>very</em></span> careful that the value you
        return from the C function corresponds exactly to the memory
        representation of the types you declared earlier in the
        <code>external</code> declaration of the ML file, or else
        heap carnage and corruption will ensure.
      </p><aside class="tip"><h1>
      Activating the debug runtime
      </h1><p id="idp11185216">
        Despite your best efforts, it is easy to introduce a bug into C
        bindings that cause heap invariants to be violated. OCaml
        includes a variant of the runtime library that is compiled with
        debugging symbols, and includes regular memory integrity checks
        upon every garbage collection. Running these often will abort
        the program near the point of corruption and helps track it down
        quickly.
      </p><p id="idp11186064">
        To use this, just recompile with
        <code>-runtime-variant d</code> set:
      </p><pre id="idp11187232">
$ ocamlopt -runtime-variant d -verbose -o hello hello.ml hello_stubs.c
$ ./hello 
### OCaml runtime: debug mode ###
Initial minor heap size: 2048k bytes
Initial major heap size: 992k bytes
Initial space overhead: 80%
Initial max overhead: 500%
Initial heap increment: 992k bytes
Initial allocation policy: 0
Hello OCaml World!
</pre><p id="idp11188240">
        If you get an error that <code>libasmrund.a</code> is not
        found, then this is probably because you're using OCaml 4.00 and
        not 4.01. It's only installed by default in the very latest
        version, which you should be using via the
        <code>4.01.0dev+trunk</code> OPAM switch.
      </p></aside></section><section><h1 id="converting-from-ocaml-values-in-c">Converting from OCaml values in C</h1><p id="idp11191712">
        The earlier hello world example is rather basic and only uses
        <code>unit</code> types. Let's extend the signature to
        take a couple of <code>int</code> arguments instead of a
        single <code>unit</code> so that we can send more useful
        data between OCaml and C:
      </p><div class="highlight"><pre><span class="k">external</span> <span class="n">add_numbers</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="s2">&quot;caml_add_numbers&quot;</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;From OCaml: %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">add_numbers</span> <span class="mi">10</span> <span class="mi">15</span><span class="o">)</span>
</pre></div><p id="idp11195536">
        The <code>add_numbers</code> external function now takes
        two arguments, and returns an integer instead of a simple
        <code>unit</code>. The updated C stub looks like this:
      </p><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;caml/mlvalues.h&gt;</span>

<span class="n">CAMLprim</span> <span class="n">value</span>
<span class="nf">caml_add_numbers</span><span class="p">(</span><span class="n">value</span> <span class="n">v_arg1</span><span class="p">,</span> <span class="n">value</span> <span class="n">v_arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">Int_val</span><span class="p">(</span><span class="n">v_arg1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">Int_val</span><span class="p">(</span><span class="n">v_arg2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;From C:     %d + %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Val_int</span><span class="p">(</span><span class="n">v1</span><span class="o">+</span><span class="n">v2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p id="idp11198816">
        OCaml passes the integers to <code>caml_add_numbers</code>
        as <code>value</code> types, so the binding uses the
        <code>Int_val</code> macro to convert them into local
        stack variables. The <code>Int_val</code> macro converts a
        <code>value</code> to an integer by removing the tag bit.
        The C integers are then added together and the result
        <code>value</code> is constructed by applying the
        <code>Val_int</code> macro, which takes a C integer and
        tags it into becoming an OCaml <code>value</code>. When
        you compile and run this version of the code, you should see
        this output:
      </p><pre id="idp11205376">
$ ./hello 
From C:     10 + 15
From OCaml: 25
</pre><p id="idp11206096">
        You should keep an eye out for warnings from your compiler which
        often indicate that you've forgotten to correctly convert a
        <code>value</code>. For example, try a broken version of
        the previous binding:
      </p><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;caml/mlvalues.h&gt;</span>

<span class="n">CAMLprim</span> <span class="n">value</span>
<span class="nf">caml_add_numbers</span><span class="p">(</span><span class="n">value</span> <span class="n">v_arg1</span><span class="p">,</span> <span class="n">value</span> <span class="n">v_arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;From C:     %d + %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v_arg1</span><span class="p">,</span> <span class="n">v_arg2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Val_int</span><span class="p">(</span><span class="n">v_arg1</span> <span class="o">+</span> <span class="n">v_arg2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p id="idp11208624">
        The compiler will now complain of invalid format strings when
        you compile this:
      </p><pre id="idp11209120">
$ ocamlopt -o hello -ccopt -Wall hello_stubs.c hello.ml
hello_stubs.c: In function caml_add_numbers:
hello_stubs.c:7: warning: format %d expects type int, but argument 2 has type value
hello_stubs.c:7: warning: format %d expects type int, but argument 3 has type value
hello_stubs.c:7: warning: format %d expects type int, but argument 2 has type value
hello_stubs.c:7: warning: format %d expects type int, but argument 3 has type value
$ ./hello 
From C:     21 + 31
From OCaml: 26
</pre><p id="idp11210272">
        Notice that both the input and output integers are incorrect in
        the output, since they still have their tag bits set when being
        added in the C code. Don't depend on the good graces of your C
        compiler to always spot such errors though. It's also invalid to
        add two <code>value</code>s together without converting
        them into native C type, but the C compiler can't warn about
        this and the result is silently incorrect. It's good practise to
        immediately convert arguments to local C stack variables as
        early as possible, so you don't get the types mixed up deep into
        the C function.
      </p><p id="idp11212016">
        OCaml provides macros to convert to and from all the basic OCaml
        runtime values and C types, of the form
        <code>to_from</code>. For example
        <code>Val_long</code> means &quot;Value from long&quot;,
        and <code>Long_val</code> means &quot;Long from
        value&quot;. The table below summarises the macros to extract
        various C types from OCaml <code>values</code> for 64-bit
        architectures. Note that OCaml doesn't support a
        single-precision float, so these are always double-precision.
      </p><p id="idp11215920">
        TODO: buggy markdown below in table rendering
      </p><table><thead><tr><th>
                Macro
              </th><th>
                OCaml Type
              </th><th>
                C type
              </th></tr></thead><tbody><tr><td>
<code>Long_val</code>
</td><td>
<code>int</code> `
              </td><td>
                long`
              </td></tr><tr><td>
<code>Int_val</code>
</td><td>
<code>int</code> `
              </td><td>
                int`
              </td></tr><tr><td>
<code>Unsigned_long_val</code>
</td><td>
<code>int</code> `
              </td><td>
                unsigned long`
              </td></tr><tr><td>
<code>Unsigned_int_val</code>
</td><td>
<code>int</code> `
              </td><td>
                unsigned int`
              </td></tr><tr><td>
<code>Bool_val</code>
</td><td>
<code>bool</code> `
              </td><td>
                int`
              </td></tr><tr><td>
<code>Double_val</code>
</td><td>
<code>float</code> `
              </td><td>
                double`
              </td></tr><tr><td>
<code>String_val</code>
</td><td>
<code>string</code> `
              </td><td>
                string`
              </td></tr><tr><td>
<code>Nativeint_val</code>
</td><td>
<code>Nativeint.t</code> `
              </td><td>
                long`
              </td></tr><tr><td>
<code>Int32_val</code>
</td><td>
<code>Int32.t</code> `
              </td><td>
                long`
              </td></tr><tr><td>
<code>Int64_val</code>
</td><td>
<code>Int64.t</code> `
              </td><td>
                unsigned long`
              </td></tr></tbody></table></section><section><h1 id="constructing-ocaml-values-from-c">Constructing OCaml values from C</h1><p id="idp11252496">
        Building OCaml values to return from C is a little more
        involved, since we must ensure that any OCaml allocations aren't
        immediately cleaned up by the garbage collector before they have
        been registered as live values. Luckily, OCaml provides some
        more macros to make this easier to enforce. Let's extend our
        earlier example to return a tuple of integers instead of just
        the result.
      </p><div class="highlight"><pre><span class="k">external</span> <span class="n">add_numbers</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">int32</span> <span class="o">=</span> <span class="s2">&quot;caml_add_numbers&quot;</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">,</span><span class="n">v</span><span class="o">)</span> <span class="o">=</span> <span class="n">add_numbers</span> <span class="mi">10</span> <span class="mi">15</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;From OCaml: %d+%d=%ld</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">l</span> <span class="n">r</span> <span class="n">v</span>
</pre></div><p id="idp11254640">
        The <code>add_numbers</code> external now returns a more
        complex data type that requires allocating an OCaml tuple from
        within the C binding, storing the results within the tuple, and
        returning that tuple. The contents of the tuple are also a mix
        of immediate values (the two first <code>int</code> fields
        in the tuple) and the last boxed <code>int32</code> that
        also needs to be allocated on the OCaml heap.
      </p><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;caml/memory.h&gt;</span>
<span class="cp">#include &lt;caml/alloc.h&gt;</span>

<span class="n">CAMLprim</span> <span class="n">value</span>
<span class="nf">caml_add_numbers</span><span class="p">(</span><span class="n">value</span> <span class="n">v_arg1</span><span class="p">,</span> <span class="n">value</span> <span class="n">v_arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CAMLparam2</span><span class="p">(</span><span class="n">v_arg1</span><span class="p">,</span> <span class="n">v_arg2</span><span class="p">);</span>
  <span class="n">CAMLlocal1</span><span class="p">(</span><span class="n">v_res</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">Int_val</span><span class="p">(</span><span class="n">v_arg1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">Int_val</span><span class="p">(</span><span class="n">v_arg2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;From C:     %d+%d=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">v1</span><span class="o">+</span><span class="n">v2</span><span class="p">));</span>
  <span class="n">v_res</span> <span class="o">=</span> <span class="n">caml_alloc_tuple</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">Store_field</span><span class="p">(</span><span class="n">v_res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Val_int</span><span class="p">(</span><span class="n">v1</span><span class="p">));</span>
  <span class="n">Store_field</span><span class="p">(</span><span class="n">v_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Val_int</span><span class="p">(</span><span class="n">v2</span><span class="p">));</span>
  <span class="n">Store_field</span><span class="p">(</span><span class="n">v_res</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">caml_copy_int32</span><span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">));</span>
  <span class="n">CAMLreturn</span><span class="p">(</span><span class="n">v_res</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p id="idp11259088">
        The stub now uses several new macros that are all defined in
        <code>caml/memory.h</code>. The
        <code>CAMLparam</code> macro registers its parameters as
        <span><em>local roots</em></span> with the garbage collector.
        This ensures that if the garbage collector is triggered during
        the C binding, it will not relocate or free the value we just
        allocated. We also need to allocate a tuple to store the result.
        This is declared with the <code>CAMLlocal</code> macro,
        and returned via <code>CAMLreturn</code>. For many simple
        bindings, you can just follow the simple rule of replacing the C
        <code>return</code> with <code>CAMLreturn</code> and
        starting every function with <code>CAMLparam</code> and
        <code>CAMLlocal</code>, and not have to worry about the
        garbage collector.
      </p><aside class="note"><h1>
      FFI rule: Use CAMLparam and
      CAMLreturn for OCaml values
      </h1><p id="idp11268368">
        A function that has parameters or local variables of type value
        must begin with a call to one of the
        <code>CAMLparam</code> macros and return with
        <code>CAMLreturn</code>, <code>CAMLreturn0</code>,
        or <code>CAMLreturnT</code>. Local variables of type
        <code>value</code> must be declared with one of the
        <code>CAMLlocal</code> macros. Arrays of values are
        declared with <code>CAMLlocalN</code>. These macros must
        be used at the beginning of the function, not in a nested block.
      </p></aside><p id="idp11274208">
        The tuple is then allocated via
        <code>caml_alloc_tuple</code>, with the number of fields
        representing the size of the tuple. This must
        <span><em>immediately</em></span> be followed by the
        <code>Store_field</code> macros to set the newly allocated
        tuple to sensible values. In our example, we assign the first
        two fields to the local integers. The <code>int32</code>
        requires another allocation, and
        <code>caml_copy_int32</code> is used which copies a C
        <code>int32</code> into the correspondig OCaml
        <code>value</code>. Once the tuple has been set, the
        function returns via <code>CAMLreturn</code>, which frees
        up the local roots that we registered at the beginning of the
        function.
      </p><aside class="note"><h1>
      FFI rule: Use Store_field to assign to tuples,
      records and arrays
      </h1><p id="idp11282000">
        Assignments to the fields of structured blocks must be done with
        the <code>Store_field</code> macro (for normal blocks) or
        <code>Store_double_field</code> macro (for arrays and
        records of floating-point numbers). Other assignments must not
        use <code>Store_field</code> nor
        <code>Store_double_field</code>.
      </p></aside><p id="idp11285600">
        The <code>caml/alloc.h</code> header file lists all of the
        functions that allocate OCaml values.
      </p><table><thead><tr><th>
                Function name
              </th><th>
                Argument
              </th><th>
                OCaml return type
              </th></tr></thead><tbody><tr><td>
<code>caml_alloc_tuple (&lt;len&gt;)</code>
</td><td>
                Number of fields
              </td><td>
                Tuple or record
              </td></tr><tr><td>
<code>caml_alloc_string (&lt;len&gt;)</code>
</td><td>
                Size in bytes
              </td><td>
<code>string</code>
</td></tr><tr><td>
<code>caml_copy_string (char *)</code>
</td><td>
                Pointer to a C string
              </td><td>
<code>string</code>
</td></tr><tr><td>
<code>caml_copy_string_array (char **)</code>
</td><td>
                Pointer to array of C strings
              </td><td>
<code>string array</code>
</td></tr><tr><td>
<code>caml_copy_double (double)</code>
</td><td>
                C <code>double</code> value
              </td><td>
<code>double</code>
</td></tr><tr><td>
<code>caml_copy_int32 (int32)</code>
</td><td>
                32-bit C integer
              </td><td>
<code>int32</code>
</td></tr><tr><td>
                `caml_copy_int64 (int64);
              </td><td>
                64-bit C integer
              </td><td>
<code>int64</code>
</td></tr><tr><td>
                `caml_copy_nativeint (intnat);
              </td><td>
                native C integer size (<code>long</code>)
              </td><td>
<code>Nativeint.t</code>
</td></tr></tbody></table><p id="idp11315376">
        Tuples and records both have the same memory representation,
        with the same tag value (<code>0</code>). This means that
        you can change how you map these fields into OCaml, without
        having to modify the C bindings. For example, our earlier
        integer addition example can also look like this:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">v1</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="n">v2</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="n">res</span><span class="o">:</span> <span class="n">int32</span><span class="o">;</span>
<span class="o">}</span>
 
<span class="k">external</span> <span class="n">add_numbers</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;caml_add_numbers&quot;</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">add_numbers</span> <span class="mi">10</span> <span class="mi">15</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;From OCaml: %d+%d=%ld</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">v</span><span class="o">.</span><span class="n">v1</span> <span class="n">v</span><span class="o">.</span><span class="n">v2</span> <span class="n">v</span><span class="o">.</span><span class="n">res</span>
</pre></div><p id="idp11318160">
        Records are never rearranged in memory, so the fields will
        appear in the same order they are declared.
      </p><aside class="note"><h1>
      Faster bindings for zero-allocation functions
      </h1><p id="idp11319408">
        TODO Talk about &quot;alloc&quot; and &quot;float&quot;
        qualifiers to <code>external</code>
</p></aside></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt03.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="parsing-binary-protocols-with-bigarray.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>