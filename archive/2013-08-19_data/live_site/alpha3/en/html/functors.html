<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 7. Functors / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha3',
                        page: 'functors.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">3. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">4. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">5. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">6. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html" class="here">7. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">9. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 7. Functors</h1>
                
                

    <p id="idp8172336">
    Up until now, we've seen OCaml's module system play an important but
    limited role. In particular, we've seen them as a mechanism for
    organizing code into units with specified interfaces. But modules
    can do much more than that, acting as a powerful toolset for
    building generic code and structuring large-scale systems. Much of
    that power comes from functors.
  </p><p id="idp8173120">
    Functors are, roughly speaking, functions from modules to modules,
    and they can be used to solve a variety of code-structuring
    problems, including:
  </p><ul><li><p id="idp8174192">
<span><em>Dependency injection</em></span>, or making the
        implementations of some components of a system swappable. This
        is particularly useful when you want to mock up parts of your
        system for testing and simulation purposes.
      </p></li><li><p id="idp8175568">
<span><em>Auto-extension of modules</em></span>. Sometimes, there
        is some functionality that you want to build in a standard way
        for different types, in each case based on a some piece of
        type-specific logic. For example, you might want to add a slew
        of comparison operators derived from a base comparison function.
        To do this by hand would require a lot of repetitive code for
        each type, but functors let you write this logic just once and
        apply it to many different types.
      </p></li><li><p id="idp8177232">
<span><em>Instantiating modules with state</em></span>. Modules
        can contain mutable state, and that means that you'll
        occasionally want to have multiple instantiations of a
        particular module, each with its own separate and independent
        mutable state. Functors let you automate the construction of
        such modules.
      </p></li></ul><section><h1 id="a-trivial-example">A trivial example</h1><p id="idp8179456">
      We'll start by considering the simplest possible example: a
      functor for incrementing an integer.
    </p><p id="idp8179968">
      More precisely, we'll create a functor that takes a module
      containing a single integer variable <code>x</code>, and
      returns a new module with <code>x</code> incremented by one.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Increment</span> <span class="o">(</span><span class="nc">M</span><span class="o">:</span><span class="nc">X_int</span><span class="o">)</span> <span class="o">:</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Increment</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">X_int</span>
</pre></div><p id="idp8183008">
      One thing that immediately jumps out about functors is that
      they're considerably more heavyweight syntactically than ordinary
      functions. For one thing, functors require explicit (module) type
      annotations, which ordinary functions do not. Here, we've
      specified the module type <code>X_int</code> for both the
      input and output of the functor. Technically, only the type on the
      input is mandatory, although in practice, one often specifies
      both.
    </p><p id="idp8184528">
      The following shows what happens when we omit the module type for
      the output of the functor.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Increment</span> <span class="o">(</span><span class="nc">M</span><span class="o">:</span><span class="nc">X_int</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Increment</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div><p id="idp8186144">
      We can see that the inferred module type of the output is now
      written out explicitly, rather than being a reference to the named
      signature <code>X_int</code>.
    </p><p id="idp8187328">
      We can now use <code>Increment</code> to define new modules.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Three</span> <span class="o">=</span> <span class="k">struct</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">end</span><span class="o">;;</span>
  <span class="k">module</span> <span class="nc">Three</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Four</span> <span class="o">=</span> <span class="nc">Increment</span><span class="o">(</span><span class="nc">Three</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Four</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="nn">Four</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="nn">Three</span><span class="p">.</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div><p id="idp8189392">
      In this case, we applied <code>Increment</code> to a module
      whose signature is exactly equal to <code>X_int</code>. But
      we can apply <code>Increment</code> to any module that
      satisfies the interface <code>X_int</code>, in the same way
      that a the contents of an <code>ml</code> file can satisfy
      the <code>mli</code>. That means that the module type can
      omit some information available in the module, either by dropping
      fields or by leaving some fields abstract. Here's an example:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Three_and_more</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;three&quot;</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Three_and_more</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">val</span> <span class="n">x_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Four</span> <span class="o">=</span> <span class="nc">Increment</span><span class="o">(</span><span class="nc">Three_and_more</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Four</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div></section><section><h1 id="a-bigger-example-computing-with-intervals">A bigger example: computing with intervals</h1><p id="idp8196160">
      Let's now consider a more realistic example of how to use
      functors: a library for computing with intervals. This library
      will be functorized over the type of the endpoints of the
      intervals and the ordering of those endpoints.
    </p><p id="idp8196816">
      First we'll define a module type that captures the information
      we'll need about the endpoint type. This interface, which we'll
      call <code>Comparable</code>, contains just two things: a
      comparison function, and the type of the values to be compared.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Comparable</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Comparable</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">type</span> <span class="n">t</span> <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div><p id="idp8199392">
      The comparison function follows the standard OCaml idiom for such
      functions, returning <code>0</code> if the two elements are
      equal, a positive number if the first element is larger than the
      second, and a negative number if the first element is smaller than
      the second. Thus, we could rewrite the standard comparison
      functions on top of <code>compare</code> as shown below.
    </p><div class="highlight"><pre><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span>     <span class="c">(* x &lt; y *)</span>
<span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c">(* x = y *)</span>
<span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span>     <span class="c">(* x &gt; y *)</span>
</pre></div><p id="idp8202448">
      The functor for creating the interval module is shown below. We
      represent an interval with a variant type, which is either
      <code>Empty</code> or <code>Interval (x,y)</code>,
      where <code>x</code> and <code>y</code> are the bounds
      of the interval.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nc">Empty</span>

    <span class="k">let</span> <span class="n">create</span> <span class="n">low</span> <span class="n">high</span> <span class="o">=</span>
      <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">low</span> <span class="n">high</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Empty</span>
      <span class="k">else</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">)</span>

    <span class="k">let</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">true</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

    <span class="k">let</span> <span class="n">contains</span> <span class="n">t</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">false</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">h</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="mi">0</span>

    <span class="k">let</span> <span class="n">intersect</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">min</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">max</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">t1</span><span class="o">,</span><span class="n">t2</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_</span> <span class="o">|</span> <span class="o">_,</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="nc">Empty</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l1</span><span class="o">,</span><span class="n">h1</span><span class="o">),</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l2</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="n">create</span> <span class="o">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span> <span class="o">(</span><span class="n">min</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span>

  <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="nc">Empty</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp8208256">
      We can instantiate the functor by applying it to a module with the
      right signature. In the following, we provide the functor input as
      an anonymous module.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span>
    <span class="nc">Make_interval</span><span class="o">(</span><span class="k">struct</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
      <span class="k">let</span> <span class="n">compare</span> <span class="o">=</span> <span class="nn">Int</span><span class="p">.</span><span class="n">compare</span>
    <span class="k">end</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Empty</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp8210128">
      When we choose our interfaces that are aligned with the standards
      of our libraries, we don't need to construct a custom module to
      feed to the functor. In this case, for example, we can directly
      use the <code>Int</code> or <code>String</code>
      modules provided by Core.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">String_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="o">;;</span>
</pre></div><p id="idp8212976">
      This works because many modules in Core, including
      <code>Int</code> and <code>String</code>, satisfy an
      extended version of the <code>Comparable</code> signature
      described above. Standardized signatures are generally good
      practice, both because they makes functors easier to use, and
      because they make the codebase generally easier to navigate.
    </p><p id="idp8215552">
      Now we can use the newly defined <code>Int_interval</code>
      module like any ordinary module.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i1</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">8</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i1</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">i2</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">10</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i2</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">intersect</span> <span class="n">i1</span> <span class="n">i2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
</pre></div><p id="idp8217712">
      This design gives us the freedom to use any comparison function we
      want for comparing the endpoints. We could, for example, create a
      type of int interval with the order of the comparison reversed, as
      follows:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Rev_int_interval</span> <span class="o">=</span>
    <span class="nc">Make_interval</span><span class="o">(</span><span class="k">struct</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
      <span class="k">let</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Int</span><span class="p">.</span><span class="n">compare</span> <span class="n">y</span> <span class="n">x</span>
    <span class="k">end</span><span class="o">);;</span>
</pre></div><p id="idp8219360">
      The behavior of <code>Rev_int_interval</code> is of course
      different from <code>Int_interval</code>, as we can see
      below.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">interval</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">interval</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Empty</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">rev_interval</span> <span class="o">=</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">rev_interval</span> <span class="o">:</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div><p id="idp8222096">
      Importantly, <code>Rev_int_interval.t</code> is a different
      type than <code>Int_interval.t</code>, even though its
      physical representation is the same. Indeed, the type system will
      prevent us from confusing them.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">rev_interval</span> <span class="mi">3</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">22</span><span class="o">-</span><span class="mi">34</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">rev_interval</span> <span class="mi">3</span><span class="o">;;</span>
                        <span class="o">^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">t</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">).</span><span class="n">t</span>
</pre></div><p id="idp8225040">
      This is important, because confusing the two kinds of intervals
      would be a semantic error, and it's an easy one to make. The
      ability of functors to mint new types is a useful trick that comes
      up a lot.
    </p><section><h1 id="making-the-functor-abstract">Making the functor abstract</h1><p id="idp8226544">
        There's a problem with <code>Make_interval</code>. The
        code we wrote depends on the invariant that the upper bound of
        an interval is greater than its lower bound, but that invariant
        can be violated. The invariant is enforced by the create
        function, but because <code>Interval.t</code> is not
        abstract, we can bypass the <code>create</code> function.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span> <span class="c">(* going through create *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Empty</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span> <span class="c">(* bypassing create *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div><p id="idp8230144">
        To make <code>Int_interval.t</code> abstract, we need to
        apply an interface to the output of the
        <code>Make_interval</code>. Here's an explicit interface
        that we can use for that purpose.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Interval_intf</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">t</span>
   <span class="k">type</span> <span class="n">endpoint</span>
   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp8233264">
        This interface includes the type <code>endpoint</code> to
        represent the type of the endpoints of the interval. Given this
        interface, we can redo our definition of
        <code>Make_interval</code>. Notice that we added the type
        <code>endpoint</code> to the implementation of the module
        to make the implementation match
        <code>Interval_intf</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">....</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Interval_intf</span>
</pre></div></section><section><h1 id="sharing-constraints">Sharing constraints</h1><p id="idp8238784">
        The resulting module is abstract, but unfortunately, it's too
        abstract. In particular, we haven't exposed the type
        <code>endpoint</code>, which means that we can't even
        construct an interval anymore.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">:</span> <span class="nc">Interval_intf</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">20</span><span class="o">-</span><span class="mi">21</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
                      <span class="o">^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="nn">Int_interval</span><span class="p">.</span><span class="n">endpoint</span>
</pre></div><p id="idp8241216">
        To fix this, we need to expose the fact that
        <code>endpoint</code> is equal to <code>Int.t</code>
        (or more generally, <code>Endpoint.t</code>, where
        <code>Endpoint</code> is the argument to the functor). One
        way of doing this is through a <span><em>sharing
        constraint</em></span>, which allows you to tell the compiler to
        expose the fact that a given type is equal to some other type.
        The syntax for a sharing constraint on a module type is as
        follows.
      </p><div class="highlight"><pre><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">s</span> <span class="o">=</span> <span class="n">t</span>
</pre></div><p id="idp8245744">
        where <code>S</code> is a module type,
        <code>s</code> is a type inside of <code>S</code>,
        and <code>t</code> is a type defined outside of
        <code>S</code>. The result of this expression is a new
        signature that's been modified so that it exposes the fact that
        <code>s</code> is equal to <code>t</code>. We can
        use a sharing constraint to create a specialized version of
        <code>Interval_intf</code> for integer intervals.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="kt">int</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp8252592">
        And we can also use it in the context of a functor, where the
        right-hand side of the sharing constraint is an element of the
        functor argument. Thus, we expose an equality between a type in
        the output of the functor (in this case, the type
        <code>endpoint</code>) and a type in its input
        (<code>Endpoint.t</code>).
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
      <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">...</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp8256000">
        So now, the interface is as it was, except that
        <code>endpoint</code> is now known to be equal to
        <code>Endpoint.t</code>. As a result of that type
        equality, we can now do things like construct intervals again.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">i</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div></section><section><h1 id="destructive-substitution">Destructive substitution</h1><p id="idp8259856">
        Sharing constraints basically do the job, but they have some
        downsides. In particular, we've now been stuck with the useless
        type declaration of <code>endpoint</code> that clutters up
        both the interface and the implementation. A better solution
        would be to modify the <code>Interval_intf</code>
        signature by replacing <code>endpoint</code> with
        <code>Endpoint.t</code> everywhere it shows up, and
        deleting the definition of <code>endpoint</code> from the
        signature. We can do just this using what's called
        <span><em>destructive substitution</em></span>. Here's the basic
        syntax.
      </p><div class="highlight"><pre><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">t</span>
</pre></div><p id="idp8265104">
        The following shows how we could use this with
        <code>Make_interval</code>.
      </p><p id="idp8266192">
        Here's an example of what we get if we use destructive
        substitution to specialize the <code>Interval_intf</code>
        interface to integer intervals.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp8268496">
        There's now no mention of n <code>endpoint</code>, all
        occurrences of that type having been replaced by
        <code>int</code>. As with sharing constraints, we can also
        use this in the context of a functor.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
    <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">....</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp8271728">
        The interface is precisely what we want, and we didn't need to
        define the <code>endpoint</code> type alias in the body of
        the module. If we instantiate this module, we'll see that it
        works properly: we can construct new intervals, but
        <code>t</code> is abstract, and so we can't directly
        access the constructors and violate the invariants of the data
        structure.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">);;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">27</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span>
  <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="n">constructor</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span>
</pre></div></section><section><h1 id="using-multiple-interfaces">Using multiple interfaces</h1><p id="idp8276384">
        Another feature that we might want for our interval module is
        the ability to serialize the type, in particular, by converting
        to s-expressions. If we simply invoke the
        <code>sexplib</code> macros by adding
        <code>with sexp</code> to the definition of
        <code>t</code>, though, we'll get an error:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
    <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nc">Empty</span>
    <span class="k">with</span> <span class="n">sexp</span>

    <span class="o">....</span>

  <span class="k">end</span> <span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">120</span><span class="o">-</span><span class="mi">123</span><span class="o">:</span>
        <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
                               <span class="o">^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="n">value</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t_of_sexp</span>
</pre></div><p id="idp8280112">
        The problem is that <code>with sexp</code> adds code for
        defining the s-expression converters, and that code assumes that
        <code>Endpoint</code> has the appropriate sexp-conversion
        functions for <code>Endpoint.t</code>. But all we know
        about <code>Endpoint</code> is that it satisfies the
        <code>Comparable</code> interface, which doesn't say
        anything about s-expressions.
      </p><p id="idp8283904">
        Happily, Core comes with a built in interface for just this
        purpose called <code>Sexpable</code>, which is defined as
        follows:
      </p><div class="highlight"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">Sexpable</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
  <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span>
</pre></div><p id="idp8286032">
        We can modify <code>Make_interval</code> to use the
        <code>Sexpable</code> interface, for both its input and
        its output. Note the use of destructive substitution to combine
        multiple signatures together. This is important because it stops
        the <code>type t</code>'s from the different signatures
        from interfering with each other.
      </p><p id="idp8288592">
        Also note that we have been careful to override the
        sexp-converter here to ensure that the data structures
        invariants are still maintained when reading in from an
        s-expression.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Interval_intf_with_sexp</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">t</span>
   <span class="k">include</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
   <span class="k">include</span> <span class="nc">Sexpable</span>      <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">include</span> <span class="nc">Comparable</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
    <span class="k">include</span> <span class="nc">Sexpable</span>   <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Interval_intf_with_sexp</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="k">struct</span>

      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
               <span class="o">|</span> <span class="nc">Empty</span>
      <span class="k">with</span> <span class="n">sexp</span>

      <span class="k">let</span> <span class="n">create</span> <span class="n">low</span> <span class="n">high</span> <span class="o">=</span>
         <span class="o">...</span>

      <span class="c">(* put a wrapper round the auto-generated sexp_of_t to enforce</span>
<span class="c">         the invariants of the data structure *)</span>
      <span class="k">let</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="nc">Empty</span>
        <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">create</span> <span class="n">x</span> <span class="n">y</span>

      <span class="o">....</span>

     <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span>
    <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="k">sig</span>
           <span class="k">type</span> <span class="n">t</span>
           <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
           <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
           <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
         <span class="k">end</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
      <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp8291472">
        And now, we can use that sexp-converter in the ordinary way:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">(</span><span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Interval</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">(</span><span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexplib</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Empty</span>
</pre></div></section></section><section><h1 id="extending-modules">Extending modules</h1><p id="idp8294176">
      Another common use of functors is to generate type-specific
      functionality for a given module in a standardized way. Let's see
      how this works in the context of a functional queue, which is just
      a functional version of a FIFO (first-in, first-out) queue. Being
      functional, operations on the queue return new queues, rather than
      modifying the queues that were passed in.
    </p><p id="idp8294992">
      Here's a reasonable mli
    </p><div class="highlight"><pre><span class="c">(* file: fqueue.mli *)</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">enqueue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

<span class="c">(** [dequeue q] returns None if the [q] is empty *)</span>
<span class="k">val</span> <span class="n">dequeue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="n">option</span>

<span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>
</pre></div><p id="idp8296720">
      Now let's implement <code>Fqueue</code>. A standard trick is
      for the <code>Fqueue</code> to maintain an input and an
      output list, so that one can efficiently
      <code>enqueue</code> on the first list, and can efficiently
      dequeue from the out list. If you attempt to dequeue when the
      output list is empty, the input list is reversed and becomes the
      new output list. Here's an implementation that uses that trick.
    </p><div class="highlight"><pre><span class="c">(* file: fqueue.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="o">(</span><span class="bp">[]</span><span class="o">,</span><span class="bp">[]</span><span class="o">)</span>

<span class="k">let</span> <span class="n">enqueue</span> <span class="o">(</span><span class="n">l1</span><span class="o">,</span><span class="n">l2</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l1</span><span class="o">,</span><span class="n">l2</span><span class="o">)</span>

<span class="k">let</span> <span class="n">dequeue</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">out_list</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">tl</span><span class="o">))</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="bp">[]</span><span class="o">,</span> <span class="n">tl</span><span class="o">))</span>

<span class="k">let</span> <span class="n">fold</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span>
    <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span><span class="o">)</span>
</pre></div><p id="idp8301296">
      One problem with our <code>Fqueue</code> is that the
      interface is quite skeletal. There are lots of useful helper
      functions that one might want that aren't there. For example, for
      lists we have <code>List.iter</code> which runs a function
      on each node; and a <code>List.find</code> that finds the
      first element on the list that matches a given predicate. Such
      helper functions come up for pretty much every container type, and
      implementing them over and over is a bit of a dull and repetitive
      affair.
    </p><p id="idp8304016">
      As it happens, many of these helper functions can be derived
      mechanically from just the fold function we already implemented.
      Rather than write all of these helper functions by hand for every
      new container type, we can instead use a functor that will let us
      add this functionality to any container that has a
      <code>fold</code> function.
    </p><p id="idp8305392">
      We'll create a new module, <code>Foldable</code> that
      automates the process of adding helper functions to a
      fold-supporting container. As you can see,
      <code>Foldable</code> contains a module signature
      <code>S</code> which defines the signature that is required
      to support folding; and a functor <code>Extend</code> that
      allows one to extend any module that matches
      <code>Foldable.S</code>.
    </p><div class="highlight"><pre><span class="c">(* file: foldable.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>
<span class="k">end</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">Extension</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">iter</span>    <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">length</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">count</span>   <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">for_all</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">val</span> <span class="n">exists</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
<span class="k">end</span>

<span class="c">(* For extending a Foldable module *)</span>
<span class="k">module</span> <span class="nc">Extend</span><span class="o">(</span><span class="nc">Arg</span> <span class="o">:</span> <span class="nc">S</span><span class="o">)</span>
  <span class="o">:</span> <span class="nc">Extension</span> <span class="k">with</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Arg</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="k">open</span> <span class="nc">Arg</span>

  <span class="k">let</span> <span class="n">iter</span> <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">()</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="bp">()</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">length</span> <span class="n">t</span> <span class="o">=</span>
    <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span>  <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">count</span> <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span>  <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">count</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count</span> <span class="o">+</span> <span class="k">if</span> <span class="n">f</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">exception</span> <span class="nc">Short_circuit</span>

  <span class="k">let</span> <span class="n">for_all</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">try</span> <span class="n">iter</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">not</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="k">then</span> <span class="k">raise</span> <span class="nc">Short_circuit</span><span class="o">);</span> <span class="bp">true</span>
    <span class="k">with</span> <span class="nc">Short_circuit</span> <span class="o">-&gt;</span> <span class="bp">false</span>

  <span class="k">let</span> <span class="n">exists</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">try</span> <span class="n">iter</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">x</span> <span class="k">then</span> <span class="k">raise</span> <span class="nc">Short_circuit</span><span class="o">);</span> <span class="bp">false</span>
    <span class="k">with</span> <span class="nc">Short_circuit</span> <span class="o">-&gt;</span> <span class="bp">true</span>
<span class="k">end</span>
</pre></div><p id="idp8311504">
      Now we can apply this to <code>Fqueue</code>. We can rewrite
      the interface of <code>Fqueue</code> as follows.
    </p><div class="highlight"><pre><span class="c">(* file: fqueue.mli *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">enqueue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">dequeue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>

<span class="k">include</span> <span class="nn">Foldable</span><span class="p">.</span><span class="nc">Extension</span> <span class="k">with</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
</pre></div><p id="idp8314384">
      In order to apply the functor, we'll put the definition of
      <code>Fqueue</code> in a sub-module called
      <code>T</code>, and then call
      <code>Foldable.Extend</code> on <code>T</code>.
    </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">module</span> <span class="nc">T</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>

  <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">,</span><span class="bp">[]</span>

  <span class="k">let</span> <span class="n">enqueue</span> <span class="o">(</span><span class="n">l1</span><span class="o">,</span><span class="n">l2</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span>
    <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l1</span><span class="o">,</span><span class="n">l2</span><span class="o">)</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">dequeue</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">out_list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">tl</span><span class="o">))</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">dequeue</span> <span class="o">(</span><span class="bp">[]</span><span class="o">,</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">fold</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span>
      <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span><span class="o">)</span>
<span class="k">end</span>
<span class="k">include</span> <span class="nc">T</span>
<span class="k">include</span> <span class="nn">Foldable</span><span class="p">.</span><span class="nc">Extend</span><span class="o">(</span><span class="nc">T</span><span class="o">)</span>
</pre></div><p id="idp8319472">
      This pattern comes up quite a bit in Core, and is used to for a
      variety of purposes.
    </p><ul><li><p id="idp8320480">
          Adding comparison-based data structures like maps and sets,
          based on the <code>Comparable</code> interface.
        </p></li><li><p id="idp8321984">
          Adding hash-based data structures like hash sets and hash
          heaps.
        </p></li><li><p id="idp8322864">
          Support for so-called monadic libraries, like the ones
          discussed in <a href="error-handling.html">Chapter 5, <i>Error Handling</i></a> and
          <a href="">???</a>.
          Here, the functor is used to provide a collection of standard
          helper functions based on the core <code>bind</code> and
          <code>return</code> operators.
        </p></li></ul></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="files-modules-and-programs.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="imperative-programming-1.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>