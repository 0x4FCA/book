<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 6. Files, Modules and Programs / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha3',
                        page: 'files\u002Dmodules\u002Dand\u002Dprograms.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">3. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">4. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">5. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html" class="here">6. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html">7. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="object-oriented-programming.html">9. Object Oriented Programming</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 6. Files, Modules and Programs</h1>
                
                

    <p id="idp7978192">
    We've so far experienced OCaml largely through the toplevel. As you
    move from exercises to real-world programs, you'll need to leave the
    toplevel behind and start building programs from files. Files are
    more than just a convenient way to store and manage your code; in
    OCaml, they also act as boundaries that divide your program into
    conceptual units.
  </p><p id="idp7978976">
    In this chapter, we'll show you how to build an OCaml program from a
    collection of files, as well as the basics of working with modules
    and module signatures.
  </p><section><h1 id="single-file-programs">Single File Programs</h1><p id="idp7980432">
      We'll start with an example: a utility that reads lines from
      <code>stdin</code>, computing a frequency count of the lines
      that have been read in. At the end, the 10 lines with the highest
      frequency counts are written out. Here's a simple implementation,
      which we'll save as the file <code>freq.ml</code>. Note that
      we're using several functions from the
      <code>List.Assoc</code> module, which provides utility
      functions for interacting with association lists,
      <span><em>i.e.</em></span>, lists of key/value pairs.
    </p><div class="highlight"><pre><span class="c">(* freq.ml: basic implementation *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* build_counts recursively builds up a mapping from lines to</span>
<span class="c">   number of occurrences of that line. *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">build_counts</span> <span class="n">counts</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">input_line</span> <span class="n">stdin</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">counts</span> <span class="c">(* EOF, so return the counts accumulated so far *)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">line</span> <span class="o">-&gt;</span>
    <span class="c">(* get the number of times this line has been seen before,</span>
<span class="c">       inferring 0 if the line doesn't show up in [counts] *)</span>
    <span class="k">let</span> <span class="n">count</span> <span class="o">=</span>
      <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">find</span> <span class="n">counts</span> <span class="n">line</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="mi">0</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="k">in</span>
    <span class="c">(* increment the count for line by 1, and recurse *)</span>
    <span class="n">build_counts</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">add</span> <span class="n">counts</span> <span class="n">line</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Compute the line counts *)</span>
  <span class="k">let</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">build_counts</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="c">(* Sort the line counts in descending order of frequency *)</span>
  <span class="k">let</span> <span class="n">sorted_counts</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="o">~</span><span class="n">cmp</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(_,</span><span class="n">x</span><span class="o">)</span> <span class="o">(_,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">descending</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">counts</span>  <span class="k">in</span>
  <span class="c">(* Print out the 10 highest frequency entries *)</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">take</span> <span class="mi">10</span> <span class="n">sorted_counts</span><span class="o">)</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">line</span><span class="o">,</span><span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="n">printf</span> <span class="s2">&quot;%3d: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">count</span> <span class="n">line</span><span class="o">)</span>
</pre></div><aside class="note"><h1>
    Where is the main function?
    </h1><p id="idp7986352">
      Unlike C, programs in OCaml do not have a unique
      <code>main</code> function. When an OCaml program is
      evaluated, all the statements in the implementation files are
      evaluated in order. These implementation files can contain
      arbitrary expressions, not just function definitions. In this
      example, the declaration starting with <code>let () =</code>
      plays the role of the <code>main</code> declaration, kicking
      off the processing. But really the entire file is evaluated at
      startup, and so in some sense the full codebase is one big
      <code>main</code> function.
    </p></aside><p id="idp7989920">
      If we weren't using Core or any other external libraries, we could
      build the executable like this:
    </p><pre id="idp7990432">
ocamlc freq.ml -o freq
</pre><p id="idp7991056">
      But in this case, this command will fail with the error
      <code>Unbound module Core</code>. We need a somewhat more
      complex invocation to get Core linked in:
    </p><pre id="idp7992240">
ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq
</pre><p id="idp7992944">
      Here we're using <code>ocamlfind</code>, a tool which itself
      invokes other parts of the ocaml toolchain (in this case,
      <code>ocamlc</code>) with the appropriate flags to link in
      particular libraries and packages. Here,
      <code>-package core</code> is asking
      <code>ocamlfind</code> to link in the Core library,
      <code>-linkpkg</code> is required to do the final linking in
      of packages for building a runnable executable, and
      <code>-thread</code> turns on threading support, which is
      required for Core.
    </p><p id="idp7997504">
      While this works well enough for a one-file project, more
      complicated builds will require a tool to orchestrate the build.
      One great tool for this task is <code>ocamlbuild</code>,
      which is shipped with the OCaml compiler. We'll talk more about
      <code>ocamlbuild</code> in
      <a href="">???</a>, but for
      now, we'll just walk through the steps required for this simple
      application. First, create a <code>_tags</code> file,
      containing the following lines.
    </p><pre id="idp8000672">
true:package(core),thread,annot,debugging
</pre><p id="idp8001296">
      The purpose of the <code>_tags</code> file is to specify
      which compilation options are required for which files. In this
      case, we're telling <code>ocamlbuild</code> to link in the
      <code>core</code> package and to turn on threading, output
      of annotation files, and debugging support for all files (the
      condition <code>true</code> causes the options to be applied
      to every file in the project.)
    </p><p id="idp8004544">
      We can then invoke <code>ocamlbuild</code> to build the
      executable in question.
    </p><pre id="idp8005552">
$ ocamlbuild -use-ocamlfind freq.byte
</pre><p id="idp8006176">
      If we'd invoked <code>ocamlbuild</code> with a target of
      <code>freq.native</code> instead of
      <code>freq.byte</code>, we would have gotten native-code
      instead.
    </p><p id="idp8008432">
      We can now run the our program from the command-line. The
      following line extracts strings from the
      <code>ocamlopt</code> executable, and then reports the most
      frequently occurring ones.
    </p><pre id="idp8009664">
$ strings `which ocamlopt` | ./freq.byte
 13: movq
 10: cmpq
  8: &quot;, &amp;
  7: .globl
  6: addq
  6: leaq
  5: &quot;, $
  5: .long
  5: .quad
  4: &quot;, '
</pre><aside class="note"><h1>
    Byte-code vs native-code
    </h1><p id="idp8011152">
      OCaml ships with two compilers---the <code>ocamlc</code>
      byte-code compiler, and the <code>ocamlopt</code>
      native-code compiler. Programs compiled with
      <code>ocamlc</code> are interpreted by a virtual machine,
      while programs compiled with <code>ocamlopt</code> are
      compiled to native machine code to be run on a specific operating
      system and processor architecture.
    </p><p id="idp8014352">
      Aside from performance, executables generated by the two compilers
      have nearly identical behavior. There are a few things to be aware
      of. First, the byte-code compiler can be used on more
      architectures, and has some better tool support; in particular,
      the OCaml debugger only works with byte-code. Also, the byte-code
      compiler compiles faster than the native code compiler. Also, in
      order to run a bytecode executable you typically need to have
      OCaml installed on the system in question. That's not strictly
      required, though, since you can a byte-code executable with an
      embedded runtime, using the <code>-custom</code> compiler
      flag.
    </p><p id="idp8016032">
      As a general matter, production executables should usually be
      built using the native-code compiler, but it sometimes makes sense
      to use bytecode for development builds. And, of course, bytecode
      makes sense when targeting a platform not supported by the native
      code compiler.
    </p></aside></section><section><h1 id="multi-file-programs-and-modules">Multi-file programs and modules</h1><p id="idp8017872">
      Source files in OCaml are tied into the module system, with each
      file compiling down into a module whose name is derived from the
      name of the file. We've encountered modules before, for example,
      when we used functions like <code>find</code> and
      <code>add</code> from the <code>List.Assoc</code>
      module. At it's simplest, you can think of a module as a
      collection of definitions that are stored within a namespace.
    </p><p id="idp8020560">
      Let's consider how we can use modules to refactor the
      implementation of <code>freq.ml</code>. Remember that the
      variable <code>counts</code> contains an association list
      representing the counts of the lines seen so far. But updating an
      association list takes time linear in the length of the list,
      meaning that the time complexity of processing a file is quadratic
      in the number of distinct lines in the file.
    </p><p id="idp8022608">
      We can fix this problem by replacing association lists with a more
      efficient data structure. To do that, we'll first factor out the
      key functionality into a separate module with an explicit
      interface. We can consider alternative (and more efficient)
      implementations once we have a clear interface to program against.
    </p><p id="idp8023360">
      We'll start by creating a file, <code>counter.ml</code>,
      that contains the logic for maintaining the association list used
      to describe the counts. The key function, called
      <code>touch</code>, updates the association list with the
      information that a given line should be added to the frequency
      counts.
    </p><div class="highlight"><pre><span class="c">(* counter.ml: first version *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="n">touch</span> <span class="n">t</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">count</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">find</span> <span class="n">t</span> <span class="n">s</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">add</span> <span class="n">t</span> <span class="n">s</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div><p id="idp8026416">
      We can now rewrite <code>freq.ml</code> to use
      <code>Counter</code>. Note that the resulting code can still
      be built with <code>build.sh</code>, since
      <code>ocamlbuild</code> will discover dependencies and
      realize that <code>counter.ml</code> needs to be compiled.
    </p><div class="highlight"><pre><span class="c">(* freq.ml: using Counter *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">build_counts</span> <span class="n">counts</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">input_line</span> <span class="n">stdin</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">counts</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">line</span> <span class="o">-&gt;</span> <span class="n">build_counts</span> <span class="o">(</span><span class="nn">Counter</span><span class="p">.</span><span class="n">touch</span> <span class="n">counts</span> <span class="n">line</span><span class="o">)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">build_counts</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">sorted_counts</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">counts</span>
    <span class="o">~</span><span class="n">cmp</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(_,</span><span class="n">x</span><span class="o">)</span> <span class="o">(_,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nn">Int</span><span class="p">.</span><span class="n">descending</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">take</span> <span class="n">sorted_counts</span> <span class="mi">10</span><span class="o">)</span>
    <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(</span><span class="n">line</span><span class="o">,</span><span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">printf</span> <span class="s2">&quot;%3d: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">count</span> <span class="n">line</span><span class="o">)</span>
</pre></div><section><h1 id="signatures-and-abstract-types">Signatures and Abstract Types</h1><p id="idp8032576">
        While we've pushed some of the logic to the
        <code>Counter</code> module, the code in
        <code>freq.ml</code> can still depend on the details of
        the implementation of <code>Counter</code>. Indeed, if you
        look at the invocation of <code>build_counts</code>:
      </p><div class="highlight"><pre>  <span class="k">let</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">build_counts</span> <span class="bp">[]</span> <span class="k">in</span>
</pre></div><p id="idp8036480">
        you'll see that it depends on the fact that the empty set of
        frequency counts is represented as an empty list. We'd like to
        prevent this kind of dependency, so that we can change the
        implementation of <code>Counter</code> without needing to
        change client code like that in <code>freq.ml</code>.
      </p><p id="idp8038448">
        The first step towards hiding the implementation details of
        <code>Counter</code> is to create an interface file,
        <code>counter.mli</code>, which controls how
        <code>counter</code> is accessed. Let's start by writing
        down a simple descriptive interface, <span><em>i.e.</em></span>,
        an interface that describes what's currently available in
        <code>Counter</code> without hiding anything. We'll use
        <code>val</code> declarations in the
        <code>mli</code>, which have the following syntax
      </p><pre id="idp8043248">
val &lt;identifier&gt; : &lt;type&gt;
</pre><p id="idp8043872">
        and are used to expose the existence of a given value in the
        module. Here's an interface that describes the current contents
        of <code>Counter</code>. We can save this as
        <code>counter.mli</code> and compile, and the program will
        build as before.
      </p><div class="highlight"><pre><span class="c">(* counter.mli: descriptive interface *)</span>

<span class="k">val</span> <span class="n">touch</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="kt">list</span>
</pre></div><p id="idp8046800">
        To actually hide the fact that frequency counts are represented
        as association lists, we need to make the type of frequency
        counts <span><em>abstract</em></span>. A type is abstract if its
        name is exposed in the interface, but its definition is not.
        Here's an abstract interface for <code>Counter</code>:
      </p><div class="highlight"><pre><span class="c">(* counter.mli: abstract interface *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_list</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="kt">list</span>
<span class="k">val</span> <span class="n">touch</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span>
</pre></div><p id="idp8049600">
        Note that we needed to add <code>empty</code> and
        <code>to_list</code> to <code>Counter</code>, since
        otherwise, there would be no way to create a
        <code>Counter.t</code> or get data out of one.
      </p><p id="idp8052560">
        Here's a rewrite of <code>counter.ml</code> to match this
        signature.
      </p><div class="highlight"><pre><span class="c">(* counter.ml: implementation matching abstract interface *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="bp">[]</span>

<span class="k">let</span> <span class="n">to_list</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>

<span class="k">let</span> <span class="n">touch</span> <span class="n">t</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">count</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">find</span> <span class="n">t</span> <span class="n">s</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="nn">Assoc</span><span class="p">.</span><span class="n">add</span> <span class="n">t</span> <span class="n">s</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div><p id="idp8054896">
        If we now try to compile <code>freq.ml</code>, we'll get
        the following error:
      </p><pre id="idp8055904">
File &quot;freq.ml&quot;, line 11, characters 20-22:
Error: This expression has type 'a list
       but an expression was expected of type Counter.t
</pre><p id="idp8056832">
        This is because <code>freq.ml</code> depends on the fact
        that frequency counts are represented as association lists, a
        fact that we've just hidden. We just need to fix the code to use
        <code>Counter.empty</code> instead of
        <code>[]</code> and <code>Counter.to_list</code> to
        get the association list out at the end for processing and
        printing.
      </p><p id="idp8060016">
        Now we can turn to optimizing the implementation of
        <code>Counter</code>. Here's an alternate and far more
        efficient implementation, based on the <code>Map</code>
        datastructure in Core.
      </p><div class="highlight"><pre><span class="c">(* counter.ml: efficient version *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span> <span class="nn">Int</span><span class="p">.</span><span class="nn">Map</span><span class="p">.</span><span class="n">t</span>

<span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="n">empty</span>

<span class="k">let</span> <span class="n">touch</span> <span class="n">t</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">count</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">Map</span><span class="p">.</span><span class="n">find</span> <span class="n">t</span> <span class="n">s</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="k">in</span>
  <span class="nn">Map</span><span class="p">.</span><span class="n">add</span> <span class="n">t</span> <span class="n">s</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">let</span> <span class="n">to_list</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="n">to_alist</span> <span class="n">t</span>
</pre></div></section></section><section><h1 id="more-on-modules-and-signatures">More on modules and signatures</h1><section><h1 id="concrete-types-in-signatures">Concrete types in signatures</h1><p id="idp8065072">
        In our frequency-count example, the module
        <code>Counter</code> had an abstract type
        <code>Counter.t</code> for representing a collection of
        frequency counts. Sometimes, you'll want to make a type in your
        interface <span><em>concrete</em></span>, by including the type
        definition in the interface.
      </p><p id="idp8067392">
        For example, imagine we wanted to add a function to
        <code>Counter</code> for returning the line with the
        median frequency count. If the number of lines is even, then
        there is no precise median, so the function would return the two
        lines before and after the median instead. We'll use a custom
        type to represent the fact that there are two possible return
        values. Here's a possible implementation.
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">median</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Median</span> <span class="k">of</span> <span class="kt">string</span>
              <span class="o">|</span> <span class="nc">Before_and_after</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span>

<span class="k">let</span> <span class="n">median</span> <span class="n">t</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">sorted_strings</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="o">(</span><span class="nn">Map</span><span class="p">.</span><span class="n">to_alist</span> <span class="n">t</span><span class="o">)</span>
      <span class="o">~</span><span class="n">cmp</span><span class="o">:(</span><span class="k">fun</span> <span class="o">(_,</span><span class="n">x</span><span class="o">)</span> <span class="o">(_,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nn">Int</span><span class="p">.</span><span class="n">descending</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">sorted_strings</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">&quot;median: empty frequency count&quot;</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">nth</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fst</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">nth_exn</span> <span class="n">sorted_strings</span> <span class="n">n</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">len</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">then</span> <span class="nc">Median</span> <span class="o">(</span><span class="n">nth</span> <span class="o">(</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="o">))</span>
  <span class="k">else</span> <span class="nc">Before_and_after</span> <span class="o">(</span><span class="n">nth</span> <span class="o">(</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="o">),</span> <span class="n">nth</span> <span class="o">(</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));;</span>
</pre></div><p id="idp8070800">
        Now, to expose this usefully in the interface, we need to expose
        both the function and the type <code>median</code> with
        its definition. We'd do that by adding these lines to the
        <code>counter.mli</code>:
      </p><div class="highlight"><pre><span class="k">type</span> <span class="n">median</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Median</span> <span class="k">of</span> <span class="kt">string</span>
              <span class="o">|</span> <span class="nc">Before_and_after</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span>

<span class="k">val</span> <span class="n">get_median</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">median</span>
</pre></div><p id="idp8073760">
        The decision of whether a given type should be abstract or
        concrete is an important one. Abstract types give you more
        control over how values are created and accessed, and makes it
        easier to enforce invariants beyond the what's enforced by the
        type itself; concrete types let you expose more detail and
        structure to client code in a lightweight way. The right choice
        depends very much on the context.
      </p></section><section><h1 id="the-include-directive">The <code>include</code> directive</h1><p id="idp179664">
        OCaml provides a number of tools for manipulating modules. One
        particularly useful one is the <code>include</code>
        directive, which is used to include the contents of one module
        into another.
      </p><p id="idp180976">
        One natural application of <code>include</code> is to
        create one module which is an extension of another one. For
        example, imagine you wanted to build an extended version of the
        <code>List</code> module, where you've added some
        functionality not present in the module as distributed in Core.
        We can do this easily using <code>include</code>:
      </p><div class="highlight"><pre><span class="c">(* ext_list.ml: an extended list module *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* The new function we're going to add *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">intersperse</span> <span class="kt">list</span> <span class="n">el</span> <span class="o">=</span>
  <span class="k">match</span> <span class="kt">list</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[</span> <span class="o">_</span> <span class="o">]</span>   <span class="o">-&gt;</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">el</span> <span class="o">::</span> <span class="n">intersperse</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">tl</span><span class="o">)</span> <span class="n">el</span>

<span class="c">(* The remainder of the list module *)</span>
<span class="k">include</span> <span class="nc">List</span>
</pre></div><p id="idp185120">
        Now, what about the interface of this new module? It turns out
        that include works on the signature language as well, so we can
        pull essentially the same trick to write an
        <code>mli</code> for this new module. The only trick is
        that we need to get our hands on the signature for the list
        module, which can be done using
        <code>module type of</code>.
      </p><div class="highlight"><pre><span class="c">(* ext_list.mli: an extended list module *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="c">(* Include the interface of the list module from Core *)</span>
<span class="k">include</span> <span class="o">(</span><span class="k">module</span> <span class="k">type</span> <span class="k">of</span> <span class="nc">List</span><span class="o">)</span>

<span class="c">(* Signature of function we're adding *)</span>
<span class="k">val</span> <span class="n">intersperse</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
</pre></div><p id="idp8093408">
        And we can now use <code>Ext_list</code> as a replacement
        for <code>List</code>. If we want to use
        <code>Ext_list</code> in preference to
        <code>List</code> in our project, we can create a file of
        common definitions:
      </p><div class="highlight"><pre><span class="c">(* common.ml *)</span>

<span class="k">module</span> <span class="nc">List</span> <span class="o">=</span> <span class="nc">Ext_list</span>
</pre></div><p id="idp8097248">
        And if we then put <code>open Common</code> after
        <code>open Core.Std</code> at the top of each file in our
        project, then references to <code>List</code> will
        automatically go to <code>Ext_list</code> instead.
      </p></section><section><h1 id="modules-within-a-file">Modules within a file</h1><p id="idp8101216">
        Up until now, we've only considered modules that correspond to
        files, like <code>counter.ml</code>. But modules (and
        module signatures) can be nested inside other modules. As a
        simple example, consider a program that needs to deal with some
        class of identifier like a username. Rather than just keeping
        usernames as strings, you might want to mint an abstract type,
        so that the type-system will help you to not confuse usernames
        with other string data that is floating around your program.
      </p><p id="idp8102800">
        Here's how you might create such a type, within a module:
      </p><div class="highlight"><pre><span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">module</span> <span class="nc">Username</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">of_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span>
  <span class="k">let</span> <span class="n">of_string</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">let</span> <span class="n">to_string</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">end</span>
</pre></div><p id="idp8104640">
        The basic structure of a module declaration like this is:
      </p><div class="highlight"><pre><span class="k">module</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span> <span class="o">:</span> <span class="o">&lt;</span><span class="n">signature</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">implementation</span><span class="o">&gt;</span>
</pre></div><p id="idp8106064">
        We could have written this slightly differently, by giving the
        signature its own toplevel <code>module type</code>
        declaration, making it possible to in a lightweight way create
        multiple distinct types with the same underlying implementation.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">ID</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">of_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">String_id</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span>
  <span class="k">let</span> <span class="n">of_string</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">let</span> <span class="n">to_string</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Username</span> <span class="o">:</span> <span class="nc">ID</span> <span class="o">=</span> <span class="nc">String_id</span>
<span class="k">module</span> <span class="nc">Hostname</span> <span class="o">:</span> <span class="nc">ID</span> <span class="o">=</span> <span class="nc">String_id</span>

<span class="c">(* Now the following buggy code won't compile *)</span>
<span class="k">type</span> <span class="n">session_info</span> <span class="o">=</span> <span class="o">{</span> <span class="n">user</span><span class="o">:</span> <span class="nn">Username</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
                      <span class="n">host</span><span class="o">:</span> <span class="nn">Hostname</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
                      <span class="n">when_started</span><span class="o">:</span> <span class="nn">Time</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
                    <span class="o">}</span>

<span class="k">let</span> <span class="n">sessions_have_same_user</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">=</span>
  <span class="n">s1</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">user</span>
</pre></div><p id="idp8109328">
        We can also combine this with the use of the include directive
        to add some extra functionality to such a module. Thus, we could
        have rewritten the definition of <code>Hostname</code>
        above as follows to add a function
        <code>Hostname.mine</code> that returns the hostname of
        the present machine.
      </p><div class="highlight"><pre><span class="k">module</span> <span class="nc">Hostname</span> <span class="o">:</span> <span class="k">sig</span>
  <span class="k">include</span> <span class="nc">ID</span>
  <span class="k">val</span> <span class="n">mine</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">include</span> <span class="nc">String_id</span>
  <span class="k">let</span> <span class="n">mine</span> <span class="o">=</span> <span class="nn">Unix</span><span class="p">.</span><span class="n">gethostname</span>
<span class="k">end</span>  
</pre></div></section><section><h1 id="opening-modules">Opening modules</h1><p id="idp8113504">
        One useful primitive in OCaml's module language is the
        <code>open</code> directive. We've seen that already in
        the <code>open Core.Std</code> that has been at the top of
        our source files.
      </p><p id="idp8115312">
        The basic purpose of <code>open</code> is to extend the
        namespaces that OCaml searches when trying to resolve an
        identifier. Roughly, if you open a module <code>M</code>,
        then every subsequent time you look for an identifier
        <code>foo</code>, the module system will look in
        <code>M</code> for a value named <code>foo</code>.
        This is true for all kinds of identifiers, including types, type
        constructors, values and modules.
      </p><p id="idp8119200">
<code>open</code> is essential when dealing with something
        like a standard library, but it's generally good style to keep
        opening of modules to a minimum. Opening a module is basically a
        tradeoff between terseness and explicitness - the more modules
        you open, the harder it is to look at an identifier and figure
        out where it's defined.
      </p><p id="idp8120592">
        Here's some general advice on how to deal with opens.
      </p><ul><li><p id="idp8121568">
            Opening modules at the toplevel of a module should be done
            quite sparingly, and generally only with modules that have
            been specifically designed to be opened, like
            <code>Core.Std</code> or
            <code>Option.Monad_infix</code>.
          </p></li><li><p id="idp8123808">
            One alternative to local opens that makes your code terser
            without giving up on explicitness is to locally rebind the
            name of a module. So, instead of writing:
          </p><div class="highlight"><pre><span class="k">let</span> <span class="n">print_median</span> <span class="n">m</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">m</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nn">Counter</span><span class="p">.</span><span class="nc">Median</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">printf</span> <span class="s2">&quot;True median:</span><span class="se">\n</span><span class="s2">   %s</span><span class="se">\n</span><span class="s2">&quot;</span>
   <span class="o">|</span> <span class="nn">Counter</span><span class="p">.</span><span class="nc">Before_and_after</span> <span class="k">of</span> <span class="n">before</span> <span class="o">*</span> <span class="n">after</span> <span class="o">-&gt;</span>
     <span class="n">printf</span> <span class="s2">&quot;Before and after median:</span><span class="se">\n</span><span class="s2">   %s</span><span class="se">\n</span><span class="s2">   %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">before</span> <span class="n">after</span>
</pre></div><p id="idp8125664">
            ...you could write
          </p><div class="highlight"><pre><span class="k">let</span> <span class="n">print_median</span> <span class="n">m</span> <span class="o">=</span>
   <span class="k">let</span> <span class="k">module</span> <span class="nc">C</span> <span class="o">=</span> <span class="nc">Counter</span> <span class="k">in</span>
   <span class="k">match</span> <span class="n">m</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nn">C</span><span class="p">.</span><span class="nc">Median</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">printf</span> <span class="s2">&quot;True median:</span><span class="se">\n</span><span class="s2">   %s</span><span class="se">\n</span><span class="s2">&quot;</span>
   <span class="o">|</span> <span class="nn">C</span><span class="p">.</span><span class="nc">Before_and_after</span> <span class="k">of</span> <span class="n">before</span> <span class="o">*</span> <span class="n">after</span> <span class="o">-&gt;</span>
     <span class="n">printf</span> <span class="s2">&quot;Before and after median:</span><span class="se">\n</span><span class="s2">   %s</span><span class="se">\n</span><span class="s2">   %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">before</span> <span class="n">after</span>
</pre></div><p id="idp8127376">
            Because the module name <code>C</code> only exists for
            a short scope, it's easy to read and remember what
            <code>C</code> stands for. Rebinding modules to very
            short names at the toplevel of your module is usually a
            mistake.
          </p></li><li><p id="idp8129664">
            If you do need to do an open, it's better to do a
            <span><em>local open</em></span>. There are two syntaxes for
            local opens. For example, you can write:
          </p><div class="highlight"><pre><span class="k">let</span> <span class="n">average</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Int64</span> <span class="k">in</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">/</span> <span class="n">of_int</span> <span class="mi">2</span>
</pre></div><p id="idp8131584">
            In the above, <code>of_int</code> and the infix
            operators are the ones from <code>Int64</code> module.
          </p><p id="idp8133216">
            There's another even more lightweight syntax for local
            opens, which is particularly useful for small expressions:
          </p><div class="highlight"><pre><span class="k">let</span> <span class="n">average</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="nn">Int64</span><span class="p">.</span><span class="err">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">/</span> <span class="n">of_int</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></li></ul></section><section><h1 id="common-errors-with-modules">Common errors with modules</h1><p id="idp8135888">
        When OCaml compiles a program with an <code>ml</code> and
        an <code>mli</code>, it will complain if it detects a
        mismatch between the two. Here are some of the common errors
        you'll run into.
      </p><section><h1 id="type-mismatches">Type mismatches</h1><p id="idp8138544">
          The simplest kind of error is where the type specified in the
          signature does not match up with the type in the
          implementation of the module. As an example, if we replace the
          <code>val</code> declaration in
          <code>counter.mli</code> by swapping the types of the
          first two arguments:
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">touch</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</pre></div><p id="idp8141344">
          and then try to compile <code>Counter</code> (by writing
          <code>ocamlbuild -use-ocamlfind counter.cmo</code>),
          we'll get the following error:
        </p><pre id="idp8142976">
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       Values do not match:
         val touch :
           ('a, int) Core.Std.Map.t -&gt; 'a -&gt; ('a, int) Core.Std.Map.t
       is not included in
         val touch : string -&gt; t -&gt; t
</pre><p id="idp8144112">
          This error message is a bit intimidating at first, and it
          takes a bit of thought to see where the first type, which is
          the type of [touch] in the implementation, doesn't match the
          second one, which is the type of [touch] in the interface. You
          need to recognize that [t] is in fact a [Core.Std.Map.t], and
          the problem is that in the first type, the first argument is a
          map while the second is the key to that map, but the order is
          swapped in the second type.
        </p></section><section><h1 id="missing-definitions">Missing definitions</h1><p id="idp8146064">
          We might decide that we want a new function in
          <code>Counter</code> for pulling out the frequency count
          of a given string. We can update the <code>mli</code> by
          adding the following line.
        </p><div class="highlight"><pre><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</pre></div><p id="idp8148736">
          Now, if we try to compile without actually adding the
          implementation, we'll get this error:
        </p><pre id="idp8149264">
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       The field `count' is required but not provided
</pre><p id="idp8150336">
          A missing type definition will lead to a similar error.
        </p></section><section><h1 id="type-definition-mismatches">Type definition mismatches</h1><p id="idp8151824">
          Type definitions that show up in an <code>mli</code>
          need to match up with corresponding definitions in the
          <code>ml</code>. Consider again the example of the type
          <code>median</code>. The order of the declaration of
          variants matters to the OCaml compiler so, if the definition
          of <code>median</code> in the implementation lists those
          options in a different order:
        </p><div class="highlight"><pre><span class="k">type</span> <span class="n">median</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Before_and_after</span> <span class="k">of</span> <span class="n">line</span> <span class="o">*</span> <span class="n">line</span>
              <span class="o">|</span> <span class="nc">Median</span> <span class="k">of</span> <span class="n">line</span>
</pre></div><p id="idp8155984">
          that will lead to a compilation error:
        </p><pre id="idp8156448">
File &quot;counter.ml&quot;, line 1, characters 0-1:
Error: The implementation counter.ml
       does not match the interface counter.cmi:
       Type declarations do not match:
         type median = Before_and_after of string * string | Median of string
       is not included in
         type median = Median of string | Before_and_after of string * string
       Their first fields have different names, Before_and_after and Median.
</pre><p id="idp8158016">
          Order is similarly important in other parts of the signature,
          including the order in which record fields are declared and
          the order of arguments (including labeled and optional
          arguments) to a function.
        </p></section><section><h1 id="cyclic-dependencies">Cyclic dependencies</h1><p id="idp8159680">
          In most cases, OCaml doesn't allow circular dependencies,
          <span><em>i.e.</em></span>, a collection of definitions that
          all refer to each other. If you want to create such
          definitions, you typically have to mark them specially. For
          example, when defining a set of mutually recursive values, you
          need to define them using <code>let rec</code> rather
          than ordinary <code>let</code>.
        </p><p id="idp8162080">
          The same is true at the module level. By default, circular
          dependencies between modules is not allowed, and indeed,
          circular dependencies among files is never allowed.
        </p><p id="idp8162688">
          The simplest case of this is that a module can not directly
          refer to itself (although definitions within a module can
          refer to each other in the ordinary way). So, if we tried to
          add a reference to <code>Counter</code> from within
          <code>counter.ml</code>:
        </p><div class="highlight"><pre><span class="k">let</span> <span class="n">singleton</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">Counter</span><span class="p">.</span><span class="n">touch</span> <span class="nn">Counter</span><span class="p">.</span><span class="n">empty</span>
</pre></div><p id="idp8165440">
          then when we try to build, we'll get this error:
        </p><pre id="idp8165904">
File &quot;counter.ml&quot;, line 17, characters 18-31:
Error: Unbound module Counter
Command exited with code 2.
</pre><p id="idp8166816">
          The problem manifests in a different way if we create circular
          references between files. We could create such a situation by
          adding a reference to Freq from <code>counter.ml</code>,
          <span><em>e.g.</em></span>, by adding the following line:
        </p><div class="highlight"><pre><span class="k">let</span> <span class="n">build_counts</span> <span class="o">=</span> <span class="nn">Freq</span><span class="p">.</span><span class="n">build_counts</span>
</pre></div><p id="idp8169280">
          In this case, <code>ocamlbuild</code> will notice the
          error and complain:
        </p><pre id="idp8170288">
Circular dependencies: &quot;freq.cmo&quot; already seen in
  [ &quot;counter.cmo&quot;; &quot;freq.cmo&quot; ]
</pre></section></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="error-handling.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="functors.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>