<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 12. XML Streams and Trees / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'alpha3',
                        page: 'xml\u002Dstreams\u002Dand\u002Dtrees.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Basic Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Practical Examples</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="data-serialization-with-s-expressions.html">10. Data Serialization with S-Expressions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="handling-json-data.html">11. Handling JSON data</a>
                                            </li>
                                        
                                            <li>
                                                <a href="xml-streams-and-trees.html" class="here">12. XML Streams and Trees</a>
                                            </li>
                                        
                                            <li>
                                                <a href="fast-binary-serialization-with-bin_prot.html">13. Fast Binary Serialization with bin_prot</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. Advanced Topics</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 12. XML Streams and Trees</h1>
                
                

    <p id="idp9038320">
    XML is a markup language designed to store tree-structured data in a
    format that is (somewhat) human- and machine-readable. Like JSON, it
    is a textual format commonly used in web technologies, with a
    complete
    <a href="http://www.w3.org/TR/REC-xml/" target="_top">specification</a>
    available online. A complete description is beyond the scope of this
    book, but we'll explain how to manipulate it now.
  </p><aside class="note"><h1>
  Obtaining and installing XMLM
  </h1><p id="idp9040480">
    The remainder of this section uses the freely available XMLM
    library. It's easiest to obtain it via OPAM (see
    <a href="">???</a> for
    installation instructions). You need to run
    <code>opam install xmlm</code> once OPAM is installed. The
    library documentation is also readable
    <a href="http://erratique.ch/software/xmlm/doc/Xmlm" target="_top">online</a>.
  </p></aside><p id="idp9043472">
    Since XML is such a common web format, we've taken our example
    document from the
    <a href="http://duckduckgo.com" target="_top">DuckDuckGo</a> search engine.
    This is a smaller search engine than the usual suspects, but has the
    advantage of a freely available API that doesn't require you to
    register before using it. We'll talk more about how to use the live
    API later in
    <a href="">???</a>, but
    for now here's what a shortened XML search response from DuckDuckGo
    looks like:
  </p><div class="highlight"><pre><span class="o">&lt;</span><span class="nc">DuckDuckGoResponse</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">Heading</span><span class="o">&gt;</span><span class="nc">DuckDuckGo</span><span class="o">&lt;/</span><span class="nc">Heading</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">AbstractText</span><span class="o">&gt;</span><span class="nc">DuckDuckGo</span> <span class="n">is</span> <span class="n">an</span> <span class="nc">Internet</span> <span class="n">search</span> <span class="n">engine</span><span class="o">.&lt;/</span><span class="nc">AbstractText</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">AbstractURL</span><span class="o">&gt;</span><span class="n">https</span><span class="o">://</span><span class="n">en</span><span class="o">.</span><span class="n">wikipedia</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">wiki</span><span class="o">/</span><span class="nc">DuckDuckGo</span><span class="o">&lt;/</span><span class="nc">AbstractURL</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">AbstractSource</span><span class="o">&gt;</span><span class="nc">Wikipedia</span><span class="o">&lt;/</span><span class="nc">AbstractSource</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">Results</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">Result</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nc">Text</span><span class="o">&gt;</span><span class="nc">Official</span> <span class="n">site</span><span class="o">&lt;/</span><span class="nc">Text</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nc">FirstURL</span><span class="o">&gt;</span><span class="n">https</span><span class="o">://</span><span class="n">duckduckgo</span><span class="o">.</span><span class="n">com</span><span class="o">/&lt;/</span><span class="nc">FirstURL</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="nc">Result</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nc">Results</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nc">RelatedTopics</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="nc">RelatedTopic</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="nc">Text</span><span class="o">&gt;</span><span class="nc">Companies</span> <span class="n">based</span> <span class="k">in</span> <span class="nc">Pennsylvania</span><span class="o">&lt;/</span><span class="nc">Text</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="nc">FirstURL</span><span class="o">&gt;</span> 
     <span class="n">http</span><span class="o">://</span><span class="n">duckduckgo</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">c</span><span class="o">/</span><span class="nc">Companies_based_in_Pennsylvania</span>
   <span class="o">&lt;/</span><span class="nc">FirstURL</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="nc">RelatedTopic</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="nc">RelatedTopic</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="nc">Text</span><span class="o">&gt;</span><span class="nc">Internet</span> <span class="n">search</span> <span class="n">engines</span><span class="o">&lt;/</span><span class="nc">Text</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="nc">FirstURL</span><span class="o">&gt;</span>
     <span class="n">http</span><span class="o">://</span><span class="n">duckduckgo</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">c</span><span class="o">/</span><span class="nc">Internet_search_engines</span>
   <span class="o">&lt;/</span><span class="nc">FirstURL</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="nc">RelatedTopic</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nc">RelatedTopics</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nc">DuckDuckGoResponse</span><span class="o">&gt;</span>
</pre></div><p id="idp9047888">
    The XML document is structured as a series of
    <code>&lt;tags&gt;</code> that are closed by an end
    <code>&lt;/tag&gt;</code>. The opening tags have an optional
    set of key/value attributes and usually contain text data or further
    tags within them. If the XML document is large, we don't want to
    read the whole thing into memory before processing it. Luckily we
    don't have to, as there are two parsing strategies for XML: a
    low-level <span><em>streaming</em></span> API that parses a document
    incrementally, and a simpler but more inefficient tree API. We'll
    start with the streaming API first, as the tree API is built on top
    of it.
  </p><section><h1 id="stream-parsing-xml">Stream parsing XML</h1><p id="idp9051776">
      The XMLM documentation is a good place to read about the overall
      layout of the library. It tells us that:
    </p><div><blockquote><p id="idp9052560">
        A well-formed sequence of <code>signal</code>s represents
        an XML document tree traversal in depth-first order. Input pulls
        a well-formed sequence of <code>signal</code>s from a data
        source and output pushes a well-formed sequence of
        <code>signal</code>s to a data destination. Functions are
        provided to easily transform sequences of
        <code>signal</code>s to/from arborescent data structures.
      </p></blockquote></div><p id="idp9056288">
      The type of a <code>signal</code> reveals the basic
      structure of the streaming API in XMLM:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">signal</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Data</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Dtd</span> <span class="k">of</span> <span class="n">dtd</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">El_end</span> 
  <span class="o">|</span> <span class="o">`</span><span class="nc">El_start</span> <span class="k">of</span> <span class="n">tag</span> 
<span class="o">]</span>
</pre></div><p id="idp9058512">
      XMLM outputs an ordered sequence of these signals to your code as
      it parses the document. The first <code>signal</code> when
      inputting an XML document is always a <code>Dtd</code>. The
      DTD (or <span><em>document type description</em></span>) optionally
      defines which tags are allowed within the XML document. Some XML
      parsers can validate a document against a DTD, but XMLM is a
      <span><em>non-validating</em></span> parser that reads the DTD if
      present, but disregards its contents. The
      <code>El_start</code> and <code>El_end</code> signals
      indicate the opening and closing of tags, and
      <code>Data</code> passes the free-form information contained
      between tags.
    </p><p id="idp9063888">
      Let's take a shot at handling signals by writing the XML identity
      function that parses some XML and outputs it again. There is no
      explicit buffering required since this uses the XMLM streaming
      API.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">xml_id</span> <span class="n">i</span> <span class="n">o</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="n">depth</span> <span class="o">=</span>
    <span class="nn">Xmlm</span><span class="p">.</span><span class="n">output</span> <span class="n">o</span> <span class="o">(</span><span class="nn">Xmlm</span><span class="p">.</span><span class="n">peek</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">match</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">input</span> <span class="n">i</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">El_start</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="o">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">El_end</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="o">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">Data</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="n">depth</span>
    <span class="o">|</span> <span class="o">`</span><span class="nc">Dtd</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>
  <span class="k">in</span>
  <span class="nn">Xmlm</span><span class="p">.</span><span class="n">output</span> <span class="n">o</span> <span class="o">(</span><span class="nn">Xmlm</span><span class="p">.</span><span class="n">input</span> <span class="n">i</span><span class="o">);</span> <span class="c">(* `Dtd *)</span>
  <span class="n">pull</span> <span class="n">i</span> <span class="n">o</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">if</span> <span class="n">not</span> <span class="o">(</span><span class="nn">Xmlm</span><span class="p">.</span><span class="n">eoi</span> <span class="n">i</span><span class="o">)</span> <span class="k">then</span> <span class="n">invalid_arg</span> <span class="s2">&quot;document not well-formed&quot;</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">make_input</span> <span class="o">(`</span><span class="nc">Channel</span> <span class="o">(</span><span class="n">open_in</span> <span class="s2">&quot;ddg.xml&quot;</span><span class="o">))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">o</span> <span class="o">=</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">make_output</span> <span class="o">(`</span><span class="nc">Channel</span> <span class="n">stdout</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">xml_id</span> <span class="n">i</span> <span class="n">o</span>
</pre></div><p id="idp9066192">
      Let's start at the bottom, where we open up input and output
      channels to pass to <code>Xmlm</code> parser. The
      <code>input</code> and <code>output</code> constructor
      functions use a polymorphic variant to define the mechanism that
      the library should use to read the document.
      <code>Channel</code> is the simplest, but there are several
      others available.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">source</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Channel</span> <span class="k">of</span> <span class="n">in_channel</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Fun</span> <span class="k">of</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> 
<span class="o">]</span> 
</pre></div><p id="idp9070816">
      The <code>Fun</code> channel returns one character at a time
      as an integer, and <code>String</code> starts parsing an
      OCaml string from the given integer offset. Both of these are will
      normally be used in preference to <code>Channel</code>,
      which uses an interface that is deprecated in Core.
    </p><p id="idp9073616">
      The <code>xml_id</code> function begins by reading one
      signal, which will always be a <code>Dtd</code>. The
      recursive <code>pull</code> function is then invoked to
      iterate over the remaining signals. This uses
      <code>Xmlm.peek</code> to inspect the current input signal
      and immediately output it. The rest of the function is not
      strictly necessary, but it tracks that all of the tags that have
      been started via the <code>El_start</code> signal are also
      closed by a corresponding <code>El_end</code> signal. Once
      the <code>pull</code> function has finished due to the
      opening tag being closed, the <code>Xmlm.eoi</code> function
      verifies that the &quot;end of input&quot; has been reached.
    </p></section><section><h1 id="tree-parsing-xml">Tree parsing XML</h1><p id="idp9081376">
      Signals enforce a very iterative style of parsing XML, as your
      program has to deal with signals arriving serially. It's often
      more convenient to deal with complete XML documents directly
      in-memory as an OCaml data structure. You can convert a signal
      stream into an OCaml structure by defining the following data type
      and helper functions:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">tree</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="nc">Element</span> <span class="k">of</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">tag</span> <span class="o">*</span> <span class="n">tree</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="nc">Data</span> <span class="k">of</span> <span class="kt">string</span>

<span class="k">let</span> <span class="n">in_tree</span> <span class="n">i</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">el</span> <span class="n">tag</span> <span class="n">children</span> <span class="o">=</span> <span class="nc">Element</span> <span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">children</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">data</span> <span class="n">d</span> <span class="o">=</span> <span class="nc">Data</span> <span class="n">d</span> <span class="k">in</span>
  <span class="nn">Xmlm</span><span class="p">.</span><span class="n">input_doc_tree</span> <span class="o">~</span><span class="n">el</span> <span class="o">~</span><span class="n">data</span> <span class="n">i</span>

<span class="k">let</span> <span class="n">out_tree</span> <span class="n">o</span> <span class="n">t</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">frag</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Element</span> <span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">childs</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">`</span><span class="nc">El</span> <span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">childs</span><span class="o">)</span> 
  <span class="o">|</span> <span class="nc">Data</span> <span class="n">d</span> <span class="o">-&gt;</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">d</span> 
  <span class="k">in</span>
  <span class="nn">Xmlm</span><span class="p">.</span><span class="n">output_doc_tree</span> <span class="n">frag</span> <span class="n">o</span> <span class="n">t</span>
</pre></div><p id="idp9083648">
      The type <code>tree</code> can be pattern-matched and
      traversed like a normal OCaml data structure. Let's see how this
      works by extracting out all the &quot;Related Topics&quot; in the
      example document. First, we'll need a few helper combinator
      functions to filter through tags and trees, with the following
      signature:
    </p><div class="highlight"><pre><span class="c">(* Extract a textual name from an XML tag.</span>
<span class="c">   Discards the namespace information. *)</span>
<span class="k">val</span> <span class="n">name</span> <span class="o">:</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">tag</span> <span class="o">-&gt;</span> <span class="kt">string</span>

<span class="c">(* Filter out the contents of a tag [n] from a tagset,</span>
<span class="c">   and return the concatenated contents of all of them *)</span>
<span class="k">val</span> <span class="n">filter_tag</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">tree</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">tree</span> <span class="kt">list</span>

<span class="c">(* Given a list of [trees], concatenate all of the data contents               </span>
<span class="c">   into a string, and discard any sub-tags within it *)</span>
<span class="k">val</span> <span class="n">concat_data</span> <span class="o">:</span> <span class="n">tree</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</pre></div><p id="idp9087328">
      The implementation of these signatures fold over the
      <code>tree</code> structure to filter the tags which match
      the desired tag name. A similar version that matches on tag
      attributes is left as an exercise for you to try.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">name</span> <span class="o">((_,</span><span class="n">n</span><span class="o">),_)</span> <span class="o">=</span> <span class="n">n</span>

<span class="k">let</span> <span class="n">filter_tag</span> <span class="n">n</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="o">-&gt;</span>
    <span class="k">function</span>
    <span class="o">|</span><span class="nc">Element</span> <span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">ts</span><span class="o">)</span> <span class="k">when</span> <span class="n">name</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-&gt;</span>
      <span class="n">ts</span> <span class="o">@</span> <span class="n">acc</span>
    <span class="o">|_</span> <span class="o">-&gt;</span> <span class="n">acc</span>
  <span class="o">)</span>
     
<span class="k">let</span> <span class="n">concat_data</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="s2">&quot;&quot;</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="o">-&gt;</span>
    <span class="k">function</span>
    <span class="o">|</span><span class="nc">Data</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">^</span> <span class="n">s</span>
    <span class="o">|_</span> <span class="o">-&gt;</span> <span class="n">acc</span>                           
  <span class="o">)</span>
</pre></div><p id="idp9090064">
      (<span><em>avsm</em></span>: have we explained
      <code>fold_left</code> before this section or does it need a
      full intro?)
    </p><p id="idp9091712">
      Notice the use of a <span><em>guard pattern</em></span> in the
      <code>filter_tag</code> pattern match. This looks for an
      <code>Element</code> tag that matches the name parameter,
      and concatenates the results with the accumulator list.
    </p><p id="idp9094160">
      Once we have these helper functions, the selection of all the
      <code>&lt;Text&gt;</code> tags is a matter of chaining the
      combinators together to peform the selection over the
      <code>tree</code> data structure.
    </p><div class="highlight"><pre><span class="k">let</span> <span class="n">topics</span> <span class="n">trees</span> <span class="o">=</span>
  <span class="n">filter_tag</span> <span class="s2">&quot;DuckDuckGoResponse&quot;</span> <span class="n">trees</span> <span class="o">|!</span>
  <span class="n">filter_tag</span> <span class="s2">&quot;RelatedTopics&quot;</span> <span class="o">|!</span>
  <span class="n">filter_tag</span> <span class="s2">&quot;RelatedTopic&quot;</span> <span class="o">|!</span>
  <span class="n">filter_tag</span> <span class="s2">&quot;Text&quot;</span> <span class="o">|!</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">concat_data</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">|!</span> <span class="n">print_endline</span><span class="o">)</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Xmlm</span><span class="p">.</span><span class="n">make_input</span> <span class="o">(`</span><span class="nc">Channel</span> <span class="o">(</span><span class="n">open_in</span> <span class="s2">&quot;ddg.xml&quot;</span><span class="o">))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">(_,</span><span class="n">it</span><span class="o">)</span> <span class="o">=</span> <span class="n">in_tree</span> <span class="n">i</span> <span class="k">in</span>
  <span class="n">topics</span> <span class="o">[</span><span class="n">it</span><span class="o">]</span>
</pre></div><p id="idp9097648">
      The <code>filter_tag</code> combinator accepts a
      <code>tree list</code> parameter and outputs a
      <code>tree list</code>. This lets us easily chain together
      the results of one filter to another, and hence select
      hierarchical XML tags very easily. When we get to the
      <code>&lt;Text&gt;</code> tag, we iterate over all the
      results and print each one individually.
    </p></section><section><h1 id="constructing-xml-documents-using-syntax-extensions">Constructing XML documents using syntax extensions</h1><p id="idp9102560">
      In the earlier JSON chapter, we explained how to construct records
      by creating the records directly. You can do exactly the same
      thing for XML, but there is also a more automated method available
      by using OCaml's facility for syntax extensions.
    </p><p id="idp9103232">
      The OCaml distribution provides the <code>camlp4</code> tool
      for this purpose, which you can view as a type-safe preprocessor.
      Camlp4 operates by loading in a set of syntax extension modules
      that transform the Abstract Syntax Tree (AST) of OCaml, usually by
      adding nodes that generate code. We'll talk about how to build
      your own syntax extensions later in the book, but for now we'll
      describe how to <span><em>use</em></span> several syntax extensions
      that make it easier to manipulate external data formats such as
      XML.
    </p><p id="idp9105328">
      We'll use the Atom 1.0 syndication format as our example here.
      Atom feeds allow web-based programs (such as browsers) to poll a
      website for updates. The website owner publishes a feed of content
      in a standardized XML format via HTTP. This feed is then parsed by
      clients and compared against previously downloaded versions to
      determine which contents are available.
    </p><p id="idp9106128">
      Here's an example of an Atom feed:
    </p><div class="highlight"><pre><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;feed</span> <span class="na">xmlns=</span><span class="s">&quot;http://www.w3.org/2005/Atom&quot;</span><span class="nt">&gt;</span>
 <span class="nt">&lt;title&gt;</span>Example Feed<span class="nt">&lt;/title&gt;</span>
 <span class="nt">&lt;subtitle&gt;</span>A subtitle.<span class="nt">&lt;/subtitle&gt;</span>
 <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;http://example.org/feed/&quot;</span> <span class="na">rel=</span><span class="s">&quot;self&quot;</span> <span class="nt">/&gt;</span>
 <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;http://example.org/&quot;</span> <span class="nt">/&gt;</span>
 <span class="nt">&lt;id&gt;</span>urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6<span class="nt">&lt;/id&gt;</span>
 <span class="nt">&lt;updated&gt;</span>2003-12-13T18:30:02Z<span class="nt">&lt;/updated&gt;</span>

 <span class="nt">&lt;entry&gt;</span>
  <span class="nt">&lt;title&gt;</span>Atom-Powered Robots Run Amok<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;http://example.org/2003/12/13/atom03&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;alternate&quot;</span> <span class="na">type=</span><span class="s">&quot;text/html&quot;</span> <span class="na">href=</span><span class="s">&quot;http://example.org/2003/12/13/atom03.html&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;edit&quot;</span> <span class="na">href=</span><span class="s">&quot;http://example.org/2003/12/13/atom03/edit&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;id&gt;</span>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a<span class="nt">&lt;/id&gt;</span>
  <span class="nt">&lt;updated&gt;</span>2003-12-13T18:30:02Z<span class="nt">&lt;/updated&gt;</span>
  <span class="nt">&lt;summary&gt;</span>Some text.<span class="nt">&lt;/summary&gt;</span>
  <span class="nt">&lt;author&gt;</span>
    <span class="nt">&lt;name&gt;</span>John Doe<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;email&gt;</span>johndoe@example.com<span class="nt">&lt;/email&gt;</span>
  <span class="nt">&lt;/author&gt;</span>
 <span class="nt">&lt;/entry&gt;</span>
<span class="nt">&lt;/feed&gt;</span>
</pre></div><p id="idp9108368">
      We want to build this by minimising the amount of repetitive XML
      generation code. The &quot;Caml on the Web&quot; (COW) library
      provides a syntax extension that is useful here.
    </p><aside class="note"><h1>
    Installing Caml on the Web (COW)
    </h1><p id="idp9109680">
      The COW library and syntax extension can be installed via OPAM by
      <code>opam install cow</code>. There are two OCamlfind
      packages installed: the library is called <code>cow</code>
      and the syntax extension is activated with the
      <code>cow.syntax</code> package.
    </p><p id="idp9112400">
      One caveat to bear in mind is that COW isn't fully compatible with
      Core yet, and so you must use the syntax extension before opening
      the Core modules. (<span><em>avsm</em></span>: we can fix this
      easily, but note is here as a warning to reviewers).
    </p></aside><p id="idp9113616">
      Let's start to build up an Atom specification using Cow. First,
      the <code>&lt;author&gt;</code> tag can be represented with
      the following type:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">author</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">uri</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">email</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="n">xml</span>
</pre></div><p id="idp9115904">
      This is a standard record type definition with the addition of
      <code>with xml</code> at the end. This uses a syntax
      extension to signify that we wish to generate boilerplate code for
      handling this record as an XML document.
    </p><section><h1><b>
    Invoking <code>camlp4</code> syntax extensions
    </b></h1><p id="idp9118640">
      The OCaml compiler can call <code>camlp4</code>
      automatically during a compilation to preprocess the source files.
      This is specified via the <code>-pp</code> flag to the
      compiler. You don't normally need to specify this flag yourself.
      Use the <code>ocamlfind</code> utility instead to generate
      the right command-line flags for you. Here's a small shell script
      which preprocesses a source file with the COW syntax extension:
    </p><div class="highlight"><pre><span class="c">#!/bin/sh -x</span>

<span class="nv">file</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">lib</span><span class="o">=</span>cow.syntax
<span class="nv">bin</span><span class="o">=</span>ocamlfind
<span class="nv">args</span><span class="o">=</span><span class="sb">`</span><span class="nv">$bin</span> query -predicates syntax,preprocessor -r -format <span class="s1">'-I %d %a'</span> <span class="nv">$lib</span><span class="sb">`</span>
camlp4o -printer o <span class="nv">$args</span> <span class="nv">$file</span>
</pre></div><p id="idp9122640">
      You can supply <code>ocamlfind</code> with a number of
      different predicates to define the type of build you are running
      (preprocessing, compilation or linking). The final part of the
      script invokes the <code>camlp4o</code> binary on your ML
      source file and outputs the transformed source code to your
      terminal.
    </p></section><p id="idp9124880">
      Let's see the OCaml code that has been generated for our
      <code>author</code> record after it has been preprocessed:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">author</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">uri</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">email</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">xml_of_author</span> <span class="n">author</span> <span class="o">:</span> <span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">flatten</span>
    <span class="o">[</span> <span class="o">(</span><span class="k">match</span> <span class="k">match</span> <span class="n">author</span><span class="o">.</span><span class="n">email</span> <span class="k">with</span>
             <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
             <span class="o">|</span> <span class="nc">Some</span> <span class="n">var1</span> <span class="o">-&gt;</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">var1</span> <span class="o">]</span>
       <span class="k">with</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">El</span> <span class="o">((((</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="s2">&quot;email&quot;</span><span class="o">),</span> <span class="bp">[]</span><span class="o">)</span> <span class="o">:</span> <span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">tag</span><span class="o">),</span>
           <span class="o">(</span><span class="k">match</span> <span class="n">author</span><span class="o">.</span><span class="n">email</span> <span class="k">with</span>
            <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
            <span class="o">|</span> <span class="nc">Some</span> <span class="n">var1</span> <span class="o">-&gt;</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">var1</span> <span class="o">]))</span> <span class="o">]);</span>
      <span class="o">(</span><span class="k">match</span> <span class="k">match</span> <span class="n">author</span><span class="o">.</span><span class="n">uri</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span> <span class="o">|</span> <span class="nc">Some</span> <span class="n">var2</span> <span class="o">-&gt;</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">var2</span> <span class="o">]</span>
       <span class="k">with</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">El</span> <span class="o">((((</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="s2">&quot;uri&quot;</span><span class="o">),</span> <span class="bp">[]</span><span class="o">)</span> <span class="o">:</span> <span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">tag</span><span class="o">),</span>
           <span class="o">(</span><span class="k">match</span> <span class="n">author</span><span class="o">.</span><span class="n">uri</span> <span class="k">with</span>
             <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
             <span class="o">|</span> <span class="nc">Some</span> <span class="n">var2</span> <span class="o">-&gt;</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">var2</span> <span class="o">]))</span> <span class="o">]);</span>
      <span class="o">(</span><span class="k">match</span> <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">author</span><span class="o">.</span><span class="n">name</span> <span class="o">]</span> <span class="k">with</span>
       <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
         <span class="o">[</span> <span class="o">`</span><span class="nc">El</span> <span class="o">((((</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="s2">&quot;name&quot;</span><span class="o">),</span> <span class="bp">[]</span><span class="o">)</span> <span class="o">:</span> <span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">tag</span><span class="o">),</span> 
         <span class="o">[</span> <span class="o">`</span><span class="nc">Data</span> <span class="n">author</span><span class="o">.</span><span class="n">name</span> <span class="o">])</span> <span class="o">])</span> <span class="o">]</span>
</pre></div><p id="idp9128672">
      Notice that the <code>with xml</code> clause has been
      replaced with a new <code>xml_of_author</code> function that
      has been generated for you. It accepts an
      <code>author</code> value and returns an
      <code>Xml.t</code> value. The generated code isn't really
      meant to be human-readable, but you don't normally see it when
      using the syntax extension (we've only dumped it out here to
      illustrate how <code>camlp4</code> works).
    </p><p id="idp9132960">
      If we run <code>xml_of_author</code> and convert the result
      to a human-readable string, our complete example looks like:
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">author</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">uri</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">email</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="n">xml</span>

<span class="k">let</span> <span class="n">anil</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Anil Madhavapeddy&quot;</span><span class="o">;</span>
  <span class="n">uri</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">&quot;http://anil.recoil.org&quot;</span><span class="o">;</span>
  <span class="n">email</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">&quot;anil@recoil.org&quot;</span>
<span class="o">}</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print_endline</span> <span class="o">(</span><span class="nn">Cow</span><span class="p">.</span><span class="nn">Xml</span><span class="p">.</span><span class="n">to_string</span> <span class="o">(</span><span class="n">xml_of_author</span> <span class="n">anil</span><span class="o">))</span>
</pre></div><p id="idp9135712">
      This will generate the following XML output on the terminal when
      you execute it:
    </p><div class="highlight"><pre><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;email&gt;</span>anil@recoil.org<span class="nt">&lt;/email&gt;</span>
<span class="nt">&lt;uri&gt;</span>http://anil.recoil.org<span class="nt">&lt;/uri&gt;</span>
<span class="nt">&lt;name&gt;</span>Anil Madhavapeddy<span class="nt">&lt;/name&gt;</span>
</pre></div><p id="idp9137312">
      This is convenient, but just one small portion of Atom. How do we
      express the full Atom scheme from earlier? The answer is with just
      a few more records that match the Atom XML schema.
    </p><div class="highlight"><pre><span class="k">type</span> <span class="n">author</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">uri</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">email</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="n">xml</span>

<span class="k">type</span> <span class="n">date</span> <span class="o">=</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="c">(* year, month, date, hour, minute *)</span>
<span class="k">with</span> <span class="n">xml</span>

<span class="k">let</span> <span class="n">xml_of_date</span> <span class="o">(</span><span class="n">year</span><span class="o">,</span><span class="n">month</span><span class="o">,</span><span class="n">day</span><span class="o">,</span><span class="n">hour</span><span class="o">,</span><span class="n">min</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;%.4d-%.2d-%.2dT%.2d:%.2d:00Z&quot;</span> <span class="n">year</span> <span class="n">month</span> <span class="n">day</span> <span class="n">hour</span> <span class="n">min</span> <span class="k">in</span>
  <span class="o">&lt;:</span><span class="n">xml</span><span class="o">&lt;</span> <span class="o">$</span><span class="n">str</span><span class="o">:</span><span class="n">d</span><span class="o">$</span> <span class="o">&gt;&gt;</span>

<span class="k">type</span> <span class="n">meta</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">id</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">title</span><span class="o">:</span> <span class="kt">string</span><span class="o">;</span>
  <span class="n">subtitle</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">author</span><span class="o">:</span> <span class="n">author</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">rights</span><span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="o">;</span>
  <span class="n">updated</span><span class="o">:</span> <span class="n">date</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="n">xml</span>
</pre></div><p id="idp9139360">
      We've now filled in more of the Atom schema with these records.
      The first problem we run into is that occasionally there is a
      mismatch between the syntax extension's idea of what the
      auto-generated XML should look like, and the reality of the
      protocol you are mapping to.
    </p><p id="idp9140064">
      The Atom date field is a good example. We define it as a tuple of
      integers, but the format mandated by the specification is actually
      a free-form text format and not XML. However, because the syntax
      extension generates normal OCaml functions, we can just override
      the <code>xml_of_date</code> function with a custom one
      which returns the correct XML fragment. Any references further
      down the module will just use our overridden version and ignore
      the auto-generated one.
    </p><p id="idp9141680">
      There's another interesting bit of new syntax in the
      <code>xml_of_date</code> function known as a
      <span><em>quotation</em></span>. OCaml not only allows code to be
      generated during pre-processing, but also to override the core
      language grammar with new constructs. The most common way of doing
      this is by embedding the custom grammars inside
      <code>&lt;:foo&lt; ... &gt;&gt;</code> tags, where
      <code>foo</code> represents the particular grammar being
      used. In the case of COW, this lets you generate XMLM-compatible
      OCaml values just by typing in XML tags.
    </p><p id="idp9145120">
      TODO antiquotations.
    </p><p id="idp9145552">
      TODO finish the atom example.
    </p></section><section><h1 id="working-with-xhtml">Working with XHTML</h1><p id="idp9147216">
      TODO use Cow.Html to generate a more complete Atom feed.
    </p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="handling-json-data.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="fast-binary-serialization-with-bin_prot.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p>
            </footer>
            
        </div>
    
    </body>

</html>