<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 19. Foreign Function Interface / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta3',
                        page: 'foreign\u002Dfunction\u002Dinterface.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html" class="here">19. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="memory-representation-of-values.html">20. Memory Representation of Values</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">21. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-frontend-parsing-and-type-checking.html">22. The Compiler Frontend: Parsing and Type Checking</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-backend-byte-code-and-native-code.html">23. The Compiler Backend: Byte-code and Native-code</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 19. Foreign Function Interface</h1>
                
                

    <p id="idp11138016">
    OCaml has several options available to interact with non-OCaml code.
    The compiler can link with external system libraries via C code and
    also produce standalone native object files that can be embedded
    within other non-OCaml applications.
  </p><p id="idp11138672">
    The mechanism by which code in one programming language can invoke
    routines in another different programming language is called a
    <span><em>foreign function interface</em></span>. This chapter will:
  </p><ul><li><p id="idp11140192">
        show how to call routines in C libraries directly from your
        OCaml code.
      </p></li><li><p id="idp11141072">
        teach you how to build higher-level abstractions in OCaml from
        the low-level C bindings.
      </p></li><li><p id="idp11141968">
        work through some full examples for binding a terminal interface
        and UNIX date/time functions.
      </p></li></ul><p id="idp11142736">
    The simplest foreign function interface in OCaml doesn't even
    require you to write any C code at all! The Ctypes library lets you
    define the C interface in pure OCaml, and the library then takes
    care of loading the C symbols and invoking the foreign function
    call.
  </p><p id="idp11143424">
    Let's dive straight into a realistic example to show you how the
    library looks. We'll create a binding to the Ncurses terminal
    toolkit, as it's widely available on most systems and doesn't have
    any complex dependencies.
  </p><aside class="note"><h1>
  Installing the Ctypes library
  </h1><p id="idp11144752">
    You'll need to install the
    <a href="https://github.com/atgreen/libffi" target="_top"><code>libffi</code></a>
    library as a prerequisite to using Ctypes. It's a fairly popular
    library and should be available in your OS package manager.
  </p><p id="idp11146448">
    A special note for Mac users: the version of
    <code>libffi</code> installed by default in MacOS X 10.8 is
    too old for some of the features that Ctypes needs. Use Homebrew to
    <code>brew install libffi</code> to get the latest version
    before installing the OCaml library.
  </p><p id="idp11148480">
    Once that's done, Ctypes is available via OPAM as usual.
  </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> brew install libffi     <span class="c"># for MacOS X users</span>
</div><div class="highlight"><span class="gp">$</span> opam install ctypes
</div><div class="highlight"><span class="gp">$</span> utop
</div><div class="rwocodeout"># require &quot;ctypes.foreign&quot; ;;</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/install.out">ffi/install.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11149648">
    You'll also need the Ncurses library for the first example. This
    comes pre-installed on many operating systems such as MacOS X and
    Debian Linux provides it as the <code>ncurses-dev</code>
    package.
  </p></aside><section><h1 id="example-a-terminal-interface">Example: a terminal interface</h1><p id="idp11152208">
      Ncurses is a library to help build terminal-independent text
      interfaces in a reasonably efficient way. It's used in console
      mail clients like Mutt and Pine, and console web browsers such as
      Lynx.
    </p><p id="idp11152832">
      The full C interface is quite large and is explained in the online
      <a href="http://www.gnu.org/software/ncurses/" target="_top">documentation</a>.
      We'll just use the small excerpt that's shown below since we just
      want to demonstrate Ctypes in action.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_win_st</span> <span class="n">WINDOW</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chtype</span><span class="p">;</span>

<span class="n">WINDOW</span> <span class="o">*</span><span class="n">initscr</span>   <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">WINDOW</span> <span class="o">*</span><span class="n">newwin</span>    <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">endwin</span>    <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">refresh</span>   <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">wrefresh</span>  <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">addstr</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>     <span class="n">mvwaddch</span>  <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">chtype</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">mvwaddstr</span> <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>    <span class="n">box</span> <span class="p">(</span><span class="n">WINDOW</span> <span class="o">*</span><span class="p">,</span> <span class="n">chtype</span><span class="p">,</span> <span class="n">chtype</span><span class="p">);</span>
<span class="kt">int</span>     <span class="n">cbreak</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.h">ffi/ncurses.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11154864">
      The Ncurses functions either operate on the current
      pseudo-terminal or on a window that has been created via
      <code>newwin</code>. The <code>WINDOW</code> structure
      holds the internal library state and is considered abstract
      outside of Ncurses. Ncurses clients just need to store the pointer
      somewhere and pass it back to Ncurses library calls, which in turn
      dereference its contents.
    </p><p id="idp11157072">
      Note that there are over 200 library calls in Ncurses, so we're
      only binding a select few for this example. The
      <code>initscr</code> and <code>newwin</code> create
      <code>WINDOW</code> pointers for the global and sub-windows
      respectively. The <code>mvwaddrstr</code> takes a window,
      x/y offsets and a string and writes to the screen at that
      location. The terminal is only updated after
      <code>refresh</code> or <code>wrefresh</code> are
      called.
    </p><p id="idp11162096">
      Ctypes provides an OCaml interface that lets you map these C
      functions to equivalent OCaml functions. The library takes care of
      converting OCaml function calls and arguments into the C calling
      convention, invoking the foreign call within the C library and
      finally returning the result as an OCaml value.
    </p><p id="idp11162832">
      Let's begin by defining the basic values we need, starting with
      the <code>WINDOW</code> state pointer.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword6">Ctypes
</span>
<span class="keyword4">type</span> window <span class="keyword2">=</span> unit ptr
<span class="keyword4">let</span> window <span class="keyword2">:</span> window typ <span class="keyword2">=</span> ptr void</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.ml">ffi/ncurses.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11164752">
      We don't know the internal representation of the window pointer,
      so we treat it as a C void pointer. We'll improve on this later on
      in the chapter, but that's good enough for now. The second
      statement defines an OCaml value that represents the
      <code>WINDOW</code> C pointer. This value is used later in
      the Ctypes function definitions.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword6">Foreign
</span>
<span class="keyword4">let</span> initscr <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;initscr&quot;</span> <span class="keyword2">(</span>void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning window<span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.ml">ffi/ncurses.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11166928">
      That's all we need to invoke our first function call to
      <code>initscr</code> to initialize the terminal. The
      <code>foreign</code> function accepts two parameters:
    </p><ul><li><p id="idp11169376">
          the C function call name, which is looked up using the
          <code>dlsym</code> POSIX function.
        </p></li><li><p id="idp11170976">
          a value that defines the complete set of C function arguments
          and its return type. The <code>@-&gt;</code> operator
          adds an argument to the C parameter list and
          <code>returning</code> terminates the parameter list
          with the return type.
        </p></li></ul><p id="idp11173296">
      The remainder of the Ncurses binding simply expands on these
      definitions.
    </p><div class="rwocode"><pre><code><span class="keyword4">let</span> newwin <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;newwin&quot;</span> 
    <span class="keyword2">(</span><span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning window<span class="keyword2">)</span>

<span class="keyword4">let</span> endwin <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;endwin&quot;</span> <span class="keyword2">(</span>void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> refresh <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;refresh&quot;</span> <span class="keyword2">(</span>void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> wrefresh <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;wrefresh&quot;</span> <span class="keyword2">(</span>window <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> addstr <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;addstr&quot;</span> <span class="keyword2">(</span><span class="keyword3">string</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> mvwaddch <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;mvwaddch&quot;</span>
    <span class="keyword2">(</span>window <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> char <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> mvwaddstr <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;mvwaddstr&quot;</span>
    <span class="keyword2">(</span>window <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">int</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> <span class="keyword3">string</span> <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> box <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;box&quot;</span> <span class="keyword2">(</span>window <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> char <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> char <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> cbreak <span class="keyword2">=</span>
  foreign <span class="keyword7">&quot;cbreak&quot;</span> <span class="keyword2">(</span>void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">int</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.ml">ffi/ncurses.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11174512">
      These definitions are all straightforward mappings from the C
      declarations in the Ncurses header file. Note that the
      <code>string</code> and <code>int</code> values here
      are nothing to do with OCaml type declarations; instead, they are
      values that come from opening the <code>Ctypes</code> module
      at the top of the file.
    </p><p id="idp11177328">
      Most of the parameters in the Ncurses example represent fairly
      simple scalar C types except for <code>window</code> (a
      pointer to the library state), and <code>string</code>,
      which maps from OCaml strings that have a specific length onto C
      character buffers whose length is defined by a terminating null
      character that immediately follows the string data.
    </p><p id="idp11179504">
      The module signature for <code>ncurses.mli</code> looks much
      like a normal OCaml signature. You can infer it directly from the
      <code>ncurses.ml</code> by running a special build target.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign ncurses.inferred.mli
</div><div class="highlight"><span class="gp">$</span> cp _build/ncurses.inferred.mli .
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/infer_ncurses.out">ffi/infer_ncurses.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11182208">
      The <code>inferred.mli</code> target instructs the compiler
      to generate the default signature for a module file, and places it
      in the <code>_build</code> directory as a normal output. You
      should normally copy it out into your source directory and
      customize it improve its safety for external callers by making
      some of its internals more abstract.
    </p><p id="idp11184368">
      Here's the customized interface that we can safely use from other
      libraries.
    </p><div class="rwocode"><pre><code><span class="keyword4">type</span> window
<span class="keyword4">val</span> window <span class="keyword2">:</span> window <span class="keyword5">Ctypes.</span>typ
<span class="keyword4">val</span> initscr <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> window
<span class="keyword4">val</span> endwin <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> refresh <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> wrefresh <span class="keyword2">:</span> window -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> newwin <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> window
<span class="keyword4">val</span> mvwaddch <span class="keyword2">:</span> window -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> char -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> addstr <span class="keyword2">:</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> mvwaddstr <span class="keyword2">:</span> window -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> box <span class="keyword2">:</span> window -<span class="keyword2">&gt;</span> char -<span class="keyword2">&gt;</span> char -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> cbreak <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> <span class="keyword3">int</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/ncurses.mli">ffi/ncurses.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11185568">
      The <code>window</code> type is left abstract in the
      signature to ensure that window pointers can only be constructed
      via the <code>Ncurses.initscr</code> function. This prevents
      void pointers obtained from other sources from being mistakenly
      passed to an Ncurses library call.
    </p><p id="idp11187648">
      Now compile a &quot;hello world&quot; terminal drawing program to
      tie this all together.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword6">Ncurses
</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> main_window <span class="keyword2">=</span> initscr <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  ignore<span class="keyword2">(</span>cbreak <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword4">let</span> small_window <span class="keyword2">=</span> newwin <span class="keyword8">10</span> <span class="keyword8">10</span> <span class="keyword8">5</span> <span class="keyword8">5</span> <span class="keyword4">in</span>
  mvwaddstr main_window <span class="keyword8">1</span> <span class="keyword8">2</span> <span class="keyword7">&quot;Hello&quot;</span><span class="keyword2">;</span>
  mvwaddstr small_window <span class="keyword8">2</span> <span class="keyword8">2</span> <span class="keyword7">&quot;World&quot;</span><span class="keyword2">;</span>
  box small_window '\<span class="keyword8">000</span>' '\<span class="keyword8">000</span>'<span class="keyword2">;</span>
  refresh <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword5">Unix.</span>sleep <span class="keyword8">1</span><span class="keyword2">;</span>
  wrefresh small_window<span class="keyword2">;</span>
  <span class="keyword5">Unix.</span>sleep <span class="keyword8">5</span><span class="keyword2">;</span>
  endwin <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/hello.ml">ffi/hello.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11188960">
      The <code>hello</code> executable is compiled by linking
      with the <code>ctypes.foreign</code> OCamlfind package.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign -lflags -cclib,-lncurses hello.native 
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/build_hello.out">ffi/build_hello.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11191584">
      Running <code>./hello.native</code> should now display a
      Hello World in your terminal!
    </p><aside class="note"><h1>
    On build directives for Ctypes
    </h1><p id="idp11193472">
      The command-line above include some important extra link
      directives. The <code>-lflags</code> instructs
      <span><strong>ocamlbuild</strong></span> to pass the next comma-separated set
      of arguments through to the <span><strong>ocaml</strong></span> command when
      linking a binary. OCaml in turn uses <code>-cclib</code> to
      pass directives through to the system compiler (normally
      <span><strong>gcc</strong></span> or <span><strong>clang</strong></span>. We first need
      to link to the <code>ncurses</code> C library to make the
      symbols available to Ctypes, and
      <code>-cclib,-lncurses</code> does that.
    </p><p id="idp11199968">
      On some distributions such as Ubuntu 11.10 upwards, you'll also
      need to add
      <code>-cclib,-Xlinker,-cclib,--no-as-needed</code> to the
      <code>-lflags</code> directive. <code>-Xlinker</code>
      is interpreted by the compiler as a directive for the system
      linker <span><strong>ld</strong></span>, to which it passes
      <code>--no-as-needed</code>. Several modern OS distributions
      (such as Ubuntu 11.10 onwards) configure the system linker to only
      link in libraries that directly contain symbols used by the
      program. However, when we use Ctypes, those symbols are not
      referenced until runtime, which results an exception due to the
      library not being available.
    </p><p id="idp11204512">
      The <code>--no-as-needed</code> flag disables this behavior
      and ensures all the specified libraries are linked despite not
      being directly used. The flag unfortunately doesn't work
      everywhere (notably, MacOS X should <span><em>not</em></span> have
      this passed to it).
    </p></aside><p id="idp11206400">
      Ctypes wouldn't be very useful if it were limited to only defining
      simple C types of course. It provides full support for C pointer
      arithmetic, pointer conversions, reading and writing through
      pointers, using OCaml functions as function pointers to C code, as
      well as struct and union definitions.
    </p><p id="idp11207136">
      We'll go over some of these features in more detail for the
      remainder of the chapter by using some POSIX date functions as
      running examples.
    </p></section><section><h1 id="basic-scalar-c-types">Basic scalar C types</h1><p id="idp11208864">
      First, let's look at how to define basic scalar C types. Every C
      type is represented by an OCaml equivalent via the single type
      definition below.
    </p><div class="rwocode"><pre><code><span class="keyword4">type</span> 'a typ</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11210160">
<code>Ctypes.typ</code> is the type of values that
      represents C types to OCaml. There are two types associated with
      each instance of <code>typ</code>:
    </p><ul><li><p id="idp11212624">
          the C type used to store and pass values to the foreign
          library.
        </p></li><li><p id="idp11213504">
          the corresponding OCaml type. The <code>'a</code> type
          parameter contains the OCaml type such that a value of type
          <code>t typ</code> is used to read and write OCaml
          values of type <code>t</code>.
        </p></li></ul><p id="idp11216416">
      There are various other uses of <code>typ</code> values
      within Ctypes, such as:
    </p><ul><li><p id="idp11218080">
          constructing function types for binding native functions.
        </p></li><li><p id="idp11218944">
          constructing pointers for reading and writing locations in
          C-managed storage.
        </p></li><li><p id="idp11219840">
          describing component fields of structures, unions and arrays.
        </p></li></ul><p id="idp11220576">
      Here are the definitions for most of the standard C99 scalar
      types, including some platform-dependent ones.
    </p><div class="rwocode"><pre><code><span class="keyword4">val</span> void      <span class="keyword2">:</span> unit typ
<span class="keyword4">val</span> char      <span class="keyword2">:</span> char typ
<span class="keyword4">val</span> schar     <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> short     <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> <span class="keyword3">int</span>       <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> long      <span class="keyword2">:</span> long typ
<span class="keyword4">val</span> llong     <span class="keyword2">:</span> llong typ
<span class="keyword4">val</span> nativeint <span class="keyword2">:</span> nativeint typ

<span class="keyword4">val</span> int8_t    <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> int16_t   <span class="keyword2">:</span> <span class="keyword3">int</span> typ
<span class="keyword4">val</span> int32_t   <span class="keyword2">:</span> int32 typ
<span class="keyword4">val</span> int64_t   <span class="keyword2">:</span> int64 typ
<span class="keyword4">val</span> uchar     <span class="keyword2">:</span> uchar typ
<span class="keyword4">val</span> uchar     <span class="keyword2">:</span> uchar typ
<span class="keyword4">val</span> uint8_t   <span class="keyword2">:</span> uint8 typ
<span class="keyword4">val</span> uint16_t  <span class="keyword2">:</span> uint16 typ
<span class="keyword4">val</span> uint32_t  <span class="keyword2">:</span> uint32 typ
<span class="keyword4">val</span> uint64_t  <span class="keyword2">:</span> uint64 typ
<span class="keyword4">val</span> size_t    <span class="keyword2">:</span> size_t typ
<span class="keyword4">val</span> ushort    <span class="keyword2">:</span> ushort typ
<span class="keyword4">val</span> uint      <span class="keyword2">:</span> uint typ
<span class="keyword4">val</span> ulong     <span class="keyword2">:</span> ulong typ
<span class="keyword4">val</span> ullong    <span class="keyword2">:</span> ullong typ

<span class="keyword4">val</span> <span class="keyword3">float</span>     <span class="keyword2">:</span> <span class="keyword3">float</span> typ
<span class="keyword4">val</span> double    <span class="keyword2">:</span> <span class="keyword3">float</span> typ

<span class="keyword4">val</span> complex32 <span class="keyword2">:</span> <span class="keyword5">Complex.</span>t typ
<span class="keyword4">val</span> complex64 <span class="keyword2">:</span> <span class="keyword5">Complex.</span>t typ</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11221824">
      These values are all of type <code>'a typ</code>, where the
      value name (<span><em>e.g.</em></span> <code>void</code>)
      tells you the C type and the <code>'a</code> component
      (<span><em>e.g.</em></span> <code>unit</code>) is the OCaml
      representation of that C type. Most of the mappings are
      straightforward, but some of them need a bit more explanation.
    </p><ul><li><p id="idp11226608">
          Void values appear in OCaml as the <code>unit</code>
          type. Using <code>void</code> in an argument or result
          type specification produces an OCaml function which accepts or
          returns unit. Dereferencing a pointer to
          <code>void</code> is an error, as in C, and will raise
          the <code>IncompleteType</code> exception.
        </p></li><li><p id="idp11230496">
          The C <code>size_t</code> type is an alias for one of
          the unsigned integer types. The actual size and alignment
          requirements for <code>size_t</code> varies between
          platforms. Ctypes provides an OCaml <code>size_t</code>
          type that is aliased to the appropriate integer type.
        </p></li><li><p id="idp11233680">
          OCaml only supports double-precision floating-point numbers,
          and so the C <code>float</code> and
          <code>double</code> types both map onto the OCaml
          <code>float</code> type, and the C
          <code>float complex</code> and
          <code>double complex</code> types both map onto the
          OCaml double-precision <code>Complex.t</code> type.
        </p></li></ul></section><section><h1 id="pointers-and-arrays">Pointers and arrays</h1><p id="idp11240016">
      Pointers are at the heart of C, so they are necessarily part of
      Ctypes, which provides support for pointer arithmetic, pointer
      conversions, reading and writing through pointers, and passing and
      returning pointers to and from functions.
    </p><p id="idp11240688">
      We've already seen a simple use of pointers in the Ncurses
      example. Let's start a new example by binding the following POSIX
      functions.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="kt">time_t</span> <span class="n">time</span><span class="p">(</span><span class="kt">time_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">difftime</span><span class="p">(</span><span class="kt">time_t</span><span class="p">,</span> <span class="kt">time_t</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ctime</span><span class="p">(</span><span class="k">const</span> <span class="kt">time_t</span> <span class="o">*</span><span class="n">timep</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix_headers.h">ffi/posix_headers.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11241952">
      The <code>time</code> function returns the current calendar
      time and is a simple start. The first step is to open some of the
      Ctypes modules.
    </p><ul><li><p id="idp11243728">
          The <code>Ctypes</code> module provides functions for
          describing C types in OCaml.
        </p></li><li><p id="idp11245312">
          The <code>PosixTypes</code> module includes some extra
          POSIX-specific types (such as <code>time_t</code>).
        </p></li><li><p id="idp11247600">
          The <code>Foreign</code> module exposes the
          <code>foreign</code> function that makes it possible to
          invoke C functions.
        </p></li></ul><p id="idp11249792">
      We can now create a binding to <code>time</code> directly
      from the top-level.
    </p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;ctypes.foreign&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword7">#require</span> <span class="keyword7">&quot;ctypes.top&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">Ctypes </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">PosixTypes </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">Foreign </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword4">let</span> time <span class="keyword2">=</span> foreign <span class="keyword7">&quot;time&quot;</span> <span class="keyword2">(</span>ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning time_t<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val time : time_t ptr -&gt; time_t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11251696">
      The <code>foreign</code> function is the main link between
      OCaml and C. It takes two arguments: the name of the C function to
      bind, and a value describing the type of the bound function. In
      the <code>time</code> binding, the function type specifies
      one argument of type <code>ptr time_t</code> and a return
      type of <code>time_t</code>.
    </p><p id="idp11255232">
      We can now call <code>time</code> immediately in the same
      top-level. The argument is actually optional, so we'll just pass a
      null pointer that has been coerced into becoming a null pointer to
      <code>time_t</code>.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> cur_time <span class="keyword2">=</span> time <span class="keyword2">(</span>from_voidp time_t null<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val cur_time : time_t = 1376834134
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11257968">
      Since we're going to call <code>time</code> a few times,
      let's create a wrapper function that passes the null pointer
      through.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> time' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> time <span class="keyword2">(</span>from_voidp time_t null<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val time' : unit -&gt; time_t = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11259920">
      Since <code>time_t</code> is an abstract type, we can't
      actually do anything useful with it directly. We need to bind a
      second function to do anything useful with the return values from
      <code>time</code>. We'll move on to
      <code>difftime</code>; the second C function in our
      prototype list above.
    </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> difftime <span class="keyword2">=</span>
    foreign <span class="keyword7">&quot;difftime&quot;</span> <span class="keyword2">(</span>time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning double<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val difftime : time_t -&gt; time_t -&gt; float = &lt;fun&gt;
</div># <span class="keyword4">let</span> t1 <span class="keyword2">=</span>
    time' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span>
    <span class="keyword5">Unix.</span>sleep <span class="keyword8">2</span><span class="keyword2">;</span>
    <span class="keyword4">let</span> t2 <span class="keyword2">=</span> time' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword4">in</span> 
    difftime t2 t1 <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : float = 2.
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11263440">
      The binding to <code>difftime</code> above is sufficient to
      compare two <code>time_t</code> values.
    </p><section><h1 id="allocating-typed-memory-for-pointers">Allocating typed memory for pointers</h1><p id="idp11266416">
        Let's look at a slightly less trivial example where we pass a
        non-null pointer to a function. Continuing with the theme from
        earlier, we'll bind to the <code>ctime</code> function
        which converts a <code>time_t</code> value to a
        human-readable string.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> ctime <span class="keyword2">=</span> foreign <span class="keyword7">&quot;ctime&quot;</span> <span class="keyword2">(</span>ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">string</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val ctime : time_t ptr -&gt; string = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11269200">
        The binding is continued in the top-level to add to our growing
        collection. However, we can't just pass the result of
        <code>time</code> to <code>ctime</code>.
      </p><div class="rwocode"><pre><code># ctime <span class="keyword2">(</span>time' <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">Characters 7-15:
Error: This expression has type time_t but an expression was expected of type
         time_t ptr
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11271904">
        This is because <code>ctime</code> needs a pointer to the
        <code>time_t</code> rather than passing it by value. We
        thus need to allocate some memory for the
        <code>time_t</code> and obtain its memory address.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> t_ptr <span class="keyword2">=</span> allocate time_t <span class="keyword2">(</span>time' <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val t_ptr : time_t ptr = (int64_t*) 0x238ac30
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 6) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11275328">
        The <code>allocate</code> function takes the type of the
        memory to be allocated and the initial value, and it returns a
        suitably-typed pointer. We can now call <code>ctime</code>
        passing the pointer as an argument:
      </p><div class="rwocode"><pre><code># ctime t_ptr <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : string = &quot;Sun Aug 18 14:55:36 2013\n&quot;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 7) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="using-views-to-map-complex-values">Using views to map complex values</h1><p id="idp11279392">
        While scalar types typically have a 1:1 representation, other C
        types require extra work to convert them into OCaml. Views
        create new C type descriptions that have special behavior when
        used to read or write C values.
      </p><p id="idp11280048">
        We've already used one view in the definition of
        <code>ctime</code> earlier. The <code>string</code>
        view wraps the C type <code>char *</code> (written in
        OCaml as <code>ptr char</code>), and converts between the
        C and OCaml string representations each time the value is
        written or read.
      </p><p id="idp11283536">
        Here is the type signature of the <code>Ctypes.view</code>
        function.
      </p><div class="rwocode"><pre><code><span class="keyword4">val</span> view <span class="keyword2">:</span>
  read<span class="keyword2">:</span><span class="keyword2">(</span>'a -<span class="keyword2">&gt;</span> 'b<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
  write<span class="keyword2">:</span><span class="keyword2">(</span>'b -<span class="keyword2">&gt;</span> 'a<span class="keyword2">)</span> -<span class="keyword2">&gt;</span>
  'a typ -<span class="keyword2">&gt;</span> 'b typ</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11285440">
        Ctypes has some internal low-level conversion functions that map
        between an OCaml <code>string</code> and a C character
        buffer by copying the contents into the respective data
        structure. They have the following type signature.
      </p><div class="rwocode"><pre><code><span class="keyword4">val</span> string_of_char_ptr <span class="keyword2">:</span> char ptr -<span class="keyword2">&gt;</span> <span class="keyword3">string</span>
<span class="keyword4">val</span> char_ptr_of_string <span class="keyword2">:</span> <span class="keyword3">string</span> -<span class="keyword2">&gt;</span> char ptr</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11287504">
        Given these functions, the definition of the
        <code>Ctypes.string</code> value that uses views is quite
        simple.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword3">string</span> <span class="keyword2">=</span> 
  view <span class="keyword2">(</span>char ptr<span class="keyword2">)</span>
    ~read<span class="keyword2">:</span>string_of_char_ptr 
    ~write<span class="keyword2">:</span>char_ptr_of_string</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes_impl.ml">ctypes/ctypes_impl.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11289440">
        The type of this <code>string</code> function is a normal
        <code>typ</code> with no external sign of the use of the
        view function.
      </p><div class="rwocode"><pre><code><span class="keyword4">val</span> <span class="keyword3">string</span>    <span class="keyword2">:</span> <span class="keyword3">string</span>.typ</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 4) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="note"><h1>
      OCaml strings versus C character buffers
      </h1><p id="idp11292768">
        Although OCaml strings may look like C character buffers from an
        interface perspective, they're very different in terms of their
        memory representations.
      </p><p id="idp11293360">
        OCaml strings are stored in the OCaml heap with a header that
        explicitly defines their length. C buffers are also
        fixed-length, but by convention a C string is terminated by a
        null (a <code>\0</code> byte) character. The C string
        functions calculate their length by scanning the buffer until
        the first null character is encountered.
      </p><p id="idp11294864">
        This means that you need to be careful that OCaml strings that
        you pass to C functions don't contain any null values, since the
        first occurrence of a null character will be treated as the end
        of the C string. Ctypes also defaults to a
        <span><em>copying</em></span> interface for strings, which means
        that you shouldn't use them when you want the library to mutate
        the buffer in-place. In that situation, use the Ctypes
        <code>Bigarray</code> support to pass memory by reference
        instead.
      </p></aside></section></section><section><h1 id="structs-and-unions">Structs and unions</h1><p id="idp11298448">
      The C constructs <code>struct</code> and
      <code>union</code> make it possible to build new types from
      existing types. Ctypes contains counterparts that work similarly.
    </p><section><h1 id="defining-a-structure">Defining a structure</h1><p id="idp11301520">
        Let's improve the timer function that we wrote earlier. The
        POSIX function <code>gettimeofday</code> retrieves the
        time with microsecond resolution. The signature of
        <code>gettimeofday</code> is as follows, including the
        structure definitions.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="k">struct</span> <span class="n">timeval</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="n">tv_sec</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">tv_usec</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">gettimeofday</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tv</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/timeval_headers.h">ffi/timeval_headers.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11304272">
        Using Ctypes, we can describe this type as follows in our
        top-level, continuing on from the previous definitions.
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> timeval <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type timeval
</div># <span class="keyword4">let</span> timeval <span class="keyword2">:</span> timeval structure typ <span class="keyword2">=</span> structure <span class="keyword7">&quot;timeval&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val timeval : timeval structure typ = struct timeval
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 8) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11305536">
        The first command defines a new OCaml type
        <code>timeval</code> that we'll use to instantiate the
        OCaml version of the struct. This is a <span><em>phantom
        type</em></span> that exists only to distinguish the underlying C
        type from other pointer types. The particular
        <code>timeval</code> structure now has a distinct type
        from other structures we define elsewhere, which helps to avoid
        getting them mixed up.
      </p><p id="idp11308176">
        The second command calls <code>structure</code> to create
        a fresh structure type. At this point the structure type is
        incomplete: we can add fields but cannot yet use it in
        <code>foreign</code> calls or use it to create values.
      </p></section><section><h1 id="adding-fields-to-structures">Adding fields to structures</h1><p id="idp11311536">
        The <code>timeval</code> structure definition still
        doesn't have any fields, so we need to add those next.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> tv_sec  <span class="keyword2">=</span> field timeval <span class="keyword7">&quot;tv_sec&quot;</span> long <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val tv_sec : (Signed.long, (timeval, [ `Struct ]) structured) field = &lt;abstr&gt;
</div># <span class="keyword4">let</span> tv_usec <span class="keyword2">=</span> field timeval <span class="keyword7">&quot;tv_usec&quot;</span> long <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val tv_usec : (Signed.long, (timeval, [ `Struct ]) structured) field =
  &lt;abstr&gt;
</div># seal timeval <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : unit = ()
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 9) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11313472">
        The <code>field</code> function appends a field to the
        structure, as shown with <code>tv_sec</code> and
        <code>tv_usec</code> above. Structure fields are typed
        accessors that are associated with a particular structure, and
        they correspond to the labels in C.
      </p><p id="idp11316240">
        Every field addition mutates the structure variable and records
        a new size (the exact value of which depends on the type of the
        field that was just added). Once we <code>seal</code> the
        structure we will be able to create values using it, but adding
        fields to a sealed structure is an error.
      </p></section><section><h1 id="incomplete-structure-definitions">Incomplete structure definitions</h1><p id="idp11318992">
        Since <code>gettimeofday</code> needs a
        <code>struct timezone</code> pointer for its second
        argument, we also need to define a second structure type.
      </p><div class="rwocode"><pre><code># <span class="keyword4">type</span> timezone <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type timezone
</div># <span class="keyword4">let</span> timezone <span class="keyword2">:</span> timezone structure typ <span class="keyword2">=</span> structure <span class="keyword7">&quot;timezone&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val timezone : timezone structure typ = struct timezone
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 10) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11321648">
        We don't ever need to create <code>struct timezone</code>
        values, so we can leave this struct as incomplete without adding
        any fields or sealing it. If you ever try to use it in a
        situation where its concrete size needs to be known, the library
        will raise an <code>IncompleteType</code> exception.
      </p><p id="idp11323744">
        We're finally ready to bind to <code>gettimeofday</code>
        now.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> gettimeofday <span class="keyword2">=</span> foreign <span class="keyword7">&quot;gettimeofday&quot;</span>
    <span class="keyword2">(</span>ptr timeval <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> ptr timezone <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning_checking_errno <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val gettimeofday : timeval structure ptr -&gt; timezone structure ptr -&gt; int =
  &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 11) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11325632">
        There's one other new feature here: the
        <code>returning_checking_errno</code> function behaves
        like <code>returning</code>, except that it checks whether
        the bound C function modifies the C error flag. Changes to
        <code>errno</code> are mapped into OCaml exceptions and
        raise a <code>Unix.Unix_error</code> exception just as the
        standard library functions do.
      </p><p id="idp11329184">
        As before we can create a wrapper to make
        <code>gettimeofday</code> easier to use. The functions
        <code>make</code>, <code>addr</code> and
        <code>getf</code> create a structure value, retrieve the
        address of a structure value, and retrieve the value of a field
        from a structure.
      </p><div class="rwocode"><pre><code># <span class="keyword4">let</span> gettimeofday' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> tv <span class="keyword2">=</span> make timeval <span class="keyword4">in</span>
  ignore<span class="keyword2">(</span>gettimeofday <span class="keyword2">(</span>addr tv<span class="keyword2">)</span> <span class="keyword2">(</span>from_voidp timezone null<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword4">let</span> secs <span class="keyword2">=</span> <span class="keyword5">Signed.</span><span class="keyword5">Long.</span><span class="keyword2">(</span>to_int <span class="keyword2">(</span>getf tv tv_sec<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> usecs <span class="keyword2">=</span> <span class="keyword5">Signed.</span><span class="keyword5">Long.</span><span class="keyword2">(</span>to_int <span class="keyword2">(</span>getf tv tv_usec<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword5">Pervasives.</span><span class="keyword2">(</span><span class="keyword3">float</span> secs <span class="keyword2">+</span>. <span class="keyword3">float</span> usecs /. <span class="keyword8">1000000</span>.<span class="keyword8">0</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val gettimeofday' : unit -&gt; float = &lt;fun&gt;
</div># gettimeofday' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">- : float = 1376834137.14
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/posix.topscript">ffi/posix.topscript</a> , continued (part 12) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11333360">
        You need to be a little careful not to get all the open modules
        mixed up here. Both <code>Pervasives</code> and
        <code>Ctypes</code> define different
        <code>float</code> functions. The
        <code>Ctypes</code> module we opened up earlier overrides
        the <code>Pervasives</code> definition. As seen above
        though, you just need to locally open
        <code>Pervasives</code> again to bring the usual
        <code>float</code> function back in scope,
      </p><section><h1 id="recap-a-time-printing-command">Recap: a time-printing command</h1><p id="idp11340256">
          We built up a lot of bindings in the earlier section, so let's
          recap them with a complete example that ties it together with
          a command-line frontend.
        </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword6">Ctypes
</span><span class="keyword1">open</span> <span class="keyword6">PosixTypes
</span><span class="keyword1">open</span> <span class="keyword6">Foreign
</span>
<span class="keyword4">let</span> time     <span class="keyword2">=</span> foreign <span class="keyword7">&quot;time&quot;</span> <span class="keyword2">(</span>ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning time_t<span class="keyword2">)</span>
<span class="keyword4">let</span> difftime <span class="keyword2">=</span> foreign <span class="keyword7">&quot;difftime&quot;</span> <span class="keyword2">(</span>time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning double<span class="keyword2">)</span>
<span class="keyword4">let</span> ctime    <span class="keyword2">=</span> foreign <span class="keyword7">&quot;ctime&quot;</span> <span class="keyword2">(</span>ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">string</span><span class="keyword2">)</span>

<span class="keyword4">type</span> timeval
<span class="keyword4">let</span> timeval <span class="keyword2">:</span> timeval structure typ <span class="keyword2">=</span> structure <span class="keyword7">&quot;timeval&quot;</span>
<span class="keyword4">let</span> tv_sec   <span class="keyword2">=</span> field timeval <span class="keyword7">&quot;tv_sec&quot;</span> long
<span class="keyword4">let</span> tv_usec  <span class="keyword2">=</span> field timeval <span class="keyword7">&quot;tv_usec&quot;</span> long
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span>       <span class="keyword2">=</span> seal timeval

<span class="keyword4">type</span> timezone
<span class="keyword4">let</span> timezone <span class="keyword2">:</span> timezone structure typ <span class="keyword2">=</span> structure <span class="keyword7">&quot;timezone&quot;</span>

<span class="keyword4">let</span> gettimeofday <span class="keyword2">=</span> foreign <span class="keyword7">&quot;gettimeofday&quot;</span>
    <span class="keyword2">(</span>ptr timeval <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> ptr timezone <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning_checking_errno <span class="keyword3">int</span><span class="keyword2">)</span>

<span class="keyword4">let</span> time' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> time <span class="keyword2">(</span>from_voidp time_t null<span class="keyword2">)</span>

<span class="keyword4">let</span> gettimeofday' <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> tv <span class="keyword2">=</span> make timeval <span class="keyword4">in</span>
  ignore<span class="keyword2">(</span>gettimeofday <span class="keyword2">(</span>addr tv<span class="keyword2">)</span> <span class="keyword2">(</span>from_voidp timezone null<span class="keyword2">)</span><span class="keyword2">)</span><span class="keyword2">;</span>
  <span class="keyword4">let</span> secs <span class="keyword2">=</span> <span class="keyword5">Signed.</span><span class="keyword5">Long.</span><span class="keyword2">(</span>to_int <span class="keyword2">(</span>getf tv tv_sec<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> usecs <span class="keyword2">=</span> <span class="keyword5">Signed.</span><span class="keyword5">Long.</span><span class="keyword2">(</span>to_int <span class="keyword2">(</span>getf tv tv_usec<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword5">Pervasives.</span><span class="keyword2">(</span><span class="keyword3">float</span> secs <span class="keyword2">+</span>. <span class="keyword3">float</span> usecs /. <span class="keyword8">1_000_000</span>.<span class="keyword2">)</span>

<span class="keyword4">let</span> float_time <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> printf <span class="keyword7">&quot;%f%!\n&quot;</span> <span class="keyword2">(</span>gettimeofday' <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span>

<span class="keyword4">let</span> ascii_time <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> t_ptr <span class="keyword2">=</span> allocate time_t <span class="keyword2">(</span>time' <span class="keyword2">(</span><span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  printf <span class="keyword7">&quot;%s%!&quot;</span> <span class="keyword2">(</span>ctime t_ptr<span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword6">Command </span><span class="keyword4">in</span>
  basic ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Display the current time in various formats&quot;</span>
    <span class="keyword5">Spec.</span><span class="keyword2">(</span>empty <span class="keyword2">+</span><span class="keyword2">&gt;</span> flag <span class="keyword7">&quot;-a&quot;</span> no_arg ~doc<span class="keyword2">:</span><span class="keyword7">&quot; Human-readable output format&quot;</span><span class="keyword2">)</span>
    <span class="keyword2">(</span><span class="keyword1">fun</span> human -<span class="keyword2">&gt;</span> <span class="keyword1">if</span> human <span class="keyword1">then</span> ascii_time <span class="keyword1">else</span> float_time<span class="keyword2">)</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/datetime.ml">ffi/datetime.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11341552">
          This can be compiled and run in the usual way.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign datetime.native
</div><div class="highlight"><span class="gp">$</span> ./datetime.native
</div><div class="rwocodeout">1376833554.984496</div><div class="highlight"><span class="gp">$</span> ./datetime.native -a
</div><div class="rwocodeout">Sun Aug 18 14:45:55 2013</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/build_datetime.out">ffi/build_datetime.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><section><h1><b>
        Why do we need to use <code>returning</code>?
        </b></h1><p id="idp11344144">
          The alert reader may be curious why all these function
          definitions have to be terminated by
          <code>returning</code>.
        </p><div class="rwocode"><pre><code><span class="comments">(* correct types *)</span>
<span class="keyword4">val</span> time<span class="keyword2">:</span> ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning time_t
<span class="keyword4">val</span> difftime<span class="keyword2">:</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning double</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_frag.ml">ffi/return_frag.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11346112">
          The <code>returning</code> function may appear
          superfluous here. Why couldn't we simply give the types as
          follows?
        </p><div class="rwocode"><pre><code><span class="comments">(* incorrect types *)</span>
<span class="keyword4">val</span> time<span class="keyword2">:</span> ptr time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t
<span class="keyword4">val</span> difftime<span class="keyword2">:</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> time_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> double</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_frag.ml">ffi/return_frag.ml</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11348064">
          The reason involves higher types and two differences between
          the way that functions are treated in OCaml and C. Functions
          are first-class values in OCaml, but not in C. For example, in
          C, it is possible to return a function pointer from a
          function, but not to return an actual function.
        </p><p id="idp11348816">
          Secondly, OCaml functions are typically defined in a curried
          style. The signature of a two-argument function is written as
          follows:
        </p><div class="rwocode"><pre><code><span class="keyword4">val</span> curried <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_frag.ml">ffi/return_frag.ml</a> , continued (part 2) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11350112">
          but this really means
        </p><div class="rwocode"><pre><code><span class="keyword4">val</span> curried <span class="keyword2">:</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span><span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_frag.ml">ffi/return_frag.ml</a> , continued (part 3) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11351280">
          and the arguments can be supplied one at a time to create a
          closure. In contrast, C functions receive their arguments all
          at once. The equivalent C function type is the following:
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="kt">int</span> <span class="n">uncurried_C</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_c_frag.h">ffi/return_c_frag.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11352608">
          and the arguments must always be supplied together:
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="n">uncurried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_c_frag.c">ffi/return_c_frag.c</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11353776">
          A C function that's written in curried style looks very
          different:
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="cm">/* A function that accepts an int, and returns a function</span>
<span class="cm">   pointer that accepts a second int and returns an int. */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">function_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">function_t</span> <span class="o">*</span><span class="n">curried_C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* supply both arguments */</span>
<span class="n">curried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">);</span>

<span class="cm">/* supply one argument at a time */</span>
<span class="n">function_t</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">curried_C</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/return_c_uncurried.c">ffi/return_c_uncurried.c</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11354992">
          The OCaml type of <code>uncurried_C</code> when bound by
          Ctypes is <code>int -&gt; int -&gt; int</code>: a
          two-argument function. The OCaml type of
          <code>curried_C</code> when bound by
          <code>ctypes</code> is
          <code>int -&gt; (int -&gt; int)</code>: a one-argument
          function that returns a one-argument function.
        </p><p id="idp11359200">
          In OCaml, of course, these types are absolutely equivalent.
          Since the OCaml types are the same but the C semantics are
          quite different, we need some kind of marker to distinguish
          the cases. This is the purpose of <code>returning</code>
          in function definitions.
        </p></section></section></section><section><h1 id="defining-arrays">Defining arrays</h1><p id="idp11362032">
        Arrays in C are contiguous blocks of the same type of value. Any
        of the basic types defined earlier can be allocated as blocks
        via the <code>Array</code> module.
      </p><div class="rwocode"><pre><code><span class="keyword4">module</span> <span class="keyword6">Array </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
  <span class="keyword4">type</span> 'a t <span class="keyword2">=</span> 'a <span class="keyword3">array</span>

  <span class="keyword4">val</span> get <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> 'a
  <span class="keyword4">val</span> set <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> unit
  <span class="keyword4">val</span> of_list <span class="keyword2">:</span> 'a typ -<span class="keyword2">&gt;</span> 'a <span class="keyword3">list</span> -<span class="keyword2">&gt;</span> 'a t
  <span class="keyword4">val</span> to_list <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a <span class="keyword3">list</span>
  <span class="keyword4">val</span> length <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> <span class="keyword3">int</span>
  <span class="keyword4">val</span> start <span class="keyword2">:</span> 'a t -<span class="keyword2">&gt;</span> 'a ptr
  <span class="keyword4">val</span> from_ptr <span class="keyword2">:</span> 'a ptr -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> 'a t
  <span class="keyword4">val</span> make <span class="keyword2">:</span> 'a typ -<span class="keyword2">&gt;</span> ?initial<span class="keyword2">:</span>'a -<span class="keyword2">&gt;</span> <span class="keyword3">int</span> -<span class="keyword2">&gt;</span> 'a t
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ctypes/ctypes.mli">ctypes/ctypes.mli</a> , continued (part 5) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11364032">
        The array functions are similar to those in the standard library
        <code>Array</code> module except that they operate on
        arrays stored using the flat C representation rather than the
        OCaml representation described in
        <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a>.
      </p><p id="idp11366128">
        As with standard OCaml arrays, the conversion between arrays and
        lists requires copying the values, which can be expensive for
        large data structures. Notice that you can also convert an array
        into a <code>ptr</code> pointer to the head of the
        underlying buffer, which can be useful if you need to pass the
        pointer and size arguments separately to a C function.
      </p><p id="idp11367616">
        Unions in C are named structures that can be mapped onto the
        same underlying memory. They are also fully supported in Ctypes,
        but we won't go into more detail here.
      </p><section><h1><b>
      Pointer operators for dereferencing and arithmetic
      </b></h1><p id="idp11368928">
        Ctypes defines a number of operators that let you manipulate
        pointers and arrays just as you would in C. The Ctypes
        equivalents do have the benefit of being more strongly typed, of
        course.
      </p><table><thead><tr><th>
                Operator
              </th><th>
                Purpose
              </th></tr></thead><tbody><tr><td>
<code>!@ p</code>
</td><td>
                Dereference the pointer <code>p</code>.
              </td></tr><tr><td>
<code>p &lt;-@ v</code>
</td><td>
                Write the value <code>v</code> to the address
                <code>p</code>.
              </td></tr><tr><td>
<code>p +@ n</code>
</td><td>
                If <code>p</code> points to an array element, then
                compute the address of the <code>n</code>th next
                element.
              </td></tr><tr><td>
<code>p -@ n</code>
</td><td>
                If <code>p</code> points to an array element, then
                compute the address of the <code>n</code>th
                previous element.
              </td></tr></tbody></table><p id="idp11386256">
        There are also other useful non-operator functions available
        (see the Ctypes documentation), for example for pointer
        differencing and comparison.
      </p></section></section></section><section><h1 id="passing-functions-to-c">Passing functions to C</h1><p id="idp11388320">
      It's also straightforward to pass OCaml function values to C. The
      C standard library function <code>qsort</code> sorts arrays
      of elements using a comparison function passed in as a function
      pointer. The signature for <code>qsort</code> is as follows:
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="kt">void</span> <span class="n">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
           <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">compar</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort.h">ffi/qsort.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11391072">
      C programmers often use <code>typedef</code> to make type
      definitions involving function pointers easier to read. Using a
      typedef, the type of <code>qsort</code> looks a little more
      palatable.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="n">compare_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">compare_t</span> <span class="o">*</span><span class="p">);</span>
</div></code></pre><div class="rwocodeinfo">C ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort_typedef.h">ffi/qsort_typedef.h</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11393776">
      This also happens to be a close mapping to the corresponding
      Ctypes definition. Since type descriptions are regular values, we
      can just use <code>let</code> in place of
      <code>typedef</code> and end up with working OCaml bindings
      to <code>qsort</code>.
    </p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;ctypes.foreign&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">Ctypes </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">PosixTypes </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword1">open</span> <span class="keyword6">Foreign </span><span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword4">let</span> compare_t <span class="keyword2">=</span> ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">int</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val compare_t : (unit ptr -&gt; unit ptr -&gt; int) fn = &lt;abstr&gt;
</div># <span class="keyword4">let</span> qsort <span class="keyword2">=</span> foreign <span class="keyword7">&quot;qsort&quot;</span>
   <span class="keyword2">(</span>ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> size_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> size_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span>
    funptr compare_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning void<span class="keyword2">)</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">val qsort :
  unit ptr -&gt; size_t -&gt; size_t -&gt; (unit ptr -&gt; unit ptr -&gt; int) -&gt; unit =
  &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort.topscript">ffi/qsort.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11397216">
      We only use <code>compare_t</code> once (in the
      <code>qsort</code> definition), so you can choose to inline
      it in the OCaml code if you prefer. As the type shows, the
      resulting <code>qsort</code> value is a higher-order
      function, since its the fourth argument is itself a function. As
      before, let's define a wrapper function to make
      <code>qsort</code> easier to use. The second and third
      arguments to <code>qsort</code> specify the length (number
      of elements) of the array and the element size.
    </p><p id="idp11401600">
      Arrays created using Ctypes have a richer runtime structure than C
      arrays, so we don't need to pass size information around.
      Furthermore, we can use OCaml polymorphism in place of the unsafe
      <code>void ptr</code> type.
    </p><section><h1 id="example-a-command-line-quicksort">Example: a command-line quicksort</h1><p id="idp11404080">
        Below is a command-line tool that uses the
        <code>qsort</code> binding to sort all of the integers
        supplied on the standard input.
      </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Core.Std
</span><span class="keyword1">open</span> <span class="keyword6">Ctypes
</span><span class="keyword1">open</span> <span class="keyword6">PosixTypes
</span><span class="keyword1">open</span> <span class="keyword6">Foreign
</span>
<span class="keyword4">let</span> compare_t <span class="keyword2">=</span> ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> returning <span class="keyword3">int</span>

<span class="keyword4">let</span> qsort <span class="keyword2">=</span> foreign <span class="keyword7">&quot;qsort&quot;</span>
    <span class="keyword2">(</span>ptr void <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> size_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> size_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> funptr compare_t <span class="keyword2">@</span>-<span class="keyword2">&gt;</span> 
       returning void<span class="keyword2">)</span>

<span class="keyword4">let</span> qsort' cmp arr <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword1">open</span> <span class="keyword5">Unsigned.Size_t </span><span class="keyword4">in</span>
  <span class="keyword4">let</span> ty <span class="keyword2">=</span> <span class="keyword5">Array.</span>element_type arr <span class="keyword4">in</span>
  <span class="keyword4">let</span> len <span class="keyword2">=</span> of_int <span class="keyword2">(</span><span class="keyword5">Array.</span>length arr<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> elsize <span class="keyword2">=</span> of_int <span class="keyword2">(</span>sizeof ty<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> start <span class="keyword2">=</span> to_voidp <span class="keyword2">(</span><span class="keyword5">Array.</span>start arr<span class="keyword2">)</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> compare l r <span class="keyword2">=</span> cmp <span class="keyword2">(</span><span class="keyword2">!</span><span class="keyword2">@</span> <span class="keyword2">(</span>from_voidp ty l<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword2">(</span><span class="keyword2">!</span><span class="keyword2">@</span> <span class="keyword2">(</span>from_voidp ty r<span class="keyword2">)</span><span class="keyword2">)</span> <span class="keyword4">in</span>
  qsort start len elsize compare<span class="keyword2">;</span>
  arr

<span class="keyword4">let</span> sort_stdin <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">In_channel.</span>input_lines stdin
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>map ~f<span class="keyword2">:</span>int_of_string
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Array.</span>of_list <span class="keyword3">int</span>
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> qsort' <span class="keyword5">Int.</span>compare
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Array.</span>to_list
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">List.</span>iter ~f<span class="keyword2">:</span><span class="keyword2">(</span><span class="keyword1">fun</span> a -<span class="keyword2">&gt;</span> printf <span class="keyword7">&quot;%d\n&quot;</span> a<span class="keyword2">)</span>

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword5">Command.</span>basic ~summary<span class="keyword2">:</span><span class="keyword7">&quot;Sort integers on standard input&quot;</span>
    <span class="keyword5">Command.</span><span class="keyword5">Spec.</span>empty sort_stdin
  <span class="keyword2">|</span><span class="keyword2">&gt;</span> <span class="keyword5">Command.</span>run</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort.ml">ffi/qsort.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11406032">
        Compile it in the usual way with corebuild and test it against
        some input data, and also build the inferred interface so we can
        examine it more closely.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign qsort.native
</div><div class="highlight"><span class="gp">$</span> cat input.txt
</div><div class="rwocodeout">5</div><div class="rwocodeout">3</div><div class="rwocodeout">2</div><div class="rwocodeout">1</div><div class="rwocodeout">4</div><div class="highlight"><span class="gp">$</span> ./qsort.native &lt; input.txt
</div><div class="rwocodeout">1</div><div class="rwocodeout">2</div><div class="rwocodeout">3</div><div class="rwocodeout">4</div><div class="rwocodeout">5</div><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign qsort.inferred.mli
</div><div class="highlight"><span class="gp">$</span> cp _build/qsort.inferred.mli qsort.mli
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/build_qsort.out">ffi/build_qsort.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11407344">
        The inferred interface shows us the types of the raw
        <code>qsort</code> binding and also the
        <code>qsort'</code> wrapper function.
      </p><div class="rwocode"><pre><code><span class="keyword4">val</span> compare_t <span class="keyword2">:</span> <span class="keyword2">(</span>unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span> unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword5">Ctypes.</span>fn
<span class="keyword4">val</span> qsort <span class="keyword2">:</span>
  unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span>
  <span class="keyword5">PosixTypes.</span>size_t -<span class="keyword2">&gt;</span>
  <span class="keyword5">PosixTypes.</span>size_t -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span> unit <span class="keyword5">Ctypes.</span>ptr -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> unit
<span class="keyword4">val</span> qsort' <span class="keyword2">:</span> <span class="keyword2">(</span>'a -<span class="keyword2">&gt;</span> 'a -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span> -<span class="keyword2">&gt;</span> 'a <span class="keyword5">Ctypes.</span><span class="keyword3">array</span> -<span class="keyword2">&gt;</span> 'a <span class="keyword5">Ctypes.</span><span class="keyword3">array</span>
<span class="keyword4">val</span> sort_stdin <span class="keyword2">:</span> unit -<span class="keyword2">&gt;</span> unit</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ffi/qsort.mli">ffi/qsort.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11409984">
        The <code>qsort'</code> wrapper function has a much more
        canonical OCaml interface than the raw binding. It accepts a
        comparator function and a Ctypes array, and returns the same
        Ctypes array. It's not strictly required that it returns the
        array since it modifies it in-place, but it makes it easier to
        chain the function using the <code>|&gt;</code> operator
        (as <code>sort_stdin</code> does in the example).
      </p><p id="idp11412912">
        Using <code>qsort'</code> to sort arrays is
        straightforward. Our example code reads the standard input as a
        list, converts it to a C array, passes it through qsort, and
        outputs the result to the standard output. Again, remember to
        not confuse the <code>Ctypes.Array</code> module with the
        <code>Core.Std.Array</code> module: the former is in scope
        since we opened <code>Ctypes</code> at the start of the
        file.
      </p><section><h1><b>
      Lifetime of allocated Ctypes
      </b></h1><p id="idp11417248">
        Values allocated via Ctypes (<span><em>i.e.</em></span> using
        <code>allocate</code>, <code>Array.make</code> and
        so on) will not be garbage-collected as long as they are
        reachable from OCaml values. The system memory they occupy is
        freed when they do become unreachable, via a finalizer function
        registered with the GC.
      </p><p id="idp11419776">
        The definition of reachability for Ctypes values is a little
        different from conventional OCaml values, though. The allocation
        functions return an OCaml-managed pointer to the value, and as
        long as some derivative pointer is still reachable by the GC,
        the value won't be collected.
      </p><p id="idp11420512">
        &quot;Derivative&quot; means a pointer that's computed from the
        original pointer via arithmetic, so a reachable reference to an
        array element or a structure field protects the whole object
        from collection.
      </p><p id="idp11421376">
        A corollary of the above rule is that pointers written into the
        C heap don't have any effect on reachability. For example, if
        you have a C-managed array of pointers to structs then you'll
        need some additional way of keeping the structs themselves
        around to protect them from collection. You could achieve this
        via a global array of values on the OCaml side that would keep
        them live until they're no longer needed.
      </p><p id="idp11422256">
        Functions passed to C have similar considerations regarding
        lifetime. On the OCaml side, functions created at runtime may be
        collected when they become unreachable. As we've seen, OCaml
        functions passed to C are converted to function pointers, and
        function pointers written into the C heap have no effect on the
        reachability of the OCaml functions they reference. With
        <code>qsort</code> things are straightforward, since the
        comparison function is only used during the call to
        <code>qsort</code> itself. However, other C libraries may
        store function pointers in global variables or elsewhere, in
        which case you'll need to take care that the OCaml functions you
        pass to them aren't prematurely garbage collected.
      </p></section></section></section><section><h1 id="learning-more-about-c-bindings">Learning more about C bindings</h1><p id="idp11426432">
      The Ctypes
      <a href="http://github.com/ocamllabs/ocaml-ctypes" target="_top">distribution</a>
      contains a number of larger-scale examples, including:
    </p><ul><li><p id="idp11428176">
          bindings to the POSIX <code>fts</code> API which
          demonstrates C callbacks more comprehensively.
        </p></li><li><p id="idp11429792">
          a more complete Ncurses binding than the example we opened the
          chapter with.
        </p></li><li><p id="idp11430688">
          a comprehensive test suite that covers the complete library,
          and can provide useful snippets for your own bindings.
        </p></li></ul><p id="idp11431488">
      This chapter hasn't really needed you to understand the innards of
      OCaml at all. Ctypes does its best to make function bindings easy,
      but the rest of this part will also fill you in about how
      interactions with OCaml memory layout in
      <a href="memory-representation-of-values.html">Chapter 20, <i>Memory Representation of Values</i></a> and
      automatic memory management in
      <a href="understanding-the-garbage-collector.html">Chapter 21, <i>Understanding the Garbage Collector</i></a>.
    </p><p id="idp11433648">
      Ctypes gives OCaml programs access to the C representation of
      values, shielding you from the details of the OCaml value
      representation, and introduces an abstraction layer that hides the
      details of foreign calls. While this covers a wide variety of
      situations, it's sometimes necessary to look behind the
      abstraction to obtain finer control over the details of the
      interaction between the two languages.
    </p><p id="idp11434496">
      You can find more information about the C interface in several
      places.
    </p><ul><li><p id="idp11435504">
          The standard OCaml foreign function interface allows you to
          glue OCaml and C together from the other side of the boundary,
          by writing C functions that operate on the OCaml
          representation of values. You can find details of the standard
          interface in the
          <a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual033.html" target="_top">OCaml
          manual</a> and in the book
          <a href="http://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf" target="_top">Developing
          Applications with Objective Caml</a>.
        </p></li><li><p id="idp11438144">
          Florent Monnier maintains an excellent online
          <a href="http://www.linux-nantes.org/~fmonnier/ocaml/ocaml-wrapping-c.php" target="_top">reference</a>
          that provides examples of how to call OCaml functions from C.
          This covers a wide variety of OCaml data types and also more
          complex callbacks between C and OCaml.
        </p></li><li><p id="idp11439952">
<a href="http://www.swig.org" target="_top">SWIG</a> is a tool that
          connects programs written in C/C++ to a variety of
          higher-level programming languages, including OCaml. The SWIG
          manual has examples of converting library specifications into
          OCaml bindings.
        </p></li></ul><section><h1 id="struct-memory-layout">Struct memory layout</h1><p id="idp11442656">
        The C language gives implementations a certain amount of freedom
        in choosing how to lay out structs in memory. There may be
        padding between members and at the end of the struct, in order
        to satisfy the memory alignment requirements of the host
        platform. Ctypes uses platform-appropriate size and alignment
        information to replicate the struct layout process. OCaml and C
        will have consistent views abotu the layout of the struct as
        long as you declare the fields of a struct in the same order and
        with the same types as the C library you're binding to.
      </p><p id="idp11444320">
        However, this approach can lead to difficulties when the fields
        of a struct aren't fully specified in the interface of a
        library. The interface may list the fields of a structure
        without specifying their order, or make certain fields available
        only on certain platforms, or insert undocumented fields into
        struct definitions for performance reasons. For example, the
        <code>struct timeval</code> definition used in this
        chapter accurately describes the layout of the struct on common
        platforms but implementations on some more unusual architectures
        include additional padding members that will lead to strange
        behaviour in the examples.
      </p><p id="idp11446144">
        The Cstubs subpackage of Ctypes addresses this issue. Rather
        than simply assuming that struct definitions given by the user
        accurately reflect the actual definitions of structs used in C
        libraries, Cstubs generates code that uses the C library headers
        to discover the layout of the struct. The good news is that the
        code that you write doesn't need to change much. Cstubs provides
        alternative implementations of the <code>field</code> and
        <code>seal</code> functions that you've already used to
        describe <code>struct timeval</code>; instead of computing
        member offsets and sizes appropriate for the platform, these
        implementations obtain them directly from C.
      </p><p id="idp11449360">
        The details of using Cstubs are available in the online
        <a href="https://ocamllabs.github.io/ocaml-ctypes" target="_top">documentation</a>,
        along with instructions on integration with
        <span><strong>autoconf</strong></span> platform portability instructions.
      </p><aside class="note"><h1>
      Production note
      </h1><p id="idp11452080">
        This chapter contains significant contributions from Jeremy
        Yallop.
      </p></aside></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="pt03.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="memory-representation-of-values.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>