<!DOCTYPE html>
<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 22. The Compiler Frontend: Parsing and Type Checking / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta3',
                        page: 'the\u002Dcompiler\u002Dfrontend\u002Dparsing\u002Dand\u002Dtype\u002Dchecking.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="foreign-function-interface.html">19. Foreign Function Interface</a>
                                            </li>
                                        
                                            <li>
                                                <a href="memory-representation-of-values.html">20. Memory Representation of Values</a>
                                            </li>
                                        
                                            <li>
                                                <a href="understanding-the-garbage-collector.html">21. Understanding the Garbage Collector</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-frontend-parsing-and-type-checking.html" class="here">22. The Compiler Frontend: Parsing and Type Checking</a>
                                            </li>
                                        
                                            <li>
                                                <a href="the-compiler-backend-byte-code-and-native-code.html">23. The Compiler Backend: Byte-code and Native-code</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 22. The Compiler Frontend: Parsing and Type Checking</h1>
                
                

    <p id="idp11807200">
    Compiling source code into executable programs is a fairly complex
    process that involves quite a few tools—preprocessors, compilers,
    runtime libraries, linkers and assemblers. It's important to
    understand how these fit together to help with your day-to-day
    workflow of developing, debugging and deploying applications.
  </p><p id="idp11808288">
    OCaml has a strong emphasis on static type safety and rejects source
    code that doesn't meet its requirements as early as possible. The
    compiler does this by running the source code through a series of
    checks and transformations. Each stage performs its job
    (<span><em>e.g.</em></span> type checking, optimization or code
    generation) and discards some information from the previous stage.
    The final native code output is low-level assembly code that doesn't
    know anything about the OCaml modules or objects that the compiler
    started with.
  </p><p id="idp11809664">
    You don't have to do all this manually, of course. The compiler
    frontends (<code>ocamlc</code> and
    <code>ocamlopt</code>) are invoked via the command-line and
    chain the stages together for you. Sometimes though, you'll need to
    dive into the toolchain to hunt down a bug or investigate a
    performance problem. This chapter explains the compiler pipeline in
    more depth so you understand how to harness the command-line tools
    effectively.
  </p><p id="idp11811904">
    In this chapter, we'll cover the following topics:
  </p><ul><li><p id="idp11812880">
        the compilation pipeline and what each stage represents.
      </p></li><li><p id="idp11813744">
        source preprocessing via Camlp4 and the intermediate forms.
      </p></li><li><p id="idp11814608">
        the type-checking process, including module resolution.
      </p></li></ul><p id="idp11815328">
    The details of the compilation process into executable code can be
    found next in
    <a href="the-compiler-backend-byte-code-and-native-code.html">Chapter 23, <i>The Compiler Backend: Byte-code and Native-code</i></a>.
  </p><section><h1 id="an-overview-of-the-toolchain">An overview of the toolchain</h1><p id="idp11817760">
      The OCaml tools accept textual source code as input, using
      filename extensions of <code>.ml</code> and
      <code>.mli</code> for modules and signatures respectively.
      We explained the basics of the build process earlier in
      <a href="files-modules-and-programs.html">Chapter 4, <i>Files, Modules and Programs</i></a>, so we'll
      assume you've built a few OCaml programs already by this point.
    </p><p id="idp11820576">
      Each source file represents a <span><em>compilation
      unit</em></span> that is built separately. The compiler generates
      intermediate files with different filename extensions to use as it
      advances through the compilation stages. The linker takes a
      collection of compiled units and produces a standalone executable
      or library archive that can be reused by other applications.
    </p><p id="idp11821728">
      The overall compilation pipeline looks like this:
    </p><div class="rwocode"><pre><code><pre>    Source code
        |
        | parsing and preprocessing
        |
        | camlp4 syntax extensions
        |
        v
    Parsetree (untyped AST)
        |
        | type inference and checking
        v
    Typedtree (type-annotated AST)
        |
        | pattern-matching compilation
        | elimination of modules and classes
        v
     Lambda
      /   \
     /     \ closure conversion, inlining, uncurrying,
    v       \  data representation strategy
 Bytecode    \
    |         +-----+
    |              Cmm
    |ocamlrun       |
    |               | code generation
    |               | assembly &amp; linking
    v               v
 Interpreted    Compiled
</pre></code></pre><div class="rwocodeinfo">Diagram ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/pipeline.ascii">front-end/pipeline.ascii</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11822912">
      Notice that the pipeline branches towards the end. OCaml has
      multiple compiler backends that reuse the early stages of
      compilation, but produce very different final outputs. The
      <span><em>bytecode</em></span> can be run by a portable
      interpreter, and can even be transformed into JavaScript (via
      <a href="http://ocsigen.org/js_of_ocaml" target="_top">js_of_ocaml</a>)
      or C source code (via
      <a href="https://github.com/ocaml-bytes/ocamlcc" target="_top">OCamlCC</a>).
      The <span><em>native code</em></span> compiler generates
      specialized executable binaries suitable for high-performance
      applications.
    </p><section><h1><b>
    Obtaining the compiler source code
    </b></h1><p id="idp11826784">
      Although it's not necessary to understand the examples, you may
      find it useful to have a copy of the OCaml source tree checked out
      while you read through this chapter. The source code is available
      from multiple places:
    </p><ul><li><p id="idp11827952">
          Stable releases as zip and tar archives from the
          <a href="http://caml.inria.fr/download.en.html" target="_top">OCaml
          download site</a>.
        </p></li><li><p id="idp11829552">
          A Subversion anonymous mirror of the main development sources
          available on the
          <a href="http://caml.inria.fr/ocaml/anonsvn.en.html" target="_top">development
          resources</a> page online.
        </p></li><li><p id="idp11831216">
          A Git mirror of the Subversion repository with all the history
          and development branches included, browsable online at
          <a href="https://github.com/ocaml/ocaml" target="_top">Github</a>.
        </p></li></ul><p id="idp11832752">
      The source tree is split up into sub-directories. The core
      compiler consists of:
    </p><ul><li><p id="idp11833760">
<code>config/</code>: configuration directives to tailor
          OCaml for your operating system and architecture.
        </p></li><li><p id="idp11835344">
<code>bytecomp/</code> and <code>byterun/</code>:
          byte-code compiler and runtime, including the garbage
          collector.
        </p></li><li><p id="idp11837632">
<code>asmcomp/</code> and <code>asmrun/</code>:
          native-code compiler and runtime. The native runtime symlinks
          many modules from the <code>byterun</code> directory to
          share code, most notably the garbage collector.
        </p></li><li><p id="idp11840720">
<code>parsing/</code>: the OCaml lexer, parser and
          libraries for manipulating them.
        </p></li><li><p id="idp11842272">
<code>typing/</code>: the static type checking
          implementation and type definitions.
        </p></li><li><p id="idp11843824">
<code>camlp4/</code>: the source code macro
          preprocessor.
        </p></li><li><p id="idp11845360">
<code>driver/</code>: command-line interfaces for the
          compiler tools.
        </p></li></ul><p id="idp11846768">
      There are a number of tools and scripts also built alongside the
      core compiler:
    </p><ul><li><p id="idp11847776">
<code>debugger/</code>: the interactive byte-code
          debugger.
        </p></li><li><p id="idp11849312">
<code>toplevel/</code>: interactive top-level console.
        </p></li><li><p id="idp11850832">
<code>emacs/</code>: a <span><em>caml-mode</em></span>
          for the Emacs editor.
        </p></li><li><p id="idp11852800">
<code>stdlib/</code>: the compiler standard library,
          including the <code>Pervasives</code> module.
        </p></li><li><p id="idp11855056">
<code>ocamlbuild/</code>: build system that automates
          common OCaml compilation modes.
        </p></li><li><p id="idp11856608">
<code>otherlibs/</code>: optional libraries such as the
          Unix and graphics modules.
        </p></li><li><p id="idp11858160">
<code>tools/</code>: command-line utilities such as
          <code>ocamldep</code> that are installed with the
          compiler.
        </p></li><li><p id="idp11860448">
<code>testsuite/</code>: regression tests for the core
          compiler.
        </p></li></ul></section><p id="idp11861984">
      We'll go through each of the compilation stages now and explain
      how that'll be useful to you during day-to-day OCaml development.
    </p></section><section><h1 id="parsing-source-code">Parsing source code</h1><p id="idp11863808">
      When a source file is passed to the OCaml compiler, its first task
      is to parse the text into a more structured Abstract Syntax Tree
      (AST). The parsing logic is implemented in OCaml itself using the
      techniques described earlier in
      <a href="parsing-with-ocamllex-and-menhir.html">Chapter 16, <i>Parsing with OCamllex and Menhir</i></a>. The
      lexer and parser rules can be found in the
      <code>parsing</code> directory in the source distribution.
    </p><section><h1 id="syntax-errors">Syntax errors</h1><p id="idp11867120">
        The OCaml parser's goal is to output a well-formed AST data
        structure to the next phase of compilation, and so it rejects
        any source code that doesn't match basic syntactic requirements.
        The compiler emits a <span><em>syntax error</em></span> in this
        situation, with a pointer to the filename and line and character
        number that's as close to the error as possible.
      </p><p id="idp11868336">
        Here's an example syntax error that we obtain by performing a
        module assignment as a statement instead of as a let-binding.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">module</span> <span class="keyword6">MyString </span><span class="keyword2">=</span> String<span class="keyword2">;</span>
  <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/broken_module.ml">front-end/broken_module.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11869600">
        The above code results in a syntax error when compiled.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c broken_module.ml
</div><div class="rwocodeout">File &quot;broken_module.ml&quot;, line 2, characters 2-8:</div><div class="rwocodeout">Error: Syntax error</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_broken_module.out">front-end/build_broken_module.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11870800">
        The correct version of this source code creates the
        <code>MyString</code> module correctly via a local open,
        and compiles successfully.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> <span class="keyword4">module</span> <span class="keyword6">MyString </span><span class="keyword2">=</span> <span class="keyword6">String </span><span class="keyword4">in</span>
  <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/fixed_module.ml">front-end/fixed_module.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11872768">
        The syntax error points to the line and character number of the
        first token that couldn't be parsed. In the broken example the
        <code>module</code> keyword isn't a valid token at that
        point in parsing, so the error location information is correct.
      </p></section><section><h1 id="automatically-indenting-source-code">Automatically indenting source code</h1><p id="idp11875472">
        Sadly, syntax errors do get more inaccurate sometimes depending
        on the nature of your mistake. Try to spot the deliberate error
        in the following function definitions.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> concat_and_print x y <span class="keyword2">=</span>
  <span class="keyword4">let</span> v <span class="keyword2">=</span> x <span class="keyword2">^</span> y <span class="keyword4">in</span>
  print_endline v<span class="keyword2">;</span>
  v<span class="keyword2">;</span>

<span class="keyword4">let</span> add_and_print x y <span class="keyword2">=</span>
  <span class="keyword4">let</span> v <span class="keyword2">=</span> x <span class="keyword2">+</span> y <span class="keyword4">in</span>
  print_endline <span class="keyword2">(</span>string_of_int v<span class="keyword2">)</span><span class="keyword2">;</span>
  v

<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword4">let</span> _x <span class="keyword2">=</span> add_and_print <span class="keyword8">1</span> <span class="keyword8">2</span> <span class="keyword4">in</span>
  <span class="keyword4">let</span> _y <span class="keyword2">=</span> concat_and_print <span class="keyword7">&quot;a&quot;</span> <span class="keyword7">&quot;b&quot;</span> <span class="keyword4">in</span>
  <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/follow_on_function.ml">front-end/follow_on_function.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11876784">
        When you compile this file you'll get a syntax error again.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c follow_on_function.ml
</div><div class="rwocodeout">File &quot;follow_on_function.ml&quot;, line 11, characters 0-3:</div><div class="rwocodeout">Error: Syntax error</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_follow_on_function.out">front-end/build_follow_on_function.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11878000">
        The line number in the error points to the end of the
        <code>add_and_print</code> function, but the actual error
        is at the end of the <span><em>first</em></span> function
        definition. There's an extra semicolon at the end of the first
        definition that causes the second definition to become part of
        the first <code>let</code> binding. This eventually
        results in a parsing error at the very end of the second
        function.
      </p><p id="idp11880624">
        This class of bug (due to a single errant character) can be hard
        to spot in a large body of code. Luckily, there's a great tool
        available via OPAM called <span><strong>ocp-indent</strong></span> that
        applies structured indenting rules to your source code on a
        line-by-line basis. This not only beautifies your code layout,
        but it also makes this syntax error much easier to locate.
      </p><p id="idp11882128">
        Let's run our erroneous file through
        <span><strong>ocp-indent</strong></span> and see how it processes it.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocp-indent follow_on_function.ml
</div><div class="rwocodeout">let concat_and_print x y =</div><div class="rwocodeout">  let v = x ^ y in</div><div class="rwocodeout">  print_endline v;</div><div class="rwocodeout">  v;</div><div class="rwocodeout"> </div><div class="rwocodeout">  let add_and_print x y =</div><div class="rwocodeout">    let v = x + y in</div><div class="rwocodeout">    print_endline (string_of_int v);</div><div class="rwocodeout">    v</div><div class="rwocodeout"> </div><div class="rwocodeout">let () =</div><div class="rwocodeout">  let _x = add_and_print 1 2 in</div><div class="rwocodeout">  let _y = concat_and_print &quot;a&quot; &quot;b&quot; in</div><div class="rwocodeout">  ()</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/indent_follow_on_function.out">front-end/indent_follow_on_function.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11884048">
        The <code>add_and_print</code> definition has been
        indented as if it were part of the first
        <code>concat_and_print</code> definition, and the errant
        semicolon is now much easier to spot. We just need to remove
        that semicolon and re-run <span><strong>ocp-indent</strong></span> to
        verify that the syntax is correct.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocp-indent follow_on_function_fixed.ml
</div><div class="rwocodeout">let concat_and_print x y =</div><div class="rwocodeout">  let v = x ^ y in</div><div class="rwocodeout">  print_endline v;</div><div class="rwocodeout">  v</div><div class="rwocodeout"> </div><div class="rwocodeout">let add_and_print x y =</div><div class="rwocodeout">  let v = x + y in</div><div class="rwocodeout">  print_endline (string_of_int v);</div><div class="rwocodeout">  v</div><div class="rwocodeout"> </div><div class="rwocodeout">let () =</div><div class="rwocodeout">  let _x = add_and_print 1 2 in</div><div class="rwocodeout">  let _y = concat_and_print &quot;a&quot; &quot;b&quot; in</div><div class="rwocodeout">  ()</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/indent_follow_on_function_fixed.out">front-end/indent_follow_on_function_fixed.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11887568">
        The <span><strong>ocp-indent</strong></span>
<a href="https://github.com/OCamlPro/ocp-indent" target="_top">homepage</a>
        documents how to integrate it with your favorite editor. All the
        Core libraries are formatted using it to ensure consistency, and
        it's a good idea to do this before publishing your own source
        code online.
      </p></section><section><h1 id="generating-documentation-from-interfaces">Generating documentation from interfaces</h1><p id="idp11891008">
        Whitespace and source code comments are removed during parsing
        and aren't significant in determining the semantics of the
        program. However, other tools in the OCaml distribution can
        interpret comments for their own ends.
      </p><p id="idp11891664">
        The <span><strong>ocamldoc</strong></span> tool uses specially formatted
        comments in the source code to generate documentation bundles.
        These comments are combined with the function definitions and
        signatures and output as structured documentation in a variety
        of formats. It can generate HTML pages, LaTeX and PDF documents,
        UNIX manual pages and even module dependency graphs that can be
        viewed using
        <a href="http://www.graphviz.org" target="_top">Graphviz</a>.
      </p><p id="idp11893920">
        Here's a sample of some source code that's been annotated with
        <span><strong>ocamldoc</strong></span> comments.
      </p><div class="rwocode"><pre><code><span class="comments">(** example.ml: The first special comment of the file is the comment 
    associated with the whole module. *)</span>

<span class="comments">(** Comment for exception My_exception. *)</span>
<span class="keyword1">exception</span> <span class="keyword6">My_exception </span><span class="keyword2">of</span> <span class="keyword2">(</span><span class="keyword3">int</span> -<span class="keyword2">&gt;</span> <span class="keyword3">int</span><span class="keyword2">)</span> <span class="keyword2">*</span> <span class="keyword3">int</span>

<span class="comments">(** Comment for type [weather]  *)</span>
<span class="keyword4">type</span> weather <span class="keyword2">=</span>
  <span class="keyword2">|</span> <span class="keyword6">Rain </span><span class="keyword2">of</span> <span class="keyword3">int</span> <span class="comments">(** The comment for construtor Rain *)</span>
  <span class="keyword2">|</span> <span class="keyword6">Sun </span>        <span class="comments">(** The comment for constructor Sun *)</span>

<span class="comments">(** Find the current weather for a country
    @author Anil Madhavapeddy
    @param location The country to get the weather for.
*)</span>
<span class="keyword4">let</span> what_is_the_weather_in location <span class="keyword2">=</span>
  <span class="keyword1">match</span> location <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">`Cambridge </span> -<span class="keyword2">&gt;</span> <span class="keyword6">Rain </span><span class="keyword8">100</span>
  <span class="keyword2">|</span> <span class="keyword6">`New_york </span>  -<span class="keyword2">&gt;</span> <span class="keyword6">Rain </span><span class="keyword8">20</span>
  <span class="keyword2">|</span> <span class="keyword6">`California </span>-<span class="keyword2">&gt;</span> Sun</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/doc.ml">front-end/doc.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11895840">
        The <span><strong>ocamldoc</strong></span> comments are distinguished by
        beginning with the double asterisk. There are formatting
        conventions for the contents of the comment to mark metadata.
        For instance, the <code>@tag</code> fields mark specific
        properties such as the author of that section of code.
      </p><p id="idp11897952">
        Try compiling the HTML documentation and UNIX man pages by
        running <span><strong>ocamldoc</strong></span> over the source file.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> mkdir -p html man/man3
</div><div class="highlight"><span class="gp">$</span> ocamldoc -html -d html doc.ml
</div><div class="highlight"><span class="gp">$</span> ocamldoc -man -d man/man3 doc.ml
</div><div class="highlight"><span class="gp">$</span> man -M man Doc
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_ocamldoc.out">front-end/build_ocamldoc.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11899888">
        You should now have HTML files inside the
        <code>html/</code> directory and also be able to view the
        UNIX manual pages held in <code>man/man3</code>. There are
        quite a few comment formats and options to control the output
        for the various backends. Refer to the
        <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual029.html" target="_top">OCaml
        manual</a> for the complete list.
      </p><aside class="tip"><h1>
      Using custom ocamldoc generators
      </h1><p id="idp11904160">
        The default HTML output stylesheets from
        <span><strong>ocamldoc</strong></span> are pretty spartan and distinctly
        Web 1.0. The tool supports plugging in custom documentation
        generators, and there are several available that provide
        prettier or more detailed output.
      </p><ul><li><p id="idp11906064">
<a href="http://argot.x9c.fr/" target="_top">Argot</a> is an
            enhanced HTML generator that supports code folding and
            searching by name or type definition.
          </p></li><li><p id="idp11907664">
<a href="https://gitorious.org/ocamldoc-generators/ocamldoc-generators" target="_top">ocamldoc-generators</a>
            add support for Bibtex references within comments and
            generating literate documentation that embeds the code
            alongside the comments.
          </p></li><li><p id="idp11909360">
            JSON output is available via a custom
            <a href="https://github.com/xen-org/ocamldoc-json" target="_top">generator</a>
            in Xen.
          </p></li></ul></aside></section></section><section><h1 id="preprocessing-source-code">Preprocessing source code</h1><p id="idp11912432">
      One powerful feature in OCaml is a facility to extend the standard
      language grammar without having to modify the compiler. You can
      roughly think of it as a type-safe version to the
      <code>cpp</code> preprocessor used in C/C++ to control
      conditional compilation directives.
    </p><p id="idp11913840">
      The OCaml distribution includes a system called Camlp4 for writing
      extensible parsers. This provides some OCaml libraries that are
      used to define grammars and also dynamically loadable syntax
      extensions of such grammars. Camlp4 modules register new language
      keywords and later transform these keywords (or indeed, any
      portion of the input program) into conventional OCaml code that
      can be understood by the rest of the compiler.
    </p><p id="idp11914720">
      We've already seen several Core libraries that use Camlp4:
    </p><ul><li><p id="idp11915696">
<code>Fieldslib</code> generates first-class values that
          represent fields of a record.
        </p></li><li><p id="idp11917248">
<code>Sexplib</code> to convert types to textual
          s-expressions.
        </p></li><li><p id="idp11918784">
<code>Bin_prot</code> for efficient binary conversion
          and parsing.
        </p></li></ul><p id="idp11920192">
      These libraries all extend the language in quite a minimal way by
      adding a <code>with</code> keyword to type declarations to
      signify that extra code should be generated from that declaration.
      For example, here's a trivial use of Sexplib and Fieldslib.
    </p><div class="rwocode"><pre><code><span class="keyword1">open</span> <span class="keyword5">Sexplib.Std
</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span>
  foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span>
  bar<span class="keyword2">:</span> <span class="keyword3">string</span>
<span class="keyword2">}</span> <span class="keyword1">with</span> sexp, fields</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/type_conv_example.ml">front-end/type_conv_example.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11922288">
      Compiling this code will normally give you a syntax error if you
      do so without Camlp4 since the <code>with</code> keyword
      isn't normally allowed after a type definition.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlfind ocamlc -c type_conv_example.ml
</div><div class="rwocodeout">File &quot;type_conv_example.ml&quot;, line 6, characters 2-6:</div><div class="rwocodeout">Error: Syntax error</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_type_conv_without_camlp4.out">front-end/build_type_conv_without_camlp4.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11924304">
      Now add in the syntax extension packages for Fieldslib and
      Sexplib, and everything will compile again.
    </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlfind ocamlc -c -syntax camlp4o -package sexplib.syntax <span class="se">\</span>
</div><div class="rwocodeout">    -package fieldslib.syntax type_conv_example.ml</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_type_conv_with_camlp4.out">front-end/build_type_conv_with_camlp4.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11925568">
      We've specified a couple of additional flags here. The
      <code>-syntax</code> flag directs
      <span><strong>ocamlfind</strong></span> to add the <code>-pp</code>
      flag to the compiler command-line. This flag instructs the
      compiler to run the preprocessor during its parsing phase.
    </p><p id="idp11928272">
      The <code>-package</code> flag imports other OCaml
      libraries. The <code>.syntax</code> suffix in the package
      name is a convention that indicates these libraries are
      preprocessors that should be run during parsing. The syntax
      extension modules are dynamically loaded into the
      <span><strong>camlp4o</strong></span> command which rewrites the input source
      code into conventional OCaml code that has no trace of the new
      keywords. The compiler then compiles this transformed code with no
      knowledge of the preprocessor's actions.
    </p><p id="idp11931296">
      Both Fieldslib and Sexplib need this new <code>with</code>
      keyword, but they both can't register the same extension. Instead,
      a library called Type_conv provides the common extension framework
      for them to use. Type_conv registers the <code>with</code>
      grammar extension to Camlp4, and the OCamlfind packaging ensures
      that it's loaded before Variantslib or Sexplib.
    </p><p id="idp11933472">
      The two extensions generate boilerplate OCaml code based on the
      type definition at compilation time. This avoids the performance
      hit of doing the code generation dynamically and also doesn't
      require a Just-In-Time (JIT) runtime that can be a source of
      unpredictable dynamic behavior. Instead, all the extra code is
      simply generated at compilation time via Camlp4, and type
      information can be discarded from the runtime image.
    </p><p id="idp11934352">
      The syntax extensions accept an input AST and output a modified
      one. If you're not familiar with the Camlp4 module in question,
      how do you figure out what changes it's made to your code? The
      obvious way is to read the documentation that accompanies the
      extension. Another approach is to use the top-level to explore the
      extension's behavior or run Camlp4 manually yourself to see the
      transformation in action. We'll show you how to do both of these
      now.
    </p><section><h1 id="using-camlp4-interactively">Using Camlp4 interactively</h1><p id="idp11936400">
        The <span><strong>utop</strong></span> top-level can run the phrases that
        you type through <span><strong>camlp4</strong></span> automatically. You
        should have at least these lines in your
        <code>~/.ocamlinit</code> file in your home directory (see
        <a href="installation.html">Appendix A, <i>Installation</i></a> for more information).
      </p><div class="rwocode"><pre><code># <span class="keyword7">#use</span> <span class="keyword7">&quot;topfind&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"><br/>- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require &quot;package&quot;;;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates &quot;p,q,...&quot;;;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
 </div># <span class="keyword7">#camlp4o</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/camlp4_toplevel.topscript">front-end/camlp4_toplevel.topscript</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11940544">
        The first directive loads the <span><strong>ocamlfind</strong></span>
        top-level interface that lets you require
        <span><strong>ocamlfind</strong></span> packages (including all their
        dependent packages). The second directive instructs the
        top-level to filter all phrases via Camlp4. You can now run
        <span><strong>utop</strong></span> and load the syntax extensions in. We'll
        use the <code>comparelib</code> syntax extension for our
        experiments.
      </p><p id="idp11944144">
        OCaml provides a built-in polymorphic comparison operator that
        inspects the runtime representation of two values to see if
        they're equal. As we noted in
        <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a>, the
        polymorphic comparison is less efficient than defining explicit
        comparison functions between values. However, it quickly become
        tedious to manually define comparison functions for complex type
        definitions.
      </p><p id="idp11945680">
        Let's see how <code>comparelib</code> solves this problem
        by running it in <span><strong>utop</strong></span>.
      </p><div class="rwocode"><pre><code># <span class="keyword7">#require</span> <span class="keyword7">&quot;comparelib.syntax&quot;</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout"> </div># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span> bar <span class="keyword2">:</span> t <span class="keyword2">}</span> <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : string; bar : t; }
</div># <span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> t <span class="keyword2">}</span> <span class="keyword1">with</span> compare <span class="keyword2">;</span><span class="keyword2">;</span><div class="rwocodeout">type t = { foo : string; bar : t; }
val compare : t -&gt; t -&gt; int = &lt;fun&gt;
val compare_t : t -&gt; t -&gt; int = &lt;fun&gt;
</div></code></pre><div class="rwocodeinfo">OCaml Utop ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/camlp4_toplevel.topscript">front-end/camlp4_toplevel.topscript</a> , continued (part 1) ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11948272">
        The first definition of <code>t</code> is a standard OCaml
        phrase and results in the expected output. The second one
        includes the <code>with compare</code> directive. This is
        intercepted by <code>comparelib</code> and transformed
        into the original type definition with two new functions also
        included.
      </p></section><section><h1 id="running-camlp4-from-the-command-line">Running Camlp4 from the command line</h1><p id="idp11952384">
        The top-level is a quick way to examine the signatures generated
        from the extensions, but how can we see what these new functions
        actually do? You can't do this from <span><strong>utop</strong></span>
        directly since it embeds the Camlp4 invocation as an automated
        part of its operation.
      </p><p id="idp11953792">
        Let's turn to the command-line to obtain the result of the
        <code>comparelib</code> transformation instead. Create a
        file that contains the type declaration from earlier.
      </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> 
  foo<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span> 
  bar<span class="keyword2">:</span> t
<span class="keyword2">}</span> <span class="keyword1">with</span> compare</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/comparelib_test.ml">front-end/comparelib_test.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11955792">
        We need to run the Camlp4 binary with the library paths to
        Comparelib and Type_conv. Let's use a small shell script to wrap
        this invocation.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="c">#!/bin/sh</span>

<span class="nv">OCAMLFIND</span><span class="o">=</span><span class="s2">&quot;ocamlfind query -predicates syntax,preprocessor -r&quot;</span>
<span class="nv">INCLUDE</span><span class="o">=</span><span class="sb">`</span><span class="nv">$OCAMLFIND</span> -i-format comparelib.syntax<span class="sb">`</span>
<span class="nv">ARCHIVES</span><span class="o">=</span><span class="sb">`</span><span class="nv">$OCAMLFIND</span> -a-format comparelib.syntax<span class="sb">`</span>
camlp4o -printer o <span class="nv">$INCLUDE</span> <span class="nv">$ARCHIVES</span> <span class="nv">$1</span>
</div></code></pre><div class="rwocodeinfo">Shell script ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/camlp4_dump.cmd">front-end/camlp4_dump.cmd</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11957088">
        The script uses the <span><strong>ocamlfind</strong></span> package manager
        to list the include and library paths needed by
        <code>comparelib</code>. It then invokes the
        <span><strong>camlp4o</strong></span> preprocessor with these paths and
        outputs the resulting AST to the standard output.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> sh camlp4_dump.cmd comparelib_test.ml
</div><div class="rwocodeout">type t = { foo : string; bar : t }</div><div class="rwocodeout"> </div><div class="rwocodeout">let _ = fun (_ : t) -&gt; ()</div><div class="rwocodeout">  </div><div class="rwocodeout">let rec compare : t -&gt; t -&gt; int =</div><div class="rwocodeout">  fun a__001_ b__002_ -&gt;</div><div class="rwocodeout">    if Pervasives.( == ) a__001_ b__002_</div><div class="rwocodeout">    then 0</div><div class="rwocodeout">    else</div><div class="rwocodeout">      (let ret =</div><div class="rwocodeout">         (Pervasives.compare : string -&gt; string -&gt; int) a__001_.foo</div><div class="rwocodeout">           b__002_.foo</div><div class="rwocodeout">       in</div><div class="rwocodeout">         if Pervasives.( &lt;&gt; ) ret 0</div><div class="rwocodeout">         then ret</div><div class="rwocodeout">         else compare a__001_.bar b__002_.bar)</div><div class="rwocodeout">  </div><div class="rwocodeout">let _ = compare</div><div class="rwocodeout">  </div><div class="rwocodeout">let compare_t = compare</div><div class="rwocodeout">  </div><div class="rwocodeout">let _ = compare_t</div><div class="rwocodeout">  </div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/process_comparelib_test.out">front-end/process_comparelib_test.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11960576">
        The output contains the original type definition accompanied by
        some automatically generated code that implements an explicit
        comparison function for each field in the record. If you're
        using the extension in your compiler command-line, this
        generated code is then compiled as if you had typed it in
        yourself.
      </p><p id="idp11961344">
        Note that although the generated code uses
        <code>Pervasives.compare</code>, it is also annotated with
        a <code>string</code> type. This lets the compiler use a
        specialized string comparison function and not actually call the
        runtime polymorphic comparison function. This has implications
        for correctness too: recall from
        <a href="maps-and-hash-tables.html">Chapter 13, <i>Maps and Hash Tables</i></a> that
        <code>comparelib</code> provides reliable comparison
        functions that work for values that are logically the same but
        that have differing internal representations (e.g.
        <code>Int.Set.t</code>).
      </p><aside class="note"><h1>
      A style note: wildcards in let bindings
      </h1><p id="idp11967120">
        You may have noticed the <code>let _ = fun</code>
        construct in the autogenerated code above. The underscore in a
        <code>let</code> binding is just the same as a wildcard
        underscore in a pattern match, and tells the compiler to accept
        any return value and discard it immediately.
      </p><p id="idp11969184">
        This is fine for mechanically generated code from Type_conv, but
        should be avoided in code that you write by hand. If it's a
        unit-returning expression, then write a <code>unit</code>
        binding explicitly instead. This will cause a type error if the
        expression changes type in the future (<span><em>e.g.</em></span>
        due to code refactoring).
      </p><div class="rwocode"><pre><code><pre>let () = &lt;expr&gt;
</pre></code></pre><div class="rwocodeinfo">Syntax ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/let_unit.syntax">front-end/let_unit.syntax</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11971808">
        If the expression has a different type, then write it
        explicitly.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword8">_</span><span class="keyword2">:</span>some_type<span class="keyword2">)</span> <span class="keyword2">=</span> <span class="keyword2">&lt;</span>expr<span class="keyword2">&gt;</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> ignore <span class="keyword2">(</span><span class="keyword2">&lt;</span>expr<span class="keyword2">&gt;</span> <span class="keyword2">:</span> some_type<span class="keyword2">)</span>
<span class="keyword2">)</span><span class="comments">(* if the expression returns a unit Deferred.t *)</span>
<span class="keyword4">let</span> <span class="keyword2">(</span><span class="keyword2">)</span> <span class="keyword2">=</span> don't_wait_for <span class="keyword2">(</span><span class="keyword2">&lt;</span>expr<span class="keyword2">&gt;</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/let_notunit.ml">front-end/let_notunit.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11973024">
        The last one is used to ignore Async expressions that should run
        in the background rather than blocking in the current thread.
      </p><p id="idp11973568">
        One other important reason for using wildcard matches is to bind
        a variable name to something that you want to use in future
        code, but don't want to use right away. This would normally
        generate an &quot;unused value&quot; compiler warning. These
        warnings are suppressed for any variable name that's prepended
        with an underscore.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> fn x y <span class="keyword2">=</span>
  <span class="keyword4">let</span> _z <span class="keyword2">=</span> x <span class="keyword2">+</span> y <span class="keyword4">in</span>
  <span class="keyword2">(</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/unused_var.ml">front-end/unused_var.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11975152">
        Although you don't use <code>_z</code> in your code, this
        will never generate an unused variable warning.
      </p></aside></section><section><h1 id="preprocessing-module-signatures">Preprocessing module signatures</h1><p id="idp11977792">
        Another useful feature of <code>type_conv</code> is that
        it can generate module signatures too. Copy the earlier type
        definition into a <code>comparelib_test.mli</code> that's
        got exactly the same content.
      </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> 
  foo<span class="keyword2">:</span> <span class="keyword3">string</span><span class="keyword2">;</span> 
  bar<span class="keyword2">:</span> t
<span class="keyword2">}</span> <span class="keyword1">with</span> compare</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/comparelib_test.mli">front-end/comparelib_test.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11980512">
        If you rerun the Camlp4 dumper script now, you'll see that
        different code is produced for signature files.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> sh camlp4_dump.cmd comparelib_test.mli
</div><div class="rwocodeout">type t = { foo : string; bar : t }</div><div class="rwocodeout"> </div><div class="rwocodeout">val compare : t -&gt; t -&gt; int</div><div class="rwocodeout">  </div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/process_comparelib_interface.out">front-end/process_comparelib_interface.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp11981776">
        The external signature generated by
        <code>comparelib</code> is much simpler than the actual
        code. Running Camlp4 directly on the original source code lets
        you see these all these transformations precisely.
      </p><aside class="caution"><h1>
      Don't overdo the syntax extensions
      </h1><p id="idp11983808">
        Syntax extensions are a powerful extension mechanism that can
        completely alter your source code's layout and style. Core
        includes a very conservative set of extensions that take care to
        minimize the syntax changes. There are a number of third-party
        libraries that are much more ambitious—some introduce
        whitespace-sensitive indentation, while others build entirely
        new embedded languages using OCaml as a host language, and yet
        others introduce conditional compilation for macros or optional
        logging.
      </p><p id="idp11985376">
        While it's tempting to compress all your boiler-plate code into
        Camlp4 extensions, it can make your source code much harder for
        other people to quickly read and understand. Core mainly focuses
        on type-driven code generation using the
        <code>type_conv</code> extension and doesn't fundamentally
        change the OCaml syntax.
      </p><p id="idp11986832">
        Another thing to consider before deploying your own syntax
        extension is compatibility with other extensions. Two separate
        extensions can create a grammar clash that leads to odd syntax
        errors and hard-to-reproduce bugs. That's why most of Core's
        syntax extensions go through <code>type_conv</code>, which
        acts as a single point for extending the grammar via the
        <code>with</code> keyword.
      </p></aside></section><section><h1 id="further-reading-on-camlp4">Further reading on Camlp4</h1><p id="idp11990400">
        We've deliberately only shown you how to use Camlp4 extensions
        here, and not how to build your own. The full details of
        building new extensions are fairly daunting and could be the
        subject of an entirely new book.
      </p><p id="idp11991056">
        The best resources to get started are:
      </p><ul><li><p id="idp11992016">
            a series of
            <a href="http://ambassadortothecomputers.blogspot.co.uk/p/reading-camlp4.html" target="_top">blog
            posts</a> by Jake Donham describe the internals of
            Camlp4 and its syntax extension mechanism.
          </p></li><li><p id="idp11993696">
            the online
            <a href="http://brion.inria.fr/gallium/index.php/Camlp4" target="_top">Camlp4
            wiki</a>.
          </p></li><li><p id="idp11995264">
            using OPAM to install existing Camlp4 extensions and
            inspecting their source code.
          </p></li></ul></section></section><section><h1 id="static-type-checking">Static type checking</h1><p id="idp11997440">
      After obtaining a valid abstract syntax tree, the compiler has to
      verify that the code obeys the rules of the OCaml type system.
      Code that is syntactically correct but misuses values is rejected
      with an explanation of the problem.
    </p><p id="idp11998096">
      Although type checking is done in a single pass in OCaml, it
      actually consists of three distinct steps that happen
      simultaneously:
    </p><ul><li><p id="idp11999168">
          an <span><em>automatic type inference</em></span> algorithm
          that calculates types for a module without requiring manual
          type annotations.
        </p></li><li><p id="idp12000528">
          a <span><em>module system</em></span> that combines software
          components with explicit knowledge of their type signatures.
        </p></li><li><p id="idp12001856">
<span><em>explicit subtyping</em></span> checks for objects and
          polymorphic variants.
        </p></li></ul><p id="idp12002992">
      Automatic type inference lets you write succinct code for a
      particular task and have the compiler ensure that your use of
      variables is locally consistent.
    </p><p id="idp12003568">
      Type inference doesn't scale to very large code bases that depend
      on separate compilation of files. A small change in one module may
      ripple through thousands of other files and libraries and require
      all of them to be recompiled. The module system solves this by
      providing the facility to combine and manipulate explicit type
      signatures for modules within a large project, and also to reuse
      them via functors and first-class modules.
    </p><p id="idp12004448">
      Subtyping in OCaml objects is always an explicit operation (via
      the <code>:&gt;</code> operator). This means that it doesn't
      complicate the core type inference engine and can be tested as a
      separate concern.
    </p><section><h1 id="displaying-inferred-types-from-the-compiler">Displaying inferred types from the compiler</h1><p id="idp12007024">
        We've already seen how you can explore type inference directly
        from the top-level. It's also possible to generate type
        signatures for an entire file by asking the compiler to do the
        work for you. Create a file with a single type definition and
        value.
      </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword6">Foo </span><span class="keyword2">|</span> <span class="keyword6">Bar
</span><span class="keyword4">let</span> v <span class="keyword2">=</span> Foo</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/typedef.ml">front-end/typedef.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12008448">
        Now run the compiler with the <code>-i</code> flag to
        infer the type signature for that file. This runs the type
        checker but doesn't compile the code any further after
        displaying the interface to the standard output.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -i typedef.ml
</div><div class="rwocodeout">type t = Foo | Bar</div><div class="rwocodeout">val v : t</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/infer_typedef.out">front-end/infer_typedef.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12010480">
        The output is the default signature for the module which
        represents the input file. It's often useful to redirect this
        output to an <code>mli</code> file to give you a starting
        signature to edit the external interface without having to type
        it all in by hand.
      </p><p id="idp12011840">
        The compiler stores a compiled version of the interface as a
        <code>cmi</code> file. This interface is either obtained
        from compiling an <code>mli</code> signature file for a
        module, or by the inferred type if there is only an
        <code>ml</code> implementation present.
      </p><p id="idp12014576">
        The compiler makes sure that your <code>ml</code> and
        <code>mli</code> files have compatible signatures. The
        type checker throws an immediate error if this isn't the case.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> <span class="nb">echo type </span><span class="nv">t</span> <span class="o">=</span> Foo &gt; test.ml
</div><div class="highlight"><span class="gp">$</span> <span class="nb">echo type </span><span class="nv">t</span> <span class="o">=</span> Bar &gt; test.mli
</div><div class="highlight"><span class="gp">$</span> ocamlc -c test.mli test.ml
</div><div class="rwocodeout">File &quot;test.ml&quot;, line 1:</div><div class="rwocodeout">Error: The implementation test.ml does not match the interface test.cmi:</div><div class="rwocodeout">       Type declarations do not match:</div><div class="rwocodeout">         type t = Foo</div><div class="rwocodeout">       is not included in</div><div class="rwocodeout">         type t = Bar</div><div class="rwocodeout">       File &quot;test.ml&quot;, line 1, characters 5-12: Actual declaration</div><div class="rwocodeout">       Fields number 1 have different names, Foo and Bar.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/conflicting_interfaces.out">front-end/conflicting_interfaces.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="note"><h1>
      Which comes first: the ml or the
      mli?
      </h1><p id="idp12019296">
        There are two schools of thought on which order OCaml code
        should be written in. It's very easy to begin writing code by
        starting with an <code>ml</code> file and using the type
        inference to guide you as you build up your functions. The
        <code>mli</code> file can then be generated as described
        above, and the exported functions documented.
      </p><p id="idp12021392">
        If you're writing code that spans multiple files, it's sometimes
        easier to start by writing all the <code>mli</code>
        signatures and checking that they type check against each other.
        Once the signatures are in place, you can write the
        implementations with the confidence that they'll all glue
        together correctly with no cyclic dependencies between the
        modules.
      </p><p id="idp12022864">
        As with any such stylistic debate, you should experiment with
        which system works best for you. Everyone agrees on one thing
        though: no matter what order you write them, production code
        should always explicitly define an <code>mli</code> file
        for every <code>ml</code> file in the project. It's also
        perfectly fine to have an <code>mli</code> file without a
        corresponding <code>ml</code> file if you're only
        declaring signatures (such as module types).
      </p><p id="idp12026416">
        Signature files provide a place to write succinct documentation
        and to abstract internal details that shouldn't be exported.
        Maintaining separate signature files also speeds up incremental
        compilation in larger code-bases, since recompiling a
        <code>mli</code> signature is much faster than a full
        compilation of the implementation to native code.
      </p></aside></section><section><h1 id="type-inference-1">Type inference</h1><p id="idp12029280">
        Type inference is the process of determining the appropriate
        types for expressions based on their use. It's a feature that's
        partially present in many other languages such as Haskell and
        Scala, but OCaml embeds it as a fundamental feature throughout
        the core language.
      </p><p id="idp12030000">
        OCaml type inference is based on the Hindley-Milner algorithm,
        which is notable for its ability to infer the most general type
        for an expression without requiring any explicit type
        annotations. The algorithm can deduce multiple types for an
        expression, and has the notion of a <span><em>principal
        type</em></span> that is the most general choice from the
        possible inferences. Manual type annotations can specialize the
        type explicitly, but the automatic inference selects the most
        general type unless told otherwise.
      </p><p id="idp12031392">
        OCaml does have some language extensions which strain the limits
        of principal type inference, but by and large most programs you
        write will never <span><em>require</em></span> annotations
        (although they sometimes help the compiler produce better error
        messages).
      </p><section><h1 id="adding-type-annotations-to-find-errors">Adding type annotations to find errors</h1><p id="idp12033648">
          It's often said that the hardest part of writing OCaml code is
          getting past the type checker—but once the code does compile,
          it works correctly the first time! This is an exaggeration of
          course, but it can certainly feel true when moving from a
          dynamically typed language. The OCaml static type system
          protects you from certain classes of bugs such as memory
          errors and abstraction violations by rejecting your program at
          compilation time rather than by generating an error at
          runtime. Learning how to navigate the type checker's
          compile-time feedback is key to building robust libraries and
          applications that take full advantage of these static checks.
        </p><p id="idp12034880">
          There are a couple of tricks to make it easier to quickly
          locate type errors in your code. The first is to introduce
          manual type annotations to narrow down the source of your
          error more accurately. These annotations shouldn't actually
          change your types and can be removed once your code is
          correct. However, they act as anchors to locate errors while
          you're still writing your code.
        </p><p id="idp12035744">
          Manual type annotations are particularly useful if you use
          lots of polymorphic variants or objects. Type inference with
          row polymorphism can generate some very large signatures, and
          errors tend to propagate more widely than if you are using
          more explicitly typed variants or classes.
        </p><p id="idp12036480">
          For instance, consider this broken example that expresses some
          simple algebraic operations over integers.
        </p><div class="rwocode"><pre><code><span class="keyword4">let</span> <span class="keyword4">rec</span> algebra <span class="keyword2">=</span>
  <span class="keyword1">function</span>
  <span class="keyword2">|</span> <span class="keyword6">`Add </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> <span class="keyword2">+</span> <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Sub </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> - <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Mul </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> <span class="keyword2">*</span> <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Num </span>x     -<span class="keyword2">&gt;</span> x

<span class="keyword4">let</span> <span class="keyword8">_</span> <span class="keyword2">=</span>
  algebra <span class="keyword2">(</span>
    <span class="keyword6">`Add </span><span class="keyword2">(</span>
      <span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">0</span><span class="keyword2">)</span>,
      <span class="keyword2">(</span><span class="keyword6">`Sub </span><span class="keyword2">(</span>
          <span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">1</span><span class="keyword2">)</span>,
          <span class="keyword2">(</span><span class="keyword6">`Mul </span><span class="keyword2">(</span>
              <span class="keyword2">(</span><span class="keyword6">`Nu </span><span class="keyword8">3</span><span class="keyword2">)</span>,<span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">2</span><span class="keyword2">)</span>
            <span class="keyword2">)</span><span class="keyword2">)</span>
        <span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/broken_poly.ml">front-end/broken_poly.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12037728">
          There's a single character typo in the code so that it uses
          <code>Nu</code> instead of <code>Num</code>. The
          resulting type error is impressive.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c broken_poly.ml
</div><div class="rwocodeout">File &quot;broken_poly.ml&quot;, line 9, characters 10-154:</div><div class="rwocodeout">Error: This expression has type</div><div class="rwocodeout">         [&gt; `Add of</div><div class="rwocodeout">              ([&lt; `Add of 'a * 'a</div><div class="rwocodeout">                | `Mul of 'a * 'a</div><div class="rwocodeout">                | `Num of int</div><div class="rwocodeout">                | `Sub of 'a * 'a</div><div class="rwocodeout">                &gt; `Num ]</div><div class="rwocodeout">               as 'a) *</div><div class="rwocodeout">              [&gt; `Sub of 'a * [&gt; `Mul of [&gt; `Nu of int ] * [&gt; `Num of int ] ] ] ]</div><div class="rwocodeout">       but an expression was expected of type 'a</div><div class="rwocodeout">       The second variant type does not allow tag(s) `Nu</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_broken_poly.out">front-end/build_broken_poly.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12040400">
          The type error is perfectly accurate, but rather verbose and
          with a line number that doesn't point to the exact location of
          the incorrect variant name. The best the compiler can do is to
          point you in the general direction of the
          <code>algebra</code> function application.
        </p><p id="idp12041824">
          This is because the type checker doesn't have enough
          information to match the inferred type of the
          <code>algebra</code> definition to its application a few
          lines down. It calculates types for both expressions
          separately, and when they don't match up, outputs the
          difference as best it can.
        </p><p id="idp12043264">
          Let's see what happens with an explicit type annotation to
          help the compiler out.
        </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">[</span>
  <span class="keyword2">|</span> <span class="keyword6">`Add </span><span class="keyword2">of</span> t <span class="keyword2">*</span> t
  <span class="keyword2">|</span> <span class="keyword6">`Sub </span><span class="keyword2">of</span> t <span class="keyword2">*</span> t
  <span class="keyword2">|</span> <span class="keyword6">`Mul </span><span class="keyword2">of</span> t <span class="keyword2">*</span> t
  <span class="keyword2">|</span> <span class="keyword6">`Num </span><span class="keyword2">of</span> <span class="keyword3">int</span>
<span class="keyword2">]</span>

<span class="keyword4">let</span> <span class="keyword4">rec</span> algebra <span class="keyword2">(</span>x<span class="keyword2">:</span>t<span class="keyword2">)</span> <span class="keyword2">=</span>
  <span class="keyword1">match</span> x <span class="keyword1">with</span>
  <span class="keyword2">|</span> <span class="keyword6">`Add </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> <span class="keyword2">+</span> <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Sub </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> - <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Mul </span><span class="keyword2">(</span>x,y<span class="keyword2">)</span> -<span class="keyword2">&gt;</span> <span class="keyword2">(</span>algebra x<span class="keyword2">)</span> <span class="keyword2">*</span> <span class="keyword2">(</span>algebra y<span class="keyword2">)</span>
  <span class="keyword2">|</span> <span class="keyword6">`Num </span>x     -<span class="keyword2">&gt;</span> x

<span class="keyword4">let</span> <span class="keyword8">_</span> <span class="keyword2">=</span>
  algebra <span class="keyword2">(</span>
    <span class="keyword6">`Add </span><span class="keyword2">(</span>
      <span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">0</span><span class="keyword2">)</span>,
      <span class="keyword2">(</span><span class="keyword6">`Sub </span><span class="keyword2">(</span>
          <span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">1</span><span class="keyword2">)</span>,
          <span class="keyword2">(</span><span class="keyword6">`Mul </span><span class="keyword2">(</span>
              <span class="keyword2">(</span><span class="keyword6">`Nu </span><span class="keyword8">3</span><span class="keyword2">)</span>,<span class="keyword2">(</span><span class="keyword6">`Num </span><span class="keyword8">2</span><span class="keyword2">)</span>
            <span class="keyword2">)</span><span class="keyword2">)</span>
        <span class="keyword2">)</span><span class="keyword2">)</span>
    <span class="keyword2">)</span><span class="keyword2">)</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/broken_poly_with_annot.ml">front-end/broken_poly_with_annot.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12044512">
          This code contains exactly the same error as before, but we've
          added a closed type definition of the polymorphic variants,
          and a type annotation to the <code>algebra</code>
          definition. The compiler error we get is much more useful now.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -i broken_poly_with_annot.ml
</div><div class="rwocodeout">File &quot;broken_poly_with_annot.ml&quot;, line 22, characters 14-21:</div><div class="rwocodeout">Error: This expression has type [&gt; `Nu of int ]</div><div class="rwocodeout">       but an expression was expected of type t</div><div class="rwocodeout">       The second variant type does not allow tag(s) `Nu</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_broken_poly_with_annot.out">front-end/build_broken_poly_with_annot.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12046608">
          This error points directly to the correct line number that
          contains the typo. Once you fix the problem, you can remove
          the manual annotations if you prefer more succinct code. You
          can also leave the annotations there of course, to help with
          future refactoring and debugging.
        </p></section><section><h1 id="enforcing-principal-typing">Enforcing principal typing</h1><p id="idp12048672">
          The compiler also has a stricter <span><em>principal type
          checking</em></span> mode that is activated via the
          <code>-principal</code> flag. This warns about risky
          uses of type information to ensure that the type inference has
          one principal result. A type is considered risky if the
          success or failure of type inference depends on the order in
          which sub-expressions are typed.
        </p><p id="idp12050608">
          The principality check only affects a few language features:
        </p><ul><li><p id="idp12051600">
              polymorphic methods for objects.
            </p></li><li><p id="idp12052448">
              permuting the order of labeled arguments in a function
              from their type definition.
            </p></li><li><p id="idp12053360">
              discarding optional labeled arguments.
            </p></li><li><p id="idp12054208">
              generalized algebraic data types (GADTs) present from
              OCaml 4.0 onwards.
            </p></li><li><p id="idp12055104">
              automatic disambiguation of record field and constructor
              names (since OCaml 4.1)
            </p></li></ul><p id="idp12055888">
          Here's an example of principality warnings when used with
          record disambiguation.
        </p><div class="rwocode"><pre><code><span class="keyword4">type</span> s <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> unit <span class="keyword2">}</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword2">}</span>

<span class="keyword4">let</span> f x <span class="keyword2">=</span>
  x.bar<span class="keyword2">;</span>
  x.foo</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/non_principal.ml">front-end/non_principal.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12057120">
          Inferring the signature with <code>-principal</code>
          will show you a new warning.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -i -principal non_principal.ml
</div><div class="rwocodeout">File &quot;non_principal.ml&quot;, line 6, characters 4-7:</div><div class="rwocodeout">Warning 18: this type-based field disambiguation is not principal.</div><div class="rwocodeout">type s = { foo : int; bar : unit; }</div><div class="rwocodeout">type t = { foo : int; }</div><div class="rwocodeout">val f : s -&gt; int</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_non_principal.out">front-end/build_non_principal.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12059056">
          This example isn't principal since the inferred type for
          <code>x.foo</code> is guided by the inferred type of
          <code>x.bar</code>, whereas principal typing requires
          that each sub-expression's type can be calculated
          independently. If the <code>x.bar</code> use is removed
          from the definition of <code>f</code>, its argument
          would be of type <code>t</code> and not
          <code>type s</code>.
        </p><p id="idp12064000">
          You can fix this either by permuting the order of the type
          declarations, or by adding an explicit type annotation.
        </p><div class="rwocode"><pre><code><span class="keyword4">type</span> s <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span><span class="keyword2">;</span> bar<span class="keyword2">:</span> unit <span class="keyword2">}</span>
<span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword2">{</span> foo<span class="keyword2">:</span> <span class="keyword3">int</span> <span class="keyword2">}</span>

<span class="keyword4">let</span> f <span class="keyword2">(</span>x<span class="keyword2">:</span>s<span class="keyword2">)</span> <span class="keyword2">=</span>
  x.bar<span class="keyword2">;</span>
  x.foo</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/principal.ml">front-end/principal.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12065264">
          There is now no ambiguity about the inferred types, since
          we've explicitly given the argument a type and the order of
          inference of the sub-expressions no longer matters.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -i -principal principal.ml
</div><div class="rwocodeout">type s = { foo : int; bar : unit; }</div><div class="rwocodeout">type t = { foo : int; }</div><div class="rwocodeout">val f : s -&gt; int</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/build_principal.out">front-end/build_principal.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12066592">
          The <span><strong>ocamlbuild</strong></span> equivalent is to add the tag
          <code>principal</code> to your build. The
          <code>corebuild</code> wrapper script actually adds this
          by default, but it does no harm to explicitly repeat it, as
          below.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -tag principal principal.cmi non_principal.cmi
</div><div class="rwocodeout">File &quot;non_principal.ml&quot;, line 6, characters 4-7:</div><div class="rwocodeout">Warning 18: this type-based field disambiguation is not principal.</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/principal/build_principal.out">principal/build_principal.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12070048">
          Ideally, all code should systematically use
          <code>-principal</code>. It reduces variance in type
          inference and enforces the notion of a single known type.
          However, there are drawbacks to this mode: type inference is
          slower and the <code>cmi</code> files become larger.
          This is generally only a problem if you use objects
          extensively, which usually have larger type signature to cover
          all their methods.
        </p><p id="idp12072272">
          If compiling in principal mode works, it is guaranteed that
          the program will pass type checking in non-principal mode too.
          For this reason, the <span><strong>corebuild</strong></span> wrapper
          script activates principal mode by default, preferring
          stricter type inference over a small loss in compilation speed
          and extra disk space usage.
        </p><p id="idp12073744">
          Bear in mind that the <code>cmi</code> files generated
          in principal mode differ from the default mode. Try to ensure
          that you compile your whole project with it activated. Getting
          the files mixed up won't let you violate type safety, but can
          result in the type checker failing unexpectedly very
          occasionally. In this case, just recompile with a clean source
          tree.
        </p></section></section><section><h1 id="modules-and-separate-compilation">Modules and separate compilation</h1><p id="idp12077024">
        The OCaml module system enables smaller components to be reused
        effectively in large projects while still retaining all the
        benefits of static type safety. We covered the basics of using
        modules earlier in
        <a href="files-modules-and-programs.html">Chapter 4, <i>Files, Modules and Programs</i></a>. The
        module language that operates over these signatures also extends
        to functors and first-class modules, described in
        <a href="functors.html">Chapter 9, <i>Functors</i></a> and
        <a href="first-class-modules.html">Chapter 10, <i>First-Class Modules</i></a> respectively.
      </p><p id="idp12079840">
        This section discusses how the compiler implements them in more
        detail. Modules are essential for larger projects that consist
        of many source files (also known as <span><em>compilation
        units</em></span>). It's impractical to recompile every single
        source file when changing just one or two files, and the module
        system minimizes such recompilation while still encouraging code
        reuse.
      </p><section><h1 id="the-mapping-between-files-and-modules">The mapping between files and modules</h1><p id="idp12082224">
          Individual compilation units provide a convenient way to break
          up a big module hierarchy into a collection of files. The
          relationship between files and modules can be explained
          directly in terms of the module system.
        </p><p id="idp12082896">
          Create a file called <code>alice.ml</code> with the
          following contents.
        </p><div class="rwocode"><pre><code><span class="keyword4">let</span> friends <span class="keyword2">=</span> <span class="keyword2">[</span> <span class="keyword5">Bob.</span>name <span class="keyword2">]</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/alice.ml">front-end/alice.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12084800">
          and a corresponding signature file.
        </p><div class="rwocode"><pre><code><span class="keyword4">val</span> friends <span class="keyword2">:</span> <span class="keyword5">Bob.</span>t <span class="keyword3">list</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/alice.mli">front-end/alice.mli</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12085968">
          These two files are exactly analogous to including the
          following code directly in another module that references
          <code>Alice</code>.
        </p><div class="rwocode"><pre><code><span class="keyword4">module</span> <span class="keyword6">Alice </span><span class="keyword2">:</span> <span class="keyword4">sig</span>
  <span class="keyword4">val</span> friends <span class="keyword2">:</span> <span class="keyword5">Bob.</span>t <span class="keyword3">list</span>
<span class="keyword4">end</span> <span class="keyword2">=</span> <span class="keyword4">struct</span>
  <span class="keyword4">let</span> friends <span class="keyword2">=</span> <span class="keyword2">[</span> <span class="keyword5">Bob.</span>name <span class="keyword2">]</span>
<span class="keyword4">end</span></code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/alice_combined.ml">front-end/alice_combined.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div></section><section><h1 id="defining-a-module-search-path">Defining a module search path</h1><p id="idp12089280">
          In the example above, <code>Alice</code> also has a
          reference to another module <code>Bob</code>. For the
          overall type of <code>Alice</code> to be valid, the
          compiler also needs to check that the <code>Bob</code>
          module contains at least a <code>Bob.name</code> value
          and defines a <code>Bob.t</code> type.
        </p><p id="idp12094096">
          The type checker resolves such module references into concrete
          structures and signatures in order to unify types across
          module boundaries. It does this by searching a list of
          directories for a compiled interface file matching that
          module's name. For example, it will look for
          <code>alice.cmi</code> and <code>bob.cmi</code> on
          the search path, and use the first ones it encounters as the
          interfaces for <code>Alice</code> and
          <code>Bob</code>.
        </p><p id="idp12097760">
          The module search path is set by adding <code>-I</code>
          flags to the compiler command-line with the directory
          containing the <code>cmi</code> files as the argument.
          Manually specifying these flags gets complex when you have
          lots of libraries, and is the reason why the OCamlfind
          frontend to the compiler exists. OCamlfind automates the
          process of turning third-party package names and build
          descriptions into command-line flags that are passed to the
          compiler command-line.
        </p><p id="idp12100448">
          By default, only the current directory and the OCaml standard
          library will be searched for <code>cmi</code> files. The
          <code>Pervasives</code> module from the standard library
          will also be opened by default in every compilation unit. The
          standard library location is obtained by running
          <code>ocamlc -where</code>, and can be overridden by
          setting the <code>CAMLLIB</code> environment variable.
          Needless to say, don't override the default path unless you
          have a good reason to (such as setting up a cross-compilation
          environment).
        </p><section><h1><b>
        Inspecting compilation units with
        <code>ocamlobjinfo</code>
</b></h1><p id="idp12105568">
          For separate compilation to be sound, we need to ensure that
          all the <code>cmi</code> files used to type-check a
          module are the same across compilation runs. If they vary,
          this raises the possibility of two modules checking different
          type signatures for a common module with the same name. This
          in turn lets the program completely violate the static type
          system and can lead to memory corruption and crashes.
        </p><p id="idp12107120">
          OCaml guards against this by recording a MD5 checksum in every
          <code>cmi</code>. Let's examine our earlier
          <code>typedef.ml</code> more closely.
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c typedef.ml
</div><div class="highlight"><span class="gp">$</span> ocamlobjinfo typedef.cmi
</div><div class="rwocodeout">File typedef.cmi</div><div class="rwocodeout">Unit name: Typedef</div><div class="rwocodeout">Interfaces imported:</div><div class="rwocodeout">	bd274dc132ce5c3d8b6774d19cd373a6	Typedef</div><div class="rwocodeout">	36b5bc8227dc9914c6d9fd9bdcfadb45	Pervasives</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/typedef_objinfo.out">front-end/typedef_objinfo.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12109744">
<code>ocamlobjinfo</code> examines the compiled
          interface and displays what other compilation units it depends
          on. In this case, we don't use any external modules other than
          <code>Pervasives</code>. Every module depends on
          <code>Pervasives</code> by default, unless you use the
          <code>-nopervasives</code> flag (this is an advanced
          use-case, and you shouldn't normally need it).
        </p><p id="idp12113296">
          The long alphanumeric identifier beside each module name is a
          hash calculated from all the types and values exported from
          that compilation unit. It's used during type-checking and
          linking to ensure that all of the compilation units have been
          compiled consistently against each other. A difference in the
          hashes means that a compilation unit with the same module name
          may have conflicting type signatures in different modules. The
          compiler will reject such programs with an error similar to
          this:
        </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -c foo.ml
</div><div class="rwocodeout">File &quot;foo.ml&quot;, line 1, characters 0-1:</div><div class="rwocodeout">Error: The files /home/build/bar.cmi</div><div class="rwocodeout">       and /usr/lib/ocaml/map.cmi make inconsistent assumptions</div><div class="rwocodeout">       over interface Map</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/inconsistent_compilation_units.out">front-end/inconsistent_compilation_units.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12115024">
          This hash check is very conservative, but ensures that
          separate compilation remains type-safe all the way up to the
          final link phase. Your build system should ensure that you
          never see the error messages above, but if you do run into it,
          just clean out your intermediate files and recompile from
          scratch.
        </p></section></section></section><section><h1 id="packing-modules-together">Packing modules together</h1><p id="idp12117312">
        The module-to-file mapping described so far rigidly enforces a
        1:1 mapping between a top-level module and a file. It's often
        convenient to split larger modules into separate files to make
        editing and version control easier, but still compile them all
        into a single OCaml module.
      </p><p id="idp12118032">
        The <code>-pack</code> compiler option accepts a list of
        compiled object files (<code>.cmo</code> in bytecode and
        <code>.cmx</code> for native code) and their associated
        <code>.cmi</code> compiled interfaces, and combines them
        into a single module that contains them as sub-modules of the
        output. Packing thus generates an entirely new
        <code>.cmo</code> (or <code>.cmx</code> file) and
        <code>.cmi</code> that includes the input modules.
      </p><p id="idp12123776">
        Packing for native code introduces an additional requirement:
        the modules that are intended to be packed must be compiled with
        the <code>-for-pack</code> argument that specifies the
        eventual name of the pack. The easiest way to handle packing is
        to let <span><strong>ocamlbuild</strong></span> figure out the command-line
        arguments for you, so let's try that out next with a simple
        example.
      </p><p id="idp12125984">
        First, create a couple of toy modules called
        <code>A.ml</code> and <code>B.ml</code> that contain
        a single value. You will also need a <code>_tags</code>
        file that adds the <code>-for-pack</code> option for the
        <code>cmx</code> files (but careful to exclude the pack
        target itself). Finally, the <code>X.mlpack</code> file
        contains the list of modules that are intended to be packed
        under module <code>X</code>. There are special rules in
        <span><strong>ocamlbuild</strong></span> that tell it how to map
        <code>%.mlpack</code> files to the packed
        <code>%.cmx</code> or <code>%.cmo</code> equivalent.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> cat A.ml
</div><div class="rwocodeout">let v = &quot;hello&quot;</div><div class="highlight"><span class="gp">$</span> cat B.ml
</div><div class="rwocodeout">let w = 42</div><div class="highlight"><span class="gp">$</span> cat _tags
</div><div class="rwocodeout">&lt;*.cmx&gt; and not &quot;X.cmx&quot;: for-pack(X)</div><div class="highlight"><span class="gp">$</span> cat X.mlpack
</div><div class="rwocodeout">A</div><div class="rwocodeout">B</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/packing/show_files.out">packing/show_files.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12135344">
        You can now run <code>corebuild</code> to build the
        <code>X.cmx</code> file directly, but let's create a new
        module to link against <code>X</code> to complete the
        example.
      </p><div class="rwocode"><pre><code><span class="keyword4">let</span> v <span class="keyword2">=</span> <span class="keyword5">X.</span><span class="keyword5">A.</span>v
<span class="keyword4">let</span> w <span class="keyword2">=</span> <span class="keyword5">X.</span><span class="keyword5">B.</span>w</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/packing/test.ml">packing/test.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12138688">
        You can now compile this test module and see that its inferred
        interface is the result of using the packed contents of
        <code>X</code>. We further verify this by examining the
        imported interfaces in <code>Test</code> and confirming
        that neither <code>A</code> nor <code>B</code> are
        mentioned in there and that only the packed <code>X</code>
        module is used.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild test.inferred.mli test.cmi
</div><div class="highlight"><span class="gp">$</span> cat _build/test.inferred.mli
</div><div class="rwocodeout">val v : string</div><div class="rwocodeout">val w : int</div><div class="highlight"><span class="gp">$</span> ocamlobjinfo _build/test.cmi
</div><div class="rwocodeout">File _build/test.cmi</div><div class="rwocodeout">Unit name: Test</div><div class="rwocodeout">Interfaces imported:</div><div class="rwocodeout">	906fc1b74451f0c24ceaa085e0f26e5f	Test</div><div class="rwocodeout">	36b5bc8227dc9914c6d9fd9bdcfadb45	Pervasives</div><div class="rwocodeout">	25f4b4e10ec64c56b2987f5900045fec	X</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/packing/build_test.out">packing/build_test.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><aside class="warning"><h1>
      Packing and search paths
      </h1><p id="idp12144256">
        One very common build error that happens with packing is
        confusion resulting from building the packed
        <code>cmi</code> in the same directory as the sub-modules.
        When you add this directory to your module search path, the
        sub-modules are also visible. If you forget to include the
        top-level prefix (e.g <code>X.A</code>) and instead use a
        sub-module directly (<code>A</code>), then this will
        compile and link fine.
      </p><p id="idp12147152">
        However, the types of <code>A</code> and
        <code>X.A</code> are <span><em>not</em></span>
        automatically equivalent, and so the type checker will complain
        if you attempt to mix-and-match the packed and unpacked versions
        of the library.
      </p><p id="idp12149536">
        This mostly only happens with unit tests since they are built at
        the same time as the library. You can avoid it by being aware of
        the need to open the packed module from the test, or only using
        the library after it has been installed (and hence not exposing
        the intermediate compiled modules).
      </p></aside></section><section><h1 id="shorter-module-paths-in-type-errors">Shorter module paths in type errors</h1><p id="idp12151728">
        Core uses the OCaml module system quite extensively to provide a
        complete replacement standard library. It collects these modules
        into a single <code>Std</code> module which provides a
        single module that needs to be opened to import the replacement
        modules and functions.
      </p><p id="idp12153104">
        There's one downside to this approach: type errors suddenly get
        much more verbose. We can see this if you run the vanilla OCaml
        top-level (not <span><strong>utop</strong></span>).
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocaml
</div><div class="rwocodeout"># List.map print_endline &quot;&quot; ;;</div><div class="rwocodeout">Error: This expression has type string but an expression was expected of type</div><div class="rwocodeout">         string list</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/short_paths_1.out">front-end/short_paths_1.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12155120">
        This type error without <code>Core.Std</code> has a
        straightforward type error. When we switch to Core, though, it
        gets more verbose.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocaml
</div><div class="rwocodeout"># open Core.Std ;;</div><div class="rwocodeout"># List.map ~f:print_endline &quot;&quot; ;;</div><div class="rwocodeout">Error: This expression has type string but an expression was expected of type</div><div class="rwocodeout">         'a Core.Std.List.t = 'a list</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/short_paths_2.out">front-end/short_paths_2.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12157088">
        The default <code>List</code> module in OCaml is
        overridden by <code>Core.Std.List</code>. The compiler
        does its best to show the type equivalence, but at the cost of a
        more verbose error message.
      </p><p id="idp12159088">
        The compiler can remedy this via a so-called &quot;short
        paths&quot; heuristic. This causes the compiler to search all
        the type aliases for the shortest module path, and use that as
        the preferred output type. The option is activated by passing
        <code>-short-paths</code> to the compiler, and works on
        the top-level too.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocaml -short-paths
</div><div class="rwocodeout"># open Core.Std;;</div><div class="rwocodeout"># List.map ~f:print_endline &quot;foo&quot;;;</div><div class="rwocodeout">Error: This expression has type string but an expression was expected of type</div><div class="rwocodeout">         'a list</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/short_paths_3.out">front-end/short_paths_3.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12161600">
        The <span><strong>utop</strong></span> enhanced top-level activates short
        paths by default, which is why you've not had to do this before
        in our interactive examples. However, the compiler doesn't
        default to the short path heuristic since there are some
        situations where the type aliasing information is useful to
        know, and would be lost in the error if the shortest module path
        is always picked.
      </p><p id="idp12163136">
        You'll need to choose for yourself if you prefer short paths or
        the default behavior in your own projects, and pass the
        <code>-short-paths</code> flag to the compiler if you need
        it.
      </p></section></section><section><h1 id="the-typed-syntax-tree">The typed syntax tree</h1><p id="idp12165776">
      When the type checking process has successfully completed, it is
      combined with the AST to form a <span><em>typed abstract syntax
      tree</em></span>. This contains precise location information for
      every token in the input file, and decorates each token with
      concrete type information.
    </p><p id="idp12166896">
      The compiler can output this as compiled <code>cmt</code>
      and <code>cmti</code> files that contain the typed AST for
      the implementation and signatures of a compilation unit. This is
      activated by passing the <code>-bin-annot</code> flag to the
      compiler.
    </p><p id="idp12169616">
      The <code>cmt</code> files are particularly useful for IDE
      tools to match up OCaml source code at a specific location to the
      inferred or external types.
    </p><section><h1 id="using-ocp-index-for-auto-completion">Using ocp-index for auto-completion</h1><p id="idp12172000">
        One such command-line tool to display auto-completion
        information in your editor is <span><strong>ocp-index</strong></span>.
        Install it via OPAM as follows.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> opam install ocp-index
</div><div class="highlight"><span class="gp">$</span> ocp-index
</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/install_ocp_index.out">front-end/install_ocp_index.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12173968">
        Let's refer back to our Ncurses binding example from the
        beginning of
        <a href="foreign-function-interface.html">Chapter 19, <i>Foreign Function Interface</i></a>. This
        module defined bindings for the Ncurses library. First, compile
        the interfaces with <code>-bin-annot</code> so that we can
        obtain the <code>cmt</code> and <code>cmti</code>
        files, and then run <span><strong>ocp-index</strong></span> in completion
        mode.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> corebuild -pkg ctypes.foreign -tag bin_annot ncurses.cmi
</div><div class="highlight"><span class="gp">$</span> ocp-index <span class="nb">complete</span> -I . Ncur
</div><div class="rwocodeout">Ncurses module</div><div class="highlight"><span class="gp">$</span> ocp-index <span class="nb">complete</span> -I . Ncurses.a
</div><div class="rwocodeout">Ncurses.addstr val string -&gt; unit</div><div class="highlight"><span class="gp">$</span> ocp-index <span class="nb">complete</span> -I . Ncurses.
</div><div class="rwocodeout">Ncurses.window val Ncurses.window Ctypes.typ</div><div class="rwocodeout">Ncurses.wrefresh val Ncurses.window -&gt; unit</div><div class="rwocodeout">Ncurses.initscr val unit -&gt; Ncurses.window</div><div class="rwocodeout">Ncurses.endwin val unit -&gt; unit</div><div class="rwocodeout">Ncurses.refresh val unit -&gt; unit</div><div class="rwocodeout">Ncurses.newwin val int -&gt; int -&gt; int -&gt; int -&gt; Ncurses.window</div><div class="rwocodeout">Ncurses.mvwaddch val Ncurses.window -&gt; int -&gt; int -&gt; char -&gt; unit</div><div class="rwocodeout">Ncurses.mvwaddstr val Ncurses.window -&gt; int -&gt; int -&gt; string -&gt; unit</div><div class="rwocodeout">Ncurses.addstr val string -&gt; unit</div><div class="rwocodeout">Ncurses.box val Ncurses.window -&gt; char -&gt; char -&gt; unit</div><div class="rwocodeout">Ncurses.cbreak val unit -&gt; int</div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/ocp-index/index_ncurses.out">ocp-index/index_ncurses.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12178880">
        You need to pass <span><strong>ocp-index</strong></span> a set of
        directories to search for <code>cmt</code> files in, and a
        fragment of text to autocomplete. As you can imagine,
        autocompletion is invaluable on larger codebases. See the
        <a href="https://github.com/ocamlpro/ocp-index" target="_top">ocp-index</a>
        homepage for more information on how to integrate it with your
        favorite editor.
      </p></section><section><h1 id="examining-the-typed-syntax-tree-directly">Examining the typed syntax tree directly</h1><p id="idp12183040">
        The compiler has a couple of advanced flags that can dump the
        raw output of the internal AST representation. You can't depend
        on these flags to give the same output across compiler
        revisions, but they are a useful learning tool.
      </p><p id="idp12183712">
        We'll use our toy <code>typedef.ml</code> again.
      </p><div class="rwocode"><pre><code><span class="keyword4">type</span> t <span class="keyword2">=</span> <span class="keyword6">Foo </span><span class="keyword2">|</span> <span class="keyword6">Bar
</span><span class="keyword4">let</span> v <span class="keyword2">=</span> Foo</code></pre><div class="rwocodeinfo">OCaml ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/typedef.ml">front-end/typedef.ml</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12185584">
        Let's first look at the untyped syntax tree that's generated
        from the parsing phase.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dparsetree typedef.ml 2&gt;&amp;1
</div><div class="rwocodeout">[</div><div class="rwocodeout">  structure_item (typedef.ml[1,0+0]..[1,0+18])</div><div class="rwocodeout">    Pstr_type</div><div class="rwocodeout">    [</div><div class="rwocodeout">      &quot;t&quot; (typedef.ml[1,0+5]..[1,0+6])</div><div class="rwocodeout">        type_declaration (typedef.ml[1,0+5]..[1,0+18])</div><div class="rwocodeout">          ptype_params =</div><div class="rwocodeout">            []</div><div class="rwocodeout">          ptype_cstrs =</div><div class="rwocodeout">            []</div><div class="rwocodeout">          ptype_kind =</div><div class="rwocodeout">            Ptype_variant</div><div class="rwocodeout">              [</div><div class="rwocodeout">                (typedef.ml[1,0+9]..[1,0+12])</div><div class="rwocodeout">                  &quot;Foo&quot; (typedef.ml[1,0+9]..[1,0+12])</div><div class="rwocodeout">                  []</div><div class="rwocodeout">                  None</div><div class="rwocodeout">                (typedef.ml[1,0+15]..[1,0+18])</div><div class="rwocodeout">                  &quot;Bar&quot; (typedef.ml[1,0+15]..[1,0+18])</div><div class="rwocodeout">                  []</div><div class="rwocodeout">                  None</div><div class="rwocodeout">              ]</div><div class="rwocodeout">          ptype_private = Public</div><div class="rwocodeout">          ptype_manifest =</div><div class="rwocodeout">            None</div><div class="rwocodeout">    ]</div><div class="rwocodeout">  structure_item (typedef.ml[2,19+0]..[2,19+11])</div><div class="rwocodeout">    Pstr_value Nonrec</div><div class="rwocodeout">    [</div><div class="rwocodeout">      &lt;def&gt;</div><div class="rwocodeout">        pattern (typedef.ml[2,19+4]..[2,19+5])</div><div class="rwocodeout">          Ppat_var &quot;v&quot; (typedef.ml[2,19+4]..[2,19+5])</div><div class="rwocodeout">        expression (typedef.ml[2,19+8]..[2,19+11])</div><div class="rwocodeout">          Pexp_construct &quot;Foo&quot; (typedef.ml[2,19+8]..[2,19+11])</div><div class="rwocodeout">          None</div><div class="rwocodeout">          false</div><div class="rwocodeout">    ]</div><div class="rwocodeout">]</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/parsetree_typedef.out">front-end/parsetree_typedef.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12186816">
        This is rather a lot of output for a simple two-line program,
        but it shows just how much structure the OCaml parser generates
        even from a small source file.
      </p><p id="idp12187408">
        Each portion of the AST is decorated with the precise location
        information (including the filename and character location of
        the token). This code hasn't been type checked yet, and so the
        raw tokens are all included.
      </p><p id="idp12188064">
        The typed AST that is normally output as a compiled
        <code>cmt</code> file can be displayed in a more
        developer-readable form via the <code>-dtypedtree</code>
        option.
      </p><div class="rwocode"><pre><code><div class="highlight"><span class="gp">$</span> ocamlc -dtypedtree typedef.ml 2&gt;&amp;1
</div><div class="rwocodeout">[</div><div class="rwocodeout">  structure_item (typedef.ml[1,0+0]..typedef.ml[1,0+18])</div><div class="rwocodeout">    Pstr_type</div><div class="rwocodeout">    [</div><div class="rwocodeout">      t/1008</div><div class="rwocodeout">        type_declaration (typedef.ml[1,0+5]..typedef.ml[1,0+18])</div><div class="rwocodeout">          ptype_params =</div><div class="rwocodeout">            []</div><div class="rwocodeout">          ptype_cstrs =</div><div class="rwocodeout">            []</div><div class="rwocodeout">          ptype_kind =</div><div class="rwocodeout">            Ptype_variant</div><div class="rwocodeout">              [</div><div class="rwocodeout">                &quot;Foo/1009&quot;</div><div class="rwocodeout">                  []</div><div class="rwocodeout">                &quot;Bar/1010&quot;</div><div class="rwocodeout">                  []</div><div class="rwocodeout">              ]</div><div class="rwocodeout">          ptype_private = Public</div><div class="rwocodeout">          ptype_manifest =</div><div class="rwocodeout">            None</div><div class="rwocodeout">    ]</div><div class="rwocodeout">  structure_item (typedef.ml[2,19+0]..typedef.ml[2,19+11])</div><div class="rwocodeout">    Pstr_value Nonrec</div><div class="rwocodeout">    [</div><div class="rwocodeout">      &lt;def&gt;</div><div class="rwocodeout">        pattern (typedef.ml[2,19+4]..typedef.ml[2,19+5])</div><div class="rwocodeout">          Ppat_var &quot;v/1011&quot;</div><div class="rwocodeout">        expression (typedef.ml[2,19+8]..typedef.ml[2,19+11])</div><div class="rwocodeout">          Pexp_construct &quot;Foo&quot;</div><div class="rwocodeout">          []</div><div class="rwocodeout">          false</div><div class="rwocodeout">    ]</div><div class="rwocodeout">]</div><div class="rwocodeout"> </div></code></pre><div class="rwocodeinfo">Terminal ∗ <a href="http://github.com/realworldocaml/examples/blob/master/code/front-end/typedtree_typedef.out">front-end/typedtree_typedef.out</a>  ∗ <a href="http://github.com/realworldocaml/examples/">all code</a></div></div><p id="idp12190720">
        The typed AST is more explicit than the untyped syntax tree. For
        instance, the type declaration has been given a unique name
        (<code>t/1008</code>), as has the <code>v</code>
        value (<code>v/1011</code>).
      </p><p id="idp12193392">
        You'll rarely need to look at this raw output from the compiler
        unless you're building IDE tools such as
        <span><strong>ocp-index</strong></span>, or are hacking on extensions to
        the core compiler itself. However, it's useful to know that this
        intermediate form exists before we delve further into the code
        generation process next in
        <a href="the-compiler-backend-byte-code-and-native-code.html">Chapter 23, <i>The Compiler Backend: Byte-code and Native-code</i></a>.
      </p></section></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="understanding-the-garbage-collector.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="the-compiler-backend-byte-code-and-native-code.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>