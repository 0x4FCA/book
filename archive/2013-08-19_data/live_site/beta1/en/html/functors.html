<html>

    <head>
    
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta name="robots" content="NOINDEX, NOARCHIVE, NOFOLLOW"/>
        
        <title>Chapter 9. Functors / Real World OCaml</title>
        
        <link rel="stylesheet" href="../../media/css/main.css"/>
        
        <script src="../../media/js/require.js" data-main="../../media/js/main.js"> </script>
        <script>
            require.config({
                config: {
                    gitHub: {
                        user: 'ocamllabs',
                        repo: 'rwo\u002Dcomments',
                        milestone: 'beta1',
                        page: 'functors.html'
                    }
                }
            });
        </script>
        
    
    </head>
    
    <body>
    
        <div class="body">
        
            <header class="header">
                <h1><img src="../../media/img/header.png" width="213" height="59" alt="Real World OCaml, by Jason Hickey, Anil Madhavapeddy and Yaron Minsky"/></h1>
            </header>
    
            <nav class="navigation">
                <ul>
                    <li>
                        <a href="index.html">Table of Contents</a>
                    </li>
                    
                        <li>
                            <a href="prologue.html">Prologue</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt01.html">I. Language Concepts</a>
                            
                                 
                                    <ul>
                                        
                                            <li>
                                                <a href="a-guided-tour.html">1. A Guided Tour</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variables-and-functions.html">2. Variables and Functions</a>
                                            </li>
                                        
                                            <li>
                                                <a href="lists-and-patterns.html">3. Lists and Patterns</a>
                                            </li>
                                        
                                            <li>
                                                <a href="files-modules-and-programs.html">4. Files, Modules and Programs</a>
                                            </li>
                                        
                                            <li>
                                                <a href="records.html">5. Records</a>
                                            </li>
                                        
                                            <li>
                                                <a href="variants.html">6. Variants</a>
                                            </li>
                                        
                                            <li>
                                                <a href="error-handling.html">7. Error Handling</a>
                                            </li>
                                        
                                            <li>
                                                <a href="imperative-programming-1.html">8. Imperative Programming</a>
                                            </li>
                                        
                                            <li>
                                                <a href="functors.html" class="here">9. Functors</a>
                                            </li>
                                        
                                            <li>
                                                <a href="first-class-modules.html">10. First class modules</a>
                                            </li>
                                        
                                            <li>
                                                <a href="objects.html">11. Objects</a>
                                            </li>
                                        
                                            <li>
                                                <a href="classes.html">12. Classes</a>
                                            </li>
                                        
                                    </ul>
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt02.html">II. Tools and Techniques</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="pt03.html">III. The Runtime System</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="installation.html">A. Installation</a>
                            
                                
                            
                        </li>
                    
                        <li>
                            <a href="packaging.html">B. Packaging</a>
                            
                                
                            
                        </li>
                    
                </ul>
            </nav>
        
            <article class="page">
        
                <h1>Chapter 9. Functors</h1>
                
                

    <p id="idp9214048">
    Up until now, we've seen OCaml's module system play an important but
    limited role. In particular, we've seen them as a mechanism for
    organizing code into units with specified interfaces. But modules
    can do much more than that, acting as a powerful toolset for
    building generic code and structuring large-scale systems. Much of
    that power comes from functors.
  </p><p id="idp9214832">
    Functors are, roughly speaking, functions from modules to modules,
    and they can be used to solve a variety of code-structuring
    problems, including:
  </p><ul><li><p id="idp9215904">
<span><em>Dependency injection</em></span>, or making the
        implementations of some components of a system swappable. This
        is particularly useful when you want to mock up parts of your
        system for testing and simulation purposes.
      </p></li><li><p id="idp9217312">
<span><em>Auto-extension of modules</em></span>. Functors give
        you a way of extending existing modules with new functionality
        in a standardized way. For example, you might want to add a slew
        of comparison operators derived from a base comparison function.
        To do this by hand would require a lot of repetitive code for
        each type, but functors let you write this logic just once and
        apply it to many different types.
      </p></li><li><p id="idp9218944">
<span><em>Instantiating modules with state</em></span>. Modules
        can contain mutable state, and that means that you'll
        occasionally want to have multiple instantiations of a
        particular module, each with its own separate and independent
        mutable state. Functors let you automate the construction of
        such modules.
      </p></li></ul><section><h1 id="a-trivial-example">A trivial example</h1><p id="idp9221488">
      Let's create a functor that takes a module containing a single
      integer variable <code>x</code>, and returns a new module
      with <code>x</code> incremented by one. This is not actually
      a useful example, but it's a good way to walk through the basic
      mechanics of functors.
    </p><p id="idp9223504">
      First, let's define a signature for a module that contains a
      single value of type <code>int</code>.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div><p id="idp9225712">
      Now we can define our functor. We'll use <code>X_int</code>
      both to constrain the argument to the functor, as well as to
      constraint module returned by the functor.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Increment</span> <span class="o">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">:</span> <span class="nc">X_int</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Increment</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">X_int</span>
</pre></div><p id="idp9228176">
      One thing that immediately jumps out is that functors are more
      syntactically heavyweight than ordinary functions. For one thing,
      functors require explicit (module) type annotations, which
      ordinary functions do not. Technically, only the type on the input
      is mandatory, although in practice, it's good practice to
      constrain the module returned by the functor, just as one
      typically uses an <code>mli</code>, even though it's not
      mandatory.
    </p><p id="idp9229728">
      The following shows what happens when we omit the module type for
      the output of the functor.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Increment</span> <span class="o">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Increment</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">X_int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div><p id="idp9231408">
      We can see that the inferred module type of the output is now
      written out explicitly, rather than being a reference to the named
      signature <code>X_int</code>.
    </p><p id="idp9232688">
      We can now use <code>Increment</code> to define new modules.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Three</span> <span class="o">=</span> <span class="k">struct</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">end</span><span class="o">;;</span>
  <span class="k">module</span> <span class="nc">Three</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Four</span> <span class="o">=</span> <span class="nc">Increment</span><span class="o">(</span><span class="nc">Three</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Four</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
<span class="o">#</span> <span class="nn">Four</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="nn">Three</span><span class="p">.</span><span class="n">x</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div><p id="idp9234960">
      In this case, we applied <code>Increment</code> to a module
      whose signature is exactly equal to <code>X_int</code>. But
      we can apply <code>Increment</code> to any module that
      <span><em>satisfies</em></span> the interface
      <code>X_int</code>, in the same way that the contents of an
      <code>ml</code> file must satisfy the
      <code>mli</code>. That means that the module type can omit
      some information available in the module, either by dropping
      fields or by leaving some fields abstract. Here's an example:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Three_and_more</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;three&quot;</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Three_and_more</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">val</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">string</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Four</span> <span class="o">=</span> <span class="nc">Increment</span><span class="o">(</span><span class="nc">Three_and_more</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Four</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div><p id="idp9241856">
      The rules for determining whether a module matches a given
      signature are similar in spirit to the rules in an object-oriented
      language that determine whether an object satisfies a given
      interface. As in an object-oriented context, the extra information
      that doesn't match the signature you're looking for (in this case,
      the variable <code>y</code>), is simply ignored.
    </p></section><section><h1 id="a-bigger-example-computing-with-intervals">A bigger example: computing with intervals</h1><p id="idp9244704">
      Let's consider a more realistic example of how to use functors: a
      library for computing with intervals. Intervals are a common
      computational object, and they come up in different contexts and
      for different types. You might need to work with intervals of
      floating point values, or strings, or times, and in each of these
      cases, you want similar operations: testing for emptiness,
      checking for containment, intersecting intervals, and so on.
    </p><p id="idp9245584">
      Let's see how to use functors to build a generic interval library
      that can be used with any type that supports a total ordering on
      the underlying set over which you want to build intervals.
    </p><p id="idp9246192">
      First we'll define a module type that captures the information
      we'll need about the endpoints of the intervals. This interface,
      which we'll call <code>Comparable</code>, contains just two
      things: a comparison function, and the type of the values to be
      compared.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Comparable</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Comparable</span> <span class="o">=</span> <span class="k">sig</span> <span class="k">type</span> <span class="n">t</span> <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="k">end</span>
</pre></div><p id="idp9248912">
      The comparison function follows the standard OCaml idiom for such
      functions, returning <code>0</code> if the two elements are
      equal, a positive number if the first element is larger than the
      second, and a negative number if the first element is smaller than
      the second. Thus, we could rewrite the standard comparison
      functions on top of <code>compare</code> as shown below.
    </p><div class="highlight"><pre><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span>     <span class="c">(* x &lt; y *)</span>
<span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c">(* x = y *)</span>
<span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span>     <span class="c">(* x &gt; y *)</span>
</pre></div><p id="idp9252160">
      The functor for creating the interval module is shown below. We
      represent an interval with a variant type, which is either
      <code>Empty</code> or <code>Interval (x,y)</code>,
      where <code>x</code> and <code>y</code> are the bounds
      of the interval. In addition to the type, the functor contains
      implementations of a number of useful primitives for interacting
      with intervals.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nc">Empty</span>

    <span class="c">(** [create low high] creates a new interval from [low] to</span>
<span class="c">        [high].  If [low &gt; high], then the interval is empty *)</span>
    <span class="k">let</span> <span class="n">create</span> <span class="n">low</span> <span class="n">high</span> <span class="o">=</span>
      <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">low</span> <span class="n">high</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Empty</span>
      <span class="k">else</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">)</span>

    <span class="c">(** Returns true iff the interval is empty *)</span>
    <span class="k">let</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">true</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

    <span class="c">(** [contains t x] returns true iff [x] is contained in the</span>
<span class="c">        interval [t] *)</span>
    <span class="k">let</span> <span class="n">contains</span> <span class="n">t</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">false</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">h</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="mi">0</span>

    <span class="c">(** [intersect t1 t2] returns the intersection of the two input</span>
<span class="c">        intervals *)</span>
    <span class="k">let</span> <span class="n">intersect</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">min</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">max</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">t1</span><span class="o">,</span><span class="n">t2</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_</span> <span class="o">|</span> <span class="o">_,</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="nc">Empty</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l1</span><span class="o">,</span><span class="n">h1</span><span class="o">),</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l2</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="n">create</span> <span class="o">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span> <span class="o">(</span><span class="n">min</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span>

  <span class="k">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="nc">Empty</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp9259152">
      We can instantiate the functor by applying it to a module with the
      right signature. In the following, rather than name the module
      first and then call the functor, we provide the functor input as
      an anonymous module.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span>
    <span class="nc">Make_interval</span><span class="o">(</span><span class="k">struct</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
      <span class="k">let</span> <span class="n">compare</span> <span class="o">=</span> <span class="nn">Int</span><span class="p">.</span><span class="n">compare</span>
    <span class="k">end</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Empty</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp9261152">
      If the input interface for your functor is aligned with the
      standards of the libraries you use, then you don't need to
      construct a custom module to feed to the functor. In this case, we
      can directly use the <code>Int</code> or
      <code>String</code> modules provided by Core.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">String_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="o">;;</span>
</pre></div><p id="idp9264256">
      This works because many modules in Core, including
      <code>Int</code> and <code>String</code>, satisfy an
      extended version of the <code>Comparable</code> signature
      described above. Such standardized signatures are good practice,
      both because they makes functors easier to use, and because they
      make your codebase generally easier to navigate.
    </p><p id="idp9267072">
      Now we can use the newly defined <code>Int_interval</code>
      module like any ordinary module.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i1</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">8</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i1</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">i2</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">10</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i2</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">intersect</span> <span class="n">i1</span> <span class="n">i2</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">)</span>
</pre></div><p id="idp9269488">
      This design gives us the freedom to use any comparison function we
      want for comparing the endpoints. We could, for example, create a
      type of integer interval with the order of the comparison
      reversed, as follows:
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Rev_int_interval</span> <span class="o">=</span>
    <span class="nc">Make_interval</span><span class="o">(</span><span class="k">struct</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
      <span class="k">let</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Int</span><span class="p">.</span><span class="n">compare</span> <span class="n">y</span> <span class="n">x</span>
    <span class="k">end</span><span class="o">);;</span>
</pre></div><p id="idp9271200">
      The behavior of <code>Rev_int_interval</code> is of course
      different from <code>Int_interval</code>, as we can see
      below.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">interval</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">interval</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Empty</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">rev_interval</span> <span class="o">=</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">rev_interval</span> <span class="o">:</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div><p id="idp9274256">
      Importantly, <code>Rev_int_interval.t</code> is a different
      type than <code>Int_interval.t</code>, even though its
      physical representation is the same. Indeed, the type system will
      prevent us from confusing them.
    </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">rev_interval</span> <span class="mi">3</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">22</span><span class="o">-</span><span class="mi">34</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">rev_interval</span> <span class="mi">3</span><span class="o">;;</span>
                        <span class="o">^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="nn">Rev_int_interval</span><span class="p">.</span><span class="n">t</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">).</span><span class="n">t</span>
</pre></div><p id="idp9277472">
      This is important, because confusing the two kinds of intervals
      would be a semantic error, and it's an easy one to make. The
      ability of functors to mint new types is a useful trick that comes
      up a lot.
    </p><section><h1 id="making-the-functor-abstract">Making the functor abstract</h1><p id="idp9279232">
        There's a problem with <code>Make_interval</code>. The
        code we wrote depends on the invariant that the upper bound of
        an interval is greater than its lower bound, but that invariant
        can be violated. The invariant is enforced by the create
        function, but because <code>Interval.t</code> is not
        abstract, we can bypass the <code>create</code> function.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">;;</span> <span class="c">(* going through create *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Empty</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span> <span class="c">(* bypassing create *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div><p id="idp9283232">
        To make <code>Int_interval.t</code> abstract, we need to
        restrict it the output of the <code>Make_interval</code>
        with an interface. Here's an explicit interface that we can use
        for that purpose.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Interval_intf</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">t</span>
   <span class="k">type</span> <span class="n">endpoint</span>
   <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
   <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
   <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9286592">
        This interface includes the type <code>endpoint</code> to
        give us a way of referring to the endpoint type. Given this
        interface, we can redo our definition of
        <code>Make_interval</code>. Notice that we added the type
        <code>endpoint</code> to the implementation of the module
        to match <code>Interval_intf</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Interval_intf</span>
  <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">....</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Interval_intf</span>
</pre></div></section><section><h1 id="sharing-constraints">Sharing constraints</h1><p id="idp9292720">
        The resulting module is abstract, but it's unfortunately too
        abstract. In particular, we haven't exposed the type
        <code>endpoint</code>, which means that we can't even
        construct an interval anymore.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">:</span> <span class="nc">Interval_intf</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">20</span><span class="o">-</span><span class="mi">21</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
                      <span class="o">^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="nn">Int_interval</span><span class="p">.</span><span class="n">endpoint</span>
</pre></div><p id="idp9295280">
        To fix this, we need to expose the fact that
        <code>endpoint</code> is equal to <code>Int.t</code>
        (or more generally, <code>Endpoint.t</code>, where
        <code>Endpoint</code> is the argument to the functor). One
        way of doing this is through a <span><em>sharing
        constraint</em></span>, which allows you to tell the compiler to
        expose the fact that a given type is equal to some other type.
        The syntax for a simple sharing constraint is as follows.
      </p><div class="highlight"><pre><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">s</span> <span class="o">=</span> <span class="n">t</span>
</pre></div><p id="idp9300304">
        where <code>S</code> is a module type,
        <code>s</code> is a type inside of <code>S</code>,
        and <code>t</code> is a type defined outside of
        <code>S</code>. The result of this expression is a new
        signature that's been modified so that it exposes the fact that
        <code>s</code> is equal to <code>t</code>. One can
        also apply multiple sharing constraints to the same signature.
      </p><div class="highlight"><pre><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">s</span> <span class="o">=</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">s'</span> <span class="o">=</span> <span class="n">t'</span>
</pre></div><p id="idp9306768">
        We can use a sharing constraint to create a specialized version
        of <code>Interval_intf</code> for integer intervals.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span>
    <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="kt">int</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp9309296">
        We can also use sharing constraints in the context of a functor.
        The most common use case is where you want to expose that some
        of the types of the module being generated by the functor are
        related to the types in the module fed to the functor.
      </p><p id="idp9309984">
        In this case, we'd like to expose an equality between the type
        <code>endpoint</code> in the new module and the type
        <code>Endpoint.t</code>, from the module
        <code>Endpoint</code> that is the functor argument. We can
        do this as follows.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
      <span class="o">:</span> <span class="o">(</span><span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
  <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">...</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">type</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp9314272">
        So now, the interface is as it was, except that
        <code>endpoint</code> is now known to be equal to
        <code>Endpoint.t</code>. As a result of that type
        equality, we can again do things that require that
        <code>endpoint</code> be exposed, like constructing
        intervals.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">i</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">contains</span> <span class="n">i</span> <span class="mi">5</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div></section><section><h1 id="destructive-substitution">Destructive substitution</h1><p id="idp9319376">
        Sharing constraints basically do the job, but they have some
        downsides. In particular, we've now been stuck with the useless
        type declaration of <code>endpoint</code> that clutters up
        both the interface and the implementation. A better solution
        would be to modify the <code>Interval_intf</code>
        signature by replacing <code>endpoint</code> with
        <code>Endpoint.t</code> everywhere it shows up, and
        deleting the definition of <code>endpoint</code> from the
        signature. We can do just this using what's called
        <span><em>destructive substitution</em></span>. Here's the basic
        syntax.
      </p><div class="highlight"><pre><span class="nc">S</span> <span class="k">with</span> <span class="k">type</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">t</span>
</pre></div><p id="idp9325232">
        The following shows how we could use this with
        <code>Make_interval</code>.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span>
    <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="kt">int</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Int_interval_intf</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp9327664">
        There's now no <code>endpoint</code> type: all of its
        occurrences of have been replaced by <code>int</code>. As
        with sharing constraints, we can also use this in the context of
        a functor.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
    <span class="o">:</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nn">Empty</span>

    <span class="p">....</span>

  <span class="n">end</span> <span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span> <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp9331104">
        The interface is precisely what we want: the type
        <code>t</code> is abstract, the type of the endpoint is
        exposed, so we can create values of type
        <code>Int_interval.t</code> using the creation function,
        but not directly using the constructors and thereby violating
        the invariants of the module, as you can see below.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">);;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span>
<span class="nc">Characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">27</span><span class="o">:</span>
  <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">);;</span>
  <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="n">constructor</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="nc">Interval</span>
</pre></div><p id="idp9334848">
        In addition, the <code>endpoint</code> type is gone from
        the interface, meaning we no longer need to define the
        <code>endpoint</code> type alias in the body of the
        module.
      </p><p id="idp9336832">
        It's worth noting that the name is somewhat misleading, in that
        there's nothing destructive about destructive substitution; it's
        really just a way of creating a new signature by transforming an
        existing one.
      </p></section><section><h1 id="using-multiple-interfaces">Using multiple interfaces</h1><p id="idp9338688">
        Another feature that we might want for our interval module is
        the ability to <span><em>serialize</em></span>,
        <span><em>i.e.</em></span>, to be able to read and write
        intervals as a stream of bytes. In this case, we'll do this by
        converting to and from <span><em>s-expressions</em></span>. An
        s-expression is essentially a parenthesized expression whose
        atoms are strings, and it is a serialization format that is used
        commonly in Core. Here's an example.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">&quot;(This is (an s-expression))&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">This</span> <span class="n">is</span> <span class="o">(</span><span class="n">an</span> <span class="n">s</span><span class="o">-</span><span class="n">expression</span><span class="o">))</span>
</pre></div><p id="idp9341888">
        Core comes with a syntax extension called
        <code>sexplib</code> which can auto-generate s-expression
        conversion functions from a type declaration. Attaching
        <code>with sexp</code> to a type definition signals to the
        extension to generate the converters. Thus, we can write:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">type</span> <span class="n">some_type</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">list</span> <span class="k">with</span> <span class="n">sexp</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">some_type</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">list</span>
<span class="k">val</span> <span class="n">some_type_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="n">sexp_of_some_type</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">sexp_of_some_type</span> <span class="o">(</span><span class="mi">33</span><span class="o">,</span> <span class="o">[</span><span class="s2">&quot;one&quot;</span><span class="o">;</span> <span class="s2">&quot;two&quot;</span><span class="o">]);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="mi">33</span> <span class="o">(</span><span class="n">one</span> <span class="n">two</span><span class="o">))</span>
<span class="o">#</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">&quot;(44 (five six))&quot;</span> <span class="o">|&gt;</span> <span class="n">some_type_of_sexp</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">(</span><span class="mi">44</span><span class="o">,</span> <span class="o">[</span><span class="s2">&quot;five&quot;</span><span class="o">;</span> <span class="s2">&quot;six&quot;</span><span class="o">])</span>
</pre></div><p id="idp9345408">
        We'll discuss s-expressions and <code>sexplib</code> in
        more detail in
        <a href="data-serialization-with-s-expressions.html">Chapter 17, <i>Data Serialization with S-Expressions</i></a>,
        but for now, let's see what happens if attach the
        <code>with sexp</code> declaration to the definition of
        <code>t</code> within the functor.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span>
    <span class="o">:</span> <span class="o">(</span><span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nc">Empty</span>
    <span class="k">with</span> <span class="n">sexp</span>

    <span class="o">....</span>

  <span class="k">end</span> <span class="o">;;</span>
<span class="nc">Characters</span> <span class="mi">120</span><span class="o">-</span><span class="mi">123</span><span class="o">:</span>
        <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
                               <span class="o">^^^^^^^^^^</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Unbound</span> <span class="n">value</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t_of_sexp</span>
</pre></div><p id="idp9350112">
        The problem is that <code>with sexp</code> adds code for
        defining the s-expression converters, and that code assumes that
        <code>Endpoint</code> has the appropriate sexp-conversion
        functions for <code>Endpoint.t</code>. But all we know
        about <code>Endpoint</code> is that it satisfies the
        <code>Comparable</code> interface, which doesn't say
        anything about s-expressions.
      </p><p id="idp9354368">
        Happily, Core comes with a built in interface for just this
        purpose called <code>Sexpable</code>, which is defined as
        follows:
      </p><div class="highlight"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">Sexpable</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
  <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span>
</pre></div><p id="idp9356688">
        We can modify <code>Make_interval</code> to use the
        <code>Sexpable</code> interface, for both its input and
        its output. First, let's create an extended version of the
        <code>Interval_intf</code> interface that includes the
        functions from the Sexpable interface. We can do this using
        destructive substitution on the <code>Sexpable</code>
        interface, to avoid having multiple distinct type
        <code>t</code>'s clashing with each other.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Interval_intf_with_sexp</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">include</span> <span class="nc">Interval_intf</span>
   <span class="k">include</span> <span class="nc">Sexpable</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Interval_intf_with_sexp</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">endpoint</span>
    <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">endpoint</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
  <span class="k">end</span>
</pre></div><p id="idp9362336">
        Equivalently, we can define a type <code>t</code> within
        our new module, and apply destructive substitutions to all of
        the included interfaces, <code>Interval_intf</code>
        included, as shown below. This is somewaht cleaner when
        combining multiple interfaces, since it correctly reflects that
        all of the signatures are being handled equivalently.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Interval_intf_with_sexp</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">t</span>
   <span class="k">include</span> <span class="nc">Interval_intf</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
   <span class="k">include</span> <span class="nc">Sexpable</span>      <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
  <span class="k">end</span><span class="o">;;</span>
</pre></div><p id="idp9365568">
        Now we can write the functor itself. We have been careful to
        override the sexp-converter here to ensure that the data
        structure's invariants are still maintained when reading in from
        an s-expression.
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="k">sig</span>
                         <span class="k">type</span> <span class="n">t</span>
                         <span class="k">include</span> <span class="nc">Comparable</span> <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
                         <span class="k">include</span> <span class="nc">Sexpable</span>   <span class="k">with</span> <span class="k">type</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
                       <span class="k">end</span><span class="o">)</span>
    <span class="o">:</span> <span class="o">(</span><span class="nc">Interval_intf_with_sexp</span> <span class="k">with</span> <span class="k">type</span> <span class="n">endpoint</span> <span class="o">:=</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
  <span class="o">=</span> <span class="k">struct</span>

    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Interval</span> <span class="k">of</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span>
             <span class="o">|</span> <span class="nc">Empty</span>
    <span class="k">with</span> <span class="n">sexp</span>

    <span class="c">(** [create low high] creates a new interval from [low] to</span>
<span class="c">        [high].  If [low &gt; high], then the interval is empty *)</span>
    <span class="k">let</span> <span class="n">create</span> <span class="n">low</span> <span class="n">high</span> <span class="o">=</span>
      <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">low</span> <span class="n">high</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Empty</span>
      <span class="k">else</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">)</span>

    <span class="c">(* put a wrapper round the auto-generated sexp_of_t to enforce</span>
<span class="c">       the invariants of the data structure *)</span>
    <span class="k">let</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">t_of_sexp</span> <span class="n">sexp</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="nc">Empty</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">create</span> <span class="n">x</span> <span class="n">y</span>

    <span class="c">(** Returns true iff the interval is empty *)</span>
    <span class="k">let</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">true</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

    <span class="c">(** [contains t x] returns true iff [x] is contained in the</span>
<span class="c">        interval [t] *)</span>
    <span class="k">let</span> <span class="n">contains</span> <span class="n">t</span> <span class="n">x</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="bp">false</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">h</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="mi">0</span>

    <span class="c">(** [intersect t1 t2] returns the intersection of the two input</span>
<span class="c">        intervals *)</span>
    <span class="k">let</span> <span class="n">intersect</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">min</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">max</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">t1</span><span class="o">,</span><span class="n">t2</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_</span> <span class="o">|</span> <span class="o">_,</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="nc">Empty</span>
      <span class="o">|</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l1</span><span class="o">,</span><span class="n">h1</span><span class="o">),</span> <span class="nc">Interval</span> <span class="o">(</span><span class="n">l2</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="n">create</span> <span class="o">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span> <span class="o">(</span><span class="n">min</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span>
  <span class="k">end</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Make_interval</span> <span class="o">:</span>
  <span class="k">functor</span>
    <span class="o">(</span><span class="nc">Endpoint</span> <span class="o">:</span> <span class="k">sig</span>
                  <span class="k">type</span> <span class="n">t</span>
                  <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
                  <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
                  <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
                <span class="k">end</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">is_empty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Endpoint</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
      <span class="k">val</span> <span class="n">intersect</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
    <span class="k">end</span>
</pre></div><p id="idp9371104">
        And now, we can use that sexp-converter in the ordinary way:
      </p><div class="highlight"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Int_interval</span> <span class="o">=</span> <span class="nc">Make_interval</span><span class="o">(</span><span class="nc">Int</span><span class="o">)</span> <span class="o">;;</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">(</span><span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Interval</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">#</span> <span class="nn">Int_interval</span><span class="p">.</span><span class="n">sexp_of_t</span> <span class="o">(</span><span class="nn">Int_interval</span><span class="p">.</span><span class="n">create</span> <span class="mi">4</span> <span class="mi">3</span><span class="o">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Empty</span>
</pre></div></section></section><section><h1 id="extending-modules">Extending modules</h1><p id="idp9374080">
      Another common use of functors is to generate type-specific
      functionality for a given module in a standardized way. Let's see
      how this works in the context of a functional queue, which is just
      a functional version of a FIFO (first-in, first-out) queue. Being
      functional, operations on the queue return new queues, rather than
      modifying the queues that were passed in.
    </p><p id="idp9374896">
      Here's a reasonable <code>mli</code> for such a module.
    </p><div class="highlight"><pre><span class="c">(* file: fqueue.mli *)</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

<span class="c">(** [enqueue el q] adds [el] to the back of [q] *)</span>
<span class="k">val</span> <span class="n">enqueue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

<span class="c">(** [dequeue q] returns None if the [q] is empty, otherwise returns</span>
<span class="c">    the first element of the queue and the remainder of the queue *)</span>
<span class="k">val</span> <span class="n">dequeue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="n">option</span>

<span class="c">(** Folds over the queue, from front to back *)</span>
<span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>
</pre></div><p id="idp9377808">
      The <code>Fqueue.fold</code> function above requires some
      explanation. It follows the same pattern as the
      <code>List.fold</code> function we described in
      <a href="using-the-list-module-effectively" target="_top">xref</a>.
      Essentially, <code>Fqueue.fold ~q ~init ~f</code> walks over
      the elements of <code>q</code> from front to back, starting
      with an accumulator of <code>init</code> and using
      <code>f</code> to update the accumulator value as it walks
      over the queue, returning the final value of the accumulator at
      the end of the computation. Fold is a quite powerful operation, as
      we'll see.
    </p><p id="idp9383616">
      Now let's implement <code>Fqueue</code>. A standard trick is
      for the <code>Fqueue</code> to maintain an input and an
      output list, so that one can efficiently
      <code>enqueue</code> on the input list and efficiently
      dequeue from the output list. If you attempt to dequeue when the
      output list is empty, the input list is reversed and becomes the
      new output list. Here's an implementation that uses that trick.
    </p><div class="highlight"><pre><span class="c">(* file: fqueue.ml *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="o">(</span><span class="bp">[]</span><span class="o">,</span><span class="bp">[]</span><span class="o">)</span>

<span class="k">let</span> <span class="n">enqueue</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span> <span class="n">out_list</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span>

<span class="k">let</span> <span class="n">dequeue</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span> <span class="n">out_list</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">out_list</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span> <span class="n">tl</span><span class="o">))</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="bp">[]</span><span class="o">,</span> <span class="n">tl</span><span class="o">))</span>

<span class="k">let</span> <span class="n">fold</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span> <span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">after_out</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="n">out_list</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="n">after_out</span> <span class="o">~</span><span class="n">f</span> <span class="n">in_list</span>
</pre></div><p id="idp9388688">
      One problem with <code>Fqueue</code> is that the interface
      is quite skeletal. There are lots of useful helper functions that
      one might want that aren't there. The list module, by way of
      contrast, has functions like <code>List.iter</code>, which
      runs a function on each element; and
      <code>List.for_all</code>, which returns true if and only if
      the given predicate evaluates to try on every element of the list.
      Such helper functions come up for pretty much every container
      type, and implementing them over and over is a dull and repetitive
      affair.
    </p><p id="idp9391760">
      As it happens, many of these helper functions can be derived
      mechanically from just the fold function we already implemented.
      Rather than write all of these helper functions by hand for every
      new container type, we can instead use a functor that will let us
      add this functionality to any container that has a
      <code>fold</code> function.
    </p><p id="idp9393232">
      We'll create a new module, <code>Foldable</code> that
      automates the process of adding helper functions to a
      fold-supporting container. As you can see,
      <code>Foldable</code> contains a module signature
      <code>S</code> which defines the signature that is required
      to support folding; and a functor <code>Extend</code> that
      allows one to extend any module that matches
      <code>Foldable.S</code>.
    </p><div class="highlight"><pre><span class="c">(* file: foldable.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">S</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>
<span class="k">end</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">Extension</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">iter</span>    <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">length</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">count</span>   <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">val</span> <span class="n">for_all</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">val</span> <span class="n">exists</span>  <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
<span class="k">end</span>

<span class="c">(* For extending a Foldable module *)</span>
<span class="k">module</span> <span class="nc">Extend</span><span class="o">(</span><span class="nc">Arg</span> <span class="o">:</span> <span class="nc">S</span><span class="o">)</span>
  <span class="o">:</span> <span class="o">(</span><span class="nc">Extension</span> <span class="k">with</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Arg</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="k">open</span> <span class="nc">Arg</span>

  <span class="k">let</span> <span class="n">iter</span> <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">()</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="bp">()</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">length</span> <span class="n">t</span> <span class="o">=</span>
    <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span>  <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">acc</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">count</span> <span class="n">t</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="n">fold</span> <span class="n">t</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span>  <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">count</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count</span> <span class="o">+</span> <span class="k">if</span> <span class="n">f</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">exception</span> <span class="nc">Short_circuit</span>

  <span class="k">let</span> <span class="n">for_all</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">try</span> <span class="n">iter</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">not</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="k">then</span> <span class="k">raise</span> <span class="nc">Short_circuit</span><span class="o">);</span> <span class="bp">true</span>
    <span class="k">with</span> <span class="nc">Short_circuit</span> <span class="o">-&gt;</span> <span class="bp">false</span>

  <span class="k">let</span> <span class="n">exists</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">try</span> <span class="n">iter</span> <span class="n">c</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">x</span> <span class="k">then</span> <span class="k">raise</span> <span class="nc">Short_circuit</span><span class="o">);</span> <span class="bp">false</span>
    <span class="k">with</span> <span class="nc">Short_circuit</span> <span class="o">-&gt;</span> <span class="bp">true</span>
<span class="k">end</span>
</pre></div><p id="idp9399840">
      Now we can apply this to <code>Fqueue</code>. We can rewrite
      the interface of <code>Fqueue</code> as follows.
    </p><div class="highlight"><pre><span class="c">(* file: fqueue.mli *)</span>
<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">enqueue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">dequeue</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="n">option</span>
<span class="k">val</span> <span class="n">fold</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">init</span><span class="o">:</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:(</span><span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span>

<span class="k">include</span> <span class="nn">Foldable</span><span class="p">.</span><span class="nc">Extension</span> <span class="k">with</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
</pre></div><p id="idp9403056">
      In order to apply the functor, we'll put the definition of
      <code>Fqueue</code> in a sub-module called
      <code>T</code>, and then call
      <code>Foldable.Extend</code> on <code>T</code>.
    </p><div class="highlight"><pre><span class="c">(* file: fqueue.ml *)</span>

<span class="k">open</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span>

<span class="k">module</span> <span class="nc">T</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>

  <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">,</span><span class="bp">[]</span>

  <span class="k">let</span> <span class="n">enqueue</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span>
    <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">dequeue</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span> <span class="n">out_list</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">out_list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span> <span class="n">tl</span><span class="o">))</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">in_list</span> <span class="k">with</span>
      <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="bp">[]</span><span class="o">,</span> <span class="n">tl</span><span class="o">))</span>

  <span class="k">let</span> <span class="n">fold</span> <span class="o">(</span><span class="n">in_list</span><span class="o">,</span><span class="n">out_list</span><span class="o">)</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">after_out</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="n">out_list</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="n">after_out</span> <span class="o">~</span><span class="n">f</span> <span class="n">in_list</span>
<span class="k">end</span>

<span class="k">include</span> <span class="nc">T</span>
<span class="k">include</span> <span class="nn">Foldable</span><span class="p">.</span><span class="nc">Extend</span><span class="o">(</span><span class="nc">T</span><span class="o">)</span>
</pre></div><p id="idp9408784">
      Core comes with a number of functors for extending modules that
      follow this same basic pattern, including:
    </p><ul><li><p id="idp9409824">
<code>Container.Make</code>, which is very similar to
          <code>Foldable.Extend</code>.
        </p></li><li><p id="idp9412048">
<code>Comparable.Make</code>, which adds a variety of
          helper functions and types for types that have a comparison
          function.
        </p></li><li><p id="idp9413648">
<code>Hashable.Make</code> for adding hash-based data
          structures like hash sets and hash heaps for types that have
          hash functions.
        </p></li><li><p id="idp9415248">
<code>Monad.Make</code> for so-called monadic libraries,
          like the ones discussed in
          <a href="error-handling.html">Chapter 7, <i>Error Handling</i></a> and
          <a href="concurrent-programming-with-async.html">Chapter 18, <i>Concurrent Programming with Async</i></a>.
          Here, the functor is used to provide a collection of standard
          helper functions based on the <code>bind</code> and
          <code>return</code> operators.
        </p></li></ul><p id="idp9419632">
      These functors come in handy when you want to add the same kind of
      functionality that is commonly available in Core to your own
      types.
    </p></section>


                
            </article>
            
            
    
                <nav class="pagination">
                    
                        <a rel="previous" href="imperative-programming-1.html">
                            &lt; Previous
                        </a>
                    
                    
                        <a rel="next" href="first-class-modules.html">
                            Next &gt;
                        </a>
                    
                </nav>
            
            
            
            <footer class="footer">
                <p>Copyright 2012-2013, Jason Hickey, Anil Madhavapeddy and Yaron Minsky. Licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">CC BY-NC-ND 3.0 US</a>.</p>
            </footer>
            
        </div>
    
    </body>

</html>