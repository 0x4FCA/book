* DONE 9
 near bottom "right hand side of the let" should be left-hand side?

* DONE 10

the first example: something is happening here that you don't remark
on: the "let .. in .." syntax. This is, to me as an outsider, one of
the weirder bits of syntax. I get how it is supposed to work but it
always makes me feel as if I am holding my breath. Anyway, my remark
is -- do you address this somewhere or just let the reader guess how
it works?

(why does it seem so weird to me? Mainly because the term "in"
suggests that there should be a clear demarcation of what the "in"
applies to -- maybe some braces { ... } or something. It makes me
nervous that there isn't. Obviously I don't have objective grounds for
complaint here.)

That example also makes me wonder: why use ** for exponentiation
instead of ^ ? I think the latter is so much nicer looking.

(talking about OCaml makes me really judgmental. Maybe it's just a
sign of age.)

* DONE 11

p. 11 middle "I omitted" -- are we not using the authorial "we", then?

* TODO 12

   the example at the top is actually the first truly impressive
   example of type inference! The first line of the match requires the
   list components to be the same type as the output. The second line
   sets the type of the output -- in a case where the input has no
   type... Maybe this is worth a comment? (Not necessarily a
   full-fledged discussion but a mini-challenge to the reader to
   figure it out)

* DONE 13

p. 13 the ~f label thing is totally mystifying here.

   bottom of 13: "An option is used to..." this sentence is garbled.

around here you also start to drop off the toplevel ";;", somewhat
inconsistently.  Not sure what is better, since obviously the ;; is a
pain.

* DONE 15

p. 15 the "x=x" business is kind of disturbing.  This is the beginning
   of what I have noticed before is an irritating custom of using the
   same word twice with two meanings in types.

   next example is near the bottom where you have "| Circle of
   circle".

  For pedagogic reasons maybe you could write " | C of circle | R of
  rect ..." etc? I guess you are just getting the reader used to this
  style; but I am thinking that the first time you see a construction,
  in this case the variant type, the notation should be chosen to
  minimize ambiguity.  Then later you could slip in ambiguous choices
  after the correct structure has been clearly given.

* DONE 16
** DONE Segment _
   top example -- you have the notation "Segment _" where I assume
   _ means "object of unspecified structure". Does this deserve a
   comment?

** DONE List.for_all
   also you have this business with List.for_all... I guess your
   philosophy here is throw a bit of extra stuff in for the advanced
   reader to puzzle over and the less advanced reader to ignore? That
   does make some sense.
** DONE Mutability
   in the section on mutation you just launch in, seemingly assuming
   that the reader knows what mutability is. As you know I am a little
   fuzzy on it myself. Is it a good assumption about your readers?

   similarly you talk about "imperative programming" as being somehow
   equivalent or closely related to mutability. Certainly you are
   right, since both non-imperative programming and immutability
   appear to make me equally nervous. Anyway it seems pretty cryptic
   to the uninitiated.
* DONE 17 

   The running_sum example made me wonder: I notice you have declared
   samples to be a float. But samples presumably should always be a
   (nonnegative) integer, so declaring it this way forfeits an
   important semantic clue of the kind that I thought types were
   supposed to capture.  Really, from a math point of view you want to
   be allowed to multiply or divide a float by an int -- it makes
   consistent sense.

   In mathematics this is the structure of a vector space, or more
   generally a module. The real numbers are a vector space over the
   rationals, so q * r makes sense as "multiplication by a scalar". I
   guess one can always build such types on top of OCaml, but the
   example you give reminds me that this is actually a very common
   thing and should be built-in.

   What's with the "()" in let create () ? You don't comment on it.

   "unit" -- did you explain what that means yet?

* DONE 18 

   refs: is the field always called "content"?

   In the section on for and while. I find this construction a little confusing:

   let tmp =  ar.(i) in
   ar.(i) <- ar.(j);
   ar.(j) <- tmp

   My first interpretation was that the semicolon terminates the scope
   of the "let tmp... in" -- but clearly that's not right since the
   third line has to also be within that scope to make sense.

   So what are the rules on the scope of a let, and how does it
   interact with semicolons?

* DONE 19

   Ah -- now you remark on what "unit" means.
