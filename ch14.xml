<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="command-line-parsing">
  <title>Command-Line Parsing</title>

  <para>Many of the OCaml programs that you'll write will end up as binaries
  that need to be run from a command prompt. Any nontrivial command line
  should support a collection of basic features:<indexterm class="singular">
      <primary>command-line parsing</primary>

      <secondary>features needed</secondary>
    </indexterm></para>

  <itemizedlist>
    <listitem>
      <para>Parsing of command-line arguments</para>
    </listitem>

    <listitem>
      <para>Generation of error messages in response to incorrect
      inputs</para>
    </listitem>

    <listitem>
      <para>Help for all the available options</para>
    </listitem>

    <listitem>
      <para>Interactive autocompletion</para>
    </listitem>
  </itemizedlist>

  <para>It's tedious and error-prone to code all of this manually for every
  program you write. Core provides the Command library, which simplifies all
  of this by letting you declare all your command-line options in one place
  and by deriving all of the above functionality from these
  declarations.<indexterm class="singular">
      <primary>command-line parsing</primary>

      <secondary>Command library for</secondary>
    </indexterm></para>

  <para>Command is simple to use for simple applications but also scales well
  as your needs grow more complex. In particular, Command provides a
  sophisticated subcommand mode that groups related commands together as the
  complexity of your user interface grows. You may already be familiar with
  this command-line style from the Git or Mercurial version control
  systems.</para>

  <para>In this chapter, we'll:</para>

  <itemizedlist>
    <listitem>
      <para>Learn how to use Command to construct basic and grouped
      command-line interfaces</para>
    </listitem>

    <listitem>
      <para>See examples that extend the cryptographic utility from <xref
      linkend="classes" /> and build a simple equivalent to the <literal
      moreinfo="none">md5</literal> and <literal
      moreinfo="none">shasum</literal> utilities</para>
    </listitem>

    <listitem>
      <para>Demonstrate how <emphasis>functional combinators</emphasis> can be
      used to declare complex command-line interfaces in a type-safe and
      elegant way</para>
    </listitem>
  </itemizedlist>

  <sect1 id="basic-command-line-parsing">
    <title>Basic Command-Line Parsing</title>

    <para>Let's start by working through a clone of the <literal
    moreinfo="none">md5sum</literal> command that is present on most Linux
    installations (the equivalent command on Mac OS X is simply <literal
    moreinfo="none">md5</literal>). The following function defined below reads
    in the contents of a file, applies the MD5 one-way cryptographic hash
    function to the data, and outputs an ASCII hex representation of the
    result:<indexterm class="singular">
        <primary>MD5 one-way cryptographic hash function</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>basic approach to</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5.ml">command-line-parsing/basic_md5.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let do_hash file =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )</programlisting>

    <para>The <literal moreinfo="none">do_hash</literal> function accepts a
    <literal moreinfo="none">filename</literal> parameter and prints the
    human-readable MD5 string to the console standard output. The first step
    toward turning this function into a command-line program is to declare all
    the possible command-line arguments in a
    <emphasis>specification</emphasis>. <literal
    moreinfo="none">Command.Spec</literal> defines combinators that can be
    chained together to define optional flags and positional arguments, what
    types they should map to, and whether to take special actions (such as
    pausing for interactive input) if certain inputs are encountered.</para>

    <sect2 id="anonymous-arguments">
      <title>Anonymous Arguments</title>

      <para>Let's build the specification for a single argument that is passed
      directly on the command line. This is known as an
      <emphasis>anonymous</emphasis> argument:<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>anonymous arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>anonymous arguments</primary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5.ml">command-line-parsing/basic_md5.ml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let spec =
  let open Command.Spec in
  empty
  +&gt; anon ("filename" %: string)</programlisting>

      <para>The <literal moreinfo="none">Command.Spec</literal> module defines
      the tools you'll need to build up a command-line specification. We start
      with the <literal moreinfo="none">empty</literal> value and add
      parameters to that using the <literal moreinfo="none">+&gt;</literal>
      combinator. (Both of these values come from <literal
      moreinfo="none">Command.Spec</literal>.)</para>

      <para>In this case, we defined a single anonymous argument called
      <literal moreinfo="none">filename</literal>, which takes a value of type
      <literal moreinfo="none">string</literal>. Anonymous parameters are
      created using the <literal moreinfo="none">%:</literal> operator, which
      binds a textual name (used in the help text to identify the parameter)
      to an OCaml conversion function that parses the command-line string
      fragments into a higher-level OCaml data type. In the preceding example,
      this is just <literal moreinfo="none">Command.Spec.string</literal>, but
      we'll see more complex conversion options later in the chapter.</para>
    </sect2>

    <sect2 id="defining-basic-commands">
      <title>Defining Basic Commands</title>

      <para>Once we've defined a specification, we need to put it to work on
      real input. The simplest way is to directly create a command-line
      interface via the <literal moreinfo="none">Command.basic</literal>
      module:<indexterm class="singular">
          <primary>Command.basic module</primary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5.ml">command-line-parsing/basic_md5.ml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    spec
    (fun filename () -&gt; do_hash filename)</programlisting>

      <para><literal moreinfo="none">Command.basic</literal> defines a
      complete command-line interface that takes the following extra
      arguments, in addition to the ones defined in the specification:</para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">summary</literal></term>

          <listitem>
            <para>A required one-line description to go at the top of the
            command help screen.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">readme</literal></term>

          <listitem>
            <para>For longer help text when the command is called with
            <literal moreinfo="none">-help</literal>. The <literal
            moreinfo="none">readme</literal> argument is a function that is
            only evaluated when the help text is actually needed.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The specification and the callback function follow as nonlabeled
      arguments.</para>

      <para>The callback function is where all the work happens after the
      command-line parsing is complete. This function is applied with the
      arguments containing the parsed command-line values, and it takes over
      as the main thread of the application. The callback's arguments are
      passed in the same order as they were bound in the specification (using
      the <literal moreinfo="none">+&gt;</literal> operator).<indexterm
          class="singular">
          <primary>arguments</primary>

          <secondary>unit argument to callbacks</secondary>
        </indexterm><indexterm class="singular">
          <primary>unit argument</primary>
        </indexterm><indexterm class="singular">
          <primary>callback function</primary>
        </indexterm></para>

      <note>
        <title>The Extra unit Argument to Callbacks</title>

        <para>The preceding callback needs an extra <literal
        moreinfo="none">unit</literal> argument after <literal
        moreinfo="none">filename</literal>. This is to ensure that
        specifications can work even when they are empty (i.e. the <literal
        moreinfo="none">Command.Spec.empty</literal> value).</para>

        <para>Every OCaml function needs at least one argument, so the final
        <literal moreinfo="none">unit</literal> guarantees that it will not be
        evaluated immediately as a value if there are no other
        arguments.</para>
      </note>
    </sect2>

    <sect2 id="running-basic-commands">
      <title>Running Basic Commands</title>

      <para>Once we've defined the basic command, running it is just one
      function call away:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5.ml">command-line-parsing/basic_md5.ml</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml">let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para><literal moreinfo="none">Command.run</literal> takes a couple of
      optional arguments that are useful to identify which version of the
      binary you are running in production. You'll need to install Cryptokit
      via <literal moreinfo="none">opam install cryptokit</literal> before
      building this example. Once that's completed, run the following to
      compile the binary:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/build_basic_md5.out">command-line-parsing/build_basic_md5.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cryptokit basic_md5.native</userinput>
</programlisting>

      <para>You can now query the version information for the binary you just
      compiled:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/get_basic_md5_version.out">command-line-parsing/get_basic_md5_version.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5.native -version</userinput>
<computeroutput moreinfo="none">1.0</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5.native -build-info</userinput>
<computeroutput moreinfo="none">RWO</computeroutput></programlisting>

      <para>The versions that you see in the output were defined via the
      optional arguments to <literal moreinfo="none">Command.run</literal>.
      You can leave these blank in your own programs or get your build system
      to generate them directly from your version control system (e.g., by
      running <literal moreinfo="none">hg id</literal> to generate a build
      revision number, in the case of Mercurial):</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/get_basic_md5_help.out">command-line-parsing/get_basic_md5_help.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5.native</userinput>
<computeroutput moreinfo="none">Generate an MD5 hash of the input data</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  basic_md5.native FILENAME</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">More detailed information</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">=== flags ===</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  [-build-info]  print info about this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-version]     print the version of this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-help]        print this help text and exit</computeroutput>
<computeroutput moreinfo="none">                 (alias: -?)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">missing anonymous argument: FILENAME</computeroutput></programlisting>

      <para>When we invoke this binary without any arguments, it helpfully
      displays all of the command-line options available, along with a message
      to the standard error that informs you that a required argument <literal
      moreinfo="none">filename</literal> is missing.</para>

      <para>If you do supply the <literal moreinfo="none">filename</literal>
      argument, then <literal moreinfo="none">do_hash</literal> is called with
      the argument and the MD5 output is displayed to the standard
      output:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/run_basic_md5.out">command-line-parsing/run_basic_md5.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5.native ./basic_md5.native</userinput>
<computeroutput moreinfo="none">b5ee7de449a2e0c6c01d4f2d898926de</computeroutput></programlisting>

      <para>And that's all it took to build our little MD5 utility! Here's a
      complete version of the example we just walked through, made slightly
      more succinct by removing intermediate variables:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5_succinct.ml">command-line-parsing/basic_md5_succinct.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: string))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>Now that we have the basics in place, the rest of the chapter will
      examine some of the more advanced features of Command.</para>
    </sect2>
  </sect1>

  <sect1 id="argument-types">
    <title>Argument Types</title>

    <para>You aren't just limited to parsing command lines as strings, of
    course. <literal moreinfo="none">Command.Spec</literal> defines several
    other conversion functions (shown in <xref linkend="table14_1" />) that
    validate and parse input into various types.<indexterm class="singular">
        <primary>arguments</primary>

        <secondary>argument types</secondary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>argument types</secondary>
      </indexterm></para>

    <table id="table14_1">
      <title>Conversion functions defined by
      <literal>Command.spec</literal></title>

      <tgroup cols="3">
        <colspec align="left" />

        <colspec align="left" />

        <colspec align="left" />

        <thead>
          <row>
            <entry>Argument type</entry>

            <entry>OCaml type</entry>

            <entry>Example</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal moreinfo="none">string</literal></entry>

            <entry><literal moreinfo="none">string</literal></entry>

            <entry><literal moreinfo="none">foo</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">int</literal></entry>

            <entry><literal moreinfo="none">int</literal></entry>

            <entry><literal moreinfo="none">123</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">float</literal></entry>

            <entry><literal moreinfo="none">float</literal></entry>

            <entry><literal moreinfo="none">123.01</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">bool</literal></entry>

            <entry><literal moreinfo="none">bool</literal></entry>

            <entry><literal moreinfo="none">true</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">date</literal></entry>

            <entry><literal moreinfo="none">Date.t</literal></entry>

            <entry><literal moreinfo="none">2013-12-25</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">time_span</literal></entry>

            <entry><literal moreinfo="none">Span.t</literal></entry>

            <entry><literal moreinfo="none">5s</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">file</literal></entry>

            <entry><literal moreinfo="none">string</literal></entry>

            <entry><literal moreinfo="none">/etc/passwd</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>We can tighten up the specification of the command to <literal
    moreinfo="none">file</literal> to reflect that the argument must be a
    valid filename, and not just any string:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5_as_filename.ml">command-line-parsing/basic_md5_as_filename.ml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: file))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

    <para>Running this with a nonexistent filename will now output an error if
    the file doesn't exist. As a bonus, it also enables interactive
    command-line completion to work on the filename argument (explained later
    in the chapter):</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/run_basic_md5_as_filename.out">command-line-parsing/run_basic_md5_as_filename.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_as_filename.native nonexistent</userinput>
<computeroutput moreinfo="none">Uncaught exception:</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">  (Sys_error "nonexistent: No such file or directory")</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Raised by primitive operation at file "pervasives.ml", line 292, characters 20-46</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/in_channel.ml", line 19, characters 46-65</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/exn.ml", line 87, characters 6-10</computeroutput></programlisting>

    <sect2 id="defining-custom-argument-types">
      <title>Defining Custom Argument Types</title>

      <para>We can also define our own argument types if the predefined ones
      aren't sufficient. For instance, let's make a <literal
      moreinfo="none">regular_file</literal> argument type that ensures that
      the input file isn't a character device or some other odd UNIX file type
      that can't be fully read:<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>defining custom types</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5_with_custom_arg.ml">command-line-parsing/basic_md5_with_custom_arg.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let regular_file =
  Command.Spec.Arg_type.create
    (fun filename -&gt;
       match Sys.is_file filename with
       | `Yes -&gt; filename
       | `No | `Unknown -&gt;
         eprintf "'%s' is not a regular file.\n%!" filename;
         exit 1
    )

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: regular_file))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>The <literal moreinfo="none">regular_file</literal> function
      transforms a <literal moreinfo="none">filename</literal> string
      parameter into the same string but first checks that the file exists and
      is a regular file type. When you build and run this code, you will see
      the new error messages if you try to open a special device such as
      <literal moreinfo="none">/dev/null</literal>:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/run_basic_md5_with_custom_arg.out">command-line-parsing/run_basic_md5_with_custom_arg.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_with_custom_arg.native /etc/passwd</userinput>
<computeroutput moreinfo="none">8cfb68a5622dd12932df658a54698aad</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_with_custom_arg.native /dev/null</userinput>
<computeroutput moreinfo="none">'/dev/null' is not a regular file.</computeroutput></programlisting>
    </sect2>

    <sect2 id="optional-and-default-arguments">
      <title>Optional and Default Arguments</title>

      <para>A more realistic MD5 binary could also read from the standard
      input if a <literal moreinfo="none">filename</literal> isn't
      specified:<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>default arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>default arguments</primary>
        </indexterm><indexterm class="singular">
          <primary>optional arguments</primary>

          <secondary sortas="default">and default arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>arguments</primary>

          <secondary>optional arguments</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5_with_optional_file_broken.ml">command-line-parsing/basic_md5_with_optional_file_broken.ml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (maybe ("filename" %: string)))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>This just wraps the <literal moreinfo="none">filename</literal>
      argument declaration in the <literal moreinfo="none">maybe</literal>
      function to mark it as an optional argument. However, building this
      results in a compile-time error:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/build_basic_md5_with_optional_file_broken.out">command-line-parsing/build_basic_md5_with_optional_file_broken.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cryptokit basic_md5_with_optional_file_broken.native</userinput>
<computeroutput moreinfo="none">File "basic_md5_with_optional_file_broken.ml", line 18, characters 4-11:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string -&gt; unit -&gt; unit</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type string option -&gt; unit -&gt; unit</computeroutput>
<computeroutput moreinfo="none">       Type string is not compatible with type string option </computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>This is because changing the argument type has also changed the
      type of the callback function. It now wants a <literal
      moreinfo="none">string option</literal> instead of a <literal
      moreinfo="none">string</literal>, since the value has become optional.
      We can adapt our example to use the new information and read from
      standard input if no file is specified:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5_with_optional_file.ml">command-line-parsing/basic_md5_with_optional_file.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let get_inchan = function
  | None | Some "-" -&gt;
    In_channel.stdin
  | Some filename -&gt;
    In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (maybe ("filename" %: file)))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>The <literal moreinfo="none">filename</literal> parameter to
      <literal moreinfo="none">do_hash</literal> is now a <literal
      moreinfo="none">string option</literal> type. This is resolved into an
      input channel via <literal moreinfo="none">get_inchan</literal> to
      determine whether to open the standard input or a file, and then the
      rest of the command is similar to our previous examples.</para>

      <para>Another possible way to handle this would be to supply a dash as
      the default filename if one isn't specified. The <literal
      moreinfo="none">maybe_with_default</literal> function can do just this,
      with the benefit of not having to change the callback parameter type
      (which may be a problem in more complex applications).</para>

      <para>The following example behaves exactly the same as the previous
      example, but replaces <literal moreinfo="none">maybe</literal> with
      <literal moreinfo="none">maybe_with_default</literal>:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5_with_default_file.ml">command-line-parsing/basic_md5_with_default_file.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let get_inchan = function
  | "-"      -&gt; In_channel.stdin
  | filename -&gt; In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(
      empty
      +&gt; anon (maybe_with_default "-" ("filename" %: file))
    )
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>Building and running both against a system file confirms that they
      have the same behavior:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/run_basic_and_default_md5.out">command-line-parsing/run_basic_and_default_md5.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">cat /etc/passwd | ./basic_md5_with_optional_file.native</userinput>
<computeroutput moreinfo="none">8cfb68a5622dd12932df658a54698aad</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat /etc/passwd | ./basic_md5_with_default_file.native</userinput>
<computeroutput moreinfo="none">8cfb68a5622dd12932df658a54698aad</computeroutput></programlisting>
    </sect2>

    <sect2 id="sequences-of-arguments">
      <title>Sequences of Arguments</title>

      <para>One last transformation that's useful is to obtain lists of
      anonymous arguments rather than a single one. As an example, let's
      modify our MD5 code to take a collection of files to process on the
      command line:<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>sequences of</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5_sequence.ml">command-line-parsing/basic_md5_sequence.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let do_hash filename ic =
  let open Cryptokit in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; fun md5 -&gt; printf "MD5 (%s) = %s\n" filename md5

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (sequence ("filename" %: file)))
    (fun files () -&gt;
       match files with
       | [] -&gt; do_hash "-" In_channel.stdin
       | _  -&gt;
         List.iter files ~f:(fun file -&gt;
           In_channel.with_file ~f:(do_hash file) file
         )
    )

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>The callback function is a little more complex now, to handle the
      extra options. The <literal moreinfo="none">files</literal> are now a
      <literal moreinfo="none">string list</literal>, and an empty list
      reverts to using standard input, just as our previous <literal
      moreinfo="none">maybe</literal> and <literal
      moreinfo="none">maybe_with_default</literal> examples did. If the list
      of files isn't empty, then it opens up each file and runs them through
      <literal moreinfo="none">do_hash</literal> sequentially.</para>
    </sect2>
  </sect1>

  <sect1 id="adding-labeled-flags-to-the-command-line">
    <title>Adding Labeled Flags to the Command Line</title>

    <para>You aren't just limited to anonymous arguments on the command line.
    A <emphasis>flag</emphasis> is a named field that can be followed by an
    optional argument. These flags can appear in any order on the command
    line, or multiple times, depending on how they're declared in the
    specification.<indexterm class="singular">
        <primary>flags</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>labeled flags and</secondary>
      </indexterm></para>

    <para>Let's add two arguments to our <literal
    moreinfo="none">md5</literal> command that mimics the Mac OS X version. A
    <literal moreinfo="none" role="keep-together">-s</literal> flag specifies
    the string to be hashed directly on the command line and <literal
    moreinfo="none">-t</literal> runs a self-test. The complete example
    follows:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic_md5_with_flags.ml">command-line-parsing/basic_md5_with_flags.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Cryptokit

let checksum_from_string buf =
  hash_string (Hash.md5 ()) buf
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let checksum_from_file filename =
  let ic = match filename with
    | "-" -&gt; In_channel.stdin
    | _   -&gt; In_channel.create ~binary:true filename
  in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    Command.Spec.(
      empty
      +&gt; flag "-s" (optional string) ~doc:"string Checksum the given string"
      +&gt; flag "-t" no_arg ~doc:" run a built-in time trial"
      +&gt; anon (maybe_with_default "-" ("filename" %: file))
    )
    (fun use_string trial filename () -&gt;
       match trial with
       | true -&gt; printf "Running time trial\n"
       | false -&gt; begin
           match use_string with
           | Some buf -&gt; checksum_from_string buf
           | None -&gt; checksum_from_file filename
         end
    )

let () = Command.run command</programlisting>

    <para>The specification now uses the <literal
    moreinfo="none">flag</literal> function to define the two new labeled,
    command-line arguments. The <literal moreinfo="none">doc</literal> string
    is formatted so that the first word is the short name that appears in the
    usage text, with the remainder being the full help text. Notice that the
    <literal moreinfo="none" role="keep-together">-t</literal> flag has no
    argument, and so we prepend its <literal moreinfo="none">doc</literal>
    text with a blank space. The help text for the preceding code looks like
    this:</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/run_basic_md5_flags_help.out">command-line-parsing/run_basic_md5_flags_help.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_with_flags.native -help</userinput>
<computeroutput moreinfo="none">Generate an MD5 hash of the input data</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  basic_md5_with_flags.native [FILENAME]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">=== flags ===</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  [-s string]    Checksum the given string</computeroutput>
<computeroutput moreinfo="none">  [-t]           run a built-in time trial</computeroutput>
<computeroutput moreinfo="none">  [-build-info]  print info about this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-version]     print the version of this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-help]        print this help text and exit</computeroutput>
<computeroutput moreinfo="none">                 (alias: -?)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_with_flags.native -s "ocaml rocks"</userinput>
<computeroutput moreinfo="none">5a118fe92ac3b6c7854c595ecf6419cb</computeroutput></programlisting>

    <para>The <literal moreinfo="none">-s</literal> flag in our specification
    requires a <literal moreinfo="none">string</literal> argument and isn't
    optional. The Command parser outputs an error message if the flag isn't
    supplied, as with the anonymous arguments in earlier examples. <xref
    linkend="table14-2" /> contains a list of some of the functions that you
    can wrap flags in to control how they are parsed.<indexterm
        class="singular">
        <primary>flag functions</primary>
      </indexterm></para>

    <table id="table14-2">
      <title>Flag functions</title>

      <tgroup cols="2">
        <colspec align="left" />

        <colspec align="left" />

        <thead>
          <row>
            <entry>Flag function</entry>

            <entry>OCaml type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal moreinfo="none">required</literal>
            <emphasis>arg</emphasis></entry>

            <entry><emphasis>arg</emphasis> and error if not present</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">optional</literal>
            <emphasis>arg</emphasis></entry>

            <entry><emphasis>arg</emphasis> <literal
            moreinfo="none">option</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">optional_with_default</literal>
            <emphasis>val</emphasis> <emphasis>arg</emphasis></entry>

            <entry><emphasis>arg</emphasis> with default
            <emphasis>val</emphasis> if not present</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">listed</literal>
            <emphasis>arg</emphasis></entry>

            <entry><emphasis>arg</emphasis> <literal
            moreinfo="none">list</literal>, flag may appear multiple
            times</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">no_arg</literal></entry>

            <entry><literal moreinfo="none">bool</literal> that is true if
            flag is present</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The flags affect the type of the callback function in exactly the
    same way as anonymous arguments do. This lets you change the specification
    and ensure that all the callback functions are updated appropriately,
    without runtime errors.</para>
  </sect1>

  <sect1 id="grouping-sub-commands-together">
    <title>Grouping Subcommands Together</title>

    <para>You can get pretty far by using flags and anonymous arguments to
    assemble complex, command-line interfaces. After a while, though, too many
    options can make the program very confusing for newcomers to your
    application. One way to solve this is by grouping common operations
    together and adding some hierarchy to the command-line
    interface.<indexterm class="singular">
        <primary>subcommands, grouping of</primary>
      </indexterm><indexterm class="singular">
        <primary>OPAM package manager</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>subcommand grouping</secondary>
      </indexterm></para>

    <para>You'll have run across this style already when using the OPAM
    package manager (or, in the non-OCaml world, the Git or Mercurial
    commands). OPAM exposes commands in this form:</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/opam.out">command-line-parsing/opam.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">opam config env</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam remote list -k git</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam install --help</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam install cryptokit --verbose</userinput></programlisting>

    <para>The <literal moreinfo="none">config</literal>, <literal
    moreinfo="none">remote</literal>, and <literal
    moreinfo="none">install</literal> keywords form a logical grouping of
    commands that factor out a set of flags and arguments. This lets you
    prevent flags that are specific to a particular subcommand from leaking
    into the general configuration space.<indexterm class="singular">
        <primary>install keyword</primary>
      </indexterm><indexterm class="singular">
        <primary>remote keyword</primary>
      </indexterm><indexterm class="singular">
        <primary>config keyword</primary>
      </indexterm></para>

    <para>This usually only becomes a concern when your application
    organically grows features. Luckily, it's simple to extend your
    application to do this in Command: just swap the <literal
    moreinfo="none">Command.basic</literal> for <literal
    moreinfo="none">Command.group</literal>, which takes an association list
    of specifications and handles the subcommand parsing and help output for
    you:<indexterm class="singular">
        <primary>Command.group</primary>
      </indexterm></para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/group.topscript">command-line-parsing/group.topscript</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Command.basic ;;</userinput>
<computeroutput moreinfo="none">- : summary:string -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?readme:(unit -&gt; string) -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.group ;;</userinput>
<computeroutput moreinfo="none">- : summary:string -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?readme:(unit -&gt; string) -&gt; (string * Command.t) list -&gt; Command.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

    <para>The <literal moreinfo="none">group</literal> signature accepts a
    list of basic <literal moreinfo="none">Command.t</literal> values and
    their corresponding names. When executed, it looks for the appropriate
    subcommand from the name list, and dispatches it to the right command
    handler.</para>

    <para>Let's build the outline of a calendar tool that does a few
    operations over dates from the command line. We first need to define a
    command that adds days to an input date and prints the resulting
    date:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/cal_add_days.ml">command-line-parsing/cal_add_days.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add</programlisting>

    <para>Everything in this command should be familiar to you by now. Once
    you've tested it and made sure it works, we can define another new command
    that takes the difference of two dates. However, instead of creating a new
    binary, we group both operations as subcommands using <literal
    moreinfo="none">Command.group</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/cal_add_sub_days.ml">command-line-parsing/cal_add_sub_days.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let add =
  Command.basic ~summary:"Add [days] to the [base] date"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff =
  Command.basic ~summary:"Show days between [date1] and [date2]"
    Command.Spec.(
      empty
      +&gt; anon ("date1" %: date)
      +&gt; anon ("date2" %: date)
    )
    (fun date1 date2 () -&gt;
       Date.diff date1 date2
       |&gt; printf "%d days\n"
    )

let command =
  Command.group ~summary:"Manipulate dates"
    [ "add", add; "diff", diff ]

let () = Command.run command</programlisting>

    <para>And that's all you really need to add subcommand support! Let's
    build the example first in the usual way and inspect the help output,
    which now reflects the subcommands we just added.</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/build_cal_add_sub_days.out">command-line-parsing/build_cal_add_sub_days.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild cal_add_sub_days.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_sub_days.native -help</userinput>
<computeroutput moreinfo="none">Manipulate dates</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  cal_add_sub_days.native SUBCOMMAND</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">=== subcommands ===</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  add      Add [days] to the [base] date</computeroutput>
<computeroutput moreinfo="none">  diff     Show days between [date1] and [date2]</computeroutput>
<computeroutput moreinfo="none">  version  print version information</computeroutput>
<computeroutput moreinfo="none">  help     explain a given subcommand (perhaps recursively)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

    <para>We can invoke the two commands we just defined to verify that they
    work and see the date parsing in action:</para>

    <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/run_cal_add_sub_days.out">command-line-parsing/run_cal_add_sub_days.out</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_sub_days.native add 2012-12-25 40</userinput>
<computeroutput moreinfo="none">2013-02-03</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_sub_days.native diff 2012-12-25 2012-11-01</userinput>
<computeroutput moreinfo="none">54 days</computeroutput></programlisting>
  </sect1>

  <sect1 id="advanced-control-over-parsing">
    <title>Advanced Control over Parsing</title>

    <para>The functions for generating a specification may seem like magic. In
    particular, even if you know how to use them, it's not entirely clear how
    they work, and in particular, why the types work out the way they
    do.<indexterm class="singular">
        <primary>specifications</primary>

        <secondary>complexity of</secondary>
      </indexterm><indexterm class="startofrange" id="CLPadv">
        <primary>command-line parsing</primary>

        <secondary>advanced control over</secondary>
      </indexterm></para>

    <para>Understanding the details of how these specifications fit together
    becomes more useful as your command-line interfaces get more complex. In
    particular, you may want to factor out common functionality between
    specifications or interrupt the parsing to perform special processing,
    such as requesting an interactive passphrase from the user before
    proceeding. All of this is helped by a deeper understanding of the Command
    library.</para>

    <para>In the following sections we'll explain the logic behind the
    combinators we've already described and show you some new combinators that
    let you use Command even more effectively.</para>

    <sect2 id="the-types-behind-command.spec">
      <title>The Types Behind Command.Spec</title>

      <para>The Command module's safety relies on the specification's output
      values precisely matching the callback function which invokes the main
      program. In order to prevent any such mismatches, Command uses some
      interesting type machinery to guarantee they remain in sync. You don't
      have to understand this section to use the more advanced combinators,
      but it'll help you debug type errors as you use Command more.<indexterm
          class="singular">
          <primary>callback function</primary>
        </indexterm><indexterm class="singular">
          <primary>specifications</primary>

          <secondary>syncronization of</secondary>
        </indexterm><indexterm class="singular">
          <primary>debugging</primary>

          <secondary>Command mode</secondary>
        </indexterm><indexterm class="singular">
          <primary>Command module</primary>
        </indexterm></para>

      <para>The <literal moreinfo="none">Command.Spec.t</literal> type looks
      deceptively simple: <literal moreinfo="none">('a, 'b) t</literal>. You
      can think of <literal moreinfo="none">('a, 'b) t</literal> here as a
      function of type <literal moreinfo="none">'a -&gt; 'b</literal>, but
      embellished with information about:</para>

      <itemizedlist>
        <listitem>
          <para>How to parse the command line</para>
        </listitem>

        <listitem>
          <para>What the command does and how to call it</para>
        </listitem>

        <listitem>
          <para>How to autocomplete a partial command line</para>
        </listitem>
      </itemizedlist>

      <para>The type of a specification transforms a <literal
      moreinfo="none">'a</literal> to a <literal moreinfo="none">'b</literal>
      value. For instance, a value of <literal
      moreinfo="none">Spec.t</literal> might have type <literal
      moreinfo="none">(arg1 -&gt; ... -&gt; argN -&gt; 'r, 'r)
      Spec.t</literal>.</para>

      <para>Such a value transforms a main function of type <literal
      moreinfo="none">arg1 -&gt; ... -&gt; argN -&gt; 'r</literal> by
      supplying all the argument values, leaving a main function that returns
      a value of type <literal moreinfo="none">'r</literal>. Let's look at
      some examples of specs, and their types:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/command_types.topscript">command-line-parsing/command_types.topscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Command.Spec.empty ;;</userinput>
<computeroutput moreinfo="none">- : ('m, 'm) Command.Spec.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.Spec.(empty +&gt; anon ("foo" %: int)) ;;</userinput>
<computeroutput moreinfo="none">- : (int -&gt; '_a, '_a) Command.Spec.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>The empty specification is simple, as it doesn't add any
      parameters to the callback type. The second example adds an <literal
      moreinfo="none">int</literal> anonymous parameter that is reflected in
      the inferred type. One forms a command by combining a spec of type
      <literal moreinfo="none">('main, unit) Spec.t</literal> with a function
      of type <literal moreinfo="none">'main</literal>. The combinators we've
      shown so far incrementally build the type of <literal
      moreinfo="none">'main</literal> according to the command-line parameters
      it expects, so the resulting type of <literal
      moreinfo="none">'main</literal> is something like <literal
      moreinfo="none">arg1 -&gt; ... -&gt; argN -&gt; unit</literal>.</para>

      <para>The type of <literal moreinfo="none">Command.basic</literal>
      should make more sense now:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/basic.topscript">command-line-parsing/basic.topscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Command.basic ;;</userinput>
<computeroutput moreinfo="none">- : summary:string -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?readme:(unit -&gt; string) -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

      <para>The parameters to <literal moreinfo="none">Spec.t</literal> are
      important here. They show that the callback function for a spec should
      consume identical arguments to the supplied <literal
      moreinfo="none">main</literal> function, except for an additional
      <literal moreinfo="none">unit</literal> argument. This final <literal
      moreinfo="none">unit</literal> is there to make sure the callback is
      evaluated as a function, since if zero command-line arguments are
      specified (i.e., <literal moreinfo="none">Spec.empty</literal>), the
      callback would otherwise have no arguments and be evaluated immediately.
      That's why you have to supply an additional <literal
      moreinfo="none">()</literal> to the callback function in all the
      previous examples.</para>
    </sect2>

    <sect2 id="composing-specification-fragments-together">
      <title>Composing Specification Fragments Together</title>

      <para>If you want to factor out common command-line operations, the
      <literal moreinfo="none">++</literal> operator will append two
      specifications together. Let's add some dummy verbosity and debug flags
      to our calendar application to illustrate this.<indexterm
          class="singular">
          <primary>specifications</primary>

          <secondary>composing fragments together</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/cal_append.ml">command-line-parsing/cal_append.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let add ~common =
  Command.basic ~summary:"Add [days] to the [base] date"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
      ++ common
    )
    (fun base span debug verbose () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff ~common =
  Command.basic ~summary:"Show days between [date2] and [date1]"
    Command.Spec.(
      empty
      +&gt; anon ("date1" %: date)
      +&gt; anon ("date2" %: date)
      ++ common
    )
    (fun date1 date2 debug verbose () -&gt;
       Date.diff date1 date2
       |&gt; printf "%d days\n"
    )</programlisting>

      <para>The definitions of the specifications are very similar to the
      earlier example, except that they append a <literal
      moreinfo="none">common</literal> parameter after each specification. We
      can supply these flags when defining the groups.</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/cal_append.ml">command-line-parsing/cal_append.ml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let () =
  let common =
    Command.Spec.(
      empty
      +&gt; flag "-d" (optional_with_default false bool) ~doc:" Debug mode"
      +&gt; flag "-v" (optional_with_default false bool) ~doc:" Verbose output"
    )
  in
  List.map ~f:(fun (name, cmd) -&gt; (name, cmd ~common))
    [ "add", add; "diff", diff ]
  |&gt; Command.group ~summary:"Manipulate dates"
  |&gt; Command.run</programlisting>

      <para>Both of these flags will now be applied and passed to all the
      callback functions. This makes code refactoring a breeze by using the
      compiler to spot places where you use commands. Just add a parameter to
      the common definition, run the compiler, and fix type errors until
      everything works again.<indexterm class="singular">
          <primary>refactoring</primary>
        </indexterm></para>

      <para>For example, if we remove the <literal
      moreinfo="none">verbose</literal> flag and recompile, we'll get this
      impressively long type error:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/build_cal_append_broken.out">command-line-parsing/build_cal_append_broken.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild cal_append_broken.native</userinput>
<computeroutput moreinfo="none">File "cal_append_broken.ml", line 38, characters 45-52:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type</computeroutput>
<computeroutput moreinfo="none">         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit -&gt; unit) Command.Spec.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit) Command.Spec.t</computeroutput>
<computeroutput moreinfo="none">       Type unit -&gt; unit is not compatible with type unit </computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>While this does look scary, the key line to scan is the last one,
      where it's telling you that you have supplied too many arguments in the
      callback function (<literal moreinfo="none">unit -&gt; unit</literal>
      versus <literal moreinfo="none">unit</literal>). If you started with a
      working program and made this single change, you typically don't even
      need to read the type error, as the filename and location information is
      sufficient to make the obvious fix.</para>
    </sect2>

    <sect2 id="prompting-for-interactive-input">
      <title>Prompting for Interactive Input</title>

      <para>The <literal moreinfo="none">step</literal> combinator lets you
      control the normal course of parsing by supplying a function that maps
      callback arguments to a new set of values. For instance, let's revisit
      our first calendar application that added a number of days onto a
      supplied base date:<indexterm class="singular">
          <primary>interactive input</primary>

          <secondary>prompts for</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/cal_add_days.ml">command-line-parsing/cal_add_days.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add</programlisting>

      <para>This program requires you to specify both the <literal
      moreinfo="none">base</literal> date and the number of <literal
      moreinfo="none">days</literal> to add onto it. If <literal
      moreinfo="none">days</literal> isn't supplied on the command line, an
      error is output. Now let's modify it to interactively prompt for a
      number of days if only the <literal moreinfo="none">base</literal> date
      is supplied:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/cal_add_interactive.ml">command-line-parsing/cal_add_interactive.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let add_days base span () =
  Date.add_days base span
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.( 
      step 
        (fun m base days -&gt;
           match days with
           | Some days -&gt;
             m base days
           | None -&gt;
             print_endline "enter days: ";
             read_int ()
             |&gt; m base
        )
      +&gt; anon ("base" %: date)
      +&gt; anon (maybe ("days" %: int))
    )
    add_days

let () = Command.run add</programlisting>

      <para>The <literal moreinfo="none">days</literal> anonymous argument is
      now an optional integer in the spec, and we want to transform it into a
      nonoptional value before calling our <literal
      moreinfo="none">add_days</literal> callback. The <literal
      moreinfo="none">step</literal> combinator lets us perform this
      transformation by applying its supplied callback function first. In the
      example, the callback first checks if <literal
      moreinfo="none">days</literal> is defined. If it's undefined, then it
      interactively reads an integer from the standard input.</para>

      <para>The first <literal moreinfo="none">m</literal> argument to the
      <literal moreinfo="none">step</literal> callback is the next callback
      function in the chain. The transformation is completed by calling
      <literal moreinfo="none">m base days</literal> to continue processing
      with the new values we've just calculated. The <literal
      moreinfo="none">days</literal> value that is passed onto the next
      callback now has a nonoptional <literal moreinfo="none">int</literal>
      type:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/build_and_run_cal_add_interactive.out">command-line-parsing/build_and_run_cal_add_interactive.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlbuild -use-ocamlfind -tag thread -pkg core cal_add_interactive.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_interactive.native 2013-12-01</userinput>
<computeroutput moreinfo="none">enter days:</computeroutput>
<computeroutput moreinfo="none">35</computeroutput>
<computeroutput moreinfo="none">2014-01-05</computeroutput></programlisting>

      <para>The transformation means that the <literal
      moreinfo="none">add_days</literal> callback can just keep its original
      definition of <literal moreinfo="none">Date.t -&gt; int -&gt;
      unit</literal>. The <literal moreinfo="none">step</literal> function
      transformed the <literal moreinfo="none">int option</literal> argument
      from the parsing into an <literal moreinfo="none">int</literal> suitable
      for <literal moreinfo="none">add_days</literal>. This transformation is
      explicitly represented in the type of the <literal
      moreinfo="none">step</literal> return value:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/step.topscript">command-line-parsing/step.topscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">open Command.Spec ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">step (fun m (base:Date.t) days -&gt;</userinput>
<userinput moreinfo="none">  match days with</userinput>
<userinput moreinfo="none">  | Some days -&gt; m base days</userinput>
<userinput moreinfo="none">  | None -&gt;</userinput>
<userinput moreinfo="none">     print_endline "enter days: ";</userinput>
<userinput moreinfo="none">     m base (read_int ())) ;;</userinput>
<computeroutput moreinfo="none">- : (Date.t -&gt; int -&gt; '_a, Date.t -&gt; int option -&gt; '_a) t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>The first half of the <literal moreinfo="none">Spec.t</literal>
      shows that the callback type is <literal moreinfo="none">Date.t -&gt;
      int</literal>, whereas the resulting value expected from the next
      specification in the chain is a <literal moreinfo="none">Date.t -&gt;
      int option</literal>.</para>
    </sect2>

    <sect2 id="adding-labeled-arguments-to-callbacks">
      <title>Adding Labeled Arguments to Callbacks</title>

      <para>The <literal moreinfo="none">step</literal> chaining lets you
      control the types of your callbacks very easily. This can help you match
      existing interfaces or make things more explicit by adding labeled
      arguments:<indexterm class="singular">
          <primary>callback function</primary>
        </indexterm><indexterm class="singular">
          <primary>arguments</primary>

          <secondary>labeled arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>labeled arguments</primary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/cal_add_labels.ml">command-line-parsing/cal_add_labels.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let add_days ~base_date ~num_days () =
  Date.add_days base_date num_days
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.( 
      step (fun m base days -&gt; m ~base_date:base ~num_days:days)
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    add_days

let () = Command.run add</programlisting>

      <para>This <literal moreinfo="none">cal_add_labels</literal> example
      goes back to our noninteractive calendar addition program, but the
      <literal moreinfo="none">add_days</literal> main function now expects
      labeled arguments. The <literal moreinfo="none">step</literal> function
      in the specification simply converts the default <literal
      moreinfo="none">base</literal> and <literal
      moreinfo="none">days</literal> arguments into a labeled function.</para>

      <para>Labeled arguments are more verbose but can also help prevent
      errors with command-line arguments with similar types but different
      names and purposes. It's good form to use labels when you have a lot of
      otherwise anonymous <literal moreinfo="none">int</literal> and <literal
      moreinfo="none">string</literal> arguments.<indexterm class="endofrange"
      startref="CLPadv"></indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="command-line-auto-completion-with-bash">
    <title>Command-Line Autocompletion with bash</title>

    <para>Modern UNIX shells usually have a tab-completion feature to
    interactively help you figure out how to build a command line. These work
    by pressing the Tab key in the middle of typing a command, and seeing the
    options that pop up. You've probably used this most often to find the
    files in the current directory, but it can actually be extended for other
    parts of the command, too.<indexterm class="singular">
        <primary>tab-autocompletion</primary>
      </indexterm><indexterm class="singular">
        <primary>autocompletion</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>autocompletion with bash</secondary>
      </indexterm></para>

    <para>The precise mechanism for autocompletion varies depending on what
    shell you are using, but we'll assume you are using the most common one:
    <command moreinfo="none">bash</command>. This is the default interactive
    shell on most Linux distributions and Mac OS X, but you may need to switch
    to it on *BSD or Windows (when using Cygwin). The rest of this section
    assumes that you're using <command
    moreinfo="none">bash</command>.<indexterm class="singular">
        <primary>bash autocompletion</primary>
      </indexterm></para>

    <para>Bash autocompletion isn't always installed by default, so check your
    OS package manager to see if you have it available.</para>

    <informaltable>
      <tgroup cols="3">
        <colspec align="left" />

        <colspec align="left" />

        <colspec align="left" />

        <thead>
          <row>
            <entry>Operating system</entry>

            <entry>Package manager</entry>

            <entry>Package</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Debian Linux</entry>

            <entry><literal moreinfo="none">apt</literal></entry>

            <entry><literal moreinfo="none">bash-completion</literal></entry>
          </row>

          <row>
            <entry>Mac OS X</entry>

            <entry>Homebrew</entry>

            <entry><literal moreinfo="none">bash-completion</literal></entry>
          </row>

          <row>
            <entry>FreeBSD</entry>

            <entry>Ports system</entry>

            <entry><filename
            moreinfo="none">/usr/ports/shells/bash-completion</filename></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Once <emphasis>bash</emphasis> completion is installed and
    configured, check that it works by typing the <literal
    moreinfo="none">ssh</literal> command and pressing the Tab key. This
    should show you the list of known hosts from your
    <emphasis>~/.ssh/known_hosts</emphasis> file. If it lists some hosts that
    you've recently connected to, you can continue on. If it lists the files
    in your current directory instead, then check your OS documentation to
    configure completion correctly.</para>

    <para>One last bit of information you'll need to find is the location of
    the <filename moreinfo="none">bash_completion.d</filename> directory. This
    is where all the shell fragments that contain the completion logic are
    held. On Linux, this is often in <filename
    moreinfo="none">/etc/bash_completion.d</filename>, and in Homebrew on Mac
    OS X, it would be <filename
    moreinfo="none">/usr/local/etc/bash_completion.d</filename> by
    default.</para>

    <sect2 id="generating-completion-fragments-from-command">
      <title>Generating Completion Fragments from Command</title>

      <para>The Command library has a declarative description of all the
      possible valid options, and it can use this information to generate a
      shell script that provides completion support for that command. To
      generate the fragment, just run the command with the
      <envar>COMMAND_OUTPUT_INSTALLATION_BASH</envar> environment variable set
      to any value.</para>

      <para>For example, let's try it on our MD5 example from earlier,
      assuming that the binary is called <command
      moreinfo="none">basic_md5_with_flags</command> in the current
      directory:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/md5_completion.out">command-line-parsing/md5_completion.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./basic_md5_with_flags.native</userinput>
<computeroutput moreinfo="none">function _jsautocom_23343 {</computeroutput>
<computeroutput moreinfo="none">  export COMP_CWORD</computeroutput>
<computeroutput moreinfo="none">  COMP_WORDS[0]=./basic_md5_with_flags.native</computeroutput>
<computeroutput moreinfo="none">  COMPREPLY=($("${COMP_WORDS[@]}"))</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<computeroutput moreinfo="none">complete -F _jsautocom_23343 ./basic_md5_with_flags.native</computeroutput></programlisting>

      <para>Recall that we used the <literal
      moreinfo="none">Arg_type.file</literal> to specify the argument type.
      This also supplies the completion logic so that you can just press Tab
      to complete files in your current directory.</para>
    </sect2>

    <sect2 id="installing-the-completion-fragment">
      <title>Installing the Completion Fragment</title>

      <para>You don't need to worry about what the preceding output script
      actually does (unless you have an unhealthy fascination with shell
      scripting internals, that is). Instead, redirect the output to a file in
      your current directory and source it into your current shell:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/command-line-parsing/cal_completion.out">command-line-parsing/cal_completion.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./cal_add_sub_days.native &gt; cal.cmd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">. cal.cmd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_sub_days.native &lt;tab&gt;</userinput>
<computeroutput moreinfo="none">add      diff     help     version</computeroutput></programlisting>

      <para>Command completion support works for flags and grouped commands
      and is very useful when building larger command-line interfaces. Don't
      forget to install the shell fragment into your global <filename
      moreinfo="none">bash_completion.d</filename> directory if you want it to
      be loaded in all of your login shells.<indexterm class="singular">
          <primary>completion handlers</primary>
        </indexterm></para>

      <note>
        <title>Installing a Generic Completion Handler</title>

        <para>Sadly, <command moreinfo="none">bash</command> doesn't support
        installing a generic handler for all Command-based applications. This
        means you have to install the completion script for every application,
        but you should be able to automate this in the build and packaging
        system for your application.</para>

        <para>It will help to check out how other applications install
        tab-completion scripts and follow their lead, as the details are very
        OS-specific.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="alternative-command-line-parsers">
    <title>Alternative Command-Line Parsers</title>

    <para>This rounds up our tour of the Command library. This isn't the only
    way to parse command-line arguments of course; there are several
    alternatives available on OPAM. Three of the most prominent ones
    follow:<indexterm class="singular">
        <primary>Cmdliner</primary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocaml-getopt</secondary>
      </indexterm><indexterm class="singular">
        <primary>Arg module</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>alternatives to Command library</secondary>
      </indexterm><indexterm class="singular">
        <primary>OPAM package manager</primary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term>The <literal moreinfo="none">Arg</literal> module</term>

        <listitem>
          <para>The<literal> Arg</literal> module is from the OCaml standard
          library, which is used by the compiler itself to handle its
          command-line interface. Command is generally more featureful than
          Arg (mainly via support for subcommands, the <literal
          moreinfo="none">step</literal> combinator to transform inputs, and
          help generation), but there's absolutely nothing wrong with using
          Arg either.</para>

          <para>You can use the <literal
          moreinfo="none">Command.Spec.flags_of_args_exn</literal> function to
          convert Arg specifications into ones compatible with Command. This
          is quite often used to help port older non-Core code into the Core
          standard library world.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><ulink
        url="https://forge.ocamlcore.org/projects/ocaml-getopt/">ocaml-getopt</ulink></term>

        <listitem>
          <para><literal>ocaml-getopt</literal> provides the general
          command-line syntax of GNU <literal moreinfo="none">getopt</literal>
          and <literal moreinfo="none"
          role="keep-together">getopt_long</literal>. The GNU conventions are
          widely used in the open source world, and this library lets your
          OCaml programs obey the same rules.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><ulink
        url="http://erratique.ch/software/cmdliner">Cmdliner</ulink></term>

        <listitem>
          <para>Cmdliner is a mix between the Command and Getopt libraries. It
          allows for the declarative definition of command-line interfaces but
          exposes a more <literal moreinfo="none">getopt</literal>-like
          interface. It also automates the generation of UNIX man pages as
          part of the specification. Cmdliner is the parser used by OPAM to
          manage its command line.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>