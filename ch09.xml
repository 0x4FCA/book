<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="functors">
  <title>Functors</title>

  <para>Up until now, we've seen OCaml's modules play an important but limited
  role. In particular, we've seen them as a mechanism for organizing code into
  units with specified interfaces. But OCaml's module system can do much more
  than that, serving as a powerful tool for building generic code and
  structuring large-scale systems. Much of that power comes from
  functors.<indexterm class="singular">
      <primary>functors</primary>

      <secondary>benefits of</secondary>
    </indexterm></para>

  <para>Functors are, roughly speaking, functions from modules to modules, and
  they can be used to solve a variety of code-structuring problems,
  including:</para>

  <para><variablelist>
      <varlistentry>
        <term>Dependency injection</term>

        <listitem>
          <para>Makes the implementations of some components of a system
          swappable. This is particularly useful when you want to mock up
          parts of your system for testing and simulation purposes.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Autoextension of modules</term>

        <listitem>
          <para>Functors give you a way of extending existing modules with new
          functionality in a standardized way. For example, you might want to
          add a slew of comparison operators derived from a base comparison
          function. To do this by hand would require a lot of repetitive code
          for each type, but functors let you write this logic just once and
          apply it to many different types.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Instantiating modules with state</term>

        <listitem>
          <para>Modules can contain mutable states, and that means that you'll
          occasionally want to have multiple instantiations of a particular
          module, each with its own separate and independent mutable state.
          Functors let you automate the construction of such modules.</para>
        </listitem>
      </varlistentry>
    </variablelist></para>

  <para>These are really just some of the uses that you can put functors to.
  We'll make no attempt to provide examples of all of the uses of functors
  here. Instead, this chapter will try to provide examples that illuminate the
  language features and design patterns that you need to master in order to
  use functors effectively.</para>

  <sect1 id="a-trivial-example">
    <title>A Trivial Example</title>

    <para>Let's create a functor that takes a module containing a single
    integer variable <literal moreinfo="none">x</literal> and returns a new
    module with <literal moreinfo="none">x</literal> incremented by one. This
    is intended to serve as a way to walk through the basic mechanics of
    functors, even though it's not something you'd want to do in
    practice.<indexterm class="singular">
        <primary>functors</primary>

        <secondary>basic mechanics of</secondary>
      </indexterm></para>

    <para>First, let's define a signature for a module that contains a single
    value of type <literal moreinfo="none">int</literal>:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module type X_int = sig val x : int end;;</userinput>
<computeroutput moreinfo="none">module type X_int = sig val x : int end</computeroutput></programlisting>

    <para>Now we can define our functor. We'll use <literal
    moreinfo="none">X_int</literal> both to constrain the argument to the
    functor and to constrain the module returned by the functor:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Increment (M : X_int) : X_int = struct</userinput>
<userinput moreinfo="none">    let x = M.x + 1</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Increment : functor (M : X_int) -&gt; X_int</computeroutput></programlisting>

    <para>One thing that immediately jumps out is that functors are more
    syntactically heavyweight than ordinary functions. For one thing, functors
    require explicit (module) type annotations, which ordinary functions do
    not. Technically, only the type on the input is mandatory, although in
    practice, you should usually constrain the module returned by the functor,
    just as you should use an <literal moreinfo="none">mli</literal>, even
    though it's not mandatory.</para>

    <para>The following shows what happens when we omit the module type for
    the output of the functor:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Increment (M : X_int) = struct</userinput>
<userinput moreinfo="none">    let x = M.x + 1</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Increment : functor (M : X_int) -&gt; sig val x : int end</computeroutput></programlisting>

    <para>We can see that the inferred module type of the output is now
    written out explicitly, rather than being a reference to the named
    signature <literal moreinfo="none">X_int</literal>.</para>

    <para>We can use <literal moreinfo="none">Increment</literal> to define
    new modules:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Three = struct let x = 3 end;;</userinput>
<computeroutput moreinfo="none">module Three : sig val x : int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Four = Increment(Three);;</userinput>
<computeroutput moreinfo="none">module Four : sig val x : int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Four.x - Three.x;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput></programlisting>

    <para>In this case, we applied <literal
    moreinfo="none">Increment</literal> to a module whose signature is exactly
    equal to <literal moreinfo="none">X_int</literal>. But we can apply
    <literal moreinfo="none">Increment</literal> to any module that
    <emphasis>satisfies</emphasis> the interface <literal
    moreinfo="none">X_int</literal>, in the same way that the contents of an
    <literal moreinfo="none">ml</literal> file must satisfy the <literal
    moreinfo="none">mli</literal>. That means that the module type can omit
    some information available in the module, either by dropping fields or by
    leaving some fields abstract. Here's an example:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Three_and_more = struct</userinput>
<userinput moreinfo="none">    let x = 3</userinput>
<userinput moreinfo="none">    let y = "three"</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Three_and_more : sig val x : int val y : string end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Four = Increment(Three_and_more);;</userinput>
<computeroutput moreinfo="none">module Four : sig val x : int end</computeroutput></programlisting>

    <para>The rules for determining whether a module matches a given signature
    are similar in spirit to the rules in an object-oriented language that
    determine whether an object satisfies a given interface. As in an
    object-oriented context, the extra information that doesn't match the
    signature you're looking for (in this case, the variable <literal
    moreinfo="none">y</literal>) is simply ignored.</para>
  </sect1>

  <sect1 id="a-bigger-example-computing-with-intervals">
    <title>A Bigger Example: Computing with Intervals</title>

    <para>Let's consider a more realistic example of how to use functors: a
    library for computing with intervals. Intervals are a common computational
    object, and they come up in different contexts and for different types.
    You might need to work with intervals of floating-point values or strings
    or times, and in each of these cases, you want similar operations: testing
    for emptiness, checking for containment, intersecting intervals, and so
    on.</para>

    <para>Let's see how to use functors to build a generic interval library
    that can be used with any type that supports a total ordering on the
    underlying set over which you want to build intervals.<indexterm
        class="singular">
        <primary>interval computation</primary>

        <secondary>generic library for</secondary>
      </indexterm><indexterm class="startofrange" id="FUNCTinterv">
        <primary>functors</primary>

        <secondary>interval computation with</secondary>
      </indexterm></para>

    <para>First we'll define a module type that captures the information we'll
    need about the endpoints of the intervals. This interface, which we'll
    call <literal moreinfo="none">Comparable</literal>, contains just two
    things: a comparison function and the type of the values to be
    compared:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module type Comparable = sig</userinput>
<userinput moreinfo="none">    type t</userinput>
<userinput moreinfo="none">    val compare : t -&gt; t -&gt; int</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module type Comparable = sig type t val compare : t -&gt; t -&gt; int end</computeroutput></programlisting>

    <para>The comparison function follows the standard OCaml idiom for such
    functions, returning <literal moreinfo="none">0</literal> if the two
    elements are equal, a positive number if the first element is larger than
    the second, and a negative number if the first element is smaller than the
    second. Thus, we could rewrite the standard comparison functions on top of
    <literal moreinfo="none">compare</literal>.</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/compare_example.ml">functors/compare_example.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">compare x y &lt; 0     (* x &lt; y *)
compare x y = 0     (* x = y *)
compare x y &gt; 0     (* x &gt; y *)</programlisting>

    <para>(This idiom is a bit of a historical error. It would be better if
    <literal>compare</literal> returned a variant with three cases for less
    than, greater than, and equal. But it's well-established at this point and
    unlikely to change.)</para>

    <para>The functor for creating the interval module follows. We represent
    an interval with a variant type, which is either <literal
    moreinfo="none">Empty</literal> or <literal moreinfo="none">Interval
    (x,y)</literal>, where <literal moreinfo="none">x</literal> and <literal
    moreinfo="none">y</literal> are the bounds of the interval. In addition to
    the type, the functor contains implementations of a number of useful
    primitives for interacting with intervals:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Make_interval(Endpoint : Comparable) = struct</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    type t = | Interval of Endpoint.t * Endpoint.t</userinput>
<userinput moreinfo="none">             | Empty</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (** [create low high] creates a new interval from [low] to</userinput>
<userinput moreinfo="none">        [high].  If [low &gt; high], then the interval is empty *)</userinput>
<userinput moreinfo="none">    let create low high =</userinput>
<userinput moreinfo="none">      if Endpoint.compare low high &gt; 0 then Empty</userinput>
<userinput moreinfo="none">      else Interval (low,high)</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (** Returns true iff the interval is empty *)</userinput>
<userinput moreinfo="none">    let is_empty = function</userinput>
<userinput moreinfo="none">      | Empty -&gt; true</userinput>
<userinput moreinfo="none">      | Interval _ -&gt; false</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (** [contains t x] returns true iff [x] is contained in the</userinput>
<userinput moreinfo="none">        interval [t] *)</userinput>
<userinput moreinfo="none">    let contains t x =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; false</userinput>
<userinput moreinfo="none">      | Interval (l,h) -&gt;</userinput>
<userinput moreinfo="none">        Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (** [intersect t1 t2] returns the intersection of the two input</userinput>
<userinput moreinfo="none">        intervals *)</userinput>
<userinput moreinfo="none">    let intersect t1 t2 =</userinput>
<userinput moreinfo="none">      let min x y = if Endpoint.compare x y &lt;= 0 then x else y in</userinput>
<userinput moreinfo="none">      let max x y = if Endpoint.compare x y &gt;= 0 then x else y in</userinput>
<userinput moreinfo="none">      match t1,t2 with</userinput>
<userinput moreinfo="none">      | Empty, _ | _, Empty -&gt; Empty</userinput>
<userinput moreinfo="none">      | Interval (l1,h1), Interval (l2,h2) -&gt;</userinput>
<userinput moreinfo="none">        create (max l1 l2) (min h1 h2)</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module Make_interval :</computeroutput>
<computeroutput moreinfo="none">  functor (Endpoint : Comparable) -&gt;</computeroutput>
<computeroutput moreinfo="none">    sig</computeroutput>
<computeroutput moreinfo="none">      type t = Interval of Endpoint.t * Endpoint.t | Empty</computeroutput>
<computeroutput moreinfo="none">      val create : Endpoint.t -&gt; Endpoint.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">      val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">      val contains : t -&gt; Endpoint.t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">      val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    end</computeroutput></programlisting>

    <para>We can instantiate the functor by applying it to a module with the
    right signature. In the following code, rather than name the module first
    and then call the functor, we provide the functor input as an anonymous
    module:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval =</userinput>
<userinput moreinfo="none">    Make_interval(struct</userinput>
<userinput moreinfo="none">      type t = int</userinput>
<userinput moreinfo="none">      let compare = Int.compare</userinput>
<userinput moreinfo="none">    end);;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Interval of int * int | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>If the input interface for your functor is aligned with the
    standards of the libraries you use, then you don't need to construct a
    custom module to feed to the functor. In this case, we can directly use
    the <literal moreinfo="none">Int</literal> or <literal
    moreinfo="none">String</literal> modules provided by Core:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int) ;;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t = Interval of int * int | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">module String_interval = Make_interval(String) ;;</userinput>
<computeroutput moreinfo="none">module String_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t =</computeroutput>
<computeroutput moreinfo="none">      Make_interval(Core.Std.String).t =</computeroutput>
<computeroutput moreinfo="none">        Interval of string * string</computeroutput>
<computeroutput moreinfo="none">      | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : string -&gt; string -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; string -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>This works because many modules in Core, including <literal
    moreinfo="none">Int</literal> and <literal
    moreinfo="none">String</literal>, satisfy an extended version of the
    <literal moreinfo="none">Comparable</literal> signature described
    previously. Such standardized signatures are good practice, both because
    they makes functors easier to use, and because they encourage
    standardization that makes your codebase easier to navigate.</para>

    <para>Now we can use the newly defined <literal
    moreinfo="none">Int_interval</literal> module like any ordinary
    module:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let i1 = Int_interval.create 3 8;;</userinput>
<computeroutput moreinfo="none">val i1 : Int_interval.t = Int_interval.Interval (3, 8)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let i2 = Int_interval.create 4 10;;</userinput>
<computeroutput moreinfo="none">val i2 : Int_interval.t = Int_interval.Interval (4, 10)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.intersect i1 i2;;</userinput>
<computeroutput moreinfo="none">- : Int_interval.t = Int_interval.Interval (4, 8)</computeroutput></programlisting>

    <para>This design gives us the freedom to use any comparison function we
    want for comparing the endpoints. We could, for example, create a type of
    integer interval with the order of the comparison reversed, as
    follows:<indexterm class="singular">
        <primary>interval computation</primary>

        <secondary>comparison function for</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 10)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">module Rev_int_interval =</userinput>
<userinput moreinfo="none">    Make_interval(struct</userinput>
<userinput moreinfo="none">      type t = int</userinput>
<userinput moreinfo="none">      let compare x y = Int.compare y x</userinput>
<userinput moreinfo="none">    end);;</userinput>
<computeroutput moreinfo="none">module Rev_int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Interval of int * int | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>The behavior of <literal moreinfo="none">Rev_int_interval</literal>
    is of course different from <literal
    moreinfo="none">Int_interval</literal>:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 11)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let interval = Int_interval.create 4 3;;</userinput>
<computeroutput moreinfo="none">val interval : Int_interval.t = Int_interval.Empty</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rev_interval = Rev_int_interval.create 4 3;;</userinput>
<computeroutput moreinfo="none">val rev_interval : Rev_int_interval.t = Rev_int_interval.Interval (4, 3)</computeroutput></programlisting>

    <para>Importantly, <literal moreinfo="none">Rev_int_interval.t</literal>
    is a different type than <literal
    moreinfo="none">Int_interval.t</literal>, even though its physical
    representation is the same. Indeed, the type system will prevent us from
    confusing them.</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
    (part 12)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.contains rev_interval 3;;</userinput>
<computeroutput moreinfo="none">Characters 22-34:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type Rev_int_interval.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type Int_interval.t</computeroutput></programlisting>

    <para>This is important, because confusing the two kinds of intervals
    would be a semantic error, and it's an easy one to make. The ability of
    functors to mint new types is a useful trick that comes up a lot.</para>

    <sect2 id="making-the-functor-abstract">
      <title>Making the Functor Abstract</title>

      <para>There's a problem with <literal
      moreinfo="none">Make_interval</literal>. The code we wrote depends on
      the invariant that the upper bound of an interval is greater than its
      lower bound, but that invariant can be violated. The invariant is
      enforced by the <literal>create</literal> function, but because <literal
      moreinfo="none">Interval.t</literal> is not abstract, we can bypass the
      <literal moreinfo="none">create</literal> function:<indexterm
          class="singular">
          <primary>interval computation</primary>

          <secondary>abstract functor for</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.is_empty (* going through create *)</userinput>
<userinput moreinfo="none">    (Int_interval.create 4 3) ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.is_empty (* bypassing create *)</userinput>
<userinput moreinfo="none">    (Int_interval.Interval (4,3)) ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

      <para>To make <literal moreinfo="none">Int_interval.t</literal>
      abstract, we need to restrict the output of <literal
      moreinfo="none">Make_interval</literal> with an interface. Here's an
      explicit interface that we can use for that purpose:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 14)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module type Interval_intf = sig</userinput>
<userinput moreinfo="none">   type t</userinput>
<userinput moreinfo="none">   type endpoint</userinput>
<userinput moreinfo="none">   val create : endpoint -&gt; endpoint -&gt; t</userinput>
<userinput moreinfo="none">   val is_empty : t -&gt; bool</userinput>
<userinput moreinfo="none">   val contains : t -&gt; endpoint -&gt; bool</userinput>
<userinput moreinfo="none">   val intersect : t -&gt; t -&gt; t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Interval_intf =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    type endpoint</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>This interface includes the type <literal
      moreinfo="none">endpoint</literal> to give us a way of referring to the
      endpoint type. Given this interface, we can redo our definition of
      <literal moreinfo="none">Make_interval</literal>. Notice that we added
      the type <literal moreinfo="none">endpoint</literal> to the
      implementation of the module to match <literal
      moreinfo="none">Interval_intf</literal>:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main-15.rawscript">functors/main-15.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Make_interval(Endpoint : Comparable) : Interval_intf = struct
    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;</userinput>
<computeroutput moreinfo="none">  module Make_interval : functor (Endpoint : Comparable) -&gt; Interval_intf</computeroutput></programlisting>
    </sect2>

    <sect2 id="sharing-constraints">
      <title>Sharing Constraints</title>

      <para>The resulting module is abstract, but it's unfortunately too
      abstract. In particular, we haven't exposed the type <literal
      moreinfo="none">endpoint</literal>, which means that we can't even
      construct an interval anymore:<indexterm class="singular">
          <primary>sharing constraint</primary>
        </indexterm><indexterm class="singular">
          <primary>interval computation</primary>

          <secondary>sharing constraints</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 16)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int);;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t</computeroutput>
<computeroutput moreinfo="none">    type endpoint = Make_interval(Core.Std.Int).endpoint</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.create 3 4;;</userinput>
<computeroutput moreinfo="none">Characters 20-21:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         Int_interval.endpoint</computeroutput></programlisting>

      <para>To fix this, we need to expose the fact that <literal
      moreinfo="none">endpoint</literal> is equal to <literal
      moreinfo="none">Int.t</literal> (or more generally, <literal
      moreinfo="none">Endpoint.t</literal>, where <literal
      moreinfo="none">Endpoint</literal> is the argument to the functor). One
      way of doing this is through a <emphasis>sharing constraint</emphasis>,
      which allows you to tell the compiler to expose the fact that a given
      type is equal to some other type. The syntax for a simple sharing
      constraint is as follows:</para>

      <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/sharing_constraint.syntax">functors/sharing_constraint.syntax</ulink></para>

      <programlisting format="linespecific" language="">&lt;Module_type&gt; with type &lt;type&gt; = &lt;type'&gt;</programlisting>

      <para>The result of this expression is a new signature that's been
      modified so that it exposes the fact that <literal
      moreinfo="none">&lt;type&gt;</literal> defined inside of the module type
      is equal to <literal moreinfo="none">&lt;type'&gt;</literal> whose
      definition is outside of it. One can also apply multiple sharing
      constraints to the same signature:</para>

      <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/multi_sharing_constraint.syntax">functors/multi_sharing_constraint.syntax</ulink></para>

      <programlisting format="linespecific" language="">&lt;Module_type&gt; with type &lt;type1&gt; = &lt;type1'&gt; and &lt;type2&gt; = &lt;type2'&gt;</programlisting>

      <para>We can use a sharing constraint to create a specialized version of
      <literal moreinfo="none">Interval_intf</literal> for integer
      intervals:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 17)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module type Int_interval_intf =</userinput>
<userinput moreinfo="none">    Interval_intf with type endpoint = int;;</userinput>
<computeroutput moreinfo="none">module type Int_interval_intf =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    type endpoint = int</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>We can also use sharing constraints in the context of a functor.
      The most common use case is where you want to expose that some of the
      types of the module being generated by the functor are related to the
      types in the module fed to the functor.</para>

      <para>In this case, we'd like to expose an equality between the type
      <literal moreinfo="none">endpoint</literal> in the new module and the
      type <literal moreinfo="none">Endpoint.t</literal>, from the module
      <literal moreinfo="none">Endpoint</literal> that is the functor
      argument. We can do this as follows:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main-18.rawscript">functors/main-18.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Make_interval(Endpoint : Comparable)
      : (Interval_intf with type endpoint = Endpoint.t)
  = struct

    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;</userinput>
<computeroutput moreinfo="none">module Make_interval :
  functor (Endpoint : Comparable) -&gt;
    sig
      type t
      type endpoint = Endpoint.t
      val create : endpoint -&gt; endpoint -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; endpoint -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end</computeroutput></programlisting>

      <para>So now, the interface is as it was, except that <literal
      moreinfo="none">endpoint</literal> is now known to be equal to <literal
      moreinfo="none">Endpoint.t</literal>. As a result of that type equality,
      we can again do things that require that <literal
      moreinfo="none">endpoint</literal> be exposed, like constructing
      intervals:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 19)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int);;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t</computeroutput>
<computeroutput moreinfo="none">    type endpoint = int</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let i = Int_interval.create 3 4;;</userinput>
<computeroutput moreinfo="none">val i : Int_interval.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.contains i 5;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>
    </sect2>

    <sect2 id="destructive-substitution">
      <title>Destructive Substitution</title>

      <para>Sharing constraints basically do the job, but they have some
      downsides. In particular, we've now been stuck with the useless type
      declaration of <literal moreinfo="none">endpoint</literal> that clutters
      up both the interface and the implementation. A better solution would be
      to modify the <literal moreinfo="none">Interval_intf</literal> signature
      by replacing <literal moreinfo="none">endpoint</literal> with <literal
      moreinfo="none">Endpoint.t</literal> everywhere it shows up, and
      deleting the definition of <literal moreinfo="none">endpoint</literal>
      from the signature. We can do just this using what's called
      <emphasis>destructive substitution</emphasis>. Here's the basic
      syntax:<indexterm class="singular">
          <primary>destructive substitution</primary>
        </indexterm><indexterm class="singular">
          <primary>interval computation</primary>

          <secondary>destructive substitution</secondary>
        </indexterm></para>

      <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/destructive_sub.syntax">functors/destructive_sub.syntax</ulink></para>

      <programlisting format="linespecific" language="">&lt;Module_type&gt; with type &lt;type&gt; := &lt;type'&gt;</programlisting>

      <para>The following shows how we could use this with <literal
      moreinfo="none">Make_interval</literal>:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 20)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module type Int_interval_intf =</userinput>
<userinput moreinfo="none">    Interval_intf with type endpoint := int;;</userinput>
<computeroutput moreinfo="none">module type Int_interval_intf =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>There's now no <literal moreinfo="none">endpoint</literal> type:
      all of its occurrences of have been replaced by <literal
      moreinfo="none">int</literal>. As with sharing constraints, we can also
      use this in the context of a functor:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main-21.rawscript">functors/main-21.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Make_interval(Endpoint : Comparable)
    : Interval_intf with type endpoint := Endpoint.t =
  struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;</userinput>
<computeroutput moreinfo="none">  module Make_interval :
    functor (Endpoint : Comparable) -&gt;
    sig
      type t
      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; Endpoint.t -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end</computeroutput></programlisting>

      <para>The interface is precisely what we want: the type <literal
      moreinfo="none">t</literal> is abstract, and the type of the endpoint is
      exposed; so we can create values of type <literal
      moreinfo="none">Int_interval.t</literal> using the creation function,
      but not directly using the constructors and thereby violating the
      invariants of the module:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 22)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int);;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.is_empty</userinput>
<userinput moreinfo="none">    (Int_interval.create 3 4);;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.is_empty</userinput>
<userinput moreinfo="none">    (Int_interval.Interval (4,3));;</userinput>
<computeroutput moreinfo="none">Characters 40-48:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound constructor Int_interval.Interval</computeroutput></programlisting>

      <para>In addition, the <literal moreinfo="none">endpoint</literal> type
      is gone from the interface, meaning we no longer need to define the
      <literal moreinfo="none">endpoint</literal> type alias in the body of
      the module.</para>

      <para>It's worth noting that the name is somewhat misleading, in that
      there's nothing destructive about destructive substitution; it's really
      just a way of creating a new signature by transforming an existing
      one.</para>
    </sect2>

    <sect2 id="using-multiple-interfaces">
      <title>Using Multiple Interfaces</title>

      <para>Another feature that we might want for our interval module is the
      ability to <emphasis>serialize</emphasis>, i.e., to be able to read and
      write intervals as a stream of bytes. In this case, we'll do this by
      converting to and from s-expressions, which were mentioned already in
      <xref linkend="error-handling" />. To recall, an s-expression is
      essentially a parenthesized expression whose atoms are strings, and it
      is a serialization format that is used commonly in Core. Here's an
      example:<indexterm class="singular">
          <primary>s-expressions</primary>

          <secondary>example of</secondary>
        </indexterm><indexterm class="singular">
          <primary>serialization</primary>
        </indexterm><indexterm class="singular">
          <primary>interval computation</primary>

          <secondary>multiple interfaces and</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 23)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.of_string "(This is (an s-expression))";;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (This is (an s-expression))</computeroutput></programlisting>

      <para>Core comes with a syntax extension called Sexplib which can
      autogenerate s-expression conversion functions from a type declaration.
      Attaching <literal moreinfo="none">with sexp</literal> to a type
      definition signals to the extension to generate the converters. Thus, we
      can write:<indexterm class="singular">
          <primary>sexp declaration</primary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 24)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type some_type = int * string list with sexp;;</userinput>
<computeroutput moreinfo="none">type some_type = int * string list</computeroutput>
<computeroutput moreinfo="none">val some_type_of_sexp : Sexp.t -&gt; int * string list = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_some_type : int * string list -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_some_type (33, ["one"; "two"]);;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (33 (one two))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.of_string "(44 (five six))" |&gt; some_type_of_sexp;;</userinput>
<computeroutput moreinfo="none">- : int * string list = (44, ["five"; "six"])</computeroutput></programlisting>

      <para>We'll discuss s-expressions and Sexplib in more detail in <xref
      linkend="data-serialization-with-s-expressions" />, but for now, let's
      see what happens if we attach the <literal moreinfo="none">with
      sexp</literal> declaration to the definition of <literal
      moreinfo="none">t</literal> within the functor:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main-25.rawscript">functors/main-25.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Make_interval(Endpoint : Comparable)
    : (Interval_intf with type endpoint := Endpoint.t) = struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty
    with sexp

    ...

  end ;;</userinput>
<computeroutput moreinfo="none">  Characters 136-146:
    Error: Unbound value Endpoint.t_of_sexp</computeroutput></programlisting>

      <para>The problem is that <literal moreinfo="none">with sexp</literal>
      adds code for defining the s-expression converters, and that code
      assumes that <literal moreinfo="none">Endpoint</literal> has the
      appropriate sexp-conversion functions for <literal
      moreinfo="none">Endpoint.t</literal>. But all we know about <literal
      moreinfo="none">Endpoint</literal> is that it satisfies the <literal
      moreinfo="none">Comparable</literal> interface, which doesn't say
      anything about s-expressions.</para>

      <para>Happily, Core comes with a built-in interface for just this
      purpose called <literal moreinfo="none">Sexpable</literal>, which is
      defined as follows:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/sexpable.ml">functors/sexpable.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">module type Sexpable = sig
  type t
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
end</programlisting>

      <para>We can modify <literal moreinfo="none">Make_interval</literal> to
      use the <literal moreinfo="none">Sexpable</literal> interface, for both
      its input and its output. First, let's create an extended version of the
      <literal moreinfo="none">Interval_intf</literal> interface that includes
      the functions from the <literal>Sexpable</literal> interface. We can do
      this using destructive substitution on the <literal
      moreinfo="none">Sexpable</literal> interface, to avoid having multiple
      distinct type <literal moreinfo="none">t</literal>'s clashing with each
      other:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 26)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module type Interval_intf_with_sexp = sig</userinput>
<userinput moreinfo="none">   include Interval_intf</userinput>
<userinput moreinfo="none">   include Sexpable with type t := t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Interval_intf_with_sexp =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    type endpoint</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>Equivalently, we can define a type <literal
      moreinfo="none">t</literal> within our new module, and apply destructive
      substitutions to all of the included interfaces, <literal
      moreinfo="none">Interval_intf</literal> included, as shown in the
      following example. This is somewhat cleaner when combining multiple
      interfaces, since it correctly reflects that all of the signatures are
      being handled equivalently:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 27)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module type Interval_intf_with_sexp = sig</userinput>
<userinput moreinfo="none">   type t</userinput>
<userinput moreinfo="none">   include Interval_intf with type t := t</userinput>
<userinput moreinfo="none">   include Sexpable      with type t := t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Interval_intf_with_sexp =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    type endpoint</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>Now we can write the functor itself. We have been careful to
      override the sexp converter here to ensure that the data structure's
      invariants are still maintained when reading in from an
      s-expression:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 28)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module Make_interval(Endpoint : sig</userinput>
<userinput moreinfo="none">                         type t</userinput>
<userinput moreinfo="none">                         include Comparable with type t := t</userinput>
<userinput moreinfo="none">                         include Sexpable   with type t := t</userinput>
<userinput moreinfo="none">                       end)</userinput>
<userinput moreinfo="none">    : (Interval_intf_with_sexp with type endpoint := Endpoint.t)</userinput>
<userinput moreinfo="none">  = struct</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    type t = | Interval of Endpoint.t * Endpoint.t</userinput>
<userinput moreinfo="none">             | Empty</userinput>
<userinput moreinfo="none">    with sexp</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (** [create low high] creates a new interval from [low] to</userinput>
<userinput moreinfo="none">        [high].  If [low &gt; high], then the interval is empty *)</userinput>
<userinput moreinfo="none">    let create low high =</userinput>
<userinput moreinfo="none">      if Endpoint.compare low high &gt; 0 then Empty</userinput>
<userinput moreinfo="none">      else Interval (low,high)</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (* put a wrapper around the autogenerated [t_of_sexp] to enforce</userinput>
<userinput moreinfo="none">       the invariants of the data structure *)</userinput>
<userinput moreinfo="none">    let t_of_sexp sexp =</userinput>
<userinput moreinfo="none">      match t_of_sexp sexp with</userinput>
<userinput moreinfo="none">      | Empty -&gt; Empty</userinput>
<userinput moreinfo="none">      | Interval (x,y) -&gt; create x y</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (** Returns true iff the interval is empty *)</userinput>
<userinput moreinfo="none">    let is_empty = function</userinput>
<userinput moreinfo="none">      | Empty -&gt; true</userinput>
<userinput moreinfo="none">      | Interval _ -&gt; false</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (** [contains t x] returns true iff [x] is contained in the</userinput>
<userinput moreinfo="none">        interval [t] *)</userinput>
<userinput moreinfo="none">    let contains t x =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; false</userinput>
<userinput moreinfo="none">      | Interval (l,h) -&gt;</userinput>
<userinput moreinfo="none">        Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">    (** [intersect t1 t2] returns the intersection of the two input</userinput>
<userinput moreinfo="none">        intervals *)</userinput>
<userinput moreinfo="none">    let intersect t1 t2 =</userinput>
<userinput moreinfo="none">      let min x y = if Endpoint.compare x y &lt;= 0 then x else y in</userinput>
<userinput moreinfo="none">      let max x y = if Endpoint.compare x y &gt;= 0 then x else y in</userinput>
<userinput moreinfo="none">      match t1,t2 with</userinput>
<userinput moreinfo="none">      | Empty, _ | _, Empty -&gt; Empty</userinput>
<userinput moreinfo="none">      | Interval (l1,h1), Interval (l2,h2) -&gt;</userinput>
<userinput moreinfo="none">        create (max l1 l2) (min h1 h2)</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Make_interval :</computeroutput>
<computeroutput moreinfo="none">  functor</computeroutput>
<computeroutput moreinfo="none">    (Endpoint : sig</computeroutput>
<computeroutput moreinfo="none">                  type t</computeroutput>
<computeroutput moreinfo="none">                  val compare : t -&gt; t -&gt; int</computeroutput>
<computeroutput moreinfo="none">                  val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">                  val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">                end) -&gt;</computeroutput>
<computeroutput moreinfo="none">    sig</computeroutput>
<computeroutput moreinfo="none">      type t</computeroutput>
<computeroutput moreinfo="none">      val create : Endpoint.t -&gt; Endpoint.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">      val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">      val contains : t -&gt; Endpoint.t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">      val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">      val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">      val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">    end</computeroutput></programlisting>

      <para>And now, we can use that sexp converter in the ordinary
      way:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/main.topscript">functors/main.topscript</ulink>
      (part 29)<indexterm class="endofrange"
      startref="FUNCTinterv"></indexterm></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int) ;;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.sexp_of_t (Int_interval.create 3 4);;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (Interval 3 4)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.sexp_of_t (Int_interval.create 4 3);;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = Empty</computeroutput></programlisting>
    </sect2>
  </sect1>

  <sect1 id="extending-modules">
    <title>Extending Modules</title>

    <para>Another common use of functors is to generate type-specific
    functionality for a given module in a standardized way. Let's see how this
    works in the context of a functional queue, which is just a functional
    version of a FIFO (first-in, first-out) queue. Being functional,
    operations on the queue return new queues, rather than modifying the
    queues that were passed in.<indexterm class="singular">
        <primary>modules</primary>

        <secondary>type-specific functionality in</secondary>
      </indexterm><indexterm class="singular">
        <primary>FIFO (first-in, first-out) queue</primary>
      </indexterm><indexterm class="singular">
        <primary>functors</primary>

        <secondary>module extension with</secondary>
      </indexterm></para>

    <para>Here's a reasonable <literal moreinfo="none">mli</literal> for such
    a module:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/fqueue.mli">functors/fqueue.mli</ulink></para>

    <programlisting format="linespecific" language="ocaml">type 'a t

val empty : 'a t

(** [enqueue el q] adds [el] to the back of [q] *)
val enqueue : 'a t -&gt; 'a -&gt; 'a t

(** [dequeue q] returns None if the [q] is empty, otherwise returns
    the first element of the queue and the remainder of the queue *)
val dequeue : 'a t -&gt; ('a * 'a t) option

(** Folds over the queue, from front to back *)
val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc</programlisting>

    <para>The preceding <literal moreinfo="none">Fqueue.fold</literal>
    function requires some explanation. It follows the same pattern as the
    <literal moreinfo="none">List.fold</literal> function we described in
    <xref linkend="using-the-list-module-effectively" />. Essentially,
    <literal moreinfo="none">Fqueue.fold q ~init ~f</literal> walks over the
    elements of <literal moreinfo="none">q</literal> from front to back,
    starting with an accumulator of <literal moreinfo="none">init</literal>
    and using <literal moreinfo="none">f</literal> to update the accumulator
    value as it walks over the queue, returning the final value of the
    accumulator at the end of the computation. <literal>fold</literal> is a
    quite powerful operation, as we'll see.</para>

    <para>We'll implement <literal moreinfo="none">Fqueue</literal> using a
    standard trick which is to maintain an input and an output list so that
    one can efficiently enqueue on the input list and efficiently dequeue from
    the output list. If you attempt to dequeue when the output list is empty,
    the input list is reversed and becomes the new output list. Here's the
    implementation:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/fqueue.ml">functors/fqueue.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type 'a t = 'a list * 'a list

let empty = ([],[])

let enqueue (in_list, out_list) x =
  (x :: in_list,out_list)

let dequeue (in_list, out_list) =
  match out_list with
  | hd :: tl -&gt; Some (hd, (in_list, tl))
  | [] -&gt;
    match List.rev in_list with
    | [] -&gt; None
    | hd :: tl -&gt; Some (hd, ([], tl))

let fold (in_list, out_list) ~init ~f =
  let after_out = List.fold ~init ~f out_list in
  List.fold_right ~init:after_out ~f:(fun x acc -&gt; f acc x) in_list</programlisting>

    <para>One problem with <literal moreinfo="none">Fqueue</literal> is that
    the interface is quite skeletal. There are lots of useful helper functions
    that one might want that aren't there. The <literal
    moreinfo="none">List</literal> module, by way of contrast, has functions
    like <literal moreinfo="none">List.iter</literal>, which runs a function
    on each element; and <literal moreinfo="none">List.for_all</literal>,
    which returns true if and only if the given predicate evaluates to
    <literal moreinfo="none">true</literal> on every element of the list. Such
    helper functions come up for pretty much every container type, and
    implementing them over and over is a dull and repetitive affair.</para>

    <para>As it happens, many of these helper functions can be derived
    mechanically from just the <literal>fold</literal> function we already
    implemented. Rather than write all of these helper functions by hand for
    every new container type, we can instead use a functor that will let us
    add this functionality to any container that has a <literal
    moreinfo="none">fold</literal> function.</para>

    <para>We'll create a new module, <literal
    moreinfo="none">Foldable</literal>, that automates the process of adding
    helper functions to a <literal>fold</literal>-supporting container. As you
    can see, <literal moreinfo="none">Foldable</literal> contains a module
    signature <literal moreinfo="none">S</literal> which defines the signature
    that is required to support folding; and a functor <literal
    moreinfo="none">Extend</literal> that allows one to extend any module that
    matches <literal moreinfo="none">Foldable.S</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/foldable.ml">functors/foldable.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

module type S = sig
  type 'a t
  val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc
end

module type Extension = sig
  type 'a t
  val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
  val length  : 'a t -&gt; int
  val count   : 'a t -&gt; f:('a -&gt; bool) -&gt; int
  val for_all : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
  val exists  : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
end

(* For extending a Foldable module *)
module Extend(Arg : S)
  : (Extension with type 'a t := 'a Arg.t) =
struct
  open Arg

  let iter t ~f =
    fold t ~init:() ~f:(fun () a -&gt; f a)

  let length t =
    fold t ~init:0  ~f:(fun acc _ -&gt; acc + 1)

  let count t ~f =
    fold t ~init:0  ~f:(fun count x -&gt; count + if f x then 1 else 0)

  exception Short_circuit

  let for_all c ~f =
    try iter c ~f:(fun x -&gt; if not (f x) then raise Short_circuit); true
    with Short_circuit -&gt; false

  let exists c ~f =
    try iter c ~f:(fun x -&gt; if f x then raise Short_circuit); false
    with Short_circuit -&gt; true
end</programlisting>

    <para>Now we can apply this to <literal moreinfo="none">Fqueue</literal>.
    We can rewrite the interface of <literal moreinfo="none">Fqueue</literal>
    as follows:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/extended_fqueue.mli">functors/extended_fqueue.mli</ulink></para>

    <programlisting format="linespecific" language="ocaml">type 'a t
include (module type of Fqueue) with type 'a t := 'a t
include Foldable.Extension with type 'a t := 'a t</programlisting>

    <para>In order to apply the functor, we'll put the definition of <literal
    moreinfo="none">Fqueue</literal> in a submodule called <literal
    moreinfo="none">T</literal>, and then call <literal
    moreinfo="none">Foldable.Extend</literal> on <literal
    moreinfo="none">T</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/functors/extended_fqueue.ml">functors/extended_fqueue.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">include Fqueue
include Foldable.Extend(Fqueue)</programlisting>

    <para>Core comes with a number of functors for extending modules that
    follow this same basic pattern, including:<indexterm class="singular">
        <primary>Monad.Make</primary>
      </indexterm><indexterm class="singular">
        <primary>Hashable.Make</primary>
      </indexterm><indexterm class="singular">
        <primary>Comparable module</primary>

        <secondary>Comparable.Make</secondary>
      </indexterm><indexterm class="singular">
        <primary>Container.Make</primary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">Container.Make</literal></term>

        <listitem>
          <para>Very similar to <literal
          moreinfo="none">Foldable.Extend</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Comparable.Make</literal></term>

        <listitem>
          <para>Adds support for functionality that depends on the presence of
          a comparison function, including support for containers like maps
          and sets.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Hashable.Make</literal></term>

        <listitem>
          <para>Adds support for hashing-based data structures including hash
          tables, hash sets, and hash heaps.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Monad.Make</literal></term>

        <listitem>
          <para>For so-called monadic libraries, like those discussed in <xref
          linkend="error-handling" /> and <xref
          linkend="concurrent-programming-with-async" />. Here, the functor is
          used to provide a collection of standard helper functions based on
          the <literal moreinfo="none">bind</literal> and <literal
          moreinfo="none">return</literal> operators.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>These functors come in handy when you want to add the same kind of
    functionality that is commonly available in Core to your own types.</para>
  </sect1>
</chapter>