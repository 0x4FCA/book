<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="the-compiler-frontend-parsing-and-type-checking">
      <title>The Compiler Frontend: Parsing and Type Checking</title>

      <para>Compiling source code into executable programs is a fairly complex
      process that involves quite a few toolsâ€”preprocessors, compilers,
      runtime libraries, linkers and assemblers. It's important to understand
      how these fit together to help with your day-to-day workflow of
      developing, debugging and deploying applications.</para>

      <para>OCaml has a strong emphasis on static type safety and rejects
      source code that doesn't meet its requirements as early as possible. The
      compiler does this by running the source code through a series of checks
      and transformations. Each stage performs its job
      (<emphasis>e.g.</emphasis> type checking, optimization or code
      generation) and discards some information from the previous stage. The
      final native code output is low-level assembly code that doesn't know
      anything about the OCaml modules or objects that the compiler started
      with.</para>

      <para>You don't have to do all this manually, of course. The compiler
      frontends (<literal moreinfo="none">ocamlc</literal> and <literal moreinfo="none">ocamlopt</literal>)
      are invoked via the command-line and chain the stages together for you.
      Sometimes though, you'll need to dive into the toolchain to hunt down a
      bug or investigate a performance problem. This chapter explains the
      compiler pipeline in more depth so you understand how to harness the
      command-line tools effectively.</para>

      <para>In this chapter, we'll cover the following topics:</para>

      <itemizedlist>
        <listitem>
          <para>the compilation pipeline and what each stage
          represents.</para>
        </listitem>

        <listitem>
          <para>source preprocessing via Camlp4 and the intermediate
          forms.</para>
        </listitem>

        <listitem>
          <para>the type-checking process, including module resolution.</para>
        </listitem>
      </itemizedlist>

      <para>The details of the compilation process into executable code can be
      found next in <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.</para>

      <sect1 id="an-overview-of-the-toolchain">
        <title>An overview of the toolchain</title>

        <para>The OCaml tools accept textual source code as input, using
        filename extensions of <literal moreinfo="none">.ml</literal> and
        <literal moreinfo="none">.mli</literal> for modules and signatures respectively. We
        explained the basics of the build process earlier in <xref linkend="files-modules-and-programs"/>, so we'll assume you've built
        a few OCaml programs already by this point.</para>

        <para>Each source file represents a <emphasis>compilation
        unit</emphasis> that is built separately. The compiler generates
        intermediate files with different filename extensions to use as it
        advances through the compilation stages. The linker takes a collection
        of compiled units and produces a standalone executable or library
        archive that can be reused by other applications.</para>

        <para>The overall compilation pipeline looks like this:</para>

        <para role="sourcecode">Diagram:
        <filename moreinfo="none">front-end/pipeline.ascii</filename></para>

        <programlisting language="" format="linespecific">    Source code
        |
        | parsing and preprocessing
        |
        | camlp4 syntax extensions
        |
        v
    Parsetree (untyped AST)
        |
        | type inference and checking
        v
    Typedtree (type-annotated AST)
        |
        | pattern-matching compilation
        | elimination of modules and classes
        v
     Lambda
      /   \
     /     \ closure conversion, inlining, uncurrying,
    v       \  data representation strategy
 Bytecode    \
    |         +-----+
    |              Cmm
    |ocamlrun       |
    |               | code generation
    |               | assembly &amp; linking
    v               v
 Interpreted    Compiled</programlisting>

        <para>Notice that the pipeline branches towards the end. OCaml has
        multiple compiler backends that reuse the early stages of compilation,
        but produce very different final outputs. The
        <emphasis>bytecode</emphasis> can be run by a portable interpreter,
        and can even be transformed into JavaScript (via <ulink url="http://ocsigen.org/js_of_ocaml">js_of_ocaml</ulink>) or C source
        code (via <ulink url="https://github.com/ocaml-bytes/ocamlcc">OCamlCC</ulink>). The
        <emphasis>native code</emphasis> compiler generates specialized
        executable binaries suitable for high-performance applications.</para>

        <sidebar>
          <title>Obtaining the compiler source code</title>

          <para>Although it's not necessary to understand the examples, you
          may find it useful to have a copy of the OCaml source tree checked
          out while you read through this chapter. The source code is
          available from multiple places:</para>

          <itemizedlist>
            <listitem>
              <para>Stable releases as zip and tar archives from the <ulink url="http://caml.inria.fr/download.en.html">OCaml download
              site</ulink>.</para>
            </listitem>

            <listitem>
              <para>A Subversion anonymous mirror of the main development
              sources available on the <ulink url="http://caml.inria.fr/ocaml/anonsvn.en.html">development
              resources</ulink> page online.</para>
            </listitem>

            <listitem>
              <para>A Git mirror of the Subversion repository with all the
              history and development branches included, browsable online at
              <ulink url="https://github.com/ocaml/ocaml">Github</ulink>.</para>
            </listitem>
          </itemizedlist>

          <para>The source tree is split up into sub-directories. The core
          compiler consists of:</para>

          <itemizedlist>
            <listitem>
              <para><literal moreinfo="none">config/</literal>: configuration directives to
              tailor OCaml for your operating system and architecture.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">bytecomp/</literal> and
              <literal moreinfo="none">byterun/</literal>: byte-code compiler and runtime,
              including the garbage collector.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">asmcomp/</literal> and
              <literal moreinfo="none">asmrun/</literal>: native-code compiler and runtime.
              The native runtime symlinks many modules from the
              <literal moreinfo="none">byterun</literal> directory to share code, most notably
              the garbage collector.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">parsing/</literal>: the OCaml lexer, parser and
              libraries for manipulating them.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">typing/</literal>: the static type checking
              implementation and type definitions.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">camlp4/</literal>: the source code macro
              preprocessor.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">driver/</literal>: command-line interfaces for
              the compiler tools.</para>
            </listitem>
          </itemizedlist>

          <para>There are a number of tools and scripts also built alongside
          the core compiler:</para>

          <itemizedlist>
            <listitem>
              <para><literal moreinfo="none">debugger/</literal>: the interactive byte-code
              debugger.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">toplevel/</literal>: interactive top-level
              console.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">emacs/</literal>: a
              <emphasis>caml-mode</emphasis> for the Emacs editor.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">stdlib/</literal>: the compiler standard library,
              including the <literal moreinfo="none">Pervasives</literal> module.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">ocamlbuild/</literal>: build system that
              automates common OCaml compilation modes.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">otherlibs/</literal>: optional libraries such as
              the Unix and graphics modules.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">tools/</literal>: command-line utilities such as
              <literal moreinfo="none">ocamldep</literal> that are installed with the
              compiler.</para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">testsuite/</literal>: regression tests for the
              core compiler.</para>
            </listitem>
          </itemizedlist>
        </sidebar>

        <para>We'll go through each of the compilation stages now and explain
        how that'll be useful to you during day-to-day OCaml
        development.</para>
      </sect1>

      <sect1 id="parsing-source-code">
        <title>Parsing source code</title>

        <para>When a source file is passed to the OCaml compiler, its first
        task is to parse the text into a more structured Abstract Syntax Tree
        (AST). The parsing logic is implemented in OCaml itself using the
        techniques described earlier in <xref linkend="parsing-with-ocamllex-and-menhir"/>. The lexer and parser
        rules can be found in the <literal moreinfo="none">parsing</literal> directory in the
        source distribution.</para>

        <sect2 id="syntax-errors">
          <title>Syntax errors</title>

          <para>The OCaml parser's goal is to output a well-formed AST data
          structure to the next phase of compilation, and so it rejects any
          source code that doesn't match basic syntactic requirements. The
          compiler emits a <emphasis>syntax error</emphasis> in this
          situation, with a pointer to the filename and line and character
          number that's as close to the error as possible.</para>

          <para>Here's an example syntax error that we obtain by performing a
          module assignment as a statement instead of as a let-binding.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">front-end/broken_module.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">let () =
  module MyString = String;
  ()</programlisting>

          <para>The above code results in a syntax error when compiled.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/build_broken_module.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c broken_module.ml</userinput>
<computeroutput moreinfo="none">File "broken_module.ml", line 2, characters 2-8:</computeroutput>
<computeroutput moreinfo="none">Error: Syntax error</computeroutput></programlisting>

          <para>The correct version of this source code creates the
          <literal moreinfo="none">MyString</literal> module correctly via a local open, and
          compiles successfully.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">front-end/fixed_module.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">let () =
  let module MyString = String in
  ()</programlisting>

          <para>The syntax error points to the line and character number of
          the first token that couldn't be parsed. In the broken example the
          <literal moreinfo="none">module</literal> keyword isn't a valid token at that point
          in parsing, so the error location information is correct.</para>
        </sect2>

        <sect2 id="automatically-indenting-source-code">
          <title>Automatically indenting source code</title>

          <para>Sadly, syntax errors do get more inaccurate sometimes
          depending on the nature of your mistake. Try to spot the deliberate
          error in the following function definitions.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">front-end/follow_on_function.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">let concat_and_print x y =
  let v = x ^ y in
  print_endline v;
  v;

let add_and_print x y =
  let v = x + y in
  print_endline (string_of_int v);
  v

let () =
  let _x = add_and_print 1 2 in
  let _y = concat_and_print "a" "b" in
  ()</programlisting>

          <para>When you compile this file you'll get a syntax error
          again.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/build_follow_on_function.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c follow_on_function.ml</userinput>
<computeroutput moreinfo="none">File "follow_on_function.ml", line 11, characters 0-3:</computeroutput>
<computeroutput moreinfo="none">Error: Syntax error</computeroutput></programlisting>

          <para>The line number in the error points to the end of the
          <literal moreinfo="none">add_and_print</literal> function, but the actual error is
          at the end of the <emphasis>first</emphasis> function definition.
          There's an extra semicolon at the end of the first definition that
          causes the second definition to become part of the first
          <literal moreinfo="none">let</literal> binding. This eventually results in a parsing
          error at the very end of the second function.</para>

          <para>This class of bug (due to a single errant character) can be
          hard to spot in a large body of code. Luckily, there's a great tool
          available via OPAM called <command moreinfo="none">ocp-indent</command> that applies
          structured indenting rules to your source code on a line-by-line
          basis. This not only beautifies your code layout, but it also makes
          this syntax error much easier to locate.</para>

          <para>Let's run our erroneous file through
          <command moreinfo="none">ocp-indent</command> and see how it processes it.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/indent_follow_on_function.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-indent follow_on_function.ml</userinput>
<computeroutput moreinfo="none">let concat_and_print x y =</computeroutput>
<computeroutput moreinfo="none">  let v = x ^ y in</computeroutput>
<computeroutput moreinfo="none">  print_endline v;</computeroutput>
<computeroutput moreinfo="none">  v;</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  let add_and_print x y =</computeroutput>
<computeroutput moreinfo="none">    let v = x + y in</computeroutput>
<computeroutput moreinfo="none">    print_endline (string_of_int v);</computeroutput>
<computeroutput moreinfo="none">    v</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">let () =</computeroutput>
<computeroutput moreinfo="none">  let _x = add_and_print 1 2 in</computeroutput>
<computeroutput moreinfo="none">  let _y = concat_and_print "a" "b" in</computeroutput>
<computeroutput moreinfo="none">  ()</computeroutput></programlisting>

          <para>The <literal moreinfo="none">add_and_print</literal> definition has been
          indented as if it were part of the first
          <literal moreinfo="none">concat_and_print</literal> definition, and the errant
          semicolon is now much easier to spot. We just need to remove that
          semicolon and re-run <command moreinfo="none">ocp-indent</command> to verify that
          the syntax is correct.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/indent_follow_on_function_fixed.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-indent follow_on_function_fixed.ml</userinput>
<computeroutput moreinfo="none">let concat_and_print x y =</computeroutput>
<computeroutput moreinfo="none">  let v = x ^ y in</computeroutput>
<computeroutput moreinfo="none">  print_endline v;</computeroutput>
<computeroutput moreinfo="none">  v</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">let add_and_print x y =</computeroutput>
<computeroutput moreinfo="none">  let v = x + y in</computeroutput>
<computeroutput moreinfo="none">  print_endline (string_of_int v);</computeroutput>
<computeroutput moreinfo="none">  v</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">let () =</computeroutput>
<computeroutput moreinfo="none">  let _x = add_and_print 1 2 in</computeroutput>
<computeroutput moreinfo="none">  let _y = concat_and_print "a" "b" in</computeroutput>
<computeroutput moreinfo="none">  ()</computeroutput></programlisting>

          <para>The <command moreinfo="none">ocp-indent</command> <ulink url="https://github.com/OCamlPro/ocp-indent">homepage</ulink>
          documents how to integrate it with your favorite editor. All the
          Core libraries are formatted using it to ensure consistency, and
          it's a good idea to do this before publishing your own source code
          online.</para>
        </sect2>

        <sect2 id="generating-documentation-from-interfaces">
          <title>Generating documentation from interfaces</title>

          <para>Whitespace and source code comments are removed during parsing
          and aren't significant in determining the semantics of the program.
          However, other tools in the OCaml distribution can interpret
          comments for their own ends.</para>

          <para>The <command moreinfo="none">ocamldoc</command> tool uses specially formatted
          comments in the source code to generate documentation bundles. These
          comments are combined with the function definitions and signatures
          and output as structured documentation in a variety of formats. It
          can generate HTML pages, LaTeX and PDF documents, UNIX manual pages
          and even module dependency graphs that can be viewed using <ulink url="http://www.graphviz.org">Graphviz</ulink>.</para>

          <para>Here's a sample of some source code that's been annotated with
          <command moreinfo="none">ocamldoc</command> comments.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">front-end/doc.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">(** example.ml: The first special comment of the file is the comment 
    associated with the whole module. *)

(** Comment for exception My_exception. *)
exception My_exception of (int -&gt; int) * int

(** Comment for type [weather]  *)
type weather =
  | Rain of int (** The comment for construtor Rain *)
  | Sun         (** The comment for constructor Sun *)

(** Find the current weather for a country
    @author Anil Madhavapeddy
    @param location The country to get the weather for.
*)
let what_is_the_weather_in location =
  match location with
  | `Cambridge  -&gt; Rain 100
  | `New_york   -&gt; Rain 20
  | `California -&gt; Sun</programlisting>

          <para>The <command moreinfo="none">ocamldoc</command> comments are distinguished by
          beginning with the double asterisk. There are formatting conventions
          for the contents of the comment to mark metadata. For instance, the
          <literal moreinfo="none">@tag</literal> fields mark specific properties such as the
          author of that section of code.</para>

          <para>Try compiling the HTML documentation and UNIX man pages by
          running <command moreinfo="none">ocamldoc</command> over the source file.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/build_ocamldoc.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">mkdir -p html man/man3</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamldoc -html -d html doc.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamldoc -man -d man/man3 doc.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">man -M man Doc</userinput></programlisting>

          <para>You should now have HTML files inside the
          <literal moreinfo="none">html/</literal> directory and also be able to view the UNIX
          manual pages held in <literal moreinfo="none">man/man3</literal>. There are quite a
          few comment formats and options to control the output for the
          various backends. Refer to the <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual029.html">OCaml
          manual</ulink> for the complete list.</para>

          <tip>
            <title>Using custom <command moreinfo="none">ocamldoc</command> generators</title>

            <para>The default HTML output stylesheets from
            <command moreinfo="none">ocamldoc</command> are pretty spartan and distinctly Web
            1.0. The tool supports plugging in custom documentation
            generators, and there are several available that provide prettier
            or more detailed output.</para>

            <itemizedlist>
              <listitem>
                <para><ulink url="http://argot.x9c.fr/">Argot</ulink> is an
                enhanced HTML generator that supports code folding and
                searching by name or type definition.</para>
              </listitem>

              <listitem>
                <para><ulink url="https://gitorious.org/ocamldoc-generators/ocamldoc-generators">ocamldoc-generators</ulink>
                add support for Bibtex references within comments and
                generating literate documentation that embeds the code
                alongside the comments.</para>
              </listitem>

              <listitem>
                <para>JSON output is available via a custom <ulink url="https://github.com/xen-org/ocamldoc-json">generator</ulink>
                in Xen.</para>
              </listitem>
            </itemizedlist>
          </tip>
        </sect2>
      </sect1>

      <sect1 id="preprocessing-source-code">
        <title>Preprocessing source code</title>

        <para>One powerful feature in OCaml is a facility to extend the
        standard language grammar without having to modify the compiler. You
        can roughly think of it as a type-safe version to the
        <literal moreinfo="none">cpp</literal> preprocessor used in C/C++ to control
        conditional compilation directives.</para>

        <para>The OCaml distribution includes a system called Camlp4 for
        writing extensible parsers. This provides some OCaml libraries that
        are used to define grammars and also dynamically loadable syntax
        extensions of such grammars. Camlp4 modules register new language
        keywords and later transform these keywords (or indeed, any portion of
        the input program) into conventional OCaml code that can be understood
        by the rest of the compiler.</para>

        <para>We've already seen several Core libraries that use
        Camlp4:</para>

        <itemizedlist>
          <listitem>
            <para><literal moreinfo="none">Fieldslib</literal> generates first-class values
            that represent fields of a record.</para>
          </listitem>

          <listitem>
            <para><literal moreinfo="none">Sexplib</literal> to convert types to textual
            s-expressions.</para>
          </listitem>

          <listitem>
            <para><literal moreinfo="none">Bin_prot</literal> for efficient binary conversion
            and parsing.</para>
          </listitem>
        </itemizedlist>

        <para>These libraries all extend the language in quite a minimal way
        by adding a <literal moreinfo="none">with</literal> keyword to type declarations to
        signify that extra code should be generated from that declaration. For
        example, here's a trivial use of Sexplib and Fieldslib.</para>

        <para role="sourcecode">OCaml:
        <filename moreinfo="none">front-end/type_conv_example.ml</filename></para>

        <programlisting language="ocaml" format="linespecific">open Sexplib.Std

type t = {
  foo: int;
  bar: string
} with sexp, fields</programlisting>

        <para>Compiling this code will normally give you a syntax error if you
        do so without Camlp4 since the <literal moreinfo="none">with</literal> keyword isn't
        normally allowed after a type definition.</para>

        <para role="sourcecode">Terminal:
        <filename moreinfo="none">front-end/build_type_conv_without_camlp4.out</filename></para>

        <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind ocamlc -c type_conv_example.ml</userinput>
<computeroutput moreinfo="none">File "type_conv_example.ml", line 6, characters 2-6:</computeroutput>
<computeroutput moreinfo="none">Error: Syntax error</computeroutput></programlisting>

        <para>Now add in the syntax extension packages for Fieldslib and
        Sexplib, and everything will compile again.</para>

        <para role="sourcecode">Terminal:
        <filename moreinfo="none">front-end/build_type_conv_with_camlp4.out</filename></para>

        <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind ocamlc -c -syntax camlp4o -package sexplib.syntax \</userinput>
<computeroutput moreinfo="none">    -package fieldslib.syntax type_conv_example.ml</computeroutput></programlisting>

        <para>We've specified a couple of additional flags here. The
        <literal moreinfo="none">-syntax</literal> flag directs <command moreinfo="none">ocamlfind</command>
        to add the <literal moreinfo="none">-pp</literal> flag to the compiler command-line.
        This flag instructs the compiler to run the preprocessor during its
        parsing phase.</para>

        <para>The <literal moreinfo="none">-package</literal> flag imports other OCaml
        libraries. The <literal moreinfo="none">.syntax</literal> suffix in the package name
        is a convention that indicates these libraries are preprocessors that
        should be run during parsing. The syntax extension modules are
        dynamically loaded into the <command moreinfo="none">camlp4o</command> command which
        rewrites the input source code into conventional OCaml code that has
        no trace of the new keywords. The compiler then compiles this
        transformed code with no knowledge of the preprocessor's
        actions.</para>

        <para>Both Fieldslib and Sexplib need this new <literal moreinfo="none">with</literal>
        keyword, but they both can't register the same extension. Instead, a
        library called Type_conv provides the common extension framework for
        them to use. Type_conv registers the <literal moreinfo="none">with</literal> grammar
        extension to Camlp4, and the OCamlfind packaging ensures that it's
        loaded before Variantslib or Sexplib.</para>

        <para>The two extensions generate boilerplate OCaml code based on the
        type definition at compilation time. This avoids the performance hit
        of doing the code generation dynamically and also doesn't require a
        Just-In-Time (JIT) runtime that can be a source of unpredictable
        dynamic behavior. Instead, all the extra code is simply generated at
        compilation time via Camlp4, and type information can be discarded
        from the runtime image.</para>

        <para>The syntax extensions accept an input AST and output a modified
        one. If you're not familiar with the Camlp4 module in question, how do
        you figure out what changes it's made to your code? The obvious way is
        to read the documentation that accompanies the extension. Another
        approach is to use the top-level to explore the extension's behavior
        or run Camlp4 manually yourself to see the transformation in action.
        We'll show you how to do both of these now.</para>

        <sect2 id="using-camlp4-interactively">
          <title>Using Camlp4 interactively</title>

          <para>The <command moreinfo="none">utop</command> top-level can run the phrases that
          you type through <command moreinfo="none">camlp4</command> automatically. You should
          have at least these lines in your <literal moreinfo="none">~/.ocamlinit</literal>
          file in your home directory (see <xref linkend="installation"/> for
          more information).</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">front-end/camlp4_toplevel.topscript</filename></para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#use "topfind" ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<computeroutput moreinfo="none">Findlib has been successfully loaded. Additional directives:</computeroutput>
<computeroutput moreinfo="none">  #require "package";;      to load a package</computeroutput>
<computeroutput moreinfo="none">  #list;;                   to list the available packages</computeroutput>
<computeroutput moreinfo="none">  #camlp4o;;                to load camlp4 (standard syntax)</computeroutput>
<computeroutput moreinfo="none">  #camlp4r;;                to load camlp4 (revised syntax)</computeroutput>
<computeroutput moreinfo="none">  #predicates "p,q,...";;   to set these predicates</computeroutput>
<computeroutput moreinfo="none">  Topfind.reset();;         to force that packages will be reloaded</computeroutput>
<computeroutput moreinfo="none">  #thread;;                 to enable threads</computeroutput>
<computeroutput moreinfo="none"/>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">#camlp4o ;;</userinput></programlisting>

          <para>The first directive loads the <command moreinfo="none">ocamlfind</command>
          top-level interface that lets you require
          <command moreinfo="none">ocamlfind</command> packages (including all their dependent
          packages). The second directive instructs the top-level to filter
          all phrases via Camlp4. You can now run <command moreinfo="none">utop</command> and
          load the syntax extensions in. We'll use the
          <literal moreinfo="none">comparelib</literal> syntax extension for our
          experiments.</para>

          <para>OCaml provides a built-in polymorphic comparison operator that
          inspects the runtime representation of two values to see if they're
          equal. As we noted in <xref linkend="maps-and-hash-tables"/>, the
          polymorphic comparison is less efficient than defining explicit
          comparison functions between values. However, it quickly become
          tedious to manually define comparison functions for complex type
          definitions.</para>

          <para>Let's see how <literal moreinfo="none">comparelib</literal> solves this
          problem by running it in <command moreinfo="none">utop</command>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">front-end/camlp4_toplevel.topscript</filename> (part
          1)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "comparelib.syntax" ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: string; bar : t } ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : string; bar : t; }</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: string; bar: t } with compare ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : string; bar : t; }</computeroutput>
<computeroutput moreinfo="none">val compare : t -&gt; t -&gt; int = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val compare_t : t -&gt; t -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

          <para>The first definition of <literal moreinfo="none">t</literal> is a standard
          OCaml phrase and results in the expected output. The second one
          includes the <literal moreinfo="none">with compare</literal> directive. This is
          intercepted by <literal moreinfo="none">comparelib</literal> and transformed into
          the original type definition with two new functions also
          included.</para>
        </sect2>

        <sect2 id="running-camlp4-from-the-command-line">
          <title>Running Camlp4 from the command line</title>

          <para>The top-level is a quick way to examine the signatures
          generated from the extensions, but how can we see what these new
          functions actually do? You can't do this from
          <command moreinfo="none">utop</command> directly since it embeds the Camlp4
          invocation as an automated part of its operation.</para>

          <para>Let's turn to the command-line to obtain the result of the
          <literal moreinfo="none">comparelib</literal> transformation instead. Create a file
          that contains the type declaration from earlier.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">front-end/comparelib_test.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">type t = { 
  foo: string; 
  bar: t
} with compare</programlisting>

          <para>We need to run the Camlp4 binary with the library paths to
          Comparelib and Type_conv. Let's use a small shell script to wrap
          this invocation.</para>

          <para role="sourcecode">Shell script:
          <filename moreinfo="none">front-end/camlp4_dump.cmd</filename></para>

          <programlisting language="bash" format="linespecific">#!/bin/sh

OCAMLFIND="ocamlfind query -predicates syntax,preprocessor -r"
INCLUDE=`$OCAMLFIND -i-format comparelib.syntax`
ARCHIVES=`$OCAMLFIND -a-format comparelib.syntax`
camlp4o -printer o $INCLUDE $ARCHIVES $1</programlisting>

          <para>The script uses the <command moreinfo="none">ocamlfind</command> package
          manager to list the include and library paths needed by
          <literal moreinfo="none">comparelib</literal>. It then invokes the
          <command moreinfo="none">camlp4o</command> preprocessor with these paths and outputs
          the resulting AST to the standard output.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/process_comparelib_test.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">sh camlp4_dump.cmd comparelib_test.ml</userinput>
<computeroutput moreinfo="none">type t = { foo : string; bar : t }</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">let _ = fun (_ : t) -&gt; ()</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">let rec compare : t -&gt; t -&gt; int =</computeroutput>
<computeroutput moreinfo="none">  fun a__001_ b__002_ -&gt;</computeroutput>
<computeroutput moreinfo="none">    if Pervasives.( == ) a__001_ b__002_</computeroutput>
<computeroutput moreinfo="none">    then 0</computeroutput>
<computeroutput moreinfo="none">    else</computeroutput>
<computeroutput moreinfo="none">      (let ret =</computeroutput>
<computeroutput moreinfo="none">         (Pervasives.compare : string -&gt; string -&gt; int) a__001_.foo</computeroutput>
<computeroutput moreinfo="none">           b__002_.foo</computeroutput>
<computeroutput moreinfo="none">       in</computeroutput>
<computeroutput moreinfo="none">         if Pervasives.( &lt;&gt; ) ret 0</computeroutput>
<computeroutput moreinfo="none">         then ret</computeroutput>
<computeroutput moreinfo="none">         else compare a__001_.bar b__002_.bar)</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">let _ = compare</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">let compare_t = compare</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">let _ = compare_t</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

          <para>The output contains the original type definition accompanied
          by some automatically generated code that implements an explicit
          comparison function for each field in the record. If you're using
          the extension in your compiler command-line, this generated code is
          then compiled as if you had typed it in yourself.</para>

          <para>Note that although the generated code uses
          <literal moreinfo="none">Pervasives.compare</literal>, it is also annotated with a
          <literal moreinfo="none">string</literal> type. This lets the compiler use a
          specialized string comparison function and not actually call the
          runtime polymorphic comparison function. This has implications for
          correctness too: recall from <xref linkend="maps-and-hash-tables"/>
          that <literal moreinfo="none">comparelib</literal> provides reliable comparison
          functions that work for values that are logically the same but that
          have differing internal representations (e.g.
          <literal moreinfo="none">Int.Set.t</literal>).</para>

          <note>
            <title>A style note: wildcards in <literal moreinfo="none">let</literal>
            bindings</title>

            <para>You may have noticed the <literal moreinfo="none">let _ = fun</literal>
            construct in the autogenerated code above. The underscore in a
            <literal moreinfo="none">let</literal> binding is just the same as a wildcard
            underscore in a pattern match, and tells the compiler to accept
            any return value and discard it immediately.</para>

            <para>This is fine for mechanically generated code from Type_conv,
            but should be avoided in code that you write by hand. If it's a
            unit-returning expression, then write a <literal moreinfo="none">unit</literal>
            binding explicitly instead. This will cause a type error if the
            expression changes type in the future (<emphasis>e.g.</emphasis>
            due to code refactoring).</para>

            <para role="sourcecode">Syntax:
            <filename moreinfo="none">front-end/let_unit.syntax</filename></para>

            <programlisting language="" format="linespecific">let () = &lt;expr&gt;</programlisting>

            <para>If the expression has a different type, then write it
            explicitly.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/let_notunit.ml</filename></para>

            <programlisting language="ocaml" format="linespecific">let (_:some_type) = &lt;expr&gt;
let () = ignore (&lt;expr&gt; : some_type)
)(* if the expression returns a unit Deferred.t *)
let () = don't_wait_for (&lt;expr&gt;</programlisting>

            <para>The last one is used to ignore Async expressions that should
            run in the background rather than blocking in the current
            thread.</para>

            <para>One other important reason for using wildcard matches is to
            bind a variable name to something that you want to use in future
            code, but don't want to use right away. This would normally
            generate an "unused value" compiler warning. These warnings are
            suppressed for any variable name that's prepended with an
            underscore.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/unused_var.ml</filename></para>

            <programlisting language="ocaml" format="linespecific">let fn x y =
  let _z = x + y in
  ()</programlisting>

            <para>Although you don't use <literal moreinfo="none">_z</literal> in your code,
            this will never generate an unused variable warning.</para>
          </note>
        </sect2>

        <sect2 id="preprocessing-module-signatures">
          <title>Preprocessing module signatures</title>

          <para>Another useful feature of <literal moreinfo="none">type_conv</literal> is that
          it can generate module signatures too. Copy the earlier type
          definition into a <literal moreinfo="none">comparelib_test.mli</literal> that's got
          exactly the same content.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">front-end/comparelib_test.mli</filename></para>

          <programlisting language="ocaml" format="linespecific">type t = { 
  foo: string; 
  bar: t
} with compare</programlisting>

          <para>If you rerun the Camlp4 dumper script now, you'll see that
          different code is produced for signature files.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/process_comparelib_interface.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">sh camlp4_dump.cmd comparelib_test.mli</userinput>
<computeroutput moreinfo="none">type t = { foo : string; bar : t }</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">val compare : t -&gt; t -&gt; int</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

          <para>The external signature generated by
          <literal moreinfo="none">comparelib</literal> is much simpler than the actual code.
          Running Camlp4 directly on the original source code lets you see
          these all these transformations precisely.</para>

          <caution>
            <title>Don't overdo the syntax extensions</title>

            <para>Syntax extensions are a powerful extension mechanism that
            can completely alter your source code's layout and style. Core
            includes a very conservative set of extensions that take care to
            minimize the syntax changes. There are a number of third-party
            libraries that are much more ambitiousâ€”some introduce
            whitespace-sensitive indentation, while others build entirely new
            embedded languages using OCaml as a host language, and yet others
            introduce conditional compilation for macros or optional
            logging.</para>

            <para>While it's tempting to compress all your boiler-plate code
            into Camlp4 extensions, it can make your source code much harder
            for other people to quickly read and understand. Core mainly
            focuses on type-driven code generation using the
            <literal moreinfo="none">type_conv</literal> extension and doesn't fundamentally
            change the OCaml syntax.</para>

            <para>Another thing to consider before deploying your own syntax
            extension is compatibility with other extensions. Two separate
            extensions can create a grammar clash that leads to odd syntax
            errors and hard-to-reproduce bugs. That's why most of Core's
            syntax extensions go through <literal moreinfo="none">type_conv</literal>, which
            acts as a single point for extending the grammar via the
            <literal moreinfo="none">with</literal> keyword.</para>
          </caution>
        </sect2>

        <sect2 id="further-reading-on-camlp4">
          <title>Further reading on Camlp4</title>

          <para>We've deliberately only shown you how to use Camlp4 extensions
          here, and not how to build your own. The full details of building
          new extensions are fairly daunting and could be the subject of an
          entirely new book.</para>

          <para>The best resources to get started are:</para>

          <itemizedlist>
            <listitem>
              <para>a series of <ulink url="http://ambassadortothecomputers.blogspot.co.uk/p/reading-camlp4.html">blog
              posts</ulink> by Jake Donham describe the internals of Camlp4
              and its syntax extension mechanism.</para>
            </listitem>

            <listitem>
              <para>the online <ulink url="http://brion.inria.fr/gallium/index.php/Camlp4">Camlp4
              wiki</ulink>.</para>
            </listitem>

            <listitem>
              <para>using OPAM to install existing Camlp4 extensions and
              inspecting their source code.</para>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>

      <sect1 id="static-type-checking">
        <title>Static type checking</title>

        <para>After obtaining a valid abstract syntax tree, the compiler has
        to verify that the code obeys the rules of the OCaml type system. Code
        that is syntactically correct but misuses values is rejected with an
        explanation of the problem.</para>

        <para>Although type checking is done in a single pass in OCaml, it
        actually consists of three distinct steps that happen
        simultaneously:</para>

        <itemizedlist>
          <listitem>
            <para>an <emphasis>automatic type inference</emphasis> algorithm
            that calculates types for a module without requiring manual type
            annotations.</para>
          </listitem>

          <listitem>
            <para>a <emphasis>module system</emphasis> that combines software
            components with explicit knowledge of their type
            signatures.</para>
          </listitem>

          <listitem>
            <para><emphasis>explicit subtyping</emphasis> checks for objects
            and polymorphic variants.</para>
          </listitem>
        </itemizedlist>

        <para>Automatic type inference lets you write succinct code for a
        particular task and have the compiler ensure that your use of
        variables is locally consistent.</para>

        <para>Type inference doesn't scale to very large code bases that
        depend on separate compilation of files. A small change in one module
        may ripple through thousands of other files and libraries and require
        all of them to be recompiled. The module system solves this by
        providing the facility to combine and manipulate explicit type
        signatures for modules within a large project, and also to reuse them
        via functors and first-class modules.</para>

        <para>Subtyping in OCaml objects is always an explicit operation (via
        the <literal moreinfo="none">:&gt;</literal> operator). This means that it doesn't
        complicate the core type inference engine and can be tested as a
        separate concern.</para>

        <sect2 id="displaying-inferred-types-from-the-compiler">
          <title>Displaying inferred types from the compiler</title>

          <para>We've already seen how you can explore type inference directly
          from the top-level. It's also possible to generate type signatures
          for an entire file by asking the compiler to do the work for you.
          Create a file with a single type definition and value.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">front-end/typedef.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">type t = Foo | Bar
let v = Foo</programlisting>

          <para>Now run the compiler with the <literal moreinfo="none">-i</literal> flag to
          infer the type signature for that file. This runs the type checker
          but doesn't compile the code any further after displaying the
          interface to the standard output.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/infer_typedef.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -i typedef.ml</userinput>
<computeroutput moreinfo="none">type t = Foo | Bar</computeroutput>
<computeroutput moreinfo="none">val v : t</computeroutput></programlisting>

          <para>The output is the default signature for the module which
          represents the input file. It's often useful to redirect this output
          to an <literal moreinfo="none">mli</literal> file to give you a starting signature
          to edit the external interface without having to type it all in by
          hand.</para>

          <para>The compiler stores a compiled version of the interface as a
          <literal moreinfo="none">cmi</literal> file. This interface is either obtained from
          compiling an <literal moreinfo="none">mli</literal> signature file for a module, or
          by the inferred type if there is only an <literal moreinfo="none">ml</literal>
          implementation present.</para>

          <para>The compiler makes sure that your <literal moreinfo="none">ml</literal> and
          <literal moreinfo="none">mli</literal> files have compatible signatures. The type
          checker throws an immediate error if this isn't the case.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/conflicting_interfaces.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">echo type t = Foo &gt; test.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">echo type t = Bar &gt; test.mli</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c test.mli test.ml</userinput>
<computeroutput moreinfo="none">File "test.ml", line 1:</computeroutput>
<computeroutput moreinfo="none">Error: The implementation test.ml does not match the interface test.cmi:</computeroutput>
<computeroutput moreinfo="none">       Type declarations do not match:</computeroutput>
<computeroutput moreinfo="none">         type t = Foo</computeroutput>
<computeroutput moreinfo="none">       is not included in</computeroutput>
<computeroutput moreinfo="none">         type t = Bar</computeroutput>
<computeroutput moreinfo="none">       File "test.ml", line 1, characters 5-12: Actual declaration</computeroutput>
<computeroutput moreinfo="none">       Fields number 1 have different names, Foo and Bar.</computeroutput></programlisting>

          <note>
            <title>Which comes first: the <literal moreinfo="none">ml</literal> or the
            <literal moreinfo="none">mli</literal>?</title>

            <para>There are two schools of thought on which order OCaml code
            should be written in. It's very easy to begin writing code by
            starting with an <literal moreinfo="none">ml</literal> file and using the type
            inference to guide you as you build up your functions. The
            <literal moreinfo="none">mli</literal> file can then be generated as described
            above, and the exported functions documented.</para>

            <para>If you're writing code that spans multiple files, it's
            sometimes easier to start by writing all the
            <literal moreinfo="none">mli</literal> signatures and checking that they type
            check against each other. Once the signatures are in place, you
            can write the implementations with the confidence that they'll all
            glue together correctly with no cyclic dependencies between the
            modules.</para>

            <para>As with any such stylistic debate, you should experiment
            with which system works best for you. Everyone agrees on one thing
            though: no matter what order you write them, production code
            should always explicitly define an <literal moreinfo="none">mli</literal> file for
            every <literal moreinfo="none">ml</literal> file in the project. It's also
            perfectly fine to have an <literal moreinfo="none">mli</literal> file without a
            corresponding <literal moreinfo="none">ml</literal> file if you're only declaring
            signatures (such as module types).</para>

            <para>Signature files provide a place to write succinct
            documentation and to abstract internal details that shouldn't be
            exported. Maintaining separate signature files also speeds up
            incremental compilation in larger code-bases, since recompiling a
            <literal moreinfo="none">mli</literal> signature is much faster than a full
            compilation of the implementation to native code.</para>
          </note>
        </sect2>

        <sect2 id="type-inference-1">
          <title>Type inference</title>

          <para>Type inference is the process of determining the appropriate
          types for expressions based on their use. It's a feature that's
          partially present in many other languages such as Haskell and Scala,
          but OCaml embeds it as a fundamental feature throughout the core
          language.</para>

          <para>OCaml type inference is based on the Hindley-Milner algorithm,
          which is notable for its ability to infer the most general type for
          an expression without requiring any explicit type annotations. The
          algorithm can deduce multiple types for an expression, and has the
          notion of a <emphasis>principal type</emphasis> that is the most
          general choice from the possible inferences. Manual type annotations
          can specialize the type explicitly, but the automatic inference
          selects the most general type unless told otherwise.</para>

          <para>OCaml does have some language extensions which strain the
          limits of principal type inference, but by and large most programs
          you write will never <emphasis>require</emphasis> annotations
          (although they sometimes help the compiler produce better error
          messages).</para>

          <sect3 id="adding-type-annotations-to-find-errors">
            <title>Adding type annotations to find errors</title>

            <para>It's often said that the hardest part of writing OCaml code
            is getting past the type checkerâ€”but once the code does compile,
            it works correctly the first time! This is an exaggeration of
            course, but it can certainly feel true when moving from a
            dynamically typed language. The OCaml static type system protects
            you from certain classes of bugs such as memory errors and
            abstraction violations by rejecting your program at compilation
            time rather than by generating an error at runtime. Learning how
            to navigate the type checker's compile-time feedback is key to
            building robust libraries and applications that take full
            advantage of these static checks.</para>

            <para>There are a couple of tricks to make it easier to quickly
            locate type errors in your code. The first is to introduce manual
            type annotations to narrow down the source of your error more
            accurately. These annotations shouldn't actually change your types
            and can be removed once your code is correct. However, they act as
            anchors to locate errors while you're still writing your
            code.</para>

            <para>Manual type annotations are particularly useful if you use
            lots of polymorphic variants or objects. Type inference with row
            polymorphism can generate some very large signatures, and errors
            tend to propagate more widely than if you are using more
            explicitly typed variants or classes.</para>

            <para>For instance, consider this broken example that expresses
            some simple algebraic operations over integers.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/broken_poly.ml</filename></para>

            <programlisting language="ocaml" format="linespecific">let rec algebra =
  function
  | `Add (x,y) -&gt; (algebra x) + (algebra y)
  | `Sub (x,y) -&gt; (algebra x) - (algebra y)
  | `Mul (x,y) -&gt; (algebra x) * (algebra y)
  | `Num x     -&gt; x

let _ =
  algebra (
    `Add (
      (`Num 0),
      (`Sub (
          (`Num 1),
          (`Mul (
              (`Nu 3),(`Num 2)
            ))
        ))
    ))</programlisting>

            <para>There's a single character typo in the code so that it uses
            <literal moreinfo="none">Nu</literal> instead of <literal moreinfo="none">Num</literal>. The
            resulting type error is impressive.</para>

            <para role="sourcecode">Terminal:
            <filename moreinfo="none">front-end/build_broken_poly.out</filename></para>

            <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c broken_poly.ml</userinput>
<computeroutput moreinfo="none">File "broken_poly.ml", line 9, characters 10-154:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type</computeroutput>
<computeroutput moreinfo="none">         [&gt; `Add of</computeroutput>
<computeroutput moreinfo="none">              ([&lt; `Add of 'a * 'a</computeroutput>
<computeroutput moreinfo="none">                | `Mul of 'a * 'a</computeroutput>
<computeroutput moreinfo="none">                | `Num of int</computeroutput>
<computeroutput moreinfo="none">                | `Sub of 'a * 'a</computeroutput>
<computeroutput moreinfo="none">                &gt; `Num ]</computeroutput>
<computeroutput moreinfo="none">               as 'a) *</computeroutput>
<computeroutput moreinfo="none">              [&gt; `Sub of 'a * [&gt; `Mul of [&gt; `Nu of int ] * [&gt; `Num of int ] ] ] ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type 'a</computeroutput>
<computeroutput moreinfo="none">       The second variant type does not allow tag(s) `Nu</computeroutput></programlisting>

            <para>The type error is perfectly accurate, but rather verbose and
            with a line number that doesn't point to the exact location of the
            incorrect variant name. The best the compiler can do is to point
            you in the general direction of the <literal moreinfo="none">algebra</literal>
            function application.</para>

            <para>This is because the type checker doesn't have enough
            information to match the inferred type of the
            <literal moreinfo="none">algebra</literal> definition to its application a few
            lines down. It calculates types for both expressions separately,
            and when they don't match up, outputs the difference as best it
            can.</para>

            <para>Let's see what happens with an explicit type annotation to
            help the compiler out.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/broken_poly_with_annot.ml</filename></para>

            <programlisting language="ocaml" format="linespecific">type t = [
  | `Add of t * t
  | `Sub of t * t
  | `Mul of t * t
  | `Num of int
]

let rec algebra (x:t) =
  match x with
  | `Add (x,y) -&gt; (algebra x) + (algebra y)
  | `Sub (x,y) -&gt; (algebra x) - (algebra y)
  | `Mul (x,y) -&gt; (algebra x) * (algebra y)
  | `Num x     -&gt; x

let _ =
  algebra (
    `Add (
      (`Num 0),
      (`Sub (
          (`Num 1),
          (`Mul (
              (`Nu 3),(`Num 2)
            ))
        ))
    ))</programlisting>

            <para>This code contains exactly the same error as before, but
            we've added a closed type definition of the polymorphic variants,
            and a type annotation to the <literal moreinfo="none">algebra</literal>
            definition. The compiler error we get is much more useful
            now.</para>

            <para role="sourcecode">Terminal:
            <filename moreinfo="none">front-end/build_broken_poly_with_annot.out</filename></para>

            <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -i broken_poly_with_annot.ml</userinput>
<computeroutput moreinfo="none">File "broken_poly_with_annot.ml", line 22, characters 14-21:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type [&gt; `Nu of int ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type t</computeroutput>
<computeroutput moreinfo="none">       The second variant type does not allow tag(s) `Nu</computeroutput></programlisting>

            <para>This error points directly to the correct line number that
            contains the typo. Once you fix the problem, you can remove the
            manual annotations if you prefer more succinct code. You can also
            leave the annotations there of course, to help with future
            refactoring and debugging.</para>
          </sect3>

          <sect3 id="enforcing-principal-typing">
            <title>Enforcing principal typing</title>

            <para>The compiler also has a stricter <emphasis>principal type
            checking</emphasis> mode that is activated via the
            <literal moreinfo="none">-principal</literal> flag. This warns about risky uses of
            type information to ensure that the type inference has one
            principal result. A type is considered risky if the success or
            failure of type inference depends on the order in which
            sub-expressions are typed.</para>

            <para>The principality check only affects a few language
            features:</para>

            <itemizedlist>
              <listitem>
                <para>polymorphic methods for objects.</para>
              </listitem>

              <listitem>
                <para>permuting the order of labeled arguments in a function
                from their type definition.</para>
              </listitem>

              <listitem>
                <para>discarding optional labeled arguments.</para>
              </listitem>

              <listitem>
                <para>generalized algebraic data types (GADTs) present from
                OCaml 4.0 onwards.</para>
              </listitem>

              <listitem>
                <para>automatic disambiguation of record field and constructor
                names (since OCaml 4.1)</para>
              </listitem>
            </itemizedlist>

            <para>Here's an example of principality warnings when used with
            record disambiguation.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/non_principal.ml</filename></para>

            <programlisting language="ocaml" format="linespecific">type s = { foo: int; bar: unit }
type t = { foo: int }

let f x =
  x.bar;
  x.foo</programlisting>

            <para>Inferring the signature with <literal moreinfo="none">-principal</literal>
            will show you a new warning.</para>

            <para role="sourcecode">Terminal:
            <filename moreinfo="none">front-end/build_non_principal.out</filename></para>

            <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -i -principal non_principal.ml</userinput>
<computeroutput moreinfo="none">File "non_principal.ml", line 6, characters 4-7:</computeroutput>
<computeroutput moreinfo="none">Warning 18: this type-based field disambiguation is not principal.</computeroutput>
<computeroutput moreinfo="none">type s = { foo : int; bar : unit; }</computeroutput>
<computeroutput moreinfo="none">type t = { foo : int; }</computeroutput>
<computeroutput moreinfo="none">val f : s -&gt; int</computeroutput></programlisting>

            <para>This example isn't principal since the inferred type for
            <literal moreinfo="none">x.foo</literal> is guided by the inferred type of
            <literal moreinfo="none">x.bar</literal>, whereas principal typing requires that
            each sub-expression's type can be calculated independently. If the
            <literal moreinfo="none">x.bar</literal> use is removed from the definition of
            <literal moreinfo="none">f</literal>, its argument would be of type
            <literal moreinfo="none">t</literal> and not <literal moreinfo="none">type s</literal>.</para>

            <para>You can fix this either by permuting the order of the type
            declarations, or by adding an explicit type annotation.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/principal.ml</filename></para>

            <programlisting language="ocaml" format="linespecific">type s = { foo: int; bar: unit }
type t = { foo: int }

let f (x:s) =
  x.bar;
  x.foo</programlisting>

            <para>There is now no ambiguity about the inferred types, since
            we've explicitly given the argument a type and the order of
            inference of the sub-expressions no longer matters.</para>

            <para role="sourcecode">Terminal:
            <filename moreinfo="none">front-end/build_principal.out</filename></para>

            <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -i -principal principal.ml</userinput>
<computeroutput moreinfo="none">type s = { foo : int; bar : unit; }</computeroutput>
<computeroutput moreinfo="none">type t = { foo : int; }</computeroutput>
<computeroutput moreinfo="none">val f : s -&gt; int</computeroutput></programlisting>

            <para>The <command moreinfo="none">ocamlbuild</command> equivalent is to add the
            tag <literal moreinfo="none">principal</literal> to your build. The
            <literal moreinfo="none">corebuild</literal> wrapper script actually adds this by
            default, but it does no harm to explicitly repeat it, as
            below.</para>

            <para role="sourcecode">Terminal:
            <filename moreinfo="none">principal/build_principal.out</filename></para>

            <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -tag principal principal.cmi non_principal.cmi</userinput>
<computeroutput moreinfo="none">File "non_principal.ml", line 6, characters 4-7:</computeroutput>
<computeroutput moreinfo="none">Warning 18: this type-based field disambiguation is not principal.</computeroutput></programlisting>

            <para>Ideally, all code should systematically use
            <literal moreinfo="none">-principal</literal>. It reduces variance in type
            inference and enforces the notion of a single known type. However,
            there are drawbacks to this mode: type inference is slower and the
            <literal moreinfo="none">cmi</literal> files become larger. This is generally only
            a problem if you use objects extensively, which usually have
            larger type signature to cover all their methods.</para>

            <para>If compiling in principal mode works, it is guaranteed that
            the program will pass type checking in non-principal mode too. For
            this reason, the <command moreinfo="none">corebuild</command> wrapper script
            activates principal mode by default, preferring stricter type
            inference over a small loss in compilation speed and extra disk
            space usage.</para>

            <para>Bear in mind that the <literal moreinfo="none">cmi</literal> files generated
            in principal mode differ from the default mode. Try to ensure that
            you compile your whole project with it activated. Getting the
            files mixed up won't let you violate type safety, but can result
            in the type checker failing unexpectedly very occasionally. In
            this case, just recompile with a clean source tree.</para>
          </sect3>
        </sect2>

        <sect2 id="modules-and-separate-compilation">
          <title>Modules and separate compilation</title>

          <para>The OCaml module system enables smaller components to be
          reused effectively in large projects while still retaining all the
          benefits of static type safety. We covered the basics of using
          modules earlier in <xref linkend="files-modules-and-programs"/>.
          The module language that operates over these signatures also extends
          to functors and first-class modules, described in <xref linkend="functors"/> and <xref linkend="first-class-modules"/>
          respectively.</para>

          <para>This section discusses how the compiler implements them in
          more detail. Modules are essential for larger projects that consist
          of many source files (also known as <emphasis>compilation
          units</emphasis>). It's impractical to recompile every single source
          file when changing just one or two files, and the module system
          minimizes such recompilation while still encouraging code
          reuse.</para>

          <sect3 id="the-mapping-between-files-and-modules">
            <title>The mapping between files and modules</title>

            <para>Individual compilation units provide a convenient way to
            break up a big module hierarchy into a collection of files. The
            relationship between files and modules can be explained directly
            in terms of the module system.</para>

            <para>Create a file called <literal moreinfo="none">alice.ml</literal> with the
            following contents.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/alice.ml</filename></para>

            <programlisting language="ocaml" format="linespecific">let friends = [ Bob.name ]</programlisting>

            <para>and a corresponding signature file.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/alice.mli</filename></para>

            <programlisting language="ocaml" format="linespecific">val friends : Bob.t list</programlisting>

            <para>These two files are exactly analogous to including the
            following code directly in another module that references
            <literal moreinfo="none">Alice</literal>.</para>

            <para role="sourcecode">OCaml:
            <filename moreinfo="none">front-end/alice_combined.ml</filename></para>

            <programlisting language="ocaml" format="linespecific">module Alice : sig
  val friends : Bob.t list
end = struct
  let friends = [ Bob.name ]
end</programlisting>
          </sect3>

          <sect3 id="defining-a-module-search-path">
            <title>Defining a module search path</title>

            <para>In the example above, <literal moreinfo="none">Alice</literal> also has a
            reference to another module <literal moreinfo="none">Bob</literal>. For the
            overall type of <literal moreinfo="none">Alice</literal> to be valid, the compiler
            also needs to check that the <literal moreinfo="none">Bob</literal> module
            contains at least a <literal moreinfo="none">Bob.name</literal> value and defines
            a <literal moreinfo="none">Bob.t</literal> type.</para>

            <para>The type checker resolves such module references into
            concrete structures and signatures in order to unify types across
            module boundaries. It does this by searching a list of directories
            for a compiled interface file matching that module's name. For
            example, it will look for <literal moreinfo="none">alice.cmi</literal> and
            <literal moreinfo="none">bob.cmi</literal> on the search path, and use the first
            ones it encounters as the interfaces for <literal moreinfo="none">Alice</literal>
            and <literal moreinfo="none">Bob</literal>.</para>

            <para>The module search path is set by adding
            <literal moreinfo="none">-I</literal> flags to the compiler command-line with the
            directory containing the <literal moreinfo="none">cmi</literal> files as the
            argument. Manually specifying these flags gets complex when you
            have lots of libraries, and is the reason why the OCamlfind
            frontend to the compiler exists. OCamlfind automates the process
            of turning third-party package names and build descriptions into
            command-line flags that are passed to the compiler
            command-line.</para>

            <para>By default, only the current directory and the OCaml
            standard library will be searched for <literal moreinfo="none">cmi</literal>
            files. The <literal moreinfo="none">Pervasives</literal> module from the standard
            library will also be opened by default in every compilation unit.
            The standard library location is obtained by running
            <literal moreinfo="none">ocamlc -where</literal>, and can be overridden by setting
            the <literal moreinfo="none">CAMLLIB</literal> environment variable. Needless to
            say, don't override the default path unless you have a good reason
            to (such as setting up a cross-compilation environment).</para>

            <sidebar>
              <title>Inspecting compilation units with
              <literal moreinfo="none">ocamlobjinfo</literal></title>

              <para>For separate compilation to be sound, we need to ensure
              that all the <literal moreinfo="none">cmi</literal> files used to type-check a
              module are the same across compilation runs. If they vary, this
              raises the possibility of two modules checking different type
              signatures for a common module with the same name. This in turn
              lets the program completely violate the static type system and
              can lead to memory corruption and crashes.</para>

              <para>OCaml guards against this by recording a MD5 checksum in
              every <literal moreinfo="none">cmi</literal>. Let's examine our earlier
              <literal moreinfo="none">typedef.ml</literal> more closely.</para>

              <para role="sourcecode">Terminal:
              <filename moreinfo="none">front-end/typedef_objinfo.out</filename></para>

              <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c typedef.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlobjinfo typedef.cmi</userinput>
<computeroutput moreinfo="none">File typedef.cmi</computeroutput>
<computeroutput moreinfo="none">Unit name: Typedef</computeroutput>
<computeroutput moreinfo="none">Interfaces imported:</computeroutput>
<computeroutput moreinfo="none">	bd274dc132ce5c3d8b6774d19cd373a6	Typedef</computeroutput>
<computeroutput moreinfo="none">	36b5bc8227dc9914c6d9fd9bdcfadb45	Pervasives</computeroutput></programlisting>

              <para><literal moreinfo="none">ocamlobjinfo</literal> examines the compiled
              interface and displays what other compilation units it depends
              on. In this case, we don't use any external modules other than
              <literal moreinfo="none">Pervasives</literal>. Every module depends on
              <literal moreinfo="none">Pervasives</literal> by default, unless you use the
              <literal moreinfo="none">-nopervasives</literal> flag (this is an advanced
              use-case, and you shouldn't normally need it).</para>

              <para>The long alphanumeric identifier beside each module name
              is a hash calculated from all the types and values exported from
              that compilation unit. It's used during type-checking and
              linking to ensure that all of the compilation units have been
              compiled consistently against each other. A difference in the
              hashes means that a compilation unit with the same module name
              may have conflicting type signatures in different modules. The
              compiler will reject such programs with an error similar to
              this:</para>

              <para role="sourcecode">Terminal:
              <filename moreinfo="none">front-end/inconsistent_compilation_units.out</filename></para>

              <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c foo.ml</userinput>
<computeroutput moreinfo="none">File "foo.ml", line 1, characters 0-1:</computeroutput>
<computeroutput moreinfo="none">Error: The files /home/build/bar.cmi</computeroutput>
<computeroutput moreinfo="none">       and /usr/lib/ocaml/map.cmi make inconsistent assumptions</computeroutput>
<computeroutput moreinfo="none">       over interface Map</computeroutput></programlisting>

              <para>This hash check is very conservative, but ensures that
              separate compilation remains type-safe all the way up to the
              final link phase. Your build system should ensure that you never
              see the error messages above, but if you do run into it, just
              clean out your intermediate files and recompile from
              scratch.</para>
            </sidebar>
          </sect3>
        </sect2>

        <sect2 id="packing-modules-together">
          <title>Packing modules together</title>

          <para>The module-to-file mapping described so far rigidly enforces a
          1:1 mapping between a top-level module and a file. It's often
          convenient to split larger modules into separate files to make
          editing and version control easier, but still compile them all into
          a single OCaml module.</para>

          <para>The <literal moreinfo="none">-pack</literal> compiler option accepts a list of
          compiled object files (<literal moreinfo="none">.cmo</literal> in bytecode and
          <literal moreinfo="none">.cmx</literal> for native code) and their associated
          <literal moreinfo="none">.cmi</literal> compiled interfaces, and combines them into
          a single module that contains them as sub-modules of the output.
          Packing thus generates an entirely new <literal moreinfo="none">.cmo</literal> (or
          <literal moreinfo="none">.cmx</literal> file) and <literal moreinfo="none">.cmi</literal> that
          includes the input modules.</para>

          <para>Packing for native code introduces an additional requirement:
          the modules that are intended to be packed must be compiled with the
          <literal moreinfo="none">-for-pack</literal> argument that specifies the eventual
          name of the pack. The easiest way to handle packing is to let
          <command moreinfo="none">ocamlbuild</command> figure out the command-line arguments
          for you, so let's try that out next with a simple example.</para>

          <para>First, create a couple of toy modules called
          <literal moreinfo="none">A.ml</literal> and <literal moreinfo="none">B.ml</literal> that contain a
          single value. You will also need a <literal moreinfo="none">_tags</literal> file
          that adds the <literal moreinfo="none">-for-pack</literal> option for the
          <literal moreinfo="none">cmx</literal> files (but careful to exclude the pack target
          itself). Finally, the <literal moreinfo="none">X.mlpack</literal> file contains the
          list of modules that are intended to be packed under module
          <literal moreinfo="none">X</literal>. There are special rules in
          <command moreinfo="none">ocamlbuild</command> that tell it how to map
          <literal moreinfo="none">%.mlpack</literal> files to the packed
          <literal moreinfo="none">%.cmx</literal> or <literal moreinfo="none">%.cmo</literal>
          equivalent.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">packing/show_files.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat A.ml</userinput>
<computeroutput moreinfo="none">let v = "hello"</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat B.ml</userinput>
<computeroutput moreinfo="none">let w = 42</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat _tags</userinput>
<computeroutput moreinfo="none">&lt;*.cmx&gt; and not "X.cmx": for-pack(X)</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat X.mlpack</userinput>
<computeroutput moreinfo="none">A</computeroutput>
<computeroutput moreinfo="none">B</computeroutput></programlisting>

          <para>You can now run <literal moreinfo="none">corebuild</literal> to build the
          <literal moreinfo="none">X.cmx</literal> file directly, but let's create a new
          module to link against <literal moreinfo="none">X</literal> to complete the
          example.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">packing/test.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">let v = X.A.v
let w = X.B.w</programlisting>

          <para>You can now compile this test module and see that its inferred
          interface is the result of using the packed contents of
          <literal moreinfo="none">X</literal>. We further verify this by examining the
          imported interfaces in <literal moreinfo="none">Test</literal> and confirming that
          neither <literal moreinfo="none">A</literal> nor <literal moreinfo="none">B</literal> are mentioned
          in there and that only the packed <literal moreinfo="none">X</literal> module is
          used.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">packing/build_test.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild test.inferred.mli test.cmi</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat _build/test.inferred.mli</userinput>
<computeroutput moreinfo="none">val v : string</computeroutput>
<computeroutput moreinfo="none">val w : int</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlobjinfo _build/test.cmi</userinput>
<computeroutput moreinfo="none">File _build/test.cmi</computeroutput>
<computeroutput moreinfo="none">Unit name: Test</computeroutput>
<computeroutput moreinfo="none">Interfaces imported:</computeroutput>
<computeroutput moreinfo="none">	906fc1b74451f0c24ceaa085e0f26e5f	Test</computeroutput>
<computeroutput moreinfo="none">	36b5bc8227dc9914c6d9fd9bdcfadb45	Pervasives</computeroutput>
<computeroutput moreinfo="none">	25f4b4e10ec64c56b2987f5900045fec	X</computeroutput></programlisting>

          <warning>
            <title>Packing and search paths</title>

            <para>One very common build error that happens with packing is
            confusion resulting from building the packed
            <literal moreinfo="none">cmi</literal> in the same directory as the sub-modules.
            When you add this directory to your module search path, the
            sub-modules are also visible. If you forget to include the
            top-level prefix (e.g <literal moreinfo="none">X.A</literal>) and instead use a
            sub-module directly (<literal moreinfo="none">A</literal>), then this will compile
            and link fine.</para>

            <para>However, the types of <literal moreinfo="none">A</literal> and
            <literal moreinfo="none">X.A</literal> are <emphasis>not</emphasis> automatically
            equivalent, and so the type checker will complain if you attempt
            to mix-and-match the packed and unpacked versions of the
            library.</para>

            <para>This mostly only happens with unit tests since they are
            built at the same time as the library. You can avoid it by being
            aware of the need to open the packed module from the test, or only
            using the library after it has been installed (and hence not
            exposing the intermediate compiled modules).</para>
          </warning>
        </sect2>

        <sect2 id="shorter-module-paths-in-type-errors">
          <title>Shorter module paths in type errors</title>

          <para>Core uses the OCaml module system quite extensively to provide
          a complete replacement standard library. It collects these modules
          into a single <literal moreinfo="none">Std</literal> module which provides a single
          module that needs to be opened to import the replacement modules and
          functions.</para>

          <para>There's one downside to this approach: type errors suddenly
          get much more verbose. We can see this if you run the vanilla OCaml
          top-level (not <command moreinfo="none">utop</command>).</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/short_paths_1.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocaml</userinput>
<computeroutput moreinfo="none"># List.map print_endline "" ;;</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         string list</computeroutput></programlisting>

          <para>This type error without <literal moreinfo="none">Core.Std</literal> has a
          straightforward type error. When we switch to Core, though, it gets
          more verbose.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/short_paths_2.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocaml</userinput>
<computeroutput moreinfo="none"># open Core.Std ;;</computeroutput>
<computeroutput moreinfo="none"># List.map ~f:print_endline "" ;;</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         'a Core.Std.List.t = 'a list</computeroutput></programlisting>

          <para>The default <literal moreinfo="none">List</literal> module in OCaml is
          overridden by <literal moreinfo="none">Core.Std.List</literal>. The compiler does
          its best to show the type equivalence, but at the cost of a more
          verbose error message.</para>

          <para>The compiler can remedy this via a so-called "short paths"
          heuristic. This causes the compiler to search all the type aliases
          for the shortest module path, and use that as the preferred output
          type. The option is activated by passing
          <literal moreinfo="none">-short-paths</literal> to the compiler, and works on the
          top-level too.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/short_paths_3.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocaml -short-paths</userinput>
<computeroutput moreinfo="none"># open Core.Std;;</computeroutput>
<computeroutput moreinfo="none"># List.map ~f:print_endline "foo";;</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         'a list</computeroutput></programlisting>

          <para>The <command moreinfo="none">utop</command> enhanced top-level activates short
          paths by default, which is why you've not had to do this before in
          our interactive examples. However, the compiler doesn't default to
          the short path heuristic since there are some situations where the
          type aliasing information is useful to know, and would be lost in
          the error if the shortest module path is always picked.</para>

          <para>You'll need to choose for yourself if you prefer short paths
          or the default behavior in your own projects, and pass the
          <literal moreinfo="none">-short-paths</literal> flag to the compiler if you need
          it.</para>
        </sect2>
      </sect1>

      <sect1 id="the-typed-syntax-tree">
        <title>The typed syntax tree</title>

        <para>When the type checking process has successfully completed, it is
        combined with the AST to form a <emphasis>typed abstract syntax
        tree</emphasis>. This contains precise location information for every
        token in the input file, and decorates each token with concrete type
        information.</para>

        <para>The compiler can output this as compiled <literal moreinfo="none">cmt</literal>
        and <literal moreinfo="none">cmti</literal> files that contain the typed AST for the
        implementation and signatures of a compilation unit. This is activated
        by passing the <literal moreinfo="none">-bin-annot</literal> flag to the
        compiler.</para>

        <para>The <literal moreinfo="none">cmt</literal> files are particularly useful for IDE
        tools to match up OCaml source code at a specific location to the
        inferred or external types.</para>

        <sect2 id="using-ocp-index-for-auto-completion">
          <title>Using ocp-index for auto-completion</title>

          <para>One such command-line tool to display auto-completion
          information in your editor is <command moreinfo="none">ocp-index</command>. Install
          it via OPAM as follows.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/install_ocp_index.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam install ocp-index</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-index</userinput></programlisting>

          <para>Let's refer back to our Ncurses binding example from the
          beginning of <xref linkend="foreign-function-interface"/>. This
          module defined bindings for the Ncurses library. First, compile the
          interfaces with <literal moreinfo="none">-bin-annot</literal> so that we can obtain
          the <literal moreinfo="none">cmt</literal> and <literal moreinfo="none">cmti</literal> files, and
          then run <command moreinfo="none">ocp-index</command> in completion mode.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">ocp-index/index_ncurses.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg ctypes.foreign -tag bin_annot ncurses.cmi</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-index complete -I . Ncur</userinput>
<computeroutput moreinfo="none">Ncurses module</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-index complete -I . Ncurses.a</userinput>
<computeroutput moreinfo="none">Ncurses.addstr val string -&gt; unit</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-index complete -I . Ncurses.</userinput>
<computeroutput moreinfo="none">Ncurses.window val Ncurses.window Ctypes.typ</computeroutput>
<computeroutput moreinfo="none">Ncurses.wrefresh val Ncurses.window -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.initscr val unit -&gt; Ncurses.window</computeroutput>
<computeroutput moreinfo="none">Ncurses.endwin val unit -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.refresh val unit -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.newwin val int -&gt; int -&gt; int -&gt; int -&gt; Ncurses.window</computeroutput>
<computeroutput moreinfo="none">Ncurses.mvwaddch val Ncurses.window -&gt; int -&gt; int -&gt; char -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.mvwaddstr val Ncurses.window -&gt; int -&gt; int -&gt; string -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.addstr val string -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.box val Ncurses.window -&gt; char -&gt; char -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.cbreak val unit -&gt; int</computeroutput></programlisting>

          <para>You need to pass <command moreinfo="none">ocp-index</command> a set of
          directories to search for <literal moreinfo="none">cmt</literal> files in, and a
          fragment of text to autocomplete. As you can imagine, autocompletion
          is invaluable on larger codebases. See the <ulink url="https://github.com/ocamlpro/ocp-index">ocp-index</ulink>
          homepage for more information on how to integrate it with your
          favorite editor.</para>
        </sect2>

        <sect2 id="examining-the-typed-syntax-tree-directly">
          <title>Examining the typed syntax tree directly</title>

          <para>The compiler has a couple of advanced flags that can dump the
          raw output of the internal AST representation. You can't depend on
          these flags to give the same output across compiler revisions, but
          they are a useful learning tool.</para>

          <para>We'll use our toy <literal moreinfo="none">typedef.ml</literal> again.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">front-end/typedef.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">type t = Foo | Bar
let v = Foo</programlisting>

          <para>Let's first look at the untyped syntax tree that's generated
          from the parsing phase.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/parsetree_typedef.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -dparsetree typedef.ml 2&gt;&amp;1</userinput>
<computeroutput moreinfo="none">[</computeroutput>
<computeroutput moreinfo="none">  structure_item (typedef.ml[1,0+0]..[1,0+18])</computeroutput>
<computeroutput moreinfo="none">    Pstr_type</computeroutput>
<computeroutput moreinfo="none">    [</computeroutput>
<computeroutput moreinfo="none">      "t" (typedef.ml[1,0+5]..[1,0+6])</computeroutput>
<computeroutput moreinfo="none">        type_declaration (typedef.ml[1,0+5]..[1,0+18])</computeroutput>
<computeroutput moreinfo="none">          ptype_params =</computeroutput>
<computeroutput moreinfo="none">            []</computeroutput>
<computeroutput moreinfo="none">          ptype_cstrs =</computeroutput>
<computeroutput moreinfo="none">            []</computeroutput>
<computeroutput moreinfo="none">          ptype_kind =</computeroutput>
<computeroutput moreinfo="none">            Ptype_variant</computeroutput>
<computeroutput moreinfo="none">              [</computeroutput>
<computeroutput moreinfo="none">                (typedef.ml[1,0+9]..[1,0+12])</computeroutput>
<computeroutput moreinfo="none">                  "Foo" (typedef.ml[1,0+9]..[1,0+12])</computeroutput>
<computeroutput moreinfo="none">                  []</computeroutput>
<computeroutput moreinfo="none">                  None</computeroutput>
<computeroutput moreinfo="none">                (typedef.ml[1,0+15]..[1,0+18])</computeroutput>
<computeroutput moreinfo="none">                  "Bar" (typedef.ml[1,0+15]..[1,0+18])</computeroutput>
<computeroutput moreinfo="none">                  []</computeroutput>
<computeroutput moreinfo="none">                  None</computeroutput>
<computeroutput moreinfo="none">              ]</computeroutput>
<computeroutput moreinfo="none">          ptype_private = Public</computeroutput>
<computeroutput moreinfo="none">          ptype_manifest =</computeroutput>
<computeroutput moreinfo="none">            None</computeroutput>
<computeroutput moreinfo="none">    ]</computeroutput>
<computeroutput moreinfo="none">  structure_item (typedef.ml[2,19+0]..[2,19+11])</computeroutput>
<computeroutput moreinfo="none">    Pstr_value Nonrec</computeroutput>
<computeroutput moreinfo="none">    [</computeroutput>
<computeroutput moreinfo="none">      &lt;def&gt;</computeroutput>
<computeroutput moreinfo="none">        pattern (typedef.ml[2,19+4]..[2,19+5])</computeroutput>
<computeroutput moreinfo="none">          Ppat_var "v" (typedef.ml[2,19+4]..[2,19+5])</computeroutput>
<computeroutput moreinfo="none">        expression (typedef.ml[2,19+8]..[2,19+11])</computeroutput>
<computeroutput moreinfo="none">          Pexp_construct "Foo" (typedef.ml[2,19+8]..[2,19+11])</computeroutput>
<computeroutput moreinfo="none">          None</computeroutput>
<computeroutput moreinfo="none">          false</computeroutput>
<computeroutput moreinfo="none">    ]</computeroutput>
<computeroutput moreinfo="none">]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

          <para>This is rather a lot of output for a simple two-line program,
          but it shows just how much structure the OCaml parser generates even
          from a small source file.</para>

          <para>Each portion of the AST is decorated with the precise location
          information (including the filename and character location of the
          token). This code hasn't been type checked yet, and so the raw
          tokens are all included.</para>

          <para>The typed AST that is normally output as a compiled
          <literal moreinfo="none">cmt</literal> file can be displayed in a more
          developer-readable form via the <literal moreinfo="none">-dtypedtree</literal>
          option.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">front-end/typedtree_typedef.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -dtypedtree typedef.ml 2&gt;&amp;1</userinput>
<computeroutput moreinfo="none">[</computeroutput>
<computeroutput moreinfo="none">  structure_item (typedef.ml[1,0+0]..typedef.ml[1,0+18])</computeroutput>
<computeroutput moreinfo="none">    Pstr_type</computeroutput>
<computeroutput moreinfo="none">    [</computeroutput>
<computeroutput moreinfo="none">      t/1008</computeroutput>
<computeroutput moreinfo="none">        type_declaration (typedef.ml[1,0+5]..typedef.ml[1,0+18])</computeroutput>
<computeroutput moreinfo="none">          ptype_params =</computeroutput>
<computeroutput moreinfo="none">            []</computeroutput>
<computeroutput moreinfo="none">          ptype_cstrs =</computeroutput>
<computeroutput moreinfo="none">            []</computeroutput>
<computeroutput moreinfo="none">          ptype_kind =</computeroutput>
<computeroutput moreinfo="none">            Ptype_variant</computeroutput>
<computeroutput moreinfo="none">              [</computeroutput>
<computeroutput moreinfo="none">                "Foo/1009"</computeroutput>
<computeroutput moreinfo="none">                  []</computeroutput>
<computeroutput moreinfo="none">                "Bar/1010"</computeroutput>
<computeroutput moreinfo="none">                  []</computeroutput>
<computeroutput moreinfo="none">              ]</computeroutput>
<computeroutput moreinfo="none">          ptype_private = Public</computeroutput>
<computeroutput moreinfo="none">          ptype_manifest =</computeroutput>
<computeroutput moreinfo="none">            None</computeroutput>
<computeroutput moreinfo="none">    ]</computeroutput>
<computeroutput moreinfo="none">  structure_item (typedef.ml[2,19+0]..typedef.ml[2,19+11])</computeroutput>
<computeroutput moreinfo="none">    Pstr_value Nonrec</computeroutput>
<computeroutput moreinfo="none">    [</computeroutput>
<computeroutput moreinfo="none">      &lt;def&gt;</computeroutput>
<computeroutput moreinfo="none">        pattern (typedef.ml[2,19+4]..typedef.ml[2,19+5])</computeroutput>
<computeroutput moreinfo="none">          Ppat_var "v/1011"</computeroutput>
<computeroutput moreinfo="none">        expression (typedef.ml[2,19+8]..typedef.ml[2,19+11])</computeroutput>
<computeroutput moreinfo="none">          Pexp_construct "Foo"</computeroutput>
<computeroutput moreinfo="none">          []</computeroutput>
<computeroutput moreinfo="none">          false</computeroutput>
<computeroutput moreinfo="none">    ]</computeroutput>
<computeroutput moreinfo="none">]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

          <para>The typed AST is more explicit than the untyped syntax tree.
          For instance, the type declaration has been given a unique name
          (<literal moreinfo="none">t/1008</literal>), as has the <literal moreinfo="none">v</literal> value
          (<literal moreinfo="none">v/1011</literal>).</para>

          <para>You'll rarely need to look at this raw output from the
          compiler unless you're building IDE tools such as
          <command moreinfo="none">ocp-index</command>, or are hacking on extensions to the
          core compiler itself. However, it's useful to know that this
          intermediate form exists before we delve further into the code
          generation process next in <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.</para>
        </sect2>
      </sect1>
    </chapter>
