\labelchapter{expr1}{Simple Expressions}

Most functional programming implementations include a
runtime environment that defines a standard library and a garbage
collector.  They also often include an evaluator that can be used to
interact with the system, called a \emph{toploop}.  OCaml provides a compiler, a runtime, and a
toploop.  By default, the toploop is called \lstinline/ocaml/.  The toploop
prints a prompt (\hbox{\lstinline/#/}), reads an input expression, evaluates it,
and prints the result .  Expressions in the toploop are terminated by
a double-semicolon `\hbox{\lstinline/;;/}'.

\label{keyword:;;}

\begin{ocaml}
% ocaml
@
\begin{topoutput}
        Objective Caml version 3.10.0
\end{topoutput}
@
# 1 + 4;;
@
\begin{topoutput}
- : int = 5
\end{topoutput}
@
#
\end{ocaml}
%
The toploop prints the type of the result (in this case,
\hbox{\lstinline/int/}) and the value (\hbox{\lstinline/5/}).  To exit
the toploop, you may type the end-of-file character (usually Control-D
when using a Unix\footnote{UNIX is a registered trademark of The Open
  Group.} system, and Control-Z when using a Microsoft Windows system).

\labelsection{ocaml-doc-comments}{Comment convention}
\index{comments}

In OCaml, comments are enclosed in matching \verb+(*+ and \verb+*)+
pairs.  Comments may be nested, and the comment is treated
as white space.

\begin{ocaml}
# 1 (* this is a comment *) + 4;;
@
\begin{topoutput}
- : int = 5
\end{topoutput}
@
\end{ocaml}

\labelsection{ocaml-doc-expr1}{Basic expressions}

OCaml is a \emph{strongly typed} language.  In OCaml every valid
expression must have a type, and expressions of one type may not be
used as expressions in another type.  Apart from polymorphism, which
we discuss in Chapter~\refchapter{tuples}, there are no implicit
coercions.  Normally, you do not have to specify the types of
expressions.  OCaml uses \emph{type inference}~\cite{DM82} to figure
out the types for you.

The primitive types are \hbox{\lstinline/unit/}, \hbox{\lstinline/int/}, \hbox{\lstinline/char/}, \hbox{\lstinline/float/},
\hbox{\lstinline/bool/}, and \hbox{\lstinline/string/}.

\labelsubsection{ocaml-doc-expr-unit}{\texttt{unit}: the singleton type}
\index{unit type@\lstinline/unit/ type}

The simplest type in OCaml is the \texttt{unit} type, which contains one
element: \hbox{\lstinline/()/}.  This type seems to be a rather silly.  However,
in a functional language every function must return a value; \hbox{\lstinline/()/} is
commonly used as the value of a procedure that computes by
side-effect.  It corresponds to the type \hbox{\lstinline/void/} in C.

\labelsubsection{ocaml-doc-expr-int}{\texttt{int}: the integers}
\index{int type@\lstinline/int/ type}

The type \hbox{\lstinline/int/} is the type of signed integers:
$\ldots, -2, -1, 0, 1, 2, \ldots$ The precision is finite.  Integer
values are represented by a machine word, minus one bit that is
reserved for use by the runtime (for garbage collection), so on a 32-bit machine
architecture, the precision is 31 bits, and on a 64-bit architecture,
the precision is 63 bits.

\label{literal:integer}
Integers are usually specified in decimal, but there are several
alternate forms.  In the following table the symbol $d$ denotes a
decimal digit (`\hbox{\lstinline/0/}'..`\hbox{\lstinline/9/}'); $o$ denotes an octal digit
(`\hbox{\lstinline/0/}'..`\hbox{\lstinline/7/}'); $b$ denotes a binary digit (`\hbox{\lstinline/0/}' or
`\hbox{\lstinline/1/}'); and $h$ denotes a hexadecimal digit
(`\hbox{\lstinline/0/}'..`\hbox{\lstinline/9/}', or `\hbox{\lstinline/a/}'..`\hbox{\lstinline/f/}', or
`\hbox{\lstinline/A/}'..`\hbox{\lstinline/F/}').

\begin{center}
\begin{tabular}{ll}
{$ddd\ldots$} & {an \hbox{\lstinline/int/} literal specified in decimal.}\\
{\hbox{\lstinline/0o/}$ooo\ldots$} & {an \hbox{\lstinline/int/} literal specified in octal.}\\
{\hbox{\lstinline/0b/}$bbb\ldots$} & {an \hbox{\lstinline/int/} literal specified in binary.}\\
{\hbox{\lstinline/0x/}$hhh\ldots$} & {an \hbox{\lstinline/int/} literal specified in hexadecimal.}
\end{tabular}
\end{center}
%
There are the usual operations on \hbox{\lstinline/int/}s, including arithmetic
and bitwise operations.

\label{keyword:+}
\label{keyword:-}
\label{keyword:*}
\label{keyword:/}
\label{keyword:mod}
\label{keyword:lnot}
\label{keyword:lsl}
\label{keyword:lsr}
\label{keyword:asl}
\label{keyword:asr}
\label{keyword:land}
\label{keyword:lor}
\label{keyword:lxor}
\begin{center}
\begin{tabular}{ll}
\index{-@\lstinline$~-$ negation}
\hbox{\hbox{\lstinline/-$i$/}} or \hbox{\lstinline/~-$i$/} & negation.\\
\index{+@\lstinline$+$ integer addition}
\hbox{\hbox{\lstinline/$i$ + $j$/}}    & addition.\\
\index{-@\lstinline$-$ integer subtraction}
\hbox{\hbox{\lstinline/$i$ - $j$/}}    & subtraction.\\
\index{*@\lstinline$*$ integer multiplication}
\hbox{\hbox{\lstinline/$i$ * $j$/}}    & multiplication.\\
\index{/@\lstinline$/$ integer division}
\hbox{\lstinline+$i$ / $j$+}    & division.\\
\index{mod@\lstinline$mod$ integer modulus}
\hbox{\hbox{\lstinline/$i$ mod $j$/}}  & remainder.\\
\misspelled{\index{lnot@\lstinline$lnot$ bitwise negation}}
\hbox{\hbox{\lstinline/lnot $i$/}}     & bitwise-inverse.\\
\misspelled{\index{lsl@\lstinline$lsl$ logical shift left}}
\hbox{\hbox{\lstinline/$i$ lsl $j$/}}  & logical shift left $i \times 2^j$.\\
\misspelled{\index{lsr@\lstinline$lsr$ logical shift right}}
\hbox{\hbox{\lstinline/$i$ lsr $j$/}}  & logical shift right $\lfloor i \div 2^j \rfloor$ ($i$ is treated as an unsigned integer).\\
\misspelled{\index{asl@\lstinline$asl$ arithmetic shift left}}
\hbox{\hbox{\lstinline/$i$ asl $j$/}}  & arithmetic shift left $i \times 2^j$.\\
\misspelled{\index{asr@\lstinline$asr$ arithmetic shift right}}
\hbox{\hbox{\lstinline/$i$ asr $j$/}}  & arithmetic shift right $\lfloor i \div 2^j \rfloor$ (the sign of $i$ is preserved).\\
\misspelled{\index{land@\lstinline$land$ bitwise conjunction}}
\hbox{\hbox{\lstinline/$i$ land $j$/}} & bitwise-and.\\
\misspelled{\index{lor@\lstinline$lor$ bitwise disjunction}}
\hbox{\hbox{\lstinline/$i$ lor $j$/}}  & bitwise-or.\\
\misspelled{\index{lxor@\lstinline$lxor$ bitwise exclusive-or}}
\hbox{\hbox{\lstinline/$i$ lxor $j$/}} & bitwise exclusive-or.
\end{tabular}
\end{center}
%
Here are some examples of integer expressions.

\begin{ocaml}
# 12345 + 1;;
@
\begin{topoutput}
- : int = 12346
\end{topoutput}
@
# 0b1110 lxor 0b1010;;
@
\begin{topoutput}
- : int = 4
\end{topoutput}
@
# 1 - - 2;;
@
\begin{topoutput}
- : int = 3
\end{topoutput}
@
# 0x7fffffff;;
@
\begin{topoutput}
- : int = -1
\end{topoutput}
@
# 0xffffffff;;
@
\begin{toperror}
Characters 0-10:
  0xffffffff;;
  ^^^^^^^^^^
Integer literal exceeds the range of representable integers of type int
\end{toperror}
@
\end{ocaml}

\labelsubsection{ocaml-doc-expr-float}{\texttt{float}: the floating-point numbers}
\index{float type@\lstinline/float/ type}
\label{literal:float}
The floating-point numbers provide dynamically scaled ``floating
point'' numbers.  The syntax of a floating point requires a decimal
point, an exponent (base 10) denoted by an `\hbox{\lstinline/E/}' or
`\hbox{\lstinline/e/}', or both.  A digit is required before the
decimal point, but not after.  Here are a few examples:

\begin{center}
0.2, 2e7, 3.1415926, 31.415926E-1, 2.
\end{center}
%
The integer arithmetic operators (\hbox{\lstinline/+/}, \hbox{\lstinline/-/}, \hbox{\lstinline/*/},
\hbox{\lstinline//}/, $\ldots$) \emph{do not work} with floating point values.
The operators for floating-point numbers include a `.' as follows:

\label{keyword:+.}
\label{keyword:-.}
\label{keyword:*.}
\label{keyword:/.}
\begin{center}
\begin{tabular}{@{}ll@{}}
\index{-.@\lstinline$~-.$ floating-point negation}
\hbox{\hbox{\lstinline/-.$x$/}} or \hbox{\lstinline/~-.$x$/} & floating-point negation\\
\index{+.@\lstinline$+.$ floating-point addition}
\hbox{\hbox{\lstinline/$x$ +. $y$/}} & floating-point addition.\\
\index{-.@\lstinline{-.} floating-point subtraction}
\hbox{\hbox{\lstinline/$x$ -. $y$/}} & floating-point subtraction.\\
\index{*.@\lstinline$*.$ floating-point multiplication}
\hbox{\hbox{\lstinline/$x$ *. $y$/}} & float-point multiplication.\\
\index{/.@\lstinline$/.$ floating-point division}
\hbox{\lstinline+$x$ /. $y$+} & floating-point division.\\
\index{int\_of\_float@\lstinline$int_of_float$}
\hbox{\hbox{\lstinline/int_of_float $x$/}} & \hbox{\lstinline+float+} to \hbox{\lstinline+int+} conversion.\\
\index{float\_of\_int@\lstinline$float_of_int$}
\hbox{\hbox{\lstinline/float_of_int $x$/}} & \hbox{\lstinline+int+} to \hbox{\lstinline+float+} conversion.
\end{tabular}
\end{center}
%
Here are some example floating-point expressions.

\begin{ocaml}
# 31.415926e-1;;
@
\begin{topoutput}
- : float = 3.1415926
\end{topoutput}
@
# float_of_int 1;;
@
\begin{topoutput}
- : float = 1.
\end{topoutput}
@
# int_of_float 1.2;;
@
\begin{topoutput}
- : int = 1
\end{topoutput}
@
# 3.1415926 *. 17.2;;
@
\begin{topoutput}
- : float = 54.03539272
\end{topoutput}
@
# 1 + 2.0;;
@
\begin{toperror}
Characters 4-7:
\end{toperror}
@
  1 + 2.0;;
      ^^^
@
\begin{toperror}
This expression has type float but is here used with type int
\end{toperror}
@
\end{ocaml}
%
The final expression fails to type-check because the \hbox{\lstinline/int/} operator
\hbox{\lstinline/+/} is used with the floating-point value \hbox{\lstinline/2.0/}.

\labelsubsection{ocaml-doc-expr-char}{\texttt{char}: the characters}
\index{char type@\lstinline/char/ type}
\label{literal:char}

The character type \hbox{\lstinline/char/} specifies characters from the ASCII
character set.  The syntax for a character constants uses the single
quote symbol \hbox{\lstinline/'$c$'/}.

\begin{ocaml}
'a', 'Z', ' ', 'W'
\end{ocaml}
%
In addition, there are several kinds of escape sequences with an alternate syntax.
Each escape sequence begins with the backslash character ``\hbox{\lstinline/\/}''.

\begin{center}
\begin{tabular}{@{}ll@{}}
\hbox{\hbox{\lstinline/'\\'/}} & The backslash character itself.\\
\hbox{\hbox{\lstinline/'\''/}} & The single-quote character.\\
\hbox{\hbox{\lstinline/'\t'/}} & The tab character.\\
\hbox{\hbox{\lstinline/'\r'/}} & The carriage-return character.\\
\hbox{\hbox{\lstinline/'\n'/}} & The newline character.\\
\hbox{\hbox{\lstinline/'\b'/}} & The backspace character.\\
\hbox{\hbox{\lstinline/'\/}}$ddd$\hbox{\lstinline/'/} & A decimal escape sequence.\\
\hbox{\hbox{\lstinline/'\x/}}$hh$\hbox{\lstinline/'/} & A hexadecimal escape sequence.
\end{tabular}
\end{center}
%
A decimal escape sequence must have exactly three decimal characters
$d$; it specifies the ASCII character with the given decimal
code.  A hexadecimal escape sequence must have exactly two hexadecimal
characters $h$.

\begin{ocaml}
'a', 'Z', '\120', '\t', '\n', '\x7e'
\end{ocaml}
%
There are functions for converting between characters and integers.
The function
\index{characters!decimal code}
\index{Char module!code@\lstinline/code/}
\hbox{\hbox{\lstinline/Char.code/}} returns the
integer corresponding to a character,
and
\misspelled{\index{Char module!chr@\lstinline/chr/}}
\hbox{\lstinline/Char.chr/} returns the character with the
given ASCII code.  The
\index{Char module!lowercase@\lstinline/lowercase/}
\hbox{\lstinline/Char.lowercase/} and
\index{Char module!uppercase@\lstinline/uppercase/}
\hbox{\lstinline/Char.uppercase/} functions give the equivalent
lower- or upper-case characters.

\begin{ocaml}
# '\120';;
@
\begin{topoutput}
- : char = 'x'
\end{topoutput}
@
# Char.code 'x';;
@
\begin{topoutput}
- : int = 120
\end{topoutput}
@
# '\x7e';;
@
\begin{topoutput}
- : char = '~'
\end{topoutput}
@
# Char.uppercase 'z';;
@
\begin{topoutput}
- : char = 'Z'
\end{topoutput}
@
# Char.uppercase '[';;
@
\begin{topoutput}
- : char = '['
\end{topoutput}
@
# Char.chr 33;;
@
\begin{topoutput}
- : char = '!'
\end{topoutput}
@
\end{ocaml}

\labelsubsection{ocaml-doc-expr-string}{\texttt{string}: character strings}
\index{character strings}
\index{string type@\lstinline/string/ type}
\label{literal:string}

In OCaml, character strings belong to a primitive type \hbox{\lstinline/string/}.
Unlike strings in C, character strings are not arrays of characters,
and they do not use the null-character \hbox{\lstinline/'\000'/} for termination.

The syntax for strings uses the double-quote symbol \hbox{\lstinline/"/} as a
delimiter.  Characters in the string may be specified using the same escape
sequences used for characters.

\begin{center}
\begin{ocaml}
"Hello", "The character '\000' is not a terminator", "\072\105"
\end{ocaml}
\end{center}
%
The operator \index{\^@\lstinline/^/ string concatenation}\hbox{\lstinline/^/}
performs string concatenation.

\begin{ocaml}
# "Hello " ^ " world\n";;
@
\begin{topoutput}
- : string = "Hello world\n"
\end{topoutput}
@
# "The character '\000' is not a terminator";;
@
\begin{topoutput}
- : string = "The character '\000' is not a terminator"
\end{topoutput}
@
# "\072\105";;
@
\begin{topoutput}
- : string = "Hi"
\end{topoutput}
@
\end{ocaml}
%
Strings also support random access.  The
expression \index{.[@\lstinline/.[]/ string subscripting}\hbox{\lstinline/s.[i]/} returns the
$i$'th from string $s$; and the expression
\label{keyword:<-(string-assignment)}
\index{<-!string assignment}\hbox{\lstinline/s.[i] <- c/}
replaces the $i$'th in string $s$ by character $c$, returning a
\hbox{\lstinline/unit/} value.  The
\hbox{\lstinline/String/} module (see
Section~\refsection{strings}) also defines many functions
to manipulate strings, including the
\index{String module!length@\lstinline/length/}\hbox{\lstinline/String.length/}
function, which returns the length of a string; and the
\index{String module!sub@\lstinline/sub/}\hbox{\lstinline/String.sub/}
function, which returns a substring.

\begin{ocaml}
# "Hello".[1];;
@
\begin{topoutput}
- : char = 'e'
\end{topoutput}
@
# "Hello".[0] <- 'h';;
@
\begin{topoutput}
- : unit = ()
\end{topoutput}
@
# String.length "Ab\000cd";;
@
\begin{topoutput}
- : int = 5
\end{topoutput}
@
# String.sub "Abcd" 1 2;;
@
\begin{topoutput}
- : string = "bc"
\end{topoutput}
@
\end{ocaml}

\labelsubsection{ocaml-doc-expr-bool}{\texttt{bool}: the Boolean values}
\index{bool type@\lstinline/bool/ type}
\label{keyword:true}
\label{keyword:false}

The \hbox{\lstinline/bool/} type includes the Boolean
values \index{true@\lstinline/true/}\hbox{\lstinline/true/}
and \index{false@\lstinline/false/}\hbox{\lstinline/false/}.  Logical
negation of Boolean values is performed by
the \index{not@\lstinline/not/ logical negation}\hbox{\lstinline/not/}
function.

There are several relations that can be used to compare values,
returning \hbox{\lstinline/true/} if the comparison holds and \hbox{\lstinline/false/}
otherwise.

\label{keyword:=}
\label{keyword:==}
\label{keyword:!=}
\label{keyword:<>}
\label{keyword:<}
\label{keyword:<=}
\label{keyword:>}
\label{keyword:>=}
\begin{center}
\begin{tabular}{ll}
\index{=@\lstinline$=$ comparison}
\hbox{\hbox{\lstinline/$x$ = $y$/}}  & $x$ is equal to $y$.\\
\index{==@\lstinline$==$ comparison}
\hbox{\hbox{\lstinline/$x$ == $y$/}} & $x$ is ``identical'' to $y$.\\
\index{!=@\lstinline$!=$ comparison}
\hbox{\hbox{\lstinline/$x$ != $y$/}} & $x$ is not ``identical'' to $y$.\\
\index{<>@\lstinline$<>$ comparison}
\hbox{\hbox{\lstinline/$x$ <> $y$/}} & $x$ is not equal to $y$.\\
\index{<@\lstinline$<$ comparison}
\hbox{\hbox{\lstinline/$x$ < $y$/}}  & $x$ is less than $y$.\\
\index{<=@\lstinline$<=$ comparison}
\hbox{\hbox{\lstinline/$x$ <= $y$/}} & $x$ is no greater than $y$.\\
\index{>=@\lstinline$>=$ comparison}
\hbox{\hbox{\lstinline/$x$ >= $y$/}} & $x$ is no less than $y$.\\
\index{>@\lstinline$>$ comparison}
\hbox{\hbox{\lstinline/$x$ > $y$/}}  & $x$ is greater than $y$.
\end{tabular}
\end{center}
%
These relations operate on two values $x$ and $y$ having equal but
arbitrary type.  For the primitive types in this chapter, the
comparison is what you would expect.  For values of other types, the
value is implementation-dependent, and in some cases may raise a
runtime error.  For example, functions (discussed in the next chapter)
cannot be compared.

The \hbox{\lstinline/==/} deserves special mention, since we use the
word ``identical'' in an informal sense.  The exact semantics is this:
if the expression ``$x$ \hbox{\lstinline/==/} $y$'' evaluates to
\hbox{\lstinline/true/}, then so does the expression ``$x$
\hbox{\lstinline/=/} $y$''.  However it is still possible for ``$x$
\hbox{\lstinline/=/} $y$'' to be \hbox{\lstinline/true/} even if ``$x$
\hbox{\lstinline/==/} $y$'' is not.  In the OCaml implementation from
INRIA, the expression ``$x$ \hbox{\lstinline/==/} $y$''evaluates to
\hbox{\lstinline/true/} only if the two values $x$ and $y$ are exactly
the same value, similar to the \hbox{\lstinline/==/} operators in
C/Java, or the function \hbox{\lstinline/eq?/} operator in Scheme.
The comparison \hbox{\lstinline/==/} is a constant-time operation that
runs in a bounded number of machine instructions; the comparison
\hbox{\lstinline/=/} is not.

\begin{ocaml}
# 2 < 4;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# "A good job" > "All the tea in China";;
@
\begin{topoutput}
- : bool = false
\end{topoutput}
@
# 2 + 6 = 8;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# 1.0 = 1.0;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# 1.0 == 1.0;;
@
\begin{topoutput}
- : bool = false
\end{topoutput}
@
# 2 == 1 + 1;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
\end{ocaml}
%
Strings are compared lexicographically (in alphabetical-order), so the
second example is \hbox{\lstinline/false/} because the character
`\hbox{\lstinline/l/}' is greater than the space-character
`\hbox{\lstinline/ /}' in the ASCII character set.  The comparison
``\hbox{\lstinline/1.0 == 1.0/}'' in this case returns
\hbox{\lstinline/false/} (because the 2 floating-point numbers are
represented by different values in memory), but it performs normal
comparison on \hbox{\lstinline/int/} values.

\label{keyword:conjunction}
There are two logical operators:
\index{\&\&@\lstinline/&&/ logical conjunction}\hbox{\lstinline/&&/}
is conjunction (which can also be written \hbox{\lstinline/&/}), and
\hbox{\lstinline/||/}
\label{keyword:or}
is disjunction (which can also be written \hbox{\lstinline/or/}).  Both operators are the
``short-circuit'' versions: the second clause is not evaluated if the
result can be determined from the first clause.

\begin{ocaml}
# 1 < 2 || (1 / 0) > 0;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# 1 < 2 && (1 / 0) > 0;;
@
\begin{toperror}
Exception: Division_by_zero.
\end{toperror}
@
# 1 > 2 && (1 / 0) > 0;;
@
\begin{topoutput}
- : bool = false
\end{topoutput}
@
\end{ocaml}
%
Conditionals are expressed with the syntax
\label{keyword:if}
\label{keyword:then}
\label{keyword:else}
\index{if@\lstinline/if/ conditional}
\hbox{\lstinline/if $b$ then $e_1$ else $e_2$/}.

\begin{ocaml}
# if 1 < 2 then
     3 + 7
  else
     4;;
@
\begin{topoutput}
- : int = 10
\end{topoutput}
@
\end{ocaml}

\labelsection{ocaml-core-precedences}{Operator precedences}
\index{precedences}

The precedences of operators on the basic types are as follows,
listed in increasing order.

\begin{center}
\newcommand\comma{\quad}
\begin{tabular}{l|l}
Operators                                                                            & Associativity\\
\hline
\hbox{\lstinline$||$}\comma{} \hbox{\lstinline$&&$}                                                          & left\\
\hbox{\lstinline$=$}\comma{} \hbox{\lstinline$==$}\comma{} \hbox{\lstinline$!=$}\comma{}
\hbox{\lstinline$<>$}\comma{} \hbox{\lstinline$<$}\comma{} \hbox{\lstinline$<=$}\comma{}
\hbox{\lstinline$>$}\comma{} \hbox{\lstinline$>=$}                                                           & left\\
\hbox{\lstinline$+$}\comma{} \hbox{\lstinline$-$}\comma{} \hbox{\lstinline$+.$}\comma{} \hbox{\lstinline$-.$}              & left\\
\hbox{\lstinline$*$}\comma{} \hbox{\lstinline$/$}\comma{} \hbox{\lstinline$*.$}\comma{} \hbox{\lstinline$/.$}\comma{}
\hbox{\lstinline$mod$}\comma{} \hbox{\lstinline$land$}\comma{} \hbox{\lstinline$lor$}\comma{} \hbox{\lstinline$lxor$}      & left\\
\hbox{\lstinline$lsl$}\comma{} \hbox{\lstinline$lsr$}\comma{} \hbox{\lstinline$asr$}                                & right\\
\hbox{\lstinline$lnot$}                                                                               & left\\
\hbox{\lstinline$~-$}\comma{} \hbox{\lstinline$-$}\comma{} \hbox{\lstinline$~-.$}\comma{} \hbox{\lstinline$-.$}            & right
\end{tabular}
\end{center}

\labelsection{ocaml-type-system}{The OCaml type system}

The ML languages are statically and strictly typed.  In addition,
every expression has a exactly one type.  In contrast, C is a
weakly-typed language: values of one type can usually be coerced to a
value of any other type, whether the coercion makes sense or not.
Lisp is a language that is dynamically and strictly typed: the
compiler (or interpreter) will accept any program that is
syntactically correct; the types are checked at run time.  The
strictly typed languages are safe; both Lisp and ML are \emph{safe}
languages, but C is not.

What is ``safety?''  There is a formal definition based on the
operational semantics of the programming language, but an approximate
definition is that a valid program will never fault because of an
invalid machine operation.  All memory accesses will be valid.  ML
guarantees safety by proving that every program that passes the type
checker can never produce a machine fault, and Lisp guarantees it by
checking for validity at run time.  One surprising (some would say
annoying) consequence is that ML has no \hbox{\lstinline/nil/} or \hbox{\lstinline/NULL/}
values; these would potentially cause machine errors if used where
a value is expected.

As you learn OCaml, you will initially spend a lot of time getting the
OCaml type checker to accept your programs.  Be patient, you will
eventually find that the type checker is one of your best friends.  It
will help you figure out where errors may be lurking in your programs.
If you make a change, the type checker will help track down the parts
of your program that are affected.  In the meantime, here are some
rules about type checking.

\begin{enumerate}

\item{Every expression has exactly one type.}

\item{When an expression is evaluated, one of four things may happen:

   \begin{enumerate}
   \item{it may evaluate to a \emph{value} of the same type as the
      expression,}
   \item{it may raise an exception (we'll discuss exceptions in
      Chapter \refchapter{exceptions}),}
   \item{it may not terminate,}
   \item{it may exit.}
   \end{enumerate}}

\end{enumerate}
%
One of the important points here is that there are no ``pure
commands.''  Even assignments produce a value---although the value has
the trivial \texttt{unit} type.

To begin to see how this works, let's look at the conditional
expression.

\begin{ocaml}
% cat -b x.ml
@
\begin{topoutput}
    1	if 1 < 2 then
    2	   1
    3	else
    4	   1.3
\end{topoutput}
@
% ocamlc -c x.ml
@
\begin{toperror}
File "x.ml", line 4, characters 3-6:
This expression has type float but is here used with type int
\end{toperror}
@
\end{ocaml}
%
This error message seems rather cryptic: it says that there is a type
error on line 4, characters 3-6 (the expression \texttt{1.3}).  The
conditional expression evaluates the test.  If the test is \texttt{true},
it evaluates the first branch.  Otherwise, it evaluates the second branch.
In general, the compiler doesn't try to figure out the value of the
test during type checking.  Instead, it requires that both branches of
the conditional have the same type (so that the value will have the same
type no matter how the test turns out).  Since the expressions \texttt{1}
and \texttt{1.3} have different types, the type checker generates an
error.

One other issue: the \texttt{else} branch is not required in a conditional.
If it is omitted, the conditional is treated as if the \texttt{else} case
returns the \texttt{()} value.  The following code has a type error.

\begin{ocaml}
% cat -b y.ml
@
\begin{topoutput}
    1	if 1 < 2 then
    2	   1
\end{topoutput}
@
% ocamlc -c y.ml
@
\begin{toperror}
File "y.ml", line 2, characters 3-4:
This expression has type int but is here used with type unit
\end{toperror}
@
\end{ocaml}
%
In this case, the expression \texttt{1} is flagged as a type error,
because it does not have the same type as the omitted \texttt{else}
branch.

\labelsection{ocaml-compiling}{Compiling your code}

You aren't required to use the toploop for all your programs.  In
fact, as your programs become larger, you will begin to use the
toploop less, and rely more on the OCaml compilers.  Here is a brief
introduction to using the compiler; more information is given in the
Chapter \refchapter{files}.

If you wish to compile your code, you should place it in a file with
the \texttt{.ml} suffix.  In INRIA OCaml, there are two compilers:
\texttt{ocamlc} compiles to byte-code, and \texttt{ocamlopt} compiles to
native machine code.  The native code is several times faster, but
compile time is longer.  The usage is similar to \texttt{cc}.  The
double-semicolon terminators are not necessary in \hbox{\lstinline/.ml/} source
files; you may omit them if the source text is unambiguous.

\begin{itemize}

\item{{To compile a single file, use \texttt{ocamlc -g -c
\emph{file}.ml}.  This will produce a file \texttt{\emph{file}.cmo}.  The
\texttt{ocamlopt} programs produces a file \texttt{\emph{file}.cmx}.  The
\texttt{-g} option causes debugging
information to be included in the output file.}}

\item{To link together several files into a single executable, use
\texttt{ocamlc} to link the \texttt{.cmo} files.  Normally, you would also
specify the \texttt{-o \emph{program\_file}} option to specify the output
file (the default is \texttt{a.out}).  For example, if you have two program
files \texttt{x.cmo} and \texttt{y.cmo}, the command would be:

\begin{ocaml}
% ocamlc -g -o program x.cmo y.cmo
% ./program
...
\end{ocaml}}
\end{itemize}
%
There is also a debugger \texttt{ocamldebug} that you can use to debug
your programs.  The usage is a lot like \texttt{gdb}, with one major
exception: execution can go backwards.  The \texttt{back} command will
go back one instruction.
