\labelchapter{intro}{Introduction}

This book is an introduction to ML programming, specifically for
the Objective Caml (\emph{OCaml}) programming language from INRIA
\cite{Ler02,RV97}.  OCaml is a dialect of the ML
(\emph{Meta-Language}) family of languages, which derive from the
Classic ML language designed by Robin Milner in 1975 for the LCF
(\emph{Logic of Computable Functions}) theorem prover
\cite{GMW79}.

OCaml shares many features with other dialects of ML, and it provides
several new features of its own.  Throughout this document, we use the
term ML to stand for any of the dialects of ML, and OCaml when a
feature is specific to OCaml.

\begin{itemize}
\item{{ML is a \textbf{functional} language, meaning that functions are
treated as first-class values.  Functions may be nested, functions may
be passed as arguments to other functions, and functions can be stored
in data structures.  Functions are treated like their mathematical
counterparts as much as possible.  Assignment statements that
permanently change the value of certain expressions are permitted, but used
much less frequently than in languages like C or Java.}}

\item{{
ML is \textbf{strongly typed}, meaning that the type of every variable
and every expression in a program is determined at compile-time.
Programs that pass the type checker are \emph{safe}: they will never
``go wrong'' because of an illegal instruction or memory fault.}}

\item{{
Related to strong typing, ML uses \textbf{type inference} to infer
types for the expressions in a program.  Even though the language is
strongly typed, it is rare that the programmer has to annotate a
program with type constraints.}}

\item{{
The ML type system is \textbf{polymorphic}, meaning that it is possible
to write programs that work for values of any type.  For example, it
is straightforward to define generic data structures like lists, stacks, and
trees that can contain elements of any type.  In a language without polymorphism,
the programmer would either have to write different
implementations for each type (say, lists of integers \emph{vs}.{} lists of
floating-point values), or else use explicit coercions to bypass the
type system.}}

\item{{
ML implements a \textbf{pattern matching} mechanism that
unifies case analysis and data destructors.}}

\item{{
ML includes an expressive \textbf{module system} that allows data
structures to be specified and defined \emph{abstractly}.  The module
system includes \emph{functors}, which are are functions over modules
that can be used to produce one data structure from another.}}

\item{{
OCaml is also the only widely-available ML implementation to include an
\textbf{object system}.  The module system and object system complement
one another: the module system provides data abstraction, and the
object system provides inheritance and re-use.}}

\item{{
OCaml includes a compiler that supports \textbf{separate compilation}.
This makes the development process easier by reducing the amount
of code that must be recompiled when a program is modified.  OCaml
actually includes two compilers: a \emph{byte-code} compiler that
produces code for the portable OCaml byte-code interpreter, and a
\emph{native-code} compiler that produces efficient code for many
machine architectures.}}

\item{{
One other feature should be mentioned: all the languages in the ML
family have a \textbf{formal semantics}, which means that programs have a
mathematical interpretation, making the programming
language easier to understand and explain.}}

\end{itemize}

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{ccode}
/*
 * A C function to
 * determine the greatest
 * common divisor of two
 * positive numbers a and b.
 * We assume a>b.
 */
int gcd(int a, int b)
{
   int r;

   while((r = a % b) != 0) {
      a = b;
      b = r;
   }
   return b;
}
\end{ccode}
&
\begin{ocaml}
(*
 * An OCaml function to
 * determine the greatest
 * common divisor of two
 * positive numbers a and b.
 * We assume a>b.
 *)
let rec gcd a b =
   let r = a mod b in
   if r = 0 then
      b
   else
      gcd b r
\end{ocaml}
\end{tabular}
\end{center}
\caption{
C is an imperative programming language, while \OCaml{} is functional.
The code on the left is a C program to compute the greatest common divisor
of two natural numbers.  The code on the right is equivalent \OCaml{} code,
written functionally.
}% end caption
\label{figure:c-vs-ocaml}
\end{figure}

\labelsection{ocaml-doc-intro-functional}{Functional and imperative languages}

The ML languages are mostly functional, meaning that the normal
programming style is functional, but the language includes assignment and
side-effects.

\index{Euclid's algorithm}
\index{greatest common divisor}
%
To compare ML with an imperative language, a comparison of two simple
implementations of Euclid's algorithm is shown in
Figure~\ref{figure:c-vs-ocaml} (Euclid's algorithm computes the
greatest common divisor of two nonnegative integers).  In a language
like C, the algorithm is normally implemented as a loop, and progress
is made by modifying the state.  Reasoning about this program requires
that we reason about the program state: give an invariant for the
loop, and show that the state makes progress on each step toward the
goal.

In OCaml, Euclid's algorithm is normally implemented using recursion.
The steps are the same, but there are no side-effects.  The \texttt{let}
keyword specifies a definition, the \texttt{rec} keyword specifies that
the definition is recursive, and the \texttt{gcd a b} defines a function
with two arguments $a$ and $b$.

In ML, programs rarely use assignment or side-effects except for I/O.
Pure functional programs have some nice properties: one is that data
structures are \emph{persistent}, which means that no
data structure is ever destroyed.

There are problems with taking too strong a stance in favor of
pure functional programming.  One is that every updatable data structure
has to be passed as an argument to every function that uses it (this
is called \emph{threading} the state).  This can make the code obscure
if there are too many of these data structures.  We take an intermediate
approach.  We use imperative code when necessary, but we encourage
the use of pure functional approach whenever appropriate.

\labelsection{ocaml-doc-intro-organization}{Organization}

This book is organized as a \emph{user guide} to programming in
OCaml.  It is not a reference manual: there is already an online
reference manual.  We assume that the reader already has some
experience using an imperative programming language like C; we'll point
out the differences between ML and C in the cases that seem
appropriate.

\labelsection{ocaml-doc-intro-additional-source}{Additional Sources of Information}

This book was originally used for a course in compiler
construction at Caltech.  The course material, including exercises, is
available at \url{http://www.cs.caltech.edu/courses/cs134/cs134b}.

The OCaml reference manual \cite{Ler02} is available on the
OCaml home page \url{http://www.ocaml.org/}.

The author can be reached at \email{jyh@cs.caltech.edu}.
