\index{file suffixes!.cmo (byte code)} Compilation now takes several steps. In the first step, the
`set.ml` and `unique.ml` files are compiled with the
`-c` option, which specifies that the compiler should produce an intermediate file
with a `.cmo` suffix. These files are then linked to produce an executable with the
command `ocamlc -o unique set.cmo unique.cmo`.

\index{compilation units!cyclic dependencies}
The order of compilation and linking here is
significant. The `unique.ml` file refers to
the `set.ml` file by using
the `Set.mem` function. Due to this dependency,
the `set.ml` file must be compiled before
the `unique.ml` file, and
the `set.cmo` file must appear before
the `unique.cmo` file during linking. 
Cyclic dependencies are \emph{not allowed}. It is not legal to have a
file `a.ml` refer to a value `B.x`,
and a file `b.ml` that refers to a
value `A.y`.

\labelsubsection{defining-interfaces}{Defining an interface}

\index{compilation units!interfaces}
One of the reasons for factoring the program was to be able to improve
the implementation of sets. To begin, we should make the type of
sets \emph{abstract}---that is, we should hide the details of how it
is implemented so that we can be sure the rest of the program does not
unintentionally depend on the implementation details. To do this, we
can define an abstract interface for sets, in a
file `set.mli`.

An interface should declare types for each of the values that are
publicly accessible in a module, as well as any needed type
declarations or definitions. For our purposes, we need to define a
polymorphic type of sets `'a set` abstractly. That
is, in the interface we will declare a type `'a set`
without giving a definition, preventing other parts of the program
from knowing, or depending on, the particular representation of sets
we have chosen. The interface also needs to declare types for the
public values `empty`, `add`,
and `mem` values, as a declaration with the following
syntax.

\index{val@\lstinline/val/}
\label{keyword:val(signatures)}
\begin{ocaml}
val $\nt{identifier}$ : $\nt{type}$
\end{ocaml}
%
The complete interface is shown in Figure \reffigure{unique3}. The
implementation remains mostly unchanged, except that a specific,
concrete type definition must be given for the type
%
`'a set`.

\begin{figure}
\begin{center}
\begin{tabular}{ll}
\begin{tabular}[t]{l}
File: set.mli\\
\hline
\begin{ocaml}
type 'a set
val empty : 'a set
val add : 'a -> 'a set -> 'a set
val mem : 'a -> 'a set -> bool
\end{ocaml}
\\
\\
File: set.ml\\
\hline
\begin{ocaml}
type 'a set = 'a list
let empty = []
let add x l = x :: l
let mem x l = List.mem x l
\end{ocaml}
\end{tabular}
&
\begin{tabular}[t]{l}
Example run (with lists)\\
\hline
\begin{minipage}{2.5in}
\begin{ocaml}
% ocamlc -c set.mli
% ocamlc -c set.ml
% ocamlc -c unique.ml
% ocamlc -o unique set.cmo unique.cmo
% ./unique
> Siddhartha
@
\begin{topoutput}
Siddhartha
\end{topoutput}
@
> Siddhartha
> Siddharta
@
\begin{topoutput}
Siddharta
\end{topoutput}
@
\end{ocaml}
\end{minipage}
\end{tabular}
\end{tabular}
\end{center}
\caption{Adding an interface to the \hbox{\lstinline$Set$} implementation.}
\labelfigure{unique3}
\end{figure}
%
%% \\
%% \\
%% \begin{ocaml}
%% % ocamlc -c set.mli
%% % ocamlc -c set.ml
%% % ocamlc -c unique.ml
%% File "unique.ml", line 8, characters 14-36:
%% This expression has type 'a list but is
%%    here used with type string Set.set
%% \end{ocaml}
%% \begin{tabular}[t]{l}
%% File: unique.ml\\
%% \hline
%% \begin{ocaml}
%% let rec unique alread_read =
%%    output_string stdout "> ";
%%    flush stdout;
%%    let line = input_line stdin in
%%       if not (Set.mem line already_read) then begin
%%          output_string stdout line;
%%          output_char stdout '\n';
%%          (* unique (line :: already_read) *)
%%          unique (Set.add line already_read)
%%       end else
%%          unique already_read;;
%
%% try unique Set.empty with
%%    End_of_file ->
%%       ();;
%% \end{ocaml}
%% \end{tabular}
%% &
%% \begin{tabular}[t]{l}
%% Example run\\
%% \hline
%% \begin{ocaml}
%% % ocamlc -c set.mli
%% % ocamlc -c set.ml
%% % ocamlc -c unique.ml
%% % ocamlc -o unique set.cmo unique.cmo
%% % ./unique
%% > Siddhartha
%% Siddhartha
%% > Siddhartha
%% > Siddharta
%% Siddharta
%% \end{ocaml}
%% \end{tabular}
%% \end{tabular}
%% \end{center}
%% \labelfigure{uniq2}
%% \end{figure}
%
Now, when we compile the program, we first compile the interface
file `set.mli`, then the
implementations `set.ml`
and `unique.ml`.
%
%% But something has changed, the `uniq.ml` file
%% no longer compiles! Following the error message, we find that the error is due to the expression
%% `line :: already_read`, which uses a `List` operation instead of a `Set`
%% operation. Since the `'a set` type is abstract, it is now an error to treat the set as a list,
%% and the compiler complains appropriately.
%
%% Changing this expression to `Set.add line already_read` fixes the error. 
%
Note that, although the `set.mli` file must be compiled, it does not
need to be specified during linking
%
`ocamlc -o unique set.cmo unique.cmo`.

At this point, the `set.ml` implementation is fully
abstract, making it easy to replace the implementation with a better
one (for example, the implementation of sets using red-black trees in
Section~\reflabelsection{balanced-red-black-trees}).

\labelsubsection{transparent-types}{Transparent type definitions}

\index{types!transparent}
In some cases, abstract type definitions are too strict. There are
times when we want a type definition to be \emph{transparent}---that
is, visible outside the file. For example, suppose we wanted to add a
`choose` function to the set implementation, where, given a set
$s$, the expression (`choose $s$`) returns
some element of the set if the set is non-empty, and nothing
otherwise. One possible way to write this function is to define a
union type `choice` that defines the two cases, as shown in
Figure~\reffigure{unique4}.

The type definition for `choice` must be transparent (otherwise
there isn't much point in defining the function).  For the type to be
transparent, the interface simply provides the definition.  The
implementation must contain the \emph{same} definition.

\begin{figure}
\begin{center}
\begin{tabular}{l@{\hskip0.25in}l}
\begin{tabular}[t]{l}
Interface file: set.mli\\
\hline
\begin{ocaml}
type 'a set
type 'a choice =
   Element of 'a
 | Empty
val empty : 'a set
val add : 'a -> 'a set -> 'a set
val mem : 'a -> 'a set -> bool
val choose : 'a set -> 'a choice
\end{ocaml}
\end{tabular}
&
\begin{tabular}[t]{l}
Implementation file: set.ml\\
\hline
\begin{ocaml}
type 'a set = 'a list
type 'a choice =
   Element of 'a
 | Empty
let empty = []
let add x l = x :: l
let mem x l = List.mem x l
let choose = function
   x :: _ -> Element x
 | [] -> Empty
\end{ocaml}
\end{tabular}
\end{tabular}
\end{center}
\caption{Extending the \hbox{\lstinline$Set$} implementation.}
\labelfigure{unique4}
\end{figure}

\labelsection{common-errors}{Some common errors}

As you develop programs with several files, you will undoubtably
encounter some errors.

\labelsubsection{interface-errors}{Interface errors}

\index{file suffixes!.cmi (compiled interface)}
When an interface file (with a `.mli` suffix) is
compiled successfully with `ocamlc`
or `ocamlopt`, the compiler produces a compiled
representation of the file, having a `.cmi` suffix.
When an implementation is compiled, the compiler compares the
implementation with the interface.  If a definition does not match the
interface, the compiler will print an error and refuse to compile the
file.

\labelsubsubsection{type-mismatch-error}{Type errors}

\index{interfaces!type errors}
For example, suppose we had reversed the order of arguments in the
`Set.add` function so that the set argument is first.

\begin{ocaml}
let add s x = x :: s
\end{ocaml}
%
When we compile the file, we get an error. The compiler prints the
types of the mismatched values, and exits with an error code.

\begin{ocaml}
% ocamlc -c set.mli
% ocamlc -c set.ml
@
\begin{toperror}
The implementation set.ml does not match the interface set.cmi:
Values do not match:
  val add : 'a list -> 'a -> 'a list
is not included in
  val add : 'a -> 'a set -> 'a set
\end{toperror}
@
\end{ocaml}
%
The first declaration is the type the compiler inferred for the
definition; the second declaration is from the interface. Note that
the definition's type is not abstract (using
`'a list`
instead of `'a set`). For this example, we deduce
that the argument ordering doesn't match, and the implementation or the
interface must be changed.

\labelsubsubsection{missing-def-error}{Missing definition errors}

\index{interfaces!missing definitions}
Another common error occurs when a function declared in the interface
is not defined in the implementation. For example, suppose we had
defined an \texttt{insert} function instead of an \texttt{add}
function. In this case, the compiler prints the name of the missing
function, and exits with an error code.

\begin{ocaml}
% ocamlc -c set.ml
@
\begin{toperror}
The implementation set.ml does not match the interface set.cmi:
The field `add' is required but not provided
\end{toperror}
@
\end{ocaml}

\labelsubsubsection{type-def-errors}{Type definition mismatch errors}

\index{interfaces!type mismatches}
\emph{Transparent} type definitions in the interface can also cause an
error if the type definition in the implementation does not match. For
example, in the definition of the `choice` type,
suppose we had declared the cases in different orders.

\begin{center}
\begin{tabular}{l@{\hskip0.25in}l}
\begin{tabular}[t]{l}
Interface file: set.mli\\
\hline
\begin{ocaml}
type 'a set
type 'a choice =
   Element of 'a
 | Empty
$\cdots$
\end{ocaml}
\end{tabular}
&
\begin{tabular}[t]{l}
Implementation file: set.ml\\
\hline
\begin{ocaml}
type 'a set = 'a list
type 'a choice =
   Empty
 | Element of 'a
$\cdots$
\end{ocaml}
\end{tabular}
\end{tabular}
\end{center}
%
When we compile the `set.ml` file, the compiler produces an error
with the mismatched types.

\begin{ocaml}
% ocamlc -c set.mli
% ocamlc -c set.ml
@
\begin{toperror}
The implementation set.ml does not match the interface set.cmi:
Type declarations do not match:
  type 'a choice = Empty | Element of 'a
is not included in
  type 'a choice = Element of 'a | Empty
\end{toperror}
@
\end{ocaml}
%
\index{interfaces!omitting@omitting the \lstinline$.mli$ file}
The type definitions are required to be \emph{exactly} the same. Some
programmers find this duplication of type definitions to be
annoying. While it is difficult to avoid all duplication of type
definitions, one common solution is to define the transparent types in
a separate `.ml` file without an interface, for
example by moving the definition of `'a choice` to a
file `set_types.ml`. By default, when an interface
file does not exist, the compiler automatically produces an interface
in which all definitions from the implementation are fully visible. As
a result, the type in `set_types.ml` needs to be
defined just once.

\labelsubsubsection{compile-errors}{Compile dependency errors}

\index{compilation units!dependency errors}
\index{compiling!inconsistent assumptions}
The compiler will also produce errors if the compile state is
inconsistent. Each time an interface is compiled, all the files that
uses that interface must be recompiled.  For example, suppose we update
the `set.mli` file, and recompile it and
the `unique.ml` file (but we forget to recompile
the `set.ml` file). The compiler produces the
following error.

\begin{ocaml}
% ocamlc -c set.mli
% ocamlc -c unique.ml
% ocamlc -o unique set.cmo unique.cmo
@
\begin{toperror}
Files unique.cmo and set.cmo make inconsistent
assumptions over interface Set
\end{toperror}
@
\end{ocaml}
%
It takes a little work to detect the cause of the error. The compiler
says that the files make inconsistent assumptions for
interface `Set`. The interface is defined in the
file `set.cmi`, and so this error message states that
at least one of `set.ml`
or `unique.ml` needs to be recompiled. In general, we
don't know which file is out of date, and the best solution is usually
to recompile them all.

\labelsection{open}{Using \texttt{open} to expose a namespace}

\label{keyword:open}
\index{open!compilation units}
Using the full name \texttt{\emph{Filename}.\emph{identifier}} to refer to
the values in a module can get
tedious. The statement \texttt{open \emph{Filename}} can be used to
``open'' an interface, allowing the use of unqualified names for
types, exceptions, and values. For example,
the `unique.ml` module can be somewhat simplified by
using the `open` directive for
the `Set` module. In the following listing,
the \underline{underlined} variables refer to values from the Set
implementation (the underlines are for illustration only, they don't
exist in the program files).

\begin{center}
\lstset{moreemph={mem,add,empty},emphstyle=\underbar}
\begin{tabular}[t]{l}
File: unique.ml\\
\hline
\begin{ocaml}
open Set
let rec unique already_read =
   output_string stdout "> ";
   flush stdout;
   let line = input_line stdin in
      if not (mem line already_read) then begin
         output_string stdout line;
         output_char stdout '\n';
         unique (add line already_read)
      end else
         unique already_read;;

(* Main program *)
try unique empty with
   End_of_file ->
      ();;
\end{ocaml}
\end{tabular}
\end{center}
%
\index{open!scoping}
Sometimes multiple \texttt{open}ed files will define the same name. In
this case, the \emph{last} file with an \texttt{open} statement will
determine the value of that symbol. Fully qualified names (of the
form \texttt{\emph{Filename}.\emph{identifier}}) may still be used even if
the file has been opened. Fully qualified names can be used to access
values that may have been hidden by an \texttt{open} statement.

\labelsubsection{open-errors}{A note about \texttt{open}}

\index{open!overuse}
Be careful with the use of \texttt{open}. In general, fully qualified
names provide more information, specifying not only the name of the
value, but the name of the module where the value is defined. For
example, the \texttt{Set} and \texttt{List} modules both define
a \texttt{mem} function. In the \texttt{Unique} module we just
defined, it may not be immediately obvious to a programmer that
the \texttt{mem} symbol refers to `Set.mem`,
not `List.mem`.

In general, you should use `open` statement
sparingly. Also, as a matter of style, it is better not
to \texttt{open} most of the library modules, like
the `Array`, `List`,
and `String` modules, all of which define methods
(like `create`) with common names. Also, you should
never \texttt{open}
the `Unix`, `Obj`,
and `Marshal` modules! The functions in these modules
are not completely portable, and the fully qualified names can be used
to identify all the places where portability may be a problem (for
instance, the Unix \misspelled{\texttt{grep}} command can be used to find all the
places where `Unix` functions are used).

\index{open!vs include@\textit{vs.}~`#include`}
The behavior of the \texttt{open} statement is not like
an `#include` statement in C. An implementation
file `mod.ml` should not include
an `open Mod` statement. One common source of errors
is defining a type in a `.mli` interface, then
attempting to use `open` to ``include'' the
definition in the `.ml` implementation. This won't
work---the implementation must include an identical type
definition. This might be considered to be an annoying feature of
OCaml, but it preserves a simple semantics---the implementation must
provide a definition for each declaration in the interface.

\labelsection{debugging}{Debugging a program}

\index{ocamldebug@\lstinline$ocamldebug$}
The `ocamldebug` program can be used to debug a
program compiled
with `ocamlc`. The `ocamldebug`
program is a little like the GNU `gdb` program.  It
allows breakpoints to be set; when a breakpoint is reached, control is
returned to the debugger so that program variables can be examined.

To use `ocamldebug`, the program must be compiled with the
`-g` flag.

\begin{ocaml}
% ocamlc -c -g set.mli
% ocamlc -c -g set.ml
% ocamlc -c -g unique.ml
% ocamlc -o unique -g set.cmo unique.cmo
\end{ocaml}
%
The debugger is invoked using by specifying the program to be debugged
on the `ocamldebug` command line.

\begin{ocamldebug}
% ocamldebug ./unique
`
\begin{topoutput}
	Objective Caml Debugger version 3.08.3
\end{topoutput}
`
(ocd) help
`
\begin{toperror}
List of commands: cd complete pwd directory kill help quit shell run reverse
step backstep goto finish next start previous print display source break
delete set show info frame backtrace bt up down last list load_printer
install_printer remove_printer
\end{toperror}
`
\end{ocamldebug}
%
There are several commands that can be used. The basic commands
are `run`, `step`, `next`, `break`, `list`, `print`,
and `goto`.

\begin{quote}
\begin{itemize}
\item \lstinline]run]: Start or continue execution of the program.
\item \lstinline]break @ module linenum]: Set a breakpoint on line \lstinline/linenum/ in module \lstinline/module/.
\item \lstinline]list]: display the lines around the current execution point.
\item \lstinline]print expr]: Print the value of an expression. The expression must be a variable.
\item \lstinline]goto time]:
%
Execution of the program is measured in time steps, starting from
0. Each time a breakpoint is reached, the debugger prints the current
time. The `goto` command may be used to continue
execution to a future time, or to a \emph{previous} timestep.

\item \lstinline]step]: Go forward one time step.
\item \lstinline]next]:
%
If the current value to be executed is a function, evaluate the
function, a return control to the debugger when the function
completes. Otherwise, step forward one time step.
\end{itemize}
\end{quote}
%
For debugging the `unique` program, we need to know
the line numbers. Let's set a breakpoint in
the `unique` function, which starts in line 1 in
the `Unique` module. We'll want to stop at the first
line of the function.

\begin{ocamldebug}
(ocd) break @ Unique 1
`
\begin{topoutput}
Loading program... done.
Breakpoint 1 at 21656 : file unique.ml, line 2, character 4
\end{topoutput}
`
1
(ocd) run
`
\begin{topoutput}
Time : 12 - pc : 21656 - module Unique
Breakpoint : 1
2    <|b|>output_string stdout "> ";
\end{topoutput}
`
(ocd) n
`
\begin{topoutput}
Time : 14 - pc : 21692 - module Unique
2    output_string stdout "> "<|a|>;
\end{topoutput}
`
(ocd) n
`
\begin{topoutput}
> Time : 15 - pc : 21720 - module Unique
3    flush stdout<|a|>;
\end{topoutput}
`
(ocd) n
`
\begin{topoutput}
Robinson Crusoe
Time : 29 - pc : 21752 - module Unique
5       <|b|>if not (Set.mem line already_read) then begin
\end{topoutput}
`
(ocd) p line
`
\begin{topoutput}
line : string = "Robinson Crusoe"
\end{topoutput}
`
\end{ocamldebug}
%
Next, let's set a breakpoint just before calling the `unique`
function recursively.

\begin{ocamldebug}
(ocd) list
`
\begin{topoutput}
1 let rec unique already_read =
2    output_string stdout "> ";
3    flush stdout;
4    let line = input_line stdin in
5       <|b|>if not (Set.mem line already_read) then begin
6          output_string stdout line;
7          output_char stdout '\n';
8          unique (Set.add line already_read)
9       end
10       else
11          unique already_read;;
12
13 (* Main program *)
14 try unique Set.empty with
15    End_of_file ->
16       ();;
Position out of range.
\end{topoutput}
`
(ocd) break @ 8
`
\begin{topoutput}
Breakpoint 2 at 21872 : file unique.ml, line 8, character 42
\end{topoutput}
`
(ocd) run
`
\begin{topoutput}
Time : 38 - pc : 21872 - module Unique
Breakpoint : 2
8          unique (Set.add line already_read)<|a|>
\end{topoutput}
`
\end{ocamldebug}
%
\index{ocamldebug!backward execution}
Next, suppose we don't like adding this line of input. We can go back
to time `15` (the time just before
the `input_line` function is called).

\begin{ocamldebug}
(ocd) goto 15
`
\begin{topoutput}
> Time : 15 - pc : 21720 - module Unique
3    flush stdout<|a|>;
\end{topoutput}
`
(ocd) n
`
\begin{topoutput}
Mrs Dalloway
Time : 29 - pc : 21752 - module Unique
5       <|b|>if not (Set.mem line already_read) then begin
\end{topoutput}
`
\end{ocamldebug}
%
Note that when we go back in time, the program prompts us again for an
input line. This is due to way time travel is implemented
in `ocamldebug`.  Periodically, the debugger takes a
checkpoint of the program (using the Unix `fork()`
system call).  When reverse time travel is requested, the debugger
restarts the program from the closest checkpoint before the time
requested.  In this case, the checkpoint was taken before the call
to `input_line`, and the program resumption requires
another input value.

We can continue from here, examining the remaining functions and
variables. You may wish to explore the other features of the
debugger.  Further documentation can be found in the OCaml reference
manual.
