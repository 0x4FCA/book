#use "topfind";;
[%%expect ocaml {|- : unit = ()|};
{|
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

|};
ocaml {|- : unit = ()|}];;
#thread;;
[%%expect{|
/Users/yminsky/.opam/4.04.1/lib/ocaml/threads: added to search path
/Users/yminsky/.opam/4.04.1/lib/ocaml/threads/threads.cma: loaded
|}];;
#camlp4o;;
[%%expect{|
/Users/yminsky/.opam/4.04.1/lib/ocaml/dynlink.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ocaml/camlp4: added to search path
/Users/yminsky/.opam/4.04.1/lib/ocaml/camlp4/camlp4o.cma: loaded
|}];;
#require "core";;
[%%expect{|
/Users/yminsky/.opam/4.04.1/lib/base/caml: added to search path
/Users/yminsky/.opam/4.04.1/lib/base/caml/caml.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/base/shadow_stdlib: added to search path
/Users/yminsky/.opam/4.04.1/lib/base/shadow_stdlib/shadow_stdlib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/sexplib/0: added to search path
/Users/yminsky/.opam/4.04.1/lib/base: added to search path
/Users/yminsky/.opam/4.04.1/lib/base/base.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/fieldslib: added to search path
/Users/yminsky/.opam/4.04.1/lib/fieldslib/fieldslib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ppx_compare/runtime-lib: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_compare/runtime-lib/ppx_compare_lib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/sexplib: added to search path
/Users/yminsky/.opam/4.04.1/lib/variantslib: added to search path
/Users/yminsky/.opam/4.04.1/lib/variantslib/variantslib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/bin_prot/shape: added to search path
/Users/yminsky/.opam/4.04.1/lib/bin_prot/shape/bin_shape_lib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/bin_prot: added to search path
/Users/yminsky/.opam/4.04.1/lib/bin_prot/bin_prot.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ppx_hash/runtime-lib: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_hash/runtime-lib/ppx_hash_lib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ppx_inline_test/config: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_inline_test/config/inline_test_config.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ppx_inline_test/runtime-lib: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_inline_test/runtime-lib/ppx_inline_test_lib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/core_kernel/base_for_tests: added to search path
/Users/yminsky/.opam/4.04.1/lib/core_kernel/base_for_tests/base_for_tests.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/jane-street-headers: added to search path
/Users/yminsky/.opam/4.04.1/lib/jane-street-headers/jane_street_headers.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ocaml/nums.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/num-top: added to search path
/Users/yminsky/.opam/4.04.1/lib/num-top/num_top.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/num: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_assert/runtime-lib: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_assert/runtime-lib/ppx_assert_lib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ppx_bench/runtime-lib: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_bench/runtime-lib/ppx_bench_lib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ppx_expect/common: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_expect/common/expect_test_common.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ppx_expect/config: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_expect/config/expect_test_config.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/ppx_expect/collector: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_expect/collector/expect_test_collector.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/stdio: added to search path
/Users/yminsky/.opam/4.04.1/lib/stdio/stdio.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/typerep: added to search path
/Users/yminsky/.opam/4.04.1/lib/typerep/typerep_lib.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/core_kernel: added to search path
/Users/yminsky/.opam/4.04.1/lib/core_kernel/core_kernel.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/sexplib/unix: added to search path
/Users/yminsky/.opam/4.04.1/lib/sexplib/unix/sexplib_unix.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/spawn: added to search path
/Users/yminsky/.opam/4.04.1/lib/spawn/spawn.cma: loaded
/Users/yminsky/.opam/4.04.1/lib/core: added to search path
/Users/yminsky/.opam/4.04.1/lib/core/core.cma: loaded
|}];;
#require "ppx_jane";;
[%%expect{|
/Users/yminsky/.opam/4.04.1/lib/ppx_jane: added to search path
/Users/yminsky/.opam/4.04.1/lib/ppx_jane/./ppx.exe --as-ppx: activated
|}];;
#warnings "-40";;
open Core_kernel;;
module Time_ns = Core_kernel.Time_ns;;
[%%expect ocaml {|module Time_ns = Core_kernel.Time_ns|}];;
[@@@part "1"];;
module Log_entry = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      important: bool;
      message: string;
    }
end
;;
[%%expect ocaml {|
module Log_entry :
  sig
    type t = {
      session_id : string;
      time : Time_ns.t;
      important : bool;
      message : string;
    }
  end
|}];;
[@@@part "1.5"];;
module Heartbeat = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      status_message: string;
    }
end;;
[%%expect ocaml {|
module Heartbeat :
  sig
    type t = {
      session_id : string;
      time : Time_ns.t;
      status_message : string;
    }
  end
|}];;
module Logon = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      user: string;
      credentials: string;
    }
end;;
[%%expect ocaml {|
module Logon :
  sig
    type t = {
      session_id : string;
      time : Time_ns.t;
      user : string;
      credentials : string;
    }
  end
|}];;
[@@@part "2"];;
type client_message = | Logon of Logon.t
                      | Heartbeat of Heartbeat.t
                      | Log_entry of Log_entry.t
;;
[%%expect ocaml {|
type client_message =
    Logon of Logon.t
  | Heartbeat of Heartbeat.t
  | Log_entry of Log_entry.t
|}];;
[@@@part "3"];;
let messages_for_user user messages =
  let (user_messages,_) =
    List.fold messages ~init:([],String.Set.empty)
      ~f:(fun ((messages,user_sessions) as acc) message ->
        match message with
        | Logon m ->
          if m.user = user then
            (message::messages, Set.add user_sessions m.session_id)
          else acc
        | Heartbeat _ | Log_entry _ ->
          let session_id = match message with
            | Logon     m -> m.session_id
            | Heartbeat m -> m.session_id
            | Log_entry m -> m.session_id
          in
          if Set.mem user_sessions session_id then
            (message::messages,user_sessions)
          else acc
      )
  in
  List.rev user_messages
;;
[%%expect ocaml {|
val messages_for_user : string -> client_message list -> client_message list =
  <fun>
|}];;
[@@@part "4"];;
module Log_entry = struct
  type t = { important: bool;
             message: string;
           }
end;;
[%%expect ocaml {|module Log_entry : sig type t = { important : bool; message : string; } end|}];;
module Heartbeat = struct
  type t = { status_message: string; }
end;;
[%%expect ocaml {|module Heartbeat : sig type t = { status_message : string; } end|}];;
module Logon = struct
  type t = { user: string;
             credentials: string;
           }
end ;;
[%%expect ocaml {|module Logon : sig type t = { user : string; credentials : string; } end|}];;
[@@@part "5"];;
type details =
  | Logon of Logon.t
  | Heartbeat of Heartbeat.t
  | Log_entry of Log_entry.t
;;
[%%expect ocaml {|
type details =
    Logon of Logon.t
  | Heartbeat of Heartbeat.t
  | Log_entry of Log_entry.t
|}];;
[@@@part "6"];;
module Common = struct
  type t = { session_id: string;
             time: Time_ns.t;
           }
end ;;
[%%expect ocaml {|module Common : sig type t = { session_id : string; time : Time_ns.t; } end|}];;
[@@@part "7"];;
let messages_for_user user (messages : (Common.t * details) list) =
  let (user_messages,_) =
    List.fold messages ~init:([],String.Set.empty)
      ~f:(fun ((messages,user_sessions) as acc) ((common,details) as message) ->
        match details with
        | Logon m ->
          if m.user = user then
            (message::messages, Set.add user_sessions common.session_id)
          else acc
        | Heartbeat _ | Log_entry _ ->
          if Set.mem user_sessions common.session_id then
            (message::messages, user_sessions)
          else acc
      )
  in
  List.rev user_messages
;;
[%%expect ocaml {|
val messages_for_user :
  string -> (Common.t * details) list -> (Common.t * details) list = <fun>
|}];;
[@@@part "7.9"];;
type server_state;;
[%%expect ocaml {|type server_state|}];;
let handle_log_entry (_:server_state) ((_:Common.t),_) = ();;
[%%expect ocaml {|val handle_log_entry : server_state -> Common.t * 'a -> unit = <fun>|}];;
let handle_logon _ (_,_) = ();;
[%%expect ocaml {|val handle_logon : 'a -> 'b * 'c -> unit = <fun>|}];;
let handle_heartbeat _ (_,_) = ();;
[%%expect ocaml {|val handle_heartbeat : 'a -> 'b * 'c -> unit = <fun>|}];;
[@@@part "8"];;
let handle_message server_state (common,details) =
  match details with
  | Log_entry m -> handle_log_entry server_state (common,m)
  | Logon     m -> handle_logon     server_state (common,m)
  | Heartbeat m -> handle_heartbeat server_state (common,m)
;;
[%%expect ocaml {|val handle_message : server_state -> Common.t * details -> unit = <fun>|}];;
[@@@part "9"];;
type details =
  | Logon     of { user: string; credentials: string; }
  | Heartbeat of { status_message: string; }
  | Log_entry of { important: bool; message: string; }
;;
[%%expect ocaml {|
type details =
    Logon of { user : string; credentials : string; }
  | Heartbeat of { status_message : string; }
  | Log_entry of { important : bool; message : string; }
|}];;
[@@@part "10"];;
let messages_for_user user (messages : (Common.t * details) list) =
  let (user_messages,_) =
    List.fold messages ~init:([],String.Set.empty)
      ~f:(fun ((messages,user_sessions) as acc) ((common,details) as message) ->
        match details with
        | Logon m ->
          if m.user = user then
            (message::messages, Set.add user_sessions common.session_id)
          else acc
        | Heartbeat _ | Log_entry _ ->
          if Set.mem user_sessions common.session_id then
            (message::messages, user_sessions)
          else acc
      )
  in
  List.rev user_messages
;;
[%%expect ocaml {|
val messages_for_user :
  string -> (Common.t * details) list -> (Common.t * details) list = <fun>
|}];;
[@@@part "11"];;
let get_logon_contents = function
  | Logon m -> Some m
  | _ -> None
;;
[%%expect{|
Characters 54-55:
Error: This form is not allowed as the type of the inlined record could escape.
|}];;
