#use "topfind";;
[%%expect ocaml {|
- : unit = ()
- : unit = ()
|}];;
#thread;;
#camlp4o;;
#require "core";;
#require "ppx_jane";;

[@@@part "1"];;
open Core_kernel;;
let digit_alist =
  [ 0, "zero"; 1, "one"; 2, "two"  ; 3, "three"; 4, "four"
  ; 5, "five"; 6, "six"; 7, "seven"; 8, "eight"; 9, "nine" ]
;;
[%%expect ocaml {|
val digit_alist : (int * string) list =
  [(0, "zero"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
   (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
|}];;

[@@@part "2"];;
List.Assoc.find ~equal:Int.equal digit_alist 6;;
[%%expect ocaml {|- : string option = Some "six"|}];;
List.Assoc.find ~equal:Int.equal digit_alist 22;;
[%%expect ocaml {|- : string option = None|}];;
List.Assoc.add ~equal:Int.equal digit_alist 0 "zilch";;
[%%expect ocaml {|
- : (int, string) Base__List.Assoc.t =
[(0, "zilch"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
 (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
|}];;

[@@@part "3"];;
let digit_map = Map.of_alist_exn digit_alist ~comparator:Int.comparator;;
[%%expect ocaml {|val digit_map : (int, string, Int.comparator_witness) Map.t = <abstr>|}];;
Map.find digit_map 3;;
[%%expect ocaml {|- : string option = Some "three"|}];;

[@@@part "4"];;
let zilch_map = Map.add digit_map ~key:0 ~data:"zilch";;
[%%expect ocaml {|val zilch_map : (int, string, Int.comparator_witness) Map.t = <abstr>|}];;

[@@@part "5"];;
let left = String.Map.of_alist_exn ["foo",1; "bar",3; "snoo",0];;
[%%expect ocaml {|val left : int String.Map.t = <abstr>|}];;
let right = String.Map.of_alist_exn ["foo",0; "snoo",0];;
[%%expect ocaml {|val right : int String.Map.t = <abstr>|}];;
Map.symmetric_diff ~data_equal:Int.equal left right |> Sequence.to_list;;
[%%expect ocaml {|
- : (string, int) Map.Symmetric_diff_element.t list =
[("bar", `Left 3); ("foo", `Unequal (1, 0))]
|}];;

[@@@part "6"];;
Map.symmetric_diff;;
[%%expect ocaml {|
- : ('k, 'v, 'cmp) Map.t ->
    ('k, 'v, 'cmp) Map.t ->
    data_equal:('v -> 'v -> bool) ->
    ('k, 'v) Map.Symmetric_diff_element.t Sequence.t
= <fun>
|}];;

[@@@part "7"];;
module Reverse = Comparator.Make(struct
    type t = string
    let sexp_of_t = String.sexp_of_t
    let t_of_sexp = String.t_of_sexp
    let compare x y = String.compare y x
  end);;
[%%expect ocaml {|
module Reverse :
  sig
    type comparator_witness
    val comparator : (string, comparator_witness) Comparator.t
  end
|}];;

[@@@part "8"];;
let alist = ["foo", 0; "snoo", 3];;
[%%expect ocaml {|val alist : (string * int) list = [("foo", 0); ("snoo", 3)]|}];;
let ord_map = Map.of_alist_exn ~comparator:String.comparator alist;;
[%%expect ocaml {|val ord_map : (string, int, String.comparator_witness) Map.t = <abstr>|}];;
let rev_map = Map.of_alist_exn ~comparator:Reverse.comparator alist;;
[%%expect ocaml {|val rev_map : (string, int, Reverse.comparator_witness) Map.t = <abstr>|}];;

[@@@part "9"];;
Map.min_elt ord_map;;
[%%expect ocaml {|- : (string * int) option = Some ("foo", 0)|}];;
Map.min_elt rev_map;;
[%%expect ocaml {|- : (string * int) option = Some ("snoo", 3)|}];;

[@@@part "10"];;
Map.symmetric_diff ord_map rev_map;;
[%%expect{|
Characters 27-34:
Error: This expression has type
         (string, int, Reverse.comparator_witness) Map.t
       but an expression was expected of type
         (string, int, String.comparator_witness) Map.t
       Type Reverse.comparator_witness is not compatible with type
         String.comparator_witness 
|}];;

[@@@part "11"];;
let ord_tree = Map.to_tree ord_map;;
[%%expect ocaml {|
val ord_tree : (string, int, String.comparator_witness) Map_intf.Tree.t =
  <abstr>
|}];;

[@@@part "12"];;
Map.Tree.find ~comparator:String.comparator ord_tree "snoo";;
[%%expect ocaml {|- : int option = Some 3|}];;

[@@@part "13"];;
Map.Tree.find ~comparator:Reverse.comparator ord_tree "snoo";;
[%%expect{|
Characters 45-53:
Error: This expression has type
         (string, int, String.comparator_witness) Map_intf.Tree.t
       but an expression was expected of type
         (string, int, Reverse.comparator_witness) Map_intf.Tree.t
       Type String.comparator_witness is not compatible with type
         Reverse.comparator_witness 
|}];;

[@@@part "14"];;
Map.of_alist_exn ~comparator:Comparator.Poly.comparator digit_alist;;
[%%expect ocaml {|- : (int, string, Comparator.Poly.comparator_witness) Map.t = <abstr>|}];;

[@@@part "15"];;
Map.Poly.of_alist_exn digit_alist;;
[%%expect ocaml {|- : (int, string) Map.Poly.t = <abstr>|}];;

[@@@part "16"];;
Map.symmetric_diff
  (Map.Poly.singleton 3 "three")
  (Int.Map.singleton  3 "four" )
;;
[%%expect{|
Characters 54-84:
Error: This expression has type
         string Int.Map.t = (int, string, Int.comparator_witness) Map.t
       but an expression was expected of type
         (int, string, Comparator.Poly.comparator_witness) Map.t
       Type Int.comparator_witness is not compatible with type
         Comparator.Poly.comparator_witness 
|}];;

[@@@part "17"];;
let dedup ~comparator l =
  List.fold l ~init:(Set.empty ~comparator) ~f:Set.add
  |> Set.to_list
;;
[%%expect ocaml {|val dedup : comparator:('a, 'b) Comparator.t -> 'a list -> 'a list = <fun>|}];;
dedup ~comparator:Int.comparator [8;3;2;3;7;8;10];;
[%%expect ocaml {|- : int list = [2; 3; 7; 8; 10]|}];;

[@@@part "18"];;
let s1 = Int.Set.of_list [1;2];;
[%%expect ocaml {|val s1 : Int.Set.t = <abstr>|}];;
let s2 = Int.Set.of_list [2;1];;
[%%expect ocaml {|val s2 : Int.Set.t = <abstr>|}];;

[@@@part "19"];;
Set.equal s1 s2;;
[%%expect ocaml {|- : bool = true|}];;

[@@@part "20"];;
s1 = s2;;
[%%expect{|Exception: Invalid_argument "compare: functional value".|}];;

[@@@part "21"];;
Set.to_tree s1 = Set.to_tree s2;;
[%%expect ocaml {|- : bool = false|}];;

[@@@part "22"];;
module Foo_and_bar : sig
  type t = { foo: Int.Set.t; bar: string }
  include Comparable.S with type t := t
end = struct
  module T = struct
    type t = { foo: Int.Set.t; bar: string } [@@deriving sexp]
    let compare t1 t2 =
      let c = Int.Set.compare t1.foo t2.foo in
      if c <> 0 then c else String.compare t1.bar t2.bar
  end
  include T
  include Comparable.Make(T)
end;;
[%%expect ocaml {|
module Foo_and_bar :
  sig
    type t = { foo : Int.Set.t; bar : string; }
    val ( >= ) : t -> t -> bool
    val ( <= ) : t -> t -> bool
    val ( = ) : t -> t -> bool
    val ( > ) : t -> t -> bool
    val ( < ) : t -> t -> bool
    val ( <> ) : t -> t -> bool
    val equal : t -> t -> bool
    val compare : t -> t -> int
    val min : t -> t -> t
    val max : t -> t -> t
    val ascending : t -> t -> int
    val descending : t -> t -> int
    val between : t -> low:t -> high:t -> bool
    val clamp_exn : t -> min:t -> max:t -> t
    val clamp : t -> min:t -> max:t -> t Base__.Or_error.t
    type comparator_witness
    val comparator : (t, comparator_witness) Comparator.t
    val validate_lbound : min:t Core_kernel._maybe_bound -> t Validate.check
    val validate_ubound : max:t Core_kernel._maybe_bound -> t Validate.check
    val validate_bound :
      min:t Core_kernel._maybe_bound ->
      max:t Core_kernel._maybe_bound -> t Validate.check
    module Replace_polymorphic_compare :
      sig
        val ( >= ) : t -> t -> bool
        val ( <= ) : t -> t -> bool
        val ( = ) : t -> t -> bool
        val ( > ) : t -> t -> bool
        val ( < ) : t -> t -> bool
        val ( <> ) : t -> t -> bool
        val equal : t -> t -> bool
        val compare : t -> t -> int
        val min : t -> t -> t
        val max : t -> t -> t
      end
    module Map :
      sig
        module Key :
          sig
            type t = t
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
            type comparator_witness = comparator_witness
            val comparator : (t, comparator_witness) Comparator.t
          end
        module Tree :
          sig
            type 'a t = (Key.t, 'a, comparator_witness) Map_intf.Tree.t
            val empty : 'a t
            val singleton : Key.t -> 'a -> 'a t
            val of_alist :
              (Key.t * 'a) list -> [ `Duplicate_key of Key.t | `Ok of 'a t ]
            val of_alist_or_error :
              (Key.t * 'a) list -> 'a t Base__.Or_error.t
            val of_alist_exn : (Key.t * 'a) list -> 'a t
            val of_alist_multi : (Key.t * 'a) list -> 'a list t
            val of_alist_fold :
              (Key.t * 'a) list -> init:'b -> f:('b -> 'a -> 'b) -> 'b t
            val of_alist_reduce :
              (Key.t * 'a) list -> f:('a -> 'a -> 'a) -> 'a t
            val of_sorted_array :
              (Key.t * 'a) array -> 'a t Base__.Or_error.t
            val of_sorted_array_unchecked : (Key.t * 'a) array -> 'a t
            val of_increasing_iterator_unchecked :
              len:int -> f:(int -> Key.t * 'a) -> 'a t
            val of_iteri :
              iteri:(f:(key:Key.t -> data:'v -> unit) -> unit) ->
              [ `Duplicate_key of Key.t | `Ok of 'v t ]
            val of_tree : 'a t -> 'a t
            val of_hashtbl_exn : (Key.t, 'a) Hashtbl.t -> 'a t
            val gen :
              Key.t Quickcheck.Generator.t ->
              'a Quickcheck.Generator.t -> 'a t Quickcheck.Generator.t
            val invariants : 'a t -> bool
            val is_empty : 'a t -> bool
            val length : 'a t -> int
            val add : 'a t -> key:Key.t -> data:'a -> 'a t
            val add_multi : 'a list t -> key:Key.t -> data:'a -> 'a list t
            val remove_multi : 'a list t -> Key.t -> 'a list t
            val find_multi : 'a list t -> Key.t -> 'a list
            val change : 'a t -> Key.t -> f:('a option -> 'a option) -> 'a t
            val update : 'a t -> Key.t -> f:('a option -> 'a) -> 'a t
            val find : 'a t -> Key.t -> 'a option
            val find_exn : 'a t -> Key.t -> 'a
            val remove : 'a t -> Key.t -> 'a t
            val mem : 'a t -> Key.t -> bool
            val iter_keys : 'a t -> f:(Key.t -> unit) -> unit
            val iter : 'a t -> f:('a -> unit) -> unit
            val iteri : 'a t -> f:(key:Key.t -> data:'a -> unit) -> unit
            val iter2 :
              'a t ->
              'b t ->
              f:(key:Key.t ->
                 data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 unit) ->
              unit
            val map : 'a t -> f:('a -> 'b) -> 'b t
            val mapi : 'a t -> f:(key:Key.t -> data:'a -> 'b) -> 'b t
            val fold :
              'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val fold_right :
              'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val fold2 :
              'a t ->
              'b t ->
              init:'c ->
              f:(key:Key.t ->
                 data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 'c -> 'c) ->
              'c
            val filter_keys : 'a t -> f:(Key.t -> bool) -> 'a t
            val filter : 'a t -> f:('a -> bool) -> 'a t
            val filteri : 'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t
            val filter_map : 'a t -> f:('a -> 'b option) -> 'b t
            val filter_mapi :
              'a t -> f:(key:Key.t -> data:'a -> 'b option) -> 'b t
            val partition_mapi :
              'a t ->
              f:(key:Key.t -> data:'a -> [ `Fst of 'b | `Snd of 'c ]) ->
              'b t * 'c t
            val partition_map :
              'a t -> f:('a -> [ `Fst of 'b | `Snd of 'c ]) -> 'b t * 'c t
            val partitioni_tf :
              'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t * 'a t
            val partition_tf : 'a t -> f:('a -> bool) -> 'a t * 'a t
            val compare_direct : ('a -> 'a -> int) -> 'a t -> 'a t -> int
            val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
            val keys : 'a t -> Key.t list
            val data : 'a t -> 'a list
            val to_alist :
              ?key_order:[ `Decreasing | `Increasing ] ->
              'a t -> (Key.t * 'a) list
            val validate :
              name:(Key.t -> string) ->
              'a Validate.check -> 'a t Validate.check
            val merge :
              'a t ->
              'b t ->
              f:(key:Key.t ->
                 [ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 'c option) ->
              'c t
            val symmetric_diff :
              'a t ->
              'a t ->
              data_equal:('a -> 'a -> bool) ->
              (Key.t, 'a) Base.Map_intf.Symmetric_diff_element.t Sequence.t
            val min_elt : 'a t -> (Key.t * 'a) option
            val min_elt_exn : 'a t -> Key.t * 'a
            val max_elt : 'a t -> (Key.t * 'a) option
            val max_elt_exn : 'a t -> Key.t * 'a
            val for_all : 'a t -> f:('a -> bool) -> bool
            val for_alli : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
            val exists : 'a t -> f:('a -> bool) -> bool
            val existsi : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
            val count : 'a t -> f:('a -> bool) -> int
            val counti : 'a t -> f:(key:Key.t -> data:'a -> bool) -> int
            val split : 'a t -> Key.t -> 'a t * (Key.t * 'a) option * 'a t
            val append :
              lower_part:'a t ->
              upper_part:'a t -> [ `Ok of 'a t | `Overlapping_key_ranges ]
            val subrange :
              'a t ->
              lower_bound:Key.t Core_kernel._maybe_bound ->
              upper_bound:Key.t Core_kernel._maybe_bound -> 'a t
            val fold_range_inclusive :
              'a t ->
              min:Key.t ->
              max:Key.t ->
              init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val range_to_alist :
              'a t -> min:Key.t -> max:Key.t -> (Key.t * 'a) list
            val closest_key :
              'a t ->
              [ `Greater_or_equal_to
              | `Greater_than
              | `Less_or_equal_to
              | `Less_than ] -> Key.t -> (Key.t * 'a) option
            val nth : 'a t -> int -> (Key.t * 'a) option
            val nth_exn : 'a t -> int -> Key.t * 'a
            val rank : 'a t -> Key.t -> int option
            val to_tree : 'a t -> 'a t
            val to_sequence :
              ?order:[ `Decreasing_key | `Increasing_key ] ->
              ?keys_greater_or_equal_to:Key.t ->
              ?keys_less_or_equal_to:Key.t -> 'a t -> (Key.t * 'a) Sequence.t
            val obs :
              Key.t Quickcheck.Observer.t ->
              'v Quickcheck.Observer.t -> 'v t Quickcheck.Observer.t
            val shrinker :
              Key.t Quickcheck.Shrinker.t ->
              'v Quickcheck.Shrinker.t -> 'v t Quickcheck.Shrinker.t
            module Provide_of_sexp :
              functor (K : sig val t_of_sexp : Sexp.t -> Key.t end) ->
                sig
                  val t_of_sexp :
                    (Sexp.t -> 'v_x__017_) -> Sexp.t -> 'v_x__017_ t
                end
            val t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a t
            val sexp_of_t : ('a -> Sexp.t) -> 'a t -> Sexp.t
          end
        type 'a t = (Key.t, 'a, comparator_witness) Map.t
        val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
        val empty : 'a t
        val singleton : Key.t -> 'a -> 'a t
        val of_alist :
          (Key.t * 'a) list -> [ `Duplicate_key of Key.t | `Ok of 'a t ]
        val of_alist_or_error : (Key.t * 'a) list -> 'a t Base__.Or_error.t
        val of_alist_exn : (Key.t * 'a) list -> 'a t
        val of_alist_multi : (Key.t * 'a) list -> 'a list t
        val of_alist_fold :
          (Key.t * 'a) list -> init:'b -> f:('b -> 'a -> 'b) -> 'b t
        val of_alist_reduce : (Key.t * 'a) list -> f:('a -> 'a -> 'a) -> 'a t
        val of_sorted_array : (Key.t * 'a) array -> 'a t Base__.Or_error.t
        val of_sorted_array_unchecked : (Key.t * 'a) array -> 'a t
        val of_increasing_iterator_unchecked :
          len:int -> f:(int -> Key.t * 'a) -> 'a t
        val of_iteri :
          iteri:(f:(key:Key.t -> data:'v -> unit) -> unit) ->
          [ `Duplicate_key of Key.t | `Ok of 'v t ]
        val of_tree : 'a Tree.t -> 'a t
        val of_hashtbl_exn : (Key.t, 'a) Hashtbl.t -> 'a t
        val gen :
          Key.t Quickcheck.Generator.t ->
          'a Quickcheck.Generator.t -> 'a t Quickcheck.Generator.t
        val invariants : 'a t -> bool
        val is_empty : 'a t -> bool
        val length : 'a t -> int
        val add : 'a t -> key:Key.t -> data:'a -> 'a t
        val add_multi : 'a list t -> key:Key.t -> data:'a -> 'a list t
        val remove_multi : 'a list t -> Key.t -> 'a list t
        val find_multi : 'a list t -> Key.t -> 'a list
        val change : 'a t -> Key.t -> f:('a option -> 'a option) -> 'a t
        val update : 'a t -> Key.t -> f:('a option -> 'a) -> 'a t
        val find : 'a t -> Key.t -> 'a option
        val find_exn : 'a t -> Key.t -> 'a
        val remove : 'a t -> Key.t -> 'a t
        val mem : 'a t -> Key.t -> bool
        val iter_keys : 'a t -> f:(Key.t -> unit) -> unit
        val iter : 'a t -> f:('a -> unit) -> unit
        val iteri : 'a t -> f:(key:Key.t -> data:'a -> unit) -> unit
        val iter2 :
          'a t ->
          'b t ->
          f:(key:Key.t ->
             data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] -> unit) ->
          unit
        val map : 'a t -> f:('a -> 'b) -> 'b t
        val mapi : 'a t -> f:(key:Key.t -> data:'a -> 'b) -> 'b t
        val fold :
          'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val fold_right :
          'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val fold2 :
          'a t ->
          'b t ->
          init:'c ->
          f:(key:Key.t ->
             data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
             'c -> 'c) ->
          'c
        val filter_keys : 'a t -> f:(Key.t -> bool) -> 'a t
        val filter : 'a t -> f:('a -> bool) -> 'a t
        val filteri : 'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t
        val filter_map : 'a t -> f:('a -> 'b option) -> 'b t
        val filter_mapi :
          'a t -> f:(key:Key.t -> data:'a -> 'b option) -> 'b t
        val partition_mapi :
          'a t ->
          f:(key:Key.t -> data:'a -> [ `Fst of 'b | `Snd of 'c ]) ->
          'b t * 'c t
        val partition_map :
          'a t -> f:('a -> [ `Fst of 'b | `Snd of 'c ]) -> 'b t * 'c t
        val partitioni_tf :
          'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t * 'a t
        val partition_tf : 'a t -> f:('a -> bool) -> 'a t * 'a t
        val compare_direct : ('a -> 'a -> int) -> 'a t -> 'a t -> int
        val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
        val keys : 'a t -> Key.t list
        val data : 'a t -> 'a list
        val to_alist :
          ?key_order:[ `Decreasing | `Increasing ] ->
          'a t -> (Key.t * 'a) list
        val validate :
          name:(Key.t -> string) -> 'a Validate.check -> 'a t Validate.check
        val merge :
          'a t ->
          'b t ->
          f:(key:Key.t ->
             [ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] -> 'c option) ->
          'c t
        val symmetric_diff :
          'a t ->
          'a t ->
          data_equal:('a -> 'a -> bool) ->
          (Key.t, 'a) Base.Map_intf.Symmetric_diff_element.t Sequence.t
        val min_elt : 'a t -> (Key.t * 'a) option
        val min_elt_exn : 'a t -> Key.t * 'a
        val max_elt : 'a t -> (Key.t * 'a) option
        val max_elt_exn : 'a t -> Key.t * 'a
        val for_all : 'a t -> f:('a -> bool) -> bool
        val for_alli : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
        val exists : 'a t -> f:('a -> bool) -> bool
        val existsi : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
        val count : 'a t -> f:('a -> bool) -> int
        val counti : 'a t -> f:(key:Key.t -> data:'a -> bool) -> int
        val split : 'a t -> Key.t -> 'a t * (Key.t * 'a) option * 'a t
        val append :
          lower_part:'a t ->
          upper_part:'a t -> [ `Ok of 'a t | `Overlapping_key_ranges ]
        val subrange :
          'a t ->
          lower_bound:Key.t Core_kernel._maybe_bound ->
          upper_bound:Key.t Core_kernel._maybe_bound -> 'a t
        val fold_range_inclusive :
          'a t ->
          min:Key.t ->
          max:Key.t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val range_to_alist :
          'a t -> min:Key.t -> max:Key.t -> (Key.t * 'a) list
        val closest_key :
          'a t ->
          [ `Greater_or_equal_to
          | `Greater_than
          | `Less_or_equal_to
          | `Less_than ] -> Key.t -> (Key.t * 'a) option
        val nth : 'a t -> int -> (Key.t * 'a) option
        val nth_exn : 'a t -> int -> Key.t * 'a
        val rank : 'a t -> Key.t -> int option
        val to_tree : 'a t -> 'a Tree.t
        val to_sequence :
          ?order:[ `Decreasing_key | `Increasing_key ] ->
          ?keys_greater_or_equal_to:Key.t ->
          ?keys_less_or_equal_to:Key.t -> 'a t -> (Key.t * 'a) Sequence.t
        val obs :
          Key.t Quickcheck.Observer.t ->
          'v Quickcheck.Observer.t -> 'v t Quickcheck.Observer.t
        val shrinker :
          Key.t Quickcheck.Shrinker.t ->
          'v Quickcheck.Shrinker.t -> 'v t Quickcheck.Shrinker.t
        module Provide_of_sexp :
          functor (Key : sig val t_of_sexp : Sexp.t -> Key.t end) ->
            sig
              val t_of_sexp :
                (Sexp.t -> 'v_x__018_) -> Sexp.t -> 'v_x__018_ t
            end
        module Provide_bin_io :
          functor
            (Key : sig
                     val bin_t : Key.t Bin_prot.Type_class.t0
                     val bin_read_t : Key.t Bin_prot.Read.reader
                     val __bin_read_t__ : (int -> Key.t) Bin_prot.Read.reader
                     val bin_reader_t : Key.t Bin_prot.Type_class.reader0
                     val bin_size_t : Key.t Bin_prot.Size.sizer
                     val bin_write_t : Key.t Bin_prot.Write.writer
                     val bin_writer_t : Key.t Bin_prot.Type_class.writer0
                     val bin_shape_t : Bin_prot.Shape.t
                   end) ->
            sig
              val bin_shape_t : Bin_prot.Shape.t -> Bin_prot.Shape.t
              val bin_size_t : ('a, 'a t) Bin_prot.Size.sizer1
              val bin_write_t : ('a, 'a t) Bin_prot.Write.writer1
              val bin_read_t : ('a, 'a t) Bin_prot.Read.reader1
              val __bin_read_t__ : ('a, int -> 'a t) Bin_prot.Read.reader1
              val bin_writer_t : ('a, 'a t) Bin_prot.Type_class.S1.writer
              val bin_reader_t : ('a, 'a t) Bin_prot.Type_class.S1.reader
              val bin_t : ('a, 'a t) Bin_prot.Type_class.S1.t
            end
        module Provide_hash :
          functor
            (Key : sig
                     val hash_fold_t : Hash.state -> Key.t -> Hash.state
                   end) ->
            sig
              val hash_fold_t :
                (Hash.state -> 'a -> Hash.state) ->
                Hash.state -> 'a t -> Hash.state
            end
        val t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a t
        val sexp_of_t : ('a -> Sexp.t) -> 'a t -> Sexp.t
      end
    module Set :
      sig
        module Elt :
          sig
            type t = Map.Key.t
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
            type comparator_witness = Map.Key.comparator_witness
            val comparator : (t, comparator_witness) Comparator.t
          end
        module Tree :
          sig
            type t = (Elt.t, comparator_witness) Set_intf.Tree.t
            val compare : t -> t -> int
            val length : t -> int
            val is_empty : t -> bool
            val iter : t -> f:(Elt.t -> unit) -> unit
            val fold :
              t -> init:'accum -> f:('accum -> Elt.t -> 'accum) -> 'accum
            val fold_result :
              t ->
              init:'accum ->
              f:('accum -> Elt.t -> ('accum, 'e) result) ->
              ('accum, 'e) result
            val exists : t -> f:(Elt.t -> bool) -> bool
            val for_all : t -> f:(Elt.t -> bool) -> bool
            val count : t -> f:(Elt.t -> bool) -> int
            val sum :
              (module Base__.Commutative_group.S with type t = 'sum) ->
              t -> f:(Elt.t -> 'sum) -> 'sum
            val find : t -> f:(Elt.t -> bool) -> Elt.t option
            val find_map : t -> f:(Elt.t -> 'a option) -> 'a option
            val to_list : t -> Elt.t list
            val to_array : t -> Elt.t array
            val invariants : t -> bool
            val mem : t -> Elt.t -> bool
            val add : t -> Elt.t -> t
            val remove : t -> Elt.t -> t
            val union : t -> t -> t
            val inter : t -> t -> t
            val diff : t -> t -> t
            val symmetric_diff :
              t -> t -> (Elt.t, Elt.t) Core_kernel._either Sequence.t
            val compare_direct : t -> t -> int
            val equal : t -> t -> bool
            val is_subset : t -> of_:t -> bool
            val subset : t -> t -> bool
            val fold_until :
              t ->
              init:'b ->
              f:('b -> Elt.t -> ('b, 'stop) Set_intf.Continue_or_stop.t) ->
              ('b, 'stop) Set_intf.Finished_or_stopped_early.t
            val fold_right : t -> init:'b -> f:(Elt.t -> 'b -> 'b) -> 'b
            val iter2 :
              t ->
              t ->
              f:([ `Both of Elt.t * Elt.t | `Left of Elt.t | `Right of Elt.t ] ->
                 unit) ->
              unit
            val filter : t -> f:(Elt.t -> bool) -> t
            val partition_tf : t -> f:(Elt.t -> bool) -> t * t
            val elements : t -> Elt.t list
            val min_elt : t -> Elt.t option
            val min_elt_exn : t -> Elt.t
            val max_elt : t -> Elt.t option
            val max_elt_exn : t -> Elt.t
            val choose : t -> Elt.t option
            val choose_exn : t -> Elt.t
            val split : t -> Elt.t -> t * Elt.t option * t
            val group_by : t -> equiv:(Elt.t -> Elt.t -> bool) -> t list
            val find_exn : t -> f:(Elt.t -> bool) -> Elt.t
            val find_index : t -> int -> Elt.t option
            val nth : t -> int -> Elt.t option
            val remove_index : t -> int -> t
            val to_tree : t -> t
            val to_sequence :
              ?order:[ `Decreasing | `Increasing ] ->
              ?greater_or_equal_to:Elt.t ->
              ?less_or_equal_to:Elt.t -> t -> Elt.t Sequence.t
            val merge_to_sequence :
              ?order:[ `Decreasing | `Increasing ] ->
              ?greater_or_equal_to:Elt.t ->
              ?less_or_equal_to:Elt.t ->
              t ->
              t ->
              (Elt.t, Elt.t) Set_intf.Merge_to_sequence_element.t Sequence.t
            val to_map :
              t ->
              f:(Elt.t -> 'data) ->
              (Elt.t, 'data, comparator_witness) Core_kernel.Map.t
            val obs : Elt.t Quickcheck.Observer.t -> t Quickcheck.Observer.t
            val shrinker :
              Elt.t Quickcheck.Shrinker.t -> t Quickcheck.Shrinker.t
            val empty : t
            val singleton : Elt.t -> t
            val union_list : t list -> t
            val of_list : Elt.t list -> t
            val of_array : Elt.t array -> t
            val of_sorted_array : Elt.t array -> t Base__.Or_error.t
            val of_sorted_array_unchecked : Elt.t array -> t
            val of_increasing_iterator_unchecked :
              len:int -> f:(int -> Elt.t) -> t
            val stable_dedup_list : Elt.t list -> Elt.t list
            val map : ('a, 'b) Set_intf.Tree.t -> f:('a -> Elt.t) -> t
            val filter_map :
              ('a, 'b) Set_intf.Tree.t -> f:('a -> Elt.t option) -> t
            val of_tree : t -> t
            val of_hash_set : Elt.t Hash_set.t -> t
            val of_hashtbl_keys : (Elt.t, 'a) Hashtbl.t -> t
            val of_map_keys :
              (Elt.t, 'a, comparator_witness) Core_kernel.Map.t -> t
            val gen :
              Elt.t Quickcheck.Generator.t -> t Quickcheck.Generator.t
            module Provide_of_sexp :
              functor (Elt : sig val t_of_sexp : Sexp.t -> Elt.t end) ->
                sig val t_of_sexp : Sexp.t -> t end
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
          end
        type t = (Elt.t, comparator_witness) Set.t
        val compare : t -> t -> int
        val length : t -> int
        val is_empty : t -> bool
        val iter : t -> f:(Elt.t -> unit) -> unit
        val fold :
          t -> init:'accum -> f:('accum -> Elt.t -> 'accum) -> 'accum
        val fold_result :
          t ->
          init:'accum ->
          f:('accum -> Elt.t -> ('accum, 'e) result) -> ('accum, 'e) result
        val exists : t -> f:(Elt.t -> bool) -> bool
        val for_all : t -> f:(Elt.t -> bool) -> bool
        val count : t -> f:(Elt.t -> bool) -> int
        val sum :
          (module Base__.Commutative_group.S with type t = 'sum) ->
          t -> f:(Elt.t -> 'sum) -> 'sum
        val find : t -> f:(Elt.t -> bool) -> Elt.t option
        val find_map : t -> f:(Elt.t -> 'a option) -> 'a option
        val to_list : t -> Elt.t list
        val to_array : t -> Elt.t array
        val invariants : t -> bool
        val mem : t -> Elt.t -> bool
        val add : t -> Elt.t -> t
        val remove : t -> Elt.t -> t
        val union : t -> t -> t
        val inter : t -> t -> t
        val diff : t -> t -> t
        val symmetric_diff :
          t -> t -> (Elt.t, Elt.t) Core_kernel._either Sequence.t
        val compare_direct : t -> t -> int
        val equal : t -> t -> bool
        val is_subset : t -> of_:t -> bool
        val subset : t -> t -> bool
        val fold_until :
          t ->
          init:'b ->
          f:('b -> Elt.t -> ('b, 'stop) Set_intf.Continue_or_stop.t) ->
          ('b, 'stop) Set_intf.Finished_or_stopped_early.t
        val fold_right : t -> init:'b -> f:(Elt.t -> 'b -> 'b) -> 'b
        val iter2 :
          t ->
          t ->
          f:([ `Both of Elt.t * Elt.t | `Left of Elt.t | `Right of Elt.t ] ->
             unit) ->
          unit
        val filter : t -> f:(Elt.t -> bool) -> t
        val partition_tf : t -> f:(Elt.t -> bool) -> t * t
        val elements : t -> Elt.t list
        val min_elt : t -> Elt.t option
        val min_elt_exn : t -> Elt.t
        val max_elt : t -> Elt.t option
        val max_elt_exn : t -> Elt.t
        val choose : t -> Elt.t option
        val choose_exn : t -> Elt.t
        val split : t -> Elt.t -> t * Elt.t option * t
        val group_by : t -> equiv:(Elt.t -> Elt.t -> bool) -> t list
        val find_exn : t -> f:(Elt.t -> bool) -> Elt.t
        val find_index : t -> int -> Elt.t option
        val nth : t -> int -> Elt.t option
        val remove_index : t -> int -> t
        val to_tree : t -> Tree.t
        val to_sequence :
          ?order:[ `Decreasing | `Increasing ] ->
          ?greater_or_equal_to:Elt.t ->
          ?less_or_equal_to:Elt.t -> t -> Elt.t Sequence.t
        val merge_to_sequence :
          ?order:[ `Decreasing | `Increasing ] ->
          ?greater_or_equal_to:Elt.t ->
          ?less_or_equal_to:Elt.t ->
          t ->
          t -> (Elt.t, Elt.t) Set_intf.Merge_to_sequence_element.t Sequence.t
        val to_map :
          t ->
          f:(Elt.t -> 'data) ->
          (Elt.t, 'data, comparator_witness) Core_kernel.Map.t
        val obs : Elt.t Quickcheck.Observer.t -> t Quickcheck.Observer.t
        val shrinker : Elt.t Quickcheck.Shrinker.t -> t Quickcheck.Shrinker.t
        val empty : t
        val singleton : Elt.t -> t
        val union_list : t list -> t
        val of_list : Elt.t list -> t
        val of_array : Elt.t array -> t
        val of_sorted_array : Elt.t array -> t Base__.Or_error.t
        val of_sorted_array_unchecked : Elt.t array -> t
        val of_increasing_iterator_unchecked :
          len:int -> f:(int -> Elt.t) -> t
        val stable_dedup_list : Elt.t list -> Elt.t list
        val map : ('a, 'b) Set.t -> f:('a -> Elt.t) -> t
        val filter_map : ('a, 'b) Set.t -> f:('a -> Elt.t option) -> t
        val of_tree : Tree.t -> t
        val of_hash_set : Elt.t Hash_set.t -> t
        val of_hashtbl_keys : (Elt.t, 'a) Hashtbl.t -> t
        val of_map_keys :
          (Elt.t, 'a, comparator_witness) Core_kernel.Map.t -> t
        val gen : Elt.t Quickcheck.Generator.t -> t Quickcheck.Generator.t
        module Provide_of_sexp :
          functor (Elt : sig val t_of_sexp : Sexp.t -> Elt.t end) ->
            sig val t_of_sexp : Sexp.t -> t end
        module Provide_bin_io :
          functor
            (Elt : sig
                     val bin_t : Elt.t Bin_prot.Type_class.t0
                     val bin_read_t : Elt.t Bin_prot.Read.reader
                     val __bin_read_t__ : (int -> Elt.t) Bin_prot.Read.reader
                     val bin_reader_t : Elt.t Bin_prot.Type_class.reader0
                     val bin_size_t : Elt.t Bin_prot.Size.sizer
                     val bin_write_t : Elt.t Bin_prot.Write.writer
                     val bin_writer_t : Elt.t Bin_prot.Type_class.writer0
                     val bin_shape_t : Bin_prot.Shape.t
                   end) ->
            sig
              val bin_size_t : t Bin_prot.Size.sizer
              val bin_write_t : t Bin_prot.Write.writer
              val bin_read_t : t Bin_prot.Read.reader
              val __bin_read_t__ : (int -> t) Bin_prot.Read.reader
              val bin_shape_t : Bin_prot.Shape.t
              val bin_writer_t : t Bin_prot.Type_class.writer0
              val bin_reader_t : t Bin_prot.Type_class.reader0
              val bin_t : t Bin_prot.Type_class.t0
            end
        module Provide_hash :
          functor
            (Elt : sig
                     val hash_fold_t : Hash.state -> Elt.t -> Hash.state
                   end) ->
            sig
              val hash_fold_t : Hash.state -> t -> Hash.state
              val hash : t -> int
            end
        val t_of_sexp : Sexp.t -> t
        val sexp_of_t : t -> Sexp.t
      end
  end
|}];;

[@@@part "23"];;
module Foo_and_bar : sig
  type t = { foo: Int.Set.t; bar: string }
  include Comparable.S with type t := t
end = struct
  module T = struct
    type t = { foo: Int.Set.t; bar: string } [@@deriving sexp, compare]
  end
  include T
  include Comparable.Make(T)
end;;
[%%expect ocaml {|
module Foo_and_bar :
  sig
    type t = { foo : Int.Set.t; bar : string; }
    val ( >= ) : t -> t -> bool
    val ( <= ) : t -> t -> bool
    val ( = ) : t -> t -> bool
    val ( > ) : t -> t -> bool
    val ( < ) : t -> t -> bool
    val ( <> ) : t -> t -> bool
    val equal : t -> t -> bool
    val compare : t -> t -> int
    val min : t -> t -> t
    val max : t -> t -> t
    val ascending : t -> t -> int
    val descending : t -> t -> int
    val between : t -> low:t -> high:t -> bool
    val clamp_exn : t -> min:t -> max:t -> t
    val clamp : t -> min:t -> max:t -> t Base__.Or_error.t
    type comparator_witness
    val comparator : (t, comparator_witness) Comparator.t
    val validate_lbound : min:t Core_kernel._maybe_bound -> t Validate.check
    val validate_ubound : max:t Core_kernel._maybe_bound -> t Validate.check
    val validate_bound :
      min:t Core_kernel._maybe_bound ->
      max:t Core_kernel._maybe_bound -> t Validate.check
    module Replace_polymorphic_compare :
      sig
        val ( >= ) : t -> t -> bool
        val ( <= ) : t -> t -> bool
        val ( = ) : t -> t -> bool
        val ( > ) : t -> t -> bool
        val ( < ) : t -> t -> bool
        val ( <> ) : t -> t -> bool
        val equal : t -> t -> bool
        val compare : t -> t -> int
        val min : t -> t -> t
        val max : t -> t -> t
      end
    module Map :
      sig
        module Key :
          sig
            type t = t
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
            type comparator_witness = comparator_witness
            val comparator : (t, comparator_witness) Comparator.t
          end
        module Tree :
          sig
            type 'a t = (Key.t, 'a, comparator_witness) Map_intf.Tree.t
            val empty : 'a t
            val singleton : Key.t -> 'a -> 'a t
            val of_alist :
              (Key.t * 'a) list -> [ `Duplicate_key of Key.t | `Ok of 'a t ]
            val of_alist_or_error :
              (Key.t * 'a) list -> 'a t Base__.Or_error.t
            val of_alist_exn : (Key.t * 'a) list -> 'a t
            val of_alist_multi : (Key.t * 'a) list -> 'a list t
            val of_alist_fold :
              (Key.t * 'a) list -> init:'b -> f:('b -> 'a -> 'b) -> 'b t
            val of_alist_reduce :
              (Key.t * 'a) list -> f:('a -> 'a -> 'a) -> 'a t
            val of_sorted_array :
              (Key.t * 'a) array -> 'a t Base__.Or_error.t
            val of_sorted_array_unchecked : (Key.t * 'a) array -> 'a t
            val of_increasing_iterator_unchecked :
              len:int -> f:(int -> Key.t * 'a) -> 'a t
            val of_iteri :
              iteri:(f:(key:Key.t -> data:'v -> unit) -> unit) ->
              [ `Duplicate_key of Key.t | `Ok of 'v t ]
            val of_tree : 'a t -> 'a t
            val of_hashtbl_exn : (Key.t, 'a) Hashtbl.t -> 'a t
            val gen :
              Key.t Quickcheck.Generator.t ->
              'a Quickcheck.Generator.t -> 'a t Quickcheck.Generator.t
            val invariants : 'a t -> bool
            val is_empty : 'a t -> bool
            val length : 'a t -> int
            val add : 'a t -> key:Key.t -> data:'a -> 'a t
            val add_multi : 'a list t -> key:Key.t -> data:'a -> 'a list t
            val remove_multi : 'a list t -> Key.t -> 'a list t
            val find_multi : 'a list t -> Key.t -> 'a list
            val change : 'a t -> Key.t -> f:('a option -> 'a option) -> 'a t
            val update : 'a t -> Key.t -> f:('a option -> 'a) -> 'a t
            val find : 'a t -> Key.t -> 'a option
            val find_exn : 'a t -> Key.t -> 'a
            val remove : 'a t -> Key.t -> 'a t
            val mem : 'a t -> Key.t -> bool
            val iter_keys : 'a t -> f:(Key.t -> unit) -> unit
            val iter : 'a t -> f:('a -> unit) -> unit
            val iteri : 'a t -> f:(key:Key.t -> data:'a -> unit) -> unit
            val iter2 :
              'a t ->
              'b t ->
              f:(key:Key.t ->
                 data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 unit) ->
              unit
            val map : 'a t -> f:('a -> 'b) -> 'b t
            val mapi : 'a t -> f:(key:Key.t -> data:'a -> 'b) -> 'b t
            val fold :
              'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val fold_right :
              'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val fold2 :
              'a t ->
              'b t ->
              init:'c ->
              f:(key:Key.t ->
                 data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 'c -> 'c) ->
              'c
            val filter_keys : 'a t -> f:(Key.t -> bool) -> 'a t
            val filter : 'a t -> f:('a -> bool) -> 'a t
            val filteri : 'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t
            val filter_map : 'a t -> f:('a -> 'b option) -> 'b t
            val filter_mapi :
              'a t -> f:(key:Key.t -> data:'a -> 'b option) -> 'b t
            val partition_mapi :
              'a t ->
              f:(key:Key.t -> data:'a -> [ `Fst of 'b | `Snd of 'c ]) ->
              'b t * 'c t
            val partition_map :
              'a t -> f:('a -> [ `Fst of 'b | `Snd of 'c ]) -> 'b t * 'c t
            val partitioni_tf :
              'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t * 'a t
            val partition_tf : 'a t -> f:('a -> bool) -> 'a t * 'a t
            val compare_direct : ('a -> 'a -> int) -> 'a t -> 'a t -> int
            val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
            val keys : 'a t -> Key.t list
            val data : 'a t -> 'a list
            val to_alist :
              ?key_order:[ `Decreasing | `Increasing ] ->
              'a t -> (Key.t * 'a) list
            val validate :
              name:(Key.t -> string) ->
              'a Validate.check -> 'a t Validate.check
            val merge :
              'a t ->
              'b t ->
              f:(key:Key.t ->
                 [ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 'c option) ->
              'c t
            val symmetric_diff :
              'a t ->
              'a t ->
              data_equal:('a -> 'a -> bool) ->
              (Key.t, 'a) Base.Map_intf.Symmetric_diff_element.t Sequence.t
            val min_elt : 'a t -> (Key.t * 'a) option
            val min_elt_exn : 'a t -> Key.t * 'a
            val max_elt : 'a t -> (Key.t * 'a) option
            val max_elt_exn : 'a t -> Key.t * 'a
            val for_all : 'a t -> f:('a -> bool) -> bool
            val for_alli : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
            val exists : 'a t -> f:('a -> bool) -> bool
            val existsi : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
            val count : 'a t -> f:('a -> bool) -> int
            val counti : 'a t -> f:(key:Key.t -> data:'a -> bool) -> int
            val split : 'a t -> Key.t -> 'a t * (Key.t * 'a) option * 'a t
            val append :
              lower_part:'a t ->
              upper_part:'a t -> [ `Ok of 'a t | `Overlapping_key_ranges ]
            val subrange :
              'a t ->
              lower_bound:Key.t Core_kernel._maybe_bound ->
              upper_bound:Key.t Core_kernel._maybe_bound -> 'a t
            val fold_range_inclusive :
              'a t ->
              min:Key.t ->
              max:Key.t ->
              init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val range_to_alist :
              'a t -> min:Key.t -> max:Key.t -> (Key.t * 'a) list
            val closest_key :
              'a t ->
              [ `Greater_or_equal_to
              | `Greater_than
              | `Less_or_equal_to
              | `Less_than ] -> Key.t -> (Key.t * 'a) option
            val nth : 'a t -> int -> (Key.t * 'a) option
            val nth_exn : 'a t -> int -> Key.t * 'a
            val rank : 'a t -> Key.t -> int option
            val to_tree : 'a t -> 'a t
            val to_sequence :
              ?order:[ `Decreasing_key | `Increasing_key ] ->
              ?keys_greater_or_equal_to:Key.t ->
              ?keys_less_or_equal_to:Key.t -> 'a t -> (Key.t * 'a) Sequence.t
            val obs :
              Key.t Quickcheck.Observer.t ->
              'v Quickcheck.Observer.t -> 'v t Quickcheck.Observer.t
            val shrinker :
              Key.t Quickcheck.Shrinker.t ->
              'v Quickcheck.Shrinker.t -> 'v t Quickcheck.Shrinker.t
            module Provide_of_sexp :
              functor (K : sig val t_of_sexp : Sexp.t -> Key.t end) ->
                sig
                  val t_of_sexp :
                    (Sexp.t -> 'v_x__017_) -> Sexp.t -> 'v_x__017_ t
                end
            val t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a t
            val sexp_of_t : ('a -> Sexp.t) -> 'a t -> Sexp.t
          end
        type 'a t = (Key.t, 'a, comparator_witness) Map.t
        val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
        val empty : 'a t
        val singleton : Key.t -> 'a -> 'a t
        val of_alist :
          (Key.t * 'a) list -> [ `Duplicate_key of Key.t | `Ok of 'a t ]
        val of_alist_or_error : (Key.t * 'a) list -> 'a t Base__.Or_error.t
        val of_alist_exn : (Key.t * 'a) list -> 'a t
        val of_alist_multi : (Key.t * 'a) list -> 'a list t
        val of_alist_fold :
          (Key.t * 'a) list -> init:'b -> f:('b -> 'a -> 'b) -> 'b t
        val of_alist_reduce : (Key.t * 'a) list -> f:('a -> 'a -> 'a) -> 'a t
        val of_sorted_array : (Key.t * 'a) array -> 'a t Base__.Or_error.t
        val of_sorted_array_unchecked : (Key.t * 'a) array -> 'a t
        val of_increasing_iterator_unchecked :
          len:int -> f:(int -> Key.t * 'a) -> 'a t
        val of_iteri :
          iteri:(f:(key:Key.t -> data:'v -> unit) -> unit) ->
          [ `Duplicate_key of Key.t | `Ok of 'v t ]
        val of_tree : 'a Tree.t -> 'a t
        val of_hashtbl_exn : (Key.t, 'a) Hashtbl.t -> 'a t
        val gen :
          Key.t Quickcheck.Generator.t ->
          'a Quickcheck.Generator.t -> 'a t Quickcheck.Generator.t
        val invariants : 'a t -> bool
        val is_empty : 'a t -> bool
        val length : 'a t -> int
        val add : 'a t -> key:Key.t -> data:'a -> 'a t
        val add_multi : 'a list t -> key:Key.t -> data:'a -> 'a list t
        val remove_multi : 'a list t -> Key.t -> 'a list t
        val find_multi : 'a list t -> Key.t -> 'a list
        val change : 'a t -> Key.t -> f:('a option -> 'a option) -> 'a t
        val update : 'a t -> Key.t -> f:('a option -> 'a) -> 'a t
        val find : 'a t -> Key.t -> 'a option
        val find_exn : 'a t -> Key.t -> 'a
        val remove : 'a t -> Key.t -> 'a t
        val mem : 'a t -> Key.t -> bool
        val iter_keys : 'a t -> f:(Key.t -> unit) -> unit
        val iter : 'a t -> f:('a -> unit) -> unit
        val iteri : 'a t -> f:(key:Key.t -> data:'a -> unit) -> unit
        val iter2 :
          'a t ->
          'b t ->
          f:(key:Key.t ->
             data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] -> unit) ->
          unit
        val map : 'a t -> f:('a -> 'b) -> 'b t
        val mapi : 'a t -> f:(key:Key.t -> data:'a -> 'b) -> 'b t
        val fold :
          'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val fold_right :
          'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val fold2 :
          'a t ->
          'b t ->
          init:'c ->
          f:(key:Key.t ->
             data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
             'c -> 'c) ->
          'c
        val filter_keys : 'a t -> f:(Key.t -> bool) -> 'a t
        val filter : 'a t -> f:('a -> bool) -> 'a t
        val filteri : 'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t
        val filter_map : 'a t -> f:('a -> 'b option) -> 'b t
        val filter_mapi :
          'a t -> f:(key:Key.t -> data:'a -> 'b option) -> 'b t
        val partition_mapi :
          'a t ->
          f:(key:Key.t -> data:'a -> [ `Fst of 'b | `Snd of 'c ]) ->
          'b t * 'c t
        val partition_map :
          'a t -> f:('a -> [ `Fst of 'b | `Snd of 'c ]) -> 'b t * 'c t
        val partitioni_tf :
          'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t * 'a t
        val partition_tf : 'a t -> f:('a -> bool) -> 'a t * 'a t
        val compare_direct : ('a -> 'a -> int) -> 'a t -> 'a t -> int
        val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
        val keys : 'a t -> Key.t list
        val data : 'a t -> 'a list
        val to_alist :
          ?key_order:[ `Decreasing | `Increasing ] ->
          'a t -> (Key.t * 'a) list
        val validate :
          name:(Key.t -> string) -> 'a Validate.check -> 'a t Validate.check
        val merge :
          'a t ->
          'b t ->
          f:(key:Key.t ->
             [ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] -> 'c option) ->
          'c t
        val symmetric_diff :
          'a t ->
          'a t ->
          data_equal:('a -> 'a -> bool) ->
          (Key.t, 'a) Base.Map_intf.Symmetric_diff_element.t Sequence.t
        val min_elt : 'a t -> (Key.t * 'a) option
        val min_elt_exn : 'a t -> Key.t * 'a
        val max_elt : 'a t -> (Key.t * 'a) option
        val max_elt_exn : 'a t -> Key.t * 'a
        val for_all : 'a t -> f:('a -> bool) -> bool
        val for_alli : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
        val exists : 'a t -> f:('a -> bool) -> bool
        val existsi : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
        val count : 'a t -> f:('a -> bool) -> int
        val counti : 'a t -> f:(key:Key.t -> data:'a -> bool) -> int
        val split : 'a t -> Key.t -> 'a t * (Key.t * 'a) option * 'a t
        val append :
          lower_part:'a t ->
          upper_part:'a t -> [ `Ok of 'a t | `Overlapping_key_ranges ]
        val subrange :
          'a t ->
          lower_bound:Key.t Core_kernel._maybe_bound ->
          upper_bound:Key.t Core_kernel._maybe_bound -> 'a t
        val fold_range_inclusive :
          'a t ->
          min:Key.t ->
          max:Key.t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val range_to_alist :
          'a t -> min:Key.t -> max:Key.t -> (Key.t * 'a) list
        val closest_key :
          'a t ->
          [ `Greater_or_equal_to
          | `Greater_than
          | `Less_or_equal_to
          | `Less_than ] -> Key.t -> (Key.t * 'a) option
        val nth : 'a t -> int -> (Key.t * 'a) option
        val nth_exn : 'a t -> int -> Key.t * 'a
        val rank : 'a t -> Key.t -> int option
        val to_tree : 'a t -> 'a Tree.t
        val to_sequence :
          ?order:[ `Decreasing_key | `Increasing_key ] ->
          ?keys_greater_or_equal_to:Key.t ->
          ?keys_less_or_equal_to:Key.t -> 'a t -> (Key.t * 'a) Sequence.t
        val obs :
          Key.t Quickcheck.Observer.t ->
          'v Quickcheck.Observer.t -> 'v t Quickcheck.Observer.t
        val shrinker :
          Key.t Quickcheck.Shrinker.t ->
          'v Quickcheck.Shrinker.t -> 'v t Quickcheck.Shrinker.t
        module Provide_of_sexp :
          functor (Key : sig val t_of_sexp : Sexp.t -> Key.t end) ->
            sig
              val t_of_sexp :
                (Sexp.t -> 'v_x__018_) -> Sexp.t -> 'v_x__018_ t
            end
        module Provide_bin_io :
          functor
            (Key : sig
                     val bin_t : Key.t Bin_prot.Type_class.t0
                     val bin_read_t : Key.t Bin_prot.Read.reader
                     val __bin_read_t__ : (int -> Key.t) Bin_prot.Read.reader
                     val bin_reader_t : Key.t Bin_prot.Type_class.reader0
                     val bin_size_t : Key.t Bin_prot.Size.sizer
                     val bin_write_t : Key.t Bin_prot.Write.writer
                     val bin_writer_t : Key.t Bin_prot.Type_class.writer0
                     val bin_shape_t : Bin_prot.Shape.t
                   end) ->
            sig
              val bin_shape_t : Bin_prot.Shape.t -> Bin_prot.Shape.t
              val bin_size_t : ('a, 'a t) Bin_prot.Size.sizer1
              val bin_write_t : ('a, 'a t) Bin_prot.Write.writer1
              val bin_read_t : ('a, 'a t) Bin_prot.Read.reader1
              val __bin_read_t__ : ('a, int -> 'a t) Bin_prot.Read.reader1
              val bin_writer_t : ('a, 'a t) Bin_prot.Type_class.S1.writer
              val bin_reader_t : ('a, 'a t) Bin_prot.Type_class.S1.reader
              val bin_t : ('a, 'a t) Bin_prot.Type_class.S1.t
            end
        module Provide_hash :
          functor
            (Key : sig
                     val hash_fold_t : Hash.state -> Key.t -> Hash.state
                   end) ->
            sig
              val hash_fold_t :
                (Hash.state -> 'a -> Hash.state) ->
                Hash.state -> 'a t -> Hash.state
            end
        val t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a t
        val sexp_of_t : ('a -> Sexp.t) -> 'a t -> Sexp.t
      end
    module Set :
      sig
        module Elt :
          sig
            type t = Map.Key.t
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
            type comparator_witness = Map.Key.comparator_witness
            val comparator : (t, comparator_witness) Comparator.t
          end
        module Tree :
          sig
            type t = (Elt.t, comparator_witness) Set_intf.Tree.t
            val compare : t -> t -> int
            val length : t -> int
            val is_empty : t -> bool
            val iter : t -> f:(Elt.t -> unit) -> unit
            val fold :
              t -> init:'accum -> f:('accum -> Elt.t -> 'accum) -> 'accum
            val fold_result :
              t ->
              init:'accum ->
              f:('accum -> Elt.t -> ('accum, 'e) result) ->
              ('accum, 'e) result
            val exists : t -> f:(Elt.t -> bool) -> bool
            val for_all : t -> f:(Elt.t -> bool) -> bool
            val count : t -> f:(Elt.t -> bool) -> int
            val sum :
              (module Base__.Commutative_group.S with type t = 'sum) ->
              t -> f:(Elt.t -> 'sum) -> 'sum
            val find : t -> f:(Elt.t -> bool) -> Elt.t option
            val find_map : t -> f:(Elt.t -> 'a option) -> 'a option
            val to_list : t -> Elt.t list
            val to_array : t -> Elt.t array
            val invariants : t -> bool
            val mem : t -> Elt.t -> bool
            val add : t -> Elt.t -> t
            val remove : t -> Elt.t -> t
            val union : t -> t -> t
            val inter : t -> t -> t
            val diff : t -> t -> t
            val symmetric_diff :
              t -> t -> (Elt.t, Elt.t) Core_kernel._either Sequence.t
            val compare_direct : t -> t -> int
            val equal : t -> t -> bool
            val is_subset : t -> of_:t -> bool
            val subset : t -> t -> bool
            val fold_until :
              t ->
              init:'b ->
              f:('b -> Elt.t -> ('b, 'stop) Set_intf.Continue_or_stop.t) ->
              ('b, 'stop) Set_intf.Finished_or_stopped_early.t
            val fold_right : t -> init:'b -> f:(Elt.t -> 'b -> 'b) -> 'b
            val iter2 :
              t ->
              t ->
              f:([ `Both of Elt.t * Elt.t | `Left of Elt.t | `Right of Elt.t ] ->
                 unit) ->
              unit
            val filter : t -> f:(Elt.t -> bool) -> t
            val partition_tf : t -> f:(Elt.t -> bool) -> t * t
            val elements : t -> Elt.t list
            val min_elt : t -> Elt.t option
            val min_elt_exn : t -> Elt.t
            val max_elt : t -> Elt.t option
            val max_elt_exn : t -> Elt.t
            val choose : t -> Elt.t option
            val choose_exn : t -> Elt.t
            val split : t -> Elt.t -> t * Elt.t option * t
            val group_by : t -> equiv:(Elt.t -> Elt.t -> bool) -> t list
            val find_exn : t -> f:(Elt.t -> bool) -> Elt.t
            val find_index : t -> int -> Elt.t option
            val nth : t -> int -> Elt.t option
            val remove_index : t -> int -> t
            val to_tree : t -> t
            val to_sequence :
              ?order:[ `Decreasing | `Increasing ] ->
              ?greater_or_equal_to:Elt.t ->
              ?less_or_equal_to:Elt.t -> t -> Elt.t Sequence.t
            val merge_to_sequence :
              ?order:[ `Decreasing | `Increasing ] ->
              ?greater_or_equal_to:Elt.t ->
              ?less_or_equal_to:Elt.t ->
              t ->
              t ->
              (Elt.t, Elt.t) Set_intf.Merge_to_sequence_element.t Sequence.t
            val to_map :
              t ->
              f:(Elt.t -> 'data) ->
              (Elt.t, 'data, comparator_witness) Core_kernel.Map.t
            val obs : Elt.t Quickcheck.Observer.t -> t Quickcheck.Observer.t
            val shrinker :
              Elt.t Quickcheck.Shrinker.t -> t Quickcheck.Shrinker.t
            val empty : t
            val singleton : Elt.t -> t
            val union_list : t list -> t
            val of_list : Elt.t list -> t
            val of_array : Elt.t array -> t
            val of_sorted_array : Elt.t array -> t Base__.Or_error.t
            val of_sorted_array_unchecked : Elt.t array -> t
            val of_increasing_iterator_unchecked :
              len:int -> f:(int -> Elt.t) -> t
            val stable_dedup_list : Elt.t list -> Elt.t list
            val map : ('a, 'b) Set_intf.Tree.t -> f:('a -> Elt.t) -> t
            val filter_map :
              ('a, 'b) Set_intf.Tree.t -> f:('a -> Elt.t option) -> t
            val of_tree : t -> t
            val of_hash_set : Elt.t Hash_set.t -> t
            val of_hashtbl_keys : (Elt.t, 'a) Hashtbl.t -> t
            val of_map_keys :
              (Elt.t, 'a, comparator_witness) Core_kernel.Map.t -> t
            val gen :
              Elt.t Quickcheck.Generator.t -> t Quickcheck.Generator.t
            module Provide_of_sexp :
              functor (Elt : sig val t_of_sexp : Sexp.t -> Elt.t end) ->
                sig val t_of_sexp : Sexp.t -> t end
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
          end
        type t = (Elt.t, comparator_witness) Set.t
        val compare : t -> t -> int
        val length : t -> int
        val is_empty : t -> bool
        val iter : t -> f:(Elt.t -> unit) -> unit
        val fold :
          t -> init:'accum -> f:('accum -> Elt.t -> 'accum) -> 'accum
        val fold_result :
          t ->
          init:'accum ->
          f:('accum -> Elt.t -> ('accum, 'e) result) -> ('accum, 'e) result
        val exists : t -> f:(Elt.t -> bool) -> bool
        val for_all : t -> f:(Elt.t -> bool) -> bool
        val count : t -> f:(Elt.t -> bool) -> int
        val sum :
          (module Base__.Commutative_group.S with type t = 'sum) ->
          t -> f:(Elt.t -> 'sum) -> 'sum
        val find : t -> f:(Elt.t -> bool) -> Elt.t option
        val find_map : t -> f:(Elt.t -> 'a option) -> 'a option
        val to_list : t -> Elt.t list
        val to_array : t -> Elt.t array
        val invariants : t -> bool
        val mem : t -> Elt.t -> bool
        val add : t -> Elt.t -> t
        val remove : t -> Elt.t -> t
        val union : t -> t -> t
        val inter : t -> t -> t
        val diff : t -> t -> t
        val symmetric_diff :
          t -> t -> (Elt.t, Elt.t) Core_kernel._either Sequence.t
        val compare_direct : t -> t -> int
        val equal : t -> t -> bool
        val is_subset : t -> of_:t -> bool
        val subset : t -> t -> bool
        val fold_until :
          t ->
          init:'b ->
          f:('b -> Elt.t -> ('b, 'stop) Set_intf.Continue_or_stop.t) ->
          ('b, 'stop) Set_intf.Finished_or_stopped_early.t
        val fold_right : t -> init:'b -> f:(Elt.t -> 'b -> 'b) -> 'b
        val iter2 :
          t ->
          t ->
          f:([ `Both of Elt.t * Elt.t | `Left of Elt.t | `Right of Elt.t ] ->
             unit) ->
          unit
        val filter : t -> f:(Elt.t -> bool) -> t
        val partition_tf : t -> f:(Elt.t -> bool) -> t * t
        val elements : t -> Elt.t list
        val min_elt : t -> Elt.t option
        val min_elt_exn : t -> Elt.t
        val max_elt : t -> Elt.t option
        val max_elt_exn : t -> Elt.t
        val choose : t -> Elt.t option
        val choose_exn : t -> Elt.t
        val split : t -> Elt.t -> t * Elt.t option * t
        val group_by : t -> equiv:(Elt.t -> Elt.t -> bool) -> t list
        val find_exn : t -> f:(Elt.t -> bool) -> Elt.t
        val find_index : t -> int -> Elt.t option
        val nth : t -> int -> Elt.t option
        val remove_index : t -> int -> t
        val to_tree : t -> Tree.t
        val to_sequence :
          ?order:[ `Decreasing | `Increasing ] ->
          ?greater_or_equal_to:Elt.t ->
          ?less_or_equal_to:Elt.t -> t -> Elt.t Sequence.t
        val merge_to_sequence :
          ?order:[ `Decreasing | `Increasing ] ->
          ?greater_or_equal_to:Elt.t ->
          ?less_or_equal_to:Elt.t ->
          t ->
          t -> (Elt.t, Elt.t) Set_intf.Merge_to_sequence_element.t Sequence.t
        val to_map :
          t ->
          f:(Elt.t -> 'data) ->
          (Elt.t, 'data, comparator_witness) Core_kernel.Map.t
        val obs : Elt.t Quickcheck.Observer.t -> t Quickcheck.Observer.t
        val shrinker : Elt.t Quickcheck.Shrinker.t -> t Quickcheck.Shrinker.t
        val empty : t
        val singleton : Elt.t -> t
        val union_list : t list -> t
        val of_list : Elt.t list -> t
        val of_array : Elt.t array -> t
        val of_sorted_array : Elt.t array -> t Base__.Or_error.t
        val of_sorted_array_unchecked : Elt.t array -> t
        val of_increasing_iterator_unchecked :
          len:int -> f:(int -> Elt.t) -> t
        val stable_dedup_list : Elt.t list -> Elt.t list
        val map : ('a, 'b) Set.t -> f:('a -> Elt.t) -> t
        val filter_map : ('a, 'b) Set.t -> f:('a -> Elt.t option) -> t
        val of_tree : Tree.t -> t
        val of_hash_set : Elt.t Hash_set.t -> t
        val of_hashtbl_keys : (Elt.t, 'a) Hashtbl.t -> t
        val of_map_keys :
          (Elt.t, 'a, comparator_witness) Core_kernel.Map.t -> t
        val gen : Elt.t Quickcheck.Generator.t -> t Quickcheck.Generator.t
        module Provide_of_sexp :
          functor (Elt : sig val t_of_sexp : Sexp.t -> Elt.t end) ->
            sig val t_of_sexp : Sexp.t -> t end
        module Provide_bin_io :
          functor
            (Elt : sig
                     val bin_t : Elt.t Bin_prot.Type_class.t0
                     val bin_read_t : Elt.t Bin_prot.Read.reader
                     val __bin_read_t__ : (int -> Elt.t) Bin_prot.Read.reader
                     val bin_reader_t : Elt.t Bin_prot.Type_class.reader0
                     val bin_size_t : Elt.t Bin_prot.Size.sizer
                     val bin_write_t : Elt.t Bin_prot.Write.writer
                     val bin_writer_t : Elt.t Bin_prot.Type_class.writer0
                     val bin_shape_t : Bin_prot.Shape.t
                   end) ->
            sig
              val bin_size_t : t Bin_prot.Size.sizer
              val bin_write_t : t Bin_prot.Write.writer
              val bin_read_t : t Bin_prot.Read.reader
              val __bin_read_t__ : (int -> t) Bin_prot.Read.reader
              val bin_shape_t : Bin_prot.Shape.t
              val bin_writer_t : t Bin_prot.Type_class.writer0
              val bin_reader_t : t Bin_prot.Type_class.reader0
              val bin_t : t Bin_prot.Type_class.t0
            end
        module Provide_hash :
          functor
            (Elt : sig
                     val hash_fold_t : Hash.state -> Elt.t -> Hash.state
                   end) ->
            sig
              val hash_fold_t : Hash.state -> t -> Hash.state
              val hash : t -> int
            end
        val t_of_sexp : Sexp.t -> t
        val sexp_of_t : t -> Sexp.t
      end
  end
|}];;

[@@@part "24"];;
module Foo_and_bar : sig
  type t = { foo: int; bar: string }
  include Comparable.S with type t := t
end = struct
  module T = struct
    type t = { foo: int; bar: string } [@@deriving sexp]
  end
  include T
  include Comparable.Poly(T)
end;;
[%%expect ocaml {|
module Foo_and_bar :
  sig
    type t = { foo : int; bar : string; }
    val ( >= ) : t -> t -> bool
    val ( <= ) : t -> t -> bool
    val ( = ) : t -> t -> bool
    val ( > ) : t -> t -> bool
    val ( < ) : t -> t -> bool
    val ( <> ) : t -> t -> bool
    val equal : t -> t -> bool
    val compare : t -> t -> int
    val min : t -> t -> t
    val max : t -> t -> t
    val ascending : t -> t -> int
    val descending : t -> t -> int
    val between : t -> low:t -> high:t -> bool
    val clamp_exn : t -> min:t -> max:t -> t
    val clamp : t -> min:t -> max:t -> t Base__.Or_error.t
    type comparator_witness
    val comparator : (t, comparator_witness) Comparator.t
    val validate_lbound : min:t Core_kernel._maybe_bound -> t Validate.check
    val validate_ubound : max:t Core_kernel._maybe_bound -> t Validate.check
    val validate_bound :
      min:t Core_kernel._maybe_bound ->
      max:t Core_kernel._maybe_bound -> t Validate.check
    module Replace_polymorphic_compare :
      sig
        val ( >= ) : t -> t -> bool
        val ( <= ) : t -> t -> bool
        val ( = ) : t -> t -> bool
        val ( > ) : t -> t -> bool
        val ( < ) : t -> t -> bool
        val ( <> ) : t -> t -> bool
        val equal : t -> t -> bool
        val compare : t -> t -> int
        val min : t -> t -> t
        val max : t -> t -> t
      end
    module Map :
      sig
        module Key :
          sig
            type t = t
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
            type comparator_witness = comparator_witness
            val comparator : (t, comparator_witness) Comparator.t
          end
        module Tree :
          sig
            type 'a t = (Key.t, 'a, comparator_witness) Map_intf.Tree.t
            val empty : 'a t
            val singleton : Key.t -> 'a -> 'a t
            val of_alist :
              (Key.t * 'a) list -> [ `Duplicate_key of Key.t | `Ok of 'a t ]
            val of_alist_or_error :
              (Key.t * 'a) list -> 'a t Base__.Or_error.t
            val of_alist_exn : (Key.t * 'a) list -> 'a t
            val of_alist_multi : (Key.t * 'a) list -> 'a list t
            val of_alist_fold :
              (Key.t * 'a) list -> init:'b -> f:('b -> 'a -> 'b) -> 'b t
            val of_alist_reduce :
              (Key.t * 'a) list -> f:('a -> 'a -> 'a) -> 'a t
            val of_sorted_array :
              (Key.t * 'a) array -> 'a t Base__.Or_error.t
            val of_sorted_array_unchecked : (Key.t * 'a) array -> 'a t
            val of_increasing_iterator_unchecked :
              len:int -> f:(int -> Key.t * 'a) -> 'a t
            val of_iteri :
              iteri:(f:(key:Key.t -> data:'v -> unit) -> unit) ->
              [ `Duplicate_key of Key.t | `Ok of 'v t ]
            val of_tree : 'a t -> 'a t
            val of_hashtbl_exn : (Key.t, 'a) Hashtbl.t -> 'a t
            val gen :
              Key.t Quickcheck.Generator.t ->
              'a Quickcheck.Generator.t -> 'a t Quickcheck.Generator.t
            val invariants : 'a t -> bool
            val is_empty : 'a t -> bool
            val length : 'a t -> int
            val add : 'a t -> key:Key.t -> data:'a -> 'a t
            val add_multi : 'a list t -> key:Key.t -> data:'a -> 'a list t
            val remove_multi : 'a list t -> Key.t -> 'a list t
            val find_multi : 'a list t -> Key.t -> 'a list
            val change : 'a t -> Key.t -> f:('a option -> 'a option) -> 'a t
            val update : 'a t -> Key.t -> f:('a option -> 'a) -> 'a t
            val find : 'a t -> Key.t -> 'a option
            val find_exn : 'a t -> Key.t -> 'a
            val remove : 'a t -> Key.t -> 'a t
            val mem : 'a t -> Key.t -> bool
            val iter_keys : 'a t -> f:(Key.t -> unit) -> unit
            val iter : 'a t -> f:('a -> unit) -> unit
            val iteri : 'a t -> f:(key:Key.t -> data:'a -> unit) -> unit
            val iter2 :
              'a t ->
              'b t ->
              f:(key:Key.t ->
                 data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 unit) ->
              unit
            val map : 'a t -> f:('a -> 'b) -> 'b t
            val mapi : 'a t -> f:(key:Key.t -> data:'a -> 'b) -> 'b t
            val fold :
              'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val fold_right :
              'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val fold2 :
              'a t ->
              'b t ->
              init:'c ->
              f:(key:Key.t ->
                 data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 'c -> 'c) ->
              'c
            val filter_keys : 'a t -> f:(Key.t -> bool) -> 'a t
            val filter : 'a t -> f:('a -> bool) -> 'a t
            val filteri : 'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t
            val filter_map : 'a t -> f:('a -> 'b option) -> 'b t
            val filter_mapi :
              'a t -> f:(key:Key.t -> data:'a -> 'b option) -> 'b t
            val partition_mapi :
              'a t ->
              f:(key:Key.t -> data:'a -> [ `Fst of 'b | `Snd of 'c ]) ->
              'b t * 'c t
            val partition_map :
              'a t -> f:('a -> [ `Fst of 'b | `Snd of 'c ]) -> 'b t * 'c t
            val partitioni_tf :
              'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t * 'a t
            val partition_tf : 'a t -> f:('a -> bool) -> 'a t * 'a t
            val compare_direct : ('a -> 'a -> int) -> 'a t -> 'a t -> int
            val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
            val keys : 'a t -> Key.t list
            val data : 'a t -> 'a list
            val to_alist :
              ?key_order:[ `Decreasing | `Increasing ] ->
              'a t -> (Key.t * 'a) list
            val validate :
              name:(Key.t -> string) ->
              'a Validate.check -> 'a t Validate.check
            val merge :
              'a t ->
              'b t ->
              f:(key:Key.t ->
                 [ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
                 'c option) ->
              'c t
            val symmetric_diff :
              'a t ->
              'a t ->
              data_equal:('a -> 'a -> bool) ->
              (Key.t, 'a) Base.Map_intf.Symmetric_diff_element.t Sequence.t
            val min_elt : 'a t -> (Key.t * 'a) option
            val min_elt_exn : 'a t -> Key.t * 'a
            val max_elt : 'a t -> (Key.t * 'a) option
            val max_elt_exn : 'a t -> Key.t * 'a
            val for_all : 'a t -> f:('a -> bool) -> bool
            val for_alli : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
            val exists : 'a t -> f:('a -> bool) -> bool
            val existsi : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
            val count : 'a t -> f:('a -> bool) -> int
            val counti : 'a t -> f:(key:Key.t -> data:'a -> bool) -> int
            val split : 'a t -> Key.t -> 'a t * (Key.t * 'a) option * 'a t
            val append :
              lower_part:'a t ->
              upper_part:'a t -> [ `Ok of 'a t | `Overlapping_key_ranges ]
            val subrange :
              'a t ->
              lower_bound:Key.t Core_kernel._maybe_bound ->
              upper_bound:Key.t Core_kernel._maybe_bound -> 'a t
            val fold_range_inclusive :
              'a t ->
              min:Key.t ->
              max:Key.t ->
              init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
            val range_to_alist :
              'a t -> min:Key.t -> max:Key.t -> (Key.t * 'a) list
            val closest_key :
              'a t ->
              [ `Greater_or_equal_to
              | `Greater_than
              | `Less_or_equal_to
              | `Less_than ] -> Key.t -> (Key.t * 'a) option
            val nth : 'a t -> int -> (Key.t * 'a) option
            val nth_exn : 'a t -> int -> Key.t * 'a
            val rank : 'a t -> Key.t -> int option
            val to_tree : 'a t -> 'a t
            val to_sequence :
              ?order:[ `Decreasing_key | `Increasing_key ] ->
              ?keys_greater_or_equal_to:Key.t ->
              ?keys_less_or_equal_to:Key.t -> 'a t -> (Key.t * 'a) Sequence.t
            val obs :
              Key.t Quickcheck.Observer.t ->
              'v Quickcheck.Observer.t -> 'v t Quickcheck.Observer.t
            val shrinker :
              Key.t Quickcheck.Shrinker.t ->
              'v Quickcheck.Shrinker.t -> 'v t Quickcheck.Shrinker.t
            module Provide_of_sexp :
              functor (K : sig val t_of_sexp : Sexp.t -> Key.t end) ->
                sig
                  val t_of_sexp :
                    (Sexp.t -> 'v_x__017_) -> Sexp.t -> 'v_x__017_ t
                end
            val t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a t
            val sexp_of_t : ('a -> Sexp.t) -> 'a t -> Sexp.t
          end
        type 'a t = (Key.t, 'a, comparator_witness) Map.t
        val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
        val empty : 'a t
        val singleton : Key.t -> 'a -> 'a t
        val of_alist :
          (Key.t * 'a) list -> [ `Duplicate_key of Key.t | `Ok of 'a t ]
        val of_alist_or_error : (Key.t * 'a) list -> 'a t Base__.Or_error.t
        val of_alist_exn : (Key.t * 'a) list -> 'a t
        val of_alist_multi : (Key.t * 'a) list -> 'a list t
        val of_alist_fold :
          (Key.t * 'a) list -> init:'b -> f:('b -> 'a -> 'b) -> 'b t
        val of_alist_reduce : (Key.t * 'a) list -> f:('a -> 'a -> 'a) -> 'a t
        val of_sorted_array : (Key.t * 'a) array -> 'a t Base__.Or_error.t
        val of_sorted_array_unchecked : (Key.t * 'a) array -> 'a t
        val of_increasing_iterator_unchecked :
          len:int -> f:(int -> Key.t * 'a) -> 'a t
        val of_iteri :
          iteri:(f:(key:Key.t -> data:'v -> unit) -> unit) ->
          [ `Duplicate_key of Key.t | `Ok of 'v t ]
        val of_tree : 'a Tree.t -> 'a t
        val of_hashtbl_exn : (Key.t, 'a) Hashtbl.t -> 'a t
        val gen :
          Key.t Quickcheck.Generator.t ->
          'a Quickcheck.Generator.t -> 'a t Quickcheck.Generator.t
        val invariants : 'a t -> bool
        val is_empty : 'a t -> bool
        val length : 'a t -> int
        val add : 'a t -> key:Key.t -> data:'a -> 'a t
        val add_multi : 'a list t -> key:Key.t -> data:'a -> 'a list t
        val remove_multi : 'a list t -> Key.t -> 'a list t
        val find_multi : 'a list t -> Key.t -> 'a list
        val change : 'a t -> Key.t -> f:('a option -> 'a option) -> 'a t
        val update : 'a t -> Key.t -> f:('a option -> 'a) -> 'a t
        val find : 'a t -> Key.t -> 'a option
        val find_exn : 'a t -> Key.t -> 'a
        val remove : 'a t -> Key.t -> 'a t
        val mem : 'a t -> Key.t -> bool
        val iter_keys : 'a t -> f:(Key.t -> unit) -> unit
        val iter : 'a t -> f:('a -> unit) -> unit
        val iteri : 'a t -> f:(key:Key.t -> data:'a -> unit) -> unit
        val iter2 :
          'a t ->
          'b t ->
          f:(key:Key.t ->
             data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] -> unit) ->
          unit
        val map : 'a t -> f:('a -> 'b) -> 'b t
        val mapi : 'a t -> f:(key:Key.t -> data:'a -> 'b) -> 'b t
        val fold :
          'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val fold_right :
          'a t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val fold2 :
          'a t ->
          'b t ->
          init:'c ->
          f:(key:Key.t ->
             data:[ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] ->
             'c -> 'c) ->
          'c
        val filter_keys : 'a t -> f:(Key.t -> bool) -> 'a t
        val filter : 'a t -> f:('a -> bool) -> 'a t
        val filteri : 'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t
        val filter_map : 'a t -> f:('a -> 'b option) -> 'b t
        val filter_mapi :
          'a t -> f:(key:Key.t -> data:'a -> 'b option) -> 'b t
        val partition_mapi :
          'a t ->
          f:(key:Key.t -> data:'a -> [ `Fst of 'b | `Snd of 'c ]) ->
          'b t * 'c t
        val partition_map :
          'a t -> f:('a -> [ `Fst of 'b | `Snd of 'c ]) -> 'b t * 'c t
        val partitioni_tf :
          'a t -> f:(key:Key.t -> data:'a -> bool) -> 'a t * 'a t
        val partition_tf : 'a t -> f:('a -> bool) -> 'a t * 'a t
        val compare_direct : ('a -> 'a -> int) -> 'a t -> 'a t -> int
        val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
        val keys : 'a t -> Key.t list
        val data : 'a t -> 'a list
        val to_alist :
          ?key_order:[ `Decreasing | `Increasing ] ->
          'a t -> (Key.t * 'a) list
        val validate :
          name:(Key.t -> string) -> 'a Validate.check -> 'a t Validate.check
        val merge :
          'a t ->
          'b t ->
          f:(key:Key.t ->
             [ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] -> 'c option) ->
          'c t
        val symmetric_diff :
          'a t ->
          'a t ->
          data_equal:('a -> 'a -> bool) ->
          (Key.t, 'a) Base.Map_intf.Symmetric_diff_element.t Sequence.t
        val min_elt : 'a t -> (Key.t * 'a) option
        val min_elt_exn : 'a t -> Key.t * 'a
        val max_elt : 'a t -> (Key.t * 'a) option
        val max_elt_exn : 'a t -> Key.t * 'a
        val for_all : 'a t -> f:('a -> bool) -> bool
        val for_alli : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
        val exists : 'a t -> f:('a -> bool) -> bool
        val existsi : 'a t -> f:(key:Key.t -> data:'a -> bool) -> bool
        val count : 'a t -> f:('a -> bool) -> int
        val counti : 'a t -> f:(key:Key.t -> data:'a -> bool) -> int
        val split : 'a t -> Key.t -> 'a t * (Key.t * 'a) option * 'a t
        val append :
          lower_part:'a t ->
          upper_part:'a t -> [ `Ok of 'a t | `Overlapping_key_ranges ]
        val subrange :
          'a t ->
          lower_bound:Key.t Core_kernel._maybe_bound ->
          upper_bound:Key.t Core_kernel._maybe_bound -> 'a t
        val fold_range_inclusive :
          'a t ->
          min:Key.t ->
          max:Key.t -> init:'b -> f:(key:Key.t -> data:'a -> 'b -> 'b) -> 'b
        val range_to_alist :
          'a t -> min:Key.t -> max:Key.t -> (Key.t * 'a) list
        val closest_key :
          'a t ->
          [ `Greater_or_equal_to
          | `Greater_than
          | `Less_or_equal_to
          | `Less_than ] -> Key.t -> (Key.t * 'a) option
        val nth : 'a t -> int -> (Key.t * 'a) option
        val nth_exn : 'a t -> int -> Key.t * 'a
        val rank : 'a t -> Key.t -> int option
        val to_tree : 'a t -> 'a Tree.t
        val to_sequence :
          ?order:[ `Decreasing_key | `Increasing_key ] ->
          ?keys_greater_or_equal_to:Key.t ->
          ?keys_less_or_equal_to:Key.t -> 'a t -> (Key.t * 'a) Sequence.t
        val obs :
          Key.t Quickcheck.Observer.t ->
          'v Quickcheck.Observer.t -> 'v t Quickcheck.Observer.t
        val shrinker :
          Key.t Quickcheck.Shrinker.t ->
          'v Quickcheck.Shrinker.t -> 'v t Quickcheck.Shrinker.t
        module Provide_of_sexp :
          functor (Key : sig val t_of_sexp : Sexp.t -> Key.t end) ->
            sig
              val t_of_sexp :
                (Sexp.t -> 'v_x__018_) -> Sexp.t -> 'v_x__018_ t
            end
        module Provide_bin_io :
          functor
            (Key : sig
                     val bin_t : Key.t Bin_prot.Type_class.t0
                     val bin_read_t : Key.t Bin_prot.Read.reader
                     val __bin_read_t__ : (int -> Key.t) Bin_prot.Read.reader
                     val bin_reader_t : Key.t Bin_prot.Type_class.reader0
                     val bin_size_t : Key.t Bin_prot.Size.sizer
                     val bin_write_t : Key.t Bin_prot.Write.writer
                     val bin_writer_t : Key.t Bin_prot.Type_class.writer0
                     val bin_shape_t : Bin_prot.Shape.t
                   end) ->
            sig
              val bin_shape_t : Bin_prot.Shape.t -> Bin_prot.Shape.t
              val bin_size_t : ('a, 'a t) Bin_prot.Size.sizer1
              val bin_write_t : ('a, 'a t) Bin_prot.Write.writer1
              val bin_read_t : ('a, 'a t) Bin_prot.Read.reader1
              val __bin_read_t__ : ('a, int -> 'a t) Bin_prot.Read.reader1
              val bin_writer_t : ('a, 'a t) Bin_prot.Type_class.S1.writer
              val bin_reader_t : ('a, 'a t) Bin_prot.Type_class.S1.reader
              val bin_t : ('a, 'a t) Bin_prot.Type_class.S1.t
            end
        module Provide_hash :
          functor
            (Key : sig
                     val hash_fold_t : Hash.state -> Key.t -> Hash.state
                   end) ->
            sig
              val hash_fold_t :
                (Hash.state -> 'a -> Hash.state) ->
                Hash.state -> 'a t -> Hash.state
            end
        val t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a t
        val sexp_of_t : ('a -> Sexp.t) -> 'a t -> Sexp.t
      end
    module Set :
      sig
        module Elt :
          sig
            type t = Map.Key.t
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
            type comparator_witness = Map.Key.comparator_witness
            val comparator : (t, comparator_witness) Comparator.t
          end
        module Tree :
          sig
            type t = (Elt.t, comparator_witness) Set_intf.Tree.t
            val compare : t -> t -> int
            val length : t -> int
            val is_empty : t -> bool
            val iter : t -> f:(Elt.t -> unit) -> unit
            val fold :
              t -> init:'accum -> f:('accum -> Elt.t -> 'accum) -> 'accum
            val fold_result :
              t ->
              init:'accum ->
              f:('accum -> Elt.t -> ('accum, 'e) result) ->
              ('accum, 'e) result
            val exists : t -> f:(Elt.t -> bool) -> bool
            val for_all : t -> f:(Elt.t -> bool) -> bool
            val count : t -> f:(Elt.t -> bool) -> int
            val sum :
              (module Base__.Commutative_group.S with type t = 'sum) ->
              t -> f:(Elt.t -> 'sum) -> 'sum
            val find : t -> f:(Elt.t -> bool) -> Elt.t option
            val find_map : t -> f:(Elt.t -> 'a option) -> 'a option
            val to_list : t -> Elt.t list
            val to_array : t -> Elt.t array
            val invariants : t -> bool
            val mem : t -> Elt.t -> bool
            val add : t -> Elt.t -> t
            val remove : t -> Elt.t -> t
            val union : t -> t -> t
            val inter : t -> t -> t
            val diff : t -> t -> t
            val symmetric_diff :
              t -> t -> (Elt.t, Elt.t) Core_kernel._either Sequence.t
            val compare_direct : t -> t -> int
            val equal : t -> t -> bool
            val is_subset : t -> of_:t -> bool
            val subset : t -> t -> bool
            val fold_until :
              t ->
              init:'b ->
              f:('b -> Elt.t -> ('b, 'stop) Set_intf.Continue_or_stop.t) ->
              ('b, 'stop) Set_intf.Finished_or_stopped_early.t
            val fold_right : t -> init:'b -> f:(Elt.t -> 'b -> 'b) -> 'b
            val iter2 :
              t ->
              t ->
              f:([ `Both of Elt.t * Elt.t | `Left of Elt.t | `Right of Elt.t ] ->
                 unit) ->
              unit
            val filter : t -> f:(Elt.t -> bool) -> t
            val partition_tf : t -> f:(Elt.t -> bool) -> t * t
            val elements : t -> Elt.t list
            val min_elt : t -> Elt.t option
            val min_elt_exn : t -> Elt.t
            val max_elt : t -> Elt.t option
            val max_elt_exn : t -> Elt.t
            val choose : t -> Elt.t option
            val choose_exn : t -> Elt.t
            val split : t -> Elt.t -> t * Elt.t option * t
            val group_by : t -> equiv:(Elt.t -> Elt.t -> bool) -> t list
            val find_exn : t -> f:(Elt.t -> bool) -> Elt.t
            val find_index : t -> int -> Elt.t option
            val nth : t -> int -> Elt.t option
            val remove_index : t -> int -> t
            val to_tree : t -> t
            val to_sequence :
              ?order:[ `Decreasing | `Increasing ] ->
              ?greater_or_equal_to:Elt.t ->
              ?less_or_equal_to:Elt.t -> t -> Elt.t Sequence.t
            val merge_to_sequence :
              ?order:[ `Decreasing | `Increasing ] ->
              ?greater_or_equal_to:Elt.t ->
              ?less_or_equal_to:Elt.t ->
              t ->
              t ->
              (Elt.t, Elt.t) Set_intf.Merge_to_sequence_element.t Sequence.t
            val to_map :
              t ->
              f:(Elt.t -> 'data) ->
              (Elt.t, 'data, comparator_witness) Core_kernel.Map.t
            val obs : Elt.t Quickcheck.Observer.t -> t Quickcheck.Observer.t
            val shrinker :
              Elt.t Quickcheck.Shrinker.t -> t Quickcheck.Shrinker.t
            val empty : t
            val singleton : Elt.t -> t
            val union_list : t list -> t
            val of_list : Elt.t list -> t
            val of_array : Elt.t array -> t
            val of_sorted_array : Elt.t array -> t Base__.Or_error.t
            val of_sorted_array_unchecked : Elt.t array -> t
            val of_increasing_iterator_unchecked :
              len:int -> f:(int -> Elt.t) -> t
            val stable_dedup_list : Elt.t list -> Elt.t list
            val map : ('a, 'b) Set_intf.Tree.t -> f:('a -> Elt.t) -> t
            val filter_map :
              ('a, 'b) Set_intf.Tree.t -> f:('a -> Elt.t option) -> t
            val of_tree : t -> t
            val of_hash_set : Elt.t Hash_set.t -> t
            val of_hashtbl_keys : (Elt.t, 'a) Hashtbl.t -> t
            val of_map_keys :
              (Elt.t, 'a, comparator_witness) Core_kernel.Map.t -> t
            val gen :
              Elt.t Quickcheck.Generator.t -> t Quickcheck.Generator.t
            module Provide_of_sexp :
              functor (Elt : sig val t_of_sexp : Sexp.t -> Elt.t end) ->
                sig val t_of_sexp : Sexp.t -> t end
            val t_of_sexp : Sexp.t -> t
            val sexp_of_t : t -> Sexp.t
          end
        type t = (Elt.t, comparator_witness) Set.t
        val compare : t -> t -> int
        val length : t -> int
        val is_empty : t -> bool
        val iter : t -> f:(Elt.t -> unit) -> unit
        val fold :
          t -> init:'accum -> f:('accum -> Elt.t -> 'accum) -> 'accum
        val fold_result :
          t ->
          init:'accum ->
          f:('accum -> Elt.t -> ('accum, 'e) result) -> ('accum, 'e) result
        val exists : t -> f:(Elt.t -> bool) -> bool
        val for_all : t -> f:(Elt.t -> bool) -> bool
        val count : t -> f:(Elt.t -> bool) -> int
        val sum :
          (module Base__.Commutative_group.S with type t = 'sum) ->
          t -> f:(Elt.t -> 'sum) -> 'sum
        val find : t -> f:(Elt.t -> bool) -> Elt.t option
        val find_map : t -> f:(Elt.t -> 'a option) -> 'a option
        val to_list : t -> Elt.t list
        val to_array : t -> Elt.t array
        val invariants : t -> bool
        val mem : t -> Elt.t -> bool
        val add : t -> Elt.t -> t
        val remove : t -> Elt.t -> t
        val union : t -> t -> t
        val inter : t -> t -> t
        val diff : t -> t -> t
        val symmetric_diff :
          t -> t -> (Elt.t, Elt.t) Core_kernel._either Sequence.t
        val compare_direct : t -> t -> int
        val equal : t -> t -> bool
        val is_subset : t -> of_:t -> bool
        val subset : t -> t -> bool
        val fold_until :
          t ->
          init:'b ->
          f:('b -> Elt.t -> ('b, 'stop) Set_intf.Continue_or_stop.t) ->
          ('b, 'stop) Set_intf.Finished_or_stopped_early.t
        val fold_right : t -> init:'b -> f:(Elt.t -> 'b -> 'b) -> 'b
        val iter2 :
          t ->
          t ->
          f:([ `Both of Elt.t * Elt.t | `Left of Elt.t | `Right of Elt.t ] ->
             unit) ->
          unit
        val filter : t -> f:(Elt.t -> bool) -> t
        val partition_tf : t -> f:(Elt.t -> bool) -> t * t
        val elements : t -> Elt.t list
        val min_elt : t -> Elt.t option
        val min_elt_exn : t -> Elt.t
        val max_elt : t -> Elt.t option
        val max_elt_exn : t -> Elt.t
        val choose : t -> Elt.t option
        val choose_exn : t -> Elt.t
        val split : t -> Elt.t -> t * Elt.t option * t
        val group_by : t -> equiv:(Elt.t -> Elt.t -> bool) -> t list
        val find_exn : t -> f:(Elt.t -> bool) -> Elt.t
        val find_index : t -> int -> Elt.t option
        val nth : t -> int -> Elt.t option
        val remove_index : t -> int -> t
        val to_tree : t -> Tree.t
        val to_sequence :
          ?order:[ `Decreasing | `Increasing ] ->
          ?greater_or_equal_to:Elt.t ->
          ?less_or_equal_to:Elt.t -> t -> Elt.t Sequence.t
        val merge_to_sequence :
          ?order:[ `Decreasing | `Increasing ] ->
          ?greater_or_equal_to:Elt.t ->
          ?less_or_equal_to:Elt.t ->
          t ->
          t -> (Elt.t, Elt.t) Set_intf.Merge_to_sequence_element.t Sequence.t
        val to_map :
          t ->
          f:(Elt.t -> 'data) ->
          (Elt.t, 'data, comparator_witness) Core_kernel.Map.t
        val obs : Elt.t Quickcheck.Observer.t -> t Quickcheck.Observer.t
        val shrinker : Elt.t Quickcheck.Shrinker.t -> t Quickcheck.Shrinker.t
        val empty : t
        val singleton : Elt.t -> t
        val union_list : t list -> t
        val of_list : Elt.t list -> t
        val of_array : Elt.t array -> t
        val of_sorted_array : Elt.t array -> t Base__.Or_error.t
        val of_sorted_array_unchecked : Elt.t array -> t
        val of_increasing_iterator_unchecked :
          len:int -> f:(int -> Elt.t) -> t
        val stable_dedup_list : Elt.t list -> Elt.t list
        val map : ('a, 'b) Set.t -> f:('a -> Elt.t) -> t
        val filter_map : ('a, 'b) Set.t -> f:('a -> Elt.t option) -> t
        val of_tree : Tree.t -> t
        val of_hash_set : Elt.t Hash_set.t -> t
        val of_hashtbl_keys : (Elt.t, 'a) Hashtbl.t -> t
        val of_map_keys :
          (Elt.t, 'a, comparator_witness) Core_kernel.Map.t -> t
        val gen : Elt.t Quickcheck.Generator.t -> t Quickcheck.Generator.t
        module Provide_of_sexp :
          functor (Elt : sig val t_of_sexp : Sexp.t -> Elt.t end) ->
            sig val t_of_sexp : Sexp.t -> t end
        module Provide_bin_io :
          functor
            (Elt : sig
                     val bin_t : Elt.t Bin_prot.Type_class.t0
                     val bin_read_t : Elt.t Bin_prot.Read.reader
                     val __bin_read_t__ : (int -> Elt.t) Bin_prot.Read.reader
                     val bin_reader_t : Elt.t Bin_prot.Type_class.reader0
                     val bin_size_t : Elt.t Bin_prot.Size.sizer
                     val bin_write_t : Elt.t Bin_prot.Write.writer
                     val bin_writer_t : Elt.t Bin_prot.Type_class.writer0
                     val bin_shape_t : Bin_prot.Shape.t
                   end) ->
            sig
              val bin_size_t : t Bin_prot.Size.sizer
              val bin_write_t : t Bin_prot.Write.writer
              val bin_read_t : t Bin_prot.Read.reader
              val __bin_read_t__ : (int -> t) Bin_prot.Read.reader
              val bin_shape_t : Bin_prot.Shape.t
              val bin_writer_t : t Bin_prot.Type_class.writer0
              val bin_reader_t : t Bin_prot.Type_class.reader0
              val bin_t : t Bin_prot.Type_class.t0
            end
        module Provide_hash :
          functor
            (Elt : sig
                     val hash_fold_t : Hash.state -> Elt.t -> Hash.state
                   end) ->
            sig
              val hash_fold_t : Hash.state -> t -> Hash.state
              val hash : t -> int
            end
        val t_of_sexp : Sexp.t -> t
        val sexp_of_t : t -> Sexp.t
      end
  end
|}];;

[@@@part "25"];;
let table = Hashtbl.create ~hashable:String.hashable ();;
[%%expect ocaml {|val table : (string, '_a) Hashtbl.t = <abstr>|}];;
Hashtbl.set table ~key:"three" ~data:3;;
[%%expect ocaml {|- : unit = ()|}];;
Hashtbl.find table "three";;
[%%expect ocaml {|- : int option = Some 3|}];;

[@@@part "26"];;
let table = String.Table.create ();;
[%%expect ocaml {|val table : '_a String.Table.t = <abstr>|}];;

[@@@part "27"];;
let table = Hashtbl.create ~hashable:Hashtbl.Poly.hashable ();;
[%%expect ocaml {|val table : ('_a, '_b) Hashtbl.t = <abstr>|}];;

[@@@part "28"];;
let table = Hashtbl.Poly.create ();;
[%%expect ocaml {|val table : ('_a, '_b) Hashtbl.t = <abstr>|}];;

[@@@part "29"];;
Caml.Hashtbl.hash (List.range 0 9);;
[%%expect ocaml {|- : int = 209331808|}];;
Caml.Hashtbl.hash (List.range 0 10);;
[%%expect ocaml {|- : int = 182325193|}];;
Caml.Hashtbl.hash (List.range 0 11);;
[%%expect ocaml {|- : int = 182325193|}];;
Caml.Hashtbl.hash (List.range 0 100);;
[%%expect ocaml {|- : int = 182325193|}];;

[@@@part "30"];;
module Foo_and_bar : sig
  type t = { foo: int; bar: string }
  include Hashable.S with type t := t
end = struct
  module T = struct
    type t = { foo: int; bar: string } [@@deriving sexp, compare, hash]
  end
  include T
  include Hashable.Make(T)
end;;
[%%expect ocaml {|
module Foo_and_bar :
  sig
    type t = { foo : int; bar : string; }
    val hash : t -> int
    val compare : t -> t -> int
    val hashable : t Hashtbl_intf.Hashable.t
    module Table :
      sig
        type key = t
        type ('a, 'b) hashtbl = ('a, 'b) Hashtbl.t
        type 'b t = (key, 'b) hashtbl
        val sexp_of_t : ('b -> Sexp.t) -> 'b t -> Sexp.t
        type ('a, 'b) t_ = 'b t
        type 'a key_ = key
        val hashable : key Hashtbl_intf.Hashable.t
        val invariant :
          'a Base__Invariant_intf.t -> 'a t Base__Invariant_intf.t
        val create :
          (key, 'b, unit -> 'b t)
          Hashtbl_intf.create_options_without_hashable
        val of_alist :
          (key, 'b,
           (key * 'b) list -> [ `Duplicate_key of key | `Ok of 'b t ])
          Hashtbl_intf.create_options_without_hashable
        val of_alist_report_all_dups :
          (key, 'b,
           (key * 'b) list -> [ `Duplicate_keys of key list | `Ok of 'b t ])
          Hashtbl_intf.create_options_without_hashable
        val of_alist_or_error :
          (key, 'b, (key * 'b) list -> 'b t Base__.Or_error.t)
          Hashtbl_intf.create_options_without_hashable
        val of_alist_exn :
          (key, 'b, (key * 'b) list -> 'b t)
          Hashtbl_intf.create_options_without_hashable
        val of_alist_multi :
          (key, 'b list, (key * 'b) list -> 'b list t)
          Hashtbl_intf.create_options_without_hashable
        val create_mapped :
          (key, 'b,
           get_key:('r -> key) ->
           get_data:('r -> 'b) ->
           'r list -> [ `Duplicate_keys of key list | `Ok of 'b t ])
          Hashtbl_intf.create_options_without_hashable
        val create_with_key :
          (key, 'r,
           get_key:('r -> key) ->
           'r list -> [ `Duplicate_keys of key list | `Ok of 'r t ])
          Hashtbl_intf.create_options_without_hashable
        val create_with_key_or_error :
          (key, 'r, get_key:('r -> key) -> 'r list -> 'r t Base__.Or_error.t)
          Hashtbl_intf.create_options_without_hashable
        val create_with_key_exn :
          (key, 'r, get_key:('r -> key) -> 'r list -> 'r t)
          Hashtbl_intf.create_options_without_hashable
        val group :
          (key, 'b,
           get_key:('r -> key) ->
           get_data:('r -> 'b) -> combine:('b -> 'b -> 'b) -> 'r list -> 'b t)
          Hashtbl_intf.create_options_without_hashable
        val sexp_of_key : 'a t -> key -> Sexp.t
        val clear : 'a t -> unit
        val copy : 'b t -> 'b t
        val fold :
          'b t -> init:'c -> f:(key:key -> data:'b -> 'c -> 'c) -> 'c
        val iter_keys : 'a t -> f:(key -> unit) -> unit
        val iter : 'b t -> f:('b -> unit) -> unit
        val iteri : 'b t -> f:(key:key -> data:'b -> unit) -> unit
        val iter_vals : 'b t -> f:('b -> unit) -> unit
        val existsi : 'b t -> f:(key:key -> data:'b -> bool) -> bool
        val exists : 'b t -> f:('b -> bool) -> bool
        val for_alli : 'b t -> f:(key:key -> data:'b -> bool) -> bool
        val for_all : 'b t -> f:('b -> bool) -> bool
        val counti : 'b t -> f:(key:key -> data:'b -> bool) -> int
        val count : 'b t -> f:('b -> bool) -> int
        val length : 'a t -> int
        val is_empty : 'a t -> bool
        val mem : 'a t -> key -> bool
        val remove : 'a t -> key -> unit
        val replace : 'b t -> key:key -> data:'b -> unit
        val set : 'b t -> key:key -> data:'b -> unit
        val add : 'b t -> key:key -> data:'b -> [ `Duplicate | `Ok ]
        val add_exn : 'b t -> key:key -> data:'b -> unit
        val change : 'b t -> key -> f:('b option -> 'b option) -> unit
        val update : 'b t -> key -> f:('b option -> 'b) -> unit
        val add_multi : 'b list t -> key:key -> data:'b -> unit
        val remove_multi : 'a list t -> key -> unit
        val find_multi : 'b list t -> key -> 'b list
        val map : 'b t -> f:('b -> 'c) -> 'c t
        val mapi : 'b t -> f:(key:key -> data:'b -> 'c) -> 'c t
        val filter_map : 'b t -> f:('b -> 'c option) -> 'c t
        val filter_mapi : 'b t -> f:(key:key -> data:'b -> 'c option) -> 'c t
        val filter_keys : 'b t -> f:(key -> bool) -> 'b t
        val filter : 'b t -> f:('b -> bool) -> 'b t
        val filteri : 'b t -> f:(key:key -> data:'b -> bool) -> 'b t
        val partition_map :
          'b t -> f:('b -> [ `Fst of 'c | `Snd of 'd ]) -> 'c t * 'd t
        val partition_mapi :
          'b t ->
          f:(key:key -> data:'b -> [ `Fst of 'c | `Snd of 'd ]) ->
          'c t * 'd t
        val partition_tf : 'b t -> f:('b -> bool) -> 'b t * 'b t
        val partitioni_tf :
          'b t -> f:(key:key -> data:'b -> bool) -> 'b t * 'b t
        val find_or_add : 'b t -> key -> default:(unit -> 'b) -> 'b
        val find : 'b t -> key -> 'b option
        val find_exn : 'b t -> key -> 'b
        val find_and_call :
          'b t ->
          key -> if_found:('b -> 'c) -> if_not_found:(key -> 'c) -> 'c
        val find_and_remove : 'b t -> key -> 'b option
        val merge :
          'a t ->
          'b t ->
          f:(key:key ->
             [ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] -> 'c option) ->
          'c t
        type 'a merge_into_action = Remove | Set_to of 'a
        val merge_into :
          src:'a t ->
          dst:'b t ->
          f:(key:key -> 'a -> 'b option -> 'b merge_into_action) -> unit
        val keys : 'a t -> key list
        val data : 'b t -> 'b list
        val filter_keys_inplace : 'a t -> f:(key -> bool) -> unit
        val filter_inplace : 'b t -> f:('b -> bool) -> unit
        val filteri_inplace : 'b t -> f:(key:key -> data:'b -> bool) -> unit
        val map_inplace : 'b t -> f:('b -> 'b) -> unit
        val mapi_inplace : 'b t -> f:(key:key -> data:'b -> 'b) -> unit
        val filter_map_inplace : 'b t -> f:('b -> 'b option) -> unit
        val filter_mapi_inplace :
          'b t -> f:(key:key -> data:'b -> 'b option) -> unit
        val replace_all : 'b t -> f:('b -> 'b) -> unit
        val replace_alli : 'b t -> f:(key:key -> data:'b -> 'b) -> unit
        val filter_replace_all : 'b t -> f:('b -> 'b option) -> unit
        val filter_replace_alli :
          'b t -> f:(key:key -> data:'b -> 'b option) -> unit
        val equal : 'b t -> 'b t -> ('b -> 'b -> bool) -> bool
        val similar : 'b1 t -> 'b2 t -> ('b1 -> 'b2 -> bool) -> bool
        val to_alist : 'b t -> (key * 'b) list
        val validate :
          name:(key -> string) -> 'b Validate.check -> 'b t Validate.check
        val incr : ?by:int -> ?remove_if_zero:bool -> int t -> key -> unit
        val decr : ?by:int -> ?remove_if_zero:bool -> int t -> key -> unit
        module Provide_of_sexp :
          functor (Key : sig val t_of_sexp : Sexp.t -> key end) ->
            sig
              val t_of_sexp :
                (Sexp.t -> 'v_x__001_) -> Sexp.t -> 'v_x__001_ t
            end
        module Provide_bin_io :
          functor
            (Key : sig
                     val bin_t : key Bin_prot.Type_class.t0
                     val bin_read_t : key Bin_prot.Read.reader
                     val __bin_read_t__ : (int -> key) Bin_prot.Read.reader
                     val bin_reader_t : key Bin_prot.Type_class.reader0
                     val bin_size_t : key Bin_prot.Size.sizer
                     val bin_write_t : key Bin_prot.Write.writer
                     val bin_writer_t : key Bin_prot.Type_class.writer0
                     val bin_shape_t : Bin_prot.Shape.t
                   end) ->
            sig
              val bin_t :
                'a Bin_prot.Type_class.t0 -> 'a t Bin_prot.Type_class.t0
              val bin_read_t :
                'a Bin_prot.Read.reader -> 'a t Bin_prot.Read.reader
              val __bin_read_t__ :
                'a Bin_prot.Read.reader -> (int -> 'a t) Bin_prot.Read.reader
              val bin_reader_t :
                'a Bin_prot.Type_class.reader0 ->
                'a t Bin_prot.Type_class.reader0
              val bin_size_t :
                'a Bin_prot.Size.sizer -> 'a t Bin_prot.Size.sizer
              val bin_write_t :
                'a Bin_prot.Write.writer -> 'a t Bin_prot.Write.writer
              val bin_writer_t :
                'a Bin_prot.Type_class.writer0 ->
                'a t Bin_prot.Type_class.writer0
              val bin_shape_t : Bin_prot.Shape.t -> Bin_prot.Shape.t
            end
        val t_of_sexp : (Sexp.t -> 'v_x__002_) -> Sexp.t -> 'v_x__002_ t
      end
    module Hash_set :
      sig
        type elt = t
        type t = elt Hash_set.t
        val sexp_of_t : t -> Sexp.t
        type 'a t_ = t
        type 'a elt_ = elt
        val create :
          ('a, unit -> t)
          Core_kernel__.Hash_set_intf.create_options_without_hashable
        val of_list :
          ('a, elt list -> t)
          Core_kernel__.Hash_set_intf.create_options_without_hashable
        module Provide_of_sexp :
          functor (X : sig val t_of_sexp : Sexp.t -> elt end) ->
            sig val t_of_sexp : Sexp.t -> t end
        module Provide_bin_io :
          functor
            (X : sig
                   val bin_t : elt Bin_prot.Type_class.t0
                   val bin_read_t : elt Bin_prot.Read.reader
                   val __bin_read_t__ : (int -> elt) Bin_prot.Read.reader
                   val bin_reader_t : elt Bin_prot.Type_class.reader0
                   val bin_size_t : elt Bin_prot.Size.sizer
                   val bin_write_t : elt Bin_prot.Write.writer
                   val bin_writer_t : elt Bin_prot.Type_class.writer0
                   val bin_shape_t : Bin_prot.Shape.t
                 end) ->
            sig
              val bin_t : t Bin_prot.Type_class.t0
              val bin_read_t : t Bin_prot.Read.reader
              val __bin_read_t__ : (int -> t) Bin_prot.Read.reader
              val bin_reader_t : t Bin_prot.Type_class.reader0
              val bin_size_t : t Bin_prot.Size.sizer
              val bin_write_t : t Bin_prot.Write.writer
              val bin_writer_t : t Bin_prot.Type_class.writer0
              val bin_shape_t : Bin_prot.Shape.t
            end
        val t_of_sexp : Sexp.t -> t
      end
    module Hash_queue :
      sig
        module Key :
          sig
            type t = Hash_set.elt
            val compare : t -> t -> int
            val sexp_of_t : t -> Sexp.t
            val hash : t -> int
          end
        type 'a t
        val sexp_of_t : ('a -> Sexp.t) -> 'a t -> Sexp.t
        val length : 'a t -> int
        val is_empty : 'a t -> bool
        val iter : 'a t -> f:('a -> unit) -> unit
        val fold :
          'a t -> init:'accum -> f:('accum -> 'a -> 'accum) -> 'accum
        val fold_result :
          'a t ->
          init:'accum ->
          f:('accum -> 'a -> ('accum, 'e) result) -> ('accum, 'e) result
        val fold_until :
          'a t ->
          init:'accum ->
          f:('accum -> 'a -> ('accum, 'stop) Set_intf.Continue_or_stop.t) ->
          ('accum, 'stop) Set_intf.Finished_or_stopped_early.t
        val exists : 'a t -> f:('a -> bool) -> bool
        val for_all : 'a t -> f:('a -> bool) -> bool
        val count : 'a t -> f:('a -> bool) -> int
        val sum :
          (module Base__.Commutative_group.S with type t = 'sum) ->
          'a t -> f:('a -> 'sum) -> 'sum
        val find : 'a t -> f:('a -> bool) -> 'a option
        val find_map : 'a t -> f:('a -> 'b option) -> 'b option
        val to_list : 'a t -> 'a list
        val to_array : 'a t -> 'a array
        val min_elt : 'a t -> cmp:('a -> 'a -> int) -> 'a option
        val max_elt : 'a t -> cmp:('a -> 'a -> int) -> 'a option
        val invariant : 'a t -> unit
        val create : ?growth_allowed:bool -> ?size:int -> unit -> 'a t
        val clear : 'a t -> unit
        val mem : 'a t -> Key.t -> bool
        val lookup : 'a t -> Key.t -> 'a option
        val lookup_exn : 'a t -> Key.t -> 'a
        val enqueue : 'a t -> Key.t -> 'a -> [ `Key_already_present | `Ok ]
        val enqueue_exn : 'a t -> Key.t -> 'a -> unit
        val lookup_and_move_to_back : 'a t -> Key.t -> 'a option
        val lookup_and_move_to_back_exn : 'a t -> Key.t -> 'a
        val first : 'a t -> 'a option
        val first_with_key : 'a t -> (Key.t * 'a) option
        val keys : 'a t -> Key.t list
        val dequeue : 'a t -> 'a option
        val dequeue_exn : 'a t -> 'a
        val dequeue_with_key : 'a t -> (Key.t * 'a) option
        val dequeue_with_key_exn : 'a t -> Key.t * 'a
        val dequeue_all : 'a t -> f:('a -> unit) -> unit
        val remove : 'a t -> Key.t -> [ `No_such_key | `Ok ]
        val remove_exn : 'a t -> Key.t -> unit
        val replace : 'a t -> Key.t -> 'a -> [ `No_such_key | `Ok ]
        val replace_exn : 'a t -> Key.t -> 'a -> unit
        val iteri : 'a t -> f:(key:Key.t -> data:'a -> unit) -> unit
        val foldi :
          'a t -> init:'b -> f:('b -> key:Key.t -> data:'a -> 'b) -> 'b
      end
  end
|}];;
