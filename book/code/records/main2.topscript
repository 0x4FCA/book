open Core.Std;;

(* part 17 *)
module Log_entry = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      important: bool;
      message: string;
    }
end;;
module Heartbeat = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      status_message: string;
    }
end;;
module Logon = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      user: string;
      credentials: string;
    }
end;;

(* part 18 *)
let create_log_entry ~session_id ~important message =
  { Log_entry.time = Time_ns.now (); 
    Log_entry.session_id; 
    Log_entry.important; 
    Log_entry.message
  }
;;

(* part 19 *)
let create_log_entry ~session_id ~important message =
  { Log_entry.
    time = Time_ns.now (); session_id; important; message }
;;

(* part 20 *)
let message_to_string { Log_entry.important; message; _ } =
  if important then String.uppercase message else message
;;

(* part 21 *)
let is_important t = t.Log_entry.important;;

(* part 21.1 *)

let create_log_entry ~session_id ~important message : Log_entry.t =
  { time = Time_ns.now (); session_id; important; message }
let message_to_string ({ important; message; _ } : Log_entry.t) =
  if important then String.uppercase message else message
let is_important (t:Log_entry.t) = t.important ;;

(* part 22 *)
type client_info =
  { addr: Unix.Inet_addr.t;
    port: int;
    user: string;
    credentials: string;
    last_heartbeat_time: Time_ns.t;
  };;

let register_heartbeat t hb =
  { addr = t.addr;
    port = t.port;
    user = t.user;
    credentials = t.credentials;
    last_heartbeat_time = hb.Heartbeat.time;
  };;

(* part 23 *)
let register_heartbeat t hb =
  { t with last_heartbeat_time = hb.Heartbeat.time };;

(* part 24 *)
type client_info =
  { addr: Unix.Inet_addr.t;
    port: int;
    user: string;
    credentials: string;
    last_heartbeat_time: Time_ns.t;
    last_heartbeat_status: string;
  };;

(* part 25 *)
let register_heartbeat t hb =
  { t with last_heartbeat_time   = hb.Heartbeat.time;
           last_heartbeat_status = hb.Heartbeat.status_message;
  };;

(* part 26 *)
type client_info =
  { addr: Unix.Inet_addr.t;
    port: int;
    user: string;
    credentials: string;
    mutable last_heartbeat_time: Time_ns.t;
    mutable last_heartbeat_status: string;
  };;

(* part 27 *)
let register_heartbeat t hb =
  t.last_heartbeat_time   <- hb.Heartbeat.time;
  t.last_heartbeat_status <- hb.Heartbeat.status_message
;;

(* part 28 *)
let get_users logons =
  List.dedup (List.map logons ~f:(fun x -> x.Logon.user));;

(* part 29 *)
module Logon = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      user: string;
      credentials: string;
    }
  with fields
end;;

(* part 30 *)
let get_users logons = List.dedup (List.map logons ~f:Logon.user);;

(* part 31 *)
Field.get Logon.Fields.user;;

(* part 32 *)
Field.get;;

(* part 33 *)
let show_field field to_string record =
  let name = Field.name field in
  let field_string = to_string (Field.get field record) in
  name ^ ": " ^ field_string
;;

(* part 34 *)
let logon = { Logon.
              session_id = "26685";
              time = Time_ns.now ();
              user = "yminsky";
              credentials = "Xy2d9W"; }
;;

show_field Logon.Fields.user Fn.id logon;;

show_field Logon.Fields.time Time_ns.to_string logon;;

(* part 35 *)
Logon.Fields.iter;;

(* part 36 *)
let print_logon logon =
  let print to_string field =
    printf "%s\n" (show_field field to_string logon)
  in
  Logon.Fields.iter
    ~session_id:(print Fn.id)
    ~time:(print Time_ns.to_string)
    ~user:(print Fn.id)
    ~credentials:(print Fn.id)
;;

print_logon logon;;

