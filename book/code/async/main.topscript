#use "topfind";;
#thread;;
#camlp4o;;
#require "core";;
#require "ppx_jane";;

[%%expect];;
[@@@part "1"];;
open Core;;
In_channel.read_all;;

Out_channel.write_all "test.txt" ~data:"This is only a test.";;

In_channel.read_all "test.txt";;

[%%expect];;
[@@@part "3"];;
#require "async";;
open Async;;
Reader.file_contents;;


[%%expect];;
[@@@part "4"];;
let contents = Reader.file_contents "test.txt";;

Deferred.peek contents;;


[%%expect];;
[@@@part "5"];;
contents;;


[%%expect];;
[@@@part "6"];;
Deferred.peek contents;;


[%%expect];;
[@@@part "7"];;
Deferred.bind ;;


[%%expect];;
[@@@part "8"];;
let uppercase_file filename =
  Deferred.bind (Reader.file_contents filename)
    (fun text ->
       Writer.save filename ~contents:(String.uppercase text))
;;

uppercase_file "test.txt";;

Reader.file_contents "test.txt";;


[%%expect];;
[@@@part "9"];;
let uppercase_file filename =
  Reader.file_contents filename
  >>= fun text ->
  Writer.save filename ~contents:(String.uppercase text)
;;


[%%expect];;
[@@@part "10"];;
let count_lines filename =
  Reader.file_contents filename
  >>= fun text ->
  List.length (String.split text ~on:'\n')
;;




[%%expect];;
[@@@part "11"];;
return;;

let three = return 3;;

three;;


[%%expect];;
[@@@part "12"];;
let count_lines filename =
  Reader.file_contents filename
  >>= fun text ->
  return (List.length (String.split text ~on:'\n'))
;;


[%%expect];;
[@@@part "13"];;
Deferred.map;;


[%%expect];;
[@@@part "14"];;
let count_lines filename =
  Reader.file_contents filename
  >>| fun text ->
  List.length (String.split text ~on:'\n')
;;

count_lines "/etc/hosts";;


[%%expect];;
[@@@part "15"];;
let ivar = Ivar.create ();;

let def = Ivar.read ivar;;

Deferred.peek def;;

Ivar.fill ivar "Hello";;

Deferred.peek def;;


[%%expect];;
[@@@part "16"];;
module type Delayer_intf = sig
  type t
  val create : Time.Span.t -> t
  val schedule : t -> (unit -> 'a Deferred.t) -> 'a Deferred.t
end;;







[%%expect];;
[@@@part "17"];;
upon;;


[%%expect];;
[@@@part "18"];;
module Delayer : Delayer_intf = struct
  type t = { delay: Time.Span.t;
             jobs: (unit -> unit) Queue.t;
           }

  let create delay =
    { delay; jobs = Queue.create () }

  let schedule t thunk =
    let ivar = Ivar.create () in
    Queue.enqueue t.jobs (fun () ->
      upon (thunk ()) (fun x -> Ivar.fill ivar x));
    upon (after t.delay) (fun () ->
      let job = Queue.dequeue_exn t.jobs in
      job ());
    Ivar.read ivar
end;;


[%%expect];;
[@@@part "19"];;
let rec loop_forever () = loop_forever ();;

let always_fail () = assert false;;


[%%expect];;
[@@@part "20"];;
let do_stuff n =
  let x = 3 in
  if n > 0 then loop_forever ();
  x + n
;;


[%%expect];;
[@@@part "21"];;
let rec loop_forever () : never_returns = loop_forever ();;


[%%expect];;
[@@@part "22"];;
let do_stuff n =
  let x = 3 in
  if n > 0 then loop_forever ();
  x + n
;;




[%%expect];;
[@@@part "23"];;
never_returns;;

let do_stuff n =
  let x = 3 in
  if n > 0 then never_returns (loop_forever ());
  x + n
;;


[%%expect];;
[@@@part "24"];;
let (r,w) = Pipe.create ();;



[%%expect];;
[@@@part "25"];;
let (r,w) = Pipe.create ();;


let write_complete = Pipe.write w "Hello World!";;

Pipe.read r;;

write_complete;;


[%%expect];;
[@@@part "26"];;
Pipe.transfer;;



[%%expect];;
[@@@part "27"];;
Command.async_basic;;





[%%expect];;
[@@@part "28"];;
#require "cohttp.async";;
Cohttp_async.Client.get;;





[%%expect];;
[@@@part "29"];;
Deferred.all;;


[%%expect];;
[@@@part "30"];;
Deferred.all_unit;;


[%%expect];;
[@@@part "31"];;
let maybe_raise =
  let should_fail = ref false in
  fun () ->
    let will_fail = !should_fail in
    should_fail := not will_fail;
    after (Time.Span.of_sec 0.5)
    >>= fun () ->
    if will_fail then raise Exit else return ()
;;

maybe_raise ();;

maybe_raise ();;









[%%expect];;
[@@@part "32"];;
let handle_error () =
  try
    maybe_raise ()
    >>| fun () -> "success"
  with _ -> return "failure"
;;

handle_error ();;

handle_error ();;









[%%expect];;
[@@@part "33"];;
let handle_error () =
  try_with (fun () -> maybe_raise ())
  >>| function
  | Ok ()   -> "success"
  | Error _ -> "failure"
;;

handle_error ();;

handle_error ();;


[%%expect];;
[@@@part "34"];;
let blow_up () =
  let monitor = Monitor.create ~name:"blow up monitor" () in
  within' ~monitor maybe_raise
;;

blow_up ();;

blow_up ();;


[%%expect];;
[@@@part "35"];;
let swallow_error () =
  let monitor = Monitor.create () in
  Stream.iter (Monitor.detach_and_get_error_stream monitor)
    ~f:(fun _exn -> printf "an error happened\n");
  within' ~monitor (fun () ->
    after (Time.Span.of_sec 0.5) >>= fun () -> failwith "Kaboom!")
;;

swallow_error ();;



[%%expect];;
[@@@part "36"];;
exception Ignore_me;;

let swallow_some_errors exn_to_raise =
  let child_monitor  = Monitor.create  () in
  let parent_monitor = Monitor.current () in
  Stream.iter (Monitor.detach_and_get_error_stream child_monitor)
    ~f:(fun error ->
      match Monitor.extract_exn error with
      | Ignore_me -> printf "ignoring exn\n"
      | _ -> Monitor.send_exn parent_monitor error);
  within' ~monitor:child_monitor (fun () ->
    after (Time.Span.of_sec 0.5)
    >>= fun () -> raise exn_to_raise)
;;


[%%expect];;
[@@@part "37"];;
swallow_some_errors Not_found;;


[%%expect];;
[@@@part "38"];;
swallow_some_errors Ignore_me;;


[%%expect];;
[@@@part "39"];;
let string_and_float = Deferred.both
                         (after (sec 0.5)  >>| fun () -> "A")
                         (after (sec 0.25) >>| fun () -> 32.33);;

string_and_float;;


[%%expect];;
[@@@part "40"];;
Deferred.any [ (after (sec 0.5) >>| fun () -> "half a second")
             ; (after (sec 10.) >>| fun () -> "ten seconds") ] ;;


[%%expect];;
[@@@part "41"];;
choice;;

choose;;


[%%expect];;
[@@@part "42"];;
let def = In_thread.run (fun () -> List.range 1 10);;

def;;


[%%expect];;
[@@@part "43"];;
let log_delays thunk =
  let start = Time.now () in
  let print_time () =
    let diff = Time.diff (Time.now ()) start in
    printf "%s, " (Time.Span.to_string diff)
  in
  let d = thunk () in
  Clock.every (sec 0.1) ~stop:d print_time;
  d >>| fun () -> print_time (); printf "\n"
;;


[%%expect];;
[@@@part "44"];;
log_delays (fun () -> after (sec 0.5));;

[%%expect];;
[@@@part "45"];;
let busy_loop () =
  let x = ref None in
  for i = 1 to 100_000_000 do x := Some i done
;;

log_delays (fun () -> return (busy_loop ()));;


[%%expect];;
[@@@part "46"];;
log_delays (fun () -> In_thread.run busy_loop);;

[%%expect];;
[@@@part "47"];;
let noalloc_busy_loop () =
  for i = 0 to 100_000_000 do () done
;;

log_delays (fun () -> In_thread.run noalloc_busy_loop);;
