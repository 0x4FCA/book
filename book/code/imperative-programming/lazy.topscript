#use "topfind";;
#thread;;
#camlp4o;;
#require "core";;
#require "core.syntax";;
open Core_kernel.Std;;

[%%expect{|
- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
|}]
[@@@part "1"];;
let v = lazy (print_string "performing lazy computation\n"; sqrt 16.);;

Lazy.force v;;


Lazy.force v;;


[%%expect{|
performing lazy computation
|}]
[@@@part "2"];;
type 'a lazy_state =
  | Delayed of (unit -> 'a)
  | Value of 'a
  | Exn of exn
;;


[%%expect]
[@@@part "3"];;
let create_lazy f = ref (Delayed f);;

let v = create_lazy
          (fun () -> print_string "performing lazy computation\n"; sqrt 16.);;


[%%expect]
[@@@part "4"];;
let force v =
  match !v with
  | Value x -> x
  | Exn e -> raise e
  | Delayed f ->
    try
      let x = f () in
      v := Value x;
      x
    with exn ->
      v := Exn exn;
      raise exn
;;


[%%expect]
[@@@part "5"];;
force v;;


force v;;

[%%expect{|
performing lazy computation
|}]