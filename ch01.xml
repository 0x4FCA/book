<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="a-guided-tour">
  <title>A Guided Tour</title>

  <para>This chapter gives an overview of OCaml by walking through a series of
  small examples that cover most of the major features of the language. This
  should provide a sense of what OCaml can do, without getting too deep into
  any one topic.</para>

  <para>Throughout the book we're going to use Core, a more full-featured and
  capable replacement for OCaml's standard library. We'll also use <command
  moreinfo="none">utop</command>, a shell that lets you type in expressions
  and evaluate them interactively. <command moreinfo="none">utop</command> is
  an easier-to-use version of OCaml's standard toplevel (which you can start
  by typing <userinput>ocaml</userinput> at the command line). These
  instructions will assume you're using <command
  moreinfo="none">utop</command> specifically.</para>

  <para>Before getting started, make sure you have a working OCaml
  installation so you can try out the examples as you read through the
  chapter. Look at <xref linkend="installation" /> for details.</para>

  <sect1 id="ocaml-as-a-calculator">
    <title>OCaml as a Calculator</title>

    <para>The first thing you need to do when using Core is to open<indexterm
        class="singular">
        <primary>OCaml</primary>

        <secondary>numerical calculations in</secondary>
      </indexterm><indexterm class="singular">
        <primary>numerical calculations</primary>
      </indexterm><indexterm class="singular">
        <primary>Core standard library</primary>

        <secondary>opening</secondary>
      </indexterm> <literal moreinfo="none">Core.Std</literal>:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">open Core.Std;;</userinput>
</programlisting>

    <para>This makes the definitions in Core available and is required for
    many of the examples in the tour and in the remainder of the book.</para>

    <para>Now let's try a few simple numerical calculations:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">3 + 4;;</userinput>
<computeroutput moreinfo="none">- : int = 7</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">8 / 3;;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">3.5 +. 6.;;</userinput>
<computeroutput moreinfo="none">- : float = 9.5</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">30_000_000 / 300_000;;</userinput>
<computeroutput moreinfo="none">- : int = 100</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sqrt 9.;;</userinput>
<computeroutput moreinfo="none">- : float = 3.</computeroutput></programlisting>

    <para>By and large, this is pretty similar to what you'd find in any
    programming language, but a few things jump right out at you:</para>

    <itemizedlist>
      <listitem>
        <para>We needed to type <literal moreinfo="none">;;</literal> in order
        to tell the toplevel that it should evaluate an expression. This is a
        peculiarity of the toplevel that is not required in standalone
        programs (though it is sometimes helpful to include <literal
        moreinfo="none">;;</literal> to improve OCaml's error reporting, by
        making it more explicit where a given top-level declaration was
        intended to end).</para>
      </listitem>

      <listitem>
        <para>After evaluating an expression, the toplevel prints first the
        result and then the type of the result.</para>
      </listitem>

      <listitem>
        <para>Function arguments are separated by spaces instead of by
        parentheses and commas, which is more like the UNIX shell than it is
        like traditional programming languages such as C or Java.</para>
      </listitem>

      <listitem>
        <para>OCaml allows you to place underscores in the middle of your
        numeric literals to improve readability. Note that underscores can be
        placed anywhere within a number, not just every three digits.</para>
      </listitem>

      <listitem>
        <para>OCaml carefully distinguishes between <literal
        moreinfo="none">float</literal>, the type for floating-point numbers,
        and <literal moreinfo="none">int</literal>, the type for integers. The
        types have different literals (<literal moreinfo="none">6.</literal>
        instead of <literal moreinfo="none">6</literal>) and different infix
        operators (<literal moreinfo="none">+.</literal> instead of <literal
        moreinfo="none">+</literal>), and OCaml doesn't automatically cast
        between these types. This can be a bit of a nuisance, but it has its
        benefits, since it prevents some kinds of bugs that arise in other
        languages due to unexpected differences between the behavior of
        <literal moreinfo="none">int</literal> and <literal
        moreinfo="none">float</literal>. For example, in many languages,
        <literal moreinfo="none">1 / 3</literal> is <literal
        moreinfo="none">0</literal>, but <literal moreinfo="none">1 /
        3.0</literal> is a third. OCaml requires you to be explicit about
        which operation you're doing.</para>
      </listitem>
    </itemizedlist>

    <para>We can also create a variable to name the value of a given
    expression, using the <literal moreinfo="none">let</literal> keyword. This
    is known as a <emphasis>let binding</emphasis>:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let x = 3 + 4;;</userinput>
<computeroutput moreinfo="none">val x : int = 7</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let y = x + x;;</userinput>
<computeroutput moreinfo="none">val y : int = 14</computeroutput></programlisting>

    <para>After a new variable is created, the toplevel tells us the name of
    the variable (<literal moreinfo="none">x</literal> or <literal
    moreinfo="none">y</literal>), in addition to its type (<literal
    moreinfo="none">int</literal>) and value (<literal
    moreinfo="none">7</literal> or <literal
    moreinfo="none">14</literal>).</para>

    <para>Note that there are some constraints on what identifiers can be used
    for variable names. Punctuation is excluded, except for <literal
    moreinfo="none">_</literal> and <literal moreinfo="none">'</literal>, and
    variables must start with a lowercase letter or an underscore. Thus, these
    are legal:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let x7 = 3 + 4;;</userinput>
<computeroutput moreinfo="none">val x7 : int = 7</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x_plus_y = x + y;;</userinput>
<computeroutput moreinfo="none">val x_plus_y : int = 21</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x' = x + 1;;</userinput>
<computeroutput moreinfo="none">val x' : int = 8</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let _x' = x' + x';;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">_x';;</userinput>
<computeroutput moreinfo="none">- : int = 16</computeroutput></programlisting>

    <para>Note that by default, <command moreinfo="none">utop</command>
    doesn't bother to print out variables starting with an underscore.</para>

    <para>The following examples, however, are not legal:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let Seven = 3 + 4;;</userinput>
<computeroutput moreinfo="none">Characters 4-9:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound constructor Seven</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let 7x = 7;;</userinput>
<computeroutput moreinfo="none">Characters 5-10:</computeroutput>
<computeroutput moreinfo="none">Error: This expression should not be a function, the expected type is</computeroutput>
<computeroutput moreinfo="none">int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x-plus-y = x + y;;</userinput>
<computeroutput moreinfo="none">Characters 4-5:</computeroutput>
<computeroutput moreinfo="none">Error: Parse error: [fun_binding] expected after [ipatt] (in [let_binding])</computeroutput></programlisting>

    <para>The error messages here are a little confusing, but they'll make
    more sense as you learn more about the language.</para>
  </sect1>

  <sect1 id="functions-and-type-inference">
    <title>Functions and Type Inference</title>

    <para>The <literal moreinfo="none">let</literal> syntax can also be used
    to define a function:<indexterm class="singular">
        <primary>let syntax</primary>

        <secondary>function definition with</secondary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>defining</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let square x = x * x ;;</userinput>
<computeroutput moreinfo="none">val square : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">square 2;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">square (square 2);;</userinput>
<computeroutput moreinfo="none">- : int = 16</computeroutput></programlisting>

    <para>Functions in OCaml are values like any other, which is why we use
    the <literal moreinfo="none">let</literal> keyword to bind a function to a
    variable name, just as we use <literal moreinfo="none">let</literal> to
    bind a simple value like an integer to a variable name. When using
    <literal moreinfo="none">let</literal> to define a function, the first
    identifier after the <literal moreinfo="none">let</literal> is the
    function name, and each subsequent identifier is a different argument to
    the function. Thus, <literal moreinfo="none">square</literal> is a
    function with a single argument.</para>

    <para>Now that we're creating more interesting values like functions, the
    types have gotten more interesting too. <literal moreinfo="none">int -&gt;
    int</literal> is a function type, in this case indicating a function that
    takes an <literal moreinfo="none">int</literal> and returns an <literal
    moreinfo="none">int</literal>. We can also write functions that take
    multiple arguments. (Note that the following example will not work if you
    haven't opened <literal moreinfo="none">Core.Std</literal> as was
    suggested earlier.)<indexterm class="singular">
        <primary>multi-argument functions</primary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>with multiple arguments</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let ratio x y =</userinput>
<userinput moreinfo="none">     Float.of_int x /. Float.of_int y</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val ratio : int -&gt; int -&gt; float = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">ratio 4 7;;</userinput>
<computeroutput moreinfo="none">- : float = 0.571428571429</computeroutput></programlisting>

    <para>The preceding example also happens to be our first use of modules.
    Here, <literal moreinfo="none">Float.of_int</literal> refers to the
    <literal moreinfo="none">of_int</literal> function contained in the
    <literal moreinfo="none">Float</literal> module. This is different from
    what you might expect from an object-oriented language, where dot-notation
    is typically used for accessing a method of an object. Note that module
    names always start with a capital letter.</para>

    <para>The notation for the type-signature of a multiargument function may
    be a little surprising at first, but we'll explain where it comes from
    when we get to function currying in <xref
    linkend="multi-argument-functions" />. For the moment, think of the arrows
    as separating different arguments of the function, with the type after the
    final arrow being the return value. Thus, <literal moreinfo="none">int
    -&gt; int -&gt; float</literal> describes a function that takes two
    <literal moreinfo="none">int</literal> arguments and returns a <literal
    moreinfo="none">float</literal>.</para>

    <para>We can also write functions that take other functions as arguments.
    Here's an example of a function that takes three arguments: a test
    function and two integer arguments. The function returns the sum of the
    integers that pass the test:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let sum_if_true test first second =</userinput>
<userinput moreinfo="none">    (if test first then first else 0)</userinput>
<userinput moreinfo="none">    + (if test second then second else 0)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>If we look at the inferred type signature in detail, we see that the
    first argument is a function that takes an integer and returns a boolean,
    and that the remaining two arguments are integers. Here's an example of
    this function in action:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let even x =</userinput>
<userinput moreinfo="none">    x mod 2 = 0 ;;</userinput>
<computeroutput moreinfo="none">val even : int -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_if_true even 3 4;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_if_true even 2 4;;</userinput>
<computeroutput moreinfo="none">- : int = 6</computeroutput></programlisting>

    <para>Note that in the definition of <literal
    moreinfo="none">even</literal>, we used <literal
    moreinfo="none">=</literal> in two different ways: once as the part of the
    <literal>let</literal> binding that separates the thing being defined from
    its definition; and once as an equality test, when comparing <literal
    moreinfo="none">x mod 2</literal> to <literal moreinfo="none">0</literal>.
    These are very different operations despite the fact that they share some
    syntax.</para>

    <sect2 id="type-inference">
      <title>Type Inference</title>

      <para>As the types we encounter get more complicated, you might ask
      yourself how OCaml is able to figure them out, given that we didn't
      write down any explicit type information.<indexterm class="singular">
          <primary>type inference</primary>

          <secondary>process of</secondary>
        </indexterm></para>

      <para>OCaml determines the type of an expression using a technique
      called <emphasis>type inference</emphasis>, by which it infers the type
      of a given expression from the information it has about the types of
      variables, along with constraints that are implied by the structure of
      the expression.</para>

      <para>As an example, let's walk through the process of inferring the
      type of <literal moreinfo="none">sum_if_true</literal>:</para>

      <orderedlist>
        <listitem>
          <para>OCaml requires that both branches of an <literal
          moreinfo="none">if</literal> statement have the same type, so the
          expression <literal moreinfo="none">if test first then first else
          0</literal> requires that <literal moreinfo="none">first</literal>
          must be the same type as <literal moreinfo="none">0</literal>, and
          so <literal moreinfo="none">first</literal> must be of type <literal
          moreinfo="none">int</literal>. Similarly, from <literal
          moreinfo="none">if test second then second else 0</literal> we can
          infer that <literal moreinfo="none">second</literal> has type
          <literal moreinfo="none">int</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">test</literal> is passed <literal
          moreinfo="none">first</literal> as an argument. Since <literal
          moreinfo="none">first</literal> has type <literal
          moreinfo="none">int</literal>, the input type of <literal
          moreinfo="none">test</literal> must be <literal
          moreinfo="none">int</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">test first</literal> is used as the
          condition in an <literal moreinfo="none">if</literal> statement, so
          the return type of <literal moreinfo="none">test</literal> must be
          <literal moreinfo="none">bool</literal>.</para>
        </listitem>

        <listitem>
          <para>The fact that <literal moreinfo="none">+</literal> returns
          <literal moreinfo="none">int</literal> implies that the return value
          of <literal moreinfo="none">sum_if_true</literal> must be
          int.</para>
        </listitem>
      </orderedlist>

      <para>Together, that nails down the types of all the variables, which
      determines the overall type of <literal
      moreinfo="none">sum_if_true</literal>.</para>

      <para>Over time, you'll build a rough intuition for how the OCaml
      inference engine works, which makes it easier to reason through your
      programs. You can make it easier to understand the types of a given
      expression by adding explicit type annotations. These annotations don't
      change the behavior of an OCaml program, but they can serve as useful
      documentation, as well as catch unintended type changes. They can also
      be helpful in figuring out why a given piece of code fails to
      compile.</para>

      <para>Here's an annotated version of <literal
      moreinfo="none">sum_if_true</literal>:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let sum_if_true (test : int -&gt; bool) (x : int) (y : int) : int =</userinput>
<userinput moreinfo="none">     (if test x then x else 0)</userinput>
<userinput moreinfo="none">     + (if test y then y else 0)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>In the above, we've marked every argument to the function with its
      type, with the final annotation indicating the type of the return value.
      Such type annotations can be placed on any expression in an OCaml
      program:</para>
    </sect2>

    <sect2 id="inferring-generic-types">
      <title>Inferring Generic Types</title>

      <para>Sometimes, there isn't enough information to fully determine the
      concrete type of a given value. Consider this function.<indexterm
          class="singular">
          <primary>type inference</primary>

          <secondary>generic types</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let first_if_true test x y =</userinput>
<userinput moreinfo="none">    if test x then x else y</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val first_if_true : ('a -&gt; bool) -&gt; 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

      <para><literal moreinfo="none">first_if_true</literal> takes as its
      arguments a function <literal moreinfo="none">test</literal>, and two
      values, <literal moreinfo="none">x</literal> and <literal
      moreinfo="none">y</literal>, where <literal moreinfo="none">x</literal>
      is to be returned if <literal moreinfo="none">test x</literal> evaluates
      to <literal moreinfo="none">true</literal>, and <literal
      moreinfo="none">y</literal> otherwise. So what's the type of <literal
      moreinfo="none">first_if_true</literal>? There are no obvious clues such
      as arithmetic operators or literals to tell you what the type of
      <literal moreinfo="none">x</literal> and <literal
      moreinfo="none">y</literal> are. That makes it seem like one could use
      <literal moreinfo="none">first_if_true</literal> on values of any
      type.</para>

      <para>Indeed, if we look at the type returned by the toplevel, we see
      that rather than choose a single concrete type, OCaml has introduced a
      <emphasis>type variable</emphasis> <literal moreinfo="none">'a</literal>
      to express that the type is generic. (You can tell it's a type variable
      by the leading single quote mark.) In particular, the type of the
      <literal moreinfo="none">test</literal> argument is <literal
      moreinfo="none">('a -&gt; bool)</literal>, which means that <literal
      moreinfo="none">test</literal> is a one-argument function whose return
      value is <literal moreinfo="none">bool</literal> and whose argument
      could be of any type <literal moreinfo="none">'a</literal>. But,
      whatever type <literal moreinfo="none">'a</literal> is, it has to be the
      same as the type of the other two arguments, <literal
      moreinfo="none">x</literal> and <literal moreinfo="none">y</literal>,
      and of the return value of <literal
      moreinfo="none">first_if_true</literal>. This kind of genericity is
      called <emphasis>parametric polymorphism</emphasis> and is very similar
      to generics in C# and Java.<indexterm class="singular">
          <primary>parametric polymorphism</primary>
        </indexterm><indexterm class="singular">
          <primary>type variables</primary>
        </indexterm></para>

      <para>The generic type of <literal
      moreinfo="none">first_if_true</literal> allows us to write this:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let long_string s = String.length s &gt; 6;;</userinput>
<computeroutput moreinfo="none">val long_string : string -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">first_if_true long_string "short" "loooooong";;</userinput>
<computeroutput moreinfo="none">- : string = "loooooong"</computeroutput></programlisting>

      <para>As well as this:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let big_number x = x &gt; 3;;</userinput>
<computeroutput moreinfo="none">val big_number : int -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">first_if_true big_number 4 3;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput></programlisting>

      <para>Both <literal moreinfo="none">long_string</literal> and <literal
      moreinfo="none">big_number</literal> are functions, and each is passed
      to <literal moreinfo="none">first_if_true</literal> with two other
      arguments of the appropriate type (strings in the first example, and
      integers in the second). But we can't mix and match two different
      concrete types for <literal moreinfo="none">'a</literal> in the same use
      of <literal moreinfo="none">first_if_true</literal>:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">first_if_true big_number "short" "loooooong";;</userinput>
<computeroutput moreinfo="none">Characters 25-32:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

      <para>In this example, <literal moreinfo="none">big_number</literal>
      requires that <literal moreinfo="none">'a</literal> be instantiated as
      <literal moreinfo="none">int</literal>, whereas <literal
      moreinfo="none">"short"</literal> and <literal
      moreinfo="none">"loooooong"</literal> require that <literal
      moreinfo="none">'a</literal> be instantiated as <literal
      moreinfo="none">string</literal>, and they can't both be right at the
      same time.</para>

      <note>
        <title>Type Errors Versus Exceptions</title>

        <para>There's a big difference in OCaml (and really in any compiled
        language) between errors that are caught at compile time and those
        that are caught at runtime. It's better to catch errors as early as
        possible in the development process, and compilation time is best of
        all.<indexterm class="singular">
            <primary>runtime exceptions vs. type errors</primary>
          </indexterm><indexterm class="singular">
            <primary>errors</primary>

            <secondary>runtime vs. compile time</secondary>
          </indexterm><indexterm class="singular">
            <primary>exceptions</primary>

            <secondary>vs. type errors</secondary>
          </indexterm><indexterm class="singular">
            <primary>type errors vs. exceptions</primary>
          </indexterm></para>

        <para>Working in the toplevel somewhat obscures the difference between
        runtime and compile-time errors, but that difference is still there.
        Generally, type errors like this one:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 14)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let add_potato x =</userinput>
<userinput moreinfo="none">     x + "potato";;</userinput>
<computeroutput moreinfo="none">Characters 28-36:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

        <para>are compile-time errors (because <literal
        moreinfo="none">+</literal> requires that both its arguments be of
        type <literal moreinfo="none">int</literal>), whereas errors that
        can't be caught by the type system, like division by zero, lead to
        runtime exceptions:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 15)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let is_a_multiple x y =</userinput>
<userinput moreinfo="none">     x mod y = 0 ;;</userinput>
<computeroutput moreinfo="none">val is_a_multiple : int -&gt; int -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_a_multiple 8 2;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_a_multiple 8 0;;</userinput>
<computeroutput moreinfo="none">Exception: Division_by_zero.</computeroutput></programlisting>

        <para>The distinction here is that type errors will stop you whether
        or not the offending code is ever actually executed. Merely defining
        <literal moreinfo="none">add_potato</literal> is an error, whereas
        <literal moreinfo="none">is_a_multiple</literal> only fails when it's
        called, and then, only when it's called with an input that triggers
        the exception.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="tuples-lists-options-and-pattern-matching">
    <title>Tuples, Lists, Options, and Pattern Matching</title>

    <sect2 id="tuples">
      <title>Tuples</title>

      <para>So far we've encountered a handful of basic types like <literal
      moreinfo="none">int</literal>, <literal moreinfo="none">float</literal>,
      and <literal moreinfo="none">string</literal>, as well as function types
      like <literal moreinfo="none">string -&gt; int</literal>. But we haven't
      yet talked about any data structures. We'll start by looking at a
      particularly simple data structure, the tuple. A tuple is an ordered
      collection of values that can each be of a different type. You can
      create a tuple by joining values together with a comma:<indexterm
          class="singular">
          <primary>tuples</primary>
        </indexterm><indexterm class="singular">
          <primary>data structures</primary>

          <secondary>tuples</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 16)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let a_tuple = (3,"three");;</userinput>
<computeroutput moreinfo="none">val a_tuple : int * string = (3, "three")</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let another_tuple = (3,"four",5.);;</userinput>
<computeroutput moreinfo="none">val another_tuple : int * string * float = (3, "four", 5.)</computeroutput></programlisting>

      <para>(For the mathematically inclined, the <literal
      moreinfo="none">*</literal> character is used because the set of all
      pairs of type <literal moreinfo="none">t * s</literal> corresponds to
      the Cartesian product of the set of elements of type <literal
      moreinfo="none">t</literal> and the set of elements of type <literal
      moreinfo="none">s</literal>.)</para>

      <para>You can extract the components of a tuple using OCaml's
      pattern-matching syntax, as shown below:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 17)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let (x,y) = a_tuple;;</userinput>
<computeroutput moreinfo="none">val x : int = 3</computeroutput>
<computeroutput moreinfo="none">val y : string = "three"</computeroutput></programlisting>

      <para>Here, the <literal moreinfo="none">(x,y)</literal> on the lefthand
      side of the <literal moreinfo="none">let</literal> binding is the
      pattern. This pattern lets us mint the new variables <literal
      moreinfo="none">x</literal> and <literal moreinfo="none">y</literal>,
      each bound to different components of the value being matched, which can
      now be used in subsequent expressions:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 18)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">x + String.length y;;</userinput>
<computeroutput moreinfo="none">- : int = 8</computeroutput></programlisting>

      <para>Note that the same syntax is used both for constructing and for
      pattern matching on tuples.</para>

      <para>Pattern matching can also show up in function arguments. Here's a
      function for computing the distance between two points on the plane,
      where each point is represented as a pair of <literal
      moreinfo="none">float</literal>s. The pattern-matching syntax lets us
      get at the values we need with a minimum of fuss:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 19)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let distance (x1,y1) (x2,y2) =</userinput>
<userinput moreinfo="none">    sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val distance : float * float -&gt; float * float -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

      <para>The <literal moreinfo="none">**</literal> operator used above is
      for raising a floating-point number to a power.</para>

      <para>This is just a first taste of pattern matching. Pattern matching
      is a pervasive tool in OCaml, and as you'll see, it has surprising
      power.</para>
    </sect2>

    <sect2 id="lists">
      <title>Lists</title>

      <para>Where tuples let you combine a fixed number of items, potentially
      of different types, lists let you hold any number of items of the same
      type. Consider the following example:<indexterm class="startofrange"
          id="DSlists">
          <primary>data structures</primary>

          <secondary>lists</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 20)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let languages = ["OCaml";"Perl";"C"];;</userinput>
<computeroutput moreinfo="none">val languages : string list = ["OCaml"; "Perl"; "C"]</computeroutput></programlisting>

      <para>Note that you can't mix elements of different types in the same
      list, unlike tuples:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 21)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let numbers = [3;"four";5];;</userinput>
<computeroutput moreinfo="none">Characters 17-23:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

      <sect3 id="the-list-module">
        <title>The List module</title>

        <para>Core comes with a <literal moreinfo="none">List</literal> module
        that has a rich collection of functions for working with lists. We can
        access values from within a module by using dot notation. For example,
        this is how we compute the length of a list:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 22)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">List.length languages;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>

        <para>Here's something a little more complicated. We can compute the
        list of the lengths of each language as follows:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 23)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">List.map languages ~f:String.length;;</userinput>
<computeroutput moreinfo="none">- : int list = [5; 4; 1]</computeroutput></programlisting>

        <para><literal moreinfo="none">List.map</literal> takes two arguments:
        a list and a function for transforming the elements of that list. It
        returns a new list with the transformed elements and does not modify
        the original list.</para>

        <para>Notably, the function passed to <literal
        moreinfo="none">List.map</literal> is passed under a <emphasis>labeled
        argument</emphasis> <literal moreinfo="none">~f</literal>. Labeled
        arguments are specified by name rather than by position, and thus
        allow you to change the order in which arguments are presented to a
        function without changing its behavior, as you can see here:<indexterm
            class="singular">
            <primary>arguments</primary>

            <secondary>labeled arguments</secondary>
          </indexterm><indexterm class="singular">
            <primary>labeled arguments</primary>
          </indexterm></para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 24)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:String.length languages;;</userinput>
<computeroutput moreinfo="none">- : int list = [5; 4; 1]</computeroutput></programlisting>

        <para>We'll learn more about labeled arguments and why they're
        important in <xref linkend="variables-and-functions" />.</para>
      </sect3>

      <sect3 id="constructing-lists-with">
        <title>Constructing lists with ::</title>

        <para>In addition to constructing lists using brackets, we can use the
        operator <literal moreinfo="none">::</literal> for adding elements to
        the front of a list:<indexterm class="singular">
            <primary>operators</primary>

            <secondary>: : operator</secondary>
          </indexterm><indexterm class="singular">
            <primary>lists</primary>

            <secondary>operator : :</secondary>
          </indexterm></para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 25)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">"French" :: "Spanish" :: languages;;</userinput>
<computeroutput moreinfo="none">- : string list = ["French"; "Spanish"; "OCaml"; "Perl"; "C"]</computeroutput></programlisting>

        <para>Here, we're creating a new and extended list, not changing the
        list we started with, as you can see in the following code
        snippet:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 26)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">languages;;</userinput>
<computeroutput moreinfo="none">- : string list = ["OCaml"; "Perl"; "C"]</computeroutput></programlisting>

        <note>
          <title>Semicolons Versus Commas</title>

          <para>Unlike many other languages, OCaml uses semicolons to separate
          list elements in lists rather than commas. Commas, instead, are used
          for separating elements in a tuple. If you try to use commas in a
          list, you'll see that your code compiles but doesn't do quite what
          you might expect:<indexterm class="singular">
              <primary>commas vs. semicolons</primary>
            </indexterm><indexterm class="singular">
              <primary>semicolons vs. commas</primary>
            </indexterm></para>

          <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
          url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
          (part 27)</para>

          <programlisting format="linespecific" language="ocaml"><prompt
              moreinfo="none"># </prompt><userinput moreinfo="none">["OCaml", "Perl", "C"];;</userinput>
<computeroutput moreinfo="none">- : (string * string * string) list = [("OCaml", "Perl", "C")]</computeroutput></programlisting>

          <para>In particular, rather than a list of three strings, what we
          have is a singleton list containing a three-tuple of strings.</para>

          <para>This example uncovers the fact that commas create a tuple,
          even if there are no surrounding parens. So, we can write:</para>

          <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
          url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
          (part 28)</para>

          <programlisting format="linespecific" language="ocaml"><prompt
              moreinfo="none"># </prompt><userinput moreinfo="none">1,2,3;;</userinput>
<computeroutput moreinfo="none">- : int * int * int = (1, 2, 3)</computeroutput></programlisting>

          <para>to allocate a tuple of integers. This is generally considered
          poor style and should be avoided.</para>
        </note>

        <para>The bracket notation for lists is really just syntactic sugar
        for <literal moreinfo="none">::</literal>. Thus, the following
        declarations are all equivalent. Note that <literal
        moreinfo="none">[]</literal> is used to represent the empty list and
        that <literal moreinfo="none">::</literal> is
        right-associative:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 29)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">[1; 2; 3];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">1 :: (2 :: (3 :: []));;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">1 :: 2 :: 3 :: [];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput></programlisting>

        <para>The <literal moreinfo="none">::</literal> operator can only be
        used for adding one element to the front of the list, with the list
        terminating at <literal moreinfo="none">[]</literal>, the empty list.
        There's also a list concatenation operator, <literal
        moreinfo="none">@</literal>, which can concatenate two lists:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 30)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">[1;2;3] @ [4;5;6];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3; 4; 5; 6]</computeroutput></programlisting>

        <para>It's important to remember that, unlike <literal
        moreinfo="none">::</literal>, this is not a constant-time operation.
        Concatenating two lists takes time proportional to the length of the
        first list.</para>
      </sect3>

      <sect3 id="list-patterns-using-match">
        <title>List patterns using match</title>

        <para>The elements of a list can be accessed through pattern matching.
        List patterns are based on the two list constructors, <literal
        moreinfo="none">[]</literal> and <literal
        moreinfo="none">::</literal>. Here's a simple example:<indexterm
            class="singular">
            <primary>pattern matching</primary>

            <secondary sortas="lists">in lists</secondary>
          </indexterm><indexterm class="singular">
            <primary>lists</primary>

            <secondary>pattern matching</secondary>
          </indexterm></para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 31)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let my_favorite_language (my_favorite :: the_rest) =</userinput>
<userinput moreinfo="none">     my_favorite</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 25-69:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">[]</computeroutput>
<computeroutput moreinfo="none">val my_favorite_language : 'a list -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

        <para>By pattern matching using <literal moreinfo="none">::</literal>,
        we've isolated and named the first element of the list (<literal
        moreinfo="none">my_favorite</literal>) and the remainder of the list
        (<literal moreinfo="none">the_rest</literal>). If you know Lisp or
        Scheme, what we've done is the equivalent of using the functions
        <literal moreinfo="none">car</literal> and <literal
        moreinfo="none">cdr</literal> to isolate the first element of a list
        and the remainder of that list.</para>

        <para>As you can see, however, the toplevel did not like this
        definition and spit out a warning indicating that the pattern is not
        exhaustive. This means that there are values of the type in question
        that won't be captured by the pattern. The warning even gives an
        example of a value that doesn't match the provided pattern, in
        particular, <literal moreinfo="none">[]</literal>, the empty list. If
        we try to run <literal moreinfo="none">my_favorite_language</literal>,
        we'll see that it works on nonempty list and fails on empty
        ones:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 32)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">my_favorite_language ["English";"Spanish";"French"];;</userinput>
<computeroutput moreinfo="none">- : string = "English"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">my_favorite_language [];;</userinput>
<computeroutput moreinfo="none">Exception: (Match_failure //toplevel// 0 25).</computeroutput></programlisting>

        <para>You can avoid these warnings, and more importantly make sure
        that your code actually handles all of the possible cases, by using a
        <literal moreinfo="none">match</literal> statement instead.</para>

        <para>A <literal moreinfo="none">match</literal> statement is a kind
        of juiced-up version of the <literal>switch</literal> statement found
        in C and Java. It essentially lets you list a sequence of patterns,
        separated by pipe characters (|). (The one before the first case is
        optional.) The compiler then dispatches to the code following the
        first matching pattern. As we've already seen, the pattern can mint
        new variables that correspond to substructures of the value being
        matched.</para>

        <para>Here's a new version of <literal
        moreinfo="none">my_favorite_language</literal> that uses <literal
        moreinfo="none">match</literal> and doesn't trigger a compiler
        warning:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 33)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let my_favorite_language languages =</userinput>
<userinput moreinfo="none">    match languages with</userinput>
<userinput moreinfo="none">    | first :: the_rest -&gt; first</userinput>
<userinput moreinfo="none">    | [] -&gt; "OCaml" (* A good default! *)</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val my_favorite_language : string list -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">my_favorite_language ["English";"Spanish";"French"];;</userinput>
<computeroutput moreinfo="none">- : string = "English"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">my_favorite_language [];;</userinput>
<computeroutput moreinfo="none">- : string = "OCaml"</computeroutput></programlisting>

        <para>The preceding code also includes our first comment. OCaml
        comments are bounded by <literal moreinfo="none">(*</literal> and
        <literal moreinfo="none">*)</literal> and can be nested arbitrarily
        and cover multiple lines. There's no equivalent of C++-style single
        line comments that are prefixed by <literal
        moreinfo="none">//</literal>.</para>

        <para>The first pattern, <literal moreinfo="none">first ::
        the_rest</literal>, covers the case where <literal
        moreinfo="none">languages</literal> has at least one element, since
        every list except for the empty list can be written down with one or
        more <literal moreinfo="none">::</literal>'s. The second pattern,
        <literal moreinfo="none">[]</literal>, matches only the empty list.
        These cases are exhaustive, since every list is either empty, or has
        at least one element, a fact which is verified by the compiler.</para>
      </sect3>

      <sect3 id="recursive-list-functions">
        <title>Recursive list functions</title>

        <para>Recursive functions, or functions that call themselves, are an
        important technique in OCaml and in any functional language. The
        typical approach to designing a recursive function is to separate the
        logic into a set of <emphasis>base cases</emphasis> that can be solved
        directly and a set of <emphasis>inductive cases</emphasis>, where the
        function breaks the problem down into smaller pieces and then calls
        itself to solve those smaller problems.<indexterm class="singular">
            <primary>recursive functions</primary>

            <secondary>list functions</secondary>
          </indexterm><indexterm class="singular">
            <primary>lists</primary>

            <secondary>recursive list functions</secondary>
          </indexterm></para>

        <para>When writing recursive list functions, this separation between
        the base cases and the inductive cases is often done using pattern
        matching. Here's a simple example of a function that sums the elements
        of a list:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 34)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let rec sum l =</userinput>
<userinput moreinfo="none">    match l with</userinput>
<userinput moreinfo="none">    | [] -&gt; 0                   (* base case *)</userinput>
<userinput moreinfo="none">    | hd :: tl -&gt; hd + sum tl   (* inductive case *)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum : int list -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum [1;2;3];;</userinput>
<computeroutput moreinfo="none">- : int = 6</computeroutput></programlisting>

        <para>Following the common OCaml idiom, we use <literal
        moreinfo="none">hd</literal> to refer to the head of the list and
        <literal moreinfo="none">tl</literal> to refer to the tail. Note that
        we had to use the <literal moreinfo="none">rec</literal> keyword to
        allow <literal moreinfo="none">sum</literal> to refer to itself. As
        you might imagine, the base case and inductive case are different arms
        of the match.</para>

        <para>Logically, you can think of the evaluation of a simple recursive
        function like <literal moreinfo="none">sum</literal> almost as if it
        were a mathematical equation whose meaning you were unfolding step by
        step:</para>

        <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/recursion.ml">guided-tour/recursion.ml</ulink></para>

        <programlisting format="linespecific" language="ocaml">sum [1;2;3]
= 1 + sum [2;3]
= 1 + (2 + sum [3])
= 1 + (2 + (3 + sum []))
= 1 + (2 + (3 + 0))
= 1 + (2 + 3)
= 1 + 5
= 6</programlisting>

        <para>This suggests a reasonable mental model for what OCaml is
        actually doing to evaluate a recursive function.</para>

        <para>We can introduce more complicated list patterns as well. Here's
        a function for removing sequential duplicates:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 35)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let rec destutter list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | hd1 :: hd2 :: tl -&gt;</userinput>
<userinput moreinfo="none">      if hd1 = hd2 then destutter (hd2 :: tl)</userinput>
<userinput moreinfo="none">      else hd1 :: destutter (hd2 :: tl)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 29-171:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">_::[]</computeroutput>
<computeroutput moreinfo="none">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

        <para>Again, the first arm of the match is the base case, and the
        second is the inductive. Unfortunately, this code has a problem, as is
        indicated by the warning message. In particular, we don't handle
        one-element lists. We can fix this warning by adding another case to
        the match:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
        (part 36)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let rec destutter list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | [hd] -&gt; [hd]</userinput>
<userinput moreinfo="none">    | hd1 :: hd2 :: tl -&gt;</userinput>
<userinput moreinfo="none">      if hd1 = hd2 then destutter (hd2 :: tl)</userinput>
<userinput moreinfo="none">      else hd1 :: destutter (hd2 :: tl)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">destutter ["hey";"hey";"hey";"man!"];;</userinput>
<computeroutput moreinfo="none">- : string list = ["hey"; "man!"]</computeroutput></programlisting>

        <para>Note that this code used another variant of the list pattern,
        <literal moreinfo="none">[hd]</literal>, to match a list with a single
        element. We can do this to match a list with any fixed number of
        elements, e.g., <literal moreinfo="none">[x;y;z]</literal> will match
        any list with exactly three elements and will bind those elements to
        the variables <literal moreinfo="none">x</literal>, <literal
        moreinfo="none">y</literal>, and <literal
        moreinfo="none">z</literal>.</para>

        <para>In the last few examples, our list processing code involved a
        lot of recursive functions. In practice, this isn't usually necessary.
        Most of the time, you'll find yourself happy to use the iteration
        functions found in the <literal moreinfo="none">List</literal> module.
        But it's good to know how to use recursion when you need to do
        something new.<indexterm class="endofrange"
        startref="DSlists"></indexterm></para>
      </sect3>
    </sect2>

    <sect2 id="options">
      <title>Options</title>

      <para>Another common data structure in OCaml is the option. An option is
      used to express that a value might or might not be present. For
      example:<indexterm class="singular">
          <primary>options</primary>
        </indexterm><indexterm class="singular">
          <primary>data structures</primary>

          <secondary>options</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 37)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let divide x y =</userinput>
<userinput moreinfo="none">    if y = 0 then None else Some (x/y) ;;</userinput>
<computeroutput moreinfo="none">val divide : int -&gt; int -&gt; int option = &lt;fun&gt;</computeroutput></programlisting>

      <para>The function <literal moreinfo="none">divide</literal> either
      returns <literal moreinfo="none">None</literal>, if the divisor is zero;
      or <literal moreinfo="none">Some</literal> of the result of the
      division, otherwise. <literal moreinfo="none">Some</literal> and
      <literal moreinfo="none">None</literal> are constructors, like <literal
      moreinfo="none">::</literal> and <literal moreinfo="none">[]</literal>
      for lists, which let you build optional values. You can think of an
      option as a specialized list that can only have zero or one
      element.</para>

      <para>To examine the contents of an option, we use pattern matching, as
      we did with tuples and lists. Consider the following function for
      creating a log entry string given an optional time and a message. If no
      time is provided (i.e., if the time is <literal
      moreinfo="none">None</literal>), the current time is computed and used
      in its place:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 38)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let log_entry maybe_time message =</userinput>
<userinput moreinfo="none">    let time =</userinput>
<userinput moreinfo="none">      match maybe_time with</userinput>
<userinput moreinfo="none">      | Some x -&gt; x</userinput>
<userinput moreinfo="none">      | None -&gt; Time.now ()</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    Time.to_sec_string time ^ " -- " ^ message</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val log_entry : Time.t option -&gt; string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">log_entry (Some Time.epoch) "A long long time ago";;</userinput>
<computeroutput moreinfo="none">- : string = "1970-01-01 01:00:00 -- A long long time ago"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">log_entry None "Up to the minute";;</userinput>
<computeroutput moreinfo="none">- : string = "2013-08-18 14:48:08 -- Up to the minute"</computeroutput></programlisting>

      <para>This example uses Core's <literal moreinfo="none">Time</literal>
      module for dealing with time as well as the <literal
      moreinfo="none">^</literal> operator for concatenating strings. The
      concatenation operator is provided as part of the <literal
      moreinfo="none">Pervasives</literal> module which is automatically
      opened in every OCaml program.</para>

      <note>
        <title>Nesting <literal moreinfo="none">let</literal>s with <literal
        moreinfo="none">let</literal> and <literal
        moreinfo="none">in</literal></title>

        <para><literal moreinfo="none">log_entry</literal> was our first use
        of <literal moreinfo="none">let</literal> to define a new variable
        within the body of a function. A <literal
        moreinfo="none">let</literal> bounded with an <literal
        moreinfo="none">in</literal> can be used to introduce a new binding
        within any local scope, including a function body. The <literal
        moreinfo="none">in</literal> marks the beginning of the scope within
        which the new variable can be used. Thus, we could write:<indexterm
            class="singular">
            <primary>let syntax</primary>

            <secondary>nested let binding</secondary>
          </indexterm><indexterm class="singular">
            <primary>let syntax</primary>

            <secondary>nested let binding</secondary>
          </indexterm></para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/local_let.topscript">guided-tour/local_let.topscript</ulink></para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let x = 7 in</userinput>
<userinput moreinfo="none">  x + x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : int = 14</computeroutput></programlisting>

        <para>Note that the scope of the let binding is terminated by the
        double-semicolon, so the value of <literal moreinfo="none">x</literal>
        is no longer available:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/local_let.topscript">guided-tour/local_let.topscript</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">x;;</userinput>
<computeroutput moreinfo="none">Characters -1-1:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value x</computeroutput></programlisting>

        <para>We can also have multiple let statements in a row, each one
        adding a new variable binding to what came before:</para>

        <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/local_let.topscript">guided-tour/local_let.topscript</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let x = 7 in</userinput>
<userinput moreinfo="none">  let y = x * x in</userinput>
<userinput moreinfo="none">  x + y</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : int = 56</computeroutput></programlisting>

        <para>This kind of nested let binding is a common way of building up a
        complex expression, with each <literal moreinfo="none">let</literal>
        naming some component, before combining them in one final
        expression.</para>
      </note>

      <para>Options are important because they are the standard way in OCaml
      to encode a value that might not be there; there's no such thing as a
      <literal moreinfo="none">NullPointerException</literal> in OCaml. This
      is different from most other languages, including Java and C#, where
      most if not all datatypes are <emphasis>nullable</emphasis>, meaning
      that, whatever their type is, any given value also contains the
      possibility of being a null value. In such languages, null is lurking
      everywhere.<indexterm class="singular">
          <primary>datatypes</primary>

          <secondary>nullable</secondary>
        </indexterm></para>

      <para>In OCaml, however, missing values are explicit. A value of type
      <literal moreinfo="none">string * string</literal> always actually
      contains two well-defined values of type <literal
      moreinfo="none">string</literal>. If you want to allow, say, the first
      of those to be absent, then you need to change the type to <literal
      moreinfo="none">string option * string</literal>. As we'll see in <xref
      linkend="error-handling" />, this explicitness allows the compiler to
      provide a great deal of help in making sure you're correctly handing the
      possibility of missing data.</para>
    </sect2>
  </sect1>

  <sect1 id="records-and-variants">
    <title>Records and Variants</title>

    <para>So far, we've only looked at data structures that were predefined in
    the language, like lists and tuples. But OCaml also allows us to define
    new datatypes. Here's a toy example of a datatype representing a point in
    two-dimensional space:<indexterm class="singular">
        <primary>datatypes</primary>

        <secondary>defining new</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 41)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type point2d = { x : float; y : float };;</userinput>
<computeroutput moreinfo="none">type point2d = { x : float; y : float; }</computeroutput></programlisting>

    <para><literal moreinfo="none">point2d</literal> is a
    <emphasis>record</emphasis> type, which you can think of as a tuple where
    the individual fields are named, rather than being defined positionally.
    Record types are easy enough to construct:<indexterm class="singular">
        <primary>records</primary>

        <secondary>record types</secondary>
      </indexterm><indexterm class="singular">
        <primary>datatypes</primary>

        <secondary>record types</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 42)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let p = { x = 3.; y = -4. };;</userinput>
<computeroutput moreinfo="none">val p : point2d = {x = 3.; y = -4.}</computeroutput></programlisting>

    <para>And we can get access to the contents of these types using pattern
    matching:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 43)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let magnitude { x = x_pos; y = y_pos } =</userinput>
<userinput moreinfo="none">    sqrt (x_pos ** 2. +. y_pos ** 2.);;</userinput>
<computeroutput moreinfo="none">val magnitude : point2d -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

    <para>The pattern match here binds the variable <literal
    moreinfo="none">x_pos</literal> to the value contained in the <literal
    moreinfo="none">x</literal> field, and the variable <literal
    moreinfo="none">y_pos</literal> to the value in the <literal
    moreinfo="none">y</literal> field.</para>

    <para>We can write this more tersely using what's called <emphasis>field
    punning</emphasis>. In particular, when the name of the field and the name
    of the variable it is bound to in the match coincide, we don't have to
    write them both down. Using this, our magnitude function can be rewritten
    as follows:<indexterm class="singular">
        <primary>fields</primary>

        <secondary>field punning</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 44)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let magnitude { x; y } = sqrt (x ** 2. +. y ** 2.);;</userinput>
<computeroutput moreinfo="none">val magnitude : point2d -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can also use dot-notation for accessing record fields:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 45)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let distance v1 v2 =</userinput>
<userinput moreinfo="none">     magnitude { x = v1.x -. v2.x; y = v1.y -. v2.y };;</userinput>
<computeroutput moreinfo="none">val distance : point2d -&gt; point2d -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

    <para>And we can of course include our newly defined types as components
    in larger types. Here, for example, are some types for modeling different
    geometric objects that contain values of type <literal
    moreinfo="none">point2d</literal>:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 46)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type circle_desc  = { center: point2d; radius: float }</userinput>
<userinput moreinfo="none">  type rect_desc    = { lower_left: point2d; width: float; height: float }</userinput>
<userinput moreinfo="none">  type segment_desc = { endpoint1: point2d; endpoint2: point2d } ;;</userinput>
<computeroutput moreinfo="none">type circle_desc = { center : point2d; radius : float; }</computeroutput>
<computeroutput moreinfo="none">type rect_desc = { lower_left : point2d; width : float; height : float; }</computeroutput>
<computeroutput moreinfo="none">type segment_desc = { endpoint1 : point2d; endpoint2 : point2d; }</computeroutput></programlisting>

    <para>Now, imagine that you want to combine multiple objects of these
    types together as a description of a multiobject scene. You need some
    unified way of representing these objects together in a single type. One
    way of doing this is using a <emphasis>variant</emphasis> type:<indexterm
        class="singular">
        <primary>datatypes</primary>

        <secondary>variant types</secondary>
      </indexterm><indexterm class="singular">
        <primary>variant types</primary>

        <secondary>combining multiple object types with</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 47)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type scene_element =</userinput>
<userinput moreinfo="none">    | Circle  of circle_desc</userinput>
<userinput moreinfo="none">    | Rect    of rect_desc</userinput>
<userinput moreinfo="none">    | Segment of segment_desc</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type scene_element =</computeroutput>
<computeroutput moreinfo="none">    Circle of circle_desc</computeroutput>
<computeroutput moreinfo="none">  | Rect of rect_desc</computeroutput>
<computeroutput moreinfo="none">  | Segment of segment_desc</computeroutput></programlisting>

    <para>The <literal moreinfo="none">|</literal> character separates the
    different cases of the variant (the first <literal
    moreinfo="none">|</literal> is optional), and each case has a capitalized
    tag, like <literal moreinfo="none">Circle</literal>, <literal
    moreinfo="none">Rect</literal> and <literal
    moreinfo="none">Segment</literal>, to distinguish that case from the
    others.</para>

    <para>Here's how we might write a function for testing whether a point is
    in the interior of some element of a list of <literal
    moreinfo="none">scene_element</literal>s:</para>

    <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
    (part 48)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let is_inside_scene_element point scene_element =</userinput>
<userinput moreinfo="none">     match scene_element with</userinput>
<userinput moreinfo="none">     | Circle { center; radius } -&gt;</userinput>
<userinput moreinfo="none">       distance center point &lt; radius</userinput>
<userinput moreinfo="none">     | Rect { lower_left; width; height } -&gt;</userinput>
<userinput moreinfo="none">       point.x    &gt; lower_left.x &amp;&amp; point.x &lt; lower_left.x +. width</userinput>
<userinput moreinfo="none">       &amp;&amp; point.y &gt; lower_left.y &amp;&amp; point.y &lt; lower_left.y +. height</userinput>
<userinput moreinfo="none">     | Segment { endpoint1; endpoint2 } -&gt; false</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val is_inside_scene_element : point2d -&gt; scene_element -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_inside_scene point scene =</userinput>
<userinput moreinfo="none">     List.exists scene</userinput>
<userinput moreinfo="none">       ~f:(fun el -&gt; is_inside_scene_element point el)</userinput>
<userinput moreinfo="none">   ;;</userinput>
<computeroutput moreinfo="none">val is_inside_scene : point2d -&gt; scene_element list -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_inside_scene {x=3.;y=7.}</userinput>
<userinput moreinfo="none">    [ Circle {center = {x=4.;y= 4.}; radius = 0.5 } ];;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_inside_scene {x=3.;y=7.}</userinput>
<userinput moreinfo="none">    [ Circle {center = {x=4.;y= 4.}; radius = 5.0 } ];;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>You might at this point notice that the use of <literal
    moreinfo="none">match</literal> here is reminiscent of how we used
    <literal moreinfo="none">match</literal> with <literal
    moreinfo="none">option</literal> and <literal
    moreinfo="none">list</literal>. This is no accident: <literal
    moreinfo="none">option</literal> and <literal
    moreinfo="none">list</literal> are really just examples of variant types
    that happen to be important enough to be defined in the standard library
    (and in the case of lists, to have some special syntax).</para>

    <para>We also made our first use of an <emphasis>anonymous
    function</emphasis> in the call to <literal
    moreinfo="none">List.exists</literal>. Anonymous functions are declared
    using the <literal moreinfo="none">fun</literal> keyword, and don't need
    to be explicitly named. Such functions are common in OCaml, particularly
    when using iteration functions like <literal
    moreinfo="none">List.exists</literal>.<indexterm class="singular">
        <primary>anonymous functions</primary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>anonymous functions</secondary>
      </indexterm></para>

    <para>The purpose of <literal moreinfo="none">List.exists</literal> is to
    check if there are any elements of the list in question on which the
    provided function evaluates to <literal moreinfo="none">true</literal>. In
    this case, we're using <literal moreinfo="none">List.exists</literal> to
    check if there is a scene element within which our point resides.</para>
  </sect1>

  <sect1 id="imperative-programming">
    <title>Imperative Programming</title>

    <para>The code we've written so far has been almost entirely
    <emphasis>pure</emphasis> or <emphasis>functional</emphasis>, which
    roughly speaking means that the code in question doesn't modify variables
    or values as part of its execution. Indeed, almost all of the data
    structures we've encountered are <emphasis>immutable</emphasis>, meaning
    there's no way in the language to modify them at all. This is a quite
    different style from <emphasis>imperative</emphasis> programming, where
    computations are structured as sequences of instructions that operate by
    making modifications to the state of the program.<indexterm
        class="singular">
        <primary>functional code</primary>
      </indexterm><indexterm class="singular">
        <primary>pure code</primary>
      </indexterm><indexterm class="singular">
        <primary>data structures</primary>

        <secondary>immutable</secondary>
      </indexterm><indexterm class="singular">
        <primary>programming</primary>

        <secondary>immutable vs. imperative</secondary>
      </indexterm></para>

    <para>Functional code is the default in OCaml, with variable bindings and
    most data structures being immutable. But OCaml also has excellent support
    for imperative programming, including mutable data structures like arrays
    and hash tables, and control-flow constructs like for and while
    loops.</para>

    <sect2 id="arrays">
      <title>Arrays</title>

      <para>Perhaps the simplest mutable data structure in OCaml is the array.
      Arrays in OCaml are very similar to arrays in other languages like C:
      indexing starts at 0, and accessing or modifying an array element is a
      constant-time operation. Arrays are more compact in terms of memory
      utilization than most other data structures in OCaml, including lists.
      Here's an example:<indexterm class="singular">
          <primary>data structures</primary>

          <secondary>arrays</secondary>
        </indexterm><indexterm class="singular">
          <primary>arrays</primary>

          <secondary>imperative programming and</secondary>
        </indexterm><indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>arrays</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 49)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let numbers = [| 1; 2; 3; 4 |];;</userinput>
<computeroutput moreinfo="none">val numbers : int array = [|1; 2; 3; 4|]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">numbers.(2) &lt;- 4;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">numbers;;</userinput>
<computeroutput moreinfo="none">- : int array = [|1; 2; 4; 4|]</computeroutput></programlisting>

      <para>The <literal moreinfo="none">.(i)</literal> syntax is used to
      refer to an element of an array, and the <literal
      moreinfo="none">&lt;-</literal> syntax is for modification. Because the
      elements of the array are counted starting at zero, element <literal
      moreinfo="none">.(2)</literal> is the third element.</para>

      <para>The <literal moreinfo="none">unit</literal> type that we see in
      the preceding code is interesting in that it has only one possible
      value, written <literal moreinfo="none">()</literal>. This means that a
      value of type <literal moreinfo="none">unit</literal> doesn't convey any
      information, and so tends to be used as a placeholder. Thus, we use
      <literal moreinfo="none">unit</literal> for the return value of an
      operation like setting a mutable field that communicates by side effect
      rather than by returning a value. It's also used as the argument to
      functions that don't require an input value. This is similar to the role
      that <literal moreinfo="none">void</literal> plays in languages like C
      and Java.</para>
    </sect2>

    <sect2 id="mutable-record-fields">
      <title>Mutable Record Fields</title>

      <para>The array is an important mutable data structure, but it's not the
      only one. Records, which are immutable by default, can have some of
      their fields explicitly declared as mutable. Here's a small example of a
      data structure for storing a running statistical summary of a collection
      of numbers. Here's the basic data structure:<indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>mutable record fields</secondary>
        </indexterm><indexterm class="singular">
          <primary>mutable record fields</primary>
        </indexterm><indexterm class="singular">
          <primary>data structures</primary>

          <secondary>mutable record fields</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 50)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type running_sum =</userinput>
<userinput moreinfo="none">   { mutable sum: float;</userinput>
<userinput moreinfo="none">     mutable sum_sq: float; (* sum of squares *)</userinput>
<userinput moreinfo="none">     mutable samples: int;</userinput>
<userinput moreinfo="none">   }</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type running_sum = {</computeroutput>
<computeroutput moreinfo="none">  mutable sum : float;</computeroutput>
<computeroutput moreinfo="none">  mutable sum_sq : float;</computeroutput>
<computeroutput moreinfo="none">  mutable samples : int;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

      <para>The fields in <literal moreinfo="none">running_sum</literal> are
      designed to be easy to extend incrementally, and sufficient to compute
      means and standard deviations, as shown in the following example. Note
      that there are two let-bindings in a row without a double semicolon
      between them. That's because the double semicolon is required only to
      tell utop to process the input, not to separate two declarations:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 51)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let mean rsum = rsum.sum /. float rsum.samples</userinput>
<userinput moreinfo="none">  let stdev rsum =</userinput>
<userinput moreinfo="none">     sqrt (rsum.sum_sq /. float rsum.samples</userinput>
<userinput moreinfo="none">           -. (rsum.sum /. float rsum.samples) ** 2.) ;;</userinput>
<computeroutput moreinfo="none">val mean : running_sum -&gt; float = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val stdev : running_sum -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

      <para>We use the function <literal moreinfo="none">float</literal>
      above, which is a convenient equivalent of <literal
      moreinfo="none">Float.of_int</literal> which is provided by the <literal
      moreinfo="none">Pervasives</literal> library.</para>

      <para>We also need functions to create and update <literal
      moreinfo="none">running_sum</literal>s:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 52)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let create () = { sum = 0.; sum_sq = 0.; samples = 0 }</userinput>
<userinput moreinfo="none">  let update rsum x =</userinput>
<userinput moreinfo="none">     rsum.samples &lt;- rsum.samples + 1;</userinput>
<userinput moreinfo="none">     rsum.sum     &lt;- rsum.sum     +. x;</userinput>
<userinput moreinfo="none">     rsum.sum_sq  &lt;- rsum.sum_sq  +. x *. x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val create : unit -&gt; running_sum = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val update : running_sum -&gt; float -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para><literal moreinfo="none">create</literal> returns a <literal
      moreinfo="none">running_sum</literal> corresponding to the empty set,
      and <literal moreinfo="none">update rsum x</literal> changes <literal
      moreinfo="none">rsum</literal> to reflect the addition of <literal
      moreinfo="none">x</literal> to its set of samples, by updating the
      number of samples, the sum, and the sum of squares.</para>

      <para>Note the use in the above code of single semicolons to sequence
      operations. When we were working purely functionally, this wasn't
      necessary, but you start needing it when you're writing imperative
      code.</para>

      <para>Here's an example of <literal moreinfo="none">create</literal> and
      <literal moreinfo="none">update</literal> in action. Note that this code
      uses <literal moreinfo="none">List.iter</literal>, which calls the
      function <literal moreinfo="none">~f</literal> on each element of the
      provided list:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 53)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let rsum = create ();;</userinput>
<computeroutput moreinfo="none">val rsum : running_sum = {sum = 0.; sum_sq = 0.; samples = 0}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.iter [1.;3.;2.;-7.;4.;5.] ~f:(fun x -&gt; update rsum x);;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">mean rsum;;</userinput>
<computeroutput moreinfo="none">- : float = 1.33333333333</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">stdev rsum;;</userinput>
<computeroutput moreinfo="none">- : float = 3.94405318873</computeroutput></programlisting>

      <para>It's worth noting that the preceding algorithm is numerically
      naive and has poor precision in the presence of cancellation. You can
      look at this Wikipedia <ulink
      url="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">article</ulink>
      for more details, paying particular attention to the weighted
      incremental and parallel algorithms.</para>
    </sect2>

    <sect2 id="refs">
      <title>Refs</title>

      <para>We can create a single mutable value by using a <literal
      moreinfo="none">ref</literal>. The <literal
      moreinfo="none">ref</literal> type comes predefined in the standard
      library, but there's nothing really special about it. It's just a record
      type with a single mutable field called <literal
      moreinfo="none">contents</literal>:<indexterm class="singular">
          <primary>records</primary>

          <secondary>record types</secondary>
        </indexterm><indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>ref type</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 54)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let x = { contents = 0 };;</userinput>
<computeroutput moreinfo="none">val x : int ref = {contents = 0}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">x.contents &lt;- x.contents + 1;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">x;;</userinput>
<computeroutput moreinfo="none">- : int ref = {contents = 1}</computeroutput></programlisting>

      <para>There are a handful of useful functions and operators defined for
      <literal moreinfo="none">ref</literal>s to make them more convenient to
      work with:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 55)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let x = ref 0  (* create a ref, i.e., { contents = 0 } *) ;;</userinput>
<computeroutput moreinfo="none">val x : int ref = {contents = 0}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">!x             (* get the contents of a ref, i.e., x.contents *) ;;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">x := !x + 1    (* assignment, i.e., x.contents &lt;- ... *) ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">!x ;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput></programlisting>

      <para>There's nothing magical with these operators either. You can
      completely reimplement the <literal moreinfo="none">ref</literal> type
      and all of these operators in just a few lines of code:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 56)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type 'a ref = { mutable contents : 'a }</userinput>
<userinput moreinfo="none"></userinput>
<userinput moreinfo="none">  let ref x = { contents = x }</userinput>
<userinput moreinfo="none">  let (!) r = r.contents</userinput>
<userinput moreinfo="none">  let (:=) r x = r.contents &lt;- x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type 'a ref = { mutable contents : 'a; }</computeroutput>
<computeroutput moreinfo="none">val ref : 'a -&gt; 'a ref = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para>The <literal moreinfo="none">'a</literal> before the
      <literal>ref</literal> indicates that the <literal
      moreinfo="none">ref</literal> type is polymorphic, in the same way that
      lists are polymorphic, meaning it can contain values of any type. The
      parentheses around <literal moreinfo="none">!</literal> and <literal
      moreinfo="none">:=</literal> are needed because these are operators,
      rather than ordinary functions.<indexterm class="singular">
          <primary>parametric polymorphism</primary>
        </indexterm></para>

      <para>Even though a <literal moreinfo="none">ref</literal> is just
      another record type, it's important because it is the standard way of
      simulating the traditional mutable variables you'll find in most
      languages. For example, we can sum over the elements of a list
      imperatively by calling <literal moreinfo="none">List.iter</literal> to
      call a simple function on every element of a list, using a
      <literal>ref</literal> to accumulate the results:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 57)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let sum list =</userinput>
<userinput moreinfo="none">    let sum = ref 0 in</userinput>
<userinput moreinfo="none">    List.iter list ~f:(fun x -&gt; sum := !sum + x);</userinput>
<userinput moreinfo="none">    !sum</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum : int list -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This isn't the most idiomatic (or the fastest) way to sum up a
      list, but it shows how you can use a <literal>ref</literal> in place of
      a mutable variable.</para>
    </sect2>

    <sect2 id="for-and-while-loops">
      <title>For and While Loops</title>

      <para>OCaml also supports traditional imperative control-flow constructs
      like <literal>for and while</literal> loops. Here, for example, is some
      code for permuting an array that uses a for loop. We use the <literal
      moreinfo="none">Random</literal> module as our source of randomness.
      <literal moreinfo="none">Random</literal> starts with a default seed,
      but you can call <literal moreinfo="none">Random.self_init</literal> to
      choose a new seed at random:<indexterm class="singular">
          <primary>Random module</primary>
        </indexterm><indexterm class="singular">
          <primary>while loops</primary>
        </indexterm><indexterm class="singular">
          <primary>for loops</primary>
        </indexterm><indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>for and while loops</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 58)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let permute array =</userinput>
<userinput moreinfo="none">    let length = Array.length array in</userinput>
<userinput moreinfo="none">    for i = 0 to length - 2 do</userinput>
<userinput moreinfo="none">       (* pick a j that is after i and before the end of the array *)</userinput>
<userinput moreinfo="none">       let j = i + 1 + Random.int (length - i - 1) in</userinput>
<userinput moreinfo="none">       (* Swap i and j *)</userinput>
<userinput moreinfo="none">       let tmp = array.(i) in</userinput>
<userinput moreinfo="none">       array.(i) &lt;- array.(j);</userinput>
<userinput moreinfo="none">       array.(j) &lt;- tmp</userinput>
<userinput moreinfo="none">    done</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val permute : 'a array -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para>From a syntactic perspective, you should note the keywords that
      distinguish a for loop: <literal moreinfo="none">for</literal>, <literal
      moreinfo="none">to</literal>, <literal moreinfo="none">do</literal>, and
      <literal moreinfo="none">done</literal>.</para>

      <para>Here's an example run of this code:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 59)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let ar = Array.init 20 ~f:(fun i -&gt; i);;</userinput>
<computeroutput moreinfo="none">val ar : int array =</computeroutput>
<computeroutput moreinfo="none">  [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19|]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">permute ar;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">ar;;</userinput>
<computeroutput moreinfo="none">- : int array =</computeroutput>
<computeroutput moreinfo="none">[|1; 2; 4; 6; 11; 7; 14; 9; 10; 0; 13; 16; 19; 12; 17; 5; 3; 18; 8; 15|]</computeroutput></programlisting>

      <para>OCaml also supports while loops, as shown in the following
      function for finding the position of the first negative entry in an
      array. Note that <literal moreinfo="none">while</literal> (like <literal
      moreinfo="none">for</literal>) is also a keyword:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 60)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let find_first_negative_entry array =</userinput>
<userinput moreinfo="none">     let pos = ref 0 in</userinput>
<userinput moreinfo="none">     while !pos &lt; Array.length array &amp;&amp; array.(!pos) &gt;= 0 do</userinput>
<userinput moreinfo="none">       pos := !pos + 1</userinput>
<userinput moreinfo="none">     done;</userinput>
<userinput moreinfo="none">     if !pos = Array.length array then None else Some !pos</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val find_first_negative_entry : int array -&gt; int option = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_first_negative_entry [|1;2;0;3|];;</userinput>
<computeroutput moreinfo="none">- : int option = None</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_first_negative_entry [|1;-2;0;3|];;</userinput>
<computeroutput moreinfo="none">- : int option = Some 1</computeroutput></programlisting>

      <para>As a side note, the preceding code takes advantage of the fact
      that <literal moreinfo="none">&amp;&amp;</literal>, OCaml's and
      operator, short-circuits. In particular, in an expression of the form
      <emphasis><literal moreinfo="none">expr1</literal></emphasis> <literal
      moreinfo="none">&amp;&amp;</literal> <emphasis><literal
      moreinfo="none">expr2</literal></emphasis>, <emphasis><literal
      moreinfo="none">expr2</literal></emphasis> will only be evaluated if
      <emphasis><literal moreinfo="none">expr1</literal></emphasis> evaluated
      to true. Were it not for that, then the preceding function would result
      in an out-of-bounds error. Indeed, we can trigger that out-of-bounds
      error by rewriting the function to avoid the short-circuiting:</para>

      <para role="sourcecode">OCaml utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/main.topscript">guided-tour/main.topscript</ulink>
      (part 61)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let find_first_negative_entry array =</userinput>
<userinput moreinfo="none">     let pos = ref 0 in</userinput>
<userinput moreinfo="none">     while</userinput>
<userinput moreinfo="none">       let pos_is_good = !pos &lt; Array.length array in</userinput>
<userinput moreinfo="none">       let element_is_non_negative = array.(!pos) &gt;= 0 in</userinput>
<userinput moreinfo="none">       pos_is_good &amp;&amp; element_is_non_negative</userinput>
<userinput moreinfo="none">     do</userinput>
<userinput moreinfo="none">       pos := !pos + 1</userinput>
<userinput moreinfo="none">     done;</userinput>
<userinput moreinfo="none">     if !pos = Array.length array then None else Some !pos</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val find_first_negative_entry : int array -&gt; int option = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_first_negative_entry [|1;2;0;3|];;</userinput>
<computeroutput moreinfo="none">Exception: (Invalid_argument "index out of bounds").</computeroutput></programlisting>

      <para>The or operator, <literal moreinfo="none">||</literal>,
      short-circuits in a similar way to <literal
      moreinfo="none">&amp;&amp;</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="a-complete-program">
    <title>A Complete Program</title>

    <para>So far, we've played with the basic features of the language via
    <command moreinfo="none">utop</command>. Now we'll show how to create a
    simple standalone program. In particular, we'll create a program that sums
    up a list of numbers read in from the standard input.<indexterm
        class="singular">
        <primary>programming</primary>

        <secondary>simple standalone example</secondary>
      </indexterm></para>

    <para>Here's the code, which you can save in a file called
    <filename>sum.ml</filename>. Note that we don't terminate expressions with
    <literal moreinfo="none">;;</literal> here, since it's not required
    outside the toplevel:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/sum.ml">guided-tour/sum.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let rec read_and_accumulate accum =
  let line = In_channel.input_line In_channel.stdin in
  match line with
  | None -&gt; accum
  | Some x -&gt; read_and_accumulate (accum +. Float.of_string x)

let () =
  printf "Total: %F\n" (read_and_accumulate 0.)</programlisting>

    <para>This is our first use of OCaml's input and output routines. The
    function <literal moreinfo="none">read_and_accumulate</literal> is a
    recursive function that uses <literal
    moreinfo="none">In_channel.input_line</literal> to read in lines one by
    one from the standard input, invoking itself at each iteration with its
    updated accumulated sum. Note that <literal
    moreinfo="none">input_line</literal> returns an optional value, with
    <literal moreinfo="none">None</literal> indicating the end of the input
    stream.</para>

    <para>After <literal moreinfo="none">read_and_accumulate</literal>
    returns, the total needs to be printed. This is done using the <literal
    moreinfo="none">printf</literal> command, which provides support for
    type-safe format strings, similar to what you'll find in a variety of
    languages. The format string is parsed by the compiler and used to
    determine the number and type of the remaining arguments that are
    required. In this case, there is a single formatting directive, <literal
    moreinfo="none">%F</literal>, so <literal moreinfo="none">printf</literal>
    expects one additional argument of type <literal
    moreinfo="none">float</literal>.</para>

    <sect2 id="compiling-and-running">
      <title>Compiling and Running</title>

      <para>We'll compile our program using <command
      moreinfo="none">corebuild</command>, a small wrapper on top of <command
      moreinfo="none">ocamlbuild</command>, a build-tool that ships with the
      OCaml compiler. The <command moreinfo="none">corebuild</command> script
      is installed along with Core, and its purpose is to pass in the flags
      required for building a program with Core:<indexterm class="singular">
          <primary>corebuild</primary>
        </indexterm></para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/build_sum.out">guided-tour/build_sum.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild sum.native</userinput>
</programlisting>

      <para>The <literal moreinfo="none">.native</literal> suffix indicates
      that we're building a native-code executable, which we'll discuss more
      in <xref linkend="files-modules-and-programs" />. Once the build
      completes, we can use the resulting program like any command-line
      utility. We can feed input to <literal
      moreinfo="none">build_sum.native</literal> by typing in a sequence of
      numbers, one per line, hitting <literal
      moreinfo="none">control-d</literal> when we're done:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/guided-tour/sum.out">guided-tour/sum.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">./sum.native</userinput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">2</computeroutput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">94.5</computeroutput>
<computeroutput moreinfo="none">Total: 100.5</computeroutput></programlisting>

      <para>More work is needed to make a really usable command-line program,
      including a proper command-line parsing interface and better error
      handling, all of which is covered in <xref
      linkend="command-line-parsing" />.</para>
    </sect2>
  </sect1>

  <sect1 id="where-to-go-from-here">
    <title>Where to Go from Here</title>

    <para>That's it for the guided tour! There are plenty of features left and
    lots of details to explain, but we hope that you now have a sense of what
    to expect from OCaml, and that you'll be more comfortable reading the rest
    of the book as a result.</para>
  </sect1>
</chapter>