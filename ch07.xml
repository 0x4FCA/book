<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="error-handling">
      <title>Error Handling</title>

      <para>Nobody likes dealing with errors. It's tedious, it's easy to get
      wrong, and it's usually just not as fun as planning out how your program
      is going to succeed. But error handling is important, and however much
      you don't like thinking about it, having your software fail due to poor
      error handling code is worse.</para>

      <para>Thankfully, OCaml has powerful tools for handling errors reliably
      and with a minimum of pain. In this chapter we'll discuss some of the
      different approaches in OCaml to handling errors, and give some advice
      on how to design interfaces that make error handling easier.</para>

      <para>We'll start by describing the two basic approaches for reporting
      errors in OCaml: error-aware return types and exceptions.</para>

      <sect1 id="error-aware-return-types">
        <title>Error-aware return types</title>

        <para>The best way in OCaml to signal an error is to include that
        error in your return value. Consider the type of the
        <literal moreinfo="none">find</literal> function in the <literal moreinfo="none">List</literal>
        module.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename></para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.find;;</userinput>
<computeroutput moreinfo="none">- : 'a list -&gt; f:('a -&gt; bool) -&gt; 'a option = &lt;fun&gt;</computeroutput></programlisting>

        <para>The option in the return type indicates that the function may
        not succeed in finding a suitable element, as you can see
        below.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 1)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 2) ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 10) ;;</userinput>
<computeroutput moreinfo="none">- : int option = None</computeroutput></programlisting>

        <para>Including errors in the return values of your functions requires
        the caller to handle the error explicitly, allowing the caller to make
        the choice of whether to recover from the error or propagate it
        onward.</para>

        <para>Consider the <literal moreinfo="none">compute_bounds</literal> function defined
        below. The function takes a list and a comparison function, and
        returns upper and lower bounds for the list by finding the smallest
        and largest element on the list. <literal moreinfo="none">List.hd</literal> and
        <literal moreinfo="none">List.last</literal>, which return <literal moreinfo="none">None</literal>
        when they encounter an empty list, are used to extract the largest and
        smallest element of the list.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 2)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compute_bounds ~cmp list =</userinput>
<userinput moreinfo="none">    let sorted = List.sort ~cmp list in</userinput>
<userinput moreinfo="none">    match List.hd sorted, List.last sorted with</userinput>
<userinput moreinfo="none">    | None,_ | _, None -&gt; None</userinput>
<userinput moreinfo="none">    | Some x, Some y -&gt; Some (x,y)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

        <para>The match statement is used to handle the error cases,
        propagating a <literal moreinfo="none">None</literal> in <literal moreinfo="none">hd</literal> or
        <literal moreinfo="none">last</literal> into the return value of
        <literal moreinfo="none">compute_bounds</literal>.</para>

        <para>On the other hand, in <literal moreinfo="none">find_mismatches</literal> below,
        errors encountered during the computation do not propagate to the
        return value of the function. <literal moreinfo="none">find_mismatches</literal> takes
        two hash tables as arguments, and searches for keys that have
        different data in one table than in the other. As such, the failure to
        find a key in one table isn't a failure of any sort.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 3)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let find_mismatches table1 table2 =</userinput>
<userinput moreinfo="none">     Hashtbl.fold table1 ~init:[] ~f:(fun ~key ~data mismatches -&gt;</userinput>
<userinput moreinfo="none">        match Hashtbl.find table2 key with</userinput>
<userinput moreinfo="none">        | Some data' when data' &lt;&gt; data -&gt; key :: mismatches</userinput>
<userinput moreinfo="none">        | _ -&gt; mismatches</userinput>
<userinput moreinfo="none">     )</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val find_mismatches : ('a, 'b) Hashtbl.t -&gt; ('a, 'b) Hashtbl.t -&gt; 'a list =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

        <para>The use of options to encode errors underlines the fact that
        it's not clear whether a particular outcome, like not finding
        something on a list, is an error or is just another valid outcome.
        This depends on the larger context of your program, and thus is not
        something that a general purpose library can know in advance. One of
        the advantages of error-aware return types is that they work well in
        both situations.</para>

        <sect2 id="encoding-errors-with-result">
          <title>Encoding errors with <literal moreinfo="none">Result</literal></title>

          <para>Options aren't always a sufficiently expressive way to report
          errors. Specifically, when you encode an error as
          <literal moreinfo="none">None</literal>, there's nowhere to say anything about the
          nature of the error.</para>

          <para><literal moreinfo="none">Result.t</literal> is meant to address this
          deficiency. The type is defined as follows.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">error-handling/result.mli</filename></para>

          <programlisting language="ocaml" format="linespecific">module Result : sig
   type ('a,'b) t = | Ok of 'a
                    | Error of 'b
end</programlisting>

          <para>A <literal moreinfo="none">Result.t</literal> is essentially an option
          augmented with the ability to store other information in the error
          case. Like <literal moreinfo="none">Some</literal> and <literal moreinfo="none">None</literal> for
          options, the constructors <literal moreinfo="none">Ok</literal> and
          <literal moreinfo="none">Error</literal> are promoted to the toplevel by
          <literal moreinfo="none">Core.Std</literal>. As such, we can write:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 4)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">[ Ok 3; Error "abject failure"; Ok 4 ];;</userinput>
<computeroutput moreinfo="none">- : (int, string) Result.t list = [Ok 3; Error "abject failure"; Ok 4]</computeroutput></programlisting>

          <para>without first opening the <literal moreinfo="none">Result</literal>
          module.</para>
        </sect2>

        <sect2 id="error-and-or_error">
          <title><literal moreinfo="none">Error</literal> and
          <literal moreinfo="none">Or_error</literal></title>

          <para><literal moreinfo="none">Result.t</literal> gives you complete freedom to
          choose the type of value you use to represent errors, but it's often
          useful to standardize on an error type. Among other things, this
          makes it easier to write utility functions to automate common error
          handling patterns.</para>

          <para>But which type to choose? Is it better to represent errors as
          strings? Some more structured representation like XML? Or something
          else entirely?</para>

          <para>Core's answer to this question is the
          <literal moreinfo="none">Error.t</literal> type, which tries to forge a good
          compromise between efficiency, convenience, and control over the
          presentation of errors.</para>

          <para>It might not be obvious at first why efficiency is an issue at
          all. But generating error messages is an expensive business. An
          ASCII representation of a value can be quite time-consuming to
          construct, particularly if it includes expensive-to-convert
          numerical data.</para>

          <para><literal moreinfo="none">Error</literal> gets around this issue through
          laziness. In particular, an <literal moreinfo="none">Error.t</literal> allows you to
          put off generation of the error string until and unless you need it,
          which means a lot of the time you never have to construct it at all.
          You can of course construct an error directly from a string:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 5)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.of_string "something went wrong";;</userinput>
<computeroutput moreinfo="none">- : Error.t = something went wrong</computeroutput></programlisting>

          <para>But you can also construct an <literal moreinfo="none">Error.t</literal> from
          a <emphasis>thunk</emphasis>, <emphasis>i.e.</emphasis>, a function
          that takes a single argument of type <literal moreinfo="none">unit</literal>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 6)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.of_thunk (fun () -&gt;</userinput>
<userinput moreinfo="none">    sprintf "something went wrong: %f" 32.3343);;</userinput>
<computeroutput moreinfo="none">- : Error.t = something went wrong: 32.334300</computeroutput></programlisting>

          <para>In this case, we can benefit from the laziness of
          <literal moreinfo="none">Error</literal>, since the thunk won't be called unless the
          <literal moreinfo="none">Error.t</literal> is converted to a string.</para>

          <para>The most common way to create <literal moreinfo="none">Error.t</literal>s is
          using <emphasis>s-expressions</emphasis>. An s-expression is a
          balanced parenthetical expression where the leaves of the
          expressions are strings. Here's a simple example.</para>

          <para role="sourcecode">Scheme:
          <filename moreinfo="none">error-handling/sexpr.scm</filename></para>

          <programlisting language="scheme" format="linespecific">(This (is an) (s expression))</programlisting>

          <para>S-expressions are supported by the Sexplib package that is
          distributed with Core, and is the most common serialization format
          used in Core. Indeed, most types in Core come with built-in
          s-expression converters. Here's an example of creating an error
          using the sexp converter for times,
          <literal moreinfo="none">Time.sexp_of_t</literal>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 7)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.create "Something failed a long time ago" Time.epoch Time.sexp_of_t;;</userinput>
<computeroutput moreinfo="none">- : Error.t =</computeroutput>
<computeroutput moreinfo="none">Something failed a long time ago: (1970-01-01 01:00:00.000000+01:00)</computeroutput></programlisting>

          <para>Note that the time isn't actually serialized into an
          s-expression until the error is printed out.</para>

          <para>We're not restricted to doing this kind of error reporting
          with built-in types. This will be discussed in more detail in <xref linkend="data-serialization-with-s-expressions"/>, but Sexplib
          comes with a language extension that can autogenerate
          sexp-converters for newly generated types, as shown below.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 8)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let custom_to_sexp = &lt;:sexp_of&lt;float * string list * int&gt;&gt;;;</userinput>
<computeroutput moreinfo="none">val custom_to_sexp : float * string list * int -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">custom_to_sexp (3.5, ["a";"b";"c"], 6034);;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (3.5 (a b c) 6034)</computeroutput></programlisting>

          <para>We can use this same idiom for generating an error.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 9)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.create "Something went terribly wrong"</userinput>
<userinput moreinfo="none">    (3.5, ["a";"b";"c"], 6034)</userinput>
<userinput moreinfo="none">    &lt;:sexp_of&lt;float * string list * int&gt;&gt; ;;</userinput>
<computeroutput moreinfo="none">- : Error.t = Something went terribly wrong: (3.5(a b c)6034)</computeroutput></programlisting>

          <para><literal moreinfo="none">Error</literal> also supports operations for
          transforming errors. For example, it's often useful to augment an
          error with information about the context of the error or to combine
          multiple errors together. <literal moreinfo="none">Error.tag</literal> and
          <literal moreinfo="none">Error.of_list</literal> fulfill these roles, as you can see
          below.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 10)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.tag</userinput>
<userinput moreinfo="none">    (Error.of_list [ Error.of_string "Your tires were slashed";</userinput>
<userinput moreinfo="none">                     Error.of_string "Your windshield was smashed" ])</userinput>
<userinput moreinfo="none">    "over the weekend"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : Error.t =</computeroutput>
<computeroutput moreinfo="none">over the weekend: Your tires were slashed; Your windshield was smashed</computeroutput></programlisting>

          <para>The type <literal moreinfo="none">'a Or_error.t</literal> is just a shorthand
          for <literal moreinfo="none">('a,Error.t) Result.t</literal>, and it is, after
          <literal moreinfo="none">option</literal>, the most common way of returning errors
          in Core.</para>
        </sect2>

        <sect2 id="bind-and-other-error-handling-idioms">
          <title><literal moreinfo="none">bind</literal> and other error-handling
          idioms</title>

          <para>As you write more error handling code in OCaml, you'll
          discover that certain patterns start to emerge. A number of these
          common patterns have been codified by functions in modules like
          <literal moreinfo="none">Option</literal> and <literal moreinfo="none">Result</literal>. One
          particularly useful pattern is built around the function
          <literal moreinfo="none">bind</literal>, which is both an ordinary function and an
          infix operator <literal moreinfo="none">&gt;&gt;=</literal>. Here's the definition
          of <literal moreinfo="none">bind</literal> for options.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 11)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let bind option f =</userinput>
<userinput moreinfo="none">    match option with</userinput>
<userinput moreinfo="none">    | None -&gt; None</userinput>
<userinput moreinfo="none">    | Some x -&gt; f x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val bind : 'a option -&gt; ('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;</computeroutput></programlisting>

          <para>As you can see, <literal moreinfo="none">bind None f</literal> returns
          <literal moreinfo="none">None</literal> without calling <literal moreinfo="none">f</literal>, and
          <literal moreinfo="none">bind (Some x) f</literal> returns <literal moreinfo="none">f x</literal>.
          Perhaps surprisingly, <literal moreinfo="none">bind</literal> can be used as a way
          of sequencing together error-producing functions so that the first
          one to produce an error terminates the computation. Here's a rewrite
          of <literal moreinfo="none">compute_bounds</literal> to use a nested series of
          <literal moreinfo="none">bind</literal>s.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 12)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compute_bounds ~cmp list =</userinput>
<userinput moreinfo="none">    let sorted = List.sort ~cmp list in</userinput>
<userinput moreinfo="none">    Option.bind (List.hd sorted) (fun first -&gt;</userinput>
<userinput moreinfo="none">      Option.bind (List.last sorted) (fun last -&gt;</userinput>
<userinput moreinfo="none">        Some (first,last)))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

          <para>The above code is a little bit hard to swallow, however, on a
          syntactic level. We can make it easier to read, and drop some of the
          parentheses, by using the infix operator form of bind, which we get
          access to by locally opening <literal moreinfo="none">Option.Monad_infix</literal>.
          The module is called <literal moreinfo="none">Monad_infix</literal> because the bind
          operator is part of a sub-interface called <literal moreinfo="none">Monad</literal>,
          which we'll see again in <xref linkend="concurrent-programming-with-async"/>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 13)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compute_bounds ~cmp list =</userinput>
<userinput moreinfo="none">    let open Option.Monad_infix in</userinput>
<userinput moreinfo="none">    let sorted = List.sort ~cmp list in</userinput>
<userinput moreinfo="none">    List.hd sorted   &gt;&gt;= fun first -&gt;</userinput>
<userinput moreinfo="none">    List.last sorted &gt;&gt;= fun last  -&gt;</userinput>
<userinput moreinfo="none">    Some (first,last)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

          <para>This use of <literal moreinfo="none">bind</literal> isn't really materially
          better than the one we started with, and indeed, for small examples
          like this, direct matching of options is generally better than using
          <literal moreinfo="none">bind</literal>. But for large complex examples with many
          stages of error-handling, the bind idiom becomes clearer and easier
          to manage.</para>

          <para>There are other useful idioms encoded in the functions in
          <literal moreinfo="none">Option</literal>. One example is
          <literal moreinfo="none">Option.both</literal>, which takes two optional values and
          produces a new optional pair that is <literal moreinfo="none">None</literal> if
          either of its arguments are <literal moreinfo="none">None</literal>. Using
          <literal moreinfo="none">Option.both</literal>, we can make
          <literal moreinfo="none">compute_bounds</literal> even shorter.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 14)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compute_bounds ~cmp list =</userinput>
<userinput moreinfo="none">    let sorted = List.sort ~cmp list in</userinput>
<userinput moreinfo="none">    Option.both (List.hd sorted) (List.last sorted)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

          <para>These error-handling functions are valuable because they let
          you express your error handling both explicitly and concisely. We've
          only discussed these functions in the context of the
          <literal moreinfo="none">Option</literal> module, but more functionality of this
          kind can be found in the <literal moreinfo="none">Result</literal> and
          <literal moreinfo="none">Or_error</literal> modules.</para>
        </sect2>
      </sect1>

      <sect1 id="exceptions">
        <title>Exceptions</title>

        <para>Exceptions in OCaml are not that different from exceptions in
        many other languages, like Java, C# and Python. Exceptions are a way
        to terminate a computation and report an error, while providing a
        mechanism to catch and handle (and possibly recover from) exceptions
        that are triggered by sub-computations.</para>

        <para>You can trigger an exception by, for example, dividing an
        integer by zero:</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 15)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">3 / 0;;</userinput>
<computeroutput moreinfo="none">Exception: Division_by_zero.</computeroutput></programlisting>

        <para>And an exception can terminate a computation even if it happens
        nested somewhere deep within it.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 16)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:(fun x -&gt; 100 / x) [1;3;0;4];;</userinput>
<computeroutput moreinfo="none">Exception: Division_by_zero.</computeroutput></programlisting>

        <para>If we put a <literal moreinfo="none">printf</literal> in the middle of the
        computation, we can see that <literal moreinfo="none">List.map</literal> is
        interrupted part way through its execution, never getting to the end
        of the list.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 17)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:(fun x -&gt; printf "%d\n%!" x; 100 / x) [1;3;0;4];;</userinput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">0</computeroutput>
<computeroutput moreinfo="none">Exception: Division_by_zero.</computeroutput></programlisting>

        <para>In addition to built-in exceptions like
        <literal moreinfo="none">Divide_by_zero</literal>, OCaml lets you define your
        own.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 18)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Key_not_found of string;;</userinput>
<computeroutput moreinfo="none">exception Key_not_found of string</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">raise (Key_not_found "a");;</userinput>
<computeroutput moreinfo="none">Exception: Key_not_found("a").</computeroutput></programlisting>

        <para>Exceptions are ordinary values, and can be manipulated just like
        other OCaml values, as you can see below.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 19)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let exceptions = [ Not_found; Division_by_zero; Key_not_found "b" ];;</userinput>
<computeroutput moreinfo="none">val exceptions : exn list = [Not_found; Division_by_zero; Key_not_found("b")]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.filter exceptions  ~f:(function</userinput>
<userinput moreinfo="none">    | Key_not_found _ | Not_found -&gt; true</userinput>
<userinput moreinfo="none">    | _ -&gt; false);;</userinput>
<computeroutput moreinfo="none">- : exn list = [Not_found; Key_not_found("b")]</computeroutput></programlisting>

        <para>Exceptions are all of the same type, <literal moreinfo="none">exn</literal>. The
        <literal moreinfo="none">exn</literal> type is something of a special case in the
        OCaml type system. It is similar to the variant types we encountered
        in <xref linkend="variants"/>, except that it is
        <emphasis>open</emphasis>, meaning that it's not fully defined in any
        one place. In particular, new tags (specifically, new exceptions) can
        be added to it by different parts of the program. This is in contrast
        to ordinary variants, which are defined with a closed universe of
        available tags. One result of this is that you can never have an
        exhaustive match on an <literal moreinfo="none">exn</literal>, since the full set of
        possible exceptions is not known.</para>

        <para>The following function uses the <literal moreinfo="none">Key_not_found</literal>
        exception we defined above to signal an error.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 20)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec find_exn alist key = match alist with</userinput>
<userinput moreinfo="none">    | [] -&gt; raise (Key_not_found key)</userinput>
<userinput moreinfo="none">    | (key',data) :: tl -&gt; if key = key' then data else find_exn tl key</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val find_exn : (string * 'a) list -&gt; string -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let alist = [("a",1); ("b",2)];;</userinput>
<computeroutput moreinfo="none">val alist : (string * int) list = [("a", 1); ("b", 2)]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_exn alist "a";;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_exn alist "c";;</userinput>
<computeroutput moreinfo="none">Exception: Key_not_found("c").</computeroutput></programlisting>

        <para>Note that we named the function <literal moreinfo="none">find_exn</literal> to
        warn the user that the function routinely throws exceptions, a
        convention that is used heavily in Core.</para>

        <para>In the above example, <literal moreinfo="none">raise</literal> throws the
        exception, thus terminating the computation. The type of raise is a
        bit surprising when you first see it:</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 21)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">raise;;</userinput>
<computeroutput moreinfo="none">- : exn -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

        <para>The return type of <literal moreinfo="none">'a</literal> makes it look like
        <literal moreinfo="none">raise</literal> manufactures a value to return that is
        completely unconstrained in its type. That seems impossible, and it
        is. Really, <literal moreinfo="none">raise</literal> has a return type of
        <literal moreinfo="none">'a</literal> because it never returns at all. This behavior
        isn't restricted to functions like <literal moreinfo="none">raise</literal> that
        terminate by throwing exceptions. Here's another example of a function
        that doesn't return a value.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">error-handling/main.topscript</filename> (part 22)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec forever () = forever ();;</userinput>
<computeroutput moreinfo="none">val forever : unit -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

        <para><literal moreinfo="none">forever</literal> doesn't return a value for a
        different reason: it's an infinite loop.</para>

        <para>This all matters because it means that the return type of
        <literal moreinfo="none">raise</literal> can be whatever it needs to be to fit in to
        the context it is called in. Thus, the type system will let us throw
        an exception anywhere in a program.</para>

        <note>
          <title>Declaring exceptions using <literal moreinfo="none">with
          sexp</literal></title>

          <para>OCaml can't always generate a useful textual representation of
          an exception. For example:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 23)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Wrong_date of Date.t;;</userinput>
<computeroutput moreinfo="none">exception Wrong_date of Date.t</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Wrong_date (Date.of_string "2011-02-23");;</userinput>
<computeroutput moreinfo="none">- : exn = Wrong_date(_)</computeroutput></programlisting>

          <para>But if we declare the exception using <literal moreinfo="none">with
          sexp</literal> (and the constituent types have sexp converters),
          we'll get something with more information.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 24)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Wrong_date of Date.t with sexp;;</userinput>
<computeroutput moreinfo="none">exception Wrong_date of Date.t</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Wrong_date (Date.of_string "2011-02-23");;</userinput>
<computeroutput moreinfo="none">- : exn = (//toplevel//.Wrong_date 2011-02-23)</computeroutput></programlisting>

          <para>The period in front of <literal moreinfo="none">Wrong_date</literal> is there
          because the representation generated by <literal moreinfo="none">with sexp</literal>
          includes the full module path of the module where the exception in
          question is defined. In this case, the string
          <literal moreinfo="none">//toplevel//</literal> is used to indicate that this was
          declared at the top-level, rather than in a module.</para>

          <para>This is all part of the support for s-expressions provided by
          the Sexplib library and syntax-extension, which is described in more
          detail in <xref linkend="data-serialization-with-s-expressions"/>.</para>
        </note>

        <sect2 id="helper-functions-for-throwing-exceptions">
          <title>Helper functions for throwing exceptions</title>

          <para>OCaml and Core provide a number of helper functions to
          simplify the task of throwing exceptions. The simplest one is
          <literal moreinfo="none">failwith</literal>, which could be defined as
          follows:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 25)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let failwith msg = raise (Failure msg);;</userinput>
<computeroutput moreinfo="none">val failwith : string -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

          <para>There are several other useful functions for raising
          exceptions, which can be found in the API documentation for the
          <literal moreinfo="none">Common</literal> and <literal moreinfo="none">Exn</literal> modules in
          Core.</para>

          <para>Another important way of throwing an exception is the
          <literal moreinfo="none">assert</literal> directive. <literal moreinfo="none">assert</literal> is
          used for situations where a violation of the condition in question
          indicates a bug. Consider the following piece of code for zipping
          together two lists.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 26)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let merge_lists xs ys ~f =</userinput>
<userinput moreinfo="none">    if List.length xs &lt;&gt; List.length ys then None</userinput>
<userinput moreinfo="none">    else</userinput>
<userinput moreinfo="none">      let rec loop xs ys =</userinput>
<userinput moreinfo="none">        match xs,ys with</userinput>
<userinput moreinfo="none">        | [],[] -&gt; []</userinput>
<userinput moreinfo="none">        | x::xs, y::ys -&gt; f x y :: loop xs ys</userinput>
<userinput moreinfo="none">        | _ -&gt; assert false</userinput>
<userinput moreinfo="none">      in</userinput>
<userinput moreinfo="none">      Some (loop xs ys)</userinput>
<userinput moreinfo="none">   ;;</userinput>
<computeroutput moreinfo="none">val merge_lists : 'a list -&gt; 'b list -&gt; f:('a -&gt; 'b -&gt; 'c) -&gt; 'c list option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">merge_lists [1;2;3] [-1;1;2] ~f:(+);;</userinput>
<computeroutput moreinfo="none">- : int list option = Some [0; 3; 5]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">merge_lists [1;2;3] [-1;1] ~f:(+);;</userinput>
<computeroutput moreinfo="none">- : int list option = None</computeroutput></programlisting>

          <para>Here we use <literal moreinfo="none">assert false</literal>, which means that
          the assert is guaranteed to trigger. In general, one can put an
          arbitrary condition in the assertion.</para>

          <para>In this case, the assert can never be triggered because we
          have a check that makes sure that the lists are of the same length
          before we call <literal moreinfo="none">loop</literal>. If we change the code so
          that we drop this test, then we can trigger the assert.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 27)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let merge_lists xs ys ~f =</userinput>
<userinput moreinfo="none">    let rec loop xs ys =</userinput>
<userinput moreinfo="none">      match xs,ys with</userinput>
<userinput moreinfo="none">      | [],[] -&gt; []</userinput>
<userinput moreinfo="none">      | x::xs, y::ys -&gt; f x y :: loop xs ys</userinput>
<userinput moreinfo="none">      | _ -&gt; assert false</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    loop xs ys</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val merge_lists : 'a list -&gt; 'b list -&gt; f:('a -&gt; 'b -&gt; 'c) -&gt; 'c list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">merge_lists [1;2;3] [-1] ~f:(+);;</userinput>
<computeroutput moreinfo="none">Exception: (Assert_failure //toplevel// 5 13).</computeroutput></programlisting>

          <para>This shows what's special about <literal moreinfo="none">assert</literal>: it
          captures the line number and character offset of the source location
          from which the assertion was made.</para>
        </sect2>

        <sect2 id="exception-handlers">
          <title>Exception handlers</title>

          <para>So far, we've only seen exceptions fully terminate the
          execution of a computation. But often, we want a program to be able
          to respond to and recover from an exception. This is achieved
          through the use of <emphasis>exception handlers</emphasis>.</para>

          <para>In OCaml, an exception handler is declared using a
          <literal moreinfo="none">try</literal>/<literal moreinfo="none">with</literal> statement. Here's the
          basic syntax.</para>

          <para role="sourcecode">Syntax:
          <filename moreinfo="none">error-handling/try_with.syntax</filename></para>

          <programlisting language="" format="linespecific">try &lt;expr&gt; with
| &lt;pat1&gt; -&gt; &lt;expr1&gt;
| &lt;pat2&gt; -&gt; &lt;expr2&gt;
...</programlisting>

          <para>A <literal moreinfo="none">try/with</literal> clause first evaluates its body,
          <literal moreinfo="none">&lt;expr&gt;</literal>. If no exception is thrown, then the
          result of evaluating the body is what the entire
          <literal moreinfo="none">try/with</literal> clause evaluates to.</para>

          <para>But if the evaluation of the body throws an exception, then
          the exception will be fed to the pattern match statements following
          the <literal moreinfo="none">with</literal>. If the exception matches a pattern,
          then we consider the exception caught, and the
          <literal moreinfo="none">try/with</literal> clause evaluates to the expression on
          the right-hand side of the matching pattern.</para>

          <para>Otherwise, the original exception continues up the stack of
          function calls, to be handled by the next outer exception handler.
          If the exception is never caught, it terminates the program.</para>
        </sect2>

        <sect2 id="cleaning-up-in-the-presence-of-exceptions">
          <title>Cleaning up in the presence of exceptions</title>

          <para>One headache with exceptions is that they can terminate your
          execution at unexpected places, leaving your program in an awkward
          state. Consider the following function for loading a file full of
          reminders, formatted as s-expressions.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 28)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let reminders_of_sexp =</userinput>
<userinput moreinfo="none">    &lt;:of_sexp&lt;(Time.t * string) list&gt;&gt;</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val reminders_of_sexp : Sexp.t -&gt; (Time.t * string) list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let load_reminders filename =</userinput>
<userinput moreinfo="none">    let inc = In_channel.create filename in</userinput>
<userinput moreinfo="none">    let reminders = reminders_of_sexp (Sexp.input_sexp inc) in</userinput>
<userinput moreinfo="none">    In_channel.close inc;</userinput>
<userinput moreinfo="none">    reminders</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val load_reminders : string -&gt; (Time.t * string) list = &lt;fun&gt;</computeroutput></programlisting>

          <para>The problem with this code is that the function that loads the
          s-expression and parses it into a list of
          <literal moreinfo="none">Time.t</literal>/<literal moreinfo="none">string</literal> pairs might
          throw an exception if the file in question is malformed.
          Unfortunately, that means that the <literal moreinfo="none">In_channel.t</literal>
          that was opened will never be closed, leading to a file-descriptor
          leak.</para>

          <para>We can fix this using Core's <literal moreinfo="none">protect</literal>
          function, which takes two arguments: a thunk <literal moreinfo="none">f</literal>,
          which is the main body of the computation to be run, and a thunk
          <literal moreinfo="none">finally</literal>, which is to be called when
          <literal moreinfo="none">f</literal> exits, whether it exits normally or with an
          exception. This is similar to the <literal moreinfo="none">try/finally</literal>
          construct available in many programming languages, but it is
          implemented in a library, rather than being a built-in primitive.
          Here's how it could be used to fix
          <literal moreinfo="none">load_reminders</literal>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 29)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let load_reminders filename =</userinput>
<userinput moreinfo="none">    let inc = In_channel.create filename in</userinput>
<userinput moreinfo="none">    protect ~f:(fun () -&gt; reminders_of_sexp (Sexp.input_sexp inc))</userinput>
<userinput moreinfo="none">      ~finally:(fun () -&gt; In_channel.close inc)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val load_reminders : string -&gt; (Time.t * string) list = &lt;fun&gt;</computeroutput></programlisting>

          <para>This is a common enough problem that
          <literal moreinfo="none">In_channel</literal> has a function called
          <literal moreinfo="none">with_file</literal> that automates this pattern.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 30)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let reminders_of_sexp filename =</userinput>
<userinput moreinfo="none">    In_channel.with_file filename ~f:(fun inc -&gt;</userinput>
<userinput moreinfo="none">      reminders_of_sexp (Sexp.input_sexp inc))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val reminders_of_sexp : string -&gt; (Time.t * string) list = &lt;fun&gt;</computeroutput></programlisting>

          <para><literal moreinfo="none">In_channel.with_file</literal> is built on top of
          <literal moreinfo="none">protect</literal> so that it can clean up after itself in
          the presence of exceptions.</para>
        </sect2>

        <sect2 id="catching-specific-exceptions">
          <title>Catching specific exceptions</title>

          <para>OCaml's exception-handling system allows you to tune your
          error-recovery logic to the particular error that was thrown. For
          example, <literal moreinfo="none">List.find_exn</literal> throws
          <literal moreinfo="none">Not_found</literal> when the element in question can't be
          found. Let's look at an example of how you could take advantage of
          this. In particular, consider the following function</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 31)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let lookup_weight ~compute_weight alist key =</userinput>
<userinput moreinfo="none">    try</userinput>
<userinput moreinfo="none">      let data = List.Assoc.find_exn alist key in</userinput>
<userinput moreinfo="none">      compute_weight data</userinput>
<userinput moreinfo="none">    with</userinput>
<userinput moreinfo="none">      Not_found -&gt; 0. ;;</userinput>
<computeroutput moreinfo="none">val lookup_weight :</computeroutput>
<computeroutput moreinfo="none">  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

          <para>As you can see from the type, <literal moreinfo="none">lookup_weight</literal>
          takes an association list, a key for looking up a corresponding
          value in that list, and a function for computing a floating-point
          weight from the looked-up value. If no value is found, then a weight
          of <literal moreinfo="none">0.</literal> should be returned.</para>

          <para>The use of exceptions in this code, however, presents some
          problems. In particular, what happens if
          <literal moreinfo="none">compute_weight</literal> throws an exception? Ideally,
          <literal moreinfo="none">lookup_weight</literal> should propagate that exception on,
          but if the exception happens to be <literal moreinfo="none">Not_found</literal>,
          then that's not what will happen:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 32)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">lookup_weight ~compute_weight:(fun _ -&gt; raise Not_found)</userinput>
<userinput moreinfo="none">    ["a",3; "b",4] "a" ;;</userinput>
<computeroutput moreinfo="none">- : float = 0.</computeroutput></programlisting>

          <para>This kind of problem is hard to detect in advance, because the
          type system doesn't tell you what exceptions a given function might
          throw. For this reason, it's generally better to avoid relying on
          the identity of the exception to determine the nature of a failure.
          A better approach is to narrow the scope of the exception handler,
          so that when it fires it's very clear what part of the code
          failed.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 33)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let lookup_weight ~compute_weight alist key =</userinput>
<userinput moreinfo="none">    match</userinput>
<userinput moreinfo="none">      try Some (List.Assoc.find_exn alist key)</userinput>
<userinput moreinfo="none">      with _ -&gt; None</userinput>
<userinput moreinfo="none">    with</userinput>
<userinput moreinfo="none">    | None -&gt; 0.</userinput>
<userinput moreinfo="none">    | Some data -&gt; compute_weight data ;;</userinput>
<computeroutput moreinfo="none">val lookup_weight :</computeroutput>
<computeroutput moreinfo="none">  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

          <para>At which point, it makes sense to simply use the non-exception
          throwing function, <literal moreinfo="none">List.Assoc.find</literal>,
          instead.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 34)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let lookup_weight ~compute_weight alist key =</userinput>
<userinput moreinfo="none">    match List.Assoc.find alist key with</userinput>
<userinput moreinfo="none">    | None -&gt; 0.</userinput>
<userinput moreinfo="none">    | Some data -&gt; compute_weight data ;;</userinput>
<computeroutput moreinfo="none">val lookup_weight :</computeroutput>
<computeroutput moreinfo="none">  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>
        </sect2>

        <sect2 id="backtraces">
          <title>Backtraces</title>

          <para>A big part of the value of exceptions is that they provide
          useful debugging information in the form of a stack backtrace.
          Consider the following simple program.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">error-handling/blow_up.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">open Core.Std
exception Empty_list

let list_max = function
  | [] -&gt; raise Empty_list
  | hd :: tl -&gt; List.fold tl ~init:hd ~f:(Int.max)

let () =
  printf "%d\n" (list_max [1;2;3]);
  printf "%d\n" (list_max [])</programlisting>

          <para>If we build and run this program, we'll get a stack backtrace
          that will give you some information about where the error occurred,
          and the stack of function calls that were in place at the time of
          the error.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">error-handling/build_blow_up.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild blow_up.byte</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./blow_up.byte</userinput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">Fatal error: exception Blow_up.Empty_list</computeroutput>
<computeroutput moreinfo="none">Raised at file "blow_up.ml", line 5, characters 16-26</computeroutput>
<computeroutput moreinfo="none">Called from file "blow_up.ml", line 10, characters 17-28</computeroutput></programlisting>

          <para>You can also capture a backtrace within your program by
          calling <literal moreinfo="none">Exn.backtrace</literal>, which returns the
          backtrace of the most recently thrown exception. This is useful for
          reporting detailed information on errors that did not cause your
          program to fail.</para>

          <para>This works well if you have backtraces enabled, but that isn't
          always the case. In fact, by default, OCaml has backtraces turned
          off, and even if you have them turned on at runtime, you can't get
          backtraces unless you have compiled with debugging symbols. Core
          reverses the default, so if you're linking in Core, you will have
          backtraces enabled by default.</para>

          <para>Even using Core and compiling with debugging symbols, you can
          turn backtraces off by setting the <literal moreinfo="none">OCAMLRUNPARAM</literal>
          environment variable to be empty.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">error-handling/build_blow_up_notrace.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild blow_up.byte</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">OCAMLRUNPARAM= ./blow_up.byte</userinput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">Fatal error: exception Blow_up.Empty_list</computeroutput></programlisting>

          <para>The resulting error message is considerably less informative.
          You can also turn backtraces off in your code by calling
          <literal moreinfo="none">Backtrace.Exn.set_recording false</literal>.</para>

          <para>There is a legitimate reasons to run without backtraces:
          speed. OCaml's exceptions are fairly fast, but they're even faster
          still if you disable backtraces. Here's a simple benchmark that
          shows the effect, using the <literal moreinfo="none">core_bench</literal>
          package.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">error-handling/exn_cost.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">open Core.Std
open Core_bench.Std

let simple_computation () =
  List.range 0 10
  |&gt; List.fold ~init:0 ~f:(fun sum x -&gt; sum + x * x)
  |&gt; ignore

let simple_with_handler () =
  try simple_computation () with Exit -&gt; ()

let end_with_exn () =
  try
    simple_computation ();
    raise Exit
  with Exit -&gt; ()

let () =
  [ Bench.Test.create ~name:"simple computation"
      (fun () -&gt; simple_computation ());
    Bench.Test.create ~name:"simple computation w/handler"
      (fun () -&gt; simple_with_handler ());
    Bench.Test.create ~name:"end with exn"
      (fun () -&gt; end_with_exn ());
  ]
  |&gt; Bench.make_command
  |&gt; Command.run</programlisting>

          <para>We're testing three cases here: a simple computation with no
          exceptions; the same computation with an exception handler but no
          thrown exceptions; and finally the same computation where we use the
          exception to do the control flow back to the caller.</para>

          <para>If we run this with stacktraces on, the benchmark results look
          like this.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">error-handling/run_exn_cost.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench exn_cost.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./exn_cost.native -ascii cycles</userinput>
<computeroutput moreinfo="none">Estimated testing time 30s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                                                </computeroutput>
<computeroutput moreinfo="none">  Name                           Cycles   Time (ns)   % of max  </computeroutput>
<computeroutput moreinfo="none"> ------------------------------ -------- ----------- ---------- </computeroutput>
<computeroutput moreinfo="none">  simple computation                279         117      76.40  </computeroutput>
<computeroutput moreinfo="none">  simple computation w/handler      308         129      84.36  </computeroutput>
<computeroutput moreinfo="none">  end with exn                      366         153     100.00  </computeroutput>
<computeroutput moreinfo="none">                                                                </computeroutput></programlisting>

          <para>Here, we see that we lose something like 20 cycles to adding
          an exception handler, and 30 more to actually throwing and catching
          an exception. If we turn backtraces off, then the results look like
          this.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">error-handling/run_exn_cost_notrace.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">OCAMLRUNPARAM= ./exn_cost.native -ascii cycles</userinput>
<computeroutput moreinfo="none">Estimated testing time 30s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                                                </computeroutput>
<computeroutput moreinfo="none">  Name                           Cycles   Time (ns)   % of max  </computeroutput>
<computeroutput moreinfo="none"> ------------------------------ -------- ----------- ---------- </computeroutput>
<computeroutput moreinfo="none">  simple computation                279         116      83.50  </computeroutput>
<computeroutput moreinfo="none">  simple computation w/handler      308         128      92.09  </computeroutput>
<computeroutput moreinfo="none">  end with exn                      334         140     100.00  </computeroutput>
<computeroutput moreinfo="none">                                                                </computeroutput></programlisting>

          <para>Here, the handler costs about the same, at 20 cycles, but the
          exception itself costs only 20, as opposed to 30 additional cycles.
          All told, this should only matter if you're using exceptions
          routinely as part of your flow control, which is in most cases a
          stylistic mistake anyway.</para>
        </sect2>

        <sect2 id="from-exceptions-to-error-aware-types-and-back-again">
          <title>From exceptions to error-aware types and back again</title>

          <para>Both exceptions and error-aware types are necessary parts of
          programming in OCaml. As such, you often need to move between these
          two worlds. Happily, Core comes with some useful helper functions to
          help you do just that. For example, given a piece of code that can
          throw an exception, you can capture that exception into an option as
          follows:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 35)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let find alist key =</userinput>
<userinput moreinfo="none">    Option.try_with (fun () -&gt; find_exn alist key) ;;</userinput>
<computeroutput moreinfo="none">val find : (string * 'a) list -&gt; string -&gt; 'a option = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find ["a",1; "b",2] "c";;</userinput>
<computeroutput moreinfo="none">- : int option = None</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find ["a",1; "b",2] "b";;</userinput>
<computeroutput moreinfo="none">- : int option = Some 2</computeroutput></programlisting>

          <para>And <literal moreinfo="none">Result</literal> and <literal moreinfo="none">Or_error</literal>
          have similar <literal moreinfo="none">try_with</literal> functions. So, we could
          write:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 36)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let find alist key =</userinput>
<userinput moreinfo="none">    Or_error.try_with (fun () -&gt; find_exn alist key) ;;</userinput>
<computeroutput moreinfo="none">val find : (string * 'a) list -&gt; string -&gt; 'a Or_error.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find ["a",1; "b",2] "c";;</userinput>
<computeroutput moreinfo="none">- : int Or_error.t = Core_kernel.Result.Error ("Key_not_found(\"c\")")</computeroutput></programlisting>

          <para>And then we can re-raise that exception:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">error-handling/main.topscript</filename> (part 37)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Or_error.ok_exn (find ["a",1; "b",2] "b");;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Or_error.ok_exn (find ["a",1; "b",2] "c");;</userinput>
<computeroutput moreinfo="none">Exception: ("Key_not_found(\"c\")").</computeroutput></programlisting>
        </sect2>
      </sect1>

      <sect1 id="choosing-an-error-handling-strategy">
        <title>Choosing an error handling strategy</title>

        <para>Given that OCaml supports both exceptions and error-aware return
        types, how do you choose between them? The key is to think about the
        tradeoff between concision and explicitness.</para>

        <para>Exceptions are more concise because they allow you to defer the
        job of error handling to some larger scope, and because they don't
        clutter up your types. But this same concision comes at a cost:
        exceptions are all too easy to ignore. Error-aware return types, on
        the other hand, are fully manifest in your type definitions, making
        the errors that your code might generate explicit and impossible to
        ignore.</para>

        <para>The right tradeoff depends on your application. If you're
        writing a rough and ready program where getting it done quickly is
        key, and failure is not that expensive, then using exceptions
        extensively may be the way to go. If, on the other hand, you're
        writing production software whose failure is costly, then you should
        probably lean in the direction of using error-aware return
        types.</para>

        <para>To be clear, it doesn't make sense to avoid exceptions entirely.
        The maxim of "use exceptions for exceptional conditions" applies. If
        an error occurs sufficiently rarely, then throwing an exception is
        often the right behavior.</para>

        <para>Also, for errors that are omnipresent, error-aware return types
        may be overkill. A good example is out-of-memory errors, which can
        occur anywhere, and so you'd need to use error-aware return types
        everywhere to capture those. Having every operation marked as one that
        might fail is no more explicit than having none of them marked.</para>

        <para>In short, for errors that are a foreseeable and ordinary part of
        the execution of your production code and that are not omnipresent,
        error aware return types are typically the right solution.</para>
      </sect1>
    </chapter>
