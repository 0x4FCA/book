<section xmlns="http://www.w3.org/1999/xhtml" id="command-line-parsing" data-type="chapter"><h1>Command-Line Parsing</h1><p>Many of the OCaml programs that you'll write will end up as binaries
  that need to be run from a command prompt. Any nontrivial command line
  should support a collection of basic features:</p><ul><li><p>Parsing of command-line arguments</p></li><li><p>Generation of error messages in response to incorrect
      inputs</p></li><li><p>Help for all the available options</p></li><li><p>Interactive autocompletion</p></li></ul><p>It's tedious and error-prone to code all of this manually for every
  program you write. Core provides the Command library, which simplifies all
  of this by letting you declare all your command-line options in one place
  and by deriving all of the above functionality from these
  declarations.<a data-type="indexterm" data-primary="command-line parsing" data-secondary="Command library for"/></p><p>Command is simple to use for simple applications but also scales well
  as your needs grow more complex. In particular, Command provides a
  sophisticated subcommand mode that groups related commands together as the
  complexity of your user interface grows. You may already be familiar with
  this command-line style from the Git or Mercurial version control
  systems.</p><p>In this chapter, we'll:</p><ul><li><p>Learn how to use Command to construct basic and grouped
      command-line interfaces</p></li><li><p>We will build simple equivalents to the cryptographic <code>md5</code> and <code>shasum</code> utilities</p></li><li><p>Demonstrate how <em>functional combinators</em> can be
      used to declare complex command-line interfaces in a type-safe and
      elegant way<a data-type="indexterm" data-primary="combinators" data-secondary="functional combinators"/></p></li></ul><section id="basic-command-line-parsing" data-type="sect1"><h1>Basic Command-Line Parsing</h1><p>Let's start by working through a clone of the <em>md5sum</em> command that is
      present on most Linux installations (the equivalent command on Mac OS X is simply <code>md5</code>). The following function defined below reads in the contents
      of a file, applies the MD5 one-way cryptographic hash function to the data, and outputs an
      ASCII hex representation of the result:<a data-type="indexterm" data-primary="MD5 one-way cryptographic hash function"/><a data-type="indexterm" data-primary="command-line parsing" data-secondary="basic approach to"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let do_hash file =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )</pre><p>The <code>do_hash</code> function accepts a
    <code>filename</code> parameter and prints the
    human-readable MD5 string to the console standard output. The first step
    toward turning this function into a command-line program is to declare all
    the possible command-line arguments in a
    <em>specification</em>. <code>Command.Spec</code> defines combinators that can be
    chained together to define optional flags and positional arguments, what
    types they should map to, and whether to take special actions (such as
    pausing for interactive input) if certain inputs are encountered.</p><section id="anonymous-arguments" data-type="sect2"><h2>Anonymous Arguments</h2><p>Let's build the specification for a single argument that is passed
      directly on the command line. This is known as an
      <em>anonymous</em> argument:<a data-type="indexterm" data-primary="arguments" data-secondary="anonymous arguments"/><a data-type="indexterm" data-primary="anonymous arguments"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">let spec =
  let open Command.Spec in
  empty
  +&gt; anon ("filename" %: string)</pre><p>The <code>Command.Spec</code> module defines
      the tools you'll need to build up a command-line specification. We start
      with the <code>empty</code> value and add
      parameters to that using the <code>+&gt;</code>
      combinator. (Both of these values come from <code>Command.Spec</code>.)</p><p>In this case, we defined a single anonymous argument called
      <code>filename</code>, which takes a value of type
      <code>string</code>. Anonymous parameters are
      created using the <code>%:</code> operator, which
      binds a textual name (used in the help text to identify the parameter)
      to an OCaml conversion function that parses the command-line string
      fragments into a higher-level OCaml data type. In the preceding example,
      this is just <code>Command.Spec.string</code>, but
      we'll see more complex conversion options later in the chapter.</p></section><section id="defining-basic-commands" data-type="sect2"><h2>Defining Basic Commands</h2><p>Once we've defined a specification, we need to put it to work on
      real input. The simplest way is to directly create a command-line
      interface via the <code>Command.basic</code>
      module:<a data-type="indexterm" data-primary="Command.basic module"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    spec
    (fun filename () -&gt; do_hash filename)</pre><p><code>Command.basic</code> defines a
      complete command-line interface that takes the following extra
      arguments, in addition to the ones defined in the specification:</p><dl><dt><code>summary</code></dt><dd><p>A required one-line description to go at the top of the
            command help screen.</p></dd><dt><code>readme</code></dt><dd><p>For longer help text when the command is called with
            <code>-help</code>. The <code>readme</code> argument is a function that is
            only evaluated when the help text is actually needed.</p></dd></dl><p>The specification and the callback function follow as nonlabeled
      arguments.</p><p>The callback function is where all the work happens after the
      command-line parsing is complete. This function is applied with the
      arguments containing the parsed command-line values, and it takes over
      as the main thread of the application. The callback's arguments are
      passed in the same order as they were bound in the specification (using
      the <code>+&gt;</code> operator).<a data-type="indexterm" data-primary="arguments" data-secondary="unit argument to callbacks"/><a data-type="indexterm" data-primary="unit argument"/><a data-type="indexterm" data-primary="callback function"/></p><div data-type="note"><h1>The Extra unit Argument to Callbacks</h1><p>The preceding callback needs an extra <code>unit</code> argument after <code>filename</code>. This is to ensure that
        specifications can work even when they are empty (i.e. the <code>Command.Spec.empty</code> value).</p><p>Every OCaml function needs at least one argument, so the final
        <code>unit</code> guarantees that it will not be
        evaluated immediately as a value if there are no other
        arguments.</p></div></section><section id="running-basic-commands" data-type="sect2"><h2>Running Basic Commands</h2><p>Once we've defined the basic command, running it is just one
      function call away:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml">let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</pre><p><code>Command.run</code> takes a couple of
      optional arguments that are useful to identify which version of the
      binary you are running in production. You'll need to install Cryptokit
      via <code>opam install cryptokit</code> before
      building this example. Once that's completed, run the following to
      compile the binary:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_basic_md5.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>corebuild -pkg cryptokit basic_md5.native</code></strong>
</pre><p>You can now query the version information for the binary you just
      compiled:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/get_basic_md5_version.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>./basic_md5.native -version</code></strong>
<code class="computeroutput">1.0</code>
<code class="prompt">$ </code><strong><code>./basic_md5.native -build-info</code></strong>
<code class="computeroutput">RWO</code></pre><p>The versions that you see in the output were defined via the
      optional arguments to <code>Command.run</code>.
      You can leave these blank in your own programs or get your build system
      to generate them directly from your version control system (e.g., by
      running <code>hg id</code> to generate a build
      revision number, in the case of Mercurial):</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/get_basic_md5_help.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>./basic_md5.native</code></strong>
<code class="computeroutput">Generate an MD5 hash of the input data</code>
<code class="computeroutput"> </code>
<code class="computeroutput">  basic_md5.native FILENAME</code>
<code class="computeroutput"> </code>
<code class="computeroutput">More detailed information</code>
<code class="computeroutput"> </code>
<code class="computeroutput">=== flags ===</code>
<code class="computeroutput"> </code>
<code class="computeroutput">  [-build-info]  print info about this build and exit</code>
<code class="computeroutput">  [-version]     print the version of this build and exit</code>
<code class="computeroutput">  [-help]        print this help text and exit</code>
<code class="computeroutput">                 (alias: -?)</code>
<code class="computeroutput"> </code>
<code class="computeroutput">missing anonymous argument: FILENAME</code></pre><p>When we invoke this binary without any arguments, it helpfully
      displays all of the command-line options available, along with a message
      to the standard error that informs you that a required argument <code>filename</code> is missing.</p><p>If you do supply the <code>filename</code>
      argument, then <code>do_hash</code> is called with
      the argument and the MD5 output is displayed to the standard
      output:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_md5.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>./basic_md5.native ./basic_md5.native</code></strong>
<code class="computeroutput">b5ee7de449a2e0c6c01d4f2d898926de</code></pre><p>And that's all it took to build our little MD5 utility! Here's a
      complete version of the example we just walked through, made slightly
      more succinct by removing intermediate variables:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_succinct.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: string))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</pre><p>Now that we have the basics in place, the rest of the chapter will
      examine some of the more advanced features of Command.</p></section></section><section id="argument-types" data-type="sect1"><h1>Argument Types</h1><p>You aren't just limited to parsing command lines as strings, of
    course. <code>Command.Spec</code> defines several
    other conversion functions (shown in <a href="#table14_1" data-type="xref"/>) that
    validate and parse input into various types.<a data-type="indexterm" data-primary="arguments" data-secondary="argument types"/><a data-type="indexterm" data-primary="command-line parsing" data-secondary="argument types"/></p><table id="table14_1"><caption>Conversion functions defined by
      <code>Command.spec</code></caption><thead><tr><th>Argument type</th><th>OCaml type</th><th>Example</th></tr></thead><tbody><tr><td><code>string</code></td><td><code>string</code></td><td><code>foo</code></td></tr><tr><td><code>int</code></td><td><code>int</code></td><td><code>123</code></td></tr><tr><td><code>float</code></td><td><code>float</code></td><td><code>123.01</code></td></tr><tr><td><code>bool</code></td><td><code>bool</code></td><td><code>true</code></td></tr><tr><td><code>date</code></td><td><code>Date.t</code></td><td><code>2013-12-25</code></td></tr><tr><td><code>time_span</code></td><td><code>Span.t</code></td><td><code>5s</code></td></tr><tr><td><code>file</code></td><td><code>string</code></td><td><code>/etc/passwd</code></td></tr></tbody></table><p>We can tighten up the specification of the command to <code>file</code> to reflect that the argument must be a
    valid filename, and not just any string:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_as_filename.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: file))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</pre><p>Running this with a nonexistent filename will now output an error if
    the file doesn't exist. As a bonus, it also enables interactive
    command-line completion to work on the filename argument (explained later
    in the chapter):</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_md5_as_filename.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>./basic_md5_as_filename.native nonexistent</code></strong>
<code class="computeroutput">Uncaught exception:</code>
<code class="computeroutput">  </code>
<code class="computeroutput">  (Sys_error "nonexistent: No such file or directory")</code>
<code class="computeroutput"> </code>
<code class="computeroutput">Raised by primitive operation at file "pervasives.ml", line 292, characters 20-46</code>
<code class="computeroutput">Called from file "lib/in_channel.ml", line 19, characters 46-65</code>
<code class="computeroutput">Called from file "lib/exn.ml", line 87, characters 6-10</code></pre><section id="defining-custom-argument-types" data-type="sect2"><h2>Defining Custom Argument Types</h2><p>We can also define our own argument types if the predefined ones
      aren't sufficient. For instance, let's make a <code>regular_file</code> argument type that ensures that
      the input file isn't a character device or some other odd UNIX file type
      that can't be fully read:<a data-type="indexterm" data-primary="arguments" data-secondary="defining custom types"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_custom_arg.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let regular_file =
  Command.Spec.Arg_type.create
    (fun filename -&gt;
       match Sys.is_file filename with
       | `Yes -&gt; filename
       | `No | `Unknown -&gt;
         eprintf "'%s' is not a regular file.\n%!" filename;
         exit 1
    )

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: regular_file))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</pre><p>The <code>regular_file</code> function
      transforms a <code>filename</code> string
      parameter into the same string but first checks that the file exists and
      is a regular file type. When you build and run this code, you will see
      the new error messages if you try to open a special device such as
      <code>/dev/null</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_md5_with_custom_arg.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>./basic_md5_with_custom_arg.native /etc/passwd</code></strong>
<code class="computeroutput">8cfb68a5622dd12932df658a54698aad</code>
<code class="prompt">$ </code><strong><code>./basic_md5_with_custom_arg.native /dev/null</code></strong>
<code class="computeroutput">'/dev/null' is not a regular file.</code></pre></section><section id="optional-and-default-arguments" data-type="sect2"><h2>Optional and Default Arguments</h2><p>A more realistic MD5 binary could also read from the standard
      input if a <code>filename</code> isn't
      specified:<a data-type="indexterm" data-primary="arguments" data-secondary="default arguments"/><a data-type="indexterm" data-primary="default arguments"/><a data-type="indexterm" data-primary="optional arguments" data-secondary="and default arguments"/><a data-type="indexterm" data-primary="arguments" data-secondary="optional arguments"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_optional_file_broken.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (maybe ("filename" %: string)))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</pre><p>This just wraps the <code>filename</code>
      argument declaration in the <code>maybe</code>
      function to mark it as an optional argument. However, building this
      results in a compile-time error:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_basic_md5_with_optional_file_broken.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>corebuild -pkg cryptokit basic_md5_with_optional_file_broken.native</code></strong>
<code class="computeroutput">File "basic_md5_with_optional_file_broken.ml", line 18, characters 4-11:</code>
<code class="computeroutput">Error: This expression has type string -&gt; unit -&gt; unit</code>
<code class="computeroutput">       but an expression was expected of type string option -&gt; unit -&gt; unit</code>
<code class="computeroutput">       Type string is not compatible with type string option </code>
<code class="computeroutput">Command exited with code 2.</code></pre><p>This is because changing the argument type has also changed the
      type of the callback function. It now wants a <code>string option</code> instead of a <code>string</code>, since the value has become optional.
      We can adapt our example to use the new information and read from
      standard input if no file is specified:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_optional_file.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let get_inchan = function
  | None | Some "-" -&gt;
    In_channel.stdin
  | Some filename -&gt;
    In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (maybe ("filename" %: file)))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</pre><p>The <code>filename</code> parameter to
      <code>do_hash</code> is now a <code>string option</code> type. This is resolved into an
      input channel via <code>get_inchan</code> to
      determine whether to open the standard input or a file, and then the
      rest of the command is similar to our previous examples.</p><p>Another possible way to handle this would be to supply a dash as
      the default filename if one isn't specified. The <code>maybe_with_default</code> function can do just this,
      with the benefit of not having to change the callback parameter type
      (which may be a problem in more complex applications).</p><p>The following example behaves exactly the same as the previous
      example, but replaces <code>maybe</code> with
      <code>maybe_with_default</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_default_file.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let get_inchan = function
  | "-"      -&gt; In_channel.stdin
  | filename -&gt; In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(
      empty
      +&gt; anon (maybe_with_default "-" ("filename" %: file))
    )
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</pre><p>Building and running both against a system file confirms that they
      have the same behavior:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_and_default_md5.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>cat /etc/passwd | ./basic_md5_with_optional_file.native</code></strong>
<code class="computeroutput">8cfb68a5622dd12932df658a54698aad</code>
<code class="prompt">$ </code><strong><code>cat /etc/passwd | ./basic_md5_with_default_file.native</code></strong>
<code class="computeroutput">8cfb68a5622dd12932df658a54698aad</code></pre></section><section id="sequences-of-arguments" data-type="sect2"><h2>Sequences of Arguments</h2><p>One last transformation that's useful is to obtain lists of
      anonymous arguments rather than a single one. As an example, let's
      modify our MD5 code to take a collection of files to process on the
      command line:<a data-type="indexterm" data-primary="arguments" data-secondary="sequences of"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_sequence.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let do_hash filename ic =
  let open Cryptokit in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; fun md5 -&gt; printf "MD5 (%s) = %s\n" filename md5

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (sequence ("filename" %: file)))
    (fun files () -&gt;
       match files with
       | [] -&gt; do_hash "-" In_channel.stdin
       | _  -&gt;
         List.iter files ~f:(fun file -&gt;
           In_channel.with_file ~f:(do_hash file) file
         )
    )

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</pre><p>The callback function is a little more complex now, to handle the
      extra options. The <code>files</code> are now a
      <code>string list</code>, and an empty list
      reverts to using standard input, just as our previous <code>maybe</code> and <code>maybe_with_default</code> examples did. If the list
      of files isn't empty, then it opens up each file and runs them through
      <code>do_hash</code> sequentially.</p></section></section><section id="adding-labeled-flags-to-the-command-line" data-type="sect1"><h1>Adding Labeled Flags to the Command Line</h1><p>You aren't just limited to anonymous arguments on the command line.
    A <em>flag</em> is a named field that can be followed by an
    optional argument. These flags can appear in any order on the command
    line, or multiple times, depending on how they're declared in the
    specification.<a data-type="indexterm" data-primary="flags"/><a data-type="indexterm" data-primary="command-line parsing" data-secondary="labeled flags and"/></p><p>Let's add two arguments to our <code>md5</code> command that mimics the Mac OS X version. A
    <code>-s</code> flag specifies
    the string to be hashed directly on the command line and <code>-t</code> runs a self-test. The complete example
    follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_flags.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std
open Cryptokit

let checksum_from_string buf =
  hash_string (Hash.md5 ()) buf
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let checksum_from_file filename =
  let ic = match filename with
    | "-" -&gt; In_channel.stdin
    | _   -&gt; In_channel.create ~binary:true filename
  in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    Command.Spec.(
      empty
      +&gt; flag "-s" (optional string) ~doc:"string Checksum the given string"
      +&gt; flag "-t" no_arg ~doc:" run a built-in time trial"
      +&gt; anon (maybe_with_default "-" ("filename" %: file))
    )
    (fun use_string trial filename () -&gt;
       match trial with
       | true -&gt; printf "Running time trial\n"
       | false -&gt; begin
           match use_string with
           | Some buf -&gt; checksum_from_string buf
           | None -&gt; checksum_from_file filename
         end
    )

let () = Command.run command</pre><p>The specification now uses the <code>flag</code> function to define the two new labeled,
    command-line arguments. The <code>doc</code> string
    is formatted so that the first word is the short name that appears in the
    usage text, with the remainder being the full help text. Notice that the
    <code>-t</code> flag has no
    argument, and so we prepend its <code>doc</code>
    text with a blank space. The help text for the preceding code looks like
    this:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_md5_flags_help.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>./basic_md5_with_flags.native -help</code></strong>
<code class="computeroutput">Generate an MD5 hash of the input data</code>
<code class="computeroutput"> </code>
<code class="computeroutput">  basic_md5_with_flags.native [FILENAME]</code>
<code class="computeroutput"> </code>
<code class="computeroutput">=== flags ===</code>
<code class="computeroutput"> </code>
<code class="computeroutput">  [-s string]    Checksum the given string</code>
<code class="computeroutput">  [-t]           run a built-in time trial</code>
<code class="computeroutput">  [-build-info]  print info about this build and exit</code>
<code class="computeroutput">  [-version]     print the version of this build and exit</code>
<code class="computeroutput">  [-help]        print this help text and exit</code>
<code class="computeroutput">                 (alias: -?)</code>
<code class="computeroutput"> </code>
<code class="prompt">$ </code><strong><code>./basic_md5_with_flags.native -s "ocaml rocks"</code></strong>
<code class="computeroutput">5a118fe92ac3b6c7854c595ecf6419cb</code></pre><p>The <code>-s</code> flag in our specification
    requires a <code>string</code> argument and isn't
    optional. The Command parser outputs an error message if the flag isn't
    supplied, as with the anonymous arguments in earlier examples. <a href="#table14-2" data-type="xref"/> contains a list of some of the functions that you
    can wrap flags in to control how they are parsed.<a data-type="indexterm" data-primary="flag functions"/></p><table id="table14-2"><caption>Flag functions</caption><thead><tr><th>Flag function</th><th>OCaml type</th></tr></thead><tbody><tr><td><code>required</code>
            <em>arg</em></td><td><em>arg</em> and error if not present</td></tr><tr><td><code>optional</code>
            <em>arg</em></td><td><em>arg</em> <code>option</code></td></tr><tr><td><code>optional_with_default</code>
            <em>val</em> <em>arg</em></td><td><em>arg</em> with default
            <em>val</em> if not present</td></tr><tr><td><code>listed</code>
            <em>arg</em></td><td><em>arg</em> <code>list</code>, flag may appear multiple
            times</td></tr><tr><td><code>no_arg</code></td><td><code>bool</code> that is true if
            flag is present</td></tr></tbody></table><p>The flags affect the type of the callback function in exactly the
    same way as anonymous arguments do. This lets you change the specification
    and ensure that all the callback functions are updated appropriately,
    without runtime errors.</p></section><section id="grouping-sub-commands-together" data-type="sect1"><h1>Grouping Subcommands Together</h1><p>You can get pretty far by using flags and anonymous arguments to
    assemble complex, command-line interfaces. After a while, though, too many
    options can make the program very confusing for newcomers to your
    application. One way to solve this is by grouping common operations
    together and adding some hierarchy to the command-line
    interface.<a data-type="indexterm" data-primary="subcommands, grouping of"/><a data-type="indexterm" data-primary="OPAM package manager"/><a data-type="indexterm" data-primary="command-line parsing" data-secondary="subcommand grouping"/></p><p>You'll have run across this style already when using the OPAM
    package manager (or, in the non-OCaml world, the Git or Mercurial
    commands). OPAM exposes commands in this form:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/opam.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>opam config env</code></strong>
<code class="prompt">$ </code><strong><code>opam remote list -k git</code></strong>
<code class="prompt">$ </code><strong><code>opam install --help</code></strong>
<code class="prompt">$ </code><strong><code>opam install cryptokit --verbose</code></strong></pre><p>The <code>config</code>, <code>remote</code>, and <code>install</code> keywords form a logical grouping of
    commands that factor out a set of flags and arguments. This lets you
    prevent flags that are specific to a particular subcommand from leaking
    into the general configuration space.<a data-type="indexterm" data-primary="install keyword"/><a data-type="indexterm" data-primary="remote keyword"/></p><p>This usually only becomes a concern when your application
    organically grows features. Luckily, it's simple to extend your
    application to do this in Command: just swap the <code>Command.basic</code> for <code>Command.group</code>, which takes an association list
    of specifications and handles the subcommand parsing and help output for
    you:<a data-type="indexterm" data-primary="Command.group"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/group.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>Command.basic ;;</code></strong>
<code class="computeroutput">- : summary:string -&gt;</code>
<code class="computeroutput">    ?readme:(unit -&gt; string) -&gt;</code>
<code class="computeroutput">    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t</code>
<code class="computeroutput">= &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>Command.group ;;</code></strong>
<code class="computeroutput">- : summary:string -&gt;</code>
<code class="computeroutput">    ?readme:(unit -&gt; string) -&gt; (string * Command.t) list -&gt; Command.t</code>
<code class="computeroutput">= &lt;fun&gt;</code></pre><p>The <code>group</code> signature accepts a
    list of basic <code>Command.t</code> values and
    their corresponding names. When executed, it looks for the appropriate
    subcommand from the name list, and dispatches it to the right command
    handler.</p><p>Let's build the outline of a calendar tool that does a few
    operations over dates from the command line. We first need to define a
    command that adds days to an input date and prints the resulting
    date:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_days.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add</pre><p>Everything in this command should be familiar to you by now. Once
    you've tested it and made sure it works, we can define another new command
    that takes the difference of two dates. However, instead of creating a new
    binary, we group both operations as subcommands using <code>Command.group</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_sub_days.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let add =
  Command.basic ~summary:"Add [days] to the [base] date"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff =
  Command.basic ~summary:"Show days between [date1] and [date2]"
    Command.Spec.(
      empty
      +&gt; anon ("date1" %: date)
      +&gt; anon ("date2" %: date)
    )
    (fun date1 date2 () -&gt;
       Date.diff date1 date2
       |&gt; printf "%d days\n"
    )

let command =
  Command.group ~summary:"Manipulate dates"
    [ "add", add; "diff", diff ]

let () = Command.run command</pre><p>And that's all you really need to add subcommand support! Let's
    build the example first in the usual way and inspect the help output,
    which now reflects the subcommands we just added.</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_cal_add_sub_days.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>corebuild cal_add_sub_days.native</code></strong>
<code class="prompt">$ </code><strong><code>./cal_add_sub_days.native -help</code></strong>
<code class="computeroutput">Manipulate dates</code>
<code class="computeroutput"> </code>
<code class="computeroutput">  cal_add_sub_days.native SUBCOMMAND</code>
<code class="computeroutput"> </code>
<code class="computeroutput">=== subcommands ===</code>
<code class="computeroutput"> </code>
<code class="computeroutput">  add      Add [days] to the [base] date</code>
<code class="computeroutput">  diff     Show days between [date1] and [date2]</code>
<code class="computeroutput">  version  print version information</code>
<code class="computeroutput">  help     explain a given subcommand (perhaps recursively)</code>
<code class="computeroutput"> </code></pre><p>We can invoke the two commands we just defined to verify that they
    work and see the date parsing in action:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_cal_add_sub_days.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>./cal_add_sub_days.native add 2012-12-25 40</code></strong>
<code class="computeroutput">2013-02-03</code>
<code class="prompt">$ </code><strong><code>./cal_add_sub_days.native diff 2012-12-25 2012-11-01</code></strong>
<code class="computeroutput">54 days</code></pre></section><section id="advanced-control-over-parsing" data-type="sect1"><h1>Advanced Control over Parsing</h1><p>The functions for generating a specification may seem like magic. In
    particular, even if you know how to use them, it's not entirely clear how
    they work, and in particular, why the types work out the way they
    do.<a data-type="indexterm" id="CLPadv" data-primary="command-line parsing" data-secondary="advanced control over"/></p><p>Understanding the details of how these specifications fit together
    becomes more useful as your command-line interfaces get more complex. In
    particular, you may want to factor out common functionality between
    specifications or interrupt the parsing to perform special processing,
    such as requesting an interactive passphrase from the user before
    proceeding. All of this is helped by a deeper understanding of the Command
    library.</p><p>In the following sections we'll explain the logic behind the
    combinators we've already described and show you some new combinators that
    let you use Command even more effectively.</p><section id="the-types-behind-command.spec" data-type="sect2"><h2>The Types Behind Command.Spec</h2><p>The Command module's safety relies on the specification's output
      values precisely matching the callback function which invokes the main
      program. In order to prevent any such mismatches, Command uses some
      interesting type machinery to guarantee they remain in sync. You don't
      have to understand this section to use the more advanced combinators,
      but it'll help you debug type errors as you use Command more.<a data-type="indexterm" data-primary="callback function"/><a data-type="indexterm" data-primary="debugging" data-secondary="Command mode"/><a data-type="indexterm" data-primary="Command module"/></p><p>The <code>Command.Spec.t</code> type looks
      deceptively simple: <code>('a, 'b) t</code>. You
      can think of <code>('a, 'b) t</code> here as a
      function of type <code>'a -&gt; 'b</code>, but
      embellished with information about:</p><ul><li><p>How to parse the command line</p></li><li><p>What the command does and how to call it</p></li><li><p>How to autocomplete a partial command line</p></li></ul><p>The type of a specification transforms a <code>'a</code> to a <code>'b</code>
      value. For instance, a value of <code>Spec.t</code> might have type <code>(arg1 -&gt; ... -&gt; argN -&gt; 'r, 'r)
      Spec.t</code>.</p><p>Such a value transforms a main function of type <code>arg1 -&gt; ... -&gt; argN -&gt; 'r</code> by
      supplying all the argument values, leaving a main function that returns
      a value of type <code>'r</code>. Let's look at
      some examples of specs, and their types:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/command_types.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>Command.Spec.empty ;;</code></strong>
<code class="computeroutput">- : ('m, 'm) Command.Spec.t = &lt;abstr&gt;</code>
<code class="prompt"># </code><strong><code>Command.Spec.(empty +&gt; anon ("foo" %: int)) ;;</code></strong>
<code class="computeroutput">- : (int -&gt; '_a, '_a) Command.Spec.t = &lt;abstr&gt;</code></pre><p>The empty specification is simple, as it doesn't add any
      parameters to the callback type. The second example adds an <code>int</code> anonymous parameter that is reflected in
      the inferred type. One forms a command by combining a spec of type
      <code>('main, unit) Spec.t</code> with a function
      of type <code>'main</code>. The combinators we've
      shown so far incrementally build the type of <code>'main</code> according to the command-line parameters
      it expects, so the resulting type of <code>'main</code> is something like <code>arg1 -&gt; ... -&gt; argN -&gt; unit</code>.</p><p>The type of <code>Command.basic</code>
      should make more sense now:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>Command.basic ;;</code></strong>
<code class="computeroutput">- : summary:string -&gt;</code>
<code class="computeroutput">    ?readme:(unit -&gt; string) -&gt;</code>
<code class="computeroutput">    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t</code>
<code class="computeroutput">= &lt;fun&gt;</code></pre><p>The parameters to <code>Spec.t</code> are important here. They
        show that the callback function for a spec should consume identical arguments to the
        supplied <code>main</code> function, except for an additional <code>unit</code> argument. This final <code>unit</code> is there to make sure the callback is evaluated as a function, since if
        zero command-line arguments are specified (i.e., <span class="keep-together"><code>Spec.empty</code></span>), the callback would otherwise have no
        arguments and be evaluated immediately. That's why you have to supply an additional <code>()</code> to the callback function in all the previous examples.</p></section><section id="composing-specification-fragments-together" data-type="sect2"><h2>Composing Specification Fragments Together</h2><p>If you want to factor out common command-line operations, the
      <code>++</code> operator will append two
      specifications together. Let's add some dummy verbosity and debug flags
      to our calendar application to illustrate this.</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_append.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let add ~common =
  Command.basic ~summary:"Add [days] to the [base] date"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
      ++ common
    )
    (fun base span debug verbose () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff ~common =
  Command.basic ~summary:"Show days between [date2] and [date1]"
    Command.Spec.(
      empty
      +&gt; anon ("date1" %: date)
      +&gt; anon ("date2" %: date)
      ++ common
    )
    (fun date1 date2 debug verbose () -&gt;
       Date.diff date1 date2
       |&gt; printf "%d days\n"
    )</pre><p>The definitions of the specifications are very similar to the
      earlier example, except that they append a <code>common</code> parameter after each specification. We
      can supply these flags when defining the groups.</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_append.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">let () =
  let common =
    Command.Spec.(
      empty
      +&gt; flag "-d" (optional_with_default false bool) ~doc:" Debug mode"
      +&gt; flag "-v" (optional_with_default false bool) ~doc:" Verbose output"
    )
  in
  List.map ~f:(fun (name, cmd) -&gt; (name, cmd ~common))
    [ "add", add; "diff", diff ]
  |&gt; Command.group ~summary:"Manipulate dates"
  |&gt; Command.run</pre><p>Both of these flags will now be applied and passed to all the
      callback functions. This makes code refactoring a breeze by using the
      compiler to spot places where you use commands. Just add a parameter to
      the common definition, run the compiler, and fix type errors until
      everything works again.<a data-type="indexterm" data-primary="refactoring"/></p><p>For example, if we remove the <code>verbose</code> flag and recompile, we'll get this
      impressively long type error:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_cal_append_broken.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>corebuild cal_append_broken.native</code></strong>
<code class="computeroutput">File "cal_append_broken.ml", line 38, characters 45-52:</code>
<code class="computeroutput">Error: This expression has type</code>
<code class="computeroutput">         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit -&gt; unit) Command.Spec.t</code>
<code class="computeroutput">       but an expression was expected of type</code>
<code class="computeroutput">         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit) Command.Spec.t</code>
<code class="computeroutput">       Type unit -&gt; unit is not compatible with type unit </code>
<code class="computeroutput">Command exited with code 2.</code></pre><p>While this does look scary, the key line to scan is the last one,
      where it's telling you that you have supplied too many arguments in the
      callback function (<code>unit -&gt; unit</code>
      versus <code>unit</code>). If you started with a
      working program and made this single change, you typically don't even
      need to read the type error, as the filename and location information is
      sufficient to make the obvious fix.</p></section><section id="prompting-for-interactive-input" data-type="sect2"><h2>Prompting for Interactive Input</h2><p>The <code>step</code> combinator lets you
      control the normal course of parsing by supplying a function that maps
      callback arguments to a new set of values. For instance, let's revisit
      our first calendar application that added a number of days onto a
      supplied base date:<a data-type="indexterm" data-primary="interactive input" data-secondary="prompts for"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_days.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add</pre><p>This program requires you to specify both the <code>base</code> date and the number of <code>days</code> to add onto it. If <code>days</code> isn't supplied on the command line, an
      error is output. Now let's modify it to interactively prompt for a
      number of days if only the <code>base</code> date
      is supplied:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_interactive.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let add_days base span () =
  Date.add_days base span
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.( 
      step 
        (fun m base days -&gt;
           match days with
           | Some days -&gt;
             m base days
           | None -&gt;
             print_endline "enter days: ";
             read_int ()
             |&gt; m base
        )
      +&gt; anon ("base" %: date)
      +&gt; anon (maybe ("days" %: int))
    )
    add_days

let () = Command.run add</pre><p>The <code>days</code> anonymous argument is
      now an optional integer in the spec, and we want to transform it into a
      nonoptional value before calling our <code>add_days</code> callback. The <code>step</code> combinator lets us perform this
      transformation by applying its supplied callback function first. In the
      example, the callback first checks if <code>days</code> is defined. If it's undefined, then it
      interactively reads an integer from the standard input.</p><p>The first <code>m</code> argument to the
      <code>step</code> callback is the next callback
      function in the chain. The transformation is completed by calling
      <code>m base days</code> to continue processing
      with the new values we've just calculated. The <code>days</code> value that is passed onto the next
      callback now has a nonoptional <code>int</code>
      type:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_and_run_cal_add_interactive.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>ocamlbuild -use-ocamlfind -tag thread -pkg core cal_add_interactive.native</code></strong>
<code class="prompt">$ </code><strong><code>./cal_add_interactive.native 2013-12-01</code></strong>
<code class="computeroutput">enter days:</code>
<code class="computeroutput">35</code>
<code class="computeroutput">2014-01-05</code></pre><p>The transformation means that the <code>add_days</code> callback can just keep its original
      definition of <code>Date.t -&gt; int -&gt;
      unit</code>. The <code>step</code> function
      transformed the <code>int option</code> argument
      from the parsing into an <code>int</code> suitable
      for <code>add_days</code>. This transformation is
      explicitly represented in the type of the <code>step</code> return value:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/step.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>open Command.Spec ;;</code></strong>
<code class="prompt"># </code><strong><code>step (fun m (base:Date.t) days -&gt;</code></strong>
<strong><code>  match days with</code></strong>
<strong><code>  | Some days -&gt; m base days</code></strong>
<strong><code>  | None -&gt;</code></strong>
<strong><code>     print_endline "enter days: ";</code></strong>
<strong><code>     m base (read_int ())) ;;</code></strong>
<code class="computeroutput">- : (Date.t -&gt; int -&gt; '_a, Date.t -&gt; int option -&gt; '_a) t = &lt;abstr&gt;</code></pre><p>The first half of the <code>Spec.t</code>
      shows that the callback type is <code>Date.t -&gt;
      int</code>, whereas the resulting value expected from the next
      specification in the chain is a <code>Date.t -&gt;
      int option</code>.</p></section><section id="adding-labeled-arguments-to-callbacks" data-type="sect2"><h2>Adding Labeled Arguments to Callbacks</h2><p>The <code>step</code> chaining lets you
      control the types of your callbacks very easily. This can help you match
      existing interfaces or make things more explicit by adding labeled
      arguments:<a data-type="indexterm" data-primary="callback function"/><a data-type="indexterm" data-primary="arguments" data-secondary="labeled arguments"/><a data-type="indexterm" data-primary="labeled arguments"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_labels.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let add_days ~base_date ~num_days () =
  Date.add_days base_date num_days
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.( 
      step (fun m base days -&gt; m ~base_date:base ~num_days:days)
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    add_days

let () = Command.run add</pre><p>This <code>cal_add_labels</code> example goes back to our
        noninteractive calendar addition program, but the <code>add_days</code> main function now expects labeled arguments. The <code>step</code>
        <span class="keep-together">function</span> in the specification simply converts the
        default <code>base</code> and <code>days</code>
        arguments into a labeled function.</p><p>Labeled arguments are more verbose but can also help prevent
      errors with command-line arguments with similar types but different
      names and purposes. It's good form to use labels when you have a lot of
      otherwise anonymous <code>int</code> and <code>string</code> arguments.<a data-type="indexterm" data-startref="CLPadv"/></p></section></section><section id="command-line-auto-completion-with-bash" data-type="sect1"><h1>Command-Line Autocompletion with bash</h1><p>Modern UNIX shells usually have a tab-completion feature to
    interactively help you figure out how to build a command line. These work
    by pressing the Tab key in the middle of typing a command, and seeing the
    options that pop up. You've probably used this most often to find the
    files in the current directory, but it can actually be extended for other
    parts of the command, too.<a data-type="indexterm" data-primary="tab-autocompletion"/><a data-type="indexterm" data-primary="autocompletion"/><a data-type="indexterm" data-primary="command-line parsing" data-secondary="autocompletion with bash"/></p><p>The precise mechanism for autocompletion varies depending on what
    shell you are using, but we'll assume you are using the most common one:
    <span class="command"><em>bash</em></span>. This is the default interactive
    shell on most Linux distributions and Mac OS X, but you may need to switch
    to it on *BSD or Windows (when using Cygwin). The rest of this section
    assumes that you're using <span class="command"><em>bash</em></span>.<a data-type="indexterm" data-primary="bash autocompletion"/></p><p>Bash autocompletion isn't always installed by default, so check your
    OS package manager to see if you have it available.</p><table><thead><tr><th>Operating system</th><th>Package manager</th><th>Package</th></tr></thead><tbody><tr><td>Debian Linux</td><td><code>apt</code></td><td><code>bash-completion</code></td></tr><tr><td>Mac OS X</td><td>Homebrew</td><td><code>bash-completion</code></td></tr><tr><td>FreeBSD</td><td>Ports system</td><td><em class="filename">/usr/ports/shells/bash-completion</em></td></tr></tbody></table><p>Once <em>bash</em> completion is installed and
    configured, check that it works by typing the <code>ssh</code> command and pressing the Tab key. This
    should show you the list of known hosts from your
    <em>~/.ssh/known_hosts</em> file. If it lists some hosts that
    you've recently connected to, you can continue on. If it lists the files
    in your current directory instead, then check your OS documentation to
    configure completion correctly.</p><p>One last bit of information you'll need to find is the location of
    the <em class="filename">bash_completion.d</em> directory. This
    is where all the shell fragments that contain the completion logic are
    held. On Linux, this is often in <em class="filename">/etc/bash_completion.d</em>, and in Homebrew on Mac
    OS X, it would be <em class="filename">/usr/local/etc/bash_completion.d</em> by
    default.</p><section id="generating-completion-fragments-from-command" data-type="sect2"><h2>Generating Completion Fragments from Command</h2><p>The Command library has a declarative description of all the
      possible valid options, and it can use this information to generate a
      shell script that provides completion support for that command. To
      generate the fragment, just run the command with the
      <code>COMMAND_OUTPUT_INSTALLATION_BASH</code> environment variable set
      to any value.</p><p>For example, let's try it on our MD5 example from earlier,
      assuming that the binary is called <span class="command"><em>basic_md5_with_flags</em></span> in the current
      directory:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/md5_completion.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./basic_md5_with_flags.native</code></strong>
<code class="computeroutput">function _jsautocom_23343 {</code>
<code class="computeroutput">  export COMP_CWORD</code>
<code class="computeroutput">  COMP_WORDS[0]=./basic_md5_with_flags.native</code>
<code class="computeroutput">  COMPREPLY=($("${COMP_WORDS[@]}"))</code>
<code class="computeroutput">}</code>
<code class="computeroutput">complete -F _jsautocom_23343 ./basic_md5_with_flags.native</code></pre><p>Recall that we used the <code>Arg_type.file</code> to specify the argument type.
      This also supplies the completion logic so that you can just press Tab
      to complete files in your current directory.</p></section><section id="installing-the-completion-fragment" data-type="sect2"><h2>Installing the Completion Fragment</h2><p>You don't need to worry about what the preceding output script
      actually does (unless you have an unhealthy fascination with shell
      scripting internals, that is). Instead, redirect the output to a file in
      your current directory and source it into your current shell:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_completion.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./cal_add_sub_days.native &gt; cal.cmd</code></strong>
<code class="prompt">$ </code><strong><code>. cal.cmd</code></strong>
<code class="prompt">$ </code><strong><code>./cal_add_sub_days.native &lt;tab&gt;</code></strong>
<code class="computeroutput">add      diff     help     version</code></pre><p>Command completion support works for flags and grouped commands
      and is very useful when building larger command-line interfaces. Don't
      forget to install the shell fragment into your global <em class="filename">bash_completion.d</em> directory if you want it to
      be loaded in all of your login shells.<a data-type="indexterm" data-primary="completion handlers"/></p><div data-type="note"><h1>Installing a Generic Completion Handler</h1><p>Sadly, <span class="command"><em>bash</em></span> doesn't support
        installing a generic handler for all Command-based applications. This
        means you have to install the completion script for every application,
        but you should be able to automate this in the build and packaging
        system for your application.</p><p>It will help to check out how other applications install
        tab-completion scripts and follow their lead, as the details are very
        OS-specific.</p></div></section></section><section id="alternative-command-line-parsers" data-type="sect1"><h1>Alternative Command-Line Parsers</h1><p>This rounds up our tour of the Command library. This isn't the only
    way to parse command-line arguments of course; there are several
    alternatives available on OPAM. Three of the most prominent ones
    follow:<a data-type="indexterm" data-primary="Cmdliner"/><a data-type="indexterm" data-primary="OCaml toolchain" data-secondary="ocaml-getopt"/><a data-type="indexterm" data-primary="Arg module"/><a data-type="indexterm" data-primary="command-line parsing" data-secondary="alternatives to Command library"/><a data-type="indexterm" data-primary="OPAM package manager"/></p><dl><dt>The <code>Arg</code> module</dt><dd><p>The<code> Arg</code> module is from the OCaml standard
          library, which is used by the compiler itself to handle its
          command-line interface. Command is generally more featureful than
          Arg (mainly via support for subcommands, the <code>step</code> combinator to transform inputs, and
          help generation), but there's absolutely nothing wrong with using
          Arg either.</p><p>You can use the <code>Command.Spec.flags_of_args_exn</code> function to
          convert Arg specifications into ones compatible with Command. This
          is quite often used to help port older non-Core code into the Core
          standard library world.</p></dd><dt><a href="https://forge.ocamlcore.org/projects/ocaml-getopt/">ocaml-getopt</a></dt><dd><p><code>ocaml-getopt</code> provides the general
          command-line syntax of GNU <code>getopt</code>
          and <code>getopt_long</code>. The GNU conventions are
          widely used in the open source world, and this library lets your
          OCaml programs obey the same rules.</p></dd><dt><a href="http://erratique.ch/software/cmdliner">Cmdliner</a></dt><dd><p>Cmdliner is a mix between the Command and Getopt libraries. It
          allows for the declarative definition of command-line interfaces but
          exposes a more <code>getopt</code>-like
          interface. It also automates the generation of UNIX man pages as
          part of the specification. Cmdliner is the parser used by OPAM to
          manage its command line.</p></dd></dl></section></section>