\labelchapter{patt1}{Basic pattern matching}

One of ML's more powerful features is the use of \emph{pattern
matching} to define computation by case analysis.  Pattern matching is
specified by a \hbox{\lstinline/match/} expression, which has the following
syntax.

\label{keyword:|}
\label{keyword:match}
\label{keyword:with}
\index{match@\lstinline/match/ (pattern matching)}
\begin{ocaml}
match $\nt{expression}$ with
 | $\nt{pattern}_1$ -> $\nt{expression}_1$
 | $\nt{pattern}_2$ -> $\nt{expression}_2$
 $\vdots$
 | $\nt{pattern}_n$ -> $\nt{expression}_n$
\end{ocaml}
%
The first vertical bar \hbox{\lstinline/|/} is optional.

When a \hbox{\lstinline/match/} expression is evaluated, the expression
\nt{expression} to be matched is first evaluated, and its value is
compared with the patterns in order.  If $\emph{pattern}_i$ is the
first pattern to match the value, then the expression
$\emph{expression}_i$ is evaluated and returned as the result of the
\hbox{\lstinline/match/}.

A simple \nt{pattern} is an expression made of constants and
variables.  A constant pattern $c$ matches values that are equal to
it, and a variable pattern $x$ matches any expression.  A variable
pattern $x$ is a binding occurrence; when the pattern match is
successful, the variable $x$ is bound the the value being matched.

For example, Fibonacci numbers can be defined succinctly using pattern
matching.  Fibonacci numbers are defined inductively:
\hbox{\lstinline/fib 0 = 0/},
\hbox{\lstinline/fib 1 = 1/},
and for all other natural numbers $i$,
\hbox{\lstinline/fib $i$ = fib ($i$ - 1) + fib ($i$ - 2)/}.

\begin{ocaml}
# let rec fib i =
     match i with
        0 -> 0
      | 1 -> 1
      | j -> fib (j - 2) + fib (j - 1);;
@
\begin{topoutput}
val fib : int -> int = <fun>
\end{topoutput}
@
# fib 1;;
@
\begin{topoutput}
- : int = 1
\end{topoutput}
@
# fib 2;;
@
\begin{topoutput}
- : int = 1
\end{topoutput}
@
# fib 3;;
@
\begin{topoutput}
- : int = 2
\end{topoutput}
@
# fib 6;;
@
\begin{topoutput}
- : int = 8
\end{topoutput}
@
\end{ocaml}
%
In this code, the argument $i$ is compared against the constants 0 and
1.  If either of these cases match, the return value is equal to $i$.  The final
pattern is the variable $j$, which matches any argument.  When this
pattern is reached, $j$ takes on the value of the argument, and the
body \hbox{\lstinline/fib (j - 2) + fib (j - 1)/} computes the returned value.

Note that variables occurring in a pattern are always binding
occurrences.  For example, the following code produces a result you
might not expect.  The first case matches all expressions, returning
the value matched.  The toploop issues a warning for the second and
third cases.

\begin{ocaml}
# let zero = 0;;
# let one = 1;;
# let rec fib i =
     match i with
        zero -> zero
      | one -> one
      | j -> fib (j - 2) + fib (j - 1);;
@
\begin{toperror}
Characters 57-60:
Warning: this match case is unused.
Characters 74-75:
Warning: this match case is unused.
      | one -> one
        ^^^
      | j -> fib (j - 2) + fib (j - 1);;
        ^
val fib : int -> int = <fun>
\end{toperror}
@
# fib 1;;
@
\begin{topoutput}
- : int = 1
\end{topoutput}
@
# fib 2002;;
@
\begin{topoutput}
- : int = 2002
\end{topoutput}
@
\end{ocaml}

\labelsection{function}{Functions with matching}
\label{keyword:function}

It is quite common for the body of an ML function to be a \hbox{\lstinline/match/}
expression.  To simplify the syntax somewhat, OCaml allows the use of the
keyword \hbox{\lstinline/function/} (instead of \hbox{\lstinline/fun/}) to specify a function
that is defined by pattern matching.  A \hbox{\lstinline/function/} definition is
like a \hbox{\lstinline/fun/}, where a single argument is used in a pattern match.
The \hbox{\lstinline/fib/} definition using \hbox{\lstinline/function/} is as follows.

\begin{ocaml}
# let rec fib = function
     0 -> 0
   | 1 -> 1
   | i -> fib (i - 1) + fib (i - 2);;
@
\begin{topoutput}
val fib : int -> int = <fun>
\end{topoutput}
@
# fib 1;;
@
\begin{topoutput}
- : int = 1
\end{topoutput}
@
# fib 6;;
@
\begin{topoutput}
- : int = 8
\end{topoutput}
@
\end{ocaml}

\labelsection{patt1-expressions}{Pattern expressions}
\index{patterns!disjunction}
\label{patterns:choice}

Larger patterns can be constructed in several different ways.  The
vertical bar \hbox{\lstinline/|/} can be used to define a \emph{choice} pattern
\hbox{\lstinline/$\nt{pattern}_1$ | $\nt{pattern}_2$/} that matches many
value matching $\nt{pattern}_1$ or $\nt{pattern}_2$.  For
example, we can write the Fibonacci function somewhat more succinctly
by combining the first two cases.

\begin{ocaml}
let rec fib i =
   match i with
      (0 | 1) -> i
    | i -> fib (i - 1) + fib (i - 2);;
@
\begin{topoutput}
val fib : int -> int = <fun>
\end{topoutput}
@
\end{ocaml}
%
\label{keyword:as(patterns)}
\index{as!in patterns}
\index{patterns!as@\lstinline/as/}
The pattern
%
\hbox{\lstinline/$\nt{pattern}$ as $\nt{identifier}$/} matches that same
values as the pattern $\nt{pattern}$ and also binds the matched value
to the identifier.  For example, we can use this to shorten the
Fibonacci definition further.

\begin{ocaml}
let rec fib = function
   (0 | 1) as i -> i
 | i -> fib (i - 1) + fib (i - 2);;
@
\begin{topoutput}
val fib : int -> int = <fun>
\end{topoutput}
@
\end{ocaml}
%
The keyword \hbox{\lstinline/as/} has very low precedence; the patterns
\hbox{\lstinline/(0 | 1) as i/} and \hbox{\lstinline/0 | 1 as i/} are the same.

\label{keyword:when}
\index{patterns!when@\lstinline/when/ (pattern condition)}
Patterns can also be qualified by a predicate with the form
%
\hbox{\hbox{\lstinline/$\nt{pattern}$ when $\nt{expression}$/}}.  This matches the
same values as the pattern $\nt{pattern}$, but only when the predicate
$\nt{expression}$ evaluates to \hbox{\lstinline/true/}.  The expression is
evaluated within the context of the pattern; all variables in the
pattern are bound to their matched values.  Continuing with our
Fibonacci example, we get yet another version.

\begin{ocaml}
let rec fib = function
   i when i < 2 -> i
 | i -> fib (i - 1) + fib (i - 2);;
@
\begin{topoutput}
val fib : int -> int = <fun>
\end{topoutput}
@
\end{ocaml}

\labelsection{patt1-other-types}{Values of other types}

Patterns can also be used with values having the other basic types,
like characters, strings, and Boolean values.  In addition, multiple
patterns can be used for a single body.  For example, one way to check
for capital letters is with the following function definition.

\begin{ocaml}
# let is_uppercase = function
   'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H'
 | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P'
 | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X'
 | 'Y' | 'Z' ->
    true
 | c ->
    false;;
@
\begin{topoutput}
val is_uppercase : char -> bool = <fun>
\end{topoutput}
@
# is_uppercase 'M';;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# is_uppercase 'm';;
@
\begin{topoutput}
- : bool = false
\end{topoutput}
@
\end{ocaml}
%
It is rather tedious to specify the letters one at a time.
OCaml also allows pattern ranges $c_1 .. c_2$,
where $c_1$ and $c_2$ are character constants.

\begin{ocaml}
# let is_uppercase = function
     'A' .. 'Z' -> true
   | c -> false;;
@
\begin{topoutput}
val is_uppercase : char -> bool = <fun>
\end{topoutput}
@
# is_uppercase 'M';;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# is_uppercase 'm';;
@
\begin{topoutput}
- : bool = false
\end{topoutput}
@
\end{ocaml}
%
\label{patterns:wildcard}
Note that the pattern variable $c$ in these functions acts as a
``wildcard'' pattern to handle all non-uppercase characters.  The
variable itself is not used in the body \hbox{\lstinline/false/}.  This is another
commonly occurring structure, and OCaml provides a special pattern for
cases like these.  The \hbox{\lstinline/_/} pattern (a single underscore character)
is a wildcard pattern that matches anything.  It is not a variable, so
it can't be used in an expression.  The \hbox{\lstinline/is_uppercase/} function
would normally be written this way.

\label{keyword:_}
\begin{ocaml}
# let is_uppercase = function
     'A' .. 'Z' -> true
   | _ -> false;;
@
\begin{topoutput}
val is_uppercase : char -> bool = <fun>
\end{topoutput}
@
# is_uppercase 'M';;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# is_uppercase 'm';;
@
\begin{topoutput}
- : bool = false
\end{topoutput}
@
\end{ocaml}
%
The values being matched are not restricted to the basic scalar types
like integers and characters.  String matching is also supported,
using the usual syntax.

\begin{ocaml}
# let names = function
     "first" -> "George"
   | "last" -> "Washington"
   | _ -> ""
@
\begin{topoutput}
val names : string -> string = <fun>
\end{topoutput}
@
# names "first";;
@
\begin{topoutput}
- : string = "George"
\end{topoutput}
@
# names "Last";;
@
\begin{topoutput}
- : string = ""
\end{topoutput}
@
\end{ocaml}
%
Matching against floating-point values is supported, but it is rarely
used because of numerical issues.  The following example illustrates
the problem.

\begin{ocaml}
# match 4.3 -. 1.2 with
     3.1 -> true
   | _ -> false;;
@
\begin{topoutput}
- : bool = false
\end{topoutput}
@
\end{ocaml}

\labelsection{patt1-incomplete-match}{Incomplete matches}

You might wonder about what happens if the match expression does not
include patterns for all the possible cases.  For example, what
happens if we leave off the default case in the \hbox{\lstinline/is_uppercase/}
function?

\begin{ocaml}
# let is_uppercase = function
     'A' .. 'Z' -> true;;
@
\begin{toperror}
Characters 19-49:
Warning: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
'a'
val is_uppercase : char -> bool = <fun>
\end{toperror}
@
\end{ocaml}
%
The OCaml compiler and toploop are verbose about inexhaustive
patterns.  They warn when the pattern match is inexhaustive, and even
suggest a case that is not matched.  An inexhaustive set of patterns
is usually an error---what would happen if we applied the
\hbox{\lstinline/is_uppercase/} function to a non-uppercase character?

\begin{ocaml}
# is_uppercase 'M';;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# is_uppercase 'm';;
@
\begin{toperror}
Uncaught exception: Match_failure("", 19, 49)
\end{toperror}
@
\end{ocaml}
%
Again, OCaml is fairly strict.  In the case where the pattern does not
match, it raises an \emph{exception} (we'll see more about exceptions
in Chapter~\refchapter{exceptions}).  In this case, the exception
means that an error occurred during evaluation (a pattern matching
failure).

A word to the wise: \emph{heed the compiler warnings!}  The compiler
generates warnings for possible program errors.  As you build and
modify a program, these warnings will help you find places in the
program text that need work.  In some cases, you may be tempted to
ignore the compiler.  For example, in the following function, we know
that a complete match is not needed because \hbox{\lstinline/i mod 2/}
is always \hbox{\lstinline/0/} or \hbox{\lstinline/1/}---it can't be 2
as the compiler suggests.

\begin{ocaml}
# let is_odd i =
     match i mod 2 with
        0 -> false
      | 1 -> true;;
@
\begin{toperror}
Characters 18-69:
Warning: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
2
val is_odd : int -> bool = <fun>
\end{toperror}
@
# is_odd 3;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# is_odd 12;;
@
\begin{topoutput}
- : bool = false
\end{topoutput}
@
\end{ocaml}
%
However, \emph{do not} ignore the warning!  If you do, you will find
that you begin to ignore \emph{all} the compiler warnings---both real
and bogus.  Eventually, you will overlook real problems, and your
program will become hard to maintain.  For now, you should add a
wildcard case that raises an exception.  The
\hbox{\lstinline/Invalid_argument/} exception is designed for this purpose.  It
takes a string argument that is usually used to identify the name of
the place where the failure occurred.  You can generate an exception
with the \emph{raise} construction.

\begin{ocaml}
# let is_odd i =
     match i mod 2 with
        0 -> false
      | 1 -> true
      | _ -> raise (Invalid_argument "is_odd");;
@
\begin{topoutput}
val is_odd : int -> bool = <fun>
\end{topoutput}
@
# is_odd 3;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# is_odd (-1);;
@
\begin{toperror}
Uncaught exception: Invalid_argument("is_odd")
\end{toperror}
@
\end{ocaml}

\labelsection{patt1-everywhere}{Patterns are everywhere}

It may not be obvious at this point, but patterns are used in
\emph{all} the binding mechanisms, including the \hbox{\lstinline/let/} and \hbox{\lstinline/fun/}
constructions.  The general forms are as follows.

\begin{ocaml}
let $\nt{pattern}$ = $\nt{expression}$
let $\nt{identifier}$ $\nt{pattern}$ $\ldots$ $\nt{pattern}$ = $\nt{expression}$
fun $\nt{pattern}$ -> $\nt{expression}$
\end{ocaml}
%
These forms aren't much use with constants because the pattern match will
always be inexhaustive (except for the \hbox{\lstinline/()/} pattern).  However,
they will be handy when we introduce tuples and records in the next
chapter.

\begin{ocaml}
# let is_one = fun 1 -> true;;
@
\begin{toperror}
Characters 13-26:
Warning: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
0
val is_one : int -> bool = <fun>
\end{toperror}
@
# let is_one 1 = true;;
@
\begin{toperror}
Characters 11-19:
Warning: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
0
val is_one : int -> bool = <fun>
\end{toperror}
@
# is_one 1;;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
# is_one 2;;
@
\begin{toperror}
Uncaught exception: Match_failure("", 11, 19)
\end{toperror}
@
# let is_unit () = true;;
@
\begin{topoutput}
val is_unit : unit -> bool = <fun>
\end{topoutput}
@
# is_unit ();;
@
\begin{topoutput}
- : bool = true
\end{topoutput}
@
\end{ocaml}
