%
%
%
\exercises

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Exercise
%
\begin{exercise}{exn1}
Which of the following are legal expressions?

\begin{enumerate}
\item \lstinline+exception A+
\item \lstinline+exception b+
\item \lstinline+exception C of string+
\item \lstinline+exception D of exn+
\item \lstinline+exception E of exn let x = E (E (E Not_found))+
\item \lstinline+let f () = exception F raise F+
\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item \lstinline+exception A+ is legal.
\item \lstinline+exception b+ is not legal because the name \lstinline+b+ must be capitalized.
\item \lstinline+exception C of string+ is legal.
\item \lstinline+exception D of exn+ is legal, it adds a recursive definition.
\item \lstinline+exception E of exn let x = E (E (E Not_found))+ is also legal, the value \lstinline+x+ has type \lstinline+exn+.
\item \lstinline+let f () = exception F raise F+ is not legal, exceptions can only be declared at the top-level, not
within function bodies.
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Exercise
%
\begin{exercise}{exn2}
What is the result of evaluating the following programs?

\begin{enumerate}
\item

\begin{ocamllisting}
exception A
try raise A with
   A -> 1
\end{ocamllisting}

\item

\begin{ocamllisting}
exception A of int
let f i =
   raise (A (100 / i));;
let g i =
   try f i with
      A j -> j;;
g 100
\end{ocamllisting}

\item

\begin{ocamllisting}
exception A of int
let rec f i =
   if i = 0 then
      raise (A i)
   else
      g (i - 1)
and g i =
   try f i with
      A i -> i + 1;;
g 2
\end{ocamllisting}
\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item 1

\item

When \lstinline+g+ is called, \lstinline+f+ is called with the argument \lstinline+100+, raising the
exception \lstinline+A 1+, passing control back to \lstinline+g+ which returns \lstinline+1+.

\item

The expression \lstinline+g i+ returns 1 for any value $\texttt{i} \ge 0$.  The function \lstinline+f+ always
raises the exception \lstinline+A 0+, which passes control to the \emph{innermost} exception handler for
\lstinline+g+, which then returns 1.  As the call stack unwinds, the return value \lstinline+1+ is passed unchanged.

\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Exercise
%
\begin{exercise}{exn3}
In the following program, the function \lstinline+sum_entries+ sums up the integer values associated with
each name in the list \lstinline+names+.  The \lstinline+List.assoc+ function finds the value associated with
the name, raising the \lstinline+Not_found+ exception if the entry is not found.  For example, the
expression \lstinline+sum_entries 0 ["a"; "c"]+ would evaluate to \lstinline+35+, and the expression
\lstinline+sum_entries 0 ["a"; "d"]+ would raise the \lstinline+Not_found+ exception.

\begin{center}
\begin{ocaml}
let table = [("a", 10); ("b", 20); ("c", 25)]
let rec sum_entries total (names : string list) =
   match names with
      name :: names' ->
         sum_entries (total + List.assoc name table) names'
    | [] ->
         total
\end{ocaml}
\end{center}
%
Suppose we wish to catch the exception, arbitrarily assigning a value of 0 to each unknown entry.
What is the difference between the following two functions?  Which form is preferable?

\begin{enumerate}
\item 
\begin{center}
\begin{ocaml}
let table = [("a", 10); ("b", 20); ("c", 25)]
let rec sum_entries total (names : string list) =
   match names with
      name :: names' ->
         (try sum_entries (total + List.assoc name table) names' with
             Not_found ->
                sum_entries total names')
    | [] ->
         total
\end{ocaml}
\end{center}

\item
\begin{center}
\begin{ocaml}
let table = [("a", 10); ("b", 20); ("c", 25)]
let rec sum_entries total (names : string list) =
   match names with
      name :: names' ->
         let i =
            try List.assoc name table with
               Not_found  ->
                  1
         in
            sum_entries (total + i) names'
    | [] ->
         total
\end{ocaml}
\end{center}
\end{enumerate}

\begin{answer}\ifanswers
The second form is preferable.  The first version is not tail-recursive, and the depth of the
exception stack is linear in the number of entries in the \lstinline+names+ list.  The second version
does not have these problems; it is properly tail-recursive.
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Exercise
%
\begin{exercise}{exn4}
Suppose we are given a \lstinline+table+ as in the last exercise, and we wish to call some function
\lstinline+f+ on one of the entries, or returning 0 if the entry is not found.  That is, we are given the
function \lstinline+f+, and a name, and we wish to evaluate \lstinline+f (List.assoc table name)+.  What is
the difference between the following functions?

\begin{enumerate}
\item 
\begin{center}
\begin{ocaml}
let callf f name =
   try f (List.assoc table name) with
      Not_found ->
         0
\end{ocaml}
\end{center}

\item
\begin{center}
\begin{ocaml}
let callf f name =
   let i =
      try Some (List.assoc table name) with
         Not_found ->
            None
   in
      match i with
         Some j -> f j
       | None -> 0
\end{ocaml}
\end{center}
\end{enumerate}

\begin{answer}\ifanswers
In the first version, the function \lstinline+f+ is called within the exception handler, which means that
if \lstinline+f+ raises the \lstinline+Not_found+ exception, then \lstinline+callf+ will return 0, the same as if
the \lstinline+List.assoc+ function raises \lstinline+Not_found+.

The second version separates the calls.  If the function \lstinline+f+ raises \lstinline+Not_found+, the
exception will be propagated through the calls to \lstinline+callf+.  The second form is preferable in
situations where exceptions raised from \lstinline+f+ indicate an error, not normal operation.
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Exercise
%
\begin{exercise}{exn5}
The expression \lstinline+input_line stdin+ reads a line of text from standard input, returning the line
as a string, or raising the exception \lstinline+End_of_file+ if the end of the file has been reached.
Write a function \lstinline+input_lines+ to read all the lines from the channel \lstinline+stdin+, returning a
list of all the lines.  The order of the lines in the list does not matter.

\begin{answer}\ifanswers
The main problem with writing the \lstinline+input_lines+ function is in catching the \lstinline+End_of_file+ exception.
The following program is inefficient, because the exception stack is linear in the length of the input file.
For large files, the stack will likely overflow.

\begin{center}
\begin{ocaml}
let rec input_lines stdin =
    try input_line stdin :: input_lines stdin with
       End_of_file ->
          []
\end{ocaml}
\end{center}
%
The way to code this efficiently is to wrap the \lstinline+input_line+ function to catch the exception.

\begin{center}
\begin{ocaml}
let maybe_input_line stdin =
   try Some (input_line stdin) with
      End_of_file ->
         None

let input_lines stdin =
   let rec input lines =
      match maybe_input_line stdin with
         Some line -> input (line :: lines)
       | None -> List.rev lines
   in
      input []
\end{ocaml}
\end{center}
\fi\end{answer}
\end{exercise}

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
% vim:tw=100:fo=tcq:
