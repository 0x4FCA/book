\exercises

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Names
%
\begin{exercise}{person-name}
Assume there is a class \hbox{\lstinline/name/} that represents the
name of a person.  We would normally say that a \hbox{\lstinline/person/} is-a \hbox{\lstinline/human/} and has-a \hbox{\lstinline/name/},

\begin{ocaml}
class person (n : name) = object inherit human val name = n $\cdots$ end
\end{ocaml}
%
Suppose that instead, the class \hbox{\lstinline/person/} inherits from both.

\begin{ocaml}
class person (s : string) =
object
   inherit human
   inherit name s
   $\cdots$
end
\end{ocaml}
%
What is the difference?  Under what conditions would the different
representations be preferred?

\begin{answer}\ifanswers
In the former case, a person is not a name, and can't be used as a
name.  With multiple inheritance, the person \emph{can} be used as a
name.  Multiple inheritance is more likely to be used in a situation
where the name of a person and the person himself are treated as the
same thing.  The former is more likely when the name is just a symbol
for the person.
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Reference counting
%
\begin{exercise}{reference-counting}
Consider the following class, which implements a persistent
reference-counted value stored in a file.  When there are no more
references, the file is removed.

\begin{ocaml}
class persistent_refcounted_value filename =
object (self)
    (* persistent_value *)
    val mutable x : int list =
       let fin = open_in_bin filename in
       let x = input_value fin in
       close_in fin;
       x
    method get = x
    method set y = x <- y; self#save
    method private save =
       let fout = open_out_bin filename in
       output_value fout x;
       close_out fout

    (* refcounted_value *)
    val mutable ref_count = 1
    method add_ref = ref_count <- ref_count + 1
    method rm_ref =
       ref_count <- ref_count - 1;
       if ref_count = 0 then
          Sys.remove filename
end
\end{ocaml}
%
\begin{enumerate}
\item Partition the class into three classes: \hbox{\lstinline/persistent_value/} implements
persistent values stored in files, \hbox{\lstinline/refcounted_value/} implements generic reference
counted objects, and \hbox{\lstinline/persistent_refcounted_value/} inherits from both.

\item What is the advantage in partitioning the class?
\end{enumerate}

\begin{answer}\ifanswers
\begin{enumerate}
\item
The class is simply split down the middle.  The details of deletion must be implemented by
the value, not the reference counting class, so the virtual method \hbox{\lstinline/delete/} is
used to connect the two objects.

\begin{ocaml}
class persistent_value filename =
object (self)
    val mutable x : int list =
       let fin = open_in_bin filename in
       let x = input_value fin in
       close_in fin;
       x
    method get = x
    method set y = x <- y; self#save
    method private save =
       let fout = open_out_bin filename in
       output_value fout x;
       close_out fout
    method private delete = Sys.remove filename
end

class virtual ref_value =
object (self)
    val mutable ref_count = 1
    method add_ref = ref_count <- ref_count + 1
    method rm_ref =
       ref_count <- ref_count - 1;
       if ref_count = 0 then self#delete
    method private virtual delete : unit
end

class persistent_ref_value2 filename =
object
   inherit persistent_value filename
   inherit ref_value
end
\end{ocaml}

\item The advantage of splitting the class is that we now have two more generic classes.
For example, reference counting is general concept that can be re-used elsewhere in the program.
\end{enumerate}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programmer
%
\begin{exercise}{french-programmer}
In the French programmer example, the \hbox{\lstinline/programmer/} has a
field \hbox{\lstinline/favorite_language/} and so does
the \hbox{\lstinline/french_person/}.  Can the inheritance hierarchy be
modified so that these are available
as \hbox{\lstinline/favorite_programming_language/}
and \hbox{\lstinline/favorite_natural_language/}, without
modifying the classes \hbox{\lstinline/programmer/} and \hbox{\lstinline/french_person/}?

\begin{answer}\ifanswers
OCaml doesn't provide a way to rename fields, so the only thing we can
do is to hide the field and use methods to access it.  Suppose the
class \hbox{\lstinline/programmer/} is defined as follows.

\begin{ocaml}
class programmer =
object
   inherit person
   val favorite_language = "OCaml"
end
\end{ocaml}
%
The renamed class \hbox{\lstinline/programmer'/} could be defined as follows.

\begin{ocaml}
class type programmer_type' =
object
   val name : string
   val address : string
   method favorite_programming_language : string
end

class programmer' : programmer_type' =
object
   inherit programmer
   method favorite_programming_language = favorite_language
end
\end{ocaml}
\fi\end{answer}
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lists
%
\begin{exercise}{multiple-list}
You are given the following functor that defines a class \hbox{\lstinline/cell/}
containing a value of type \hbox{\lstinline/T.t/}.

\begin{ocaml}
module MakeCell (T : sig type t end) =
struct
    class cell x =
    object
        val mutable x : T.t = x
        method private get = x
        method private set y = x <- y
    end
end
\end{ocaml}
%
Define a singly-linked list of integers by inheriting from the class \hbox{\lstinline/cell/}
twice.  Your class should have the type \hbox{\lstinline/int_cons/}.

\begin{ocaml}
class type int_cons =
object
   method hd : int
   method tl : int_cons option
   method set_hd : int -> unit
   method set_tl : int_cons option -> unit
end

type int_list = int_cons option
\end{ocaml}

\begin{answer}\ifanswers
Inheriting from the \hbox{\lstinline/cell/} twice would override the
methods \hbox{\lstinline/get/} and \hbox{\lstinline/set/}, which is not what we
want.  We need to \emph{rename} the methods first.  For this list, it
is sufficient to rename the methods in just one of the classes.  Note
that the cell value is hidden so that it is not overridden.

\begin{ocaml}
module IntCell =
struct
   module Cell = MakeCell (struct type t = int end);;

   class type cell_type =
   object
      method private get_int : int
      method private set_int : int -> unit
   end

   class cell i : cell_type =
   object (self)
      inherit Cell.cell i
      method private get_int = self#get
      method private set_int = self#set
   end
end

module ListCell = MakeCell (struct type t = int_list end);;

class cons i : int_cons =
object
    inherit IntCell.cell i as value
    inherit ListCell.cell None as link

    method hd = value#get_int
    method tl = link#get
    method set_hd = value#set_int
    method set_tl = link#set
end
\end{ocaml}
\fi\end{answer}
\end{exercise}    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Recursive functions
%
\begin{exercise}{multiple-recursive-functions}
Suppose we have several mutually-recursive functions 
\hbox{\lstinline/$f_1$ : int -> int/}, $\ldots$, \hbox{\lstinline/$f_n$ : int -> int/}
that we want to define in separate files.  In
Exercise~\ref{exercise:functor5} we did this with recursive modules.
Do it with multiple inheritance instead.  Is there any advantage to
using classes over recursive modules?

\begin{answer}\ifanswers
Each function $f_i : int -> int$ would be defined in a separate class,
where all the other functions are virtual.

\begin{ocaml}
class virtual fun_$i$ =
object
   method virtual $f_1$ : int -> int
   $\cdots$
   method virtual $f_{i - 1}$ : int -> int
   method $f_i$ i = $\cdots$
   $\cdots$
   method virtual $f_n$ : int -> int
end
\end{ocaml}
%
The final class would use multiple inheritance to tie the recursive knot.
%
\begin{ocaml}
class everything =
object
   inherit fun_$1$ $\cdots$ inherit fun_$n$
end
\end{ocaml}
%
To reduce the amount of code, a single shared base class could be used
to declare all the functions.

\begin{ocaml}
class virtual declarations =
object
   method virtual $f_1$ : int -> int
   $\cdots$
   method virtual $f_n$ : int -> int
end

class virtual fun_$i$ =
object
   inherit declarations
   method $f_i$ i = $\cdots$
end
\end{ocaml}
%
An advantage of the class representation is that the text required
for the declarations is \emph{much} smaller than needed for recursive
modules.
\fi\end{answer}
\end{exercise}

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
% vim:tw=100:fo=tcq:
