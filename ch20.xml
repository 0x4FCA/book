<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="memory-representation-of-values">
  <title>Memory Representation of Values</title>

  <para>The FFI interface we described in <xref
  linkend="foreign-function-interface" /> hides the precise details of how
  values are exchanged across C libraries and the OCaml runtime. There is a
  simple reason for this: using this interface directly is a delicate
  operation that requires understanding a few different moving parts before
  you can get it right. You first need to know the mapping between OCaml types
  and their runtime memory representation. You also need to ensure that your
  code is interfacing correctly with OCaml runtime's memory management.</para>

  <para>However, knowledge of the OCaml internals is useful beyond just
  writing foreign function interfaces. As you build and maintain more complex
  OCaml applications, you'll need to interface with various external system
  tools that operate on compiled OCaml binaries. For example, profiling tools
  report output based on the runtime memory layout and debuggers execute
  binaries without any knowledge of the static OCaml types. To use these tools
  effectively, you'll need to do some translation between the OCaml and C
  worlds.</para>

  <para>Luckily, the OCaml toolchain is very predictable. The compiler
  minimizes the amount of optimization magic that it performs, and relies
  instead on its straightforward execution model for good performance. With
  some experience, you can know rather precisely where a block of
  performance-critical OCaml code is spending its time.</para>

  <note>
    <title>Why do OCaml types disappear at runtime?</title>

    <para>The OCaml compiler runs through several phases during the
    compilation process. The first phase is syntax checking, during which
    source files are parsed into Abstract Syntax Trees (ASTs). The next stage
    is a <emphasis>type checking</emphasis> pass over the AST. In a validly
    typed program, a function cannot be applied with an unexpected type. For
    example, the <literal moreinfo="none">print_endline</literal> function
    must receive a single <literal moreinfo="none">string</literal> argument,
    and an <literal moreinfo="none">int</literal> will result in a type
    error.</para>

    <para>Since OCaml verifies these properties at compile time, it doesn't
    need to keep track of as much information at runtime. Thus, later stages
    of the compiler can discard and simplify the type declarations to a much
    more minimal subset that's actually required to distinguish polymorphic
    values at runtime. This is a major performance win versus something like a
    Java or .NET method call, where the runtime must look up the concrete
    instance of the object and dispatch the method call. Those languages
    amortize some of the cost via "Just-in-Time" dynamic patching, but OCaml
    prefers runtime simplicity instead.</para>

    <para>We'll explain this compilation pipeline in more detail in <xref
    linkend="the-compiler-frontend-parsing-and-type-checking" /> and <xref
    linkend="the-compiler-backend-byte-code-and-native-code" />.</para>
  </note>

  <para>This chapter covers the precise mapping from OCaml types to runtime
  values and walks you through them via the toplevel. We'll cover how these
  values are managed by the runtime later on in <xref
  linkend="understanding-the-garbage-collector" />.</para>

  <sect1 id="ocaml-blocks-and-values">
    <title>OCaml blocks and values</title>

    <para>A running OCaml program uses blocks of memory
    (<emphasis>i.e.</emphasis> contiguous sequences of words in RAM) to
    represent values such as tuples, records, closures or arrays. An OCaml
    program implicitly allocates a block of memory when such a value is
    created.</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/simple_record.topscript">memory-repr/simple_record.topscript</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: int; bar: int } ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : int; bar : int; }</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = { foo = 13; bar = 14 } ;;</userinput>
<computeroutput moreinfo="none">val x : t = {foo = 13; bar = 14}</computeroutput></programlisting>

    <para>The type declaration <literal moreinfo="none">t</literal> doesn't
    take up any memory at runtime, but the subsequent <literal
    moreinfo="none">let</literal> binding allocates a new block of memory with
    two words of available space. One word holds the <literal
    moreinfo="none">foo</literal> field and the other word holds the <literal
    moreinfo="none">bar</literal> field. The OCaml compiler translates such an
    expression into an explicit allocation for the block from OCaml's runtime
    system.</para>

    <para>OCaml uses a uniform memory representation in which every OCaml
    variable is stored as a <emphasis>value</emphasis>. An OCaml value is a
    single memory word that is either an immediate integer or a pointer to
    some other memory. The OCaml runtime tracks all values so that it can free
    them when they are no longer needed. It thus needs to be able to
    distinguish between integer and pointer values, since it scans pointers to
    find further values but doesn't follow integers that don't point to
    anything meaningful beyond their immediate value.</para>

    <sect2 id="distinguishing-integer-and-pointers-at-runtime">
      <title>Distinguishing integer and pointers at runtime</title>

      <para>Wrapping primitives types (such as integers) inside another data
      structure that records extra metadata about the value is known as
      <emphasis>boxing</emphasis>. Values are boxed in order to make it easier
      for the garbage collector to do its job, but at the expense of an extra
      level of indirection to access the data within the boxed value.</para>

      <para>OCaml values don't all have to be boxed at runtime. Instead,
      values use a single tag bit per word to distinguish integers and
      pointers at runtime. The value is an integer if the lowest bit of the
      block word is non-zero, and a pointer if the lowest bit of the block
      word is zero. Several OCaml types map onto this integer representation,
      including <literal moreinfo="none">bool</literal>, <literal
      moreinfo="none">int</literal>, the empty list, <literal
      moreinfo="none">unit</literal>, and variants without
      constructors.</para>

      <para>This representations means that integers are unboxed runtime
      values in OCaml so that they can be stored directly without having to
      allocate a wrapper block. They can be passed directly to other function
      calls in registers and are generally the cheapest and fastest values to
      use in OCaml.</para>

      <para>A value is treated as a memory pointer if its lowest bit is zero.
      A pointer value can still be stored unmodified despite this, since
      pointers are guaranteed to be word-aligned (with the bottom bits always
      being zero).</para>

      <para>The only problem that remains with this memory representation is
      distinguishing between pointers to OCaml values (which should be
      followed by the garbage collector) and pointers into the system heap to
      C values (which shouldn't be followed).</para>

      <para>The mechanism for this is simple, since the runtime system keeps
      track of the heap blocks it has allocated for OCaml values. If the
      pointer is inside a heap chunk that is marked as being managed by the
      OCaml runtime, it is assumed to point to an OCaml value. If it points
      outside the OCaml runtime area, it is treated as an opaque C pointer to
      some other system resource.</para>

      <note>
        <title>Some history about OCaml's word-aligned pointers</title>

        <para>The alert reader may be wondering how OCaml can guarantee that
        all of its pointers are word-aligned. In the old days when RISC chips
        such as Sparc, MIPS and Alpha were commonplace, unaligned memory
        accesses were forbidden by the instruction set architecture and would
        result in a CPU exception that terminated the program. Thus, all
        pointers were historically rounded off to the architecture word-size
        (usually 32- or 64-bits).</para>

        <para>Modern CISC processors such as the Intel x86 do support
        unaligned memory accesses, but the chip still runs faster if accesses
        are word-aligned. OCaml therefore simply mandates that all pointers be
        word-aligned, which guarantees that the bottom few bits of any valid
        pointer will be zero. Setting the bottom bit to a non-zero value is a
        simple way to mark an integer, at the cost of losing that single bit
        of precision.</para>

        <para>An even more alert reader will be wondering about the
        performance implications are for integer arithmetic using this tagged
        representation. Since the bottom bit is set, any operation on the
        integer has to shift the bottom bit right to recover the "native"
        value. The native code OCaml compiler generates efficient x86 assembly
        code in this case, taking advantage of modern processor instructions
        to hide the extra shifts where possible. Addition is a single <literal
        moreinfo="none">LEA</literal> x86 instruction, subtraction can be two
        instructions, and multiplication is only a few more.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="blocks-and-values">
    <title>Blocks and values</title>

    <para>An OCaml <emphasis>block</emphasis> is the basic unit of allocation
    on the heap. A block consists of a one-word header (either 32- or 64-bits
    depending on the CPU architecture) followed by variable-length data that
    is either opaque bytes or an array of <emphasis>fields</emphasis>. The
    header has a multi-purpose tag byte that defines whether to interpret the
    subsequent data as opaque bytes or OCaml fields.</para>

    <para>The garbage collector never inspects opaque bytes. If the tag
    indicates an array of OCaml fields are present, their contents are all
    treated as more valid OCaml values. The garbage collector always inspects
    fields and follows them as part of the collection process described
    earlier.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/block.ascii">Diagram</ulink></para>

    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2001.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>The <literal moreinfo="none">size</literal> field records the length
    of the block in memory words. This is 22 bits on 32-bit platforms, which
    is the reason why OCaml strings are limited to 16MB on that architecture.
    If you need bigger strings, either switch to a 64-bit host, or use the
    <literal moreinfo="none">Bigarray</literal> module.</para>

    <para>The 2-bit <literal moreinfo="none">color</literal> field is used by
    the garbage collector to keep track of its state during mark-and-sweep
    collection. We'll come back to this field in <xref
    linkend="understanding-the-garbage-collector" />. This tag isn't exposed
    to OCaml source code in any case.</para>

    <para>A block's tag byte is multi-purpose, and indicates whether the data
    array represents opaque bytes or fields. If a block's tag is greater than
    or equal to <literal moreinfo="none">No_scan_tag</literal> (251), then the
    block's data are all opaque bytes, and are not scanned by the collector.
    The most common such block is the <literal
    moreinfo="none">string</literal> type, which we describe in more detail
    later in this chapter.</para>

    <para>The exact representation of values inside a block depends on their
    static OCaml type. All OCaml types are distilled down into <literal
    moreinfo="none">values</literal>, and summarized in the table
    below.</para>

    <informaltable>
      <tgroup cols="2">
        <colspec align="left" />

        <colspec align="left" />

        <thead>
          <row>
            <entry>OCaml Value</entry>

            <entry>Representation</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal moreinfo="none">int</literal> or <literal
            moreinfo="none">char</literal></entry>

            <entry>directly as a value, shifted left by 1 bit, with the least
            significant bit set to 1</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">unit</literal>, <literal
            moreinfo="none">[]</literal>, <literal
            moreinfo="none">false</literal></entry>

            <entry>as OCaml <literal moreinfo="none">int</literal> 0.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">true</literal></entry>

            <entry>as OCaml <literal moreinfo="none">int</literal> 1.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">Foo | Bar</literal></entry>

            <entry>as ascending OCaml <literal moreinfo="none">int</literal>s,
            starting from 0.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">Foo | Bar of int</literal></entry>

            <entry>variants with parameters are boxed, while variants with no
            parameters are unboxed.</entry>
          </row>

          <row>
            <entry>polymorphic variants</entry>

            <entry>variable space usage depending on the number of
            parameters.</entry>
          </row>

          <row>
            <entry>floating-point number</entry>

            <entry>as a block with a single field containing the
            double-precision float.</entry>
          </row>

          <row>
            <entry>string</entry>

            <entry>word-aligned byte arrays with an explicit length.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">[1; 2; 3]</literal></entry>

            <entry>as <literal moreinfo="none">1::2::3::[]</literal> where
            <literal moreinfo="none">[]</literal> is an int, and <literal
            moreinfo="none">h::t</literal> a block with tag 0 and two
            parameters.</entry>
          </row>

          <row>
            <entry>tuples, records and arrays</entry>

            <entry>an array of values. Arrays can be variable size, but
            structs and tuples are fixed size.</entry>
          </row>

          <row>
            <entry>records or arrays, all float</entry>

            <entry>special tag for unboxed arrays of floats, or records that
            only have <literal moreinfo="none">float</literal> fields.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <sect2 id="integers-characters-and-other-basic-types">
      <title>Integers, characters and other basic types</title>

      <para>Many basic types are efficiently stored as unboxed integers at
      runtime. The native <literal moreinfo="none">int</literal> type is the
      most obvious, although it drops a single bit of precision due to the tag
      bit. Other atomic types such as <literal moreinfo="none">unit</literal>
      and empty list <literal moreinfo="none">[]</literal> value are stored as
      constant integers. Boolean values have a value of <literal
      moreinfo="none">1</literal> and <literal moreinfo="none">0</literal> for
      <literal moreinfo="none">true</literal> and <literal
      moreinfo="none">false</literal> respectively.</para>

      <para>These basic types such as empty lists and <literal
      moreinfo="none">unit</literal> are very efficient to use since integers
      are never allocated on the heap. They can be passed directly in
      registers and not appear on the stack if you don't have too many
      parameters to your functions. Modern architectures such as <literal
      moreinfo="none">x86_64</literal> have a lot of spare registers to
      further improve the efficiency of using unboxed integers.</para>
    </sect2>
  </sect1>

  <sect1 id="tuples-records-and-arrays">
    <title>Tuples, records and arrays</title>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/tuple_layout.ascii">Diagram</ulink></para>

    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2002.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>Tuples, records and arrays are all represented identically at
    runtime as a block with tag <literal moreinfo="none">0</literal>. Tuples
    and records have constant sizes determined at compile-time, whereas arrays
    can be of variable length. While arrays are restricted to containing a
    single type of element in the OCaml type system, this is not required by
    the memory representation.</para>

    <para>You can check the difference between a block and a direct integer
    yourself using the <literal moreinfo="none">Obj</literal> module, which
    exposes the internal representation of values to OCaml code.</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/reprs.topscript">memory-repr/reprs.topscript</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Obj.is_block (Obj.repr (1,2,3)) ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.is_block (Obj.repr 1) ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

    <para>The <literal moreinfo="none">Obj.repr</literal> function retrieves
    the runtime representation of any OCaml value. <literal
    moreinfo="none">Obj.is_block</literal> checks the bottom bit to determine
    if the value is a block header or an unboxed integer.</para>

    <sect2 id="floating-point-numbers-and-arrays">
      <title>Floating point numbers and arrays</title>

      <para>Floating point numbers in OCaml are always stored as full
      double-precision values. Individual floating-point values are stored as
      a block with a single field that contains the number. This block has the
      <literal moreinfo="none">Double_tag</literal> set which signals to the
      collector that the floating-point value is not to be scanned.</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/reprs.topscript">memory-repr/reprs.topscript</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr 1.0) ;;</userinput>
<computeroutput moreinfo="none">- : int = 253</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_tag ;;</userinput>
<computeroutput moreinfo="none">- : int = 253</computeroutput></programlisting>

      <para>Since each floating-point value is boxed in a separate memory
      block, it can be inefficient to handle large arrays of floats in
      comparison to unboxed integers. OCaml therefore special-cases records or
      arrays that contain <emphasis>only</emphasis> <literal
      moreinfo="none">float</literal> types. These are stored in a block that
      contains the floats packed directly in the data section, with the
      <literal moreinfo="none">Double_array_tag</literal> set to signal to the
      collector that the contents are not OCaml values.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/float_array_layout.ascii">Diagram</ulink></para>

      <informalfigure>
        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="images/rwoc_2003.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </informalfigure>

      <para>First, let's check that float arrays do in fact have a different
      tag number from normal floating-point values.</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/reprs.topscript">memory-repr/reprs.topscript</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_tag ;;</userinput>
<computeroutput moreinfo="none">- : int = 253</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_array_tag ;;</userinput>
<computeroutput moreinfo="none">- : int = 254</computeroutput></programlisting>

      <para>This tells us that float arrays have a tag value of 254. Now let's
      test some sample values using the <literal
      moreinfo="none">Obj.tag</literal> function to check that the allocated
      block has the expected runtime tag, and also use <literal
      moreinfo="none">Obj.double_field</literal> to retrieve a float from
      within the block.</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/reprs.topscript">memory-repr/reprs.topscript</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr [| 1.0; 2.0; 3.0 |]) ;;</userinput>
<computeroutput moreinfo="none">- : int = 254</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr (1.0, 2.0, 3.0) ) ;;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_field (Obj.repr [| 1.1; 2.2; 3.3 |]) 1 ;;</userinput>
<computeroutput moreinfo="none">- : float = 2.2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_field (Obj.repr 1.234) 0 ;;</userinput>
<computeroutput moreinfo="none">- : float = 1.234</computeroutput></programlisting>

      <para>The first thing we tested above was that a float array has the
      correct unboxed float array tag value (254). However, the next line
      tests a tuple of floating point values instead, which are
      <emphasis>not</emphasis> optimized in the same way and have the normal
      tuple tag value (0).</para>

      <para>Only records and arrays can have the float array optimization, and
      for records every single field must be a float.</para>
    </sect2>
  </sect1>

  <sect1 id="variants-and-lists">
    <title>Variants and lists</title>

    <para>Basic variant types with no extra parameters for any of their
    branches are simply stored as an OCaml integer, starting with <literal
    moreinfo="none">0</literal> for the first option and in ascending
    order.</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/reprs.topscript">memory-repr/reprs.topscript</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type t = Apple | Orange | Pear ;;</userinput>
<computeroutput moreinfo="none">type t = Apple | Orange | Pear</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">((Obj.magic (Obj.repr Apple)) : int) ;;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">((Obj.magic (Obj.repr Pear)) : int) ;;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.is_block (Obj.repr Apple) ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

    <para><literal moreinfo="none">Obj.magic</literal> unsafely forces a type
    cast between any two OCaml types; in this example the <literal
    moreinfo="none">int</literal> type hint retrieves the runtime integer
    value. The <literal moreinfo="none">Obj.is_block</literal> confirms that
    the value isn't a more complex block, but just an OCaml <literal
    moreinfo="none">int</literal>.</para>

    <para>Variants that have parameters arguments are a little more complex.
    They are stored as blocks, with the value <emphasis>tags</emphasis>
    ascending from 0 (counting from leftmost variants with parameters). The
    parameters are stored as words in the block.</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/reprs.topscript">memory-repr/reprs.topscript</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type t = Apple | Orange of int | Pear of string | Kiwi ;;</userinput>
<computeroutput moreinfo="none">type t = Apple | Orange of int | Pear of string | Kiwi</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.is_block (Obj.repr (Orange 1234)) ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr (Orange 1234)) ;;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr (Pear "xyz")) ;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(Obj.magic (Obj.field (Obj.repr (Orange 1234)) 0) : int) ;;</userinput>
<computeroutput moreinfo="none">- : int = 1234</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(Obj.magic (Obj.field (Obj.repr (Pear "xyz")) 0) : string) ;;</userinput>
<computeroutput moreinfo="none">- : string = "xyz"</computeroutput></programlisting>

    <para>In the above example, the <literal moreinfo="none">Apple</literal>
    and <literal moreinfo="none">Kiwi</literal> values are still stored as
    normal OCaml integers with values <literal moreinfo="none">0</literal> and
    <literal moreinfo="none">1</literal> respectively. The <literal
    moreinfo="none">Orange</literal> and <literal
    moreinfo="none">Pear</literal> values both have parameters, and are stored
    as blocks whose tags ascend from <literal moreinfo="none">0</literal> (and
    so <literal moreinfo="none">Pear</literal> has a tag of <literal
    moreinfo="none">1</literal>, as the use of <literal
    moreinfo="none">Obj.tag</literal> verifies). Finally, the parameters are
    fields which contain OCaml values within the block, and <literal
    moreinfo="none">Obj.field</literal> can be used to retrieve them.</para>

    <para>Lists are stored with a representation that is exactly the same as
    if the list was written as a variant type with <literal
    moreinfo="none">Head</literal> and <literal
    moreinfo="none">Cons</literal>. The empty list <literal
    moreinfo="none">[]</literal> is an integer <literal
    moreinfo="none">0</literal>, and subsequent blocks have tag <literal
    moreinfo="none">0</literal> and two parameters: a block with the current
    value, and a pointer to the rest of the list.</para>

    <warning>
      <title><literal moreinfo="none">Obj</literal> module considered
      harmful</title>

      <para>The <literal moreinfo="none">Obj</literal> module is an
      undocumented module that exposes the internals of the OCaml compiler and
      runtime. It is very useful for examining and understanding how your code
      will behave at runtime, but should <emphasis>never</emphasis> be used
      for production code unless you understand the implications. The module
      bypasses the OCaml type system, making memory corruption and
      segmentation faults possible.</para>

      <para>Some theorem provers such as Coq do output code which uses
      <literal moreinfo="none">Obj</literal> internally, but the external
      module signatures never expose it. Unless you too have a machine proof
      of correctness to accompany your use of <literal
      moreinfo="none">Obj</literal>, stay away from it except for
      debugging!</para>
    </warning>

    <para>Due to this encoding, there is a limit around 240 variants with
    parameters that applies to each type definition, but the only limit on the
    number of variants without parameters is the size of the native integer
    (either 31- or 63-bits). This limit arises because of the size of the tag
    byte, and that some of the high numbered tags are reserved.</para>
  </sect1>

  <sect1 id="polymorphic-variants-1">
    <title>Polymorphic variants</title>

    <para>Polymorphic variants are more flexible than normal variants when
    writing code, but are slightly less efficient at runtime. This is because
    there isn't as much static compile-time information available to optimize
    their memory layout.</para>

    <para>A polymorphic variant without any parameters is stored as an unboxed
    integer and so only takes up one word of memory, just like a normal
    variant. This integer value is determined by applying a hash function to
    the <emphasis>name</emphasis> of the variant. The hash function isn't
    exposed directly by the compiler, but the <literal
    moreinfo="none">type_conv</literal> library from Core provides an
    alternative implementation.</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/reprs.topscript">memory-repr/reprs.topscript</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Pa_type_conv.hash_variant "Foo" ;;</userinput>
<computeroutput moreinfo="none">- : int = 3505894</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(Obj.magic (Obj.repr `Foo) : int) ;;</userinput>
<computeroutput moreinfo="none">- : int = 3505894</computeroutput></programlisting>

    <para>The hash function is designed to give the same results on 32-bit and
    64-bit architectures, so the memory representation is stable across
    different CPUs and host types.</para>

    <para>Polymorphic variants use more memory space than normal variants when
    parameters are included in the datatype constructors. Normal variants use
    the tag byte to encode the variant value and save the fields for the
    contents, but this single byte is insufficient to encode the hashed value
    for polymorphic variants. They must allocate a new block (with tag
    <literal moreinfo="none">0</literal>) and store the value in there
    instead. Polymorphic variants with constructors thus use one word of
    memory more than normal variant constructors.</para>

    <para>Another inefficiency over normal variants is when a polymorphic
    variant constructor has more than one parameter. Normal variants hold
    parameters as a single flat block with multiple fields for each entry, but
    polymorphic variants must adopt a more flexible uniform memory
    representation since they may be reused in a different context across
    compilation units. They allocate a tuple block for the parameters that is
    pointed to from the argument field of the variant. There are thus three
    additional words for such variants, along with an extra memory indirection
    due to the tuple.</para>

    <para>The extra space usage is generally not significant in a typical
    application, and polymorphic variants offer a great deal more flexibility
    than normal variants. However, if you're writing code that demands high
    performance or must run within tight memory bounds, the runtime layout is
    at least very predictable. The OCaml compiler never switches memory
    representation due to optimization passes. This lets you predict the
    precise runtime layout by referring to these guidelines and your source
    code.</para>
  </sect1>

  <sect1 id="string-values">
    <title>String values</title>

    <para>Strings are standard OCaml blocks with the header size defining the
    size of the string in machine words. The <literal
    moreinfo="none">String_tag</literal> (252) is higher than the <literal
    moreinfo="none">No_scan_tag</literal>, indicating that the contents of the
    block are opaque to the collector. The block contents are the contents of
    the string, with padding bytes to align the block on a word
    boundary.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/string_block.ascii">Diagram</ulink></para>

    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2004.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>On a 32-bit machine, the padding is calculated based on the modulo
    of the string length and word size to ensure the result is word-aligned. A
    64-bit machine extends the potential padding up to 7 bytes instead of
    3.</para>

    <informaltable>
      <tgroup cols="2">
        <colspec align="left" />

        <colspec align="left" />

        <thead>
          <row>
            <entry>String length mod 4</entry>

            <entry>Padding</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>0</entry>

            <entry><literal moreinfo="none">00 00 00 03</literal></entry>
          </row>

          <row>
            <entry>1</entry>

            <entry><literal moreinfo="none">00 00 02</literal></entry>
          </row>

          <row>
            <entry>2</entry>

            <entry><literal moreinfo="none">00 01</literal></entry>
          </row>

          <row>
            <entry>3</entry>

            <entry><literal moreinfo="none">00</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>This string representation is a clever way to ensure that the
    contents are always zero-terminated by the padding word, and still compute
    its length efficiently without scanning the whole string. The following
    formula is used:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/string_size_calc.ascii">Diagram</ulink></para>

    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2005.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>The guaranteed <literal moreinfo="none">NULL</literal>-termination
    comes in handy when passing a string to C, but is not relied upon to
    compute the length from OCaml code. OCaml strings can thus contain
    <literal moreinfo="none">NULL</literal> bytes at any point within the
    string.</para>

    <para>Care should be taken that any C library functions that receive these
    buffers can also cope with arbitrary bytes within the buffer contents and
    are not expecting C strings. For instance, the C <literal
    moreinfo="none">memcopy</literal> or <literal
    moreinfo="none">memmove</literal> standard library functions can operate
    on arbitrary data, but <literal moreinfo="none">strlen</literal> or
    <literal moreinfo="none">strcpy</literal> both require a <literal
    moreinfo="none">NULL</literal> terminated buffer and has no mechanism for
    encoding a <literal moreinfo="none">NULL</literal> value within its
    contents.</para>
  </sect1>

  <sect1 id="custom-heap-blocks">
    <title>Custom heap blocks</title>

    <para>OCaml supports <emphasis>custom</emphasis> heap blocks via a
    <literal moreinfo="none">Custom_tag</literal> that let the runtime perform
    user-defined operations over OCaml values. A custom block lives in the
    OCaml heap like an ordinary block and can be of whatever size the user
    desires. The <literal moreinfo="none">Custom_tag</literal> (255) is higher
    than <literal moreinfo="none">No_scan_tag</literal> and so isn't scanned
    by the garbage collector.</para>

    <para>The first word of the data within the custom block is a C pointer to
    a <literal moreinfo="none">struct</literal> of custom operations. The
    custom block cannot have pointers to OCaml blocks and is opaque to the
    garbage collector.</para>

    <para role="sourcecode">C: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/memory-repr/custom_ops.c">memory-repr/custom_ops.c</ulink></para>

    <programlisting format="linespecific" language="c">struct custom_operations {
  char *identifier;
  void (*finalize)(value v);
  int (*compare)(value v1, value v2);
  intnat (*hash)(value v);
  void (*serialize)(value v,
                    /*out*/ uintnat * wsize_32 /*size in bytes*/,
                    /*out*/ uintnat * wsize_64 /*size in bytes*/);
  uintnat (*deserialize)(void * dst);
  int (*compare_ext)(value v1, value v2);
};</programlisting>

    <para>The custom operations specify how the runtime should perform
    polymorphic comparison, hashing and binary marshalling. They also
    optionally contain a <emphasis>finalizer</emphasis> that the runtime calls
    just before the block is garbage collected. This finalizer has nothing to
    do with ordinary OCaml finalizers (as created by <literal
    moreinfo="none">Gc.finalize</literal> and explained in <xref
    linkend="understanding-the-garbage-collector" />). They are instead used
    to call C cleanup functions such as <literal
    moreinfo="none">free</literal>.</para>

    <sect2 id="managing-external-memory-with-bigarray">
      <title>Managing external memory with Bigarray</title>

      <para>A common use of custom blocks is to manage external system memory
      directly from within OCaml. The Bigarray interface was originally
      intended to exchange data with Fortran code, and maps a block of system
      memory as a multi-dimensional array that can be accessed from OCaml.
      Bigarray operations work directly on the external memory without
      requiring it to be copied into the OCaml heap (which is a potentially
      expensive operation for large arrays).</para>

      <para>Bigarray sees a lot of use beyond just scientific computing, and
      several Core libraries use it for general-purpose I/O:</para>

      <itemizedlist>
        <listitem>
          <para>The <literal moreinfo="none">Iobuf</literal> module maps I/O
          buffers as a 1-dimensional array of bytes. It provides a sliding
          window interface that lets consumer processes read from the buffer
          while it's being filled by producers. This lets OCaml use I/O
          buffers that have been externally allocated by the operating system
          without any extra data copying.</para>
        </listitem>

        <listitem>
          <para>The <literal moreinfo="none">Bigstring</literal> module
          provides a <literal moreinfo="none">String</literal>-like interface
          that uses <literal moreinfo="none">Bigarray</literal> internally.
          The <literal moreinfo="none">Bigbuffer</literal> collects these into
          extensible string buffers that can operate entirely on external
          system memory.</para>
        </listitem>
      </itemizedlist>

      <para>The <ulink
      url="https://bitbucket.org/mmottl/lacaml">Lacaml</ulink> library isn't
      part of Core, but provides the recommended interfaces to the widely used
      BLAS and LAPACK mathematical Fortran libraries. These allow developers
      to write high-performance numerical code for applications that require
      linear algebra. It supports large vectors and matrices, but with static
      typing safety of OCaml to make it easier to write safe
      algorithms.</para>
    </sect2>
  </sect1>
</chapter>