<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="data-serialization-with-s-expressions">
  <title>Data Serialization with S-Expressions</title>

  <para>S-expressions are nested parenthetical expressions whose atomic values
  are strings. They were first popularized by the Lisp programming language in
  the 1960s. They have remained one of the simplest and most effective ways to
  encode structured data in a human-readable and editable form.<indexterm
      class="startofrange" id="SERFORMsexp">
      <primary>serialization formats</primary>

      <secondary>s-expressions</secondary>
    </indexterm><indexterm class="singular">
      <primary>s-expressions</primary>

      <secondary>uses for</secondary>
    </indexterm><indexterm class="singular">
      <primary>data serialization</primary>

      <secondary sortas="s-expressions">with s-expressions</secondary>
    </indexterm></para>

  <para>There's a full definition of s-expressions available <ulink
  url="http://people.csail.mit.edu/rivest/Sexp.txt">online</ulink>. An example
  s-expression might look like this:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/basic.scm"
      >Scheme</ulink></para>

  <programlisting format="linespecific" language="scheme">(this (is an) (s expression))</programlisting>

  <para>S-expressions play a major role in Core, effectively acting as the
  default serialization format. Indeed, we've encountered s-expressions
  multiple times already, including in <xref linkend="error-handling" />,
  <xref linkend="functors" />, and <xref
  linkend="first-class-modules" />.</para>

  <para>This chapter will go into s-expressions in more depth. In particular,
  we'll discuss:</para>

  <itemizedlist>
    <listitem>
      <para>The details of the s-expression format, including how to parse it while generating good
        error messages for debugging malformed inputs</para>
    </listitem>

    <listitem>
      <para>How to generate s-expressions from arbitrary OCaml types</para>
    </listitem>

    <listitem>
      <para>How to use custom type annotations to control the exact printing
      behavior for s-expression converters</para>
    </listitem>

    <listitem>
      <para>How to integrate s-expressions into your interfaces, in particular how to add
        s-expression converters to a module without breaking abstraction boundaries</para>
    </listitem>
  </itemizedlist>

  <para>We'll tie this together at the end of the chapter with a simple s-expression formatted
    configuration file for a web server</para>

  <sect1 id="basic-usage">
    <title>Basic Usage</title>

    <para>The type used to represent an s-expression is quite
    simple:<indexterm class="singular">
        <primary>s-expressions</primary>

        <secondary>basic usage of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">module Sexp : sig
  type t =
  | Atom of string
  | List of t list
end</programlisting>

    <para>An s-expression can be thought of as a tree where each node contains
    a list of its children, and where the leaves of the tree are strings. Core
    provides good support for s-expressions in its <literal
    moreinfo="none">Sexp</literal> module, including functions for converting
    s-expressions to and from strings. Let's rewrite our example s-expression
    in terms of this type:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/print_sexp.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.List [</userinput>
<userinput moreinfo="none">    Sexp.Atom "this";</userinput>
<userinput moreinfo="none">    Sexp.List [ Sexp.Atom "is"; Sexp.Atom "an"];</userinput>
<userinput moreinfo="none">    Sexp.List [ Sexp.Atom "s"; Sexp.Atom "expression" ];</userinput>
<userinput moreinfo="none">  ];;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (this (is an) (s expression))</computeroutput></programlisting>

    <para>This prints out nicely because Core registers a pretty printer with
    the toplevel. This pretty printer is based on the functions in <literal
    moreinfo="none">Sexp</literal> for converting s-expressions to and from
    strings:<indexterm class="singular">
        <primary>pretty printers</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_printer.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.to_string (Sexp.List [Sexp.Atom "1"; Sexp.Atom "2"]) ;;</userinput>
<computeroutput moreinfo="none">- : string = "(1 2)"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.of_string ("(1 2 (3 4))") ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (1 2 (3 4))</computeroutput></programlisting>

    <para>In addition to providing the <literal moreinfo="none">Sexp</literal>
    module, most of the base types in Core support conversion to and from
    s-expressions. For example, we can use the conversion functions defined in
    the respective modules for integers, strings, and exceptions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/to_from_sexp.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Int.sexp_of_t 3;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">String.sexp_of_t "hello";;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = hello</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Exn.sexp_of_t (Invalid_argument "foo");;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (Invalid_argument foo)</computeroutput></programlisting>

    <para>It's also possible to convert more complex types such as lists or
    arrays that are polymorphic across the types that they can contain:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/to_from_sexp.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">List.sexp_of_t;;</userinput>
<computeroutput moreinfo="none">- : ('a -&gt; Sexp.t) -&gt; 'a list -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.sexp_of_t Int.sexp_of_t [1; 2; 3];;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (1 2 3)</computeroutput></programlisting>

    <para>Notice that <literal moreinfo="none">List.sexp_of_t</literal> is
    polymorphic and takes as its first argument another conversion function to
    handle the elements of the list to be converted. Core uses this scheme
    more generally for defining sexp converters for polymorphic types.</para>

    <para>The functions that go in the other direction, <emphasis>i.e.</emphasis>, reconstruct an
      OCaml value from an s-expression, use essentially the same trick for handling polymorphic
      types, as shown in the following example. Note that these functions will fail with an
      exception when presented with an s-expression that doesn't match the structure of the OCaml
      type in question.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/to_from_sexp.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">List.t_of_sexp;;</userinput>
<computeroutput moreinfo="none">- : (Sexp.t -&gt; 'a) -&gt; Sexp.t -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.t_of_sexp Int.t_of_sexp (Sexp.of_string "(1 2 3)");;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.t_of_sexp Int.t_of_sexp (Sexp.of_string "(1 2 three)");;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(Sexplib.Conv.Of_sexp_error (Failure "int_of_sexp: (Failure int_of_string)")</computeroutput>
<computeroutput moreinfo="none"> three).</computeroutput></programlisting>

    <note>
      <title>More on Top-Level Printing</title>

      <para>The values of the s-expressions that we created were printed
      properly as s-expressions in the toplevel, instead of as the tree of
      <literal moreinfo="none">Atom</literal> and <literal
      moreinfo="none">List</literal> variants that they're actually made
      of.<indexterm class="singular">
          <primary>top-level printers</primary>
        </indexterm></para>

      <para>This is due to OCaml's facility for installing custom
      <emphasis>top-level printers</emphasis> that can rewrite some values
      into more top-level-friendly equivalents. They are generally installed
      as <command moreinfo="none">ocamlfind</command> packages ending in
      <literal moreinfo="none">top</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/list_top_packages.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind list | grep top</userinput>
<computeroutput moreinfo="none">compiler-libs.toplevel (version: [distributed with Ocaml])</computeroutput>
<computeroutput moreinfo="none">core.top            (version: 109.37.00)</computeroutput>
<computeroutput moreinfo="none">ctypes.top          (version: 0.1)</computeroutput>
<computeroutput moreinfo="none">lwt.simple-top      (version: 2.4.3)</computeroutput>
<computeroutput moreinfo="none">num-top             (version: 1.3.3)</computeroutput>
<computeroutput moreinfo="none">sexplib.top         (version: 109.20.00)</computeroutput>
<computeroutput moreinfo="none">uri.top             (version: 1.3.8)</computeroutput></programlisting>

      <para>The <literal moreinfo="none">core.top</literal> package (which you
      should have loaded by default in your <literal
      moreinfo="none">.ocamlinit</literal> file) loads in printers for the
      Core extensions already, so you don't need to do anything special to use
      the s-expression printer.</para>
    </note>

    <sect2 id="generating-s-expressions-from-ocaml-types">
      <title>Generating S-Expressions from OCaml Types</title>

      <para>But what if you want a function to convert a brand new type to an
      s-expression? You can of course write it yourself manually. Here's an
      example:<indexterm class="singular">
          <primary>s-expressions</primary>

          <secondary>generating from OCaml types</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/manually_making_sexp.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: int; bar: float } ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : int; bar : float; }</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sexp_of_t t =</userinput>
<userinput moreinfo="none">    let a x = Sexp.Atom x and l x = Sexp.List x in</userinput>
<userinput moreinfo="none">    l [ l [a "foo"; Int.sexp_of_t t.foo  ];</userinput>
<userinput moreinfo="none">        l [a "bar"; Float.sexp_of_t t.bar]; ] ;;</userinput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { foo = 3; bar = -5.5 } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((foo 3) (bar -5.5))</computeroutput></programlisting>

      <para>This is somewhat tiresome to write, and it gets more so when you
      consider the parser, i.e., <literal moreinfo="none">t_of_sexp</literal>,
      which is considerably more complex. Writing this kind of parsing and
      printing code by hand is mechanical and error prone, not to mention a
      drag.</para>

      <para>Given how mechanical the code is, you could imagine writing a program that inspected the
        type definition and autogenerated the conversion code for you. As it turns out, Sexplib does
        just that. <literal moreinfo="none">Sexplib</literal>, which is included with Core, provides
        both a library for manipulating s-expressions and a <emphasis>syntax extension</emphasis>
        for generating such conversion functions. With that syntax extension enabled, any type that
        has <literal moreinfo="none">with sexp</literal> as an annotation will trigger the
        generation of the functions we want:<indexterm class="singular">
          <primary>Sexplib package</primary>
          <secondary>syntax extension in</secondary>
        </indexterm><indexterm class="singular">
          <primary>syntax extension</primary>
          <secondary>in Sexplib package</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/auto_making_sexp.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: int; bar: float } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : int; bar : float; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">t_of_sexp (Sexp.of_string "((bar 35) (foo 3))") ;;</userinput>
<computeroutput moreinfo="none">- : t = {foo = 3; bar = 35.}</computeroutput></programlisting>

      <para>The syntax extension can be used outside of type declarations as
      well. As discussed in <xref linkend="error-handling" />, <literal
      moreinfo="none">with sexp</literal> can be attached to the declaration
      of an exception, which will improve the ability of Core to generate a
      useful string representation:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/auto_making_sexp.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">exception Bad_message of string list ;;</userinput>
<computeroutput moreinfo="none">exception Bad_message of string list</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Exn.to_string (Bad_message ["1";"2";"3"]) ;;</userinput>
<computeroutput moreinfo="none">- : string = "(\"Bad_message(_)\")"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Good_message of string list with sexp;;</userinput>
<computeroutput moreinfo="none">exception Good_message of string list</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Exn.to_string (Good_message ["1";"2";"3"]) ;;</userinput>
<computeroutput moreinfo="none">- : string = "(//toplevel//.Good_message (1 2 3))"</computeroutput></programlisting>
<?hard-pagebreak?>
      <para>You don't always have to declare a named type to create an
      s-expression converter. The following syntax lets you create one inline,
      as part of a larger expression:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/inline_sexp.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let l = [(1,"one"); (2,"two")] ;;</userinput>
<computeroutput moreinfo="none">val l : (int * string) list = [(1, "one"); (2, "two")]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.iter l ~f:(fun x -&gt;</userinput>
<userinput moreinfo="none">    &lt;:sexp_of&lt;int * string&gt;&gt; x</userinput>
<userinput moreinfo="none">    |&gt; Sexp.to_string</userinput>
<userinput moreinfo="none">    |&gt; print_endline) ;;</userinput>
<computeroutput moreinfo="none">(1 one)</computeroutput>
<computeroutput moreinfo="none">(2 two)</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>The declaration <literal moreinfo="none">&lt;:sexp_of&lt;int *
      string&gt;&gt;</literal> simply gets expanded to the sexp converter for
      the type <literal moreinfo="none">int * string</literal>. This is useful
      whenever you need a sexp converter for an anonymous type.</para>

      <para>The syntax extensions bundled with Core almost all have the same
      basic structure: they autogenerate code based on type definitions,
      implementing functionality that you could in theory have implemented by
      hand, but with far less programmer effort.</para>

      <note>
        <title>Syntax Extensions, Camlp4, and Type_conv</title>

        <para>OCaml doesn't directly support generating code from type
        definitions. Instead, it supplies a powerful syntax extension
        mechanism known as Camlp4, which lets you extend the grammar of the
        language. Camlp4 is well integrated into the OCaml toolchain and can
        be activated within the toplevel and also included in compilation
        using the <literal moreinfo="none">-pp</literal> compiler
        flag.<indexterm class="singular">
            <primary>Camlp4 syntax extension mechanism</primary>
          </indexterm><indexterm class="singular">
            <primary>syntax extension</primary>

            <secondary sortas="Camlp4">in Camlp4</secondary>
          </indexterm></para>

        <para>Sexplib is part of a family of syntax extensions, including
        Comparelib, described in <xref linkend="maps-and-hash-tables" />, and
        Fieldslib, described in <xref linkend="records" />, that generate code
        based on type declarations and are all based on a common library
        called Type_conv. This library provides a common language for
        annotating types (e.g., using the <literal
        moreinfo="none">with</literal> notation) and utilities for working
        with type definitions. If you want to build your own type-driven
        syntax extension, you should consider basing it on
        Type_conv.<indexterm class="singular">
            <primary>Type_conv library</primary>
          </indexterm><indexterm class="singular">
            <primary>Sexplib package</primary>

            <secondary>Type_conv library and</secondary>
          </indexterm></para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="the-sexp-format">
    <title>The Sexp Format</title>

    <para>The textual representation of s-expressions is pretty
    straightforward. An s-expression is written down as a nested parenthetical
    expression, with whitespace-separated strings as the atoms. Quotes are
    used for atoms that contain parentheses or spaces themselves; backslash is
    the escape character; and semicolons are used to introduce single-line
    comments. Thus, the following file, <filename
    moreinfo="none">example.scm</filename>:<indexterm class="singular">
        <primary>s-expressions</primary>

        <secondary>format of</secondary>
      </indexterm></para>
    
    <?hard-pagebreak?>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/example.scm"
        >Scheme</ulink></para>

    <programlisting format="linespecific" language="scheme">;; example.scm

((foo 3.3) ;; This is a comment
 (bar "this is () an \" atom"))</programlisting>

    <para>can be loaded using Sexplib. As you can see, the commented data is
    not part of the resulting s-expression:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/example_load.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.load_sexp "example.scm" ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((foo 3.3) (bar "this is () an \" atom"))</computeroutput></programlisting>

    <para>All in, the s-expression format supports three comment
    syntaxes:</para>



    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">;</literal></term>

        <listitem>
          <para>Comments out everything to the end of line</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">#|</literal></term>

        <term><literal moreinfo="none">|#</literal></term>

        <listitem>
          <para>Delimiters for commenting out a block</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">#;</literal></term>

        <listitem>
          <para>Comments out the first complete s-expression that
          follows</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The following example shows all of these in action:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/comment_heavy.scm"
        >Scheme</ulink></para>

    <programlisting format="linespecific" >;; comment_heavy_example.scm
((this is included)
 ; (this is commented out
 (this stays)
 #; (all of this is commented
     out (even though it crosses lines.))
  (and #| block delimiters #| which can be nested |#
     will comment out
    an arbitrary multi-line block))) |#
   now we're done
   ))</programlisting>

    <para>Again, loading the file as an s-expression drops the
    comments:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/example_load.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.load_sexp "comment_heavy.scm" ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((this is included) (this stays) (and now we're done))</computeroutput></programlisting>

    <para>If we introduce an error into our s-expression, by, say, creating a
    file <literal moreinfo="none">broken_example.scm</literal> which is
    <literal moreinfo="none">example.scm</literal>, without open-paren in
    front of <literal moreinfo="none">bar</literal>, we'll get a parse
    error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/example_load.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">Exn.handle_uncaught ~exit:false (fun () -&gt;</userinput>
<userinput moreinfo="none">    ignore (Sexp.load_sexp "example_broken.scm")) ;;</userinput>
<computeroutput moreinfo="none">Uncaught exception:</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">  (Sexplib.Sexp.Parse_error</computeroutput>
<computeroutput moreinfo="none">   ((location parse) (err_msg "unexpected character: ')'") (text_line 4)</computeroutput>
<computeroutput moreinfo="none">    (text_char 29) (global_offset 78) (buf_pos 78)))</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>In the preceding example, we use <literal
    moreinfo="none">Exn.handle_uncaught</literal> to make sure that the
    exception gets printed out in full detail. You should generally wrap every
    Core program in this handler to get good error messages for any unexpected
    exceptions.</para>
  </sect1>

  <sect1 id="preserving-invariants">
    <title>Preserving Invariants</title>

    <para>The most important functionality provided by Sexplib is the
    autogeneration of converters for new types. We've seen a bit of how this
    works already, but let's walk through a complete example. Here's the
    source for a simple library for representing integer intervals, very
    similar to the one described in <xref linkend="functors" />:<indexterm
        class="singular">
        <primary>s-expressions</primary>

        <secondary>preserving invariants in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/int_interval.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">(* Module for representing closed integer intervals *)
open Core.Std

(* Invariant: For any Range (x,y), y &gt;= x *)
type t =
  | Range of int * int
  | Empty
with sexp

let is_empty =
  function 
  | Empty -&gt; true 
  | Range _ -&gt; false

let create x y =
  if x &gt; y then
    Empty 
  else 
    Range (x,y)

let contains i x =
  match i with
  | Empty -&gt; false
  | Range (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high</programlisting>

    <para>We can now use this module as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/test_interval.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let intervals =
  let module I = Int_interval in
  [ I.create 3 4;
    I.create 5 4; (* should be empty *)
    I.create 2 3;
    I.create 1 6;
  ]

let () =
  intervals
  |&gt; List.sexp_of_t Int_interval.sexp_of_t
  |&gt; Sexp.to_string_hum
  |&gt; print_endline</programlisting>

    <para>But we're still missing something: we haven't created an <literal
    moreinfo="none">mli</literal> signature for <literal
    moreinfo="none">Int_interval</literal> yet. Note that we need to
    explicitly export the s-expression converters that were created within the
    <literal moreinfo="none">ml</literal> file. For example, here's an
    interface that doesn't export the s-expression functions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/int_interval_nosexp.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type t

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool</programlisting>

    <para>Building this will give us the following error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/build_test_interval_nosexp.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild test_interval_nosexp.native</userinput>
<computeroutput moreinfo="none">File "test_interval_nosexp.ml", line 14, characters 20-42:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value Int_interval.sexp_of_t</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

    <para>We could export the types by hand in the signature, by writing the
    signatures for the extra functions generated by Sexplib:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/int_interval_manual_sexp.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t
val t_of_sexp : Sexp.t -&gt; t
val sexp_of_t : t -&gt; Sexp.t

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool</programlisting>

    <para>This isn't an ideal solution, as it makes you repeatedly expose
    these extra functions in every signature you create where you want to
    serialize values. Sexplib solves this by exposing the same syntax
    extension in signature definitions so that we can just use the same
    <literal moreinfo="none">with</literal> shorthand in the <literal
    moreinfo="none">mli</literal> file. Here's the final version of the
    signature that does just this:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/int_interval.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type t with sexp

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool</programlisting>

    <para>At this point, <literal moreinfo="none">test_interval.ml</literal>
    will compile again, and if we run it, we'll get the following
    output:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/build_test_interval.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild test_interval.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./test_interval.native</userinput>
<computeroutput moreinfo="none">((Range 3 4) Empty (Range 2 3) (Range 1 6))</computeroutput></programlisting>

    <para>One easy mistake to make when dealing with sexp converters is to
    ignore the fact that those converters can violate the invariants of your
    code. For example, the <literal moreinfo="none">Int_interval</literal>
    module depends for the correctness of the <literal
    moreinfo="none">is_empty</literal> check on the fact that for any value
    <literal moreinfo="none">Range (x,y)</literal>, <literal
    moreinfo="none">y</literal> is greater than or equal to <literal
    moreinfo="none">x</literal>. The <literal moreinfo="none">create</literal>
    function preserves this invariant, but the <literal
    moreinfo="none">t_of_sexp</literal> function does not.<indexterm
        class="singular">
        <primary>invariant checks</primary>
      </indexterm></para>

    <para>We can fix this problem by overriding the autogenerated function and
    writing a custom sexp converter that wraps the autogenerated converter
    with whatever invariant checks are necessary:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_override.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type t =
  | Range of int * int
  | Empty
with sexp

let create x y =
  if x &gt; y then Empty else Range (x,y)

let t_of_sexp sexp =
  let t = t_of_sexp sexp in
  begin match t with
    | Empty -&gt; ()
    | Range (x,y) -&gt;
      if y &lt; x then of_sexp_error "Upper and lower bound of Range swapped" sexp
  end;
  t</programlisting>

    <para>This trick of overriding an existing function definition with a new
    one is perfectly acceptable in OCaml. Since <literal
    moreinfo="none">t_of_sexp</literal> is defined with an ordinary <literal
    moreinfo="none">let</literal> rather than a <literal moreinfo="none">let
    rec</literal>, the call to the <literal
    moreinfo="none">t_of_sexp</literal> goes to the Sexplib-generated version
    of the function, rather than being a recursive call.</para>

    <para>Another important aspect of our definition is that we call the
    function <literal moreinfo="none">of_sexp_error</literal> to raise an
    exception when the parsing process fails. This improves the error
    reporting that Sexplib can provide when a conversion fails, as we'll see
    in the next section.</para>
  </sect1>

  <sect1 id="getting-good-error-messages">
    <title>Getting Good Error Messages</title>

    <para>There are two steps to deserializing a type from an s-expression:
    first, converting the bytes in a file to an s-expression; and the second,
    converting that s-expression into the type in question. One problem with
    this is that it can be hard to localize errors to the right place using
    this scheme. Consider the following example:<indexterm class="singular">
        <primary>debugging</primary>

        <secondary>s-expressions</secondary>
      </indexterm><indexterm class="singular">
        <primary>errors</primary>

        <secondary>error messages with s-expressions</secondary>
      </indexterm><indexterm class="singular">
        <primary>s-expressions</primary>

        <secondary>deserializing a type from</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/read_foo.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = { 
  a: string;
  b: int;
  c: float option 
} with sexp

let run () =
  let t =
    Sexp.load_sexp "foo_broken_example.scm"
    |&gt; t_of_sexp
  in
  printf "b is: %d\n%!" t.b

let () =
  Exn.handle_uncaught ~exit:true run</programlisting>

    <para>If you were to run this on a malformatted file, say, this
    one:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/foo_broken_example.scm"
        >Scheme</ulink></para>

    <programlisting format="linespecific" language="scheme">((a "not-an-integer")
 (b "not-an-integer")
 (c 1.0))</programlisting>

    <para>you'll get the following error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/build_read_foo.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild read_foo.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./read_foo.native foo_example_broken.scm</userinput>
<computeroutput moreinfo="none">Uncaught exception:</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">  (Sexplib.Conv.Of_sexp_error</computeroutput>
<computeroutput moreinfo="none">   (Failure "int_of_sexp: (Failure int_of_string)") not-an-integer)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Raised at file "lib/conv.ml", line 281, characters 36-72</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/core_int.ml", line 6, characters 7-14</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/std_internal.ml", line 115, characters 7-33</computeroutput>
<computeroutput moreinfo="none">Called from file "read_foo.ml", line 5, characters 2-8</computeroutput>
<computeroutput moreinfo="none">Called from file "read_foo.ml", line 4, characters 2-40</computeroutput>
<computeroutput moreinfo="none">Called from file "read_foo.ml", line 11, characters 4-60</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/exn.ml", line 87, characters 6-10</computeroutput></programlisting>

    <para>If all you have is the error message and the string, it's not
    terribly informative. In particular, you know that the parsing errored out
    on the atom "not-an-integer," but you don't know which one! In a large
    file, this kind of bad error message can be pure misery.</para>

    <para>But there's hope! We can make a small change to the code to improve
    the error message greatly:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/read_foo_better_errors.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = { 
  a: string;
  b: int;
  c: float option 
} with sexp

let run () =
  let t = Sexp.load_sexp_conv_exn "foo_broken_example.scm" t_of_sexp in
  printf "b is: %d\n%!" t.b

let () =
  Exn.handle_uncaught ~exit:true run</programlisting>

    <para>If we run it again, we'll see a much more specific error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/build_read_foo_better_errors.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt
        moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild read_foo_better_errors.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./read_foo_better_errors.native foo_example_broken.scm</userinput>
<computeroutput moreinfo="none">Uncaught exception:</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">  (Sexplib.Conv.Of_sexp_error</computeroutput>
<computeroutput moreinfo="none">   (Sexplib.Sexp.Annotated.Conv_exn foo_broken_example.scm:2:5</computeroutput>
<computeroutput moreinfo="none">    (Failure "int_of_sexp: (Failure int_of_string)"))</computeroutput>
<computeroutput moreinfo="none">   not-an-integer)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Raised at file "lib/pre_sexp.ml", line 1145, characters 12-58</computeroutput>
<computeroutput moreinfo="none">Called from file "read_foo_better_errors.ml", line 10, characters 10-68</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/exn.ml", line 87, characters 6-10</computeroutput></programlisting>

    <para>In the preceding error, <computeroutput
    moreinfo="none">foo_broken_example.scm:2:5</computeroutput> tells us that
    the error occurred in the file <computeroutput
    moreinfo="none">"foo_broken_example.scm"</computeroutput> on line 2,
    character 5. This is a much better start for figuring out what went wrong.
    The ability to find the precise location of the error depends on the sexp
    converter reporting errors using the function <literal
    moreinfo="none">of_sexp_error</literal>. This is already done by
    converters generated by Sexplib, but you should make sure to do the same
    when you write custom converters.</para>
  </sect1>

  <sect1 id="sexp-conversion-directives">
    <title>Sexp-Conversion Directives</title>

    <para>Sexplib supports a collection of directives for modifying the
    default behavior of the autogenerated sexp converters. These directives
    allow you to customize the way in which types are represented as
    s-expressions without having to write a custom converter.<indexterm
        class="singular">
        <primary>s-expressions</primary>

        <secondary>modifying default behavior of</secondary>
      </indexterm></para>

    <para>Note that the extra directives aren't part of the standard OCaml
    syntax, but are added via the Sexplib syntax extension. However, since
    Sexplib is used throughout Core and is part of the standard bundle
    activated by <command moreinfo="none">corebuild</command>, you can use
    these in your own Core code without any special effort.</para>

    <sect2 id="sexp_opaque">
      <title>sexp_opaque</title>

      <para>The most commonly used directive is <literal
      moreinfo="none">sexp_opaque</literal>, whose purpose is to mark a given
      component of a type as being unconvertible. Anything marked with
      <literal moreinfo="none">sexp_opaque</literal> will be presented as the
      atom <literal moreinfo="none">&lt;opaque&gt;</literal> by the to-sexp
      converter, and will trigger an exception from the from-sexp
      converter.<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp_opaque</secondary>
        </indexterm></para>

      <para>Note that the type of a component marked as opaque doesn't need to
      have a sexp converter defined. Here, if we define a type without a sexp
      converter and then try to use another type with a sexp converter, we'll
      error out:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type no_converter = int * int ;;</userinput>
<computeroutput moreinfo="none">type no_converter = int * int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">Characters 14-26:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value no_converter_of_sexp</computeroutput></programlisting>

      <para>But with <literal moreinfo="none">sexp_opaque</literal>, we can
      embed our opaque <literal moreinfo="none">no_converter</literal> type
      within the other data structure without an error.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter sexp_opaque; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : no_converter; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>And if we now convert a value of this type to an s-expression,
      we'll see the contents of field <literal moreinfo="none">a</literal>
      marked as opaque:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = (3,4); b = "foo" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a &lt;opaque&gt;) (b foo))</computeroutput></programlisting>

      <para>Note that the <literal moreinfo="none">t_of_sexp</literal>
      function for an opaque type is generated, but will fail at runtime if it
      is used:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">t_of_sexp (Sexp.of_string "((a whatever) (b foo))") ;;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(Sexplib.Conv.Of_sexp_error</computeroutput>
<computeroutput moreinfo="none"> (Failure "opaque_of_sexp: cannot convert opaque values") whatever).</computeroutput></programlisting>

      <para>This is there to allow for s-expression converters to be created
      for types containing <literal moreinfo="none">sexp_opaque</literal>
      values. This is useful because the resulting converters won't
      necessarily fail on all inputs. For example, if you have a record
      containing a <literal moreinfo="none">no_converter list</literal>, the
      <literal moreinfo="none">t_of_sexp</literal> function would still
      succeed when the list is empty:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter sexp_opaque list; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : no_converter list; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">t_of_sexp (Sexp.of_string "((a ()) (b foo))") ;;</userinput>
<computeroutput moreinfo="none">- : t = {a = []; b = "foo"}</computeroutput></programlisting>

      <para>If you really only want to generate one direction of converter,
      one can do this by annotating the type with <literal
      moreinfo="none">with sexp_of</literal> or <literal moreinfo="none">with
      of_sexp</literal> instead of <literal moreinfo="none">with
      sexp</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter sexp_opaque; b: string } with sexp_of ;;</userinput>
<computeroutput moreinfo="none">type t = { a : no_converter; b : string; }</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter sexp_opaque; b: string } with of_sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : no_converter; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput></programlisting>
    </sect2>

    <sect2 id="sexp_list">
      <title>sexp_list</title>

      <para>Sometimes, sexp converters have more parentheses than one would
      ideally like. Consider, for example, the following variant
      type:<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp_list</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_list.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type compatible_versions =</userinput>
<userinput moreinfo="none">  | Specific of string list</userinput>
<userinput moreinfo="none">  | All with sexp ;;</userinput>
<computeroutput moreinfo="none">type compatible_versions = Specific of string list | All</computeroutput>
<computeroutput moreinfo="none">val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_compatible_versions</userinput>
<userinput moreinfo="none">  (Specific ["3.12.0"; "3.12.1"; "3.13.0"]) ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (Specific (3.12.0 3.12.1 3.13.0))</computeroutput></programlisting>

      <para>You might prefer to make the syntax a bit less parenthesis-laden
      by dropping the parentheses around the list. We can replace the <literal
      moreinfo="none">string list</literal> in the type declaration with
      <literal moreinfo="none">string sexp_list</literal> to give us this
      alternate syntax:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_list.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type compatible_versions =</userinput>
<userinput moreinfo="none">  | Specific of string sexp_list</userinput>
<userinput moreinfo="none">  | All with sexp ;;</userinput>
<computeroutput moreinfo="none">type compatible_versions = Specific of string list | All</computeroutput>
<computeroutput moreinfo="none">val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_compatible_versions</userinput>
<userinput moreinfo="none">  (Specific ["3.12.0"; "3.12.1"; "3.13.0"]) ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (Specific 3.12.0 3.12.1 3.13.0)</computeroutput></programlisting>
    </sect2>

    <sect2 id="sexp_option">
      <title>sexp_option</title>

      <para>Another common directive is <literal
      moreinfo="none">sexp_option</literal>, which is used to make a record
      field optional in the s-expression. Normally, optional values are
      represented either as <literal moreinfo="none">()</literal> for <literal
      moreinfo="none">None</literal>, or as <literal
      moreinfo="none">(x)</literal> for <literal moreinfo="none">Some
      x</literal>, and a record field containing an option would be rendered
      accordingly. For example:<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp_option</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_option.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: int option; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : int option; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = None; b = "hello" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a ()) (b hello))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = Some 3; b = "hello" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a (3)) (b hello))</computeroutput></programlisting>

      <para>But what if we want a field to be optional, i.e., we want to allow
      it to be omitted from the record entirely? In that case, we can mark it
      with <literal moreinfo="none">sexp_option</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_option.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: int sexp_option; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : int option; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = Some 3; b = "hello" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a 3) (b hello))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = None; b = "hello" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((b hello))</computeroutput></programlisting>
    </sect2>

    <sect2 id="specifying-defaults">
      <title>Specifying Defaults</title>

      <para>The <literal moreinfo="none">sexp_option</literal> declaration is
      really just an example of specifying a default behavior for dealing with
      an unspecified field. In particular, <literal
      moreinfo="none">sexp_option</literal> fills in absent fields with
      <literal moreinfo="none">None</literal>. But you might want to allow
      other ways of filling in default values.<indexterm class="singular">
          <primary>s-expressions</primary>

          <secondary>specifying defaults in</secondary>
        </indexterm></para>

      <para>Consider the following type, which represents the configuration of
      a very simple web server:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type http_server_config = {</userinput>
<userinput moreinfo="none">     web_root: string;</userinput>
<userinput moreinfo="none">     port: int;</userinput>
<userinput moreinfo="none">     addr: string;</userinput>
<userinput moreinfo="none">  } with sexp ;;</userinput>
<computeroutput moreinfo="none">type http_server_config = { web_root : string; port : int; addr : string; }</computeroutput>
<computeroutput moreinfo="none">val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>One could imagine making some of these parameters optional; in
      particular, by default, we might want the web server to bind to port 80,
      and to listen as localhost. We can do this as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type http_server_config = {</userinput>
<userinput moreinfo="none">     web_root: string;</userinput>
<userinput moreinfo="none">     port: int with default(80);</userinput>
<userinput moreinfo="none">     addr: string with default("localhost");</userinput>
<userinput moreinfo="none">  } with sexp ;;</userinput>
<computeroutput moreinfo="none">type http_server_config = { web_root : string; port : int; addr : string; }</computeroutput>
<computeroutput moreinfo="none">val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>Now, if we try to convert an s-expression that specifies only the
      <literal moreinfo="none">web_root</literal>, we'll see that the other
      values are filled in with the desired defaults:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let cfg = http_server_config_of_sexp</userinput>
<userinput moreinfo="none">   (Sexp.of_string "((web_root /var/www/html))") ;;</userinput>
<computeroutput moreinfo="none">val cfg : http_server_config =</computeroutput>
<computeroutput moreinfo="none">  {web_root = "/var/www/html"; port = 80; addr = "localhost"}</computeroutput></programlisting>

      <para>If we convert the configuration back out to an s-expression,
      you'll notice that all of the fields are present, even though they're
      not strictly necessary:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_http_server_config cfg ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((web_root /var/www/html) (port 80) (addr localhost))</computeroutput></programlisting>

      <para>We could make the generated s-expression also drop exported
      values, by using the <literal
      moreinfo="none">sexp_drop_default</literal> directive:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">type http_server_config = {</userinput>
<userinput moreinfo="none">     web_root: string;</userinput>
<userinput moreinfo="none">     port: int with default(80), sexp_drop_default;</userinput>
<userinput moreinfo="none">     addr: string with default("localhost"), sexp_drop_default;</userinput>
<userinput moreinfo="none">  } with sexp ;;</userinput>
<computeroutput moreinfo="none">type http_server_config = { web_root : string; port : int; addr : string; }</computeroutput>
<computeroutput moreinfo="none">val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let cfg = http_server_config_of_sexp</userinput>
<userinput moreinfo="none">  (Sexp.of_string "((web_root /var/www/html))") ;;</userinput>
<computeroutput moreinfo="none">val cfg : http_server_config =</computeroutput>
<computeroutput moreinfo="none">  {web_root = "/var/www/html"; port = 80; addr = "localhost"}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_http_server_config cfg ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((web_root /var/www/html))</computeroutput></programlisting>

      <para>As you can see, the fields that are at their default values are
      simply omitted from the s-expression. On the other hand, if we convert a
      config with other values, then those values will be included in the
      s-expression:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_http_server_config { cfg with port = 8080 } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((web_root /var/www/html) (port 8080))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_http_server_config</userinput>
<userinput moreinfo="none">  { cfg with port = 8080; addr = "192.168.0.1" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((web_root /var/www/html) (port 8080) (addr 192.168.0.1))</computeroutput></programlisting>

      <para>This can be very useful in designing config file formats that are
      both reasonably terse and easy to generate and maintain. It can also be
      useful for backwards compatibility: if you add a new field to your
      config record, but you make that field optional, then you should still
      be able to parse older version of your config.<indexterm
      class="endofrange" startref="SERFORMsexp"></indexterm><indexterm class="singular">
          <primary>files</primary>

          <secondary>config files</secondary>
        </indexterm><indexterm class="singular">
          <primary>config file formats</primary>
        </indexterm></para>
    </sect2>
  </sect1>
</chapter>
