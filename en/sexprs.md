# Data Serialization with S-Expressions

S-expressions are nested parenthetical expressions whose atomic values
are strings.  They were first popularized by the Lisp programming
language in the 1960s, and have remained one of the simplest and most
effective ways to encode structured data in a human-readable and
editable form.  

There's a full definition of s-expressions available
[online](http://people.csail.mit.edu/rivest/Sexp.txt).  An example
s-expression might look like this.

```frag
((typ scheme)(name sexpr/basic.scm))
```

S-expressions play a major role in Core, effectively acting as the
default serialization format.  Indeed, we've encountered s-expressions
multiple times already, including in [xref](#error-handling),
[xref](#functors) and [xref](#first-class-modules).

This chapter will go into s-expressions in more depth.  In particular,
we'll discuss:

* the details of the s-expression format, and show how to generate
  good error messages for debugging malformed inputs,
* how to generate s-expressions from arbitrary OCaml types,
* how to use custom type annotations to control the exact printing
  behavior for s-expression converters,
* how to integrate s-expressions into your interfaces, in particular
  explaining how to add s-expression converters to a module without
  breaking your abstraction boundaries.

We will also tie this together at the end of the chapter with a simple
s-expression formatted configuration file for a web server.

## Basic Usage

The type used to represent an s-expression is quite simple.

```frag
((typ ocaml)(name sexpr/sexp.mli))
```

An s-expression can be thought of as a tree where each node contains a
list of its children, and where the leaves of the tree are strings.
Core provides good support for s-expressions in its `Sexp` module,
including functions for converting s-expressions to and from strings.
Let's rewrite our example s-expression in terms of this type.

```frag
((typ ocamltop)(name sexpr/print_sexp.topscript))
```

This prints out nicely because Core registers a pretty printer with
the toplevel.  This pretty-printer is based on the functions in `Sexp`
for converting s-expressions to and from strings.

```frag
((typ ocamltop)(name sexpr/sexp_printer.topscript))
```

In addition to providing the `Sexp` module, most of the base types in Core
support conversion to and from s-expressions.  For example, we can use the
conversion functions defined in the respective modules for integers, strings
and exceptions.

```frag
((typ ocamltop)(name sexpr/to_from_sexp.topscript)(part 0))
```

It's also possible to convert more complex types such as lists or arrays that
are polymorphic across the types that they an contain.

```frag
((typ ocamltop)(name sexpr/to_from_sexp.topscript)(part 1))
```

Notice that `List.sexp_of_t` is polymorphic, and takes as its first argument
another conversion function to handle the elements of the list to be converted.
Core uses this scheme more generally for defining sexp-converters for
polymorphic types.

The functions that reconstruct an OCaml value from an s-expression use
essentially the same trick for handling polymorphic types, as shown
below.  Note that these functions will fail with an exception when
presented with an s-expression that doesn't match the structure of the
OCaml type in question.

```frag
((typ ocamltop)(name sexpr/to_from_sexp.topscript)(part 2))
```


<note>
<title>More on toplevel printing</title>

The values of the s-expressions that we created above were printed
properly as s-expressions in the toplevel, instead of as the tree of
`Atom` and `List` variants that they're actually made of.

This is due to OCaml's facility for installing custom *toplevel
printers* that can rewrite some values into more toplevel-friendly
equivalents.  They are generally installed as
<command>ocamlfind</command> packages ending in `top`.

```frag
((typ console)(name sexpr/list_top_packages.out))
```

The `core.top` package (which you should have loaded by default in
your `.ocamlinit` file) loads in printers for the Core extensions
already, so you don't need to do anything special to use the
s-expression printer.

</note>

### Generating s-expressions from OCaml types

But what if you want a function to convert a brand new type to an
s-expression?  You can of course write it yourself manually.  Here's
an example.

```frag
((typ ocamltop)(name sexpr/manually_making_sexp.topscript))
```

This is somewhat tiresome to write, and it gets more so when you
consider the parser, _i.e._, `t_of_sexp`, which is considerably more
complex.  Writing this kind of parsing and printing code by hand is
mechanical and error prone, not to mention a drag.

Given how mechanical the code is, you could imagine writing a program
that inspected the type definition and autogenerated the conversion
code for you.  As it turns out, we can do just that using Sexplib.
The `sexplib` package, which is included with Core, provides both a
library for manipulating s-expressions and a _syntax extension_ for
generating such conversion functions.  With that syntax extension
enabled, any type that has `with sexp` as an annotation will trigger
the generation of the functions we want.

```frag
((typ ocamltop)(name sexpr/auto_making_sexp.topscript)(part 0))
```

The syntax extension can be used outside of type declarations as well.
As discussed in [xref](#error-handling), `with sexp` can be attached
to the declaration of an exception, which will improve the ability of
Core to generate a useful string representation.

```frag
((typ ocamltop)(name sexpr/auto_making_sexp.topscript)(part 1))
```

You don't always have to declare a named type to create an s-expression
converter.  The following syntax lets you create one inline, as part of a
larger expression.

```frag
((typ ocamltop)(name sexpr/inline_sexp.topscript))
```

The declaration `<:sexp_of<int * string>>` simply gets expanded to the
sexp-converter for the type `int * string`.  This is useful whenever you
need a sexp-converter for an anonymous type.

The syntax extensions bundled with Core almost all have the same basic
structure: they autogenerate code based on type definitions,
implementing functionality that you could in theory have implemented
by hand, but with far less programmer effort.

<note> <title>Syntax extensions, Camlp4 and Type_conv</title>

OCaml doesn't directly support generating code from type definitions.
Instead, it supplies a powerful syntax extension mechanism known as
Camlp4, which lets you extend the grammar of the language.  Camlp4 is
well integrated into the OCaml toolchain, and can be activated within
the toplevel and also included in compilation using the `-pp` compiler
flag.

Sexplib is part of a family of syntax extensions, including
Comparelib, described in [xref](#maps-and-hash-tables), and Fieldslib,
described in [xref](#records), that generate code based on type
declarations, and are all based on a common library called Type_conv.
This library provides a common language for annotating types (_e.g._,
using the `with` notation) and utilities for working with type
definitions.  If you want to build your own type-driven syntax
extension, you should consider basing it on Type_conv.

</note>

## The Sexp format

The textual representation of s-expressions is pretty
straightforward. An s-expression is written down as a nested
parenthetical expression, with whitespace-separated strings as the
atoms.  Quotes are used for atoms that contain parentheses or spaces
themselves; backslash is the escape character; and semicolons are used
to introduce single-line comments.  Thus, the following file,
<filename>example.scm</filename>:

```frag
((typ scheme)(name sexpr/example.scm))
```

can be loaded using Sexplib.  As you can see, the commented data is
not part of the resulting s-expression.

```frag
((typ ocamltop)(name sexpr/example_load.topscript)(part 0))
```

All in, the s-expression format supports three comment syntaxes.

<variablelist><title>S-expression comment formats</title>
  <varlistentry>
    <term>`;`</term>
    <listitem><para>comments out everything to the end of line</para></listitem>
  </varlistentry>
  <varlistentry>
    <term>`#|`</term>
    <term>`|#`</term>
    <listitem><para>delimiters for commenting out a block</para></listitem>
  </varlistentry>
  <varlistentry>
    <term>`#;`</term>
    <listitem><para>comments out the first complete s-expression that follows</para></listitem>
  </varlistentry>
</variablelist>

The following example shows all of these in action.

```frag
((typ scheme)(name sexpr/comment_heavy.scm))
```

Again, loading the file as an s-expression drops the comments.

```frag
((typ ocamltop)(name sexpr/example_load.topscript)(part 1))
```

If we introduce an error into our s-expression, by, say, creating a
file `broken_example.scm` which is `example.scm` without open-paren in
front of `bar`, we'll get a parse error:

```frag
((typ ocamltop)(name sexpr/example_load.topscript)(part 2))
```

In the above, we use `Exn.handle_uncaught` to make sure that the exception gets
printed out in full detail.  You should generally wrap every Core program in
this handler to get good error messages for any unexpected exceptions.

## Preserving invariants

The most important functionality provided by Sexplib is the
auto-generation of converters for new types.  We've seen a bit of how
this works already, but let's walk through a complete example.  Here's
the source for a simple library for representing integer intervals,
very similar to the one described in [xref](#functors).

```frag
((typ ocaml)(name sexpr/int_interval.ml))
```

We can now use this module as follows.

```frag
((typ ocaml)(name sexpr/test_interval.ml))
```

But we're still missing something: we haven't created an `mli` signature for
`Int_interval` yet.  Note that we need to explicitly export the s-expression
converters that were created within the `ml` file.  For example, here's an
interface that doesn't export the s-expression functions.

```frag
((typ ocaml)(name sexpr/int_interval_nosexp.mli))
```

Building this will give us the following error:

```frag
((typ console)(name sexpr/build_test_interval_nosexp.out))
```

We could export the types by hand in the signature, by writing the
signatures for the extra functions generated by Sexplib.

```frag
((typ ocaml)(name sexpr/int_interval_manual_sexp.mli))
```

This isn't an ideal solution, as it makes you repeatedly expose these extra
functions in every signature you create where you want to serialize values.
Sexplib solves this by exposing the same syntax extension in signature
definitions, so that we can just use the same `with` shorthand in the `mli`
file.  Here's the final version of the signature that does just this.

```frag
((typ ocaml)(name sexpr/int_interval.mli))
```

At this point `test_interval.ml` will compile again, and if we run
it, we'll get the following output.

```frag
((typ ocaml)(name sexpr/build_test_interval.out))
```

One easy mistake to make when dealing with sexp converters is to
ignore the fact that those converters can violate the invariants of
your code.  For example, the `Int_interval` module depends for the
correctness of the `is_empty` check on the fact that for any value
`Range (x,y)`, `y` is greater than or equal to `x`.  The `create`
function preserves this invariant, but the `t_of_sexp` function does
not.

We can fix this problem by overriding the autogenerated function and
writing a custom sexp-converter that wraps the autogenerated converter
with whatever invariant checks are necessary.

```frag
((typ ocaml)(name sexpr/sexp_override.ml))
```

This trick of overriding an existing function definition with a new
one is perfectly acceptable in OCaml.  Since `t_of_sexp` is defined
with an ordinary `let` rather than a `let rec`, the call to the
`t_of_sexp` goes to the Sexplib-generated version of the function,
rather than being a recursive call.

Another important aspect of our definition above is that we call the
function `of_sexp_error` to raise an exception when the parsing
process fails.  This improves the error reporting that Sexplib can
provide when a conversion fails, as we'll see in the next section.

## Getting good error messages

There are two steps to deserializing a type from an s-expression:
first, converting the bytes in a file to an s-expression, and the
second, converting that s-expression into the type in question.  One
problem with this is that it can be hard to localize errors to the
right place using this scheme.  Consider the following example:

```frag
((typ ocaml)(name sexpr/read_foo.ml))
```

If you were to run this on a malformatted file, say, this one:

```frag
((typ scheme)(name sexpr/foo_broken_example.scm))
```

you'll get the following error:

```frag
((typ console)(name sexpr/build_read_foo.out))
```

If all you have is the error message and the string, it's not terribly
informative.  In particular, you know that the parsing errored out on
the atom "not-an-integer", but you don't know which one!  In a large
file, this kind of bad error message can be pure misery.

But there's hope!  We can make a small change to the code to improve
the error message greatly.

```frag
((typ ocaml)(name sexpr/read_foo_better_errors.ml))
```

If we run it again, we'll see a much more specific errro.

```frag
((typ console)(name sexpr/build_read_foo_better_errors.out))
```

In the above error,
<computeroutput>foo_broken_example.scm:2:5</computeroutput> tells us
that the error occurred in the file
<computeroutput>"foo_broken_example.scm"</computeroutput> on line 2,
character 5.  This is a much better start for figuring out what went
wrong.  The ability to find the precise location of the error depends
on the sexp converter reporting errors using the function
`of_sexp_error`.  This is already done by converters generated by
Sexplib, but you should make sure to do the same when you write custom
converters.

## Sexp-conversion directives

Sexplib supports a collection of directives for modifying the default
behavior of the autogenerated sexp-converters.  These directives allow
you to customize the way in which types are represented as
s-expressions without having to write a custom converter.

Note that the extra directives aren't part of the standard OCaml
syntax, but are added via the Sexplib syntax extension.  However,
since Sexplib is used throughout Core and is part of the standard
bundle activated by <command>corebuild</command>, you can use these in
your own Core code without any special effort.

### `sexp_opaque`

The most commonly used directive is `sexp_opaque`, whose purpose is to
mark a given component of a type as being unconvertible.  Anything
marked with `sexp_opaque` will be presented as the atom `<opaque>` by
the to-sexp converter, and will trigger an exception from the
from-sexp converter.

Note that the type of a component marked as opaque doesn't need to have a
sexp-converter defined.  Here, if we define a type without a sexp-converter,
and then try to use another type with a sexp-converter, we'll error out:

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 0))
```

But with `sexp_opaque`, we can embed our opaque `no_converter` type within
the other data structure without an error.

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 1))
```

And if we now convert a value of this type to an s-expression, we'll
see the contents of field `a` marked as opaque:

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 2))
```

Note that the `t_of_sexp` function for an opaque type is generated,
but will fail at runtime if it is used.

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 3))
```

This is there to allow for s-expression converters to be created for
types containing `sexp_opaque` values.  This is useful because the
resulting converters won't necessarily fail on all inputs.  For
example, if you have a record containing a `no_converter list`, the
`t_of_sexp` function would still succeed when the list is empty.

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 4))
```

If you really only want to generate one direction of converter, one
can do this by annotating the type with `with sexp_of` or `with
of_sexp` instead of `with sexp`.

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 5))
```

### `sexp_list`

Sometimes, sexp-converters have more parentheses than one would
ideally like.  Consider, for example, the following variant type:

```frag
((typ ocamltop)(name sexpr/sexp_list.topscript)(part 0))
```

You might prefer to make the syntax a bit less parenthesis-laden by dropping
the parentheses around the list.  We can replace the `string list` in the type
declaration with `string sexp_list` to give us this alternate syntax:

```frag
((typ ocamltop)(name sexpr/sexp_list.topscript)(part 1))
```

### `sexp_option`

Another common directive is `sexp_option`, which is used to to make a
record field optional in the s-expression.  Normally, optional values
are represented either as `()` for `None`, or as `(x)` for `Some x`,
and a record field containing an option would be rendered accordingly.
For example:

```frag
((typ ocamltop)(name sexpr/sexp_option.topscript)(part 0))
```

But what if we want a field to be optional, _i.e._, we want to allow
it to be omitted from the record entirely?  In that case, we can mark
it with `sexp_option`:

```frag
((typ ocamltop)(name sexpr/sexp_option.topscript)(part 1))
```

### Specifying defaults

The `sexp_option` declaration is really just an example of specifying
a default behavior for dealing with an unspecified field.  In
particular, `sexp_option` fills in absent fields with `None`.  But you
might want to allow other ways of filling in default values.

Consider the following type which represents the configuration of a
very simple web-server.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 0))
```

One could imagine making some of these parameters optional; in particular, by
default, we might want the web server to bind to port 80, and to listen as
localhost.  We can do this as follows.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 1))
```

Now, if we try to convert an s-expression that specifies only the
`web_root`, we'll see that the other values are filled in with the
desired defaults.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 2))
```

If we convert the configuration back out to an s-expression, you'll
notice that all of the fields are present, even though they're not
strictly necessary.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 3))
```

We could make the generated s-expression also drop exported values, by
using the `sexp_drop_default` directive.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 4))
```

As you can see, the fields that are at their default values are simply
omitted from the s-expression.  On the other hand, if we convert a
config with other values, then those values will be included in the
s-expression.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 5))
```

This can be very useful in designing config file formats that are both
reasonably terse and easy to generate and maintain.  It can also be
useful for backwards compatibility: if you add a new field to your
config record, but you make that field optional, then you should still
be able to parse older version of your config.
