# Data Serialization with S-Expressions

We've already discussed the parsing of third-party data formats like
JSON.  Sometimes, though, you're less concerned with interoperating
with specific file formats, and you instead want an easy to use,
human-readable format that integrates well with OCaml and its
libraries.  Core's solution to this problem is to use s-expressions.

S-expressions are nested parenthetical expressions whose atomic values
are strings.  They were first popularized by the Lisp programming
language in the 1960s, and have remained one of the simplest and most
effective ways to encode structured data.  There's a full definition
of them available [online](http://people.csail.mit.edu/rivest/Sexp.txt).
An example s-expression might look like this.

```frag
((typ scheme)(name sexpr/basic.scm))
```

This chapter will show you how to:

* generate s-expressions from arbitrary OCaml types, thus giving
  you a human-readable format for persisting any values in your code.
* expose s-expressions across module interfaces, including with abstract types.
* generate good error messages for debugging malformed inputs.
* use custom type annotations to control the exact printing behavior for
  s-expression converters.

## Basic Usage

OCaml values aren't directly converted to-and-from strings of s-expressions
when you use Core.  The s-expression is instead built up as an OCaml value
which is later serialized into strings or memory buffers.  The OCaml type of an
s-expression is quite simple.

```frag
((typ ocaml)(name sexpr/sexp.mli))
```

An s-expression can be thought of as a tree where each node contains a list of
its children, and where the leaves of the tree are strings.  Here's how we can
use this type to represent the our example s-expression.

```frag
((typ ocamltop)(name sexpr/manually_making_sexp.topscript))
```

Core provides good support for `s-expressions` in its `Sexp` module,
including functions for converting s-expressions to and from strings.
If we do the same example above with Core's s-expression type, we'll
see that the output in the top-level is easier to read.

```frag
((typ ocamltop)(name sexpr/print_sexp.topscript))
```

This prints out nicely because Core registers a pretty printer with
the toplevel.  This pretty-printer uses Core's functions for
converting s-expressions to and from strings.

```frag
((typ ocamltop)(name sexpr/sexp_printer.topscript))
```

In addition to providing the `Sexp` module, most of the base types in Core
support conversion to and from s-expressions.  For example, we can write:

```frag
((typ ocamltop)(name sexpr/to_from_sexp.topscript))
```

Notice that `List.sexp_of_t` is polymorphic, and takes as its first argument
another conversion function to handle the elements of the list to be converted.
Core uses this scheme more generally for defining sexp-converters for
polymorphic types.

<note>
<title>More on toplevel printing</title>

The values of the s-expressions that we created above were printed properly as
s-expressions in the toplevel, instead of as the tree of `Atom` and `List`
variants that they're actually made of.

This is due to OCaml's facility for installing custom *toplevel printers* that
can rewrite some values into more toplevel-friendly equivalents.  They are
generally installed as `ocamlfind` packages ending in `top`.

```frag
((typ console)(name sexpr/list_top_packages.out))
```

The `core.top` package (which you should have loaded by default in your
`.ocamlinit` file) loads in printers for the Core extensions already, so you
don't need to do anything special to use the Sexplib printer.

</note>

### Generating s-expressions from OCaml types

But what if you want a function to convert some brand new type to an
s-expression?  You can of course write it yourself manually:

```frag
((typ ocamltop)(name sexpr/manually_making_sexp.topscript))
```

This is somewhat tiresome to write, and it gets more so when you consider the
parser, _i.e._, `t_of_sexp`, which is considerably more complex.  Writing this
kind of parsing and printing code by hand is mechanical and error prone, not to
mention a drag.

Given how mechanical the code is, you could imagine writing a program that
inspected the type definition and autogenerated the conversion code for you.
As it turns out, we can do just that using `sexplib`.  The `sexplib` package,
which is included with Core, provides both a library for manipulating
s-expressions and a _syntax extension_ for generating such conversion
functions.  With that syntax extension enabled, any type that has `with sexp`
as an annotation will trigger the generation of the functions we want for free.

```frag
((typ ocamltop)(name sexpr/auto_making_sexp.topscript)(part 0))
```

The `sexplib` syntax extension sees the `with sexp` annotation replaces it with
the definition of the conversions functions we see above.

The syntax extension can be used outside of type declarations as well.  As
discussed in [xref](#error-handling), `with sexp` can be attached to the
declaration of an exception, which will improve the ability of Core to generate
a useful string representation of an exception.

```frag
((typ ocamltop)(name sexpr/auto_making_sexp.topscript)(part 1))
```

You don't always have to declare a named type to create an s-expression
converter.  The following syntax lets you create one inline, as part of a
larger expression.

```frag
((typ ocamltop)(name sexpr/inline_sexp.topscript))
```

The declaration `<:sexp_of<int * string>>` simply gets expanded to the
sexp-converter for the type `int * string`.  This is useful whever you
need a sexp-converter for an anonymous type.

The syntax extensions bundled with Core almost all have the same basic
structure: they autogenerate code based on type definitions,
implementing functionality that you could in theory have implemented
by hand, but with far less programmer effort.

<note> <title>Syntax extensions, `camlp4` and `type_conv`</title>

OCaml doesn't directly support generating code from type definitions.
Instead, it supplies a powerful syntax extension mechanism known as
`camlp4`, which lets you extend the grammar of the language.  In the
case of `sexplib`, `camlp4` is used to create s-expression conversion
functions.  `camlp4` is well integrated into the OCaml toolchain, and
can be activated within the toplevel and also included in compilation
using the `-pp` compiler flag.

`sexplib` is part of a family of syntax extensions, including
`comparelib`, described in [xref](#maps-and-hash-tables), and
`fieldslib`, described in [xref](#records), that generate code based
on type declarations, and are all based on a common library called
`type_conv`.  This library provides a common language for annotating
types (_e.g._, using the `with` notation) and utilities for working
with type definitions.  If you want to build your own type-driven
syntax extension, you should consider basing it on `type_conv`.

</note>

## The Sexp format

The textual representation of s-expressions is pretty
straightforward. An s-expression is written down as a nested
parenthetical expression, with whitespace-separated strings as the
atoms.  Quotes are used for atoms that contain parentheses or spaces
themselves; backslash is the escape character; and semicolons are used
to introduce single-line comments.  Thus, the following file,
`example.scm`:

```frag
((typ scheme)(name sexpr/example.scm))
```

can be loaded using sexplib.  As you can see, the commented data is
not part of the resulting s-expression.

```frag
((typ ocamltop)(name sexpr/example_load.topscript)(part 0))
```

All in, the s-expression format actually supports three comment
syntaxes:

- `;`, which comments out everything to the end of a line
- `#|` and `|#`, which are delimiters for commenting out a block
- `#;`, which comments out the first complete s-expression that follows.

The following example shows all of these in action.

```frag
((typ scheme)(name sexpr/comment_heavy.scm))
```

Again, loading the file as an s-expression drops the comments.

```frag
((typ ocamltop)(name sexpr/example_load.topscript)(part 1))
```

Note that the comments were dropped from the file upon reading.  This is
expected, since there's no place in the `Sexp.t` type to store comments.

If we introduce an error into our s-expression, by, say, creating a
file `broken_example.scm` which is `example.scm` without open-paren in
front of `bar`, we'll get a parse error:

```frag
((typ ocamltop)(name sexpr/example_load.topscript)(part 2))
```

In the above, we use `Exn.handle_uncaught` to make sure that the exception gets
printed out in full detail.  You should generally wrap every Core program in
this handler to get good error messages for any unexpected exceptions.

## Sexp converters

The most important functionality provided by Sexplib is the auto-generation of
converters for new types.  We've seen a bit of how this works already, but
let's walk through a complete example.  Here's the source for the beginning of
a library for representing integer intervals.

```frag
((typ ocaml)(name sexpr/int_interval.ml))
```

We can now use this module as follows.

```frag
((typ ocaml)(name sexpr/test_interval.ml))
```

But we're still missing something: we haven't created an `mli` signature for
`Int_interval` yet.  Note that we need to explicitly export the s-expression
converters that were created within the ml.  For example, here's an interface
that doesn't export the s-expression functions.

```frag
((typ ocaml)(name sexpr/int_interval_nosexp.mli))
```

Building this will give us the following error:

```frag
((typ console)(name sexpr/build_test_interval_nosexp.out))
```

We could export the types by hand in the signature, by writing the
signatures for the extra functions generated by `sexplib`.

```frag
((typ ocaml)(name sexpr/int_interval_manual_sexp.mli))
```

This isn't an ideal solution, as it makes you repeatedly expose these extra
functions in every signature you create where you want to serialize values.
Sexplib solves this by exposing the same syntax extension in signature
definitions, so that we can just use the same `with` shorthand in the `mli`
file.  Here's the final version of the signature that does just this.

```frag
((typ ocaml)(name sexpr/int_interval.mli))
```

At this point `test_interval.ml` will compile again, and if we run
it, we'll get the following output.

```frag
((typ ocaml)(name sexpr/build_test_interval.out))
```

### Preserving invariants

One easy mistake to make when dealing with sexp converters is to
ignore the fact that those converters can violate the invariants of
your code.  For example, the `Int_interval` module depends for the
correctness of the `is_empty` check on the fact that for any value
`Range (x,y)`, `y` is greater than or equal to `x`.  The `create`
function preserves this invariant, but the `t_of_sexp` function does
not.

We can fix this problem by overriding the autogenerated function and
writing a custom sexp-converter that is based on the autogenerated
converter.

```frag
((typ ocaml)(name sexpr/sexp_override.ml))
```

This trick of overriding an existing function definition with a new
one is perfectly acceptable in OCaml.  Function definitions are only
recursive if the `rec` keyword is specified, and so in this case the
inner `t_of_sexp` call will go to the earlier autogenerated definition
that resulted from the `type t with sexp` definition.

We call the function `of_sexp_error` to raise an exception because
that improves the error reporting that Sexplib can provide when a
conversion fails.

### Getting good error messages

There are two steps to deserializing a type from an s-expression:
first, converting the bytes in a file to an s-expression, and the
second, converting that s-expression into the type in question.  One
problem with this is that it can be hard to localize errors to the
right place using this scheme.  Consider the following example:

```frag
((typ ocaml)(name sexpr/read_foo.ml))
```

If you were to run this on a malformatted file, say, this one:

```frag
((typ scheme)(name sexpr/foo_broken_example.scm))
```

you'll get the following error:

```frag
((typ console)(name sexpr/build_read_foo.out))
```

If all you have is the error message and the string, it's not terribly
informative.  In particular, you know that the parsing error-ed out on
the atom "not-an-integer", but you don't know which one!  In a large
file, this kind of bad error message can be pure misery.

But there's hope!  If we make small change to the `run` function as
follows:

```frag
((typ ocaml)(name sexpr/read_foo_better_errors.ml))
```

and run it again, we'll get the following much more helpful error
message:

```frag
((typ console)(name sexpr/build_read_foo_better_errors.out))
```

In the above error, "foo_broken_example.scm:2:5" tells us that the error
occurred on "foo_broken_example.scm", line 2, character 5, which is a much
better start for figuring out what has gone wrong.

## Sexp-conversion directives

Sexplib supports a collection of directives for modifying the default
behavior of the autogenerated sexp-converters.  These directives allow
you to customize the way in which types are represented as
s-expressions without having to write a custom parser.

### `sexp_opaque`

The most commonly used directive is `sexp_opaque`, whose purpose is to
mark a given component of a type as being unconvertible.  Anything
marked with `sexp_opaque` will be presented as the atom `<opaque>` by
the to-sexp converter, and will trigger an exception from the
from-sexp converter.

Note that the type of a component marked as opaque doesn't need to have a
sexp-converter defined.  Here, if we define a type without a sexp-converter,
and then try to use another type with a sexp-converter, we'll error out:

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 0))
```

But with `sexp_opaque`, we won't:

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 1))
```

And if we now convert a value of this type to an s-expression, we'll
see the contents of field `a` marked as opaque:

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 2))
```

Note that the `t_of_sexp` function for an opaque type is generated,
but will fail at runtime if it is used.

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 3))
```

This is there to allow for s-expression converters to be created for
types containing `sexp_opaque` values, and the resulting converters
won't necessarily fail.  For example, if we made the field containing
a `no_converter` a list, the `t_of_sexp` function could still succeed
when that list was empty, as shown below.

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 4))
```

If you really only want to generate one direction of converter, one
can do this by annotating the type with `with sexp_of` or `with
of_sexp`, as shown below.

```frag
((typ ocamltop)(name sexpr/sexp_opaque.topscript)(part 5))
```

### `sexp_list`

Sometimes, sexp-converters have more parentheses than one would
ideally like.  Consider, for example, the following variant type:

```frag
((typ ocamltop)(name sexpr/sexp_list.topscript)(part 0))
```

You might prefer to make the syntax a bit less parenthesis-laden by
dropping the parentheses around the list.  `sexp_list` gives us this
alternate syntax:

```frag
((typ ocamltop)(name sexpr/sexp_list.topscript)(part 1))
```

### `sexp_option`

Another common directive is `sexp_option`, which is used to to make a
record field optional in the s-expression.  Normally, optional values
are represented either as `()` for `None`, or as `(x)` for `Some x`,
and a record field containing an option would be rendered accordingly.
For example:

```frag
((typ ocamltop)(name sexpr/sexp_option.topscript)(part 0))
```

But what if we want a field to be optional, _i.e._, we want to allow
it to be omitted from the record entirely?  In that case, we can mark
it with `sexp_option`:

```frag
((typ ocamltop)(name sexpr/sexp_option.topscript)(part 1))
```

### Specifying defaults

The `sexp_option` declaration is really just an example of how one
might want to deal with default values.  With `sexp_option`, your type
on the OCaml side is an option, with `None` representing the case
where no value is provided.  But you might want to allow other ways of
filling in default values.

Consider the following type which represents the configuration of a
very simple web-server.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 0))
```

One could imagine making some of these parameters optional; in particular, by
default, we might want the web server to bind to port 80, and to listen as
localhost.  The sexp-syntax allows this as follows.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 1))
```

The top-level will echo back the type you just defined as usual, but also
generate the additional conversion functions that let you convert to and from
s-expressions.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 2))
```

When we convert the configuration back out to an s-expression, you'll notice
that no data is dropped.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 3))
```

We could make the generated s-expression also drop exported values, by
using the `sexp_drop_default` directive.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 4))
```

As you can see, the fields that are at their default values are simply
omitted from the s-expression.  On the other hand, if we convert a
config with other values, then those values will be included in the
s-expression.

```frag
((typ ocamltop)(name sexpr/sexp_default.topscript)(part 5))
```

This can be very useful in designing config file formats that are both
reasonably terse and easy to generate and maintain.  It can also be
useful for backwards compatibility: if you add a new field to your
config record, but you make that field optional, then you should still
be able to parse older version of your config.
