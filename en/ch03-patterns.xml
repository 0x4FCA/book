<chapter id="lists-options-and-pattern-matching">
  <title>Lists, Options and Pattern Matching</title>
  <section id="example-pretty-printing-a-table">
    <title>Example: pretty-printing a table</title>
    <para>
      One common programming task is displaying tabular data. In this
      example, will go over the design of a simple library to do just
      that.
    </para>
    <para>
      We'll start with the interface. The code will go in a new module
      called <literal>Text_table</literal> whose <literal>.mli</literal>
      contains just the following function:
    </para>
    <programlisting>
(* [render headers rows] returns a string containing a formatted
   text table, using unix-style newlines as separators *)
val render
   :  string list         (* header *)
   -&gt; string list list    (* data *)
   -&gt; string
</programlisting>
    <para>
      If you invoke <literal>render</literal> as follows:
    </para>
    <programlisting>
let () =
  print_string (Text_table.render
     [&quot;language&quot;;&quot;architect&quot;;&quot;first release&quot;]
     [ [&quot;Lisp&quot; ;&quot;John McCarthy&quot; ;&quot;1958&quot;] ;
       [&quot;C&quot;    ;&quot;Dennis Ritchie&quot;;&quot;1969&quot;] ;
       [&quot;ML&quot;   ;&quot;Robin Milner&quot;  ;&quot;1973&quot;] ;
       [&quot;OCaml&quot;;&quot;Xavier Leroy&quot;  ;&quot;1996&quot;] ;
     ])
</programlisting>
    <para>
      you'll get the following output:
    </para>
    <programlisting>
| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |
</programlisting>
    <para>
      Now that we know what <literal>render</literal> is supposed to do,
      let's dive into the implementation.
    </para>
    <section id="computing-the-widths">
      <title>Computing the widths</title>
      <para>
        To render the rows of the table, we'll first need the width of
        the widest entry in each column. The following function does
        just that.
      </para>
      <programlisting>
let max_widths header rows =
  let to_lengths l = List.map ~f:String.length l in
  List.fold rows
    ~init:(to_lengths header)
    ~f:(fun acc row -&gt;
      List.map2_exn ~f:Int.max acc (to_lengths row))
</programlisting>
      <para>
        In the above we define a helper function,
        <literal>to_lengths</literal> which uses
        <literal>List.map</literal> and <literal>String.length</literal>
        to convert a list of strings to a list of string lengths. Then,
        starting with the lengths of the headers, we use
        <literal>List.fold</literal> to join in the lengths of the
        elements of each row by <literal>max</literal>'ing them together
        elementwise.
      </para>
      <para>
        Note that this code will throw an exception if any of the rows
        has a different number of entries than the header. In
        particular, <literal>List.map2_exn</literal> throws an exception
        when its arguments have mismatched lengths.
      </para>
    </section>
    <section id="rendering-the-rows">
      <title>Rendering the rows</title>
      <para>
        Now we need to write the code to render a single row. There are
        really two different kinds of rows that need to be rendered; an
        ordinary row:
      </para>
      <programlisting>
| Lisp     | John McCarthy  | 1962          |
</programlisting>
      <para>
        and a separator row:
      </para>
      <programlisting>
|----------+----------------+---------------|
</programlisting>
      <para>
        Let's start with the separator row, which we can generate as
        follows:
      </para>
      <programlisting>
let render_separator widths =
  let pieces = List.map widths
    ~f:(fun w -&gt; String.make (w + 2) '-')
  in
  &quot;|&quot; ^ String.concat ~sep:&quot;+&quot; pieces ^ &quot;|&quot;
</programlisting>
      <para>
        We need the extra two-characters for each entry to account for
        the one character of padding on each side of a string in the
        table.
      </para>
      <section id="note-performance-of-string.concat-and">
        <title>Note: Performance of <literal>String.concat</literal> and
        <literal>^</literal></title>
        <blockquote>
          <para>
            In the above, we're using two different ways of
            concatenating strings, <literal>String.concat</literal>,
            which operates on lists of strings, and
            <literal>^</literal>, which is a pairwise operator. You
            should avoid <literal>^</literal> for joining long numbers
            of strings, since, it allocates a new string every time it
            runs. Thus, the following code:
          </para>
          <programlisting>
let s = &quot;.&quot; ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;  ^ &quot;.&quot;
</programlisting>
          <para>
            will allocate a string of length 2, 3, 4, 5, 6 and 7,
            whereas this code:
          </para>
          <programlisting>
let s = String.concat [&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;;&quot;.&quot;]
</programlisting>
          <para>
            allocates one string of size 7, as well as a list of length
            7. At these small sizes, the differences don't amount to
            much, but for assembling of large strings, it can be a
            serious performance issue.
          </para>
        </blockquote>
        <para>
          We can write a very similar piece of code for rendering the
          data in an ordinary row.
        </para>
        <programlisting>
let pad s length =
  if String.length s &gt;= length then s
  else s ^ String.make (length - String.length s) ' '

let render_row row widths =
  let pieces = List.map2 row widths
    ~f:(fun s width -&gt; &quot; &quot; ^ pad s width ^ &quot; &quot;)
  in
  &quot;|&quot; ^ String.concat ~sep:&quot;|&quot; pieces ^ &quot;|&quot;
</programlisting>
        <para>
          You might note that <literal>render_row</literal> and
          <literal>render_separator</literal> share a bit of structure.
          We can improve the code a bit by factoring that repeated
          structure out:
        </para>
        <programlisting>
let decorate_row ~sep row = &quot;|&quot; ^ String.concat ~sep row ^ &quot;|&quot;

let render_row widths row =
  decorate_row ~sep:&quot;|&quot;
    (List.map2_exn row widths ~f:(fun s w -&gt; &quot; &quot; ^ pad s w ^ &quot; &quot;))

let render_separator widths =
  decorate_row ~sep:&quot;+&quot;
    (List.map widths ~f:(fun width -&gt; String.make (width + 2) '-'))
</programlisting>
      </section>
    </section>
    <section id="bringing-it-all-together">
      <title>Bringing it all together</title>
      <para>
        And now we can write the function for rendering a full table.
      </para>
      <programlisting>
let render header rows =
  let widths = max_widths header rows in
  String.concat ~sep:&quot;\n&quot;
    (render_row widths header
     :: render_separator widths
     :: List.map rows ~f:(fun row -&gt; render_row widths row)
    )
</programlisting>
      <para>
        Now, let's think about how you might actually use this interface
        in practice. Usually, when you have data to render in a table,
        that data comes in the form of a list of objects of some sort,
        where you need to extract data from each record for each of the
        columns. So, imagine that you start off with a record type for
        representing information about a given programming language:
      </para>
      <programlisting>
type style =
    Object_oriented | Functional | Imperative | Logic
type prog_lang = { name: string;
                   architect: string;
                   year_released: int;
                   style: style list;
                 }
</programlisting>
      <para>
        If we then wanted to render a table from a list of languages, we
        might write something like this:
      </para>
      <programlisting>
let print_langs langs =
   let headers = [&quot;name&quot;;&quot;architect&quot;;&quot;year released&quot;] in
   let to_row lang =
     [lang.name; lang.architect; Int.to_string lang.year_released ]
   in
   print_string (Text_table.render headers (List.map ~f:to_row langs))
</programlisting>
      <para>
        This is OK, but as you consider more complicated tables with
        more columns, it becomes easier to make the mistake of having a
        mismatch in between <literal>headers</literal> and
        <literal>to_row</literal>. Also, adding, removing and reordering
        columns becomes awkward, because changes need to be made in two
        places.
      </para>
      <para>
        We can improve the table API by adding a type which is a
        first-class representative for a column. We'd add the following
        to the interface of <literal>Text_table</literal>:
      </para>
      <programlisting>
(** An ['a column] is a specification of a column for rending a table
    of values of type ['a] *)
type 'a column

(** [column header to_entry] returns a new column given a header and a
    function for extracting the text entry from the data associated
    with a row *)
val column : string -&gt; ('a -&gt; string) -&gt; 'a column

(** [column_render columns rows] Renders a table with the specified
    columns and rows *)
val column_render :
  'a column list -&gt; 'a list -&gt; string
</programlisting>
      <para>
        Thus, the <literal>column</literal> functions creates a
        <literal>column</literal> from a header string and a function
        for extracting the text for that column associated with a given
        row. Implementing this interface is quite simple:
      </para>
      <programlisting>
type 'a column = string * ('a -&gt; string)
let column header to_string = (header,to_string)

let column_render columns rows =
  let header = List.map columns ~f:fst in
  let rows = List.map rows ~f:(fun row -&gt;
    List.map columns ~f:(fun (_,to_string) -&gt; to_string row))
  in
  render header rows
</programlisting>
      <para>
        And we can rewrite <literal>print_langs</literal> to use this
        new interface as follows.
      </para>
      <programlisting>
let columns =
  [ Text_table.column &quot;Name&quot;      (fun x -&gt; x.name);
    Text_table.column &quot;Architect&quot; (fun x -&gt; x.architect);
    Text_table.column &quot;Year Released&quot;
       (fun x -&gt; Int.to_string x.year_released);
  ]

let print_langs langs =
  print_string (Text_table.column_render columns langs)
</programlisting>
      <para>
        The code is a bit longer, but it's also less error prone. In
        particular, several errors that might be made by the user are
        now ruled out by the type system. For example, it's no longer
        possible for the length of the header and the lengths of the
        rows to be mismatched.
      </para>
      <para>
        The simple column-based interface described here is also a good
        starting for building a richer API. You could for example build
        specialized colums with different formatting and alignment
        rules, which is easier to do with this interface than with the
        original one based on passing in lists-of-lists.
      </para>
    </section>
  </section>
</chapter>
