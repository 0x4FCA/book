# Tuning and Profiling

(_avsm_: all notes and outline so far)

## The OCaml toolchain

Bytecode and native code introduction. Bytecode better for quick development, native code for production.  Mostly have feature parity.

### The `ocamlc` bytecode compiler

The simplest code generator in OCaml is the `ocamlc` compiler, which outputs
portable bytecode that is interpreted via the `ocamlrun` runtime.  The OCaml
bytecode virtual machine is a stack machine (much like the Java Virtual
Machine), with the exception of a single register that stores the more recent
result.  This provides a simple runtime model that is easy to implement, but
executes rather slowly due to being interpreted.

Bytecode is generated by the the `ocamlc` compiler, which generates the following
files:

Extension  Generated By     Purpose 
---------  ------------     -------
.ml        manual/codegen   Source files for compilation unit module implementations.
.mli       manual/codegen   Source files for compilation unit module interfaces. If missing, generated from the `.ml` file.
.cmi       ocamlc           Compiled module interface from a corresponding `.mli` source file.
.cmo       ocamlc           Compiled bytecode object file of the module implementation.
.cma       ocamlc           Library of bytecode object files packed into a single file.
.o         ocamlc           C source files are compiled into native object files by the system `cc`.

### The `ocamlopt` native code compiler

### The `ocaml` top-level loop

## Understanding the Heap

Much of the static type information contained within an OCaml program is
checked and discarded at compile time, leaving a much simpler *runtime*
representation for values.  OCaml adopts a uniform memory representation for
such memory values, and understanding it is important to writing fast
programs.

Every OCaml value starts with a single word (either 32- or 64-bit) that
represents either an unboxed integer or a pointer. If the lowest bit of the
word is non-zero, then the value is an integer.  Several OCaml types map onto
such integers, including `bool`, `int`, the empty list, `unit`, and some
variants.  Integers are the only unboxed runtime values in OCaml, and are thus
cheap to allocate and manipulate.  A `value` containing a pointer is stored
unmodified, and can be followed just like a C pointer.  

Runtime values that are more complex than integers are stored in OCaml *blocks*.
An OCaml block consists of a header word followed by a variable number of data
words.   The header word is broken up as follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~
(TODO draw this properly)
+------------------------+-------+----------+----------+----------+----
| size of block in words |  col  | tag byte | value[0] | value[1] | ...
+------------------------+-------+----------+----------+----------+----
 <-either 22 or 54 bits-> <2 bit> <--8 bit-->
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The size part records the length of the block in words. Note that it is limited
to 22-bits on 32-bit platforms, which is the reason why OCaml strings are
limited to 16MB.  If you need bigger strings, then either switch to a 64-bit
host, or use the `Bigarray` module.  The 2-bit color is used by the garbage
collector to keep track of its scanning, and we will discuss it more later.
The tag byte is more important now, as it encodes the format of the subsequent
words.

(_avsm_: pointers to blocks actually point 4/8 bytes into it, for some efficiency
reason that I cannot recall right now).

(_avsm_: is the string padding trick to guarantee nul-termination worth mentioning
here? it seems more on topic for the C interface section)

<note>
<title>Why are OCaml integers missing a bit?</title>

Since the lowest bit of an OCaml value is reserved, native OCaml integers have
a maximum allowable length of 31- or 63-bits, depending on the host
architecture. The rationale for reserving the lowest bit is for efficiency.
Pointers always point to word-aligned addresses, and so their lower bits are
normally zero. By setting the lower bit to a non-zero value for integers, the
garbage collector can simply iterate over every header tag to distinguish
integers from pointers.  This reduces the garbage collection overhead on the
overall program.

</note>


## Tuning the Garbage Collector
